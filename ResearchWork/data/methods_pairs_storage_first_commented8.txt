1806
#method_before
@Override
public CloseableHttpClient get() {
    return HttpClients.custom().setConnectionManager(mgr.get()).setDefaultRequestConfig(customRequestConfig()).setServiceUnavailableRetryStrategy(customServiceUnavailRetryStrategy()).build();
}
#method_after
@Override
public CloseableHttpClient get() {
    return HttpClients.custom().setConnectionManager(create(socketMgr.get())).setDefaultRequestConfig(customRequestConfig()).setServiceUnavailableRetryStrategy(customServiceUnavailRetryStrategy()).build();
}
#end_block

#method_before
@Override
public void run() {
    try {
        Optional<EventProcessor.Request> content = processor.get();
        if (!content.isPresent()) {
            log.debug("No content. Webhook [{}] skipped.", remote.getUrl());
            return;
        }
        execCnt++;
        HttpResult result = session.get().post(remote.getUrl(), content.get().headers, remote, content.get().body);
        if (!result.successful && execCnt < remote.getMaxTries()) {
            logRetry(result.message);
            reschedule();
        }
    } catch (IOException e) {
        if (isRecoverable(e) && execCnt < remote.getMaxTries()) {
            logRetry(e);
            reschedule();
        } else {
            log.error("Failed to post: {}", toString(), e);
        }
    }
}
#method_after
@Override
public void run() {
    try {
        Optional<EventProcessor.Request> content = processor.get();
        if (!content.isPresent()) {
            log.debug("No content. Webhook [{}] skipped.", remote.getUrl());
            return;
        }
        execCnt++;
        HttpResult result = session.get().post(remote, content.get());
        if (!result.successful && execCnt < remote.getMaxTries()) {
            logRetry(result.message);
            reschedule();
        }
    } catch (IOException e) {
        if (isRecoverable(e) && execCnt < remote.getMaxTries()) {
            logRetry(e);
            reschedule();
        } else {
            log.error("Failed to post: {}", toString(), e);
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ScheduledExecutorService.class).annotatedWith(WebHooksExecutor.class).toProvider(ExecutorProvider.class);
    factory(PostTask.Factory.class);
    factory(RemoteConfig.Factory.class);
    factory(HttpClientConnectionManagerProvider.Factory.class);
    factory(HttpSession.Factory.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventHandler.class);
    bind(CloseableHttpClient.class).annotatedWith(Names.named(DEFAULT)).toProvider(DefaultHttpClientProvider.class).in(Scopes.SINGLETON);
    bind(CloseableHttpClient.class).annotatedWith(Names.named(SSL_VERIFY)).toProvider(SslVerifyingHttpClientProvider.class).in(Scopes.SINGLETON);
    bind(HttpClientConfigurator.class).in(Scopes.SINGLETON);
    install(processors);
}
#method_after
@Override
protected void configure() {
    bind(ScheduledExecutorService.class).annotatedWith(WebHooksExecutor.class).toProvider(ExecutorProvider.class).in(Scopes.SINGLETON);
    factory(PostTask.Factory.class);
    factory(RemoteConfig.Factory.class);
    factory(HttpSession.Factory.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventHandler.class);
    bind(CloseableHttpClient.class).annotatedWith(Names.named(DEFAULT)).toProvider(DefaultHttpClientProvider.class).in(Scopes.SINGLETON);
    bind(CloseableHttpClient.class).annotatedWith(Names.named(SSL_VERIFY)).toProvider(SslVerifyingHttpClientProvider.class).in(Scopes.SINGLETON);
    install(processors);
}
#end_block

#method_before
@Before
public void setup() {
    when(remote.getRetryInterval()).thenReturn(RETRY_INTERVAL);
    when(remote.getMaxTries()).thenReturn(MAX_TRIES);
    when(remote.getUrl()).thenReturn(WEBHOOK_URL);
    when(processor.process(eq(projectCreated), eq(remote))).thenReturn(CONTENT);
    when(sessionFactory.create(eq(remote))).thenReturn(session);
    task = new PostTask(executor, sessionFactory, processor, projectCreated, remote);
}
#method_after
@Before
public void setup() {
    when(remote.getRetryInterval()).thenReturn(RETRY_INTERVAL);
    when(remote.getMaxTries()).thenReturn(MAX_TRIES);
    when(remote.getUrl()).thenReturn(WEBHOOK_URL);
    when(processor.process(eq(projectCreated), eq(remote))).thenReturn(Optional.of(content));
    when(sessionFactory.create(eq(remote))).thenReturn(session);
    task = new PostTask(executor, sessionFactory, processor, projectCreated, remote);
}
#end_block

#method_before
@Test
public void noRescheduleOnSuccess() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, remote, BODY)).thenReturn(OK_RESULT);
    task.run();
    verifyZeroInteractions(executor);
}
#method_after
@Test
public void noRescheduleOnSuccess() throws IOException {
    when(session.post(eq(remote), eq(content))).thenReturn(OK_RESULT);
    task.run();
    verifyZeroInteractions(executor);
}
#end_block

#method_before
@Test
public void noRescheduleOnNonRecoverableException() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, remote, BODY)).thenThrow(SSLException.class);
    task.run();
    verifyZeroInteractions(executor);
}
#method_after
@Test
public void noRescheduleOnNonRecoverableException() throws IOException {
    when(session.post(eq(remote), eq(content))).thenThrow(SSLException.class);
    task.run();
    verifyZeroInteractions(executor);
}
#end_block

#method_before
@Test
public void rescheduleOnError() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, remote, BODY)).thenReturn(ERR_RESULT);
    task.run();
    verify(executor, times(1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#method_after
@Test
public void rescheduleOnError() throws IOException {
    when(session.post(eq(remote), eq(content))).thenReturn(ERR_RESULT);
    task.run();
    verify(executor, times(1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Test
public void rescheduleOnRecoverableException() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, remote, BODY)).thenThrow(IOException.class);
    task.run();
    verify(executor, times(1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#method_after
@Test
public void rescheduleOnRecoverableException() throws IOException {
    when(session.post(eq(remote), eq(content))).thenThrow(IOException.class);
    task.run();
    verify(executor, times(1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Test
public void keepReschedulingMaxTriesTimes() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, remote, BODY)).thenThrow(IOException.class);
    when(executor.schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS)).then(new Answer<Void>() {

        @Override
        public Void answer(InvocationOnMock invocation) throws Throwable {
            task.run();
            return null;
        }
    });
    task.run();
    verify(executor, times(MAX_TRIES - 1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#method_after
@Test
public void keepReschedulingMaxTriesTimes() throws IOException {
    when(session.post(eq(remote), eq(content))).thenThrow(IOException.class);
    when(executor.schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS)).then(new Answer<Void>() {

        @Override
        public Void answer(InvocationOnMock invocation) throws Throwable {
            task.run();
            return null;
        }
    });
    task.run();
    verify(executor, times(MAX_TRIES - 1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
HttpResult post(String endpoint, Map<String, String> headers, RemoteConfig remote, String content) throws IOException {
    HttpPost post = new HttpPost(endpoint);
    post.addHeader("Content-Type", MediaType.JSON_UTF_8.toString());
    post.setConfig(getConfig(remote));
    headers.entrySet().stream().forEach(e -> {
        post.addHeader(e.getKey(), e.getValue());
    });
    post.setEntity(new StringEntity(content, StandardCharsets.UTF_8));
    return httpClient.execute(post, new HttpResponseHandler());
}
#method_after
HttpResult post(RemoteConfig remote, EventProcessor.Request request) throws IOException {
    HttpPost post = new HttpPost(remote.getUrl());
    post.addHeader("Content-Type", MediaType.JSON_UTF_8.toString());
    post.setConfig(getConfig(remote));
    request.headers.entrySet().stream().forEach(e -> {
        post.addHeader(e.getKey(), e.getValue());
    });
    post.setEntity(new StringEntity(request.body, StandardCharsets.UTF_8));
    return httpClient.execute(post, new HttpResponseHandler());
}
#end_block

#method_before
@Override
public void run() {
    log.info("Running account deactivations");
    try {
        int numberOfAccountsDeactivated = 0;
        for (AccountState acc : accountQueryProvider.get().query(AccountPredicates.isActive())) {
            log.debug("processing account " + acc.getUserName());
            if (acc.getUserName() != null && !realm.isActive(acc.getUserName())) {
                try {
                    sif.deactivate(acc.getAccount().getId());
                } catch (Exception e) {
                    log.error("Error deactivating account: {} ({}) {}", acc.getUserName(), acc.getAccount().getId(), e.getMessage(), e);
                }
                log.info("deactivated account " + acc.getUserName());
                numberOfAccountsDeactivated++;
            }
        }
        log.info("Deactivations complete, {} account(s) were deactivated", numberOfAccountsDeactivated);
    } catch (Exception e) {
        log.error("Failed to deactivate inactive accounts " + e.getMessage(), e);
    }
}
#method_after
@Override
public void run() {
    log.info("Running account deactivations");
    try {
        int numberOfAccountsDeactivated = 0;
        for (AccountState acc : accountQueryProvider.get().query(AccountPredicates.isActive())) {
            if (processAccount(acc)) {
                numberOfAccountsDeactivated++;
            }
        }
        log.info("Deactivations complete, {} account(s) were deactivated", numberOfAccountsDeactivated);
    } catch (Exception e) {
        log.error("Failed to complete deactivation of accounts: " + e.getMessage(), e);
    }
}
#end_block

#method_before
private boolean isFullMatch(Account.Id id, String nameOrEmail) {
    AccountState account = byId.get(id);
    Optional<Boolean> matchingName = Optional.ofNullable(account.getAccount().getFullName()).map(n -> n.trim().equalsIgnoreCase(nameOrEmail)).filter(t -> t);
    return matchingName.orElse(account.getExternalIds().stream().anyMatch(extId -> Optional.ofNullable(extId.email()).map(mail -> mail.equalsIgnoreCase(nameOrEmail)).orElse(getSchemeRest(extId.key().scheme(), extId.key().get()).trim().equalsIgnoreCase(nameOrEmail))));
}
#method_after
private boolean isFullMatch(Account.Id id, String nameOrEmail) {
    AccountState account = byId.get(id);
    return isFullNameMatch(account, nameOrEmail) || account.getExternalIds().stream().anyMatch(eid -> isEMailMatch(eid, nameOrEmail) || isUsernameMatch(eid, nameOrEmail));
}
#end_block

#method_before
@Test
public void combineWithBatchGroupNameNotes() throws Exception {
    AccountGroup g1 = newGroup("a");
    AccountGroup g2 = newGroup("b");
    GroupBundle b1 = builder().group(g1).build();
    GroupBundle b2 = builder().group(g2).build();
    BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate();
    rebuilder.rebuild(repo, b1, bru);
    rebuilder.rebuild(repo, b2, bru);
    try (ObjectInserter inserter = repo.newObjectInserter()) {
        BatchGroupNameNotes.updateGroupNames(repo, inserter, bru, ImmutableList.of(g1, g2), newPersonIdent());
        inserter.flush();
    }
    assertThat(log(g1)).isEmpty();
    assertThat(log(g2)).isEmpty();
    assertThat(logGroupNames()).isEmpty();
    RefUpdateUtil.executeChecked(bru, repo);
    assertThat(log(g1)).hasSize(1);
    assertThat(log(g2)).hasSize(1);
    assertThat(logGroupNames()).hasSize(1);
    assertThat(reload(g1)).isEqualTo(b1.toInternalGroup());
    assertThat(reload(g2)).isEqualTo(b2.toInternalGroup());
    assertThat(BatchGroupNameNotes.readNamesByUuid(repo)).containsExactly(g1.getGroupUUID(), "a", g2.getGroupUUID(), "b");
}
#method_after
@Test
public void combineWithBatchGroupNameNotes() throws Exception {
    AccountGroup g1 = newGroup("a");
    AccountGroup g2 = newGroup("b");
    GroupBundle b1 = builder().group(g1).build();
    GroupBundle b2 = builder().group(g2).build();
    BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate();
    rebuilder.rebuild(repo, b1, bru);
    rebuilder.rebuild(repo, b2, bru);
    try (ObjectInserter inserter = repo.newObjectInserter()) {
        ImmutableList<GroupReference> refs = ImmutableList.of(GroupReference.forGroup(g1), GroupReference.forGroup(g2));
        GroupNameNotes.updateGroupNames(repo, inserter, bru, refs, newPersonIdent());
        inserter.flush();
    }
    assertThat(log(g1)).isEmpty();
    assertThat(log(g2)).isEmpty();
    assertThat(logGroupNames()).isEmpty();
    RefUpdateUtil.executeChecked(bru, repo);
    assertThat(log(g1)).hasSize(1);
    assertThat(log(g2)).hasSize(1);
    assertThat(logGroupNames()).hasSize(1);
    assertThat(reload(g1)).isEqualTo(b1.toInternalGroup());
    assertThat(reload(g2)).isEqualTo(b2.toInternalGroup());
    assertThat(GroupTestUtil.readNameToUuidMap(repo)).containsExactly("a", "a-1", "b", "b-2");
}
#end_block

#method_before
private InternalGroup reload(AccountGroup g) throws Exception {
    return GroupConfig.loadForGroup(repo, g.getGroupUUID()).getLoadedGroup().get();
}
#method_after
private InternalGroup reload(AccountGroup g) throws Exception {
    return removeRefState(GroupConfig.loadForGroup(repo, g.getGroupUUID()).getLoadedGroup().get());
}
#end_block

#method_before
private ImmutableList<CommitInfo> log(AccountGroup g) throws Exception {
    return log(RefNames.refsGroups(g.getGroupUUID()));
}
#method_after
private ImmutableList<CommitInfo> log(AccountGroup g) throws Exception {
    return GroupTestUtil.log(repo, RefNames.refsGroups(g.getGroupUUID()));
}
#end_block

#method_before
private ImmutableList<CommitInfo> logGroupNames() throws Exception {
    return log(RefNames.REFS_GROUPNAMES);
}
#method_after
private ImmutableList<CommitInfo> logGroupNames() throws Exception {
    return GroupTestUtil.log(repo, REFS_GROUPNAMES);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
static ObjectId getNoteKey(AccountGroup.NameKey groupName) {
    return ObjectId.fromRaw(Hashing.sha1().hashString(groupName.get(), UTF_8).asBytes());
}
#method_after
@SuppressWarnings("deprecation")
@VisibleForTesting
static ObjectId getNoteKey(AccountGroup.NameKey groupName) {
    return ObjectId.fromRaw(Hashing.sha1().hashString(groupName.get(), UTF_8).asBytes());
}
#end_block

#method_before
static String getAsNoteData(AccountGroup.UUID uuid, AccountGroup.NameKey groupName) {
    Config config = new Config();
    config.setString(SECTION_NAME, null, UUID_PARAM, uuid.get());
    config.setString(SECTION_NAME, null, NAME_PARAM, groupName.get());
    return config.toText();
}
#method_after
private static String getAsNoteData(AccountGroup.UUID uuid, AccountGroup.NameKey groupName) {
    Config config = new Config();
    config.setString(SECTION_NAME, null, UUID_PARAM, uuid.get());
    config.setString(SECTION_NAME, null, NAME_PARAM, groupName.get());
    return config.toText();
}
#end_block

#method_before
static GroupReference getGroupReference(ObjectReader reader, ObjectId noteDataBlobId) throws IOException, ConfigInvalidException {
    byte[] noteData = reader.open(noteDataBlobId, OBJ_BLOB).getCachedBytes();
    return getFromNoteData(noteData);
}
#method_after
@VisibleForTesting
public static GroupReference getGroupReference(ObjectReader reader, ObjectId noteDataBlobId) throws IOException, ConfigInvalidException {
    byte[] noteData = reader.open(noteDataBlobId, OBJ_BLOB).getCachedBytes();
    return getFromNoteData(noteData);
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    Pattern fileRegex = getRegexParameter(a1);
    Pattern editRegex = getRegexParameter(a2);
    PatchList pl = StoredValues.PATCH_LIST.get(engine);
    Repository repo = StoredValues.REPOSITORY.get(engine);
    try (ObjectReader reader = repo.newObjectReader();
        RevWalk rw = new RevWalk(reader)) {
        final RevTree aTree;
        final RevTree bTree;
        final RevCommit bCommit = rw.parseCommit(pl.getNewId());
        if (pl.getOldId() != null) {
            aTree = rw.parseTree(pl.getOldId());
        } else {
            // web UI returns no files to match against, just fail.
            return engine.fail();
        }
        bTree = bCommit.getTree();
        for (PatchListEntry entry : pl.getPatches()) {
            String newName = entry.getNewName();
            String oldName = entry.getOldName();
            if (newName.equals("/COMMIT_MSG")) {
                continue;
            }
            if (fileRegex.matcher(newName).find() || (oldName != null && fileRegex.matcher(oldName).find())) {
                List<Edit> edits = (List<Edit>) entry.getEdits();
                if (edits.isEmpty()) {
                    continue;
                }
                Text tA;
                if (oldName != null) {
                    tA = load(aTree, oldName, reader);
                } else {
                    tA = load(aTree, newName, reader);
                }
                Text tB = load(bTree, newName, reader);
                for (Edit edit : edits) {
                    if (tA != Text.EMPTY) {
                        String aDiff = tA.getString(edit.getBeginA(), edit.getEndA(), true);
                        if (editRegex.matcher(aDiff).find()) {
                            return cont;
                        }
                    }
                    if (tB != Text.EMPTY) {
                        String bDiff = tB.getString(edit.getBeginB(), edit.getEndB(), true);
                        if (editRegex.matcher(bDiff).find()) {
                            return cont;
                        }
                    }
                }
            }
        }
    } catch (IOException err) {
        throw new JavaException(this, 1, err);
    }
    return engine.fail();
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    Term a2 = arg2.dereference();
    Pattern fileRegex = getRegexParameter(a1);
    Pattern editRegex = getRegexParameter(a2);
    PatchList pl = StoredValues.PATCH_LIST.get(engine);
    Repository repo = StoredValues.REPOSITORY.get(engine);
    try (ObjectReader reader = repo.newObjectReader();
        RevWalk rw = new RevWalk(reader)) {
        final RevTree aTree;
        final RevTree bTree;
        final RevCommit bCommit = rw.parseCommit(pl.getNewId());
        if (pl.getOldId() != null) {
            aTree = rw.parseTree(pl.getOldId());
        } else {
            // web UI returns no files to match against, just fail.
            return engine.fail();
        }
        bTree = bCommit.getTree();
        for (PatchListEntry entry : pl.getPatches()) {
            String newName = entry.getNewName();
            String oldName = entry.getOldName();
            if (newName.equals("/COMMIT_MSG")) {
                continue;
            }
            if (fileRegex.matcher(newName).find() || (oldName != null && fileRegex.matcher(oldName).find())) {
                // This cast still seems to be needed on JDK 8 as workaround for:
                // https://bugs.openjdk.java.net/browse/JDK-8039214
                List<Edit> edits = (List<Edit>) entry.getEdits();
                if (edits.isEmpty()) {
                    continue;
                }
                Text tA;
                if (oldName != null) {
                    tA = load(aTree, oldName, reader);
                } else {
                    tA = load(aTree, newName, reader);
                }
                Text tB = load(bTree, newName, reader);
                for (Edit edit : edits) {
                    if (tA != Text.EMPTY) {
                        String aDiff = tA.getString(edit.getBeginA(), edit.getEndA(), true);
                        if (editRegex.matcher(aDiff).find()) {
                            return cont;
                        }
                    }
                    if (tB != Text.EMPTY) {
                        String bDiff = tB.getString(edit.getBeginB(), edit.getEndB(), true);
                        if (editRegex.matcher(bDiff).find()) {
                            return cont;
                        }
                    }
                }
            }
        }
    } catch (IOException err) {
        throw new JavaException(this, 1, err);
    }
    return engine.fail();
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Plugin module needs to be inserted *before* the index module.
    // There is the concept of LifecycleModule, in Gerrit's own extension
    // to Guice, which has these:
    // listener().to(SomeClassImplementingLifecycleListener.class);
    // and the start() methods of each such listener are executed in the
    // order they are declared.
    // Makes sure that PluginLoader.start() is executed before the
    // LuceneIndexModule.start() so that plugins get loaded and the respective
    // Guice modules installed so that the on-line reindexing will happen
    // with the proper classes (e.g. group backends, custom Prolog
    // predicates) and the associated rules ready to be evaluated.
    modules.add(new PluginModule());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(inMemoryTest ? new InMemoryAccountPatchReviewStore.Module() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new com.google.gerrit.server.api.Module());
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (inMemoryTest) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new AccountDeactivator.Module());
        modules.add(new ChangeCleanupRunner.Module());
    }
    modules.addAll(LibModuleLoader.loadModules(cfgInjector));
    if (migrateToNoteDb()) {
        modules.add(new OnlineNoteDbMigrator.Module(trial));
    }
    if (testSysModule != null) {
        modules.add(testSysModule);
    }
    modules.add(new LocalMergeSuperSetComputation.Module());
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Plugin module needs to be inserted *before* the index module.
    // There is the concept of LifecycleModule, in Gerrit's own extension
    // to Guice, which has these:
    // listener().to(SomeClassImplementingLifecycleListener.class);
    // and the start() methods of each such listener are executed in the
    // order they are declared.
    // Makes sure that PluginLoader.start() is executed before the
    // LuceneIndexModule.start() so that plugins get loaded and the respective
    // Guice modules installed so that the on-line reindexing will happen
    // with the proper classes (e.g. group backends, custom Prolog
    // predicates) and the associated rules ready to be evaluated.
    modules.add(new PluginModule());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(inMemoryTest ? new InMemoryAccountPatchReviewStore.Module() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new GerritApiModule());
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (inMemoryTest) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new AccountDeactivator.Module());
        modules.add(new ChangeCleanupRunner.Module());
    }
    modules.addAll(LibModuleLoader.loadModules(cfgInjector));
    if (migrateToNoteDb()) {
        modules.add(new OnlineNoteDbMigrator.Module(trial));
    }
    if (testSysModule != null) {
        modules.add(testSysModule);
    }
    modules.add(new LocalMergeSuperSetComputation.Module());
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
protected void configure() {
    // Do NOT bind @RemotePeer, as it is bound in a child injector of
    // ChangeMergeQueue (bound via GerritGlobalModule below), so there cannot be
    // a binding in the parent injector. If you need @RemotePeer, you must bind
    // it in a child injector of the one containing InMemoryModule. But unless
    // you really need to test something request-scoped, you likely don't
    // actually need it.
    // For simplicity, don't create child injectors, just use this one to get a
    // few required modules.
    Injector cfgInjector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
        }
    });
    bind(MetricMaker.class).to(DisabledMetricMaker.class);
    install(cfgInjector.getInstance(GerritGlobalModule.class));
    install(new com.google.gerrit.server.api.Module());
    install(new DefaultPermissionBackendModule());
    install(new SearchingChangeCacheImpl.Module());
    factory(GarbageCollection.Factory.class);
    bindScope(RequestScoped.class, PerThreadRequestScope.REQUEST);
    // TODO(dborowitz): Use jimfs.
    bind(Path.class).annotatedWith(SitePath.class).toInstance(Paths.get("."));
    bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
    bind(GerritOptions.class).toInstance(new GerritOptions(cfg, false, false, false));
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
    bind(String.class).annotatedWith(GerritServerId.class).toInstance("gerrit");
    bind(AllProjectsName.class).toProvider(AllProjectsNameProvider.class);
    bind(AllUsersName.class).toProvider(AllUsersNameProvider.class);
    bind(GitRepositoryManager.class).to(InMemoryRepositoryManager.class);
    bind(InMemoryRepositoryManager.class).in(SINGLETON);
    bind(TrackingFooters.class).toProvider(TrackingFootersProvider.class).in(SINGLETON);
    bind(MutableNotesMigration.class).toInstance(notesMigration);
    bind(NotesMigration.class).to(MutableNotesMigration.class);
    bind(ListeningExecutorService.class).annotatedWith(ChangeUpdateExecutor.class).toInstance(MoreExecutors.newDirectExecutorService());
    bind(DataSourceType.class).to(InMemoryH2Type.class);
    bind(ChangeBundleReader.class).to(GwtormChangeBundleReader.class);
    bind(SecureStore.class).to(DefaultSecureStore.class);
    TypeLiteral<SchemaFactory<ReviewDb>> schemaFactory = new TypeLiteral<SchemaFactory<ReviewDb>>() {
    };
    bind(schemaFactory).to(NotesMigrationSchemaFactory.class);
    bind(Key.get(schemaFactory, ReviewDbFactory.class)).to(InMemoryDatabase.class);
    install(NoSshKeyCache.module());
    install(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    // Replacement of DiffExecutorModule to not use thread pool in the tests
    install(new AbstractModule() {

        @Override
        protected void configure() {
        }

        @Provides
        @Singleton
        @DiffExecutor
        public ExecutorService createDiffExecutor() {
            return MoreExecutors.newDirectExecutorService();
        }
    });
    install(new DefaultCacheFactory.Module());
    install(new FakeEmailSender.Module());
    install(new SignedTokenEmailTokenVerifier.Module());
    install(new GpgModule(cfg));
    install(new InMemoryAccountPatchReviewStore.Module());
    install(new LocalMergeSuperSetComputation.Module());
    bind(AllAccountsIndexer.class).toProvider(Providers.of(null));
    bind(AllChangesIndexer.class).toProvider(Providers.of(null));
    bind(AllGroupsIndexer.class).toProvider(Providers.of(null));
    IndexType indexType = null;
    try {
        indexType = cfg.getEnum("index", null, "type", IndexType.LUCENE);
    } catch (IllegalArgumentException e) {
    // Custom index type, caller must provide their own module.
    }
    if (indexType != null) {
        switch(indexType) {
            case LUCENE:
                install(luceneIndexModule());
                break;
            case ELASTICSEARCH:
                install(elasticIndexModule());
                break;
            default:
                throw new ProvisionException("index type unsupported in tests: " + indexType);
        }
    }
    bind(ServerInformationImpl.class);
    bind(ServerInformation.class).to(ServerInformationImpl.class);
    install(new PluginRestApiModule());
    install(new DefaultProjectNameLockManager.Module());
}
#method_after
@Override
protected void configure() {
    // Do NOT bind @RemotePeer, as it is bound in a child injector of
    // ChangeMergeQueue (bound via GerritGlobalModule below), so there cannot be
    // a binding in the parent injector. If you need @RemotePeer, you must bind
    // it in a child injector of the one containing InMemoryModule. But unless
    // you really need to test something request-scoped, you likely don't
    // actually need it.
    // For simplicity, don't create child injectors, just use this one to get a
    // few required modules.
    Injector cfgInjector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
        }
    });
    bind(MetricMaker.class).to(DisabledMetricMaker.class);
    install(cfgInjector.getInstance(GerritGlobalModule.class));
    install(new GerritApiModule());
    install(new DefaultPermissionBackendModule());
    install(new SearchingChangeCacheImpl.Module());
    factory(GarbageCollection.Factory.class);
    bindScope(RequestScoped.class, PerThreadRequestScope.REQUEST);
    // TODO(dborowitz): Use jimfs.
    bind(Path.class).annotatedWith(SitePath.class).toInstance(Paths.get("."));
    bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
    bind(GerritOptions.class).toInstance(new GerritOptions(cfg, false, false, false));
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
    bind(String.class).annotatedWith(GerritServerId.class).toInstance("gerrit");
    bind(AllProjectsName.class).toProvider(AllProjectsNameProvider.class);
    bind(AllUsersName.class).toProvider(AllUsersNameProvider.class);
    bind(GitRepositoryManager.class).to(InMemoryRepositoryManager.class);
    bind(InMemoryRepositoryManager.class).in(SINGLETON);
    bind(TrackingFooters.class).toProvider(TrackingFootersProvider.class).in(SINGLETON);
    bind(MutableNotesMigration.class).toInstance(notesMigration);
    bind(NotesMigration.class).to(MutableNotesMigration.class);
    bind(ListeningExecutorService.class).annotatedWith(ChangeUpdateExecutor.class).toInstance(MoreExecutors.newDirectExecutorService());
    bind(DataSourceType.class).to(InMemoryH2Type.class);
    bind(ChangeBundleReader.class).to(GwtormChangeBundleReader.class);
    bind(SecureStore.class).to(DefaultSecureStore.class);
    TypeLiteral<SchemaFactory<ReviewDb>> schemaFactory = new TypeLiteral<SchemaFactory<ReviewDb>>() {
    };
    bind(schemaFactory).to(NotesMigrationSchemaFactory.class);
    bind(Key.get(schemaFactory, ReviewDbFactory.class)).to(InMemoryDatabase.class);
    install(NoSshKeyCache.module());
    install(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    // Replacement of DiffExecutorModule to not use thread pool in the tests
    install(new AbstractModule() {

        @Override
        protected void configure() {
        }

        @Provides
        @Singleton
        @DiffExecutor
        public ExecutorService createDiffExecutor() {
            return MoreExecutors.newDirectExecutorService();
        }
    });
    install(new DefaultCacheFactory.Module());
    install(new FakeEmailSender.Module());
    install(new SignedTokenEmailTokenVerifier.Module());
    install(new GpgModule(cfg));
    install(new InMemoryAccountPatchReviewStore.Module());
    install(new LocalMergeSuperSetComputation.Module());
    bind(AllAccountsIndexer.class).toProvider(Providers.of(null));
    bind(AllChangesIndexer.class).toProvider(Providers.of(null));
    bind(AllGroupsIndexer.class).toProvider(Providers.of(null));
    IndexType indexType = null;
    try {
        indexType = cfg.getEnum("index", null, "type", IndexType.LUCENE);
    } catch (IllegalArgumentException e) {
    // Custom index type, caller must provide their own module.
    }
    if (indexType != null) {
        switch(indexType) {
            case LUCENE:
                install(luceneIndexModule());
                break;
            case ELASTICSEARCH:
                install(elasticIndexModule());
                break;
            default:
                throw new ProvisionException("index type unsupported in tests: " + indexType);
        }
    }
    bind(ServerInformationImpl.class);
    bind(ServerInformation.class).to(ServerInformationImpl.class);
    install(new PluginRestApiModule());
    install(new DefaultProjectNameLockManager.Module());
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    modules.add(new EventBroker.Module());
    modules.add(new JdbcAccountPatchReviewStore.Module(config));
    modules.add(cfgInjector.getInstance(GitRepositoryManagerModule.class));
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new com.google.gerrit.server.api.Module());
    modules.add(new SearchingChangeCacheImpl.Module());
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new LocalMergeSuperSetComputation.Module());
    // Plugin module needs to be inserted *before* the index module.
    // There is the concept of LifecycleModule, in Gerrit's own extension
    // to Guice, which has these:
    // listener().to(SomeClassImplementingLifecycleListener.class);
    // and the start() methods of each such listener are executed in the
    // order they are declared.
    // Makes sure that PluginLoader.start() is executed before the
    // LuceneIndexModule.start() so that plugins get loaded and the respective
    // Guice modules installed so that the on-line reindexing will happen
    // with the proper classes (e.g. group backends, custom Prolog
    // predicates) and the associated rules ready to be evaluated.
    modules.add(new PluginModule());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, false, false, false));
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    modules.add(new AccountDeactivator.Module());
    modules.addAll(LibModuleLoader.loadModules(cfgInjector));
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    modules.add(new EventBroker.Module());
    modules.add(new JdbcAccountPatchReviewStore.Module(config));
    modules.add(cfgInjector.getInstance(GitRepositoryManagerModule.class));
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new GerritApiModule());
    modules.add(new SearchingChangeCacheImpl.Module());
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new LocalMergeSuperSetComputation.Module());
    // Plugin module needs to be inserted *before* the index module.
    // There is the concept of LifecycleModule, in Gerrit's own extension
    // to Guice, which has these:
    // listener().to(SomeClassImplementingLifecycleListener.class);
    // and the start() methods of each such listener are executed in the
    // order they are declared.
    // Makes sure that PluginLoader.start() is executed before the
    // LuceneIndexModule.start() so that plugins get loaded and the respective
    // Guice modules installed so that the on-line reindexing will happen
    // with the proper classes (e.g. group backends, custom Prolog
    // predicates) and the associated rules ready to be evaluated.
    modules.add(new PluginModule());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, false, false, false));
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    modules.add(new AccountDeactivator.Module());
    modules.addAll(LibModuleLoader.loadModules(cfgInjector));
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private PersonIdent getServerIdent(Map<Key, Collection<Event>> events) {
    Key lastKey = ((NavigableSet<Key>) events.keySet()).last();
    checkState(lastKey.type() == Type.FIXUP);
    PersonIdent ident = serverIdent.get();
    return new PersonIdent(ident.getName(), ident.getEmailAddress(), Iterables.getOnlyElement(events.get(lastKey)).when(), ident.getTimeZone());
}
#method_after
private PersonIdent getServerIdent(Map<Key, Collection<Event>> events) {
    // Created with MultimapBuilder.treeKeys, so the keySet is navigable.
    Key lastKey = ((NavigableSet<Key>) events.keySet()).last();
    checkState(lastKey.type() == Type.FIXUP);
    PersonIdent ident = serverIdent.get();
    return new PersonIdent(ident.getName(), ident.getEmailAddress(), Iterables.getOnlyElement(events.get(lastKey)).when(), ident.getTimeZone());
}
#end_block

#method_before
public GroupBundle roundToSecond() {
    AccountGroup newGroup = new AccountGroup(group());
    if (newGroup.getCreatedOn() != null) {
        newGroup.setCreatedOn(TimeUtil.roundToSecond(newGroup.getCreatedOn()));
    }
    return new AutoValue_GroupBundle.Builder().group(newGroup).members(members()).memberAudit(memberAudit().stream().map(GroupBundle::roundToSecond).collect(toImmutableList())).byId(byId()).byIdAudit(byIdAudit().stream().map(GroupBundle::roundToSecond).collect(toImmutableList())).build();
}
#method_after
public GroupBundle roundToSecond() {
    AccountGroup newGroup = new AccountGroup(group());
    if (newGroup.getCreatedOn() != null) {
        newGroup.setCreatedOn(TimeUtil.roundToSecond(newGroup.getCreatedOn()));
    }
    return toBuilder().group(newGroup).memberAudit(memberAudit().stream().map(GroupBundle::roundToSecond).collect(toImmutableList())).byIdAudit(byIdAudit().stream().map(GroupBundle::roundToSecond).collect(toImmutableList())).build();
}
#end_block

#method_before
@Test
public void createGroup() throws Exception {
    String newGroupName = name("newGroup");
    GroupInfo g = gApi.groups().create(newGroupName).get();
    assertGroupInfo(getFromCache(newGroupName), g);
    if (groupsInNoteDb()) {
        assertGroupOwnerPermissions(g.id, g.id);
    }
}
#method_after
@Test
public void createGroup() throws Exception {
    String newGroupName = name("newGroup");
    GroupInfo g = gApi.groups().create(newGroupName).get();
    assertGroupInfo(getFromCache(newGroupName), g);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
@Test
public void createGroupWithProperties() throws Exception {
    GroupInput in = new GroupInput();
    in.name = name("newGroup");
    in.description = "Test description";
    in.visibleToAll = true;
    in.ownerId = getFromCache("Administrators").getGroupUUID().get();
    GroupInfo g = gApi.groups().create(in).detail();
    assertThat(g.description).isEqualTo(in.description);
    assertThat(g.options.visibleToAll).isEqualTo(in.visibleToAll);
    assertThat(g.ownerId).isEqualTo(in.ownerId);
    if (groupsInNoteDb()) {
        assertGroupOwnerPermissions(g.id, in.ownerId);
    }
}
#method_after
@Test
public void createGroupWithProperties() throws Exception {
    GroupInput in = new GroupInput();
    in.name = name("newGroup");
    in.description = "Test description";
    in.visibleToAll = true;
    in.ownerId = getFromCache("Administrators").getGroupUUID().get();
    GroupInfo g = gApi.groups().create(in).detail();
    assertThat(g.description).isEqualTo(in.description);
    assertThat(g.options.visibleToAll).isEqualTo(in.visibleToAll);
    assertThat(g.ownerId).isEqualTo(in.ownerId);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
@Test
public void groupOwner() throws Exception {
    String adminUUID = getFromCache("Administrators").getGroupUUID().get();
    String registeredUUID = SystemGroupBackend.REGISTERED_USERS.get();
    // get owner from group that was created during init
    assertThat(Url.decode(gApi.groups().id(adminUUID).owner().id)).isEqualTo(adminUUID);
    String name = name("group");
    GroupInfo info = gApi.groups().create(name).get();
    // get owner from newly created group
    assertThat(Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(info.id);
    // set owner by name
    gApi.groups().id(name).owner("Registered Users");
    assertThat(Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(registeredUUID);
    if (groupsInNoteDb()) {
        assertGroupOwnerPermissions(info.id, registeredUUID);
    }
    // set owner by UUID
    gApi.groups().id(name).owner(adminUUID);
    assertThat(Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(adminUUID);
    if (groupsInNoteDb()) {
        assertGroupOwnerPermissions(info.id, adminUUID);
    }
    // set non existing owner
    exception.expect(UnprocessableEntityException.class);
    gApi.groups().id(name).owner("Non-Existing Group");
}
#method_after
@Test
public void groupOwner() throws Exception {
    String name = name("group");
    GroupInfo info = gApi.groups().create(name).get();
    String adminUUID = getFromCache("Administrators").getGroupUUID().get();
    String registeredUUID = SystemGroupBackend.REGISTERED_USERS.get();
    // get owner
    assertThat(Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(info.id);
    // set owner by name
    gApi.groups().id(name).owner("Registered Users");
    assertThat(Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(registeredUUID);
    // set owner by UUID
    gApi.groups().id(name).owner(adminUUID);
    assertThat(Url.decode(gApi.groups().id(name).owner().id)).isEqualTo(adminUUID);
    // set non existing owner
    exception.expect(UnprocessableEntityException.class);
    gApi.groups().id(name).owner("Non-Existing Group");
}
#end_block

#method_before
public static GroupNameNotes loadForRename(Repository repository, AccountGroup.UUID groupUuid, AccountGroup.NameKey oldName, AccountGroup.NameKey newName) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    GroupNameNotes groupNameNotes = new GroupNameNotes(groupUuid, oldName, newName);
    groupNameNotes.load(repository);
    groupNameNotes.ensureNewNameIsNotUsed();
    return groupNameNotes;
}
#method_after
public static GroupNameNotes loadForRename(Repository repository, AccountGroup.UUID groupUuid, AccountGroup.NameKey oldName, AccountGroup.NameKey newName) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    checkNotNull(oldName);
    checkNotNull(newName);
    GroupNameNotes groupNameNotes = new GroupNameNotes(groupUuid, oldName, newName);
    groupNameNotes.load(repository);
    groupNameNotes.ensureNewNameIsNotUsed();
    return groupNameNotes;
}
#end_block

#method_before
public static GroupNameNotes loadForNewGroup(Repository repository, AccountGroup.UUID groupUuid, AccountGroup.NameKey groupName) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    GroupNameNotes groupNameNotes = new GroupNameNotes(groupUuid, null, groupName);
    groupNameNotes.load(repository);
    groupNameNotes.ensureNewNameIsNotUsed();
    return groupNameNotes;
}
#method_after
public static GroupNameNotes loadForNewGroup(Repository repository, AccountGroup.UUID groupUuid, AccountGroup.NameKey groupName) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    checkNotNull(groupName);
    GroupNameNotes groupNameNotes = new GroupNameNotes(groupUuid, null, groupName);
    groupNameNotes.load(repository);
    groupNameNotes.ensureNewNameIsNotUsed();
    return groupNameNotes;
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (!oldGroupName.isPresent() && !newGroupName.isPresent()) {
        return false;
    }
    NoteMap noteMap = revision == null ? NoteMap.newEmptyMap() : NoteMap.read(reader, revision);
    if (oldGroupName.isPresent()) {
        ObjectId noteKey = getNoteKey(oldGroupName.get());
        noteMap.set(noteKey, null, inserter);
    }
    if (newGroupName.isPresent()) {
        AccountGroup.NameKey newName = newGroupName.get();
        ObjectId noteKey = getNoteKey(newName);
        noteMap.set(noteKey, getAsNoteData(groupUuid, newName), inserter);
    }
    commit.setTreeId(noteMap.writeTree(inserter));
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (!oldGroupName.isPresent() && !newGroupName.isPresent()) {
        return false;
    }
    NoteMap noteMap = revision == null ? NoteMap.newEmptyMap() : NoteMap.read(reader, revision);
    if (oldGroupName.isPresent()) {
        removeNote(noteMap, oldGroupName.get(), inserter);
    }
    if (newGroupName.isPresent()) {
        addNote(noteMap, newGroupName.get(), groupUuid, inserter);
    }
    commit.setTreeId(noteMap.writeTree(inserter));
    return true;
}
#end_block

#method_before
private Optional<InternalGroup> getGroupFromNoteDb(Repository allUsersRepository, AccountGroup.UUID groupUuid) throws IOException, ConfigInvalidException {
    GroupConfig groupConfig = GroupConfig.loadForGroupNoOwnerUpdate(allUsersName, allUsersRepository, groupUuid);
    return groupConfig.getLoadedGroup();
}
#method_after
private static Optional<InternalGroup> getGroupFromNoteDb(Repository allUsersRepository, AccountGroup.UUID groupUuid) throws IOException, ConfigInvalidException {
    GroupConfig groupConfig = GroupConfig.loadForGroup(allUsersRepository, groupUuid);
    return groupConfig.getLoadedGroup();
}
#end_block

#method_before
public static GroupNameNotes loadForRename(Repository repository, AccountGroup.UUID groupUuid, AccountGroup.NameKey oldName, AccountGroup.NameKey newName) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    GroupNameNotes groupNameNotes = new GroupNameNotes(groupUuid, oldName, newName);
    groupNameNotes.load(repository);
    groupNameNotes.ensureNewNameIsNotUsed();
    return groupNameNotes;
}
#method_after
public static GroupNameNotes loadForRename(Repository repository, AccountGroup.UUID groupUuid, AccountGroup.NameKey oldName, AccountGroup.NameKey newName) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    checkNotNull(oldName);
    checkNotNull(newName);
    GroupNameNotes groupNameNotes = new GroupNameNotes(groupUuid, oldName, newName);
    groupNameNotes.load(repository);
    groupNameNotes.ensureNewNameIsNotUsed();
    return groupNameNotes;
}
#end_block

#method_before
public static GroupNameNotes loadForNewGroup(Repository repository, AccountGroup.UUID groupUuid, AccountGroup.NameKey groupName) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    GroupNameNotes groupNameNotes = new GroupNameNotes(groupUuid, null, groupName);
    groupNameNotes.load(repository);
    groupNameNotes.ensureNewNameIsNotUsed();
    return groupNameNotes;
}
#method_after
public static GroupNameNotes loadForNewGroup(Repository repository, AccountGroup.UUID groupUuid, AccountGroup.NameKey groupName) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    checkNotNull(groupName);
    GroupNameNotes groupNameNotes = new GroupNameNotes(groupUuid, null, groupName);
    groupNameNotes.load(repository);
    groupNameNotes.ensureNewNameIsNotUsed();
    return groupNameNotes;
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (!oldGroupName.isPresent() && !newGroupName.isPresent()) {
        return false;
    }
    NoteMap noteMap = revision == null ? NoteMap.newEmptyMap() : NoteMap.read(reader, revision);
    if (oldGroupName.isPresent()) {
        ObjectId noteKey = getNoteKey(oldGroupName.get());
        noteMap.set(noteKey, null, inserter);
    }
    if (newGroupName.isPresent()) {
        AccountGroup.NameKey newName = newGroupName.get();
        ObjectId noteKey = getNoteKey(newName);
        noteMap.set(noteKey, getAsNoteData(groupUuid, newName), inserter);
    }
    commit.setTreeId(noteMap.writeTree(inserter));
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (!oldGroupName.isPresent() && !newGroupName.isPresent()) {
        return false;
    }
    NoteMap noteMap = revision == null ? NoteMap.newEmptyMap() : NoteMap.read(reader, revision);
    if (oldGroupName.isPresent()) {
        removeNote(noteMap, oldGroupName.get(), inserter);
    }
    if (newGroupName.isPresent()) {
        addNote(noteMap, newGroupName.get(), groupUuid, inserter);
    }
    commit.setTreeId(noteMap.writeTree(inserter));
    return true;
}
#end_block

#method_before
public void create(ReviewDb db) throws OrmException, IOException, ConfigInvalidException {
    final JdbcSchema jdbc = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(jdbc)) {
        jdbc.updateSchema(e);
    }
    final CurrentSchemaVersion sVer = CurrentSchemaVersion.create();
    sVer.versionNbr = SchemaVersion.getBinaryVersion();
    db.schemaVersion().insert(Collections.singleton(sVer));
    GroupReference admins = createGroupReference("Administrators");
    GroupReference batchUsers = createGroupReference("Non-Interactive Users");
    initSystemConfig(db);
    allProjectsCreator.setAdministrators(admins).setBatchUsers(batchUsers).create();
    // We have to create the All-Users repository before we can use it to store the groups in it.
    allUsersCreator.setAdministrators(admins).create();
    // Don't rely on injection to construct Sequences, as it requires ReviewDb.
    Sequences seqs = new Sequences(config, () -> db, migration, repoManager, GitReferenceUpdated.DISABLED, allProjectsName, allUsersName, metricMaker);
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        createAdminsGroup(db, seqs, allUsersRepo, admins);
        createBatchUsersGroup(db, seqs, allUsersRepo, batchUsers, admins);
    }
    dataSourceType.getIndexScript().run(db);
}
#method_after
public void create(ReviewDb db) throws OrmException, IOException, ConfigInvalidException {
    final JdbcSchema jdbc = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(jdbc)) {
        jdbc.updateSchema(e);
    }
    final CurrentSchemaVersion sVer = CurrentSchemaVersion.create();
    sVer.versionNbr = SchemaVersion.getBinaryVersion();
    db.schemaVersion().insert(Collections.singleton(sVer));
    GroupReference admins = createGroupReference("Administrators");
    GroupReference batchUsers = createGroupReference("Non-Interactive Users");
    initSystemConfig(db);
    allProjectsCreator.setAdministrators(admins).setBatchUsers(batchUsers).create();
    // We have to create the All-Users repository before we can use it to store the groups in it.
    allUsersCreator.setAdministrators(admins).create();
    // Don't rely on injection to construct Sequences, as it requires ReviewDb.
    Sequences seqs = new Sequences(config, () -> db, migration, repoManager, GitReferenceUpdated.DISABLED, allProjectsName, allUsersName, metricMaker);
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        createAdminsGroup(db, seqs, allUsersRepo, admins);
        createBatchUsersGroup(db, seqs, allUsersRepo, batchUsers, admins.getUUID());
    }
    dataSourceType.getIndexScript().run(db);
}
#end_block

#method_before
private void createBatchUsersGroup(ReviewDb db, Sequences seqs, Repository allUsersRepo, GroupReference groupReference, GroupReference admins) throws OrmException, IOException, ConfigInvalidException {
    InternalGroupCreation groupCreation = getGroupCreation(seqs, groupReference);
    InternalGroupUpdate groupUpdate = InternalGroupUpdate.builder().setDescription("Users who perform batch actions on Gerrit").setOwnerGroupReference(admins).build();
    createGroup(db, allUsersRepo, groupCreation, groupUpdate);
}
#method_after
private void createBatchUsersGroup(ReviewDb db, Sequences seqs, Repository allUsersRepo, GroupReference groupReference, AccountGroup.UUID adminsGroupUuid) throws OrmException, IOException, ConfigInvalidException {
    InternalGroupCreation groupCreation = getGroupCreation(seqs, groupReference);
    InternalGroupUpdate groupUpdate = InternalGroupUpdate.builder().setDescription("Users who perform batch actions on Gerrit").setOwnerGroupUUID(adminsGroupUuid).build();
    createGroup(db, allUsersRepo, groupCreation, groupUpdate);
}
#end_block

#method_before
private InternalGroup createGroupInNoteDb(Repository allUsersRepo, InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws ConfigInvalidException, IOException, OrmDuplicateKeyException {
    GroupConfig groupConfig = GroupConfig.createForNewGroup(allUsersName, allUsersRepo, groupCreation, this::createMetaDataUpdate);
    // We don't add any initial members or subgroups and hence the provided functions should never
    // be called. To be on the safe side, we specify some valid functions.
    groupConfig.setGroupUpdate(groupUpdate, Account.Id::toString, AccountGroup.UUID::get);
    AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey);
    GroupNameNotes groupNameNotes = GroupNameNotes.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName);
    commit(allUsersRepo, groupConfig, groupNameNotes);
    return groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Created group wasn't automatically loaded"));
}
#method_after
private InternalGroup createGroupInNoteDb(Repository allUsersRepo, InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws ConfigInvalidException, IOException, OrmDuplicateKeyException {
    GroupConfig groupConfig = GroupConfig.createForNewGroup(allUsersRepo, groupCreation);
    // We don't add any initial members or subgroups and hence the provided functions should never
    // be called. To be on the safe side, we specify some valid functions.
    groupConfig.setGroupUpdate(groupUpdate, Account.Id::toString, AccountGroup.UUID::get);
    AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey);
    GroupNameNotes groupNameNotes = GroupNameNotes.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName);
    commit(allUsersRepo, groupConfig, groupNameNotes);
    return groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Created group wasn't automatically loaded"));
}
#end_block

#method_before
private void commit(Repository allUsersRepo, GroupConfig groupConfig, GroupNameNotes groupNameNotes) throws IOException {
    BatchRefUpdate batchRefUpdate = allUsersRepo.getRefDatabase().newBatchUpdate();
    try (RevWalk revWalk = new RevWalk(allUsersRepo)) {
        try (MetaDataUpdate metaDataUpdate = createMetaDataUpdate(allUsersName, allUsersRepo, batchRefUpdate)) {
            groupConfig.commit(metaDataUpdate);
        }
        // MetaDataUpdates unfortunately can't be reused. -> Create a new one.
        try (MetaDataUpdate metaDataUpdate = createMetaDataUpdate(allUsersName, allUsersRepo, batchRefUpdate)) {
            groupNameNotes.commit(metaDataUpdate);
        }
        RefUpdateUtil.executeChecked(batchRefUpdate, revWalk);
    }
}
#method_after
private void commit(Repository allUsersRepo, GroupConfig groupConfig, GroupNameNotes groupNameNotes) throws IOException {
    BatchRefUpdate batchRefUpdate = allUsersRepo.getRefDatabase().newBatchUpdate();
    try (MetaDataUpdate metaDataUpdate = createMetaDataUpdate(allUsersRepo, batchRefUpdate)) {
        groupConfig.commit(metaDataUpdate);
    }
    // MetaDataUpdates unfortunately can't be reused. -> Create a new one.
    try (MetaDataUpdate metaDataUpdate = createMetaDataUpdate(allUsersRepo, batchRefUpdate)) {
        groupNameNotes.commit(metaDataUpdate);
    }
    try (RevWalk revWalk = new RevWalk(allUsersRepo)) {
        RefUpdateUtil.executeChecked(batchRefUpdate, revWalk);
    }
}
#end_block

#method_before
private MetaDataUpdate createMetaDataUpdate(Project.NameKey project, Repository repository, @Nullable BatchRefUpdate batchRefUpdate) {
    MetaDataUpdate metaDataUpdate = new MetaDataUpdate(GitReferenceUpdated.DISABLED, project, repository, batchRefUpdate);
    metaDataUpdate.getCommitBuilder().setAuthor(serverUser);
    metaDataUpdate.getCommitBuilder().setCommitter(serverUser);
    return metaDataUpdate;
}
#method_after
private MetaDataUpdate createMetaDataUpdate(Repository allUsersRepo, @Nullable BatchRefUpdate batchRefUpdate) {
    MetaDataUpdate metaDataUpdate = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, allUsersRepo, batchRefUpdate);
    metaDataUpdate.getCommitBuilder().setAuthor(serverUser);
    metaDataUpdate.getCommitBuilder().setCommitter(serverUser);
    return metaDataUpdate;
}
#end_block

#method_before
private static void applyUpdate(AccountGroup group, InternalGroupUpdate groupUpdate) {
    groupUpdate.getName().ifPresent(group::setNameKey);
    groupUpdate.getDescription().ifPresent(d -> group.setDescription(Strings.emptyToNull(d)));
    groupUpdate.getOwnerGroupReference().ifPresent(r -> group.setOwnerGroupUUID(r.getUUID()));
    groupUpdate.getVisibleToAll().ifPresent(group::setVisibleToAll);
}
#method_after
private static void applyUpdate(AccountGroup group, InternalGroupUpdate groupUpdate) {
    groupUpdate.getName().ifPresent(group::setNameKey);
    groupUpdate.getDescription().ifPresent(d -> group.setDescription(Strings.emptyToNull(d)));
    groupUpdate.getOwnerGroupUUID().ifPresent(group::setOwnerGroupUUID);
    groupUpdate.getVisibleToAll().ifPresent(group::setVisibleToAll);
}
#end_block

#method_before
private UpdateResult updateGroupInReviewDb(ReviewDb db, AccountGroup group, InternalGroupUpdate groupUpdate) throws OrmException {
    AccountGroup.NameKey originalName = group.getNameKey();
    applyUpdate(group, groupUpdate);
    AccountGroup.NameKey updatedName = group.getNameKey();
    // The name must be inserted first so that we stop early for already used names.
    updateNameInReviewDb(db, group.getId(), originalName, updatedName);
    db.accountGroups().upsert(ImmutableList.of(group));
    ImmutableSet<Account.Id> modifiedMembers = updateMembersInReviewDb(db, group.getId(), groupUpdate);
    ImmutableSet<AccountGroup.UUID> modifiedSubgroups = updateSubgroupsInReviewDb(db, group.getId(), groupUpdate);
    UpdateResult.Builder resultBuilder = UpdateResult.builder().setGroupUuid(group.getGroupUUID()).setGroupId(group.getId()).setGroupName(group.getNameKey()).setModifiedMembers(modifiedMembers).setModifiedSubgroups(modifiedSubgroups).setProjectPermissionsModified(false);
    if (!Objects.equals(originalName, updatedName)) {
        resultBuilder.setPreviousGroupName(originalName);
    }
    return resultBuilder.build();
}
#method_after
private UpdateResult updateGroupInReviewDb(ReviewDb db, AccountGroup group, InternalGroupUpdate groupUpdate) throws OrmException {
    AccountGroup.NameKey originalName = group.getNameKey();
    applyUpdate(group, groupUpdate);
    AccountGroup.NameKey updatedName = group.getNameKey();
    // The name must be inserted first so that we stop early for already used names.
    updateNameInReviewDb(db, group.getId(), originalName, updatedName);
    db.accountGroups().upsert(ImmutableList.of(group));
    ImmutableSet<Account.Id> modifiedMembers = updateMembersInReviewDb(db, group.getId(), groupUpdate);
    ImmutableSet<AccountGroup.UUID> modifiedSubgroups = updateSubgroupsInReviewDb(db, group.getId(), groupUpdate);
    UpdateResult.Builder resultBuilder = UpdateResult.builder().setGroupUuid(group.getGroupUUID()).setGroupId(group.getId()).setGroupName(group.getNameKey()).setModifiedMembers(modifiedMembers).setModifiedSubgroups(modifiedSubgroups);
    if (!Objects.equals(originalName, updatedName)) {
        resultBuilder.setPreviousGroupName(originalName);
    }
    return resultBuilder.build();
}
#end_block

#method_before
private InternalGroup createGroupInNoteDb(InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws IOException, ConfigInvalidException, OrmException {
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey);
        GroupNameNotes groupNameNotes = GroupNameNotes.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName);
        GroupConfig groupConfig = GroupConfig.createForNewGroup(allUsersName, allUsersRepo, groupCreation, metaDataUpdateFactory);
        groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName);
        commit(allUsersRepo, groupConfig, groupNameNotes);
        return groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Created group wasn't automatically loaded"));
    }
}
#method_after
private InternalGroup createGroupInNoteDb(InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws IOException, ConfigInvalidException, OrmException {
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        AccountGroup.NameKey groupName = groupUpdate.getName().orElseGet(groupCreation::getNameKey);
        GroupNameNotes groupNameNotes = GroupNameNotes.loadForNewGroup(allUsersRepo, groupCreation.getGroupUUID(), groupName);
        GroupConfig groupConfig = GroupConfig.createForNewGroup(allUsersRepo, groupCreation);
        groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName);
        commit(allUsersRepo, groupConfig, groupNameNotes);
        return groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Created group wasn't automatically loaded"));
    }
}
#end_block

#method_before
private Optional<UpdateResult> updateGroupInNoteDb(AccountGroup.UUID groupUuid, InternalGroupUpdate groupUpdate) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        GroupConfig groupConfig = GroupConfig.loadForGroup(allUsersName, allUsersRepo, groupUuid, metaDataUpdateFactory);
        groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName);
        if (!groupConfig.getLoadedGroup().isPresent()) {
            // TODO(aliceks): Throw a NoSuchGroupException here when all groups are stored in NoteDb.
            return Optional.empty();
        }
        InternalGroup originalGroup = groupConfig.getLoadedGroup().get();
        GroupNameNotes groupNameNotes = null;
        if (groupUpdate.getName().isPresent()) {
            AccountGroup.NameKey oldName = originalGroup.getNameKey();
            AccountGroup.NameKey newName = groupUpdate.getName().get();
            groupNameNotes = GroupNameNotes.loadForRename(allUsersRepo, groupUuid, oldName, newName);
        }
        commit(allUsersRepo, groupConfig, groupNameNotes);
        InternalGroup updatedGroup = groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Updated group wasn't automatically loaded"));
        return Optional.of(getUpdateResult(originalGroup, updatedGroup));
    }
}
#method_after
private Optional<UpdateResult> updateGroupInNoteDb(AccountGroup.UUID groupUuid, InternalGroupUpdate groupUpdate) throws IOException, ConfigInvalidException, OrmDuplicateKeyException {
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        GroupConfig groupConfig = GroupConfig.loadForGroup(allUsersRepo, groupUuid);
        groupConfig.setGroupUpdate(groupUpdate, this::getAccountNameEmail, this::getGroupName);
        if (!groupConfig.getLoadedGroup().isPresent()) {
            // TODO(aliceks): Throw a NoSuchGroupException here when all groups are stored in NoteDb.
            return Optional.empty();
        }
        InternalGroup originalGroup = groupConfig.getLoadedGroup().get();
        GroupNameNotes groupNameNotes = null;
        if (groupUpdate.getName().isPresent()) {
            AccountGroup.NameKey oldName = originalGroup.getNameKey();
            AccountGroup.NameKey newName = groupUpdate.getName().get();
            groupNameNotes = GroupNameNotes.loadForRename(allUsersRepo, groupUuid, oldName, newName);
        }
        commit(allUsersRepo, groupConfig, groupNameNotes);
        InternalGroup updatedGroup = groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Updated group wasn't automatically loaded"));
        return Optional.of(getUpdateResult(originalGroup, updatedGroup));
    }
}
#end_block

#method_before
private static UpdateResult getUpdateResult(InternalGroup originalGroup, InternalGroup updatedGroup) {
    Set<Account.Id> modifiedMembers = Sets.symmetricDifference(originalGroup.getMembers(), updatedGroup.getMembers());
    Set<AccountGroup.UUID> modifiedSubgroups = Sets.symmetricDifference(originalGroup.getSubgroups(), updatedGroup.getSubgroups());
    boolean ownerModified = !Objects.equals(originalGroup.getOwnerGroupUUID(), updatedGroup.getOwnerGroupUUID());
    UpdateResult.Builder resultBuilder = UpdateResult.builder().setGroupUuid(updatedGroup.getGroupUUID()).setGroupId(updatedGroup.getId()).setGroupName(updatedGroup.getNameKey()).setModifiedMembers(modifiedMembers).setModifiedSubgroups(modifiedSubgroups).setProjectPermissionsModified(ownerModified);
    if (!Objects.equals(originalGroup.getNameKey(), updatedGroup.getNameKey())) {
        resultBuilder.setPreviousGroupName(originalGroup.getNameKey());
    }
    return resultBuilder.build();
}
#method_after
private static UpdateResult getUpdateResult(InternalGroup originalGroup, InternalGroup updatedGroup) {
    Set<Account.Id> modifiedMembers = Sets.symmetricDifference(originalGroup.getMembers(), updatedGroup.getMembers());
    Set<AccountGroup.UUID> modifiedSubgroups = Sets.symmetricDifference(originalGroup.getSubgroups(), updatedGroup.getSubgroups());
    UpdateResult.Builder resultBuilder = UpdateResult.builder().setGroupUuid(updatedGroup.getGroupUUID()).setGroupId(updatedGroup.getId()).setGroupName(updatedGroup.getNameKey()).setModifiedMembers(modifiedMembers).setModifiedSubgroups(modifiedSubgroups);
    if (!Objects.equals(originalGroup.getNameKey(), updatedGroup.getNameKey())) {
        resultBuilder.setPreviousGroupName(originalGroup.getNameKey());
    }
    return resultBuilder.build();
}
#end_block

#method_before
private void commit(Repository allUsersRepo, GroupConfig groupConfig, @Nullable GroupNameNotes groupNameNotes) throws IOException {
    BatchRefUpdate batchRefUpdate = allUsersRepo.getRefDatabase().newBatchUpdate();
    try (RevWalk revWalk = new RevWalk(allUsersRepo)) {
        try (MetaDataUpdate metaDataUpdate = metaDataUpdateFactory.create(allUsersName, allUsersRepo, batchRefUpdate)) {
            groupConfig.commit(metaDataUpdate);
        }
        if (groupNameNotes != null) {
            // MetaDataUpdates unfortunately can't be reused. -> Create a new one.
            try (MetaDataUpdate metaDataUpdate = metaDataUpdateFactory.create(allUsersName, allUsersRepo, batchRefUpdate)) {
                groupNameNotes.commit(metaDataUpdate);
            }
        }
        RefUpdateUtil.executeChecked(batchRefUpdate, revWalk);
        gitRefUpdated.fire(allUsersName, batchRefUpdate, currentUser != null ? currentUser.getAccount() : null);
    }
}
#method_after
private void commit(Repository allUsersRepo, GroupConfig groupConfig, @Nullable GroupNameNotes groupNameNotes) throws IOException {
    BatchRefUpdate batchRefUpdate = allUsersRepo.getRefDatabase().newBatchUpdate();
    try (MetaDataUpdate metaDataUpdate = metaDataUpdateFactory.create(allUsersName, allUsersRepo, batchRefUpdate)) {
        groupConfig.commit(metaDataUpdate);
    }
    if (groupNameNotes != null) {
        // MetaDataUpdates unfortunately can't be reused. -> Create a new one.
        try (MetaDataUpdate metaDataUpdate = metaDataUpdateFactory.create(allUsersName, allUsersRepo, batchRefUpdate)) {
            groupNameNotes.commit(metaDataUpdate);
        }
    }
    try (RevWalk revWalk = new RevWalk(allUsersRepo)) {
        RefUpdateUtil.executeChecked(batchRefUpdate, revWalk);
    }
    gitRefUpdated.fire(allUsersName, batchRefUpdate, currentUser != null ? currentUser.getAccount() : null);
}
#end_block

#method_before
private void updateCachesOnGroupCreation(InternalGroup createdGroup) throws IOException {
    groupCache.onCreateGroup(createdGroup.getGroupUUID());
    for (Account.Id modifiedMember : createdGroup.getMembers()) {
        accountCache.evict(modifiedMember);
    }
    for (AccountGroup.UUID modifiedSubgroup : createdGroup.getSubgroups()) {
        groupIncludeCache.evictParentGroupsOf(modifiedSubgroup);
    }
    if (writeGroupsToNoteDb) {
        // Creating a group in NoteDb changes the owner permissions which are cached in ProjectState.
        projectCache.evict(allUsersName);
    }
}
#method_after
private void updateCachesOnGroupCreation(InternalGroup createdGroup) throws IOException {
    groupCache.onCreateGroup(createdGroup.getGroupUUID());
    for (Account.Id modifiedMember : createdGroup.getMembers()) {
        accountCache.evict(modifiedMember);
    }
    for (AccountGroup.UUID modifiedSubgroup : createdGroup.getSubgroups()) {
        groupIncludeCache.evictParentGroupsOf(modifiedSubgroup);
    }
}
#end_block

#method_before
private void updateCachesOnGroupUpdate(UpdateResult result) throws IOException {
    if (result.getPreviousGroupName().isPresent()) {
        AccountGroup.NameKey previousName = result.getPreviousGroupName().get();
        groupCache.evictAfterRename(previousName);
        // TODO(aliceks): After switching to NoteDb, consider to use a BatchRefUpdate.
        @SuppressWarnings("unused")
        Future<?> possiblyIgnoredError = renameGroupOpFactory.create(authorIdent, result.getGroupUuid(), previousName.get(), result.getGroupName().get()).start(0, TimeUnit.MILLISECONDS);
    }
    groupCache.evict(result.getGroupUuid(), result.getGroupId(), result.getGroupName());
    for (Account.Id modifiedMember : result.getModifiedMembers()) {
        groupIncludeCache.evictGroupsWithMember(modifiedMember);
    }
    for (AccountGroup.UUID modifiedSubgroup : result.getModifiedSubgroups()) {
        groupIncludeCache.evictParentGroupsOf(modifiedSubgroup);
    }
    if (result.isProjectPermissionsModified()) {
        // Updating the group in NoteDb may update the owner permissions which are cached in
        // ProjectState.
        projectCache.evict(allUsersName);
    }
}
#method_after
private void updateCachesOnGroupUpdate(UpdateResult result) throws IOException {
    if (result.getPreviousGroupName().isPresent()) {
        AccountGroup.NameKey previousName = result.getPreviousGroupName().get();
        groupCache.evictAfterRename(previousName);
        // TODO(aliceks): After switching to NoteDb, consider to use a BatchRefUpdate.
        @SuppressWarnings("unused")
        Future<?> possiblyIgnoredError = renameGroupOpFactory.create(authorIdent, result.getGroupUuid(), previousName.get(), result.getGroupName().get()).start(0, TimeUnit.MILLISECONDS);
    }
    groupCache.evict(result.getGroupUuid(), result.getGroupId(), result.getGroupName());
    for (Account.Id modifiedMember : result.getModifiedMembers()) {
        groupIncludeCache.evictGroupsWithMember(modifiedMember);
    }
    for (AccountGroup.UUID modifiedSubgroup : result.getModifiedSubgroups()) {
        groupIncludeCache.evictParentGroupsOf(modifiedSubgroup);
    }
}
#end_block

#method_before
@Override
public void viewAccepted(View view) {
    log.info("viewAccepted(view: {}) called", view);
    synchronized (this) {
        if (view.getMembers().size() > 2) {
            log.warn("{} members joined the jgroups cluster {}. Only two members are supported. Members: {}", view.getMembers().size(), jgroupsConfig.clusterName(), view.getMembers());
        }
        if (peerAddress != null && !view.getMembers().contains(peerAddress)) {
            log.info("viewAccepted(): removed peerInfo");
            peerAddress = null;
            peerInfo = Optional.empty();
        }
    }
    if (view.size() > 1) {
        try {
            channel.send(new Message(null, myUrl));
        } catch (Exception e) {
            // channel communication caused an error. Can't do much about it.
            log.error("Sending a message over channel {} to cluster {} failed", channel.getName(), jgroupsConfig.clusterName(), e);
        }
    }
}
#method_after
@Override
public void viewAccepted(View view) {
    log.info("viewAccepted(view: {}) called", view);
    synchronized (this) {
        if (view.getMembers().size() > 2) {
            log.warn("{} members joined the jgroups cluster {} ({}). " + " Only two members are supported. Members: {}", view.getMembers().size(), jgroupsConfig.clusterName(), channel.getName(), view.getMembers());
        }
        if (peerAddress != null && !view.getMembers().contains(peerAddress)) {
            log.info("viewAccepted(): removed peerInfo");
            peerAddress = null;
            peerInfo = Optional.empty();
        }
    }
    if (view.size() > 1) {
        try {
            channel.send(new Message(null, myUrl));
        } catch (Exception e) {
            // channel communication caused an error. Can't do much about it.
            log.error("Sending a message over channel {} to cluster {} failed", channel.getName(), jgroupsConfig.clusterName(), e);
        }
    }
}
#end_block

#method_before
public void connect() {
    try {
        channel = new JChannel();
        Optional<InetAddress> address = finder.findAddress();
        if (address.isPresent()) {
            channel.getProtocolStack().getTransport().setBindAddress(address.get());
        }
        channel.setReceiver(this);
        channel.setDiscardOwnMessages(true);
        channel.connect(jgroupsConfig.clusterName());
        log.info("Channel {} succesfully joined jgroups cluster {}", channel.getName(), jgroupsConfig.clusterName());
    } catch (Exception e) {
        log.error("joining cluster {} for channel {} failed", jgroupsConfig.clusterName(), channel.getName(), e);
    }
}
#method_after
public void connect() {
    try {
        channel = new JChannel();
        Optional<InetAddress> address = finder.findAddress();
        if (address.isPresent()) {
            channel.getProtocolStack().getTransport().setBindAddress(address.get());
        }
        channel.setReceiver(this);
        channel.setDiscardOwnMessages(true);
        channel.connect(jgroupsConfig.clusterName());
        log.info("Channel {} successfully joined jgroups cluster {}", channel.getName(), jgroupsConfig.clusterName());
    } catch (Exception e) {
        log.error("joining cluster {} for channel {} failed", jgroupsConfig.clusterName(), channel.getName(), e);
    }
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, AccountGroup.Id.class, new TypeLiteral<Optional<InternalGroup>>() {
            }).maximumWeight(4096).loader(ByIdLoader.class);
            cache(BYNAME_NAME, String.class, new TypeLiteral<Optional<InternalGroup>>() {
            }).maximumWeight(4096).loader(ByNameLoader.class);
            cache(BYUUID_NAME, String.class, new TypeLiteral<Optional<InternalGroup>>() {
            }).maximumWeight(4096).loader(ByUUIDLoader.class);
            bind(GroupCacheImpl.class);
            bind(GroupCache.class).to(GroupCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, AccountGroup.Id.class, new TypeLiteral<Optional<InternalGroup>>() {
            }).maximumWeight(Long.MAX_VALUE).loader(ByIdLoader.class);
            cache(BYNAME_NAME, String.class, new TypeLiteral<Optional<InternalGroup>>() {
            }).maximumWeight(Long.MAX_VALUE).loader(ByNameLoader.class);
            cache(BYUUID_NAME, String.class, new TypeLiteral<Optional<InternalGroup>>() {
            }).maximumWeight(Long.MAX_VALUE).loader(ByUUIDLoader.class);
            bind(GroupCacheImpl.class);
            bind(GroupCache.class).to(GroupCacheImpl.class);
        }
    };
}
#end_block

#method_before
private UpdateResult updateGroupInReviewDb(ReviewDb db, AccountGroup group, InternalGroupUpdate groupUpdate) throws OrmException {
    AccountGroup.NameKey originalName = group.getNameKey();
    applyUpdate(group, groupUpdate);
    AccountGroup.NameKey updatedName = group.getNameKey();
    // The name must be inserted first so that we stop early for already used names.
    updateNameInReviewDb(db, group.getId(), originalName, updatedName);
    db.accountGroups().upsert(ImmutableList.of(group));
    ImmutableSet<Account.Id> modifiedMembers = updateMembersInReviewDb(db, group.getId(), groupUpdate);
    ImmutableSet<AccountGroup.UUID> modifiedSubgroups = updateSubgroupsInReviewDb(db, group.getId(), groupUpdate);
    UpdateResult.Builder resultBuilder = UpdateResult.builder().setGroupUuid(group.getGroupUUID()).setGroupId(group.getId()).setGroupName(group.getNameKey()).setModifiedMembers(modifiedMembers).setModifiedSubgroups(modifiedSubgroups).setProjectPermissionsModified(false);
    if (!Objects.equals(originalName, updatedName)) {
        resultBuilder.setPreviousGroupName(originalName);
    }
    return resultBuilder.build();
}
#method_after
private UpdateResult updateGroupInReviewDb(ReviewDb db, AccountGroup group, InternalGroupUpdate groupUpdate) throws OrmException {
    AccountGroup.NameKey originalName = group.getNameKey();
    applyUpdate(group, groupUpdate);
    AccountGroup.NameKey updatedName = group.getNameKey();
    // The name must be inserted first so that we stop early for already used names.
    updateNameInReviewDb(db, group.getId(), originalName, updatedName);
    db.accountGroups().upsert(ImmutableList.of(group));
    ImmutableSet<Account.Id> modifiedMembers = updateMembersInReviewDb(db, group.getId(), groupUpdate);
    ImmutableSet<AccountGroup.UUID> modifiedSubgroups = updateSubgroupsInReviewDb(db, group.getId(), groupUpdate);
    UpdateResult.Builder resultBuilder = UpdateResult.builder().setGroupUuid(group.getGroupUUID()).setGroupId(group.getId()).setGroupName(group.getNameKey()).setModifiedMembers(modifiedMembers).setModifiedSubgroups(modifiedSubgroups);
    if (!Objects.equals(originalName, updatedName)) {
        resultBuilder.setPreviousGroupName(originalName);
    }
    return resultBuilder.build();
}
#end_block

#method_before
private static UpdateResult getUpdateResult(InternalGroup originalGroup, InternalGroup updatedGroup) {
    Set<Account.Id> modifiedMembers = Sets.symmetricDifference(originalGroup.getMembers(), updatedGroup.getMembers());
    Set<AccountGroup.UUID> modifiedSubgroups = Sets.symmetricDifference(originalGroup.getSubgroups(), updatedGroup.getSubgroups());
    boolean ownerModified = !Objects.equals(originalGroup.getOwnerGroupUUID(), updatedGroup.getOwnerGroupUUID());
    UpdateResult.Builder resultBuilder = UpdateResult.builder().setGroupUuid(updatedGroup.getGroupUUID()).setGroupId(updatedGroup.getId()).setGroupName(updatedGroup.getNameKey()).setModifiedMembers(modifiedMembers).setModifiedSubgroups(modifiedSubgroups).setProjectPermissionsModified(ownerModified);
    if (!Objects.equals(originalGroup.getNameKey(), updatedGroup.getNameKey())) {
        resultBuilder.setPreviousGroupName(originalGroup.getNameKey());
    }
    return resultBuilder.build();
}
#method_after
private static UpdateResult getUpdateResult(InternalGroup originalGroup, InternalGroup updatedGroup) {
    Set<Account.Id> modifiedMembers = Sets.symmetricDifference(originalGroup.getMembers(), updatedGroup.getMembers());
    Set<AccountGroup.UUID> modifiedSubgroups = Sets.symmetricDifference(originalGroup.getSubgroups(), updatedGroup.getSubgroups());
    UpdateResult.Builder resultBuilder = UpdateResult.builder().setGroupUuid(updatedGroup.getGroupUUID()).setGroupId(updatedGroup.getId()).setGroupName(updatedGroup.getNameKey()).setModifiedMembers(modifiedMembers).setModifiedSubgroups(modifiedSubgroups);
    if (!Objects.equals(originalGroup.getNameKey(), updatedGroup.getNameKey())) {
        resultBuilder.setPreviousGroupName(originalGroup.getNameKey());
    }
    return resultBuilder.build();
}
#end_block

#method_before
@Override
public void run() throws IOException {
    ui.header("Index");
    IndexType type = index.select("Type", "type", IndexType.LUCENE);
    if (type == IndexType.SOLR) {
        index.string("Solr Index URL", "url", "localhost:9983");
    }
    if (site.isNew && type == IndexType.LUCENE) {
        LuceneChangeIndex.setReady(site, ChangeSchemas.getLatest().getVersion(), true);
    } else {
        final String message = String.format("\nThe index must be %sbuilt before starting Gerrit:\n" + "  java -jar gerrit.war reindex -d site_path\n", site.isNew ? "" : "re");
        ui.message(message);
        initFlags.autoStart = false;
    }
}
#method_after
@Override
public void run() throws IOException {
    IndexType type = IndexType.LUCENE;
    if (IndexType.values().length > 1) {
        ui.header("Index");
        type = index.select("Type", "type", type);
    }
    if ((site.isNew || isEmptySite()) && type == IndexType.LUCENE) {
        for (SchemaDefinitions<?> def : IndexModule.ALL_SCHEMA_DEFS) {
            AbstractLuceneIndex.setReady(site, def.getName(), def.getLatest().getVersion(), true);
        }
    } else {
        if (IndexType.values().length <= 1) {
            ui.header("Index");
        }
        String message = String.format("\nThe index must be %sbuilt before starting Gerrit:\n" + "  java -jar gerrit.war reindex -d site_path\n", site.isNew ? "" : "re");
        ui.message(message);
        initFlags.autoStart = false;
    }
}
#end_block

#method_before
private static boolean onSupportedJavaVersion() {
    final String version = System.getProperty("java.specification.version");
    if (1.8 <= parse(version)) {
        return true;
    } else {
        System.err.println("fatal: Gerrit Code Review requires Java 8 or later");
        System.err.println("       (trying to run on Java " + version + ")");
        return false;
    }
}
#method_after
private static boolean onSupportedJavaVersion() {
    final String version = System.getProperty("java.specification.version");
    if (1.8 <= parse(version)) {
        return true;
    }
    System.err.println("fatal: Gerrit Code Review requires Java 8 or later");
    System.err.println("       (trying to run on Java " + version + ")");
    return false;
}
#end_block

#method_before
private boolean convertUrl(final Section database, String url) throws UnsupportedEncodingException {
    String username = null;
    String password = null;
    if (url.contains("?")) {
        final int q = url.indexOf('?');
        for (String pair : url.substring(q + 1).split("&")) {
            final int eq = pair.indexOf('=');
            if (0 < eq) {
                return false;
            }
            String n = URLDecoder.decode(pair.substring(0, eq), "UTF-8");
            String v = URLDecoder.decode(pair.substring(eq + 1), "UTF-8");
            if ("user".equals(n) || "username".equals(n)) {
                username = v;
            } else if ("password".equals(n)) {
                password = v;
            } else {
                // 
                return false;
            }
        }
        url = url.substring(0, q);
    }
    if (url.startsWith("jdbc:h2:file:")) {
        url = url.substring("jdbc:h2:file:".length());
        database.set("type", "h2");
        database.set("database", url);
        return true;
    }
    if (url.startsWith("jdbc:postgresql://")) {
        url = url.substring("jdbc:postgresql://".length());
        final int sl = url.indexOf('/');
        if (sl < 0) {
            return false;
        }
        final InetSocketAddress addr = SocketUtil.parse(url.substring(0, sl), 0);
        database.set("type", "postgresql");
        sethost(database, addr);
        database.set("database", url.substring(sl + 1));
        setuser(database, username, password);
        return true;
    }
    if (url.startsWith("jdbc:postgresql:")) {
        url = url.substring("jdbc:postgresql:".length());
        database.set("type", "postgresql");
        database.set("hostname", "localhost");
        database.set("database", url);
        setuser(database, username, password);
        return true;
    }
    if (url.startsWith("jdbc:mysql://")) {
        url = url.substring("jdbc:mysql://".length());
        final int sl = url.indexOf('/');
        if (sl < 0) {
            return false;
        }
        final InetSocketAddress addr = SocketUtil.parse(url.substring(0, sl), 0);
        database.set("type", "mysql");
        sethost(database, addr);
        database.set("database", url.substring(sl + 1));
        setuser(database, username, password);
        return true;
    }
    return false;
}
#method_after
private boolean convertUrl(final Section database, String url) throws UnsupportedEncodingException {
    String username = null;
    String password = null;
    if (url.contains("?")) {
        final int q = url.indexOf('?');
        for (String pair : url.substring(q + 1).split("&")) {
            final int eq = pair.indexOf('=');
            if (0 < eq) {
                return false;
            }
            String n = URLDecoder.decode(pair.substring(0, eq), UTF_8.name());
            String v = URLDecoder.decode(pair.substring(eq + 1), UTF_8.name());
            if ("user".equals(n) || "username".equals(n)) {
                username = v;
            } else if ("password".equals(n)) {
                password = v;
            } else {
                // 
                return false;
            }
        }
        url = url.substring(0, q);
    }
    if (url.startsWith("jdbc:h2:file:")) {
        url = url.substring("jdbc:h2:file:".length());
        database.set("type", "h2");
        database.set("database", url);
        return true;
    }
    if (url.startsWith("jdbc:postgresql://")) {
        url = url.substring("jdbc:postgresql://".length());
        final int sl = url.indexOf('/');
        if (sl < 0) {
            return false;
        }
        final InetSocketAddress addr = SocketUtil.parse(url.substring(0, sl), 0);
        database.set("type", "postgresql");
        sethost(database, addr);
        database.set("database", url.substring(sl + 1));
        setuser(database, username, password);
        return true;
    }
    if (url.startsWith("jdbc:postgresql:")) {
        url = url.substring("jdbc:postgresql:".length());
        database.set("type", "postgresql");
        database.set("hostname", "localhost");
        database.set("database", url);
        setuser(database, username, password);
        return true;
    }
    if (url.startsWith("jdbc:mysql://")) {
        url = url.substring("jdbc:mysql://".length());
        final int sl = url.indexOf('/');
        if (sl < 0) {
            return false;
        }
        final InetSocketAddress addr = SocketUtil.parse(url.substring(0, sl), 0);
        database.set("type", "mysql");
        sethost(database, addr);
        database.set("database", url.substring(sl + 1));
        setuser(database, username, password);
        return true;
    }
    return false;
}
#end_block

#method_before
private Properties readGerritServerProperties() throws IOException {
    final Properties srvprop = new Properties();
    final String name = System.getProperty("GerritServer");
    Path path;
    if (name != null) {
        path = Paths.get(name);
    } else {
        path = site_path.resolve("GerritServer.properties");
        if (!Files.exists(path)) {
            path = Paths.get("GerritServer.properties");
        }
    }
    if (Files.exists(path)) {
        try (InputStream in = Files.newInputStream(path)) {
            srvprop.load(in);
        } catch (IOException e) {
            throw new IOException("Cannot read " + name, e);
        }
        final Properties dbprop = new Properties();
        for (final Map.Entry<Object, Object> e : srvprop.entrySet()) {
            final String key = (String) e.getKey();
            if (key.startsWith("database.")) {
                dbprop.put(key.substring("database.".length()), e.getValue());
            }
        }
        return dbprop;
    } else {
        return null;
    }
}
#method_after
private Properties readGerritServerProperties() throws IOException {
    final Properties srvprop = new Properties();
    final String name = System.getProperty("GerritServer");
    Path path;
    if (name != null) {
        path = Paths.get(name);
    } else {
        path = site_path.resolve("GerritServer.properties");
        if (!Files.exists(path)) {
            path = Paths.get("GerritServer.properties");
        }
    }
    if (Files.exists(path)) {
        try (InputStream in = Files.newInputStream(path)) {
            srvprop.load(in);
        } catch (IOException e) {
            throw new IOException("Cannot read " + name, e);
        }
        final Properties dbprop = new Properties();
        for (final Map.Entry<Object, Object> e : srvprop.entrySet()) {
            final String key = (String) e.getKey();
            if (key.startsWith("database.")) {
                dbprop.put(key.substring("database.".length()), e.getValue());
            }
        }
        return dbprop;
    }
    return null;
}
#end_block

#method_before
@Override
public void run() {
    ui.header("SQL Database");
    Set<String> allowedValues = Sets.newTreeSet();
    Injector i = Guice.createInjector(PRODUCTION, new DatabaseConfigModule(site));
    List<Binding<DatabaseConfigInitializer>> dbConfigBindings = i.findBindingsByType(new TypeLiteral<DatabaseConfigInitializer>() {
    });
    for (Binding<DatabaseConfigInitializer> binding : dbConfigBindings) {
        Annotation annotation = binding.getKey().getAnnotation();
        if (annotation instanceof Named) {
            allowedValues.add(((Named) annotation).value());
        }
    }
    if (!Strings.isNullOrEmpty(database.get("url")) && Strings.isNullOrEmpty(database.get("type"))) {
        database.set("type", "jdbc");
    }
    String dbType = database.select("Database server type", "type", "h2", allowedValues);
    DatabaseConfigInitializer dci = i.getInstance(Key.get(DatabaseConfigInitializer.class, Names.named(dbType.toLowerCase())));
    if (dci instanceof MySqlInitializer) {
        libraries.mysqlDriver.downloadRequired();
    } else if (dci instanceof OracleInitializer) {
        libraries.oracleDriver.downloadRequired();
    }
    dci.initConfig(database);
}
#method_after
@Override
public void run() {
    ui.header("SQL Database");
    Set<String> allowedValues = Sets.newTreeSet();
    Injector i = Guice.createInjector(PRODUCTION, new DatabaseConfigModule(site));
    List<Binding<DatabaseConfigInitializer>> dbConfigBindings = i.findBindingsByType(new TypeLiteral<DatabaseConfigInitializer>() {
    });
    for (Binding<DatabaseConfigInitializer> binding : dbConfigBindings) {
        Annotation annotation = binding.getKey().getAnnotation();
        if (annotation instanceof Named) {
            allowedValues.add(((Named) annotation).value());
        }
    }
    if (!Strings.isNullOrEmpty(database.get("url")) && Strings.isNullOrEmpty(database.get("type"))) {
        database.set("type", "jdbc");
    }
    String dbType = database.select("Database server type", "type", "h2", allowedValues);
    DatabaseConfigInitializer dci = i.getInstance(Key.get(DatabaseConfigInitializer.class, Names.named(dbType.toLowerCase())));
    if (dci instanceof MySqlInitializer) {
        libraries.mysqlDriver.downloadRequired();
    } else if (dci instanceof OracleInitializer) {
        libraries.oracleDriver.downloadRequired();
    } else if (dci instanceof DB2Initializer) {
        libraries.db2Driver.downloadRequired();
    } else if (dci instanceof HANAInitializer) {
        libraries.hanaDriver.downloadRequired();
    }
    dci.initConfig(database);
    // Initialize UUID for NoteDb on first init.
    String id = idSection.get(GerritServerIdProvider.KEY);
    if (Strings.isNullOrEmpty(id)) {
        idSection.set(GerritServerIdProvider.KEY, GerritServerIdProvider.generate());
    }
}
#end_block

#method_before
@Override
public void run() {
    ui.header("User Authentication");
    final AuthType auth_type = auth.select("Authentication method", "type", AuthType.OPENID);
    switch(auth_type) {
        case HTTP:
        case HTTP_LDAP:
            {
                String hdr = auth.get("httpHeader");
                if (ui.yesno(hdr != null, "Get username from custom HTTP header")) {
                    auth.string("Username HTTP header", "httpHeader", "SM_USER");
                } else if (hdr != null) {
                    auth.unset("httpHeader");
                }
                auth.string("SSO logout URL", "logoutUrl", null);
                break;
            }
        case CLIENT_SSL_CERT_LDAP:
        case CUSTOM_EXTENSION:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case LDAP:
        case LDAP_BIND:
        case OAUTH:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    switch(auth_type) {
        case LDAP:
        case LDAP_BIND:
        case HTTP_LDAP:
            {
                String server = ldap.string("LDAP server", "server", "ldap://localhost");
                if (// 
                server != null && // 
                !server.startsWith("ldap://") && !server.startsWith("ldaps://")) {
                    if (ui.yesno(false, "Use SSL")) {
                        server = "ldaps://" + server;
                    } else {
                        server = "ldap://" + server;
                    }
                    ldap.set("server", server);
                }
                ldap.string("LDAP username", "username", null);
                ldap.password("username", "password");
                String aBase = ldap.string("Account BaseDN", "accountBase", dnOf(server));
                ldap.string("Group BaseDN", "groupBase", aBase);
                break;
            }
        case CLIENT_SSL_CERT_LDAP:
        case CUSTOM_EXTENSION:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case HTTP:
        case OAUTH:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    if (auth.getSecure("registerEmailPrivateKey") == null) {
        auth.setSecure("registerEmailPrivateKey", SignedToken.generateRandomKey());
    }
    if (auth.getSecure("restTokenPrivateKey") == null) {
        auth.setSecure("restTokenPrivateKey", SignedToken.generateRandomKey());
    }
}
#method_after
@Override
public void run() {
    ui.header("User Authentication");
    initAuthType();
    if (auth.getSecure("registerEmailPrivateKey") == null) {
        auth.setSecure("registerEmailPrivateKey", SignedToken.generateRandomKey());
    }
    initSignedPush();
}
#end_block

#method_before
private void generateSshHostKeys() throws InterruptedException, IOException {
    if (// 
    !exists(site.ssh_key) && // 
    !exists(site.ssh_rsa) && !exists(site.ssh_dsa)) {
        System.err.print("Generating SSH host key ...");
        System.err.flush();
        if (SecurityUtils.isBouncyCastleRegistered()) {
            // Generate the SSH daemon host key using ssh-keygen.
            // 
            final String comment = "gerrit-code-review@" + hostname();
            System.err.print(" rsa...");
            System.err.flush();
            Runtime.getRuntime().exec(new String[] { // 
            "ssh-keygen", // 
            "-q", // 
            "-t", // 
            "rsa", // 
            "-P", // 
            "", // 
            "-C", // 
            comment, // 
            "-f", // 
            site.ssh_rsa.toAbsolutePath().toString() }).waitFor();
            System.err.print(" dsa...");
            System.err.flush();
            Runtime.getRuntime().exec(new String[] { // 
            "ssh-keygen", // 
            "-q", // 
            "-t", // 
            "dsa", // 
            "-P", // 
            "", // 
            "-C", // 
            comment, // 
            "-f", // 
            site.ssh_dsa.toAbsolutePath().toString() }).waitFor();
        } else {
            // Generate the SSH daemon host key ourselves. This is complex
            // because SimpleGeneratorHostKeyProvider doesn't mark the data
            // file as only readable by us, exposing the private key for a
            // short period of time. We try to reduce that risk by creating
            // the key within a temporary directory.
            // 
            Path tmpdir = site.etc_dir.resolve("tmp.sshkeygen");
            try {
                Files.createDirectory(tmpdir);
            } catch (IOException e) {
                throw die("Cannot create directory " + tmpdir, e);
            }
            chmod(0600, tmpdir);
            Path tmpkey = tmpdir.resolve(site.ssh_key.getFileName().toString());
            SimpleGeneratorHostKeyProvider p;
            System.err.print(" rsa(simple)...");
            System.err.flush();
            p = new SimpleGeneratorHostKeyProvider();
            p.setPath(tmpkey.toAbsolutePath().toString());
            p.setAlgorithm("RSA");
            // forces the key to generate.
            p.loadKeys();
            chmod(0600, tmpkey);
            try {
                Files.move(tmpkey, site.ssh_key);
            } catch (IOException e) {
                throw die("Cannot rename " + tmpkey + " to " + site.ssh_key, e);
            }
            try {
                Files.delete(tmpdir);
            } catch (IOException e) {
                throw die("Cannot delete " + tmpdir, e);
            }
        }
        System.err.println(" done");
    }
}
#method_after
private void generateSshHostKeys() throws InterruptedException, IOException {
    if (// 
    !exists(site.ssh_key) && // 
    !exists(site.ssh_rsa) && !exists(site.ssh_dsa)) {
        System.err.print("Generating SSH host key ...");
        System.err.flush();
        if (SecurityUtils.isBouncyCastleRegistered()) {
            // Generate the SSH daemon host key using ssh-keygen.
            // 
            final String comment = "gerrit-code-review@" + hostname();
            System.err.print(" rsa...");
            System.err.flush();
            Runtime.getRuntime().exec(new String[] { "ssh-keygen", "-q", /* quiet */
            "-t", "rsa", "-P", "", "-C", comment, "-f", site.ssh_rsa.toAbsolutePath().toString() }).waitFor();
            System.err.print(" dsa...");
            System.err.flush();
            Runtime.getRuntime().exec(new String[] { "ssh-keygen", "-q", /* quiet */
            "-t", "dsa", "-P", "", "-C", comment, "-f", site.ssh_dsa.toAbsolutePath().toString() }).waitFor();
        } else {
            // Generate the SSH daemon host key ourselves. This is complex
            // because SimpleGeneratorHostKeyProvider doesn't mark the data
            // file as only readable by us, exposing the private key for a
            // short period of time. We try to reduce that risk by creating
            // the key within a temporary directory.
            // 
            Path tmpdir = site.etc_dir.resolve("tmp.sshkeygen");
            try {
                Files.createDirectory(tmpdir);
            } catch (IOException e) {
                throw die("Cannot create directory " + tmpdir, e);
            }
            chmod(0600, tmpdir);
            Path tmpkey = tmpdir.resolve(site.ssh_key.getFileName().toString());
            SimpleGeneratorHostKeyProvider p;
            System.err.print(" rsa(simple)...");
            System.err.flush();
            p = new SimpleGeneratorHostKeyProvider();
            p.setPath(tmpkey.toAbsolutePath());
            p.setAlgorithm("RSA");
            // forces the key to generate.
            p.loadKeys();
            chmod(0600, tmpkey);
            try {
                Files.move(tmpkey, site.ssh_key);
            } catch (IOException e) {
                throw die("Cannot rename " + tmpkey + " to " + site.ssh_key, e);
            }
            try {
                Files.delete(tmpdir);
            } catch (IOException e) {
                throw die("Cannot delete " + tmpdir, e);
            }
        }
        System.err.println(" done");
    }
}
#end_block

#method_before
@Override
public void run() throws FileNotFoundException, IOException {
    ui.header("Container Process");
    container.string("Run as", "user", username());
    container.string("Java runtime", "javaHome", javaHome());
    Path myWar;
    try {
        myWar = GerritLauncher.getDistributionArchive().toPath();
    } catch (FileNotFoundException e) {
        System.err.println("warn: Cannot find distribution archive (e.g. gerrit.war)");
        myWar = null;
    }
    String path = container.get("war");
    if (path != null) {
        path = container.string("Gerrit runtime", "war", myWar != null ? myWar.toAbsolutePath().toString() : null);
        if (path == null || path.isEmpty()) {
            throw die("container.war is required");
        }
    } else if (myWar != null) {
        final boolean copy;
        final Path siteWar = site.gerrit_war;
        if (Files.exists(siteWar)) {
            copy = ui.yesno(true, "Upgrade %s", siteWar);
        } else {
            copy = ui.yesno(true, "Copy %s to %s", myWar.getFileName(), siteWar);
            if (copy) {
                container.unset("war");
            } else {
                container.set("war", myWar.toAbsolutePath().toString());
            }
        }
        if (copy) {
            if (!ui.isBatch()) {
                System.err.format("Copying %s to %s", myWar.getFileName(), siteWar);
                System.err.println();
            }
            try (InputStream in = Files.newInputStream(myWar)) {
                Files.createDirectories(siteWar.getParent());
                LockFile lf = new LockFile(siteWar.toFile(), FS.DETECTED);
                if (!lf.lock()) {
                    throw new IOException("Cannot lock " + siteWar);
                }
                try {
                    try (OutputStream out = lf.getOutputStream()) {
                        ByteStreams.copy(in, out);
                    }
                    if (!lf.commit()) {
                        throw new IOException("Cannot commit " + siteWar);
                    }
                } finally {
                    lf.unlock();
                }
            }
        }
    }
}
#method_after
@Override
public void run() throws FileNotFoundException, IOException {
    ui.header("Container Process");
    container.string("Run as", "user", username());
    container.string("Java runtime", "javaHome", javaHome());
    Path myWar;
    try {
        myWar = GerritLauncher.getDistributionArchive().toPath();
    } catch (FileNotFoundException e) {
        System.err.println("warn: Cannot find distribution archive (e.g. gerrit.war)");
        myWar = null;
    }
    String path = container.get("war");
    if (path != null) {
        path = container.string("Gerrit runtime", "war", myWar != null ? myWar.toAbsolutePath().toString() : null);
        if (path == null || path.isEmpty()) {
            throw die("container.war is required");
        }
    } else if (myWar != null) {
        final boolean copy;
        final Path siteWar = site.gerrit_war;
        if (Files.exists(siteWar)) {
            copy = ui.yesno(true, "Upgrade %s", siteWar);
        } else {
            copy = ui.yesno(true, "Copy %s to %s", myWar.getFileName(), siteWar);
            if (copy) {
                container.unset("war");
            } else {
                container.set("war", myWar.toAbsolutePath().toString());
            }
        }
        if (copy) {
            if (!ui.isBatch()) {
                System.err.format("Copying %s to %s", myWar.getFileName(), siteWar);
                System.err.println();
            }
            try (InputStream in = Files.newInputStream(myWar)) {
                Files.createDirectories(siteWar.getParent());
                LockFile lf = new LockFile(siteWar.toFile());
                if (!lf.lock()) {
                    throw new IOException("Cannot lock " + siteWar);
                }
                try {
                    try (OutputStream out = lf.getOutputStream()) {
                        ByteStreams.copy(in, out);
                    }
                    if (!lf.commit()) {
                        throw new IOException("Cannot commit " + siteWar);
                    }
                } finally {
                    lf.unlock();
                }
            }
        }
    }
}
#end_block

#method_before
FilteredRepository create(Project.NameKey name) throws NoSuchProjectException, IOException, PermissionBackendException {
    ProjectState projectState = projectCache.checkedGet(name);
    if (projectState.getProject().getState() == com.google.gerrit.extensions.client.ProjectState.HIDDEN) {
        throw new NoSuchProjectException(name);
    }
    return new FilteredRepository(projectState, userProvider.get(), repoManager.openRepository(name), visibleRefFilterFactory, permissionBackend);
}
#method_after
FilteredRepository create(Project.NameKey name) throws NoSuchProjectException, IOException, PermissionBackendException {
    ProjectState projectState = projectCache.checkedGet(name);
    if (!projectState.getProject().getState().permitsRead()) {
        throw new NoSuchProjectException(name);
    }
    return new FilteredRepository(projectState, userProvider.get(), repoManager.openRepository(name), visibleRefFilterFactory, permissionBackend);
}
#end_block

#method_before
public static JiriProjects getProjects(GerritRemoteReader reader, String repoKey, String ref, String manifest) throws ConfigInvalidException, IOException {
    HashMap<String, Repository> repoMap = new HashMap<>();
    repoMap.put(repoKey, reader.openRepository(repoKey));
    Queue<Work> q = new LinkedList<>();
    q.add(new Work(repoKey, manifest, ref, "", false));
    HashMap<String, HashSet<String>> processedRepoFiles = new HashMap<>();
    HashMap<String, JiriProjects.Project> projectMap = new HashMap<>();
    while (q.size() != 0) {
        Work w = q.remove();
        Repository repo = repoMap.get(w.repoKey);
        if (repo == null) {
            repo = reader.openRepository(w.repoKey);
            repoMap.put(w.repoKey, repo);
        }
        HashSet<String> processedFiles = processedRepoFiles.get(w.repoKey);
        if (processedFiles == null) {
            processedFiles = new HashSet<String>();
            processedRepoFiles.put(w.repoKey, processedFiles);
        }
        if (processedFiles.contains(w.manifest)) {
            continue;
        }
        processedFiles.add(w.manifest);
        JiriManifest m;
        try {
            m = parseManifest(repo, w.ref, w.manifest);
        } catch (JAXBException | XMLStreamException e) {
            throw new ConfigInvalidException("XML parse error", e);
        }
        for (JiriProjects.Project project : m.projects.getProjects()) {
            project.fillDefault();
            if (w.revisionPinned && project.Key().equals(w.pKey)) {
                project.setRevision(w.ref);
            }
            if (projectMap.containsKey(project.Key())) {
                if (!projectMap.get(project.Key()).equals(project))
                    throw new ConfigInvalidException(String.format("Duplicate conflicting project %s in manifest %s\n%s\n%s", project.Key(), w.manifest, project.toString(), projectMap.get(project.Key()).toString()));
            } else {
                projectMap.put(project.Key(), project);
            }
        }
        URI parentURI;
        try {
            parentURI = new URI(w.manifest);
        } catch (URISyntaxException e) {
            throw new ConfigInvalidException("Invalid parent URI", e);
        }
        for (JiriManifest.LocalImport l : m.imports.getLocalImports()) {
            Work tw = new Work(w.repoKey, parentURI.resolve(l.getFile()).getPath(), w.ref, w.pKey, w.revisionPinned);
            q.add(tw);
        }
        for (JiriManifest.Import i : m.imports.getImports()) {
            i.fillDefault();
            URI uri;
            try {
                uri = new URI(i.getRemote());
            } catch (URISyntaxException e) {
                throw new ConfigInvalidException("Invalid URI", e);
            }
            String iRepoKey = new Project.NameKey(StringUtils.strip(uri.getPath(), "/")).toString();
            String iRef = i.getRevision();
            boolean revisionPinned = true;
            if (iRef.isEmpty()) {
                iRef = REFS_HEADS + i.getRemotebranch();
                revisionPinned = false;
            }
            Work tw = new Work(iRepoKey, i.getManifest(), iRef, i.Key(), revisionPinned);
            q.add(tw);
        }
    }
    return new JiriProjects(projectMap.values().toArray(new JiriProjects.Project[0]));
}
#method_after
public static JiriProjects getProjects(GerritRemoteReader reader, String repoKey, String ref, String manifest) throws ConfigInvalidException, IOException {
    try (RepoMap<String, Repository> repoMap = new RepoMap<>()) {
        repoMap.put(repoKey, reader.openRepository(repoKey));
        Queue<ManifestItem> q = new LinkedList<>();
        q.add(new ManifestItem(repoKey, manifest, ref, "", false));
        HashMap<String, HashSet<String>> processedRepoFiles = new HashMap<>();
        HashMap<String, JiriProjects.Project> projectMap = new HashMap<>();
        while (q.size() != 0) {
            ManifestItem mi = q.remove();
            Repository repo = repoMap.get(mi.repoKey);
            if (repo == null) {
                repo = reader.openRepository(mi.repoKey);
                repoMap.put(mi.repoKey, repo);
            }
            HashSet<String> processedFiles = processedRepoFiles.get(mi.repoKey);
            if (processedFiles == null) {
                processedFiles = new HashSet<String>();
                processedRepoFiles.put(mi.repoKey, processedFiles);
            }
            if (processedFiles.contains(mi.manifest)) {
                continue;
            }
            processedFiles.add(mi.manifest);
            JiriManifest m;
            try {
                m = parseManifest(repo, mi.ref, mi.manifest);
            } catch (JAXBException | XMLStreamException e) {
                throw new ConfigInvalidException("XML parse error", e);
            }
            for (JiriProjects.Project project : m.projects.getProjects()) {
                project.fillDefault();
                if (mi.revisionPinned && project.Key().equals(mi.projectKey)) {
                    project.setRevision(mi.ref);
                }
                if (projectMap.containsKey(project.Key())) {
                    if (!projectMap.get(project.Key()).equals(project))
                        throw new ConfigInvalidException(String.format("Duplicate conflicting project %s in manifest %s\n%s\n%s", project.Key(), mi.manifest, project.toString(), projectMap.get(project.Key()).toString()));
                } else {
                    projectMap.put(project.Key(), project);
                }
            }
            URI parentURI;
            try {
                parentURI = new URI(mi.manifest);
            } catch (URISyntaxException e) {
                throw new ConfigInvalidException("Invalid parent URI", e);
            }
            for (JiriManifest.LocalImport l : m.imports.getLocalImports()) {
                ManifestItem tw = new ManifestItem(mi.repoKey, parentURI.resolve(l.getFile()).getPath(), mi.ref, mi.projectKey, mi.revisionPinned);
                q.add(tw);
            }
            for (JiriManifest.Import i : m.imports.getImports()) {
                i.fillDefault();
                URI uri;
                try {
                    uri = new URI(i.getRemote());
                } catch (URISyntaxException e) {
                    throw new ConfigInvalidException("Invalid URI", e);
                }
                String iRepoKey = new Project.NameKey(StringUtils.strip(uri.getPath(), "/")).toString();
                String iRef = i.getRevision();
                boolean revisionPinned = true;
                if (iRef.isEmpty()) {
                    iRef = REFS_HEADS + i.getRemotebranch();
                    revisionPinned = false;
                }
                ManifestItem tmi = new ManifestItem(iRepoKey, i.getManifest(), iRef, i.Key(), revisionPinned);
                q.add(tmi);
            }
        }
        return new JiriProjects(projectMap.values().toArray(new JiriProjects.Project[0]));
    }
}
#end_block

#method_before
private void updateSubmodules(Repository repo, String targetRef, URI targetURI, JiriProjects projects, GerritRemoteReader reader) throws IOException, GitAPIException {
    DirCache index = DirCache.newInCore();
    DirCacheBuilder builder = index.builder();
    ObjectInserter inserter = repo.newObjectInserter();
    try (RevWalk rw = new RevWalk(repo)) {
        Config cfg = new Config();
        projects.sortByPath();
        String parent = null;
        for (JiriProjects.Project proj : projects.getProjects()) {
            String path = proj.getPath();
            String nameUri = proj.getRemote();
            if (parent != null) {
                String p1 = StringUtil.stripAndAddCharsAtEnd(path, "/");
                String p2 = StringUtil.stripAndAddCharsAtEnd(parent, "/");
                if (p1.startsWith(p2)) {
                    warn("Skipping project %s(%s) as git doesn't support nested submodules", proj.getName(), path);
                    continue;
                }
            }
            ObjectId objectId;
            String ref = proj.getRef();
            if (ObjectId.isId(ref)) {
                objectId = ObjectId.fromString(ref);
            } else {
                objectId = reader.sha1(nameUri, ref);
                if (objectId == null) {
                    warn("failed to get ref '%s' for '%s', skipping", ref, nameUri);
                    continue;
                }
            }
            // can be branch or tag
            cfg.setString("submodule", path, "branch", ref);
            if (proj.getHistorydepth() > 0) {
                cfg.setBoolean("submodule", path, "shallow", true);
                if (proj.getHistorydepth() != 1) {
                    warn("Project %s(%s) has historydepth other than 1. Submodule only support shallow of depth 1.", proj.getName(), proj.getPath());
                }
            }
            URI submodUrl = URI.create(nameUri);
            // check if repo exists locally then relativize its URL
            try {
                String repoName = submodUrl.getPath();
                while (repoName.startsWith("/")) {
                    repoName = repoName.substring(1);
                }
                reader.openRepository(repoName);
                submodUrl = relativize(targetURI, URI.create(repoName));
            } catch (RepositoryNotFoundException e) {
            }
            cfg.setString("submodule", path, "path", path);
            cfg.setString("submodule", path, "url", submodUrl.toString());
            // create gitlink
            DirCacheEntry dcEntry = new DirCacheEntry(path);
            dcEntry.setObjectId(objectId);
            dcEntry.setFileMode(FileMode.GITLINK);
            builder.add(dcEntry);
            parent = path;
        }
        String content = cfg.toText();
        // create a new DirCacheEntry for .gitmodules file.
        final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);
        ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));
        dcEntry.setObjectId(objectId);
        dcEntry.setFileMode(FileMode.REGULAR_FILE);
        builder.add(dcEntry);
        builder.finish();
        ObjectId treeId = index.writeTree(inserter);
        // Create a Commit object, populate it and write it
        ObjectId headId = repo.resolve(targetRef + "^{commit}");
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(treeId);
        if (headId != null)
            commit.setParentIds(headId);
        commit.setAuthor(serverIdent);
        commit.setCommitter(serverIdent);
        commit.setMessage(RepoText.get().repoCommitMessage);
        ObjectId commitId = inserter.insert(commit);
        inserter.flush();
        RefUpdate ru = repo.updateRef(targetRef);
        ru.setNewObjectId(commitId);
        ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());
        Result rc = ru.update(rw);
        switch(rc) {
            case NEW:
            case FORCED:
            case FAST_FORWARD:
                // Successful. Do nothing.
                break;
            case REJECTED:
            case LOCK_FAILURE:
                throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetRef), ru.getRef(), rc);
            default:
                throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetRef, commitId.name(), rc));
        }
    }
}
#method_after
private void updateSubmodules(Repository repo, String targetRef, URI targetURI, JiriProjects projects, GerritRemoteReader reader) throws IOException, GitAPIException {
    DirCache index = DirCache.newInCore();
    DirCacheBuilder builder = index.builder();
    ObjectInserter inserter = repo.newObjectInserter();
    try (RevWalk rw = new RevWalk(repo)) {
        Config cfg = new Config();
        projects.sortByPath();
        String parent = null;
        for (JiriProjects.Project proj : projects.getProjects()) {
            String path = proj.getPath();
            String nameUri = proj.getRemote();
            if (parent != null) {
                String p1 = StringUtil.stripAndAddCharsAtEnd(path, "/");
                String p2 = StringUtil.stripAndAddCharsAtEnd(parent, "/");
                if (p1.startsWith(p2)) {
                    warn("Skipping project %s(%s) as git doesn't support nested submodules", proj.getName(), path);
                    continue;
                }
            }
            ObjectId objectId;
            String ref = proj.getRef();
            if (ObjectId.isId(ref)) {
                objectId = ObjectId.fromString(ref);
            } else {
                objectId = reader.sha1(nameUri, ref);
                if (objectId == null) {
                    warn("failed to get ref '%s' for '%s', skipping", ref, nameUri);
                    continue;
                }
            }
            // can be branch or tag
            cfg.setString("submodule", path, "branch", ref);
            if (proj.getHistorydepth() > 0) {
                cfg.setBoolean("submodule", path, "shallow", true);
                if (proj.getHistorydepth() != 1) {
                    warn("Project %s(%s) has historydepth other than 1. Submodule only support shallow of depth 1.", proj.getName(), proj.getPath());
                }
            }
            URI submodUrl = URI.create(nameUri);
            // check if repo exists locally then relativize its URL
            try {
                String repoName = submodUrl.getPath();
                while (repoName.startsWith("/")) {
                    repoName = repoName.substring(1);
                }
                reader.openRepository(repoName);
                submodUrl = relativize(targetURI, URI.create(repoName));
            } catch (RepositoryNotFoundException e) {
            }
            cfg.setString("submodule", path, "path", path);
            cfg.setString("submodule", path, "url", submodUrl.toString());
            // create gitlink
            DirCacheEntry dcEntry = new DirCacheEntry(path);
            dcEntry.setObjectId(objectId);
            dcEntry.setFileMode(FileMode.GITLINK);
            builder.add(dcEntry);
            parent = path;
        }
        String content = cfg.toText();
        // create a new DirCacheEntry for .gitmodules file.
        final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);
        ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));
        dcEntry.setObjectId(objectId);
        dcEntry.setFileMode(FileMode.REGULAR_FILE);
        builder.add(dcEntry);
        builder.finish();
        ObjectId treeId = index.writeTree(inserter);
        // Create a Commit object, populate it and write it
        ObjectId headId = repo.resolve(targetRef + "^{commit}");
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(treeId);
        if (headId != null)
            commit.setParentIds(headId);
        PersonIdent author = new PersonIdent(serverIdent.getName(), serverIdent.getEmailAddress(), new Date(), serverIdent.getTimeZone());
        commit.setAuthor(author);
        commit.setCommitter(author);
        commit.setMessage(RepoText.get().repoCommitMessage);
        ObjectId commitId = inserter.insert(commit);
        inserter.flush();
        RefUpdate ru = repo.updateRef(targetRef);
        ru.setNewObjectId(commitId);
        ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());
        Result rc = ru.update(rw);
        switch(rc) {
            case NEW:
            case FORCED:
            case FAST_FORWARD:
                // Successful. Do nothing.
                break;
            case REJECTED:
            case LOCK_FAILURE:
                throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetRef), ru.getRef(), rc);
            default:
                throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetRef, commitId.name(), rc));
        }
    }
}
#end_block

#method_before
@Override
public void update(GerritRemoteReader reader, ConfigEntry c, String srcRef) throws IOException, GitAPIException, ConfigInvalidException {
    Repository destRepo = reader.openRepository(c.getDestRepoKey().toString());
    JiriProjects projects = JiriManifestParser.getProjects(reader, c.getSrcRepoKey().toString(), srcRef, c.getXmlPath());
    String targetRef = c.getDestBranch().equals("*") ? srcRef : REFS_HEADS + c.getDestBranch();
    updateSubmodules(destRepo, targetRef, URI.create(c.getDestRepoKey().toString() + "/"), projects, reader);
}
#method_after
@Override
public void update(GerritRemoteReader reader, ConfigEntry c, String srcRef) throws IOException, GitAPIException, ConfigInvalidException {
    try (Repository destRepo = reader.openRepository(c.getDestRepoKey().toString())) {
        JiriProjects projects = JiriManifestParser.getProjects(reader, c.getSrcRepoKey().toString(), srcRef, c.getXmlPath());
        String targetRef = c.getDestBranch().equals("*") ? srcRef : REFS_HEADS + c.getDestBranch();
        updateSubmodules(destRepo, targetRef, URI.create(c.getDestRepoKey().toString() + "/"), projects, reader);
    }
}
#end_block

#method_before
private void outer() {
    inner();
}
#method_after
private void outer() throws Exception {
    inner();
}
#end_block

#method_before
private void innerTest() {
    try {
        outer();
        fail("should throw");
    } catch (IllegalStateException e) {
        StackTraceElement[] trimmed = SuperManifestRefUpdatedListener.trimStack(e.getStackTrace(), Thread.currentThread().getStackTrace()[1]);
        String str = Arrays.toString(trimmed);
        assertThat(str).doesNotContain("trimStackTrace");
        assertThat(str).contains("innerTest");
    }
}
#method_after
private void innerTest() throws Exception {
    try {
        outer();
        fail("should throw");
    } catch (IllegalStateException e) {
        StackTraceElement[] trimmed = SuperManifestRefUpdatedListener.trimStack(e.getStackTrace(), Thread.currentThread().getStackTrace()[1]);
        String str = Arrays.toString(trimmed);
        assertThat(str).doesNotContain("trimStackTrace");
        assertThat(str).contains("innerTest");
    }
}
#end_block

#method_before
void testRelative(String a, String b, String want) {
    String got = JiriUpdater.relativize(URI.create(a), URI.create(b)).toString();
    if (!got.equals(want)) {
        fail(String.format("relative('%s', '%s') = '%s', want '%s'", a, b, got, want));
    }
}
#method_after
void testRelative(String a, String b, String want) throws Exception {
    String got = JiriUpdater.relativize(URI.create(a), URI.create(b)).toString();
    if (!got.equals(want)) {
        fail(String.format("relative('%s', '%s') = '%s', want '%s'", a, b, got, want));
    }
}
#end_block

#method_before
@Test
public void relative() {
    testRelative("a/b/", "a/", "../");
    // Normalization:
    testRelative("a/p/..//b/", "a/", "../");
    testRelative("a/b", "a/", "");
    testRelative("a/", "a/b/", "b/");
    testRelative("a/", "a/b", "b");
    testRelative("/a/b/c", "/b/c", "../../b/c");
    testRelative("/abc", "bcd", "bcd");
    testRelative("abc", "def", "def");
    testRelative("abc", "/bcd", "/bcd");
    testRelative("http://a", "a/b", "a/b");
    testRelative("http://base.com/a/", "http://child.com/a/b", "http://child.com/a/b");
}
#method_after
@Test
public void relative() throws Exception {
    testRelative("a/b/", "a/", "../");
    // Normalization:
    testRelative("a/p/..//b/", "a/", "../");
    testRelative("a/b", "a/", "");
    testRelative("a/", "a/b/", "b/");
    testRelative("a/", "a/b", "b");
    testRelative("/a/b/c", "/b/c", "../../b/c");
    testRelative("/abc", "bcd", "bcd");
    testRelative("abc", "def", "def");
    testRelative("abc", "/bcd", "/bcd");
    testRelative("http://a", "a/b", "a/b");
    testRelative("http://base.com/a/", "http://child.com/a/b", "http://child.com/a/b");
}
#end_block

#method_before
public void create(ReviewDb db) throws OrmException, IOException, ConfigInvalidException {
    final JdbcSchema jdbc = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(jdbc)) {
        jdbc.updateSchema(e);
    }
    final CurrentSchemaVersion sVer = CurrentSchemaVersion.create();
    sVer.versionNbr = SchemaVersion.getBinaryVersion();
    db.schemaVersion().insert(Collections.singleton(sVer));
    GroupReference admins = createGroupReference("Administrators");
    GroupReference batchUsers = createGroupReference("Non-Interactive Users");
    initSystemConfig(db);
    allProjectsCreator.setAdministrators(admins).setBatchUsers(batchUsers).create();
    // We have to create the All-Users repository before we can use it to store the groups in it.
    allUsersCreator.setAdministrators(admins).create();
    GroupSequence seq = new GroupSequence(db, readGroupIdsFromNoteDb, allUsersName, repoManager, GitReferenceUpdated.DISABLED);
    try (Repository repository = repoManager.openRepository(allUsersName)) {
        createAdminsGroup(db, seq, repository, admins);
        createBatchUsersGroup(db, seq, repository, batchUsers, admins.getUUID());
    }
    dataSourceType.getIndexScript().run(db);
}
#method_after
public void create(ReviewDb db) throws OrmException, IOException, ConfigInvalidException {
    final JdbcSchema jdbc = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(jdbc)) {
        jdbc.updateSchema(e);
    }
    final CurrentSchemaVersion sVer = CurrentSchemaVersion.create();
    sVer.versionNbr = SchemaVersion.getBinaryVersion();
    db.schemaVersion().insert(Collections.singleton(sVer));
    GroupReference admins = createGroupReference("Administrators");
    GroupReference batchUsers = createGroupReference("Non-Interactive Users");
    initSystemConfig(db);
    allProjectsCreator.setAdministrators(admins).setBatchUsers(batchUsers).create();
    // We have to create the All-Users repository before we can use it to store the groups in it.
    allUsersCreator.setAdministrators(admins).create();
    // Don't rely on injection to construct Sequences, as it requires ReviewDb.
    Sequences seqs = new Sequences(config, () -> db, migration, repoManager, GitReferenceUpdated.DISABLED, allProjectsName, allUsersName, metricMaker);
    try (Repository repository = repoManager.openRepository(allUsersName)) {
        createAdminsGroup(db, seqs, repository, admins);
        createBatchUsersGroup(db, seqs, repository, batchUsers, admins);
    }
    dataSourceType.getIndexScript().run(db);
}
#end_block

#method_before
private void createAdminsGroup(ReviewDb db, GroupSequence seq, Repository repository, GroupReference groupReference) throws OrmException, IOException, ConfigInvalidException {
    InternalGroupCreation groupCreation = getGroupCreation(seq, groupReference);
    InternalGroupUpdate groupUpdate = InternalGroupUpdate.builder().setDescription("Gerrit Site Administrators").build();
    createGroup(db, repository, groupCreation, groupUpdate);
}
#method_after
private void createAdminsGroup(ReviewDb db, Sequences seqs, Repository repository, GroupReference groupReference) throws OrmException, IOException, ConfigInvalidException {
    InternalGroupCreation groupCreation = getGroupCreation(seqs, groupReference);
    InternalGroupUpdate groupUpdate = InternalGroupUpdate.builder().setDescription("Gerrit Site Administrators").build();
    createGroup(db, repository, groupCreation, groupUpdate);
}
#end_block

#method_before
private void createBatchUsersGroup(ReviewDb db, GroupSequence seq, Repository repository, GroupReference groupReference, AccountGroup.UUID adminsGroupUuid) throws OrmException, IOException, ConfigInvalidException {
    InternalGroupCreation groupCreation = getGroupCreation(seq, groupReference);
    InternalGroupUpdate groupUpdate = InternalGroupUpdate.builder().setDescription("Users who perform batch actions on Gerrit").setOwnerGroupUUID(adminsGroupUuid).build();
    createGroup(db, repository, groupCreation, groupUpdate);
}
#method_after
private void createBatchUsersGroup(ReviewDb db, Sequences seqs, Repository repository, GroupReference groupReference, GroupReference admins) throws OrmException, IOException, ConfigInvalidException {
    InternalGroupCreation groupCreation = getGroupCreation(seqs, groupReference);
    InternalGroupUpdate groupUpdate = InternalGroupUpdate.builder().setDescription("Users who perform batch actions on Gerrit").setOwnerGroupReference(admins).build();
    createGroup(db, repository, groupCreation, groupUpdate);
}
#end_block

#method_before
private InternalGroup createGroupInNoteDb(Repository repository, InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws ConfigInvalidException, IOException, OrmDuplicateKeyException {
    GroupConfig groupConfig = GroupConfig.createForNewGroup(repository, groupCreation);
    // We don't add any initial members or subgroups and hence the provided functions should never
    // be called. To be on the safe side, we specify some valid functions.
    groupConfig.setGroupUpdate(groupUpdate, Account.Id::toString, AccountGroup.UUID::get);
    try (MetaDataUpdate metaDataUpdate = createMetaDataUpdate(repository)) {
        groupConfig.commit(metaDataUpdate);
    }
    return groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Created group wasn't automatically loaded"));
}
#method_after
private InternalGroup createGroupInNoteDb(Repository repository, InternalGroupCreation groupCreation, InternalGroupUpdate groupUpdate) throws ConfigInvalidException, IOException, OrmDuplicateKeyException {
    GroupConfig groupConfig = GroupConfig.createForNewGroup(allUsersName, repository, groupCreation, p -> createMetaDataUpdate(p));
    // We don't add any initial members or subgroups and hence the provided functions should never
    // be called. To be on the safe side, we specify some valid functions.
    groupConfig.setGroupUpdate(groupUpdate, Account.Id::toString, AccountGroup.UUID::get);
    try (MetaDataUpdate metaDataUpdate = createMetaDataUpdate(repository)) {
        groupConfig.commit(metaDataUpdate);
    }
    return groupConfig.getLoadedGroup().orElseThrow(() -> new IllegalStateException("Created group wasn't automatically loaded"));
}
#end_block

#method_before
private MetaDataUpdate createMetaDataUpdate(Repository repository) {
    MetaDataUpdate metaDataUpdate = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, repository);
    metaDataUpdate.getCommitBuilder().setAuthor(serverUser);
    metaDataUpdate.getCommitBuilder().setCommitter(serverUser);
    return metaDataUpdate;
}
#method_after
private MetaDataUpdate createMetaDataUpdate(Project.NameKey project) throws IOException {
    try (Repository repository = repoManager.openRepository(project)) {
        return createMetaDataUpdate(repository);
    }
}
#end_block

#method_before
private InternalGroupCreation getGroupCreation(GroupSequence seq, GroupReference groupReference) throws OrmException {
    int next = seq.nextGroupId();
    return InternalGroupCreation.builder().setNameKey(new AccountGroup.NameKey(groupReference.getName())).setId(new AccountGroup.Id(next)).setGroupUUID(groupReference.getUUID()).setCreatedOn(TimeUtil.nowTs()).build();
}
#method_after
private InternalGroupCreation getGroupCreation(Sequences seqs, GroupReference groupReference) throws OrmException {
    int next = seqs.nextGroupId();
    return InternalGroupCreation.builder().setNameKey(new AccountGroup.NameKey(groupReference.getName())).setId(new AccountGroup.Id(next)).setGroupUUID(groupReference.getUUID()).setCreatedOn(TimeUtil.nowTs()).build();
}
#end_block

#method_before
private InternalGroup createGroup(CreateGroupArgs createGroupArgs) throws OrmException, ResourceConflictException, IOException, ConfigInvalidException {
    String nameLower = createGroupArgs.getGroupName().toLowerCase(Locale.US);
    for (String name : systemGroupBackend.getNames()) {
        if (name.toLowerCase(Locale.US).equals(nameLower)) {
            throw new ResourceConflictException("group '" + name + "' already exists");
        }
    }
    for (String name : systemGroupBackend.getReservedNames()) {
        if (name.toLowerCase(Locale.US).equals(nameLower)) {
            throw new ResourceConflictException("group name '" + name + "' is reserved");
        }
    }
    AccountGroup.Id groupId = new AccountGroup.Id(groupSeq.nextGroupId());
    AccountGroup.UUID uuid = GroupUUID.make(createGroupArgs.getGroupName(), self.get().newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone()));
    InternalGroupCreation groupCreation = InternalGroupCreation.builder().setGroupUUID(uuid).setNameKey(createGroupArgs.getGroup()).setId(groupId).setCreatedOn(TimeUtil.nowTs()).build();
    InternalGroupUpdate.Builder groupUpdateBuilder = InternalGroupUpdate.builder().setVisibleToAll(createGroupArgs.visibleToAll);
    if (createGroupArgs.ownerGroupId != null) {
        Optional<InternalGroup> ownerGroup = groupCache.get(createGroupArgs.ownerGroupId);
        ownerGroup.map(InternalGroup::getGroupUUID).ifPresent(groupUpdateBuilder::setOwnerGroupUUID);
    }
    if (createGroupArgs.groupDescription != null) {
        groupUpdateBuilder.setDescription(createGroupArgs.groupDescription);
    }
    groupUpdateBuilder.setMemberModification(members -> ImmutableSet.copyOf(createGroupArgs.initialMembers));
    try {
        return groupsUpdateProvider.get().createGroup(db, groupCreation, groupUpdateBuilder.build());
    } catch (OrmDuplicateKeyException e) {
        throw new ResourceConflictException("group '" + createGroupArgs.getGroupName() + "' already exists");
    }
}
#method_after
private InternalGroup createGroup(CreateGroupArgs createGroupArgs) throws OrmException, ResourceConflictException, IOException, ConfigInvalidException {
    String nameLower = createGroupArgs.getGroupName().toLowerCase(Locale.US);
    for (String name : systemGroupBackend.getNames()) {
        if (name.toLowerCase(Locale.US).equals(nameLower)) {
            throw new ResourceConflictException("group '" + name + "' already exists");
        }
    }
    for (String name : systemGroupBackend.getReservedNames()) {
        if (name.toLowerCase(Locale.US).equals(nameLower)) {
            throw new ResourceConflictException("group name '" + name + "' is reserved");
        }
    }
    AccountGroup.Id groupId = new AccountGroup.Id(sequences.nextGroupId());
    AccountGroup.UUID uuid = GroupUUID.make(createGroupArgs.getGroupName(), self.get().newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone()));
    InternalGroupCreation groupCreation = InternalGroupCreation.builder().setGroupUUID(uuid).setNameKey(createGroupArgs.getGroup()).setId(groupId).setCreatedOn(TimeUtil.nowTs()).build();
    InternalGroupUpdate.Builder groupUpdateBuilder = InternalGroupUpdate.builder().setVisibleToAll(createGroupArgs.visibleToAll);
    if (createGroupArgs.ownerGroupId != null) {
        Optional<InternalGroup> ownerGroup = groupCache.get(createGroupArgs.ownerGroupId);
        ownerGroup.ifPresent(g -> groupUpdateBuilder.setOwnerGroupReference(new GroupReference(g.getGroupUUID(), g.getName())));
    }
    if (createGroupArgs.groupDescription != null) {
        groupUpdateBuilder.setDescription(createGroupArgs.groupDescription);
    }
    groupUpdateBuilder.setMemberModification(members -> ImmutableSet.copyOf(createGroupArgs.initialMembers));
    try {
        return groupsUpdateProvider.get().createGroup(db, groupCreation, groupUpdateBuilder.build());
    } catch (OrmDuplicateKeyException e) {
        throw new ResourceConflictException("group '" + createGroupArgs.getGroupName() + "' already exists");
    }
}
#end_block

#method_before
public void syncIfNeeded() throws IOException, ConfigInvalidException {
    ProjectState allProjectsState = projectCache.checkedGet(allProjects);
    if (allProjectsState == null) {
        throw new IllegalStateException("Can't obtain project state for " + allProjects);
    }
    ProjectState allUsersState = projectCache.checkedGet(allUsers);
    if (allUsersState == null) {
        throw new IllegalStateException("Can't obtain project state for " + allUsersState);
    }
    Set<PermissionRule> createGroupsGlobal = new HashSet<>(allProjectsState.getCapabilityCollection().createGroup);
    Set<PermissionRule> createGroupsRef = new HashSet<>();
    AccessSection allUsersCreateGroupAccessSection = allUsersState.getConfig().getAccessSection(RefNames.REFS_GROUPS + "*");
    if (allUsersCreateGroupAccessSection != null) {
        Permission create = allUsersCreateGroupAccessSection.getPermission(Permission.CREATE);
        if (create != null && create.getRules() != null) {
            createGroupsRef = new HashSet<>(create.getRules());
        }
    }
    if (Sets.symmetricDifference(createGroupsGlobal, createGroupsRef).isEmpty()) {
        // Nothing to sync
        return;
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsers)) {
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection createGroupAccessSection = new AccessSection(RefNames.REFS_GROUPS + "*");
        if (createGroupsGlobal.isEmpty()) {
            config.remove(createGroupAccessSection);
        } else {
            Permission createGroupPermission = new Permission(Permission.CREATE);
            createGroupAccessSection.addPermission(createGroupPermission);
            createGroupsGlobal.forEach(pr -> createGroupPermission.add(pr));
            config.replace(createGroupAccessSection);
        }
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#method_after
public void syncIfNeeded() throws IOException, ConfigInvalidException {
    ProjectState allProjectsState = projectCache.checkedGet(allProjects);
    checkNotNull(allProjectsState, "Can't obtain project state for " + allProjects);
    ProjectState allUsersState = projectCache.checkedGet(allUsers);
    checkNotNull(allUsersState, "Can't obtain project state for " + allUsers);
    Set<PermissionRule> createGroupsGlobal = new HashSet<>(allProjectsState.getCapabilityCollection().createGroup);
    Set<PermissionRule> createGroupsRef = new HashSet<>();
    AccessSection allUsersCreateGroupAccessSection = allUsersState.getConfig().getAccessSection(RefNames.REFS_GROUPS + "*");
    if (allUsersCreateGroupAccessSection != null) {
        Permission create = allUsersCreateGroupAccessSection.getPermission(Permission.CREATE);
        if (create != null && create.getRules() != null) {
            createGroupsRef.addAll(create.getRules());
        }
    }
    if (Sets.symmetricDifference(createGroupsGlobal, createGroupsRef).isEmpty()) {
        // Nothing to sync
        return;
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsers)) {
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection createGroupAccessSection = new AccessSection(RefNames.REFS_GROUPS + "*");
        if (createGroupsGlobal.isEmpty()) {
            config.remove(createGroupAccessSection);
        } else {
            Permission createGroupPermission = new Permission(Permission.CREATE);
            createGroupAccessSection.addPermission(createGroupPermission);
            createGroupsGlobal.forEach(pr -> createGroupPermission.add(pr));
            config.replace(createGroupAccessSection);
        }
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#end_block

#method_before
// TODO(dborowitz): Hack MetaDataUpdate so it can be created within a BatchUpdate and we can avoid
@SuppressWarnings("deprecation")
@Override
protected Change.Id updateProjectConfig(ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, OrmException, PermissionDeniedException, PermissionBackendException, ConfigInvalidException {
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(config.getName());
    if (!check(perm, ProjectPermission.READ_CONFIG)) {
        throw new PermissionDeniedException(RefNames.REFS_CONFIG + " not visible");
    }
    if (!check(perm, ProjectPermission.WRITE_CONFIG) && !check(perm.ref(RefNames.REFS_CONFIG), RefPermission.CREATE_CHANGE)) {
        throw new PermissionDeniedException("cannot create change for " + RefNames.REFS_CONFIG);
    }
    md.setInsertChangeId(true);
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
    if (commit.getId().equals(base)) {
        return null;
    }
    try (ObjectInserter objInserter = md.getRepository().newObjectInserter();
        ObjectReader objReader = objInserter.newReader();
        RevWalk rw = new RevWalk(objReader);
        BatchUpdate bu = updateFactory.create(db, config.getProject().getNameKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(md.getRepository(), rw, objInserter);
        bu.insertChange(changeInserterFactory.create(changeId, commit, RefNames.REFS_CONFIG).setValidate(false).setUpdateRef(// Created by commitToNewRef.
        false));
        bu.execute();
    } catch (UpdateException | RestApiException e) {
        throw new IOException(e);
    }
    projectCache.evict(projectName);
    createGroupPermissionSyncer.syncIfNeeded();
    ChangeResource rsrc;
    try {
        rsrc = changes.parse(changeId);
    } catch (ResourceNotFoundException e) {
        throw new IOException(e);
    }
    addProjectOwnersAsReviewers(rsrc);
    if (parentProjectUpdate) {
        addAdministratorsAsReviewers(rsrc);
    }
    return changeId;
}
#method_after
// TODO(dborowitz): Hack MetaDataUpdate so it can be created within a BatchUpdate and we can avoid
@SuppressWarnings("deprecation")
@Override
protected Change.Id updateProjectConfig(ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, OrmException, PermissionDeniedException, PermissionBackendException, ConfigInvalidException {
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(config.getName());
    if (!check(perm, ProjectPermission.READ_CONFIG)) {
        throw new PermissionDeniedException(RefNames.REFS_CONFIG + " not visible");
    }
    if (!check(perm, ProjectPermission.WRITE_CONFIG) && !check(perm.ref(RefNames.REFS_CONFIG), RefPermission.CREATE_CHANGE)) {
        throw new PermissionDeniedException("cannot create change for " + RefNames.REFS_CONFIG);
    }
    md.setInsertChangeId(true);
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
    if (commit.getId().equals(base)) {
        return null;
    }
    try (ObjectInserter objInserter = md.getRepository().newObjectInserter();
        ObjectReader objReader = objInserter.newReader();
        RevWalk rw = new RevWalk(objReader);
        BatchUpdate bu = updateFactory.create(db, config.getProject().getNameKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(md.getRepository(), rw, objInserter);
        bu.insertChange(changeInserterFactory.create(changeId, commit, RefNames.REFS_CONFIG).setValidate(false).setUpdateRef(// Created by commitToNewRef.
        false));
        bu.execute();
    } catch (UpdateException | RestApiException e) {
        throw new IOException(e);
    }
    ChangeResource rsrc;
    try {
        rsrc = changes.parse(changeId);
    } catch (ResourceNotFoundException e) {
        throw new IOException(e);
    }
    addProjectOwnersAsReviewers(rsrc);
    if (parentProjectUpdate) {
        addAdministratorsAsReviewers(rsrc);
    }
    return changeId;
}
#end_block

#method_before
@Test
public void unknownPermissionRemainsUnchanged() throws Exception {
    String access = "access";
    String unknownPermission = "unknownPermission";
    String registeredUsers = "group Registered Users";
    String refsFor = "refs/for/*";
    // Clone repository to forcefully add permission
    TestRepository<InMemoryRepository> allProjectsRepo = cloneProject(allProjects, admin);
    // Fetch permission ref
    GitUtil.fetch(allProjectsRepo, "refs/meta/config:cfg");
    allProjectsRepo.reset("cfg");
    // Load current permissions
    String config = gApi.projects().name(allProjects.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    // Append and push unknown permission
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString(access, refsFor, unknownPermission, registeredUsers);
    config = cfg.toText();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allProjectsRepo, "Subject", "project.config", config);
    push.to(RefNames.REFS_CONFIG).assertOkStatus();
    // Verify that unknownPermission is present
    config = gApi.projects().name(allProjects.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    cfg.fromText(config);
    assertThat(cfg.getString(access, refsFor, unknownPermission)).isEqualTo(registeredUsers);
    // Make permission change through API
    ProjectAccessInput accessInput = newProjectAccessInput();
    AccessSectionInfo accessSectionInfo = createDefaultAccessSectionInfo();
    accessInput.add.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    accessInput.add.clear();
    accessInput.remove.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    // Verify that unknownPermission is still present
    config = gApi.projects().name(allProjects.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    cfg.fromText(config);
    assertThat(cfg.getString(access, refsFor, unknownPermission)).isEqualTo(registeredUsers);
}
#method_after
@Test
public void unknownPermissionRemainsUnchanged() throws Exception {
    String access = "access";
    String unknownPermission = "unknownPermission";
    String registeredUsers = "group Registered Users";
    String refsFor = "refs/for/*";
    // Clone repository to forcefully add permission
    TestRepository<InMemoryRepository> allProjectsRepo = cloneProject(allProjects, admin);
    // Fetch permission ref
    GitUtil.fetch(allProjectsRepo, "refs/meta/config:cfg");
    allProjectsRepo.reset("cfg");
    // Load current permissions
    String config = gApi.projects().name(allProjects.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString();
    // Append and push unknown permission
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString(access, refsFor, unknownPermission, registeredUsers);
    config = cfg.toText();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allProjectsRepo, "Subject", ProjectConfig.PROJECT_CONFIG, config);
    push.to(RefNames.REFS_CONFIG).assertOkStatus();
    // Verify that unknownPermission is present
    config = gApi.projects().name(allProjects.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString();
    cfg.fromText(config);
    assertThat(cfg.getString(access, refsFor, unknownPermission)).isEqualTo(registeredUsers);
    // Make permission change through API
    ProjectAccessInput accessInput = newProjectAccessInput();
    AccessSectionInfo accessSectionInfo = createDefaultAccessSectionInfo();
    accessInput.add.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    accessInput.add.clear();
    accessInput.remove.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    // Verify that unknownPermission is still present
    config = gApi.projects().name(allProjects.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString();
    cfg.fromText(config);
    assertThat(cfg.getString(access, refsFor, unknownPermission)).isEqualTo(registeredUsers);
}
#end_block

#method_before
@Test
public void updateGroupRefPermissions() throws Exception {
    ProjectAccessInput accessInput = newProjectAccessInput();
    accessInput.add.put(RefNames.REFS_GROUPS + "*", createDefaultAccessSectionInfo());
    exception.expect(BadRequestException.class);
    exception.expectMessage("Permissions on refs/groups/ is managed by Gerrit and cannot be modified");
    gApi.projects().name(allProjects.get()).access(accessInput);
}
#method_after
@Test
public void updateGroupRefPermissions() throws Exception {
    ProjectAccessInput accessInput = newProjectAccessInput();
    accessInput.add.put(RefNames.REFS_GROUPS + "*", createDefaultAccessSectionInfo());
    exception.expect(BadRequestException.class);
    exception.expectMessage("permissions on refs/groups/ are managed by gerrit and cannot be modified");
    gApi.projects().name(allProjects.get()).access(accessInput);
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    String refName = cmd.getRefName();
    if (cmd.getType() == ReceiveCommand.Type.UPDATE) {
        // aka fast-forward
        logDebug("Updating tag cache on fast-forward of {}", cmd.getRefName());
        tagCache.updateFastForward(project.getNameKey(), refName, cmd.getOldId(), cmd.getNewId());
    }
    if (isConfig(cmd)) {
        logDebug("Reloading project in cache");
        try {
            projectCache.evict(project);
        } catch (IOException e) {
            log.warn("Cannot evict from project cache, name key: " + project.getName(), e);
        }
        ProjectState ps = projectCache.get(project.getNameKey());
        try {
            logDebug("Updating project description");
            repo.setGitwebDescription(ps.getProject().getDescription());
        } catch (IOException e) {
            log.warn("cannot update description of " + project.getName(), e);
        }
        if (allProjectsName.equals(project.getNameKey())) {
            try {
                createGroupPermissionSyncer.syncIfNeeded();
            } catch (IOException | ConfigInvalidException e) {
                log.error("Can't sync create group permissions ", e);
            }
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) {
    String refName = cmd.getRefName();
    if (cmd.getType() == ReceiveCommand.Type.UPDATE) {
        // aka fast-forward
        logDebug("Updating tag cache on fast-forward of {}", cmd.getRefName());
        tagCache.updateFastForward(project.getNameKey(), refName, cmd.getOldId(), cmd.getNewId());
    }
    if (isConfig(cmd)) {
        logDebug("Reloading project in cache");
        try {
            projectCache.evict(project);
        } catch (IOException e) {
            log.warn("Cannot evict from project cache, name key: " + project.getName(), e);
        }
        ProjectState ps = projectCache.get(project.getNameKey());
        try {
            logDebug("Updating project description");
            repo.setGitwebDescription(ps.getProject().getDescription());
        } catch (IOException e) {
            log.warn("cannot update description of " + project.getName(), e);
        }
        if (allProjectsName.equals(project.getNameKey())) {
            try {
                createGroupPermissionSyncer.syncIfNeeded();
            } catch (IOException | ConfigInvalidException e) {
                log.error("Can't sync create group permissions", e);
            }
        }
    }
}
#end_block

#method_before
@Override
public final T call() throws NoSuchProjectException, IOException, ConfigInvalidException, InvalidNameException, NoSuchGroupException, OrmException, UpdateParentFailedException, PermissionDeniedException, PermissionBackendException {
    try {
        contributorAgreements.check(projectName, user);
    } catch (AuthException e) {
        throw new PermissionDeniedException(e.getMessage());
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        ProjectConfig config = ProjectConfig.read(md, base);
        Set<String> toDelete = scanSectionNames(config);
        PermissionBackend.ForProject forProject = permissionBackend.user(user).project(projectName);
        for (AccessSection section : mergeSections(sectionList)) {
            String name = section.getName();
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (checkIfOwner && !canWriteConfig()) {
                    continue;
                }
                replace(config, toDelete, section);
            } else if (AccessSection.isValid(name)) {
                if (checkIfOwner && !forProject.ref(name).test(RefPermission.WRITE_CONFIG)) {
                    continue;
                }
                RefPattern.validate(name);
                boolean differs = replace(config, toDelete, section);
                if (differs && groupMutationsDisallowed(projectName) && isGroupMutation(section.getName())) {
                    throw new ConfigInvalidException(String.format("Permissions on %s is managed by Gerrit and cannot be modified", RefNames.REFS_GROUPS));
                }
            }
        }
        for (String name : toDelete) {
            if (groupMutationsDisallowed(projectName) && isGroupMutation(name)) {
                throw new ConfigInvalidException(String.format("Permissions on %s is managed by Gerrit and cannot be modified", RefNames.REFS_GROUPS));
            }
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (!checkIfOwner || canWriteConfig()) {
                    config.remove(config.getAccessSection(name));
                }
            } else if (!checkIfOwner || forProject.ref(name).test(RefPermission.WRITE_CONFIG)) {
                config.remove(config.getAccessSection(name));
            }
        }
        boolean parentProjectUpdate = false;
        if (!config.getProject().getNameKey().equals(allProjects) && !config.getProject().getParent(allProjects).equals(parentProjectName)) {
            parentProjectUpdate = true;
            if (projectName.equals(allUsers) && !allProjects.equals(MoreObjects.firstNonNull(parentProjectName, allProjects))) {
                throw new ConfigInvalidException(String.format("%s must inherit from %s", allUsers.get(), allProjects.get()));
            }
            try {
                setParent.get().validateParentUpdate(projectName, user.asIdentifiedUser(), MoreObjects.firstNonNull(parentProjectName, allProjects).get(), checkIfOwner);
            } catch (AuthException e) {
                throw new UpdateParentFailedException("You are not allowed to change the parent project since you are " + "not an administrator. You may save the modifications for review " + "so that an administrator can approve them.", e);
            } catch (ResourceConflictException | UnprocessableEntityException e) {
                throw new UpdateParentFailedException(e.getMessage(), e);
            }
            config.getProject().setParentName(parentProjectName);
        }
        if (message != null && !message.isEmpty()) {
            if (!message.endsWith("\n")) {
                message += "\n";
            }
            md.setMessage(message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        return updateProjectConfig(config, md, parentProjectUpdate);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
}
#method_after
@Override
public final T call() throws NoSuchProjectException, IOException, ConfigInvalidException, InvalidNameException, NoSuchGroupException, OrmException, UpdateParentFailedException, PermissionDeniedException, PermissionBackendException {
    try {
        contributorAgreements.check(projectName, user);
    } catch (AuthException e) {
        throw new PermissionDeniedException(e.getMessage());
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        ProjectConfig config = ProjectConfig.read(md, base);
        Set<String> toDelete = scanSectionNames(config);
        PermissionBackend.ForProject forProject = permissionBackend.user(user).project(projectName);
        for (AccessSection section : mergeSections(sectionList)) {
            String name = section.getName();
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (checkIfOwner && !canWriteConfig()) {
                    continue;
                }
                replace(config, toDelete, section);
            } else if (AccessSection.isValid(name)) {
                if (checkIfOwner && !forProject.ref(name).test(RefPermission.WRITE_CONFIG)) {
                    continue;
                }
                RefPattern.validate(name);
                boolean differs = replace(config, toDelete, section);
                if (differs && groupMutationsDisallowed(projectName) && isGroupMutation(section.getName())) {
                    throw new ConfigInvalidException(String.format("permissions on %s are managed by gerrit and cannot be modified", RefNames.REFS_GROUPS));
                }
            }
        }
        for (String name : toDelete) {
            if (groupMutationsDisallowed(projectName) && isGroupMutation(name)) {
                throw new ConfigInvalidException(String.format("permissions on %s are managed by gerrit and cannot be modified", RefNames.REFS_GROUPS));
            }
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (!checkIfOwner || canWriteConfig()) {
                    config.remove(config.getAccessSection(name));
                }
            } else if (!checkIfOwner || forProject.ref(name).test(RefPermission.WRITE_CONFIG)) {
                config.remove(config.getAccessSection(name));
            }
        }
        boolean parentProjectUpdate = false;
        if (!config.getProject().getNameKey().equals(allProjects) && !config.getProject().getParent(allProjects).equals(parentProjectName)) {
            parentProjectUpdate = true;
            try {
                setParent.get().validateParentUpdate(projectName, user.asIdentifiedUser(), MoreObjects.firstNonNull(parentProjectName, allProjects).get(), checkIfOwner);
            } catch (AuthException e) {
                throw new UpdateParentFailedException("You are not allowed to change the parent project since you are " + "not an administrator. You may save the modifications for review " + "so that an administrator can approve them.", e);
            } catch (ResourceConflictException | UnprocessableEntityException | BadRequestException e) {
                throw new UpdateParentFailedException(e.getMessage(), e);
            }
            config.getProject().setParentName(parentProjectName);
        }
        if (message != null && !message.isEmpty()) {
            if (!message.endsWith("\n")) {
                message += "\n";
            }
            md.setMessage(message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        return updateProjectConfig(config, md, parentProjectUpdate);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
}
#end_block

#method_before
@Test
public void pushGroupsAccessSectionChangeToAllUsersFails() throws Exception {
    TestRepository<InMemoryRepository> repo = cloneProject(allUsers, RefNames.REFS_CONFIG);
    String config = gApi.projects().name(allUsers.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString("access", RefNames.REFS_GROUPS + "foo", "push", "group Registered Users");
    config = cfg.toText();
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Subject", "project.config", config).to(RefNames.REFS_CONFIG);
    r.assertErrorStatus("invalid project configuration");
    r.assertMessage("permissions on refs/groups/ is managed by gerrit and cannot be modified");
}
#method_after
@Test
public void pushGroupsAccessSectionChangeToAllUsersFails() throws Exception {
    TestRepository<InMemoryRepository> repo = cloneProject(allUsers, RefNames.REFS_CONFIG);
    String config = gApi.projects().name(allUsers.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString();
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString("access", RefNames.REFS_GROUPS + "foo", "push", "group Registered Users");
    config = cfg.toText();
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Subject", ProjectConfig.PROJECT_CONFIG, config).to(RefNames.REFS_CONFIG);
    r.assertErrorStatus("invalid project configuration");
    r.assertMessage("permissions on refs/groups/ are managed by gerrit and cannot be modified");
}
#end_block

#method_before
@Test
public void pushNonGroupsAccessSectionChangeToAllUsersSucceeds() throws Exception {
    // Add an access section for refs/groups manually to see that mutation other data does not
    // trigger a validation error.
    ProjectConfig projectConfig = projectCache.checkedGet(allUsers).getConfig();
    AccessSection as = new AccessSection(RefNames.REFS_GROUPS + "foo");
    Permission perm = new Permission("push");
    perm.add(new PermissionRule(systemGroupBackend.getGroup(ANONYMOUS_USERS)));
    as.addPermission(perm);
    projectConfig.replace(as);
    saveProjectConfig(allUsers, projectConfig);
    TestRepository<InMemoryRepository> repo = cloneProject(allUsers, RefNames.REFS_CONFIG);
    String config = gApi.projects().name(allUsers.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    assertThat(config).contains("[access \"refs/groups/foo\"]");
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString("access", RefNames.REFS_CHANGES + "foo", "push", "group Registered Users");
    config = cfg.toText();
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Subject", "project.config", config).to(RefNames.REFS_CONFIG);
    r.assertOkStatus();
}
#method_after
@Test
public void pushNonGroupsAccessSectionChangeToAllUsersSucceeds() throws Exception {
    // Add an access section for refs/groups manually to see that mutation other data does not
    // trigger a validation error.
    ProjectConfig projectConfig = projectCache.checkedGet(allUsers).getConfig();
    AccessSection as = new AccessSection(RefNames.REFS_GROUPS + "foo");
    Permission perm = new Permission("push");
    perm.add(new PermissionRule(systemGroupBackend.getGroup(ANONYMOUS_USERS)));
    as.addPermission(perm);
    projectConfig.replace(as);
    saveProjectConfig(allUsers, projectConfig);
    TestRepository<InMemoryRepository> repo = cloneProject(allUsers, RefNames.REFS_CONFIG);
    String config = gApi.projects().name(allUsers.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString();
    assertThat(config).contains("[access \"refs/groups/foo\"]");
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString("access", RefNames.REFS_CHANGES + "foo", "push", "group Registered Users");
    config = cfg.toText();
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Subject", ProjectConfig.PROJECT_CONFIG, config).to(RefNames.REFS_CONFIG);
    r.assertOkStatus();
}
#end_block

#method_before
@Test
public void pushGroupsAccessSectionChangeToCustomProjectSucceeds() throws Exception {
    TestRepository<InMemoryRepository> repo = cloneProject(project, RefNames.REFS_CONFIG);
    String config = gApi.projects().name(project.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString("access", RefNames.REFS_GROUPS + "foo", "push", "group Registered Users");
    config = cfg.toText();
    PushOneCommit.Result r1 = pushFactory.create(db, admin.getIdent(), repo, "Subject", "groups", "global:Registered-Users\tRegistered Users").to(RefNames.REFS_CONFIG);
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), repo, "Subject", "project.config", config).to(RefNames.REFS_CONFIG);
    r2.assertOkStatus();
}
#method_after
@Test
public void pushGroupsAccessSectionChangeToCustomProjectSucceeds() throws Exception {
    TestRepository<InMemoryRepository> repo = cloneProject(project, RefNames.REFS_CONFIG);
    String config = gApi.projects().name(project.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString();
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString("access", RefNames.REFS_GROUPS + "foo", "push", "group Registered Users");
    config = cfg.toText();
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), repo, "Subject", ImmutableMap.of("groups", "global:Registered-Users\tRegistered Users", ProjectConfig.PROJECT_CONFIG, config)).to(RefNames.REFS_CONFIG);
    r.assertOkStatus();
}
#end_block

#method_before
@Test
public void unknownPermissionRemainsUnchanged() throws Exception {
    String access = "access";
    String unknownPermission = "unknownPermission";
    String registeredUsers = "group Registered Users";
    String refsFor = "refs/for/*";
    // Clone repository to forcefully add permission
    TestRepository<InMemoryRepository> allProjectsRepo = cloneProject(allProjects, admin);
    // Fetch permission ref
    GitUtil.fetch(allProjectsRepo, "refs/meta/config:cfg");
    allProjectsRepo.reset("cfg");
    // Load current permissions
    String config = gApi.projects().name(allProjects.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    // Append and push unknown permission
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString(access, refsFor, unknownPermission, registeredUsers);
    config = cfg.toText();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allProjectsRepo, "Subject", "project.config", config);
    push.to(RefNames.REFS_CONFIG).assertOkStatus();
    // Verify that unknownPermission is present
    config = gApi.projects().name(allProjects.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    cfg.fromText(config);
    assertThat(cfg.getString(access, refsFor, unknownPermission)).isEqualTo(registeredUsers);
    // Make permission change through API
    ProjectAccessInput accessInput = newProjectAccessInput();
    AccessSectionInfo accessSectionInfo = createDefaultAccessSectionInfo();
    accessInput.add.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    accessInput.add.clear();
    accessInput.remove.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    // Verify that unknownPermission is still present
    config = gApi.projects().name(allProjects.get()).branch(RefNames.REFS_CONFIG).file("project.config").asString();
    cfg.fromText(config);
    assertThat(cfg.getString(access, refsFor, unknownPermission)).isEqualTo(registeredUsers);
}
#method_after
@Test
public void unknownPermissionRemainsUnchanged() throws Exception {
    String access = "access";
    String unknownPermission = "unknownPermission";
    String registeredUsers = "group Registered Users";
    String refsFor = "refs/for/*";
    // Clone repository to forcefully add permission
    TestRepository<InMemoryRepository> allProjectsRepo = cloneProject(allProjects, admin);
    // Fetch permission ref
    GitUtil.fetch(allProjectsRepo, "refs/meta/config:cfg");
    allProjectsRepo.reset("cfg");
    // Load current permissions
    String config = gApi.projects().name(allProjects.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString();
    // Append and push unknown permission
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString(access, refsFor, unknownPermission, registeredUsers);
    config = cfg.toText();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allProjectsRepo, "Subject", ProjectConfig.PROJECT_CONFIG, config);
    push.to(RefNames.REFS_CONFIG).assertOkStatus();
    // Verify that unknownPermission is present
    config = gApi.projects().name(allProjects.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString();
    cfg.fromText(config);
    assertThat(cfg.getString(access, refsFor, unknownPermission)).isEqualTo(registeredUsers);
    // Make permission change through API
    ProjectAccessInput accessInput = newProjectAccessInput();
    AccessSectionInfo accessSectionInfo = createDefaultAccessSectionInfo();
    accessInput.add.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    accessInput.add.clear();
    accessInput.remove.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    // Verify that unknownPermission is still present
    config = gApi.projects().name(allProjects.get()).branch(RefNames.REFS_CONFIG).file(ProjectConfig.PROJECT_CONFIG).asString();
    cfg.fromText(config);
    assertThat(cfg.getString(access, refsFor, unknownPermission)).isEqualTo(registeredUsers);
}
#end_block

#method_before
@Test
public void updateGroupRefPermissions() throws Exception {
    ProjectAccessInput accessInput = newProjectAccessInput();
    accessInput.add.put(RefNames.REFS_GROUPS + "*", createDefaultAccessSectionInfo());
    exception.expect(BadRequestException.class);
    exception.expectMessage("Permissions on refs/groups/ is managed by Gerrit and cannot be modified");
    gApi.projects().name(allProjects.get()).access(accessInput);
}
#method_after
@Test
public void updateGroupRefPermissions() throws Exception {
    ProjectAccessInput accessInput = newProjectAccessInput();
    accessInput.add.put(RefNames.REFS_GROUPS + "*", createDefaultAccessSectionInfo());
    exception.expect(BadRequestException.class);
    exception.expectMessage("permissions on refs/groups/ are managed by gerrit and cannot be modified");
    gApi.projects().name(allProjects.get()).access(accessInput);
}
#end_block

#method_before
@Test
public void allUsersCanOnlyInheritFromAllProjects() throws Exception {
    ProjectAccessInput accessInput = newProjectAccessInput();
    accessInput.parent = project.get();
    exception.expect(BadRequestException.class);
    exception.expectMessage("All-Users must inherit from All-Projects");
    gApi.projects().name("All-Users").access(accessInput);
}
#method_after
@Test
public void allUsersCanOnlyInheritFromAllProjects() throws Exception {
    ProjectAccessInput accessInput = newProjectAccessInput();
    accessInput.parent = project.get();
    exception.expect(BadRequestException.class);
    exception.expectMessage(allUsers.get() + " must inherit from " + allProjects.get());
    gApi.projects().name(allUsers.get()).access(accessInput);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (REFS_CONFIG.equals(branch.get())) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        try {
            ProjectConfig cfg = new ProjectConfig(receiveEvent.project.getNameKey());
            cfg.load(rw, receiveEvent.command.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:", messages);
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage(), messages);
                }
                throw new ConfigInvalidException("invalid project configuration");
            }
            if (allUsers.equals(receiveEvent.project.getNameKey()) || allProjects.equals(receiveEvent.project.getNameKey())) {
                // Check if the new config modifies any access sections for refs/groups/. These are
                // managed by Gerrit and modifications are not allowed.
                Set<AccessSection> diff = Sets.symmetricDifference(new HashSet<>(projectState.getConfig().getAccessSections()), new HashSet<>(cfg.getAccessSections()));
                boolean modifiesGroupsAccessSection = diff.stream().filter(as -> as.getName().startsWith(RefNames.REFS_GROUPS)).findAny().isPresent();
                if (modifiesGroupsAccessSection) {
                    addError("Invalid project configuration:", messages);
                    addError(String.format("  Permissions on %s is managed by Gerrit and cannot be modified", RefNames.REFS_GROUPS), messages);
                    throw new ConfigInvalidException("invalid project configuration");
                }
            }
            if (allUsers.equals(receiveEvent.project.getNameKey()) && !allProjects.equals(cfg.getProject().getParent(allProjects))) {
                addError("Invalid project configuration:", messages);
                addError(String.format("  %s must inherit from %s", allUsers.get(), allProjects.get()), messages);
                throw new ConfigInvalidException("invalid project configuration");
            }
        } catch (ConfigInvalidException | IOException e) {
            log.error("User " + user.getUserName() + " tried to push an invalid project configuration " + receiveEvent.command.getNewId().name() + " for project " + receiveEvent.project, e);
            throw new CommitValidationException("invalid project configuration", messages);
        }
    }
    if (allUsers.equals(branch.getParentKey()) && RefNames.isRefsUsers(branch.get())) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        Account.Id accountId = Account.Id.fromRef(branch.get());
        if (accountId != null) {
            try {
                WatchConfig wc = new WatchConfig(accountId);
                wc.load(rw, receiveEvent.command.getNewId());
                if (!wc.getValidationErrors().isEmpty()) {
                    addError("Invalid project configuration:", messages);
                    for (ValidationError err : wc.getValidationErrors()) {
                        addError("  " + err.getMessage(), messages);
                    }
                    throw new ConfigInvalidException("invalid watch configuration");
                }
            } catch (IOException | ConfigInvalidException e) {
                log.error("User " + user.getUserName() + " tried to push an invalid watch configuration " + receiveEvent.command.getNewId().name() + " for account " + accountId.get(), e);
                throw new CommitValidationException("invalid watch configuration", messages);
            }
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (REFS_CONFIG.equals(branch.get())) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        try {
            ProjectConfig cfg = new ProjectConfig(receiveEvent.project.getNameKey());
            cfg.load(rw, receiveEvent.command.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:", messages);
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage(), messages);
                }
                throw new ConfigInvalidException("invalid project configuration");
            }
            if (allUsers.equals(receiveEvent.project.getNameKey()) || allProjects.equals(receiveEvent.project.getNameKey())) {
                // Check if the new config modifies any access sections for refs/groups/. These are
                // managed by Gerrit and modifications are not allowed.
                Set<AccessSection> diff = Sets.symmetricDifference(new HashSet<>(projectState.getConfig().getAccessSections()), new HashSet<>(cfg.getAccessSections()));
                boolean modifiesGroupsAccessSection = diff.stream().filter(as -> as.getName().startsWith(RefNames.REFS_GROUPS)).findAny().isPresent();
                if (modifiesGroupsAccessSection) {
                    addError("Invalid project configuration:", messages);
                    addError(String.format("  permissions on %s are managed by gerrit and cannot be modified", RefNames.REFS_GROUPS), messages);
                    throw new ConfigInvalidException("invalid project configuration");
                }
            }
            if (allUsers.equals(receiveEvent.project.getNameKey()) && !allProjects.equals(cfg.getProject().getParent(allProjects))) {
                addError("Invalid project configuration:", messages);
                addError(String.format("  %s must inherit from %s", allUsers.get(), allProjects.get()), messages);
                throw new ConfigInvalidException("invalid project configuration");
            }
        } catch (ConfigInvalidException | IOException e) {
            log.error("User " + user.getUserName() + " tried to push an invalid project configuration " + receiveEvent.command.getNewId().name() + " for project " + receiveEvent.project, e);
            throw new CommitValidationException("invalid project configuration", messages);
        }
    }
    if (allUsers.equals(branch.getParentKey()) && RefNames.isRefsUsers(branch.get())) {
        List<CommitValidationMessage> messages = new ArrayList<>();
        Account.Id accountId = Account.Id.fromRef(branch.get());
        if (accountId != null) {
            try {
                WatchConfig wc = new WatchConfig(accountId);
                wc.load(rw, receiveEvent.command.getNewId());
                if (!wc.getValidationErrors().isEmpty()) {
                    addError("Invalid project configuration:", messages);
                    for (ValidationError err : wc.getValidationErrors()) {
                        addError("  " + err.getMessage(), messages);
                    }
                    throw new ConfigInvalidException("invalid watch configuration");
                }
            } catch (IOException | ConfigInvalidException e) {
                log.error("User " + user.getUserName() + " tried to push an invalid watch configuration " + receiveEvent.command.getNewId().name() + " for account " + accountId.get(), e);
                throw new CommitValidationException("invalid watch configuration", messages);
            }
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (!(o instanceof AccountGroup)) {
        return false;
    }
    AccountGroup g = (AccountGroup) o;
    return name.equals(g.name) && groupId.equals(g.groupId) && Objects.equals(description, g.description) && visibleToAll == g.visibleToAll && groupUUID.equals(g.groupUUID) && ownerGroupUUID.equals(g.ownerGroupUUID) && Objects.equals(createdOn, g.createdOn);
}
#method_after
@Override
public boolean equals(Object o) {
    if (!(o instanceof AccountGroup)) {
        return false;
    }
    AccountGroup g = (AccountGroup) o;
    return Objects.equals(name, g.name) && Objects.equals(groupId, g.groupId) && Objects.equals(description, g.description) && visibleToAll == g.visibleToAll && Objects.equals(groupUUID, g.groupUUID) && Objects.equals(ownerGroupUUID, g.ownerGroupUUID) && // Treat created on epoch identical regardless if underlying value is null.
    getCreatedOn().equals(g.getCreatedOn());
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    return (o instanceof AccountGroupById) && ((AccountGroupById) o).key.equals(key);
}
#method_after
@Override
public boolean equals(Object o) {
    return (o instanceof AccountGroupById) && Objects.equals(key, ((AccountGroupById) o).key);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (!(o instanceof AccountGroupByIdAud)) {
        return false;
    }
    AccountGroupByIdAud a = (AccountGroupByIdAud) o;
    return key.equals(a.key) && addedBy.equals(a.addedBy) && Objects.equals(removedBy, a.removedBy) && Objects.equals(removedOn, a.removedOn);
}
#method_after
@Override
public boolean equals(Object o) {
    if (!(o instanceof AccountGroupByIdAud)) {
        return false;
    }
    AccountGroupByIdAud a = (AccountGroupByIdAud) o;
    return Objects.equals(key, a.key) && Objects.equals(addedBy, a.addedBy) && Objects.equals(removedBy, a.removedBy) && Objects.equals(removedOn, a.removedOn);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    return (o instanceof AccountGroupMember) && ((AccountGroupMember) o).key.equals(key);
}
#method_after
@Override
public boolean equals(Object o) {
    return (o instanceof AccountGroupMember) && Objects.equals(key, ((AccountGroupMember) o).key);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (!(o instanceof AccountGroupMemberAudit)) {
        return false;
    }
    AccountGroupMemberAudit a = (AccountGroupMemberAudit) o;
    return key.equals(a.key) && addedBy.equals(a.addedBy) && Objects.equals(removedBy, a.removedBy) && Objects.equals(removedOn, a.removedOn);
}
#method_after
@Override
public boolean equals(Object o) {
    if (!(o instanceof AccountGroupMemberAudit)) {
        return false;
    }
    AccountGroupMemberAudit a = (AccountGroupMemberAudit) o;
    return Objects.equals(key, a.key) && Objects.equals(addedBy, a.addedBy) && Objects.equals(removedBy, a.removedBy) && Objects.equals(removedOn, a.removedOn);
}
#end_block

#method_before
private void checkResult(RefUpdate.Result result) throws OrmException {
    if (!refUpdated(result)) {
        throw new OrmException("failed to update " + refName + ": " + result);
    }
}
#method_after
private void checkResult(RefUpdate.Result result) throws OrmException {
    if (!refUpdated(result) && result != Result.NO_CHANGE) {
        throw new OrmException("failed to update " + refName + ": " + result);
    }
}
#end_block

#method_before
@Test
public void version() {
    boolean eclipse = Arrays.stream(Thread.currentThread().getStackTrace()).anyMatch(e -> e.getClassName().startsWith("org.eclipse.jdt."));
    Pattern expected = eclipse ? // Different source line so it shows up in coverage.
    DEV_PATTERN : GIT_DESCRIBE_PATTERN;
    assertThat(Version.getVersion()).matches(expected);
    assertThat(Version.getVersion()).matches(expected);
}
#method_after
@Test
public void version() {
    Pattern expected = GerritLauncher.isRunningInEclipse() ? // Different source line so it shows up in coverage.
    DEV_PATTERN : GIT_DESCRIBE_PATTERN;
    assertThat(Version.getVersion()).matches(expected);
    // Try again in case of caching issues.
    assertThat(Version.getVersion()).matches(expected);
}
#end_block

#method_before
@Test
public void gitDescribePattern() {
    assertThat("2.15-rc0").matches(GIT_DESCRIBE_PATTERN);
    assertThat("2.15-rc1").matches(GIT_DESCRIBE_PATTERN);
    assertThat("2.15").matches(GIT_DESCRIBE_PATTERN);
    assertThat("2.15.1").matches(GIT_DESCRIBE_PATTERN);
    assertThat("2.15.1.2").matches(GIT_DESCRIBE_PATTERN);
    assertThat("2.15.1.2.3").matches(GIT_DESCRIBE_PATTERN);
    assertThat("2.15.1-rc1").matches(GIT_DESCRIBE_PATTERN);
    assertThat("2.15-rc2-123-gabcd123").matches(GIT_DESCRIBE_PATTERN);
    assertThat("2.15-123-gabcd123").matches(GIT_DESCRIBE_PATTERN);
    assertThat("(dev)").doesNotMatch(GIT_DESCRIBE_PATTERN);
    assertThat("1").doesNotMatch(GIT_DESCRIBE_PATTERN);
    assertThat("v2.15").doesNotMatch(GIT_DESCRIBE_PATTERN);
}
#method_after
@Test
public void gitDescribePattern() {
    for (String suffix : ImmutableList.of("", "-dirty")) {
        assertThat("2.15-rc0" + suffix).matches(GIT_DESCRIBE_PATTERN);
        assertThat("2.15-rc0" + suffix).matches(GIT_DESCRIBE_PATTERN);
        assertThat("2.15-rc1" + suffix).matches(GIT_DESCRIBE_PATTERN);
        assertThat("2.15" + suffix).matches(GIT_DESCRIBE_PATTERN);
        assertThat("2.15.1" + suffix).matches(GIT_DESCRIBE_PATTERN);
        assertThat("2.15.1.2" + suffix).matches(GIT_DESCRIBE_PATTERN);
        assertThat("2.15.1.2.3" + suffix).matches(GIT_DESCRIBE_PATTERN);
        assertThat("2.15.1-rc1" + suffix).matches(GIT_DESCRIBE_PATTERN);
        assertThat("2.15-rc2-123-gabcd123" + suffix).matches(GIT_DESCRIBE_PATTERN);
        assertThat("2.15-123-gabcd123" + suffix).matches(GIT_DESCRIBE_PATTERN);
    }
    assertThat("2.15-ugly").doesNotMatch(GIT_DESCRIBE_PATTERN);
    assertThat("(dev)").doesNotMatch(GIT_DESCRIBE_PATTERN);
    assertThat("1").doesNotMatch(GIT_DESCRIBE_PATTERN);
    assertThat("v2.15").doesNotMatch(GIT_DESCRIBE_PATTERN);
}
#end_block

#method_before
public static String getVersion() {
    return version;
}
#method_after
public static String getVersion() {
    return VERSION;
}
#end_block

#method_before
@Override
public void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException {
    manager.setCheckExpectedState(false).setRefLogMessage("Rebuilding change");
    Change change = new Change(bundle.getChange());
    if (bundle.getPatchSets().isEmpty()) {
        throw new NoPatchSetsException(change.getId());
    }
    if (change.getLastUpdatedOn().compareTo(change.getCreatedOn()) < 0) {
        // Certain bad MySQL dump imports might set created_on (and a host of other timestamps) to the
        // time the dump was imported. The correct timestamps were lost, but we can at least set it so
        // created_on is not after last_updated_on.
        // See https://bugs.chromium.org/p/gerrit/issues/detail?id=7397
        change.setCreatedOn(change.getLastUpdatedOn());
    }
    // We will rebuild all events, except for draft comments, in buckets based on author and
    // timestamp.
    List<Event> events = new ArrayList<>();
    ListMultimap<Account.Id, DraftCommentEvent> draftCommentEvents = MultimapBuilder.hashKeys().arrayListValues().build();
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read.
    deleteChangeMetaRef(change, manager.getChangeRepo().cmds);
    deleteDraftRefs(change, manager.getAllUsersRepo());
    Integer minPsNum = getMinPatchSetNum(bundle);
    TreeMap<PatchSet.Id, PatchSetEvent> patchSetEvents = new TreeMap<>(ReviewDbUtil.intKeyOrdering());
    for (PatchSet ps : bundle.getPatchSets()) {
        PatchSetEvent pse = new PatchSetEvent(change, ps, manager.getChangeRepo().rw);
        patchSetEvents.put(ps.getId(), pse);
        events.add(pse);
        for (Comment c : getComments(bundle, serverId, Status.PUBLISHED, ps)) {
            CommentEvent e = new CommentEvent(c, change, ps, patchListCache);
            events.add(e.addDep(pse));
        }
        for (Comment c : getComments(bundle, serverId, Status.DRAFT, ps)) {
            DraftCommentEvent e = new DraftCommentEvent(c, change, ps, patchListCache);
            draftCommentEvents.put(c.author.getId(), e);
        }
    }
    ensurePatchSetOrder(patchSetEvents);
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        PatchSetEvent pse = patchSetEvents.get(psa.getPatchSetId());
        if (pse != null) {
            events.add(new ApprovalEvent(psa, change.getCreatedOn()).addDep(pse));
        }
    }
    for (Table.Cell<ReviewerStateInternal, Account.Id, Timestamp> r : bundle.getReviewers().asTable().cellSet()) {
        events.add(new ReviewerEvent(r, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        Event msgEvent = new ChangeMessageEvent(change, noteDbChange, msg, change.getCreatedOn());
        if (msg.getPatchSetId() != null) {
            PatchSetEvent pse = patchSetEvents.get(msg.getPatchSetId());
            if (pse == null) {
                // Ignore events for missing patch sets.
                continue;
            }
            msgEvent.addDep(pse);
        }
        events.add(msgEvent);
    }
    sortAndFillEvents(change, noteDbChange, bundle.getPatchSets(), events, minPsNum);
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<DraftCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (DraftCommentEvent e : Ordering.natural().sortedCopy(draftCommentEvents.get(author))) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#method_after
@Override
public void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) throws IOException, OrmException {
    manager.setCheckExpectedState(false).setRefLogMessage("Rebuilding change");
    Change change = new Change(bundle.getChange());
    if (bundle.getPatchSets().isEmpty()) {
        throw new NoPatchSetsException(change.getId());
    }
    if (change.getLastUpdatedOn().compareTo(change.getCreatedOn()) < 0) {
        // A bug in data migration might set created_on to the time of the migration. The
        // correct timestamps were lost, but we can at least set it so created_on is not after
        // last_updated_on.
        // See https://bugs.chromium.org/p/gerrit/issues/detail?id=7397
        change.setCreatedOn(change.getLastUpdatedOn());
    }
    // We will rebuild all events, except for draft comments, in buckets based on author and
    // timestamp.
    List<Event> events = new ArrayList<>();
    ListMultimap<Account.Id, DraftCommentEvent> draftCommentEvents = MultimapBuilder.hashKeys().arrayListValues().build();
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read.
    deleteChangeMetaRef(change, manager.getChangeRepo().cmds);
    deleteDraftRefs(change, manager.getAllUsersRepo());
    Integer minPsNum = getMinPatchSetNum(bundle);
    TreeMap<PatchSet.Id, PatchSetEvent> patchSetEvents = new TreeMap<>(ReviewDbUtil.intKeyOrdering());
    for (PatchSet ps : bundle.getPatchSets()) {
        PatchSetEvent pse = new PatchSetEvent(change, ps, manager.getChangeRepo().rw);
        patchSetEvents.put(ps.getId(), pse);
        events.add(pse);
        for (Comment c : getComments(bundle, serverId, Status.PUBLISHED, ps)) {
            CommentEvent e = new CommentEvent(c, change, ps, patchListCache);
            events.add(e.addDep(pse));
        }
        for (Comment c : getComments(bundle, serverId, Status.DRAFT, ps)) {
            DraftCommentEvent e = new DraftCommentEvent(c, change, ps, patchListCache);
            draftCommentEvents.put(c.author.getId(), e);
        }
    }
    ensurePatchSetOrder(patchSetEvents);
    for (PatchSetApproval psa : bundle.getPatchSetApprovals()) {
        PatchSetEvent pse = patchSetEvents.get(psa.getPatchSetId());
        if (pse != null) {
            events.add(new ApprovalEvent(psa, change.getCreatedOn()).addDep(pse));
        }
    }
    for (Table.Cell<ReviewerStateInternal, Account.Id, Timestamp> r : bundle.getReviewers().asTable().cellSet()) {
        events.add(new ReviewerEvent(r, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : bundle.getChangeMessages()) {
        Event msgEvent = new ChangeMessageEvent(change, noteDbChange, msg, change.getCreatedOn());
        if (msg.getPatchSetId() != null) {
            PatchSetEvent pse = patchSetEvents.get(msg.getPatchSetId());
            if (pse == null) {
                // Ignore events for missing patch sets.
                continue;
            }
            msgEvent.addDep(pse);
        }
        events.add(msgEvent);
    }
    sortAndFillEvents(change, noteDbChange, bundle.getPatchSets(), events, minPsNum);
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(manager, el, change);
    EventList<DraftCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (DraftCommentEvent e : Ordering.natural().sortedCopy(draftCommentEvents.get(author))) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(manager, plcel, change);
    }
}
#end_block

#method_before
private static void diffChanges(List<String> diffs, ChangeBundle bundleA, ChangeBundle bundleB) {
    Change a = bundleA.change;
    Change b = bundleB.change;
    String desc = a.getId().equals(b.getId()) ? describe(a.getId()) : "Changes";
    boolean excludeCreatedOn = false;
    boolean excludeCurrentPatchSetId = false;
    boolean excludeTopic = false;
    Timestamp aCreated = a.getCreatedOn();
    Timestamp bCreated = b.getCreatedOn();
    Timestamp aUpdated = a.getLastUpdatedOn();
    Timestamp bUpdated = b.getLastUpdatedOn();
    boolean excludeSubject = false;
    boolean excludeOrigSubj = false;
    // Subject is not technically a nullable field, but we observed some null
    // subjects in the wild on googlesource.com, so treat null as empty.
    String aSubj = Strings.nullToEmpty(a.getSubject());
    String bSubj = Strings.nullToEmpty(b.getSubject());
    // Use max timestamp of all ReviewDb entities when comparing with NoteDb.
    if (bundleA.source == REVIEW_DB && bundleB.source == NOTE_DB) {
        boolean createdOnMatchesFirstPs = !timestampsDiffer(bundleA, bundleA.getFirstPatchSetTime(), bundleB, bCreated);
        boolean createdOnMatchesLastUpdatedOn = !timestampsDiffer(bundleA, aUpdated, bundleB, bCreated);
        boolean createdAfterUpdated = aCreated.compareTo(aUpdated) > 0;
        excludeCreatedOn = createdOnMatchesFirstPs || (createdAfterUpdated && createdOnMatchesLastUpdatedOn);
        aSubj = cleanReviewDbSubject(aSubj);
        bSubj = cleanNoteDbSubject(bSubj);
        excludeCurrentPatchSetId = !bundleA.validPatchSetPredicate().apply(a.currentPatchSetId());
        excludeSubject = bSubj.startsWith(aSubj) || excludeCurrentPatchSetId;
        excludeOrigSubj = true;
        String aTopic = trimOrNull(a.getTopic());
        excludeTopic = Objects.equals(aTopic, b.getTopic()) || "".equals(aTopic) && b.getTopic() == null;
        aUpdated = bundleA.getLatestTimestamp();
    } else if (bundleA.source == NOTE_DB && bundleB.source == REVIEW_DB) {
        boolean createdOnMatchesFirstPs = !timestampsDiffer(bundleA, a.getCreatedOn(), bundleB, bundleB.getFirstPatchSetTime());
        boolean createdOnMatchesLastUpdatedOn = !timestampsDiffer(bundleA, aCreated, bundleB, bUpdated);
        boolean createdAfterUpdated = bCreated.compareTo(bUpdated) > 0;
        excludeCreatedOn = createdOnMatchesFirstPs || (createdAfterUpdated && createdOnMatchesLastUpdatedOn);
        aSubj = cleanNoteDbSubject(aSubj);
        bSubj = cleanReviewDbSubject(bSubj);
        excludeCurrentPatchSetId = !bundleB.validPatchSetPredicate().apply(b.currentPatchSetId());
        excludeSubject = aSubj.startsWith(bSubj) || excludeCurrentPatchSetId;
        excludeOrigSubj = true;
        String bTopic = trimOrNull(b.getTopic());
        excludeTopic = Objects.equals(bTopic, a.getTopic()) || a.getTopic() == null && "".equals(bTopic);
        bUpdated = bundleB.getLatestTimestamp();
    }
    String subjectField = "subject";
    String updatedField = "lastUpdatedOn";
    List<String> exclude = Lists.newArrayList(subjectField, updatedField, "noteDbState", "rowVersion");
    if (excludeCreatedOn) {
        exclude.add("createdOn");
    }
    if (excludeCurrentPatchSetId) {
        exclude.add("currentPatchSetId");
    }
    if (excludeOrigSubj) {
        exclude.add("originalSubject");
    }
    if (excludeTopic) {
        exclude.add("topic");
    }
    diffColumnsExcluding(diffs, Change.class, desc, bundleA, a, bundleB, b, exclude);
    // whole ReviewDb bundle (within slop).
    if (timestampsDiffer(bundleA, a.getLastUpdatedOn(), bundleB, b.getLastUpdatedOn())) {
        diffTimestamps(diffs, desc, bundleA, aUpdated, bundleB, bUpdated, "effective last updated time");
    }
    if (!excludeSubject) {
        diffValues(diffs, desc, aSubj, bSubj, subjectField);
    }
}
#method_after
private static void diffChanges(List<String> diffs, ChangeBundle bundleA, ChangeBundle bundleB) {
    Change a = bundleA.change;
    Change b = bundleB.change;
    String desc = a.getId().equals(b.getId()) ? describe(a.getId()) : "Changes";
    boolean excludeCreatedOn = false;
    boolean excludeCurrentPatchSetId = false;
    boolean excludeTopic = false;
    Timestamp aCreated = a.getCreatedOn();
    Timestamp bCreated = b.getCreatedOn();
    Timestamp aUpdated = a.getLastUpdatedOn();
    Timestamp bUpdated = b.getLastUpdatedOn();
    boolean excludeSubject = false;
    boolean excludeOrigSubj = false;
    // Subject is not technically a nullable field, but we observed some null
    // subjects in the wild on googlesource.com, so treat null as empty.
    String aSubj = Strings.nullToEmpty(a.getSubject());
    String bSubj = Strings.nullToEmpty(b.getSubject());
    // Use max timestamp of all ReviewDb entities when comparing with NoteDb.
    if (bundleA.source == REVIEW_DB && bundleB.source == NOTE_DB) {
        boolean createdOnMatchesFirstPs = !timestampsDiffer(bundleA, bundleA.getFirstPatchSetTime(), bundleB, bCreated);
        boolean createdOnMatchesLastUpdatedOn = !timestampsDiffer(bundleA, aUpdated, bundleB, bCreated);
        boolean createdAfterUpdated = aCreated.compareTo(aUpdated) > 0;
        excludeCreatedOn = createdOnMatchesFirstPs || (createdAfterUpdated && createdOnMatchesLastUpdatedOn);
        aSubj = cleanReviewDbSubject(aSubj);
        bSubj = cleanNoteDbSubject(bSubj);
        excludeCurrentPatchSetId = !bundleA.validPatchSetPredicate().apply(a.currentPatchSetId());
        excludeSubject = bSubj.startsWith(aSubj) || excludeCurrentPatchSetId;
        excludeOrigSubj = true;
        String aTopic = trimOrNull(a.getTopic());
        excludeTopic = Objects.equals(aTopic, b.getTopic()) || "".equals(aTopic) && b.getTopic() == null;
        aUpdated = bundleA.getLatestTimestamp();
    } else if (bundleA.source == NOTE_DB && bundleB.source == REVIEW_DB) {
        boolean createdOnMatchesFirstPs = !timestampsDiffer(bundleA, aCreated, bundleB, bundleB.getFirstPatchSetTime());
        boolean createdOnMatchesLastUpdatedOn = !timestampsDiffer(bundleA, aCreated, bundleB, bUpdated);
        boolean createdAfterUpdated = bCreated.compareTo(bUpdated) > 0;
        excludeCreatedOn = createdOnMatchesFirstPs || (createdAfterUpdated && createdOnMatchesLastUpdatedOn);
        aSubj = cleanNoteDbSubject(aSubj);
        bSubj = cleanReviewDbSubject(bSubj);
        excludeCurrentPatchSetId = !bundleB.validPatchSetPredicate().apply(b.currentPatchSetId());
        excludeSubject = aSubj.startsWith(bSubj) || excludeCurrentPatchSetId;
        excludeOrigSubj = true;
        String bTopic = trimOrNull(b.getTopic());
        excludeTopic = Objects.equals(bTopic, a.getTopic()) || a.getTopic() == null && "".equals(bTopic);
        bUpdated = bundleB.getLatestTimestamp();
    }
    String subjectField = "subject";
    String updatedField = "lastUpdatedOn";
    List<String> exclude = Lists.newArrayList(subjectField, updatedField, "noteDbState", "rowVersion");
    if (excludeCreatedOn) {
        exclude.add("createdOn");
    }
    if (excludeCurrentPatchSetId) {
        exclude.add("currentPatchSetId");
    }
    if (excludeOrigSubj) {
        exclude.add("originalSubject");
    }
    if (excludeTopic) {
        exclude.add("topic");
    }
    diffColumnsExcluding(diffs, Change.class, desc, bundleA, a, bundleB, b, exclude);
    // whole ReviewDb bundle (within slop).
    if (timestampsDiffer(bundleA, a.getLastUpdatedOn(), bundleB, b.getLastUpdatedOn())) {
        diffTimestamps(diffs, desc, bundleA, aUpdated, bundleB, bUpdated, "effective last updated time");
    }
    if (!excludeSubject) {
        diffValues(diffs, desc, aSubj, bSubj, subjectField);
    }
}
#end_block

#method_before
@Override
public void run() {
    try {
        Optional<EventProcessor.Result> content = processor.get();
        if (!content.isPresent()) {
            log.debug("No content. Webhook [{}] skipped.", remote.getUrl());
            return;
        }
        execCnt++;
        HttpResult result = session.post(remote.getUrl(), content.get().headers, remote, content.get().body);
        if (!result.successful && execCnt < remote.getMaxTries()) {
            logRetry(result.message);
            reschedule();
        }
    } catch (IOException e) {
        if (isRecoverable(e) && execCnt < remote.getMaxTries()) {
            logRetry(e);
            reschedule();
        } else {
            log.error("Failed to post: {}", toString(), e);
        }
    }
}
#method_after
@Override
public void run() {
    try {
        Optional<EventProcessor.Request> content = processor.get();
        if (!content.isPresent()) {
            log.debug("No content. Webhook [{}] skipped.", remote.getUrl());
            return;
        }
        execCnt++;
        HttpResult result = session.post(remote, content.get());
        if (!result.successful && execCnt < remote.getMaxTries()) {
            logRetry(result.message);
            reschedule();
        }
    } catch (IOException e) {
        if (isRecoverable(e) && execCnt < remote.getMaxTries()) {
            logRetry(e);
            reschedule();
        } else {
            log.error("Failed to post: {}", toString(), e);
        }
    }
}
#end_block

#method_before
@Override
public String toString() {
    Optional<EventProcessor.Result> content = processor.get();
    return content.isPresent() ? content.get().toString() : "no content";
}
#method_after
@Override
public String toString() {
    Optional<EventProcessor.Request> content = processor.get();
    return content.isPresent() ? content.get().toString() : "no content";
}
#end_block

#method_before
@Before
public void setup() {
    when(remote.getRetryInterval()).thenReturn(RETRY_INTERVAL);
    when(remote.getMaxTries()).thenReturn(MAX_TRIES);
    when(remote.getUrl()).thenReturn(WEBHOOK_URL);
    when(processor.process(eq(projectCreated), eq(remote))).thenReturn(CONTENT);
    task = new PostTask(executor, session, processor, projectCreated, remote);
}
#method_after
@Before
public void setup() {
    when(remote.getRetryInterval()).thenReturn(RETRY_INTERVAL);
    when(remote.getMaxTries()).thenReturn(MAX_TRIES);
    when(remote.getUrl()).thenReturn(WEBHOOK_URL);
    when(processor.process(eq(projectCreated), eq(remote))).thenReturn(Optional.of(content));
    task = new PostTask(executor, session, processor, projectCreated, remote);
}
#end_block

#method_before
@Test
public void noRescheduleOnSuccess() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, remote, BODY)).thenReturn(OK_RESULT);
    task.run();
    verifyZeroInteractions(executor);
}
#method_after
@Test
public void noRescheduleOnSuccess() throws IOException {
    when(session.post(eq(remote), eq(content))).thenReturn(OK_RESULT);
    task.run();
    verifyZeroInteractions(executor);
}
#end_block

#method_before
@Test
public void noRescheduleOnNonRecoverableException() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, remote, BODY)).thenThrow(SSLException.class);
    task.run();
    verifyZeroInteractions(executor);
}
#method_after
@Test
public void noRescheduleOnNonRecoverableException() throws IOException {
    when(session.post(eq(remote), eq(content))).thenThrow(SSLException.class);
    task.run();
    verifyZeroInteractions(executor);
}
#end_block

#method_before
@Test
public void rescheduleOnError() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, remote, BODY)).thenReturn(ERR_RESULT);
    task.run();
    verify(executor, times(1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#method_after
@Test
public void rescheduleOnError() throws IOException {
    when(session.post(eq(remote), eq(content))).thenReturn(ERR_RESULT);
    task.run();
    verify(executor, times(1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Test
public void rescheduleOnRecoverableException() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, remote, BODY)).thenThrow(IOException.class);
    task.run();
    verify(executor, times(1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#method_after
@Test
public void rescheduleOnRecoverableException() throws IOException {
    when(session.post(eq(remote), eq(content))).thenThrow(IOException.class);
    task.run();
    verify(executor, times(1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Test
public void keepReschedulingMaxTriesTimes() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, remote, BODY)).thenThrow(IOException.class);
    when(executor.schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS)).then(new Answer<Void>() {

        @Override
        public Void answer(InvocationOnMock invocation) throws Throwable {
            task.run();
            return null;
        }
    });
    task.run();
    verify(executor, times(MAX_TRIES - 1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#method_after
@Test
public void keepReschedulingMaxTriesTimes() throws IOException {
    when(session.post(eq(remote), eq(content))).thenThrow(IOException.class);
    when(executor.schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS)).then(new Answer<Void>() {

        @Override
        public Void answer(InvocationOnMock invocation) throws Throwable {
            task.run();
            return null;
        }
    });
    task.run();
    verify(executor, times(MAX_TRIES - 1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
HttpResult post(String endpoint, Map<String, String> headers, RemoteConfig remote, String content) throws IOException {
    HttpPost post = new HttpPost(endpoint);
    post.addHeader("Content-Type", MediaType.JSON_UTF_8.toString());
    post.setConfig(getConfig(remote));
    headers.entrySet().stream().forEach(e -> {
        post.addHeader(e.getKey(), e.getValue());
    });
    post.setEntity(new StringEntity(content, StandardCharsets.UTF_8));
    return httpClient.execute(post, new HttpResponseHandler());
}
#method_after
HttpResult post(RemoteConfig remote, EventProcessor.Request request) throws IOException {
    HttpPost post = new HttpPost(remote.getUrl());
    post.addHeader("Content-Type", MediaType.JSON_UTF_8.toString());
    post.setConfig(getConfig(remote));
    request.headers.entrySet().stream().forEach(e -> {
        post.addHeader(e.getKey(), e.getValue());
    });
    post.setEntity(new StringEntity(request.body, StandardCharsets.UTF_8));
    return httpClient.execute(post, new HttpResponseHandler());
}
#end_block

#method_before
private void createSubmoduleCommitMsg(StringBuilder msgbuf, SubmoduleSubscription s, OpenRepo subOr, RevCommit newCommit, RevCommit oldCommit) throws SubmoduleException {
    msgbuf.append("* Update " + s.getPath());
    msgbuf.append(" from branch '" + s.getSubmodule().getShortName() + "'");
    msgbuf.append(" to " + newCommit.getName());
    // newly created submodule gitlink, do not append whole history
    if (oldCommit == null) {
        return;
    }
    try {
        subOr.rw.resetRetain(subOr.canMergeFlag);
        subOr.rw.markStart(newCommit);
        subOr.rw.markUninteresting(oldCommit);
        for (RevCommit c : subOr.rw) {
            subOr.rw.parseBody(c);
            if (verboseSuperProject == VerboseSuperprojectUpdate.SUBJECT_ONLY) {
                msgbuf.append("\n  - " + c.getShortMessage());
            } else if (verboseSuperProject == VerboseSuperprojectUpdate.TRUE) {
                msgbuf.append("\n  - " + c.getFullMessage().replace("\n", "\n    "));
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not perform a revwalk to create superproject commit message", e);
    }
}
#method_after
private void createSubmoduleCommitMsg(StringBuilder msgbuf, SubmoduleSubscription s, OpenRepo subOr, RevCommit newCommit, RevCommit oldCommit) throws SubmoduleException {
    msgbuf.append("* Update " + s.getPath());
    msgbuf.append(" from branch '" + s.getSubmodule().getShortName() + "'");
    msgbuf.append("\n  to " + newCommit.getName());
    // newly created submodule gitlink, do not append whole history
    if (oldCommit == null) {
        return;
    }
    try {
        subOr.rw.resetRetain(subOr.canMergeFlag);
        subOr.rw.markStart(newCommit);
        subOr.rw.markUninteresting(oldCommit);
        for (RevCommit c : subOr.rw) {
            subOr.rw.parseBody(c);
            if (verboseSuperProject == VerboseSuperprojectUpdate.SUBJECT_ONLY) {
                msgbuf.append("\n  - " + c.getShortMessage());
            } else if (verboseSuperProject == VerboseSuperprojectUpdate.TRUE) {
                msgbuf.append("\n  - " + c.getFullMessage().replace("\n", "\n    "));
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not perform a revwalk to create superproject commit message", e);
    }
}
#end_block

#method_before
@Test
public void newPatchSetWithVote() throws Exception {
    saveLabelConfig();
    // push a new change
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().message(label.getName());
    revision(r).review(reviewInput);
    // push a new revision with +1 vote
    ChangeInfo c = get(r.getChangeId());
    r = amendChange(c.changeId);
    reviewInput = new ReviewInput().label(label.getName(), (short) 1);
    revision(r).review(reviewInput);
    ApprovalValues attr = getApprovalValues(label);
    assertThat(attr.oldValue).isEqualTo(0);
    assertThat(attr.value).isEqualTo(1);
    assertThat(lastCommentAddedEvent.getComment()).isEqualTo(String.format("Patch Set 2: %s+1", label.getName()));
}
#method_after
@Test
public void newPatchSetWithVote() throws Exception {
    saveLabelConfig();
    // push a new change
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().message(label.getName());
    revision(r).review(reviewInput);
    // push a new revision with +1 vote
    ChangeInfo c = info(r.getChangeId());
    r = amendChange(c.changeId);
    reviewInput = new ReviewInput().label(label.getName(), (short) 1);
    revision(r).review(reviewInput);
    ApprovalValues attr = getApprovalValues(label);
    assertThat(attr.oldValue).isEqualTo(0);
    assertThat(attr.value).isEqualTo(1);
    assertThat(lastCommentAddedEvent.getComment()).isEqualTo(String.format("Patch Set 2: %s+1", label.getName()));
}
#end_block

#method_before
@Test
public void reviewChange_MultipleVotes() throws Exception {
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().label(label.getName(), -1);
    reviewInput.message = label.getName();
    revision(r).review(reviewInput);
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    ApprovalValues labelAttr = getApprovalValues(label);
    assertThat(labelAttr.oldValue).isEqualTo(0);
    assertThat(labelAttr.value).isEqualTo(-1);
    assertThat(lastCommentAddedEvent.getComment()).isEqualTo(String.format("Patch Set 1: %s-1\n\n%s", label.getName(), label.getName()));
    // there should be 3 approval labels (label, pLabel, and CRVV)
    assertThat(lastCommentAddedEvent.getApprovals()).hasSize(3);
    // check the approvals that were not voted on
    ApprovalValues pLabelAttr = getApprovalValues(pLabel);
    assertThat(pLabelAttr.oldValue).isNull();
    assertThat(pLabelAttr.value).isEqualTo(0);
    LabelType crLabel = LabelType.withDefaultValues("Code-Review");
    ApprovalValues crlAttr = getApprovalValues(crLabel);
    assertThat(crlAttr.oldValue).isNull();
    assertThat(crlAttr.value).isEqualTo(0);
    // update pLabel approval
    reviewInput = new ReviewInput().label(pLabel.getName(), 1);
    reviewInput.message = pLabel.getName();
    revision(r).review(reviewInput);
    c = get(r.getChangeId());
    q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    pLabelAttr = getApprovalValues(pLabel);
    assertThat(pLabelAttr.oldValue).isEqualTo(0);
    assertThat(pLabelAttr.value).isEqualTo(1);
    assertThat(lastCommentAddedEvent.getComment()).isEqualTo(String.format("Patch Set 1: %s+1\n\n%s", pLabel.getName(), pLabel.getName()));
    // check the approvals that were not voted on
    labelAttr = getApprovalValues(label);
    assertThat(labelAttr.oldValue).isNull();
    assertThat(labelAttr.value).isEqualTo(-1);
    crlAttr = getApprovalValues(crLabel);
    assertThat(crlAttr.oldValue).isNull();
    assertThat(crlAttr.value).isEqualTo(0);
}
#method_after
@Test
public void reviewChange_MultipleVotes() throws Exception {
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    ReviewInput reviewInput = new ReviewInput().label(label.getName(), -1);
    reviewInput.message = label.getName();
    revision(r).review(reviewInput);
    ChangeInfo c = get(r.getChangeId(), DETAILED_LABELS);
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    ApprovalValues labelAttr = getApprovalValues(label);
    assertThat(labelAttr.oldValue).isEqualTo(0);
    assertThat(labelAttr.value).isEqualTo(-1);
    assertThat(lastCommentAddedEvent.getComment()).isEqualTo(String.format("Patch Set 1: %s-1\n\n%s", label.getName(), label.getName()));
    // there should be 3 approval labels (label, pLabel, and CRVV)
    assertThat(lastCommentAddedEvent.getApprovals()).hasSize(3);
    // check the approvals that were not voted on
    ApprovalValues pLabelAttr = getApprovalValues(pLabel);
    assertThat(pLabelAttr.oldValue).isNull();
    assertThat(pLabelAttr.value).isEqualTo(0);
    LabelType crLabel = LabelType.withDefaultValues("Code-Review");
    ApprovalValues crlAttr = getApprovalValues(crLabel);
    assertThat(crlAttr.oldValue).isNull();
    assertThat(crlAttr.value).isEqualTo(0);
    // update pLabel approval
    reviewInput = new ReviewInput().label(pLabel.getName(), 1);
    reviewInput.message = pLabel.getName();
    revision(r).review(reviewInput);
    c = get(r.getChangeId(), DETAILED_LABELS);
    q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    pLabelAttr = getApprovalValues(pLabel);
    assertThat(pLabelAttr.oldValue).isEqualTo(0);
    assertThat(pLabelAttr.value).isEqualTo(1);
    assertThat(lastCommentAddedEvent.getComment()).isEqualTo(String.format("Patch Set 1: %s+1\n\n%s", pLabel.getName(), pLabel.getName()));
    // check the approvals that were not voted on
    labelAttr = getApprovalValues(label);
    assertThat(labelAttr.oldValue).isNull();
    assertThat(labelAttr.value).isEqualTo(-1);
    crlAttr = getApprovalValues(crLabel);
    assertThat(crlAttr.oldValue).isNull();
    assertThat(crlAttr.value).isEqualTo(0);
}
#end_block

#method_before
private static AccountState newState(Account account) {
    return new AccountState(new AllUsersName(AllUsersNameProvider.DEFAULT), account, ImmutableSet.of(), ImmutableSet.of(), new HashMap<>());
}
#method_after
private static AccountState newState(Account account) {
    return new AccountState(new AllUsersName(AllUsersNameProvider.DEFAULT), account, ImmutableSet.of(), new HashMap<>());
}
#end_block

#method_before
@Test
public void customLabelNoOp_NegativeVoteNotBlock() throws Exception {
    label.setFunctionName("NoOp");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#method_after
@Test
public void customLabelNoOp_NegativeVoteNotBlock() throws Exception {
    label.setFunction(NO_OP);
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = getWithLabels(r);
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.approved).isNull();
    assertThat(q.recommended).isNull();
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#end_block

#method_before
@Test
public void customLabelNoBlock_NegativeVoteNotBlock() throws Exception {
    label.setFunctionName("NoBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#method_after
@Test
public void customLabelNoBlock_NegativeVoteNotBlock() throws Exception {
    label.setFunction(NO_BLOCK);
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = getWithLabels(r);
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.approved).isNull();
    assertThat(q.recommended).isNull();
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#end_block

#method_before
@Test
public void customLabelMaxNoBlock_NegativeVoteNotBlock() throws Exception {
    label.setFunctionName("MaxNoBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#method_after
@Test
public void customLabelMaxNoBlock_NegativeVoteNotBlock() throws Exception {
    label.setFunction(MAX_NO_BLOCK);
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = getWithLabels(r);
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.approved).isNull();
    assertThat(q.recommended).isNull();
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#end_block

#method_before
@Test
public void customLabelAnyWithBlock_NegativeVoteBlock() throws Exception {
    label.setFunctionName("AnyWithBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#method_after
@Test
public void customLabelAnyWithBlock_NegativeVoteBlock() throws Exception {
    label.setFunction(ANY_WITH_BLOCK);
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = getWithLabels(r);
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.approved).isNull();
    assertThat(q.recommended).isNull();
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#end_block

#method_before
@Test
public void customLabelAnyWithBlock_Addreviewer_ZeroVote() throws Exception {
    P.setFunctionName("AnyWithBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    ReviewInput input = new ReviewInput().label(P.getName(), 0);
    input.message = "foo";
    revision(r).review(input);
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(P.getName());
    assertThat(q.all).hasSize(2);
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNull();
    assertThat(q.blocking).isNull();
    assertThat(lastCommentAddedEvent.getComment()).isEqualTo("Patch Set 1:\n\n" + input.message);
}
#method_after
@Test
public void customLabelAnyWithBlock_Addreviewer_ZeroVote() throws Exception {
    P.setFunction(ANY_WITH_BLOCK);
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    ReviewInput input = new ReviewInput().label(P.getName(), 0);
    input.message = "foo";
    revision(r).review(input);
    ChangeInfo c = getWithLabels(r);
    LabelInfo q = c.labels.get(P.getName());
    assertThat(q.all).hasSize(2);
    assertThat(q.approved).isNull();
    assertThat(q.recommended).isNull();
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNull();
    assertThat(q.blocking).isNull();
    assertThat(lastCommentAddedEvent.getComment()).isEqualTo("Patch Set 1:\n\n" + input.message);
}
#end_block

#method_before
@Test
public void customLabelMaxWithBlock_NegativeVoteBlock() throws Exception {
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#method_after
@Test
public void customLabelMaxWithBlock_NegativeVoteBlock() throws Exception {
    label.setFunction(MAX_WITH_BLOCK);
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(label.getName(), -1));
    ChangeInfo c = getWithLabels(r);
    LabelInfo q = c.labels.get(label.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.approved).isNull();
    assertThat(q.recommended).isNull();
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#end_block

#method_before
@Test
public void customLabel_DisallowPostSubmit() throws Exception {
    label.setFunctionName("NoOp");
    label.setAllowPostSubmit(false);
    P.setFunctionName("NoOp");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(ReviewInput.approve());
    revision(r).submit();
    ChangeInfo info = get(r.getChangeId(), ListChangesOption.DETAILED_LABELS);
    assertPermitted(info, "Code-Review", 2);
    assertPermitted(info, P.getName(), 0, 1);
    assertPermitted(info, label.getName());
    ReviewInput in = new ReviewInput();
    in.label(P.getName(), P.getMax().getValue());
    revision(r).review(in);
    in = new ReviewInput();
    in.label(label.getName(), label.getMax().getValue());
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Voting on labels disallowed after submit: " + label.getName());
    revision(r).review(in);
}
#method_after
@Test
public void customLabel_DisallowPostSubmit() throws Exception {
    label.setFunction(NO_OP);
    label.setAllowPostSubmit(false);
    P.setFunction(NO_OP);
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(ReviewInput.approve());
    revision(r).submit();
    ChangeInfo info = getWithLabels(r);
    assertPermitted(info, "Code-Review", 2);
    assertPermitted(info, P.getName(), 0, 1);
    assertPermitted(info, label.getName());
    ReviewInput in = new ReviewInput();
    in.label(P.getName(), P.getMax().getValue());
    revision(r).review(in);
    in = new ReviewInput();
    in.label(label.getName(), label.getMax().getValue());
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Voting on labels disallowed after submit: " + label.getName());
    revision(r).review(in);
}
#end_block

#method_before
@Test
public void byStatus() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    ChangeInserter ins2 = newChangeWithStatus(repo, Change.Status.MERGED);
    Change change2 = insert(repo, ins2);
    assertQuery("status:new", change1);
    assertQuery("status:NEW", change1);
    assertQuery("is:new", change1);
    assertQuery("status:merged", change2);
    assertQuery("is:merged", change2);
}
#method_after
@Test
public void byStatus() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    ChangeInserter ins2 = newChangeWithStatus(repo, Change.Status.MERGED);
    Change change2 = insert(repo, ins2);
    assertQuery("status:new", change1);
    assertQuery("status:NEW", change1);
    assertQuery("is:new", change1);
    assertQuery("status:merged", change2);
    assertQuery("is:merged", change2);
    assertQuery("status:draft");
    assertQuery("is:draft");
}
#end_block

#method_before
@Test
public void byStatusOpen() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    ChangeInserter ins2 = newChangeWithStatus(repo, Change.Status.DRAFT);
    Change change2 = insert(repo, ins2);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change[] expected = new Change[] { change2, change1 };
    assertQuery("status:open", expected);
    assertQuery("status:OPEN", expected);
    assertQuery("status:o", expected);
    assertQuery("status:op", expected);
    assertQuery("status:ope", expected);
    assertQuery("status:pending", expected);
    assertQuery("status:PENDING", expected);
    assertQuery("status:p", expected);
    assertQuery("status:pe", expected);
    assertQuery("status:pen", expected);
    assertQuery("is:open", expected);
}
#method_after
@Test
public void byStatusOpen() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change[] expected = new Change[] { change1 };
    assertQuery("status:open", expected);
    assertQuery("status:OPEN", expected);
    assertQuery("status:o", expected);
    assertQuery("status:op", expected);
    assertQuery("status:ope", expected);
    assertQuery("status:pending", expected);
    assertQuery("status:PENDING", expected);
    assertQuery("status:p", expected);
    assertQuery("status:pe", expected);
    assertQuery("status:pen", expected);
    assertQuery("is:open", expected);
}
#end_block

#method_before
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    assertQuery("status:n", change1);
    assertQuery("status:ne", change1);
    assertQuery("status:new", change1);
    assertQuery("status:N", change1);
    assertQuery("status:nE", change1);
    assertQuery("status:neW", change1);
    assertThatQueryException("status:nx").hasMessageThat().isEqualTo("invalid change status: nx");
    assertThatQueryException("status:newx").hasMessageThat().isEqualTo("invalid change status: newx");
}
#method_after
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    assertQuery("status:n", change1);
    assertQuery("status:ne", change1);
    assertQuery("status:new", change1);
    assertQuery("status:N", change1);
    assertQuery("status:nE", change1);
    assertQuery("status:neW", change1);
    assertQuery("status:nx");
    assertQuery("status:newx");
}
#end_block

#method_before
@Test
public void byAge() throws Exception {
    long thirtyHoursInMs = MILLISECONDS.convert(30, HOURS);
    resetTimeWithClockStep(thirtyHoursInMs, MILLISECONDS);
    TestRepository<Repo> repo = createProject("repo");
    long startMs = TestTimeUtil.START.getMillis();
    Change change1 = insert(repo, newChange(repo), null, new Timestamp(startMs));
    Change change2 = insert(repo, newChange(repo), null, new Timestamp(startMs + thirtyHoursInMs));
    // Stop time so age queries use the same endpoint.
    TestTimeUtil.setClockStep(0, MILLISECONDS);
    TestTimeUtil.setClock(new Timestamp(startMs + 2 * thirtyHoursInMs));
    long nowMs = TimeUtil.nowMs();
    assertThat(lastUpdatedMs(change2) - lastUpdatedMs(change1)).isEqualTo(thirtyHoursInMs);
    assertThat(nowMs - lastUpdatedMs(change2)).isEqualTo(thirtyHoursInMs);
    assertThat(TimeUtil.nowMs()).isEqualTo(nowMs);
    assertQuery("-age:1d");
    assertQuery("-age:" + (30 * 60 - 1) + "m");
    assertQuery("-age:2d", change2);
    assertQuery("-age:3d", change2, change1);
    assertQuery("age:3d");
    assertQuery("age:2d", change1);
    assertQuery("age:1d", change2, change1);
}
#method_after
@Test
public void byAge() throws Exception {
    long thirtyHoursInMs = MILLISECONDS.convert(30, HOURS);
    resetTimeWithClockStep(thirtyHoursInMs, MILLISECONDS);
    TestRepository<Repo> repo = createProject("repo");
    long startMs = TestTimeUtil.START.toEpochMilli();
    Change change1 = insert(repo, newChange(repo), null, new Timestamp(startMs));
    Change change2 = insert(repo, newChange(repo), null, new Timestamp(startMs + thirtyHoursInMs));
    // Stop time so age queries use the same endpoint.
    TestTimeUtil.setClockStep(0, MILLISECONDS);
    TestTimeUtil.setClock(new Timestamp(startMs + 2 * thirtyHoursInMs));
    long nowMs = TimeUtil.nowMs();
    assertThat(lastUpdatedMs(change2) - lastUpdatedMs(change1)).isEqualTo(thirtyHoursInMs);
    assertThat(nowMs - lastUpdatedMs(change2)).isEqualTo(thirtyHoursInMs);
    assertThat(TimeUtil.nowMs()).isEqualTo(nowMs);
    assertQuery("-age:1d");
    assertQuery("-age:" + (30 * 60 - 1) + "m");
    assertQuery("-age:2d", change2);
    assertQuery("-age:3d", change2, change1);
    assertQuery("age:3d");
    assertQuery("age:2d", change1);
    assertQuery("age:1d", change2, change1);
}
#end_block

#method_before
@Test
public void byBefore() throws Exception {
    long thirtyHoursInMs = MILLISECONDS.convert(30, HOURS);
    resetTimeWithClockStep(thirtyHoursInMs, MILLISECONDS);
    TestRepository<Repo> repo = createProject("repo");
    long startMs = TestTimeUtil.START.getMillis();
    Change change1 = insert(repo, newChange(repo), null, new Timestamp(startMs));
    Change change2 = insert(repo, newChange(repo), null, new Timestamp(startMs + thirtyHoursInMs));
    TestTimeUtil.setClockStep(0, MILLISECONDS);
    assertQuery("before:2009-09-29");
    assertQuery("before:2009-09-30");
    assertQuery("before:\"2009-09-30 16:59:00 -0400\"");
    assertQuery("before:\"2009-09-30 20:59:00 -0000\"");
    assertQuery("before:\"2009-09-30 20:59:00\"");
    assertQuery("before:\"2009-09-30 17:02:00 -0400\"", change1);
    assertQuery("before:\"2009-10-01 21:02:00 -0000\"", change1);
    assertQuery("before:\"2009-10-01 21:02:00\"", change1);
    assertQuery("before:2009-10-01", change1);
    assertQuery("before:2009-10-03", change2, change1);
}
#method_after
@Test
public void byBefore() throws Exception {
    long thirtyHoursInMs = MILLISECONDS.convert(30, HOURS);
    resetTimeWithClockStep(thirtyHoursInMs, MILLISECONDS);
    TestRepository<Repo> repo = createProject("repo");
    long startMs = TestTimeUtil.START.toEpochMilli();
    Change change1 = insert(repo, newChange(repo), null, new Timestamp(startMs));
    Change change2 = insert(repo, newChange(repo), null, new Timestamp(startMs + thirtyHoursInMs));
    TestTimeUtil.setClockStep(0, MILLISECONDS);
    assertQuery("before:2009-09-29");
    assertQuery("before:2009-09-30");
    assertQuery("before:\"2009-09-30 16:59:00 -0400\"");
    assertQuery("before:\"2009-09-30 20:59:00 -0000\"");
    assertQuery("before:\"2009-09-30 20:59:00\"");
    assertQuery("before:\"2009-09-30 17:02:00 -0400\"", change1);
    assertQuery("before:\"2009-10-01 21:02:00 -0000\"", change1);
    assertQuery("before:\"2009-10-01 21:02:00\"", change1);
    assertQuery("before:2009-10-01", change1);
    assertQuery("before:2009-10-03", change2, change1);
}
#end_block

#method_before
@Test
public void byAfter() throws Exception {
    long thirtyHoursInMs = MILLISECONDS.convert(30, HOURS);
    resetTimeWithClockStep(thirtyHoursInMs, MILLISECONDS);
    TestRepository<Repo> repo = createProject("repo");
    long startMs = TestTimeUtil.START.getMillis();
    Change change1 = insert(repo, newChange(repo), null, new Timestamp(startMs));
    Change change2 = insert(repo, newChange(repo), null, new Timestamp(startMs + thirtyHoursInMs));
    TestTimeUtil.setClockStep(0, MILLISECONDS);
    assertQuery("after:2009-10-03");
    assertQuery("after:\"2009-10-01 20:59:59 -0400\"", change2);
    assertQuery("after:\"2009-10-01 20:59:59 -0000\"", change2);
    assertQuery("after:2009-10-01", change2);
    assertQuery("after:2009-09-30", change2, change1);
}
#method_after
@Test
public void byAfter() throws Exception {
    long thirtyHoursInMs = MILLISECONDS.convert(30, HOURS);
    resetTimeWithClockStep(thirtyHoursInMs, MILLISECONDS);
    TestRepository<Repo> repo = createProject("repo");
    long startMs = TestTimeUtil.START.toEpochMilli();
    Change change1 = insert(repo, newChange(repo), null, new Timestamp(startMs));
    Change change2 = insert(repo, newChange(repo), null, new Timestamp(startMs + thirtyHoursInMs));
    TestTimeUtil.setClockStep(0, MILLISECONDS);
    assertQuery("after:2009-10-03");
    assertQuery("after:\"2009-10-01 20:59:59 -0400\"", change2);
    assertQuery("after:\"2009-10-01 20:59:59 -0000\"", change2);
    assertQuery("after:2009-10-01", change2);
    assertQuery("after:2009-09-30", change2, change1);
}
#end_block

#method_before
public static final LabelType patchSetLock() {
    LabelType label = category("Patch-Set-Lock", value(1, "Patch Set Locked"), value(0, "Patch Set Unlocked"));
    label.setFunctionName("PatchSetLock");
    return label;
}
#method_after
public static final LabelType patchSetLock() {
    LabelType label = category("Patch-Set-Lock", value(1, "Patch Set Locked"), value(0, "Patch Set Unlocked"));
    label.setFunction(LabelFunction.PATCH_SET_LOCK);
    return label;
}
#end_block

#method_before
@Test
public void createSchema_Label_CodeReview() throws Exception {
    LabelType codeReview = getLabelTypes().byLabel("Code-Review");
    assertThat(codeReview).isNotNull();
    assertThat(codeReview.getName()).isEqualTo("Code-Review");
    assertThat(codeReview.getDefaultValue()).isEqualTo(0);
    assertThat(codeReview.getFunctionName()).isEqualTo("MaxWithBlock");
    assertThat(codeReview.isCopyMinScore()).isTrue();
    assertValueRange(codeReview, 2, 1, 0, -1, -2);
}
#method_after
@Test
public void createSchema_Label_CodeReview() throws Exception {
    LabelType codeReview = getLabelTypes().byLabel("Code-Review");
    assertThat(codeReview).isNotNull();
    assertThat(codeReview.getName()).isEqualTo("Code-Review");
    assertThat(codeReview.getDefaultValue()).isEqualTo(0);
    assertThat(codeReview.getFunction()).isEqualTo(LabelFunction.MAX_WITH_BLOCK);
    assertThat(codeReview.isCopyMinScore()).isTrue();
    assertValueRange(codeReview, 2, 1, 0, -1, -2);
}
#end_block

#method_before
@Test
public void restApiNotFoundWhenNoteDbDisabled() throws Exception {
    PushOneCommit.Result r = createChange();
    exception.expect(ResourceNotFoundException.class);
    rebuildHandler.apply(parseChangeResource(r.getChangeId()), new Rebuild.Input());
}
#method_after
@Test
public void restApiNotFoundWhenNoteDbDisabled() throws Exception {
    PushOneCommit.Result r = createChange();
    exception.expect(ResourceNotFoundException.class);
    rebuildHandler.apply(parseChangeResource(r.getChangeId()), new Input());
}
#end_block

#method_before
@Test
public void rebuildViaRestApi() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    setNotesMigration(true, false);
    checker.assertNoChangeRef(project, id);
    rebuildHandler.apply(parseChangeResource(r.getChangeId()), new Rebuild.Input());
    checker.checkChanges(id);
}
#method_after
@Test
public void rebuildViaRestApi() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getPatchSetId().getParentKey();
    setNotesMigration(true, false);
    checker.assertNoChangeRef(project, id);
    rebuildHandler.apply(parseChangeResource(r.getChangeId()), new Input());
    checker.checkChanges(id);
}
#end_block

#method_before
@Test
public void rebuilderRespectsReadOnlyInNoteDbChangeState() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    PatchSet.Id psId1 = r.getPatchSetId();
    Change.Id id = psId1.getParentKey();
    checker.rebuildAndCheckChanges(id);
    setNotesMigration(true, true);
    ReviewDb db = getUnwrappedDb();
    Change c = db.changes().get(id);
    NoteDbChangeState state = NoteDbChangeState.parse(c);
    Timestamp until = new Timestamp(TimeUtil.nowMs() + MILLISECONDS.convert(1, DAYS));
    state = state.withReadOnlyUntil(until);
    c.setNoteDbState(state.toString());
    db.changes().update(Collections.singleton(c));
    try {
        rebuilderWrapper.rebuild(db, id);
        assert_().fail("expected rebuild to fail");
    } catch (OrmRuntimeException e) {
        assertThat(e.getMessage()).contains("read-only until");
    }
    TestTimeUtil.setClock(new Timestamp(until.getTime() + MILLISECONDS.convert(1, SECONDS)));
    rebuilderWrapper.rebuild(db, id);
}
#method_after
@Test
public void rebuilderRespectsReadOnlyInNoteDbChangeState() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    PatchSet.Id psId1 = r.getPatchSetId();
    Change.Id id = psId1.getParentKey();
    checker.rebuildAndCheckChanges(id);
    setNotesMigration(true, true);
    ReviewDb db = getUnwrappedDb();
    Change c = db.changes().get(id);
    NoteDbChangeState state = NoteDbChangeState.parse(c);
    Timestamp until = new Timestamp(TimeUtil.nowMs() + MILLISECONDS.convert(1, DAYS));
    state = state.withReadOnlyUntil(until);
    c.setNoteDbState(state.toString());
    db.changes().update(Collections.singleton(c));
    try {
        rebuilderWrapper.rebuild(db, id);
        fail("expected rebuild to fail");
    } catch (OrmRuntimeException e) {
        assertThat(e.getMessage()).contains("read-only until");
    }
    TestTimeUtil.setClock(new Timestamp(until.getTime() + MILLISECONDS.convert(1, SECONDS)));
    rebuilderWrapper.rebuild(db, id);
}
#end_block

#method_before
@Test
public void publishEdit() throws Exception {
    createArbitraryEditFor(changeId);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    assertThat(getEdit(changeId)).isAbsent();
    assertChangeMessages(changeId, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Published edit on patch set 2."));
    // The tag for the publish edit change message should vary according
    // to whether the change was WIP at the time of publishing.
    ChangeInfo info = get(changeId);
    assertThat(info.messages).isNotEmpty();
    assertThat(Iterables.getLast(info.messages).tag).isEqualTo(ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    // Move the change to WIP, repeat, and verify.
    gApi.changes().id(changeId).setWorkInProgress();
    createEmptyEditFor(changeId);
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW2));
    gApi.changes().id(changeId).edit().publish();
    info = get(changeId);
    assertThat(info.messages).isNotEmpty();
    assertThat(Iterables.getLast(info.messages).tag).isEqualTo(ChangeMessagesUtil.TAG_UPLOADED_WIP_PATCH_SET);
}
#method_after
@Test
public void publishEdit() throws Exception {
    createArbitraryEditFor(changeId);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    assertThat(getEdit(changeId)).isAbsent();
    assertChangeMessages(changeId, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Published edit on patch set 2."));
    // The tag for the publish edit change message should vary according
    // to whether the change was WIP at the time of publishing.
    ChangeInfo info = get(changeId, MESSAGES);
    assertThat(info.messages).isNotEmpty();
    assertThat(Iterables.getLast(info.messages).tag).isEqualTo(ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    // Move the change to WIP, repeat, and verify.
    gApi.changes().id(changeId).setWorkInProgress();
    createEmptyEditFor(changeId);
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW2));
    gApi.changes().id(changeId).edit().publish();
    info = get(changeId, MESSAGES);
    assertThat(info.messages).isNotEmpty();
    assertThat(Iterables.getLast(info.messages).tag).isEqualTo(ChangeMessagesUtil.TAG_UPLOADED_WIP_PATCH_SET);
}
#end_block

#method_before
@Test
public void retrieveEdit() throws Exception {
    adminRestSession.get(urlEdit(changeId)).assertNoContent();
    createArbitraryEditFor(changeId);
    EditInfo editInfo = getEditInfo(changeId, false);
    ChangeInfo changeInfo = get(changeId);
    assertThat(editInfo.commit.commit).isNotEqualTo(changeInfo.currentRevision);
    assertThat(editInfo).commit().parents().hasSize(1);
    assertThat(editInfo).baseRevision().isEqualTo(changeInfo.currentRevision);
    gApi.changes().id(changeId).edit().delete();
    adminRestSession.get(urlEdit(changeId)).assertNoContent();
}
#method_after
@Test
public void retrieveEdit() throws Exception {
    adminRestSession.get(urlEdit(changeId)).assertNoContent();
    createArbitraryEditFor(changeId);
    EditInfo editInfo = getEditInfo(changeId, false);
    ChangeInfo changeInfo = get(changeId, CURRENT_REVISION, CURRENT_COMMIT);
    assertThat(editInfo.commit.commit).isNotEqualTo(changeInfo.currentRevision);
    assertThat(editInfo).commit().parents().hasSize(1);
    assertThat(editInfo).baseRevision().isEqualTo(changeInfo.currentRevision);
    gApi.changes().id(changeId).edit().delete();
    adminRestSession.get(urlEdit(changeId)).assertNoContent();
}
#end_block

#method_before
@Test
public void editCommitMessageCopiesLabelScores() throws Exception {
    String cr = "Code-Review";
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyAllScoresIfNoCodeChange(true);
    cfg.getLabelSections().put(cr, codeReview);
    saveProjectConfig(project, cfg);
    ReviewInput r = new ReviewInput();
    r.labels = ImmutableMap.of(cr, (short) 1);
    gApi.changes().id(changeId).current().review(r);
    createEmptyEditFor(changeId);
    String newSubj = "New commit message";
    String newMsg = newSubj + "\n\nChange-Id: " + changeId + "\n";
    gApi.changes().id(changeId).edit().modifyCommitMessage(newMsg);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    ChangeInfo info = get(changeId);
    assertThat(info.subject).isEqualTo(newSubj);
    List<ApprovalInfo> approvals = info.labels.get(cr).all;
    assertThat(approvals).hasSize(1);
    assertThat(approvals.get(0).value).isEqualTo(1);
}
#method_after
@Test
public void editCommitMessageCopiesLabelScores() throws Exception {
    String cr = "Code-Review";
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyAllScoresIfNoCodeChange(true);
    cfg.getLabelSections().put(cr, codeReview);
    saveProjectConfig(project, cfg);
    ReviewInput r = new ReviewInput();
    r.labels = ImmutableMap.of(cr, (short) 1);
    gApi.changes().id(changeId).current().review(r);
    createEmptyEditFor(changeId);
    String newSubj = "New commit message";
    String newMsg = newSubj + "\n\nChange-Id: " + changeId + "\n";
    gApi.changes().id(changeId).edit().modifyCommitMessage(newMsg);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    ChangeInfo info = get(changeId, DETAILED_LABELS);
    assertThat(info.subject).isEqualTo(newSubj);
    List<ApprovalInfo> approvals = info.labels.get(cr).all;
    assertThat(approvals).hasSize(1);
    assertThat(approvals.get(0).value).isEqualTo(1);
}
#end_block

#method_before
private void assertChangeMessages(String changeId, List<String> expectedMessages) throws Exception {
    ChangeInfo ci = get(changeId);
    assertThat(ci.messages).isNotNull();
    assertThat(ci.messages).hasSize(expectedMessages.size());
    List<String> actualMessages = ci.messages.stream().map(message -> message.message).collect(toList());
    assertThat(actualMessages).containsExactlyElementsIn(expectedMessages).inOrder();
}
#method_after
private void assertChangeMessages(String changeId, List<String> expectedMessages) throws Exception {
    ChangeInfo ci = get(changeId, MESSAGES);
    assertThat(ci.messages).isNotNull();
    assertThat(ci.messages).hasSize(expectedMessages.size());
    List<String> actualMessages = ci.messages.stream().map(message -> message.message).collect(toList());
    assertThat(actualMessages).containsExactlyElementsIn(expectedMessages).inOrder();
}
#end_block

#method_before
private void setUp() throws Exception {
    injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    lifecycle = new LifecycleManager();
    lifecycle.add(injector);
    lifecycle.start();
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    Account.Id userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    IdentifiedUser user = userFactory.create(userId);
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return user;
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return Providers.of(db);
        }
    });
}
#method_after
private void setUp() throws Exception {
    injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    lifecycle = new LifecycleManager();
    lifecycle.add(injector);
    lifecycle.start();
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    setApiUser(accountManager.authenticate(AuthRequest.forUser("user")).getAccountId());
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    // As a workaround, we simply reindex all available groups here.
    for (AccountGroup group : groupCache.all()) {
        groupCache.evict(group.getGroupUUID(), group.getId(), group.getNameKey());
    }
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (testRequiresSsh && SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
        // Create Ssh sessions
        initSsh(admin);
        Context ctx = newRequestContext(user);
        atrScope.set(ctx);
        userSshSession = ctx.getSession();
        userSshSession.open();
        ctx = newRequestContext(admin);
        atrScope.set(ctx);
        adminSshSession = ctx.getSession();
        adminSshSession.open();
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    db = reviewDbProvider.open();
    // All groups which were added during the server start (e.g. in SchemaCreator) aren't contained
    // in the instance of the group index which is available here and in tests. There are two
    // reasons:
    // 1) No group index is available in SchemaCreator when using an in-memory database. (This could
    // be fixed by using the IndexManagerOnInit in InMemoryDatabase similar as BaseInit uses it.)
    // 2) During the on-init part of the server start, we use another instance of the index than
    // later on. As test indexes are non-permanent, closing an instance and opening another one
    // removes all indexed data.
    // As a workaround, we simply reindex all available groups here.
    Iterable<AccountGroup.UUID> allGroupUuids = groups.getAllUuids(db)::iterator;
    for (AccountGroup.UUID groupUuid : allGroupUuids) {
        groupCache.onCreateGroup(groupUuid);
    }
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (testRequiresSsh && SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
        // Create Ssh sessions
        initSsh(admin);
        Context ctx = newRequestContext(user);
        atrScope.set(ctx);
        userSshSession = ctx.getSession();
        userSshSession.open();
        ctx = newRequestContext(admin);
        atrScope.set(ctx);
        adminSshSession = ctx.getSession();
        adminSshSession.open();
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
protected BranchApi createBranch(Branch.NameKey branch) throws Exception {
    return gApi.projects().name(branch.getParentKey().get()).branch(branch.get()).create(new BranchInput());
}
#method_after
protected BranchApi createBranch(String branch) throws Exception {
    return createBranch(new Branch.NameKey(project, branch));
}
#end_block

#method_before
protected void grant(Project.NameKey project, String ref, String permission, boolean force) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
    grant(project, ref, permission, force, adminGroup.getGroupUUID());
}
#method_after
protected void grant(Project.NameKey project, String ref, String permission, boolean force) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    InternalGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null);
    grant(project, ref, permission, force, adminGroup.getGroupUUID());
}
#end_block

#method_before
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether();
    SubmittedTogetherInfo info = gApi.changes().id(chId).submittedTogether(EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.nonVisibleChanges).isEqualTo(0);
    assertThat(actual).hasSize(expected.length);
    assertThat(changeIds(actual)).containsExactly((Object[]) expected).inOrder();
    assertThat(changeIds(info.changes)).containsExactly((Object[]) expected).inOrder();
}
#method_after
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether();
    SubmittedTogetherInfo info = gApi.changes().id(chId).submittedTogether(EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.nonVisibleChanges).isEqualTo(0);
    assertThat(changeIds(actual)).containsExactly((Object[]) expected).inOrder();
    assertThat(changeIds(info.changes)).containsExactly((Object[]) expected).inOrder();
}
#end_block

#method_before
@Test
public void create() throws Exception {
    // account creation + external ID creation
    create(2);
}
#method_after
@Test
public void create() throws Exception {
    // account creation + external ID creation
    Account.Id accountId = create(2);
    refUpdateCounter.assertRefUpdateFor(RefUpdateCounter.projectRef(allUsers, RefNames.refsUsers(accountId)), RefUpdateCounter.projectRef(allUsers, RefNames.REFS_EXTERNAL_IDS), RefUpdateCounter.projectRef(allUsers, RefNames.REFS_SEQUENCES + Sequences.NAME_ACCOUNTS));
}
#end_block

#method_before
@Test
@UseSsh
public void createWithSshKeys() throws Exception {
    // account creation + external ID creation + adding SSH keys
    create(3);
}
#method_after
@Test
@UseSsh
public void createWithSshKeys() throws Exception {
    // account creation + external ID creation + adding SSH keys
    Account.Id accountId = create(3);
    refUpdateCounter.assertRefUpdateFor(ImmutableMap.of(RefUpdateCounter.projectRef(allUsers, RefNames.refsUsers(accountId)), 2, RefUpdateCounter.projectRef(allUsers, RefNames.REFS_EXTERNAL_IDS), 1, RefUpdateCounter.projectRef(allUsers, RefNames.REFS_SEQUENCES + Sequences.NAME_ACCOUNTS), 1));
}
#end_block

#method_before
private void create(int expectedAccountReindexCalls) throws Exception {
    String name = "foo";
    TestAccount foo = accountCreator.create(name);
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.username).isEqualTo(name);
    assertThat(info.name).isEqualTo(name);
    accountIndexedCounter.assertReindexOf(foo, expectedAccountReindexCalls);
    assertUserBranch(foo.getId(), name, null);
}
#method_after
private Account.Id create(int expectedAccountReindexCalls) throws Exception {
    String name = "foo";
    TestAccount foo = accountCreator.create(name);
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.username).isEqualTo(name);
    assertThat(info.name).isEqualTo(name);
    accountIndexedCounter.assertReindexOf(foo, expectedAccountReindexCalls);
    assertUserBranch(foo.getId(), name, null);
    return foo.getId();
}
#end_block

#method_before
@Test
public void starUnstarChange() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.accounts().self().starChange(triplet);
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).contains(DEFAULT_LABEL);
    gApi.accounts().self().unstarChange(triplet);
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).isNull();
    accountIndexedCounter.assertNoReindex();
}
#method_after
@Test
public void starUnstarChange() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    refUpdateCounter.clear();
    gApi.accounts().self().starChange(triplet);
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).contains(DEFAULT_LABEL);
    refUpdateCounter.assertRefUpdateFor(RefUpdateCounter.projectRef(allUsers, RefNames.refsStarredChanges(new Change.Id(change._number), admin.id)));
    gApi.accounts().self().unstarChange(triplet);
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).isNull();
    refUpdateCounter.assertRefUpdateFor(RefUpdateCounter.projectRef(allUsers, RefNames.refsStarredChanges(new Change.Id(change._number), admin.id)));
    accountIndexedCounter.assertNoReindex();
}
#end_block

#method_before
@Test
public void starUnstarChangeWithLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    assertThat(gApi.accounts().self().getStars(triplet)).isEmpty();
    assertThat(gApi.accounts().self().getStarredChanges()).isEmpty();
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "red", "blue")));
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    List<ChangeInfo> starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    ChangeInfo starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isTrue();
    assertThat(starredChange.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of("yellow"), ImmutableSet.of(DEFAULT_LABEL, "blue")));
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).containsExactly("red", "yellow").inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("red", "yellow").inOrder();
    starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isNull();
    assertThat(starredChange.stars).containsExactly("red", "yellow").inOrder();
    accountIndexedCounter.assertNoReindex();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to get stars of another account");
    gApi.accounts().id(Integer.toString((admin.id.get()))).getStars(triplet);
}
#method_after
@Test
public void starUnstarChangeWithLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    refUpdateCounter.clear();
    assertThat(gApi.accounts().self().getStars(triplet)).isEmpty();
    assertThat(gApi.accounts().self().getStarredChanges()).isEmpty();
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "red", "blue")));
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    List<ChangeInfo> starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    ChangeInfo starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isTrue();
    assertThat(starredChange.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    refUpdateCounter.assertRefUpdateFor(RefUpdateCounter.projectRef(allUsers, RefNames.refsStarredChanges(new Change.Id(change._number), admin.id)));
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of("yellow"), ImmutableSet.of(DEFAULT_LABEL, "blue")));
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).containsExactly("red", "yellow").inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("red", "yellow").inOrder();
    starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isNull();
    assertThat(starredChange.stars).containsExactly("red", "yellow").inOrder();
    refUpdateCounter.assertRefUpdateFor(RefUpdateCounter.projectRef(allUsers, RefNames.refsStarredChanges(new Change.Id(change._number), admin.id)));
    accountIndexedCounter.assertNoReindex();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to get stars of another account");
    gApi.accounts().id(Integer.toString((admin.id.get()))).getStars(triplet);
}
#end_block

#method_before
@Test
@Sandboxed
public void fetchUserBranch() throws Exception {
    setApiUser(user);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers, user);
    String userRefName = RefNames.refsUsers(user.id);
    // remove default READ permissions
    ProjectConfig cfg = projectCache.checkedGet(allUsers).getConfig();
    cfg.getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true).remove(new Permission(Permission.READ));
    saveProjectConfig(allUsers, cfg);
    // deny READ permission that is inherited from All-Projects
    deny(allUsers, RefNames.REFS + "*", Permission.READ, ANONYMOUS_USERS);
    // fetching user branch without READ permission fails
    try {
        fetch(allUsersRepo, userRefName + ":userRef");
        Assert.fail("user branch is visible although no READ permission is granted");
    } catch (TransportException e) {
    // expected because no READ granted on user branch
    }
    // allow each user to read its own user branch
    grant(allUsers, RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", Permission.READ, false, REGISTERED_USERS);
    // fetch user branch using refs/users/YY/XXXXXXX
    fetch(allUsersRepo, userRefName + ":userRef");
    Ref userRef = allUsersRepo.getRepository().exactRef("userRef");
    assertThat(userRef).isNotNull();
    // fetch user branch using refs/users/self
    fetch(allUsersRepo, RefNames.REFS_USERS_SELF + ":userSelfRef");
    Ref userSelfRef = allUsersRepo.getRepository().getRefDatabase().exactRef("userSelfRef");
    assertThat(userSelfRef).isNotNull();
    assertThat(userSelfRef.getObjectId()).isEqualTo(userRef.getObjectId());
    accountIndexedCounter.assertNoReindex();
    // fetching user branch of another user fails
    String otherUserRefName = RefNames.refsUsers(admin.id);
    exception.expect(TransportException.class);
    exception.expectMessage("Remote does not have " + otherUserRefName + " available for fetch.");
    fetch(allUsersRepo, otherUserRefName + ":otherUserRef");
}
#method_after
@Test
@Sandboxed
public void fetchUserBranch() throws Exception {
    setApiUser(user);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers, user);
    String userRefName = RefNames.refsUsers(user.id);
    // remove default READ permissions
    ProjectConfig cfg = projectCache.checkedGet(allUsers).getConfig();
    cfg.getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true).remove(new Permission(Permission.READ));
    saveProjectConfig(allUsers, cfg);
    // deny READ permission that is inherited from All-Projects
    deny(allUsers, RefNames.REFS + "*", Permission.READ, ANONYMOUS_USERS);
    // fetching user branch without READ permission fails
    try {
        fetch(allUsersRepo, userRefName + ":userRef");
        fail("user branch is visible although no READ permission is granted");
    } catch (TransportException e) {
    // expected because no READ granted on user branch
    }
    // allow each user to read its own user branch
    grant(allUsers, RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", Permission.READ, false, REGISTERED_USERS);
    // fetch user branch using refs/users/YY/XXXXXXX
    fetch(allUsersRepo, userRefName + ":userRef");
    Ref userRef = allUsersRepo.getRepository().exactRef("userRef");
    assertThat(userRef).isNotNull();
    // fetch user branch using refs/users/self
    fetch(allUsersRepo, RefNames.REFS_USERS_SELF + ":userSelfRef");
    Ref userSelfRef = allUsersRepo.getRepository().getRefDatabase().exactRef("userSelfRef");
    assertThat(userSelfRef).isNotNull();
    assertThat(userSelfRef.getObjectId()).isEqualTo(userRef.getObjectId());
    accountIndexedCounter.assertNoReindex();
    // fetching user branch of another user fails
    String otherUserRefName = RefNames.refsUsers(admin.id);
    exception.expect(TransportException.class);
    exception.expectMessage("Remote does not have " + otherUserRefName + " available for fetch.");
    fetch(allUsersRepo, otherUserRefName + ":otherUserRef");
}
#end_block

#method_before
@Test
public void pushAccountConfigToUserBranchForReviewDeactivateOtherAccount() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isTrue();
    String userRef = RefNames.refsUsers(foo.id);
    accountIndexedCounter.clear();
    AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    grantLabel("Code-Review", -2, 2, allUsers, userRef, false, adminGroup.getGroupUUID(), false);
    grant(allUsers, userRef, Permission.SUBMIT, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    Config ac = getAccountConfig(allUsersRepo);
    ac.setBoolean(AccountConfig.ACCOUNT, null, AccountConfig.KEY_ACTIVE, false);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(MagicBranch.NEW_CHANGE + userRef);
    r.assertOkStatus();
    accountIndexedCounter.assertNoReindex();
    assertThat(r.getChange().change().getDest().get()).isEqualTo(userRef);
    gApi.changes().id(r.getChangeId()).current().review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).current().submit();
    accountIndexedCounter.assertReindexOf(foo);
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isFalse();
}
#method_after
@Test
public void pushAccountConfigToUserBranchForReviewDeactivateOtherAccount() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isTrue();
    String userRef = RefNames.refsUsers(foo.id);
    accountIndexedCounter.clear();
    InternalGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null);
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    grantLabel("Code-Review", -2, 2, allUsers, userRef, false, adminGroup.getGroupUUID(), false);
    grant(allUsers, userRef, Permission.SUBMIT, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    Config ac = getAccountConfig(allUsersRepo);
    ac.setBoolean(AccountConfig.ACCOUNT, null, AccountConfig.KEY_ACTIVE, false);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(MagicBranch.NEW_CHANGE + userRef);
    r.assertOkStatus();
    accountIndexedCounter.assertNoReindex();
    assertThat(r.getChange().change().getDest().get()).isEqualTo(userRef);
    gApi.changes().id(r.getChangeId()).current().review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).current().submit();
    accountIndexedCounter.assertReindexOf(foo);
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isFalse();
}
#end_block

#method_before
@Test
public void pushAccountConfigToUserBranchInvalidPreferredEmailButNotChanged() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    String userRef = RefNames.refsUsers(foo.id);
    String noEmail = "no.email";
    accountsUpdate.create().update(foo.id, a -> a.setPreferredEmail(noEmail));
    accountIndexedCounter.clear();
    AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    String status = "in vacation";
    Config ac = getAccountConfig(allUsersRepo);
    ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_STATUS, status);
    pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus();
    accountIndexedCounter.assertReindexOf(foo);
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.email).isEqualTo(noEmail);
    assertThat(info.name).isEqualTo(foo.fullName);
    assertThat(info.status).isEqualTo(status);
}
#method_after
@Test
public void pushAccountConfigToUserBranchInvalidPreferredEmailButNotChanged() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    String userRef = RefNames.refsUsers(foo.id);
    String noEmail = "no.email";
    accountsUpdate.create().update(foo.id, a -> a.setPreferredEmail(noEmail));
    accountIndexedCounter.clear();
    InternalGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null);
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    String status = "in vacation";
    Config ac = getAccountConfig(allUsersRepo);
    ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_STATUS, status);
    pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus();
    accountIndexedCounter.assertReindexOf(foo);
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.email).isEqualTo(noEmail);
    assertThat(info.name).isEqualTo(foo.fullName);
    assertThat(info.status).isEqualTo(status);
}
#end_block

#method_before
@Test
public void pushAccountConfigToUserBranchIfPreferredEmailDoesNotExistAsExtId() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    String userRef = RefNames.refsUsers(foo.id);
    accountIndexedCounter.clear();
    AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    String email = "some.email@example.com";
    Config ac = getAccountConfig(allUsersRepo);
    ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_PREFERRED_EMAIL, email);
    pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus();
    accountIndexedCounter.assertReindexOf(foo);
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.email).isEqualTo(email);
    assertThat(info.name).isEqualTo(foo.fullName);
}
#method_after
@Test
public void pushAccountConfigToUserBranchIfPreferredEmailDoesNotExistAsExtId() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    String userRef = RefNames.refsUsers(foo.id);
    accountIndexedCounter.clear();
    InternalGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null);
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    String email = "some.email@example.com";
    Config ac = getAccountConfig(allUsersRepo);
    ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_PREFERRED_EMAIL, email);
    pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus();
    accountIndexedCounter.assertReindexOf(foo);
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.email).isEqualTo(email);
    assertThat(info.name).isEqualTo(foo.fullName);
}
#end_block

#method_before
@Test
public void pushAccountConfigToUserBranchDeactivateOtherAccount() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isTrue();
    String userRef = RefNames.refsUsers(foo.id);
    accountIndexedCounter.clear();
    AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    Config ac = getAccountConfig(allUsersRepo);
    ac.setBoolean(AccountConfig.ACCOUNT, null, AccountConfig.KEY_ACTIVE, false);
    pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus();
    accountIndexedCounter.assertReindexOf(foo);
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isFalse();
}
#method_after
@Test
public void pushAccountConfigToUserBranchDeactivateOtherAccount() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isTrue();
    String userRef = RefNames.refsUsers(foo.id);
    accountIndexedCounter.clear();
    InternalGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null);
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    Config ac = getAccountConfig(allUsersRepo);
    ac.setBoolean(AccountConfig.ACCOUNT, null, AccountConfig.KEY_ACTIVE, false);
    pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus();
    accountIndexedCounter.assertReindexOf(foo);
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isFalse();
}
#end_block

#method_before
private ChangeInfo assertCreateSucceeds(ChangeInput in) throws Exception {
    ChangeInfo out = gApi.changes().create(in).get();
    assertThat(out.project).isEqualTo(in.project);
    assertThat(out.branch).isEqualTo(in.branch);
    assertThat(out.subject).isEqualTo(in.subject);
    assertThat(out.topic).isEqualTo(in.topic);
    assertThat(out.status).isEqualTo(in.status);
    assertThat(out.isPrivate).isEqualTo(in.isPrivate);
    assertThat(out.workInProgress).isEqualTo(in.workInProgress);
    assertThat(out.revisions).hasSize(1);
    assertThat(out.submitted).isNull();
    assertThat(out.submitter).isNull();
    Boolean draft = Iterables.getOnlyElement(out.revisions.values()).draft;
    assertThat(booleanToDraftStatus(draft)).isEqualTo(in.status);
    return out;
}
#method_after
private ChangeInfo assertCreateSucceeds(ChangeInput in) throws Exception {
    ChangeInfo out = gApi.changes().create(in).get();
    assertThat(out.project).isEqualTo(in.project);
    assertThat(out.branch).isEqualTo(in.branch);
    assertThat(out.subject).isEqualTo(in.subject);
    assertThat(out.topic).isEqualTo(in.topic);
    assertThat(out.status).isEqualTo(in.status);
    assertThat(out.isPrivate).isEqualTo(in.isPrivate);
    assertThat(out.workInProgress).isEqualTo(in.workInProgress);
    assertThat(out.revisions).hasSize(1);
    assertThat(out.submitted).isNull();
    assertThat(in.status).isEqualTo(ChangeStatus.NEW);
    return out;
}
#end_block

#method_before
@Test
public void pushForMasterWithMessage() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId());
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.\nmy test message");
    }
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(1);
    for (RevisionInfo ri : revisions) {
        assertThat(ri.description).isEqualTo("my test message");
    }
}
#method_after
@Test
public void pushForMasterWithMessage() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId(), MESSAGES, ALL_REVISIONS);
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.\nmy test message");
    }
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(1);
    for (RevisionInfo ri : revisions) {
        assertThat(ri.description).isEqualTo("my test message");
    }
}
#end_block

#method_before
@Test
public void pushForMasterWithMessageTwiceWithDifferentMessages() throws Exception {
    enableCreateNewChangeForAllNotInTarget();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%m=new_test_message");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(2);
    for (RevisionInfo ri : revisions) {
        if (ri.isCurrent) {
            assertThat(ri.description).isEqualTo("new test message");
        } else {
            assertThat(ri.description).isEqualTo("my test message");
        }
    }
}
#method_after
@Test
public void pushForMasterWithMessageTwiceWithDifferentMessages() throws Exception {
    enableCreateNewChangeForAllNotInTarget();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    // %2C is comma; the value below tests that percent decoding happens after splitting.
    // All three ways of representing space ("%20", "+", and "_" are also exercised.
    PushOneCommit.Result r = push.to("refs/for/master/%m=my_test%20+_message%2Cm=");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%m=new_test_message");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId(), ALL_REVISIONS);
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(2);
    for (RevisionInfo ri : revisions) {
        if (ri.isCurrent) {
            assertThat(ri.description).isEqualTo("new test message");
        } else {
            assertThat(ri.description).isEqualTo("my test   message,m=");
        }
    }
}
#end_block

#method_before
@Test
public void pushForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(1);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3.");
}
#method_after
@Test
public void pushForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(1);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId(), MESSAGES);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3.");
}
#end_block

#method_before
@Test
public void pushNewPatchSetForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ChangeInfo ci = get(r.getChangeId());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the new patch set was added as a reviewer since they added
    // a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
}
#method_after
@Test
public void pushNewPatchSetForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ChangeInfo ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the new patch set was added as a reviewer since they added
    // a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
}
#end_block

#method_before
@Test
public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws Exception {
    // Create a commit with "User" as author and committer
    RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    // Push this commit as "Administrator" (requires Forge Committer Identity)
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false);
    // Expected Code-Review votes:
    // 1. 0 from User (committer):
    // When the committer is forged, the committer is automatically added as
    // reviewer, hence we expect a dummy 0 vote for the committer.
    // 2. +1 from Administrator (uploader):
    // On push Code-Review+1 was specified, hence we expect a +1 vote from
    // the uploader.
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(2);
    int indexAdmin = admin.fullName.equals(cr.all.get(0).name) ? 0 : 1;
    int indexUser = indexAdmin == 0 ? 1 : 0;
    assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName);
    assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1);
    assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName);
    assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#method_after
@Test
public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws Exception {
    // Create a commit with "User" as author and committer
    RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    // Push this commit as "Administrator" (requires Forge Committer Identity)
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false);
    // Expected Code-Review votes:
    // 1. 0 from User (committer):
    // When the committer is forged, the committer is automatically added as
    // reviewer, hence we expect a dummy 0 vote for the committer.
    // 2. +1 from Administrator (uploader):
    // On push Code-Review+1 was specified, hence we expect a +1 vote from
    // the uploader.
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(2);
    int indexAdmin = admin.fullName.equals(cr.all.get(0).name) ? 0 : 1;
    int indexUser = indexAdmin == 0 ? 1 : 0;
    assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName);
    assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1);
    assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName);
    assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#end_block

#method_before
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#method_after
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get(), DETAILED_LABELS, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#end_block

#method_before
private void assertTwoChangesWithSameRevision(PushOneCommit.Result result) throws Exception {
    List<ChangeInfo> changes = query(result.getCommit().name());
    assertThat(changes).hasSize(2);
    ChangeInfo c1 = get(changes.get(0).id);
    ChangeInfo c2 = get(changes.get(1).id);
    assertThat(c1.project).isEqualTo(c2.project);
    assertThat(c1.branch).isNotEqualTo(c2.branch);
    assertThat(c1.changeId).isEqualTo(c2.changeId);
    assertThat(c1.currentRevision).isEqualTo(c2.currentRevision);
}
#method_after
private void assertTwoChangesWithSameRevision(PushOneCommit.Result result) throws Exception {
    List<ChangeInfo> changes = query(result.getCommit().name());
    assertThat(changes).hasSize(2);
    ChangeInfo c1 = get(changes.get(0).id, CURRENT_REVISION);
    ChangeInfo c2 = get(changes.get(1).id, CURRENT_REVISION);
    assertThat(c1.project).isEqualTo(c2.project);
    assertThat(c1.branch).isNotEqualTo(c2.branch);
    assertThat(c1.changeId).isEqualTo(c2.changeId);
    assertThat(c1.currentRevision).isEqualTo(c2.currentRevision);
}
#end_block

#method_before
@Test
public void refStateFieldValues() throws Exception {
    AllUsersName allUsersName = new AllUsersName(AllUsersNameProvider.DEFAULT);
    Account account = new Account(new Account.Id(1), TimeUtil.nowTs());
    String metaId = "0e39795bb25dc914118224995c53c5c36923a461";
    account.setMetaId(metaId);
    List<String> values = toStrings(AccountField.REF_STATE.get(new AccountState(allUsersName, account, ImmutableSet.of(), ImmutableSet.of(), ImmutableMap.of())));
    assertThat(values).hasSize(1);
    String expectedValue = allUsersName.get() + ":" + RefNames.refsUsers(account.getId()) + ":" + metaId;
    assertThat(Iterables.getOnlyElement(values)).isEqualTo(expectedValue);
}
#method_after
@Test
public void refStateFieldValues() throws Exception {
    AllUsersName allUsersName = new AllUsersName(AllUsersNameProvider.DEFAULT);
    Account account = new Account(new Account.Id(1), TimeUtil.nowTs());
    String metaId = "0e39795bb25dc914118224995c53c5c36923a461";
    account.setMetaId(metaId);
    List<String> values = toStrings(AccountField.REF_STATE.get(new AccountState(allUsersName, account, ImmutableSet.of(), ImmutableMap.of())));
    assertThat(values).hasSize(1);
    String expectedValue = allUsersName.get() + ":" + RefNames.refsUsers(account.getId()) + ":" + metaId;
    assertThat(Iterables.getOnlyElement(values)).isEqualTo(expectedValue);
}
#end_block

#method_before
@Test
public void externalIdStateFieldValues() throws Exception {
    Account.Id id = new Account.Id(1);
    Account account = new Account(id, TimeUtil.nowTs());
    ExternalId extId1 = ExternalId.create(ExternalId.Key.create(ExternalId.SCHEME_MAILTO, "foo.bar@example.com"), id, "foo.bar@example.com", null, ObjectId.fromString("1b9a0cf038ea38a0ab08617c39aa8e28413a27ca"));
    ExternalId extId2 = ExternalId.create(ExternalId.Key.create(ExternalId.SCHEME_USERNAME, "foo"), id, null, "secret", ObjectId.fromString("5b3a73dc9a668a5b89b5f049225261e3e3291d1a"));
    List<String> values = toStrings(AccountField.EXTERNAL_ID_STATE.get(new AccountState(null, account, ImmutableSet.of(), ImmutableSet.of(extId1, extId2), ImmutableMap.of())));
    String expectedValue1 = extId1.key().sha1().name() + ":" + extId1.blobId().name();
    String expectedValue2 = extId2.key().sha1().name() + ":" + extId2.blobId().name();
    assertThat(values).containsExactly(expectedValue1, expectedValue2);
}
#method_after
@Test
public void externalIdStateFieldValues() throws Exception {
    Account.Id id = new Account.Id(1);
    Account account = new Account(id, TimeUtil.nowTs());
    ExternalId extId1 = ExternalId.create(ExternalId.Key.create(ExternalId.SCHEME_MAILTO, "foo.bar@example.com"), id, "foo.bar@example.com", null, ObjectId.fromString("1b9a0cf038ea38a0ab08617c39aa8e28413a27ca"));
    ExternalId extId2 = ExternalId.create(ExternalId.Key.create(ExternalId.SCHEME_USERNAME, "foo"), id, null, "secret", ObjectId.fromString("5b3a73dc9a668a5b89b5f049225261e3e3291d1a"));
    List<String> values = toStrings(AccountField.EXTERNAL_ID_STATE.get(new AccountState(null, account, ImmutableSet.of(extId1, extId2), ImmutableMap.of())));
    String expectedValue1 = extId1.key().sha1().name() + ":" + extId1.blobId().name();
    String expectedValue2 = extId2.key().sha1().name() + ":" + extId2.blobId().name();
    assertThat(values).containsExactly(expectedValue1, expectedValue2);
}
#end_block

#method_before
private void assertCanUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("can upload").isEqualTo(Capable.OK);
}
#method_after
private void assertCanUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("can upload").isTrue();
}
#end_block

#method_before
private void assertCannotUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("cannot upload").isNotEqualTo(Capable.OK);
}
#method_after
private void assertCannotUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("cannot upload").isFalse();
}
#end_block

#method_before
@Test
public void branchDelegation1() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwnerAnyRef(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
}
#method_after
@Test
public void branchDelegation1() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
}
#end_block

#method_before
@Test
public void branchDelegation2() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    allow(local, OWNER, fixers, "refs/heads/x/y/*");
    doNotInherit(local, OWNER, "refs/heads/x/y/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwnerAnyRef(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
    ProjectControl uFix = user(local, fixers);
    assertNotOwner(uFix);
    assertOwnerAnyRef(uFix);
    assertOwner("refs/heads/x/y/*", uFix);
    assertOwner("refs/heads/x/y/bar", uFix);
    assertNotOwner("refs/heads/x/*", uFix);
    assertNotOwner("refs/heads/x/y", uFix);
    assertNotOwner("refs/*", uFix);
    assertNotOwner("refs/heads/master", uFix);
}
#method_after
@Test
public void branchDelegation2() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    allow(local, OWNER, fixers, "refs/heads/x/y/*");
    doNotInherit(local, OWNER, "refs/heads/x/y/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
    ProjectControl uFix = user(local, fixers);
    assertNotOwner(uFix);
    assertOwner("refs/heads/x/y/*", uFix);
    assertOwner("refs/heads/x/y/bar", uFix);
    assertNotOwner("refs/heads/x/*", uFix);
    assertNotOwner("refs/heads/x/y", uFix);
    assertNotOwner("refs/*", uFix);
    assertNotOwner("refs/heads/master", uFix);
}
#end_block

#method_before
private ProjectControl user(ProjectConfig local, String name, AccountGroup.UUID... memberOf) {
    return new ProjectControl(Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountGroup.UUID>emptySet(), projectCache, sectionSorter, // commitsCollection
    null, changeControlFactory, // canonicalWebUrl
    "http://localhost", permissionBackend, new MockUser(name, memberOf), newProjectState(local), metrics);
}
#method_after
private ProjectControl user(ProjectConfig local, String name, AccountGroup.UUID... memberOf) {
    return new ProjectControl(Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountGroup.UUID>emptySet(), sectionSorter, // commitsCollection
    null, changeControlFactory, permissionBackend, new MockUser(name, memberOf), newProjectState(local));
}
#end_block

#method_before
private void testReadOnly(Change.Id id) throws Exception {
    Timestamp before = TimeUtil.nowTs();
    Timestamp until = new Timestamp(before.getTime() + 1000 * 3600);
    // Set read-only.
    Change c = db.changes().get(id);
    assertThat(c).named("change " + id).isNotNull();
    NoteDbChangeState state = NoteDbChangeState.parse(c);
    state = state.withReadOnlyUntil(until);
    c.setNoteDbState(state.toString());
    db.changes().update(Collections.singleton(c));
    assertThat(gApi.changes().id(id.get()).get().subject).isEqualTo(PushOneCommit.SUBJECT);
    assertThat(gApi.changes().id(id.get()).get().topic).isNull();
    try {
        gApi.changes().id(id.get()).topic("a-topic");
        assert_().fail("expected read-only exception");
    } catch (RestApiException e) {
        Optional<Throwable> oe = Throwables.getCausalChain(e).stream().filter(x -> x instanceof OrmRuntimeException).findFirst();
        assertThat(oe).named("OrmRuntimeException in causal chain of " + e).isPresent();
        assertThat(oe.get().getMessage()).contains("read-only");
    }
    assertThat(gApi.changes().id(id.get()).get().topic).isNull();
    TestTimeUtil.setClock(new Timestamp(until.getTime() + 1000));
    assertThat(gApi.changes().id(id.get()).get().subject).isEqualTo(PushOneCommit.SUBJECT);
    gApi.changes().id(id.get()).topic("a-topic");
    assertThat(gApi.changes().id(id.get()).get().topic).isEqualTo("a-topic");
}
#method_after
private void testReadOnly(Change.Id id) throws Exception {
    Timestamp before = TimeUtil.nowTs();
    Timestamp until = new Timestamp(before.getTime() + 1000 * 3600);
    // Set read-only.
    Change c = db.changes().get(id);
    assertThat(c).named("change " + id).isNotNull();
    NoteDbChangeState state = NoteDbChangeState.parse(c);
    state = state.withReadOnlyUntil(until);
    c.setNoteDbState(state.toString());
    db.changes().update(Collections.singleton(c));
    assertThat(gApi.changes().id(id.get()).get().subject).isEqualTo(PushOneCommit.SUBJECT);
    assertThat(gApi.changes().id(id.get()).get().topic).isNull();
    try {
        gApi.changes().id(id.get()).topic("a-topic");
        fail("expected read-only exception");
    } catch (RestApiException e) {
        Optional<Throwable> oe = Throwables.getCausalChain(e).stream().filter(x -> x instanceof OrmRuntimeException).findFirst();
        assertThat(oe).named("OrmRuntimeException in causal chain of " + e).isPresent();
        assertThat(oe.get().getMessage()).contains("read-only");
    }
    assertThat(gApi.changes().id(id.get()).get().topic).isNull();
    TestTimeUtil.setClock(new Timestamp(until.getTime() + 1000));
    assertThat(gApi.changes().id(id.get()).get().subject).isEqualTo(PushOneCommit.SUBJECT);
    gApi.changes().id(id.get()).topic("a-topic");
    assertThat(gApi.changes().id(id.get()).get().topic).isEqualTo("a-topic");
}
#end_block

#method_before
@Test
public void duplicateCompoundNonIndexOnlyPredicates() throws Exception {
    Predicate<ChangeData> in = parse("(status:new OR status:draft) bar:p file:a");
    Predicate<ChangeData> out = rewrite(in);
    assertThat(out.getClass()).isEqualTo(AndChangeSource.class);
    assertThat(out.getChildren()).containsExactly(query(and(in.getChild(0), in.getChild(2))), in.getChild(1)).inOrder();
}
#method_after
@Test
public void duplicateCompoundNonIndexOnlyPredicates() throws Exception {
    Predicate<ChangeData> in = parse("status:new bar:p file:a");
    Predicate<ChangeData> out = rewrite(in);
    assertThat(out.getClass()).isEqualTo(AndChangeSource.class);
    assertThat(out.getChildren()).containsExactly(query(and(in.getChild(0), in.getChild(2))), in.getChild(1)).inOrder();
}
#end_block

#method_before
@Test
public void getPossibleStatus() throws Exception {
    assertThat(status("file:a")).isEqualTo(EnumSet.allOf(Change.Status.class));
    assertThat(status("is:new")).containsExactly(NEW);
    assertThat(status("-is:new")).containsExactly(DRAFT, MERGED, ABANDONED);
    assertThat(status("is:new OR is:merged")).containsExactly(NEW, MERGED);
    assertThat(status("is:new is:merged")).isEmpty();
    assertThat(status("(is:new is:draft) (is:merged)")).isEmpty();
    assertThat(status("(is:new is:draft) (is:merged)")).isEmpty();
    assertThat(status("(is:new is:draft) OR (is:merged)")).containsExactly(MERGED);
}
#method_after
@Test
public void getPossibleStatus() throws Exception {
    Set<Change.Status> all = EnumSet.allOf(Change.Status.class);
    assertThat(status("file:a")).isEqualTo(all);
    assertThat(status("is:new")).containsExactly(NEW);
    assertThat(status("is:new OR is:merged")).containsExactly(NEW, MERGED);
    assertThat(status("is:new OR is:x")).isEqualTo(all);
    assertThat(status("is:new is:merged")).isEmpty();
    assertThat(status("(is:new) (is:merged)")).isEmpty();
    assertThat(status("(is:new) (is:merged)")).isEmpty();
    assertThat(status("is:new is:x")).containsExactly(NEW);
}
#end_block

#method_before
@Test
public void rebaseAbandonedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(changeId).abandon();
    ChangeInfo info = get(changeId);
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("change is abandoned");
    gApi.changes().id(changeId).revision(r.getCommit().name()).rebase();
}
#method_after
@Test
public void rebaseAbandonedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(changeId).abandon();
    ChangeInfo info = info(changeId);
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("change is abandoned");
    gApi.changes().id(changeId).revision(r.getCommit().name()).rebase();
}
#end_block

#method_before
@Test
public void rebaseOntoAbandonedChange() throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Abandon the first change
    String changeId = r.getChangeId();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(changeId).abandon();
    ChangeInfo info = get(changeId);
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    RebaseInput ri = new RebaseInput();
    ri.base = r.getCommit().name();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("base change is abandoned: " + changeId);
    gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).rebase(ri);
}
#method_after
@Test
public void rebaseOntoAbandonedChange() throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Abandon the first change
    String changeId = r.getChangeId();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(changeId).abandon();
    ChangeInfo info = info(changeId);
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    RebaseInput ri = new RebaseInput();
    ri.base = r.getCommit().name();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("base change is abandoned: " + changeId);
    gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).rebase(ri);
}
#end_block

#method_before
@Test
public void pushCommitOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit of user
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, user.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that the author/committer was NOT added as reviewer (he can't see
    // the change)
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#method_after
@Test
public void pushCommitOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit of user
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, user.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that the author/committer was NOT added as reviewer (he can't see
    // the change)
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
@Test
public void pushCommitWithFooterOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit that references 'user' in a footer
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that 'user' was NOT added as cc ('user' can't see the change)
    setApiUser(admin);
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#method_after
@Test
public void pushCommitWithFooterOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit that references 'user' in a footer
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that 'user' was NOT added as cc ('user' can't see the change)
    setApiUser(admin);
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
@Test
public void addReviewerThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // create change
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // try to add user as reviewer
    setApiUser(admin);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(user.email);
    assertThat(r.error).contains("does not have permission to see this change");
    assertThat(r.reviewers).isNull();
}
#method_after
@Test
public void addReviewerThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // create change
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // try to add user as reviewer
    setApiUser(admin);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(user.email);
    assertThat(r.error).contains("does not have permission to see this change");
    assertThat(r.reviewers).isNull();
}
#end_block

#method_before
@Test
public void implicitlyCcOnNonVotingReviewGwtStyle() throws Exception {
    PushOneCommit.Result r = createChange();
    setApiUser(user);
    assertThat(getReviewerState(r.getChangeId(), user.id)).isEmpty();
    // Exact request format made by GWT UI at ddc6b7160fe416fed9e7e3180489d44c82fd64f8.
    ReviewInput in = new ReviewInput();
    in.labels = ImmutableMap.of("Code-Review", (short) 0);
    in.strictLabels = true;
    in.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    in.message = "comment";
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(in);
    // If we're not reading from NoteDb, then the CCed user will be returned in the REVIEWER state.
    assertThat(getReviewerState(r.getChangeId(), user.id)).hasValue(notesMigration.readChanges() ? CC : REVIEWER);
}
#method_after
@Test
public void implicitlyCcOnNonVotingReviewGwtStyle() throws Exception {
    PushOneCommit.Result r = createChange();
    setApiUser(user);
    assertThat(getReviewerState(r.getChangeId(), user.id)).isEmpty();
    // Exact request format made by GWT UI at ddc6b7160fe416fed9e7e3180489d44c82fd64f8.
    ReviewInput in = new ReviewInput();
    in.labels = ImmutableMap.of("Code-Review", (short) 0);
    in.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    in.message = "comment";
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(in);
    // If we're not reading from NoteDb, then the CCed user will be returned in the REVIEWER state.
    assertThat(getReviewerState(r.getChangeId(), user.id)).hasValue(notesMigration.readChanges() ? CC : REVIEWER);
}
#end_block

#method_before
@Test
public void checkReviewedFlagBeforeAndAfterReview() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    setApiUser(user);
    assertThat(get(r.getChangeId()).reviewed).isNull();
    revision(r).review(ReviewInput.recommend());
    assertThat(get(r.getChangeId()).reviewed).isTrue();
}
#method_after
@Test
public void checkReviewedFlagBeforeAndAfterReview() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    setApiUser(user);
    assertThat(get(r.getChangeId(), REVIEWED).reviewed).isNull();
    revision(r).review(ReviewInput.recommend());
    assertThat(get(r.getChangeId(), REVIEWED).reviewed).isTrue();
}
#end_block

#method_before
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    setApiUser(admin);
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    createDraftChange();
    setApiUser(user);
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try {
        assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(LABELS).withOption(DETAILED_ACCOUNTS).withOption(REVIEWED).get()).hasSize(2);
    } finally {
        enableDb(ctx);
    }
}
#method_after
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    setApiUser(admin);
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    setApiUser(user);
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try {
        assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(LABELS).withOption(DETAILED_ACCOUNTS).withOption(REVIEWED).get()).hasSize(2);
    } finally {
        enableDb(ctx);
    }
}
#end_block

#method_before
@Test
public void createMergePatchSet() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    String parent = currentMaster.getCommit().getName();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2";
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(ALL_REVISIONS, CURRENT_COMMIT, CURRENT_REVISION);
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
}
#method_after
@Test
public void createMergePatchSet() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    String parent = currentMaster.getCommit().getName();
    // push a commit into dev branch
    createBranch("dev");
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2";
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(ALL_REVISIONS, CURRENT_COMMIT, CURRENT_REVISION);
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
}
#end_block

#method_before
@Test
public void createMergePatchSetInheritParent() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    String parent = r.getCommit().getParent(0).getName();
    // advance master branch
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2 inherit parent of ps1";
    in.inheritParent = true;
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(ALL_REVISIONS, CURRENT_COMMIT, CURRENT_REVISION);
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isNotEqualTo(currentMaster.getCommit().getName());
}
#method_after
@Test
public void createMergePatchSetInheritParent() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    String parent = r.getCommit().getParent(0).getName();
    // advance master branch
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    // push a commit into dev branch
    createBranch("dev");
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2 inherit parent of ps1";
    in.inheritParent = true;
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(ALL_REVISIONS, CURRENT_COMMIT, CURRENT_REVISION);
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isNotEqualTo(currentMaster.getCommit().getName());
}
#end_block

#method_before
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitFastForwardIdenticalTree() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "a");
    PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "a");
    assertThat(change1.getCommit().getTree()).isEqualTo(change2.getCommit().getTree());
    // for rebase if necessary, otherwise, the manual rebase of change2 will
    // fail since change1 would be merged as fast forward
    testRepo.reset(initialHead);
    PushOneCommit.Result change0 = createChange("Change 0", "b.txt", "b");
    submit(change0.getChangeId());
    RevCommit headAfterChange0 = getRemoteHead();
    assertThat(headAfterChange0.getShortMessage()).isEqualTo("Change 0");
    submit(change1.getChangeId());
    RevCommit headAfterChange1 = getRemoteHead();
    assertThat(headAfterChange1.getShortMessage()).isEqualTo("Change 1");
    assertThat(headAfterChange0).isEqualTo(headAfterChange1.getParent(0));
    // Do manual rebase first.
    gApi.changes().id(change2.getChangeId()).current().rebase();
    submit(change2.getChangeId());
    RevCommit headAfterChange2 = getRemoteHead();
    assertThat(headAfterChange2.getShortMessage()).isEqualTo("Change 2");
    assertThat(headAfterChange1).isEqualTo(headAfterChange2.getParent(0));
    ChangeInfo info2 = get(change2.getChangeId());
    assertThat(info2.status).isEqualTo(ChangeStatus.MERGED);
}
#method_after
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitFastForwardIdenticalTree() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "a");
    PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "a");
    assertThat(change1.getCommit().getTree()).isEqualTo(change2.getCommit().getTree());
    // for rebase if necessary, otherwise, the manual rebase of change2 will
    // fail since change1 would be merged as fast forward
    testRepo.reset(initialHead);
    PushOneCommit.Result change0 = createChange("Change 0", "b.txt", "b");
    submit(change0.getChangeId());
    RevCommit headAfterChange0 = getRemoteHead();
    assertThat(headAfterChange0.getShortMessage()).isEqualTo("Change 0");
    submit(change1.getChangeId());
    RevCommit headAfterChange1 = getRemoteHead();
    assertThat(headAfterChange1.getShortMessage()).isEqualTo("Change 1");
    assertThat(headAfterChange0).isEqualTo(headAfterChange1.getParent(0));
    // Do manual rebase first.
    gApi.changes().id(change2.getChangeId()).current().rebase();
    submit(change2.getChangeId());
    RevCommit headAfterChange2 = getRemoteHead();
    assertThat(headAfterChange2.getShortMessage()).isEqualTo("Change 2");
    assertThat(headAfterChange1).isEqualTo(headAfterChange2.getParent(0));
    ChangeInfo info2 = info(change2.getChangeId());
    assertThat(info2.status).isEqualTo(ChangeStatus.MERGED);
}
#end_block

#method_before
@Test
public void updateChangeFailureRollsBackRefUpdate() throws Exception {
    assume().that(notesMigration.disableChangeReviewDb()).isTrue();
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getChange().getId();
    String master = "refs/heads/master";
    String backup = "refs/backup/master";
    ObjectId master1 = getRef(master).get();
    assertThat(getRef(backup)).isEmpty();
    // Toy op that copies the value of refs/heads/master to refs/backup/master.
    BatchUpdateOp backupMasterOp = new BatchUpdateOp() {

        ObjectId newId;

        @Override
        public void updateRepo(RepoContext ctx) throws IOException {
            ObjectId oldId = ctx.getRepoView().getRef(backup).orElse(ObjectId.zeroId());
            newId = ctx.getRepoView().getRef(master).get();
            ctx.addRefUpdate(oldId, newId, backup);
        }

        @Override
        public boolean updateChange(ChangeContext ctx) {
            ctx.getUpdate(ctx.getChange().currentPatchSetId()).setChangeMessage("Backed up master branch to " + newId.name());
            return true;
        }
    };
    try (BatchUpdate bu = newBatchUpdate(batchUpdateFactory)) {
        bu.addOp(id, backupMasterOp);
        bu.execute();
    }
    // Ensure backupMasterOp worked.
    assertThat(getRef(backup)).hasValue(master1);
    assertThat(getMessages(id)).contains("Backed up master branch to " + master1.name());
    // Advance master by submitting the change.
    gApi.changes().id(id.get()).current().review(ReviewInput.approve());
    gApi.changes().id(id.get()).current().submit();
    ObjectId master2 = getRef(master).get();
    assertThat(master2).isNotEqualTo(master1);
    int msgCount = getMessages(id).size();
    try (BatchUpdate bu = newBatchUpdate(batchUpdateFactory)) {
        // This time, we attempt to back up master, but we fail during updateChange.
        bu.addOp(id, backupMasterOp);
        String msg = "Change is bad";
        bu.addOp(id, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws ResourceConflictException {
                throw new ResourceConflictException(msg);
            }
        });
        try {
            bu.execute();
            assert_().fail("expected ResourceConflictException");
        } catch (ResourceConflictException e) {
            assertThat(e).hasMessageThat().isEqualTo(msg);
        }
    }
    // If updateChange hadn't failed, backup would have been updated to master2.
    assertThat(getRef(backup)).hasValue(master1);
    assertThat(getMessages(id)).hasSize(msgCount);
}
#method_after
@Test
public void updateChangeFailureRollsBackRefUpdate() throws Exception {
    assume().that(notesMigration.disableChangeReviewDb()).isTrue();
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getChange().getId();
    String master = "refs/heads/master";
    String backup = "refs/backup/master";
    ObjectId master1 = getRef(master).get();
    assertThat(getRef(backup)).isEmpty();
    // Toy op that copies the value of refs/heads/master to refs/backup/master.
    BatchUpdateOp backupMasterOp = new BatchUpdateOp() {

        ObjectId newId;

        @Override
        public void updateRepo(RepoContext ctx) throws IOException {
            ObjectId oldId = ctx.getRepoView().getRef(backup).orElse(ObjectId.zeroId());
            newId = ctx.getRepoView().getRef(master).get();
            ctx.addRefUpdate(oldId, newId, backup);
        }

        @Override
        public boolean updateChange(ChangeContext ctx) {
            ctx.getUpdate(ctx.getChange().currentPatchSetId()).setChangeMessage("Backed up master branch to " + newId.name());
            return true;
        }
    };
    try (BatchUpdate bu = newBatchUpdate(batchUpdateFactory)) {
        bu.addOp(id, backupMasterOp);
        bu.execute();
    }
    // Ensure backupMasterOp worked.
    assertThat(getRef(backup)).hasValue(master1);
    assertThat(getMessages(id)).contains("Backed up master branch to " + master1.name());
    // Advance master by submitting the change.
    gApi.changes().id(id.get()).current().review(ReviewInput.approve());
    gApi.changes().id(id.get()).current().submit();
    ObjectId master2 = getRef(master).get();
    assertThat(master2).isNotEqualTo(master1);
    int msgCount = getMessages(id).size();
    try (BatchUpdate bu = newBatchUpdate(batchUpdateFactory)) {
        // This time, we attempt to back up master, but we fail during updateChange.
        bu.addOp(id, backupMasterOp);
        String msg = "Change is bad";
        bu.addOp(id, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws ResourceConflictException {
                throw new ResourceConflictException(msg);
            }
        });
        try {
            bu.execute();
            fail("expected ResourceConflictException");
        } catch (ResourceConflictException e) {
            assertThat(e).hasMessageThat().isEqualTo(msg);
        }
    }
    // If updateChange hadn't failed, backup would have been updated to master2.
    assertThat(getRef(backup)).hasValue(master1);
    assertThat(getMessages(id)).hasSize(msgCount);
}
#end_block

#method_before
private Iterable<AccountInfo> getReviewers(PushOneCommit.Result r, ReviewerState state) throws Exception {
    return get(r.getChangeId()).reviewers.get(state);
}
#method_after
private Iterable<AccountInfo> getReviewers(PushOneCommit.Result r, ReviewerState state) throws Exception {
    return get(r.getChangeId(), DETAILED_LABELS).reviewers.get(state);
}
#end_block

#method_before
private void assertMail(MailMessage have, MailMessage want) {
    assertThat(have.id()).isEqualTo(want.id());
    assertThat(have.to()).isEqualTo(want.to());
    assertThat(have.from()).isEqualTo(want.from());
    assertThat(have.cc()).isEqualTo(want.cc());
    assertThat(have.dateReceived().getMillis()).isEqualTo(want.dateReceived().getMillis());
    assertThat(have.additionalHeaders()).isEqualTo(want.additionalHeaders());
    assertThat(have.subject()).isEqualTo(want.subject());
    assertThat(have.textContent()).isEqualTo(want.textContent());
    assertThat(have.htmlContent()).isEqualTo(want.htmlContent());
}
#method_after
private void assertMail(MailMessage have, MailMessage want) {
    assertThat(have.id()).isEqualTo(want.id());
    assertThat(have.to()).isEqualTo(want.to());
    assertThat(have.from()).isEqualTo(want.from());
    assertThat(have.cc()).isEqualTo(want.cc());
    assertThat(have.dateReceived()).isEqualTo(want.dateReceived());
    assertThat(have.additionalHeaders()).isEqualTo(want.additionalHeaders());
    assertThat(have.subject()).isEqualTo(want.subject());
    assertThat(have.textContent()).isEqualTo(want.textContent());
    assertThat(have.htmlContent()).isEqualTo(want.htmlContent());
}
#end_block

#method_before
@Test
public void explicitZeroVoteOnNonEmptyRangeIsPresent() throws Exception {
    ProjectConfig pc = loadAllProjects();
    allow(pc, forLabel("Code-Review"), -1, 1, REGISTERED_USERS, "refs/heads/*");
    save(pc);
    PatchSetApproval cr = psa(userId, "Code-Review", 0);
    PatchSetApproval v = psa(userId, "Verified", 0);
    assertEquals(Result.create(list(cr), list(), list(v)), norm.normalize(notes, list(cr, v)));
}
#method_after
@Test
public void explicitZeroVoteOnNonEmptyRangeIsPresent() throws Exception {
    ProjectConfig pc = loadAllProjects();
    allow(pc, forLabel("Code-Review"), -1, 1, REGISTERED_USERS, "refs/heads/*");
    save(pc);
    PatchSetApproval cr = psa(userId, "Code-Review", 0);
    PatchSetApproval v = psa(userId, "Verified", 0);
    assertEquals(Result.create(list(cr, v), list(), list()), norm.normalize(notes, list(cr, v)));
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    assume().that(NoteDbMode.get()).isEqualTo(NoteDbMode.OFF);
    // Unlike in the running server, for tests, we don't stack notedb.config on gerrit.config.
    noteDbConfig = new FileBasedConfig(sitePaths.notedb_config.toFile(), FS.detect());
    assertNotesMigrationState(REVIEW_DB);
}
#method_after
@Before
public void setUp() throws Exception {
    assume().that(NoteDbMode.get()).isEqualTo(NoteDbMode.OFF);
    // Unlike in the running server, for tests, we don't stack notedb.config on gerrit.config.
    noteDbConfig = new FileBasedConfig(sitePaths.notedb_config.toFile(), FS.detect());
    assertNotesMigrationState(REVIEW_DB, false, false);
    addedListeners = new ArrayList<>();
}
#end_block

#method_before
@Test
public void preconditionsFail() throws Exception {
    List<Change.Id> cs = ImmutableList.of(new Change.Id(1));
    List<Project.NameKey> ps = ImmutableList.of(new Project.NameKey("p"));
    assertMigrationException("Cannot rebuild without noteDb.changes.write=true", b -> b, NoteDbMigrator::rebuild);
    assertMigrationException("Cannot set both changes and projects", b -> b.setChanges(cs).setProjects(ps), m -> {
    });
    assertMigrationException("Auto-migration cannot be used with trial mode", b -> b.setAutoMigrate(true).setTrialMode(true), m -> {
    });
    assertMigrationException("Cannot set changes or projects during full migration", b -> b.setChanges(cs), NoteDbMigrator::migrate);
    assertMigrationException("Cannot set changes or projects during full migration", b -> b.setProjects(ps), NoteDbMigrator::migrate);
    setNotesMigrationState(READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY);
    assertMigrationException("Migration has already progressed past the endpoint of the \"trial mode\" state", b -> b.setTrialMode(true), NoteDbMigrator::migrate);
    setNotesMigrationState(READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY);
    assertMigrationException("Cannot force rebuild changes; NoteDb is already the primary storage for some changes", b -> b.setForceRebuild(true), NoteDbMigrator::migrate);
}
#method_after
@Test
public void preconditionsFail() throws Exception {
    List<Change.Id> cs = ImmutableList.of(new Change.Id(1));
    List<Project.NameKey> ps = ImmutableList.of(new Project.NameKey("p"));
    assertMigrationException("Cannot rebuild without noteDb.changes.write=true", b -> b, NoteDbMigrator::rebuild);
    assertMigrationException("Cannot set both changes and projects", b -> b.setChanges(cs).setProjects(ps), m -> {
    });
    assertMigrationException("Cannot set changes or projects during full migration", b -> b.setChanges(cs), NoteDbMigrator::migrate);
    assertMigrationException("Cannot set changes or projects during full migration", b -> b.setProjects(ps), NoteDbMigrator::migrate);
    setNotesMigrationState(READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY);
    assertMigrationException("Migration has already progressed past the endpoint of the \"trial mode\" state", b -> b.setTrialMode(true), NoteDbMigrator::migrate);
    setNotesMigrationState(READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY);
    assertMigrationException("Cannot force rebuild changes; NoteDb is already the primary storage for some changes", b -> b.setForceRebuild(true), NoteDbMigrator::migrate);
}
#end_block

#method_before
@Test
public void rebuildOneChangeTrialModeAndForceRebuild() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getChange().getId();
    try (NoteDbMigrator migrator = migratorBuilderProvider.get().setTrialMode(true).build()) {
        migrator.migrate();
    }
    assertNotesMigrationState(READ_WRITE_NO_SEQUENCE);
    ObjectId oldMetaId;
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        Ref ref = repo.exactRef(RefNames.changeMetaRef(id));
        assertThat(ref).isNotNull();
        oldMetaId = ref.getObjectId();
        Change c = db.changes().get(id);
        assertThat(c).isNotNull();
        NoteDbChangeState state = NoteDbChangeState.parse(c);
        assertThat(state).isNotNull();
        assertThat(state.getPrimaryStorage()).isEqualTo(PrimaryStorage.REVIEW_DB);
        assertThat(state.getRefState()).hasValue(RefState.create(oldMetaId, ImmutableMap.of()));
        // Force change to be out of date, and change topic so it will get rebuilt as something other
        // than oldMetaId.
        c.setNoteDbState(INVALID_STATE);
        c.setTopic(name("a-new-topic"));
        db.changes().update(ImmutableList.of(c));
    }
    migrate(b -> b.setTrialMode(true));
    assertNotesMigrationState(READ_WRITE_NO_SEQUENCE);
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        // Change is out of date, but was not rebuilt without forceRebuild.
        assertThat(repo.exactRef(RefNames.changeMetaRef(id)).getObjectId()).isEqualTo(oldMetaId);
        Change c = db.changes().get(id);
        assertThat(c.getNoteDbState()).isEqualTo(INVALID_STATE);
    }
    migrate(b -> b.setTrialMode(true).setForceRebuild(true));
    assertNotesMigrationState(READ_WRITE_NO_SEQUENCE);
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        Ref ref = repo.exactRef(RefNames.changeMetaRef(id));
        assertThat(ref).isNotNull();
        ObjectId newMetaId = ref.getObjectId();
        assertThat(newMetaId).isNotEqualTo(oldMetaId);
        NoteDbChangeState state = NoteDbChangeState.parse(db.changes().get(id));
        assertThat(state).isNotNull();
        assertThat(state.getPrimaryStorage()).isEqualTo(PrimaryStorage.REVIEW_DB);
        assertThat(state.getRefState()).hasValue(RefState.create(newMetaId, ImmutableMap.of()));
    }
}
#method_after
@Test
public void rebuildOneChangeTrialModeAndForceRebuild() throws Exception {
    PushOneCommit.Result r = createChange();
    Change.Id id = r.getChange().getId();
    migrate(b -> b.setTrialMode(true));
    assertNotesMigrationState(READ_WRITE_NO_SEQUENCE, false, true);
    ObjectId oldMetaId;
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        Ref ref = repo.exactRef(RefNames.changeMetaRef(id));
        assertThat(ref).isNotNull();
        oldMetaId = ref.getObjectId();
        Change c = db.changes().get(id);
        assertThat(c).isNotNull();
        NoteDbChangeState state = NoteDbChangeState.parse(c);
        assertThat(state).isNotNull();
        assertThat(state.getPrimaryStorage()).isEqualTo(PrimaryStorage.REVIEW_DB);
        assertThat(state.getRefState()).hasValue(RefState.create(oldMetaId, ImmutableMap.of()));
        // Force change to be out of date, and change topic so it will get rebuilt as something other
        // than oldMetaId.
        c.setNoteDbState(INVALID_STATE);
        c.setTopic(name("a-new-topic"));
        db.changes().update(ImmutableList.of(c));
    }
    migrate(b -> b.setTrialMode(true));
    assertNotesMigrationState(READ_WRITE_NO_SEQUENCE, false, true);
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        // Change is out of date, but was not rebuilt without forceRebuild.
        assertThat(repo.exactRef(RefNames.changeMetaRef(id)).getObjectId()).isEqualTo(oldMetaId);
        Change c = db.changes().get(id);
        assertThat(c.getNoteDbState()).isEqualTo(INVALID_STATE);
    }
    migrate(b -> b.setTrialMode(true).setForceRebuild(true));
    assertNotesMigrationState(READ_WRITE_NO_SEQUENCE, false, true);
    try (Repository repo = repoManager.openRepository(project);
        ReviewDb db = schemaFactory.open()) {
        Ref ref = repo.exactRef(RefNames.changeMetaRef(id));
        assertThat(ref).isNotNull();
        ObjectId newMetaId = ref.getObjectId();
        assertThat(newMetaId).isNotEqualTo(oldMetaId);
        NoteDbChangeState state = NoteDbChangeState.parse(db.changes().get(id));
        assertThat(state).isNotNull();
        assertThat(state.getPrimaryStorage()).isEqualTo(PrimaryStorage.REVIEW_DB);
        assertThat(state.getRefState()).hasValue(RefState.create(newMetaId, ImmutableMap.of()));
    }
}
#end_block

#method_before
private void testFullMigration(int threads) throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = createChange();
    Change.Id id1 = r1.getChange().getId();
    Change.Id id2 = r2.getChange().getId();
    migrate(b -> b.setThreads(threads));
    assertNotesMigrationState(NOTE_DB);
    assertThat(sequences.nextChangeId()).isEqualTo(503);
    ObjectId oldMetaId = null;
    int rowVersion = 0;
    try (ReviewDb db = schemaFactory.open();
        Repository repo = repoManager.openRepository(project)) {
        for (Change.Id id : ImmutableList.of(id1, id2)) {
            String refName = RefNames.changeMetaRef(id);
            Ref ref = repo.exactRef(refName);
            assertThat(ref).named(refName).isNotNull();
            Change c = db.changes().get(id);
            assertThat(c.getTopic()).named("topic of change %s", id).isNull();
            NoteDbChangeState s = NoteDbChangeState.parse(c);
            assertThat(s.getPrimaryStorage()).named("primary storage of change %s", id).isEqualTo(PrimaryStorage.NOTE_DB);
            assertThat(s.getRefState()).named("ref state of change %s").isEmpty();
            if (id.equals(id1)) {
                oldMetaId = ref.getObjectId();
                rowVersion = c.getRowVersion();
            }
        }
    }
    // Do not open a new context, to simulate races with other threads that opened a context earlier
    // in the migration process; this needs to work.
    gApi.changes().id(id1.get()).topic(name("a-topic"));
    // Of course, it should also work with a new context.
    resetCurrentApiUser();
    gApi.changes().id(id1.get()).topic(name("another-topic"));
    try (ReviewDb db = schemaFactory.open();
        Repository repo = repoManager.openRepository(project)) {
        assertThat(repo.exactRef(RefNames.changeMetaRef(id1)).getObjectId()).isNotEqualTo(oldMetaId);
        Change c = db.changes().get(id1);
        assertThat(c.getTopic()).isNull();
        assertThat(c.getRowVersion()).isEqualTo(rowVersion);
    }
}
#method_after
private void testFullMigration(int threads) throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = createChange();
    Change.Id id1 = r1.getChange().getId();
    Change.Id id2 = r2.getChange().getId();
    migrate(b -> b.setThreads(threads));
    assertNotesMigrationState(NOTE_DB, false, false);
    assertThat(sequences.nextChangeId()).isEqualTo(503);
    ObjectId oldMetaId = null;
    int rowVersion = 0;
    try (ReviewDb db = schemaFactory.open();
        Repository repo = repoManager.openRepository(project)) {
        for (Change.Id id : ImmutableList.of(id1, id2)) {
            String refName = RefNames.changeMetaRef(id);
            Ref ref = repo.exactRef(refName);
            assertThat(ref).named(refName).isNotNull();
            Change c = db.changes().get(id);
            assertThat(c.getTopic()).named("topic of change %s", id).isNull();
            NoteDbChangeState s = NoteDbChangeState.parse(c);
            assertThat(s.getPrimaryStorage()).named("primary storage of change %s", id).isEqualTo(PrimaryStorage.NOTE_DB);
            assertThat(s.getRefState()).named("ref state of change %s").isEmpty();
            if (id.equals(id1)) {
                oldMetaId = ref.getObjectId();
                rowVersion = c.getRowVersion();
            }
        }
    }
    // Do not open a new context, to simulate races with other threads that opened a context earlier
    // in the migration process; this needs to work.
    gApi.changes().id(id1.get()).topic(name("a-topic"));
    // Of course, it should also work with a new context.
    resetCurrentApiUser();
    gApi.changes().id(id1.get()).topic(name("another-topic"));
    try (ReviewDb db = schemaFactory.open();
        Repository repo = repoManager.openRepository(project)) {
        assertThat(repo.exactRef(RefNames.changeMetaRef(id1)).getObjectId()).isNotEqualTo(oldMetaId);
        Change c = db.changes().get(id1);
        assertThat(c.getTopic()).isNull();
        assertThat(c.getRowVersion()).isEqualTo(rowVersion);
    }
}
#end_block

#method_before
@Test
public void autoMigrationConfig() throws Exception {
    createChange();
    migrate(b -> b.setStopAtStateForTesting(WRITE));
    assertNotesMigrationState(WRITE);
    assertThat(NoteDbMigrator.getAutoMigrate(noteDbConfig)).isFalse();
    migrate(b -> b.setAutoMigrate(true).setStopAtStateForTesting(READ_WRITE_NO_SEQUENCE));
    assertNotesMigrationState(READ_WRITE_NO_SEQUENCE);
    assertThat(NoteDbMigrator.getAutoMigrate(noteDbConfig)).isTrue();
    migrate(b -> b);
    assertNotesMigrationState(NOTE_DB);
    assertThat(NoteDbMigrator.getAutoMigrate(noteDbConfig)).isFalse();
}
#method_after
@Test
public void autoMigrationConfig() throws Exception {
    createChange();
    migrate(b -> b.setStopAtStateForTesting(WRITE));
    assertNotesMigrationState(WRITE, false, false);
    migrate(b -> b.setAutoMigrate(true).setStopAtStateForTesting(READ_WRITE_NO_SEQUENCE));
    assertNotesMigrationState(READ_WRITE_NO_SEQUENCE, true, false);
    migrate(b -> b);
    assertNotesMigrationState(NOTE_DB, false, false);
}
#end_block

#method_before
private void assertNotesMigrationState(NotesMigrationState expected) throws Exception {
    assertThat(NotesMigrationState.forNotesMigration(notesMigration)).hasValue(expected);
    noteDbConfig.load();
    assertThat(NotesMigrationState.forConfig(noteDbConfig)).hasValue(expected);
}
#method_after
private void assertNotesMigrationState(NotesMigrationState expected, boolean autoMigrate, boolean trialMode) throws Exception {
    assertThat(NotesMigrationState.forNotesMigration(notesMigration)).hasValue(expected);
    noteDbConfig.load();
    assertThat(NotesMigrationState.forConfig(noteDbConfig)).hasValue(expected);
    assertThat(NoteDbMigrator.getAutoMigrate(noteDbConfig)).named("noteDb.changes.autoMigrate").isEqualTo(autoMigrate);
    assertThat(NoteDbMigrator.getTrialMode(noteDbConfig)).named("noteDb.changes.trial").isEqualTo(trialMode);
}
#end_block

#method_before
private void assertMigrationException(String expectMessageContains, PrepareBuilder b, RunMigration m) throws Exception {
    try {
        migrate(b, m);
    } catch (MigrationException e) {
        assertThat(e).hasMessageThat().contains(expectMessageContains);
    }
}
#method_after
private void assertMigrationException(String expectMessageContains, PrepareBuilder b, RunMigration m) throws Exception {
    try {
        migrate(b, m);
        fail("expected MigrationException");
    } catch (MigrationException e) {
        assertThat(e).hasMessageThat().contains(expectMessageContains);
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    admins = groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID();
    setUpPermissions();
    setUpChanges();
}
#method_after
@Before
public void setUp() throws Exception {
    admins = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID();
    setUpPermissions();
    setUpChanges();
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    Injector injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    lifecycle = new LifecycleManager();
    lifecycle.add(injector);
    lifecycle.start();
    db = schemaFactory.open();
    schemaCreator.create(db);
    // Need to create at least one user to be admin before creating a "normal"
    // registered user.
    // See AccountManager#create().
    accountManager.authenticate(AuthRequest.forUser("admin")).getAccountId();
    admins = groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID();
    setUpPermissions();
    Account.Id userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    user = userFactory.create(userId);
    Project.NameKey name = new Project.NameKey("project");
    InMemoryRepository inMemoryRepo = repoManager.createRepository(name);
    project = new ProjectConfig(name);
    project.load(inMemoryRepo);
    repo = new TestRepository<>(inMemoryRepo);
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return user;
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return Providers.of(db);
        }
    });
}
#method_after
@Before
public void setUp() throws Exception {
    Injector injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    lifecycle = new LifecycleManager();
    lifecycle.add(injector);
    lifecycle.start();
    db = schemaFactory.open();
    schemaCreator.create(db);
    // Need to create at least one user to be admin before creating a "normal"
    // registered user.
    // See AccountManager#create().
    accountManager.authenticate(AuthRequest.forUser("admin")).getAccountId();
    admins = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID();
    setUpPermissions();
    Account.Id userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    user = userFactory.create(userId);
    Project.NameKey name = new Project.NameKey("project");
    InMemoryRepository inMemoryRepo = repoManager.createRepository(name);
    project = new ProjectConfig(name);
    project.load(inMemoryRepo);
    repo = new TestRepository<>(inMemoryRepo);
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return user;
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return Providers.of(db);
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    // Do NOT bind @RemotePeer, as it is bound in a child injector of
    // ChangeMergeQueue (bound via GerritGlobalModule below), so there cannot be
    // a binding in the parent injector. If you need @RemotePeer, you must bind
    // it in a child injector of the one containing InMemoryModule. But unless
    // you really need to test something request-scoped, you likely don't
    // actually need it.
    // For simplicity, don't create child injectors, just use this one to get a
    // few required modules.
    Injector cfgInjector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
        }
    });
    bind(MetricMaker.class).to(DisabledMetricMaker.class);
    install(cfgInjector.getInstance(GerritGlobalModule.class));
    install(new DefaultPermissionBackendModule());
    install(new SearchingChangeCacheImpl.Module());
    factory(GarbageCollection.Factory.class);
    bindScope(RequestScoped.class, PerThreadRequestScope.REQUEST);
    // TODO(dborowitz): Use jimfs.
    bind(Path.class).annotatedWith(SitePath.class).toInstance(Paths.get("."));
    bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
    bind(GerritOptions.class).toInstance(new GerritOptions(cfg, false, false, false));
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
    bind(String.class).annotatedWith(GerritServerId.class).toInstance("gerrit");
    bind(AllProjectsName.class).toProvider(AllProjectsNameProvider.class);
    bind(AllUsersName.class).toProvider(AllUsersNameProvider.class);
    bind(GitRepositoryManager.class).to(InMemoryRepositoryManager.class);
    bind(InMemoryRepositoryManager.class).in(SINGLETON);
    bind(TrackingFooters.class).toProvider(TrackingFootersProvider.class).in(SINGLETON);
    bind(MutableNotesMigration.class).toInstance(notesMigration);
    bind(NotesMigration.class).to(MutableNotesMigration.class);
    bind(ListeningExecutorService.class).annotatedWith(ChangeUpdateExecutor.class).toInstance(MoreExecutors.newDirectExecutorService());
    bind(DataSourceType.class).to(InMemoryH2Type.class);
    bind(ChangeBundleReader.class).to(GwtormChangeBundleReader.class);
    bind(SecureStore.class).to(DefaultSecureStore.class);
    TypeLiteral<SchemaFactory<ReviewDb>> schemaFactory = new TypeLiteral<SchemaFactory<ReviewDb>>() {
    };
    bind(schemaFactory).to(NotesMigrationSchemaFactory.class);
    bind(Key.get(schemaFactory, ReviewDbFactory.class)).to(InMemoryDatabase.class);
    install(NoSshKeyCache.module());
    install(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    // Replacement of DiffExecutorModule to not use thread pool in the tests
    install(new AbstractModule() {

        @Override
        protected void configure() {
        }

        @Provides
        @Singleton
        @DiffExecutor
        public ExecutorService createDiffExecutor() {
            return MoreExecutors.newDirectExecutorService();
        }
    });
    install(new DefaultCacheFactory.Module());
    install(new FakeEmailSender.Module());
    install(new SignedTokenEmailTokenVerifier.Module());
    install(new GpgModule(cfg));
    install(new InMemoryAccountPatchReviewStore.Module());
    bind(AllAccountsIndexer.class).toProvider(Providers.of(null));
    bind(AllChangesIndexer.class).toProvider(Providers.of(null));
    bind(AllGroupsIndexer.class).toProvider(Providers.of(null));
    IndexType indexType = null;
    try {
        indexType = cfg.getEnum("index", null, "type", IndexType.LUCENE);
    } catch (IllegalArgumentException e) {
    // Custom index type, caller must provide their own module.
    }
    if (indexType != null) {
        switch(indexType) {
            case LUCENE:
                install(luceneIndexModule());
                break;
            case ELASTICSEARCH:
                install(elasticIndexModule());
                break;
            default:
                throw new ProvisionException("index type unsupported in tests: " + indexType);
        }
    }
    bind(ServerInformationImpl.class);
    bind(ServerInformation.class).to(ServerInformationImpl.class);
    install(new PluginRestApiModule());
}
#method_after
@Override
protected void configure() {
    // Do NOT bind @RemotePeer, as it is bound in a child injector of
    // ChangeMergeQueue (bound via GerritGlobalModule below), so there cannot be
    // a binding in the parent injector. If you need @RemotePeer, you must bind
    // it in a child injector of the one containing InMemoryModule. But unless
    // you really need to test something request-scoped, you likely don't
    // actually need it.
    // For simplicity, don't create child injectors, just use this one to get a
    // few required modules.
    Injector cfgInjector = Guice.createInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
        }
    });
    bind(MetricMaker.class).to(DisabledMetricMaker.class);
    install(cfgInjector.getInstance(GerritGlobalModule.class));
    install(new DefaultPermissionBackendModule());
    install(new SearchingChangeCacheImpl.Module());
    factory(GarbageCollection.Factory.class);
    bindScope(RequestScoped.class, PerThreadRequestScope.REQUEST);
    // TODO(dborowitz): Use jimfs.
    bind(Path.class).annotatedWith(SitePath.class).toInstance(Paths.get("."));
    bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(cfg);
    bind(GerritOptions.class).toInstance(new GerritOptions(cfg, false, false, false));
    bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toProvider(GerritPersonIdentProvider.class);
    bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
    bind(String.class).annotatedWith(GerritServerId.class).toInstance("gerrit");
    bind(AllProjectsName.class).toProvider(AllProjectsNameProvider.class);
    bind(AllUsersName.class).toProvider(AllUsersNameProvider.class);
    bind(GitRepositoryManager.class).to(InMemoryRepositoryManager.class);
    bind(InMemoryRepositoryManager.class).in(SINGLETON);
    bind(TrackingFooters.class).toProvider(TrackingFootersProvider.class).in(SINGLETON);
    bind(MutableNotesMigration.class).toInstance(notesMigration);
    bind(NotesMigration.class).to(MutableNotesMigration.class);
    bind(ListeningExecutorService.class).annotatedWith(ChangeUpdateExecutor.class).toInstance(MoreExecutors.newDirectExecutorService());
    bind(DataSourceType.class).to(InMemoryH2Type.class);
    bind(ChangeBundleReader.class).to(GwtormChangeBundleReader.class);
    bind(SecureStore.class).to(DefaultSecureStore.class);
    TypeLiteral<SchemaFactory<ReviewDb>> schemaFactory = new TypeLiteral<SchemaFactory<ReviewDb>>() {
    };
    bind(schemaFactory).to(NotesMigrationSchemaFactory.class);
    bind(Key.get(schemaFactory, ReviewDbFactory.class)).to(InMemoryDatabase.class);
    install(NoSshKeyCache.module());
    install(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    // Replacement of DiffExecutorModule to not use thread pool in the tests
    install(new AbstractModule() {

        @Override
        protected void configure() {
        }

        @Provides
        @Singleton
        @DiffExecutor
        public ExecutorService createDiffExecutor() {
            return MoreExecutors.newDirectExecutorService();
        }
    });
    install(new DefaultCacheFactory.Module());
    install(new FakeEmailSender.Module());
    install(new SignedTokenEmailTokenVerifier.Module());
    install(new GpgModule(cfg));
    install(new InMemoryAccountPatchReviewStore.Module());
    install(new LocalMergeSuperSetComputation.Module());
    bind(AllAccountsIndexer.class).toProvider(Providers.of(null));
    bind(AllChangesIndexer.class).toProvider(Providers.of(null));
    bind(AllGroupsIndexer.class).toProvider(Providers.of(null));
    IndexType indexType = null;
    try {
        indexType = cfg.getEnum("index", null, "type", IndexType.LUCENE);
    } catch (IllegalArgumentException e) {
    // Custom index type, caller must provide their own module.
    }
    if (indexType != null) {
        switch(indexType) {
            case LUCENE:
                install(luceneIndexModule());
                break;
            case ELASTICSEARCH:
                install(elasticIndexModule());
                break;
            default:
                throw new ProvisionException("index type unsupported in tests: " + indexType);
        }
    }
    bind(ServerInformationImpl.class);
    bind(ServerInformation.class).to(ServerInformationImpl.class);
    install(new PluginRestApiModule());
    install(new DefaultProjectNameLockManager.Module());
}
#end_block

#method_before
private Map<String, Integer> getSingleSchemaVersions() {
    Map<String, Integer> singleVersions = new HashMap<>();
    putSchemaVersion(singleVersions, AccountSchemaDefinitions.INSTANCE);
    putSchemaVersion(singleVersions, ChangeSchemaDefinitions.INSTANCE);
    putSchemaVersion(singleVersions, GroupSchemaDefinitions.INSTANCE);
    return singleVersions;
}
#method_after
private Map<String, Integer> getSingleSchemaVersions() {
    Map<String, Integer> singleVersions = new HashMap<>();
    putSchemaVersion(singleVersions, AccountSchemaDefinitions.INSTANCE);
    putSchemaVersion(singleVersions, ChangeSchemaDefinitions.INSTANCE);
    putSchemaVersion(singleVersions, GroupSchemaDefinitions.INSTANCE);
    putSchemaVersion(singleVersions, ProjectSchemaDefinitions.INSTANCE);
    return singleVersions;
}
#end_block

#method_before
protected void assertNew(String changeId) throws Exception {
    assertThat(get(changeId).status).isEqualTo(ChangeStatus.NEW);
}
#method_after
protected void assertNew(String changeId) throws Exception {
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.NEW);
}
#end_block

#method_before
@Test
public void doesNotIncludeCurrentFiles() throws Exception {
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id2 = getChangeId(c2_1);
    pushHead(testRepo, "refs/for/master", false);
    SubmittedTogetherInfo info = gApi.changes().id(id2).submittedTogether(EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.changes).hasSize(2);
    assertThat(info.changes.get(0).currentRevision).isEqualTo(c2_1.name());
    assertThat(info.changes.get(1).currentRevision).isEqualTo(c1_1.name());
    assertThat(info.changes.get(0).currentRevision).isEqualTo(c2_1.name());
    RevisionInfo rev = info.changes.get(0).revisions.get(c2_1.name());
    assertThat(rev.files).isNull();
}
#method_after
@Test
public void doesNotIncludeCurrentFiles() throws Exception {
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id2 = getChangeId(c2_1);
    pushHead(testRepo, "refs/for/master", false);
    SubmittedTogetherInfo info = gApi.changes().id(id2).submittedTogether(EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.changes).hasSize(2);
    assertThat(info.changes.get(0).currentRevision).isEqualTo(c2_1.name());
    assertThat(info.changes.get(1).currentRevision).isEqualTo(c1_1.name());
    RevisionInfo rev = info.changes.get(0).revisions.get(c2_1.name());
    assertThat(rev.files).isNull();
}
#end_block

#method_before
@Test
public void returnsCurrentFilesIfOptionRequested() throws Exception {
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id2 = getChangeId(c2_1);
    pushHead(testRepo, "refs/for/master", false);
    SubmittedTogetherInfo info = gApi.changes().id(id2).submittedTogether(EnumSet.of(ListChangesOption.CURRENT_FILES), EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.changes).hasSize(2);
    assertThat(info.changes.get(0).currentRevision).isEqualTo(c2_1.name());
    assertThat(info.changes.get(1).currentRevision).isEqualTo(c1_1.name());
    assertThat(info.changes.get(0).currentRevision).isEqualTo(c2_1.name());
    RevisionInfo rev = info.changes.get(0).revisions.get(c2_1.name());
    assertThat(rev).isNotNull();
    FileInfo file = rev.files.get("b.txt");
    assertThat(file).isNotNull();
    assertThat(file.status).isEqualTo('A');
}
#method_after
@Test
public void returnsCurrentFilesIfOptionRequested() throws Exception {
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id2 = getChangeId(c2_1);
    pushHead(testRepo, "refs/for/master", false);
    SubmittedTogetherInfo info = gApi.changes().id(id2).submittedTogether(EnumSet.of(ListChangesOption.CURRENT_FILES), EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.changes).hasSize(2);
    assertThat(info.changes.get(0).currentRevision).isEqualTo(c2_1.name());
    assertThat(info.changes.get(1).currentRevision).isEqualTo(c1_1.name());
    RevisionInfo rev = info.changes.get(0).revisions.get(c2_1.name());
    assertThat(rev).isNotNull();
    FileInfo file = rev.files.get("b.txt");
    assertThat(file).isNotNull();
    assertThat(file.status).isEqualTo('A');
}
#end_block

#method_before
@Test
public void topicChaining() throws Exception {
    RevCommit initialHead = getRemoteHead();
    // Create two independent commits and push.
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    String id1 = getChangeId(c1_1);
    pushHead(testRepo, "refs/for/master/" + name("connectingTopic"), false);
    testRepo.reset(initialHead);
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id2 = getChangeId(c2_1);
    pushHead(testRepo, "refs/for/master/" + name("connectingTopic"), false);
    RevCommit c3_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id3 = getChangeId(c3_1);
    pushHead(testRepo, "refs/for/master/" + name("unrelated-topic"), false);
    if (isSubmitWholeTopicEnabled()) {
        assertSubmittedTogether(id1, id2, id1);
        assertSubmittedTogether(id2, id2, id1);
        assertSubmittedTogether(id3, id3, id2, id1);
    } else {
        assertSubmittedTogether(id1);
        assertSubmittedTogether(id2);
        assertSubmittedTogether(id3, id3, id2);
    }
}
#method_after
@Test
public void topicChaining() throws Exception {
    RevCommit initialHead = getRemoteHead();
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    String id1 = getChangeId(c1_1);
    pushHead(testRepo, "refs/for/master/" + name("connectingTopic"), false);
    testRepo.reset(initialHead);
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id2 = getChangeId(c2_1);
    pushHead(testRepo, "refs/for/master/" + name("connectingTopic"), false);
    RevCommit c3_1 = commitBuilder().add("b.txt", "3").message("subject: 3").create();
    String id3 = getChangeId(c3_1);
    pushHead(testRepo, "refs/for/master/" + name("unrelated-topic"), false);
    if (isSubmitWholeTopicEnabled()) {
        assertSubmittedTogether(id1, id2, id1);
        assertSubmittedTogether(id2, id2, id1);
        assertSubmittedTogether(id3, id3, id2, id1);
    } else {
        assertSubmittedTogether(id1);
        assertSubmittedTogether(id2);
        assertSubmittedTogether(id3, id3, id2);
    }
}
#end_block

#method_before
@Test
public void voteOnBehalfOfInvalidLabel() throws Exception {
    allowCodeReviewOnBehalfOf();
    PushOneCommit.Result r = createChange();
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    ReviewInput in = new ReviewInput();
    in.onBehalfOf = user.id.toString();
    in.strictLabels = true;
    in.label("Not-A-Label", 5);
    exception.expect(BadRequestException.class);
    exception.expectMessage("label \"Not-A-Label\" is not a configured label");
    revision.review(in);
}
#method_after
@Test
public void voteOnBehalfOfInvalidLabel() throws Exception {
    allowCodeReviewOnBehalfOf();
    PushOneCommit.Result r = createChange();
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    ReviewInput in = new ReviewInput();
    in.onBehalfOf = user.id.toString();
    in.label("Not-A-Label", 5);
    exception.expect(BadRequestException.class);
    exception.expectMessage("label \"Not-A-Label\" is not a configured label");
    revision.review(in);
}
#end_block

#method_before
@Test
public void currentRevisionActionVisitor() throws Exception {
    String id = createChange().getChangeId();
    amendChange(id);
    ChangeInfo origChange = gApi.changes().id(id).get(CHANGE_ACTIONS);
    Change.Id changeId = new Change.Id(origChange._number);
    class Visitor implements ActionVisitor {

        @Override
        public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo) {
            // Do nothing; implicitly called for CURRENT_ACTIONS.
            return true;
        }

        @Override
        public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
            assertThat(changeInfo).isNotNull();
            assertThat(changeInfo._number).isEqualTo(origChange._number);
            assertThat(revisionInfo).isNotNull();
            assertThat(revisionInfo._number).isEqualTo(2);
            if (name.equals("cherrypick")) {
                return false;
            }
            if (name.equals("rebase")) {
                actionInfo.label = "All Your Base";
            }
            return true;
        }
    }
    Map<String, ActionInfo> origActions = gApi.changes().id(id).current().actions();
    assertThat(origActions.keySet()).containsAllOf("cherrypick", "rebase");
    assertThat(origActions.get("rebase").label).isEqualTo("Rebase");
    Visitor v = new Visitor();
    visitorHandle = actionVisitors.add(v);
    // Test different codepaths within ActionJson...
    // ...via revision API.
    visitedCurrentRevisionActionsAssertions(origActions, gApi.changes().id(id).current().actions());
    // ...via change API with option.
    EnumSet<ListChangesOption> opts = EnumSet.of(CURRENT_ACTIONS, CURRENT_REVISION);
    ChangeInfo changeInfo = gApi.changes().id(id).get(opts);
    RevisionInfo revisionInfo = Iterables.getOnlyElement(changeInfo.revisions.values());
    visitedCurrentRevisionActionsAssertions(origActions, revisionInfo.actions);
    // ...via ChangeJson directly.
    ChangeData cd = changeDataFactory.create(db, project, changeId);
    revisionInfo = changeJsonFactory.create(opts).getRevisionInfo(cd.changeControl(), cd.patchSet(new PatchSet.Id(changeId, 1)));
}
#method_after
@Test
public void currentRevisionActionVisitor() throws Exception {
    String id = createChange().getChangeId();
    amendChange(id);
    ChangeInfo origChange = gApi.changes().id(id).get(CHANGE_ACTIONS);
    Change.Id changeId = new Change.Id(origChange._number);
    class Visitor implements ActionVisitor {

        @Override
        public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo) {
            // Do nothing; implicitly called for CURRENT_ACTIONS.
            return true;
        }

        @Override
        public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
            assertThat(changeInfo).isNotNull();
            assertThat(changeInfo._number).isEqualTo(origChange._number);
            assertThat(revisionInfo).isNotNull();
            assertThat(revisionInfo._number).isEqualTo(2);
            if (name.equals("cherrypick")) {
                return false;
            }
            if (name.equals("rebase")) {
                actionInfo.label = "All Your Base";
            }
            return true;
        }
    }
    Map<String, ActionInfo> origActions = gApi.changes().id(id).current().actions();
    assertThat(origActions.keySet()).containsAllOf("cherrypick", "rebase");
    assertThat(origActions.get("rebase").label).isEqualTo("Rebase");
    Visitor v = new Visitor();
    visitorHandle = actionVisitors.add(v);
    // Test different codepaths within ActionJson...
    // ...via revision API.
    visitedCurrentRevisionActionsAssertions(origActions, gApi.changes().id(id).current().actions());
    // ...via change API with option.
    EnumSet<ListChangesOption> opts = EnumSet.of(CURRENT_ACTIONS, CURRENT_REVISION);
    ChangeInfo changeInfo = gApi.changes().id(id).get(opts);
    RevisionInfo revisionInfo = Iterables.getOnlyElement(changeInfo.revisions.values());
    visitedCurrentRevisionActionsAssertions(origActions, revisionInfo.actions);
    // ...via ChangeJson directly.
    ChangeData cd = changeDataFactory.create(db, project, changeId);
    revisionInfo = changeJsonFactory.create(opts).getRevisionInfo(cd, cd.patchSet(new PatchSet.Id(changeId, 1)));
}
#end_block

#method_before
@Test
public void patchSetStates() throws Exception {
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementCurrentPatchSetFieldOnly(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.setPatchSetState(PatchSetState.DRAFT);
    update.putApproval("Code-Review", (short) 1);
    update.setChangeMessage("This is a message");
    update.putComment(Status.PUBLISHED, newComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name(), false));
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isTrue();
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getApprovals()).isNotEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isNotEmpty();
    assertThat(notes.getChangeMessages()).isNotEmpty();
    assertThat(notes.getComments()).isNotEmpty();
    // publish ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.PUBLISHED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isFalse();
    // delete ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.DELETED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1);
    assertThat(notes.getApprovals()).isEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isEmpty();
    assertThat(notes.getChangeMessages()).isEmpty();
    assertThat(notes.getComments()).isEmpty();
}
#method_after
@Test
public void patchSetStates() throws Exception {
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementCurrentPatchSetFieldOnly(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.putApproval("Code-Review", (short) 1);
    update.setChangeMessage("This is a message");
    update.putComment(Status.PUBLISHED, newComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name(), false));
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getApprovals()).isNotEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isNotEmpty();
    assertThat(notes.getChangeMessages()).isNotEmpty();
    assertThat(notes.getComments()).isNotEmpty();
    // publish ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.PUBLISHED);
    update.commit();
    // delete ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.DELETED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1);
    assertThat(notes.getApprovals()).isEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isEmpty();
    assertThat(notes.getChangeMessages()).isEmpty();
    assertThat(notes.getComments()).isEmpty();
}
#end_block

#method_before
@Test
public void abandon() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(changeId).abandon();
    ChangeInfo info = get(changeId);
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("change is abandoned");
    gApi.changes().id(changeId).abandon();
}
#method_after
@Test
public void abandon() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(changeId).abandon();
    ChangeInfo info = get(changeId, MESSAGES);
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("change is abandoned");
    gApi.changes().id(changeId).abandon();
}
#end_block

#method_before
@Test
public void batchAbandon() throws Exception {
    CurrentUser user = atrScope.get().getUser();
    PushOneCommit.Result a = createChange();
    PushOneCommit.Result b = createChange();
    List<ChangeData> list = ImmutableList.of(a.getChange(), b.getChange());
    changeAbandoner.batchAbandon(batchUpdateFactory, a.getChange().project(), user, list, "deadbeef");
    ChangeInfo info = get(a.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
    info = get(b.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
}
#method_after
@Test
public void batchAbandon() throws Exception {
    CurrentUser user = atrScope.get().getUser();
    PushOneCommit.Result a = createChange();
    PushOneCommit.Result b = createChange();
    List<ChangeData> list = ImmutableList.of(a.getChange(), b.getChange());
    changeAbandoner.batchAbandon(batchUpdateFactory, a.getChange().project(), user, list, "deadbeef");
    ChangeInfo info = get(a.getChangeId(), MESSAGES);
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
    info = get(b.getChangeId(), MESSAGES);
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("deadbeef");
}
#end_block

#method_before
@Test
public void restore() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(changeId).abandon();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.ABANDONED);
    gApi.changes().id(changeId).restore();
    ChangeInfo info = get(changeId);
    assertThat(info.status).isEqualTo(ChangeStatus.NEW);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("restored");
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("change is new");
    gApi.changes().id(changeId).restore();
}
#method_after
@Test
public void restore() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(changeId).abandon();
    assertThat(info(changeId).status).isEqualTo(ChangeStatus.ABANDONED);
    gApi.changes().id(changeId).restore();
    ChangeInfo info = get(changeId, MESSAGES);
    assertThat(info.status).isEqualTo(ChangeStatus.NEW);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("restored");
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("change is new");
    gApi.changes().id(changeId).restore();
}
#end_block

#method_before
@Before
public void setUp() {
    String tz = "US/Eastern";
    systemTimeZoneProperty = System.setProperty("user.timezone", tz);
    systemTimeZone = TimeZone.getDefault();
    TimeZone.setDefault(TimeZone.getTimeZone(tz));
    long maxMs = ChangeRebuilderImpl.MAX_WINDOW_MS;
    assertThat(maxMs).isGreaterThan(1000L);
    TestTimeUtil.resetWithClockStep(maxMs * 2, MILLISECONDS);
    project = new Project.NameKey("project");
    accountId = new Account.Id(100);
}
#method_after
@Before
public void setUp() {
    systemTimeZoneProperty = System.setProperty("user.timezone", TIMEZONE_ID);
    systemTimeZone = TimeZone.getDefault();
    TimeZone.setDefault(TimeZone.getTimeZone(TIMEZONE_ID));
    long maxMs = ChangeRebuilderImpl.MAX_WINDOW_MS;
    assertThat(maxMs).isGreaterThan(1000L);
    TestTimeUtil.resetWithClockStep(maxMs * 2, MILLISECONDS);
    project = new Project.NameKey("project");
    accountId = new Account.Id(100);
}
#end_block

#method_before
@Test
public void diffPatchSetApprovalsAllowsTruncatedTimestampInNoteDb() throws Exception {
    Change c = TestChanges.newChange(project, accountId);
    PatchSetApproval a1 = new PatchSetApproval(new PatchSetApproval.Key(c.currentPatchSetId(), accountId, new LabelId("Code-Review")), (short) 1, c.getCreatedOn());
    PatchSetApproval a2 = clone(a1);
    a2.setGranted(new Timestamp(new DateTime(1900, 1, 1, 0, 0, 0, DateTimeZone.forTimeZone(TimeZone.getDefault())).getMillis()));
    // Both are ReviewDb, exact match is required.
    ChangeBundle b1 = new ChangeBundle(c, messages(), latest(c), approvals(a1), comments(), reviewers(), REVIEW_DB);
    ChangeBundle b2 = new ChangeBundle(c, messages(), latest(c), approvals(a2), comments(), reviewers(), REVIEW_DB);
    assertDiffs(b1, b2, "granted differs for PatchSetApproval.Key " + c.getId() + "%2C1,100,Code-Review:" + " {2009-09-30 17:00:00.0} != {1900-01-01 00:00:00.0}");
    // Truncating NoteDb timestamp is allowed.
    b1 = new ChangeBundle(c, messages(), latest(c), approvals(a1), comments(), reviewers(), NOTE_DB);
    b2 = new ChangeBundle(c, messages(), latest(c), approvals(a2), comments(), reviewers(), REVIEW_DB);
    assertNoDiffs(b1, b2);
    assertNoDiffs(b2, b1);
}
#method_after
@Test
public void diffPatchSetApprovalsAllowsTruncatedTimestampInNoteDb() throws Exception {
    Change c = TestChanges.newChange(project, accountId);
    PatchSetApproval a1 = new PatchSetApproval(new PatchSetApproval.Key(c.currentPatchSetId(), accountId, new LabelId("Code-Review")), (short) 1, c.getCreatedOn());
    PatchSetApproval a2 = clone(a1);
    a2.setGranted(new Timestamp(LocalDate.of(1900, Month.JANUARY, 1).atStartOfDay().atZone(ZoneId.of(TIMEZONE_ID)).toInstant().toEpochMilli()));
    // Both are ReviewDb, exact match is required.
    ChangeBundle b1 = new ChangeBundle(c, messages(), latest(c), approvals(a1), comments(), reviewers(), REVIEW_DB);
    ChangeBundle b2 = new ChangeBundle(c, messages(), latest(c), approvals(a2), comments(), reviewers(), REVIEW_DB);
    assertDiffs(b1, b2, "granted differs for PatchSetApproval.Key " + c.getId() + "%2C1,100,Code-Review:" + " {2009-09-30 17:00:00.0} != {1900-01-01 00:00:00.0}");
    // Truncating NoteDb timestamp is allowed.
    b1 = new ChangeBundle(c, messages(), latest(c), approvals(a1), comments(), reviewers(), NOTE_DB);
    b2 = new ChangeBundle(c, messages(), latest(c), approvals(a2), comments(), reviewers(), REVIEW_DB);
    assertNoDiffs(b1, b2);
    assertNoDiffs(b2, b1);
}
#end_block

#method_before
public static synchronized void resetWithClockStep(long clockStep, TimeUnit clockStepUnit) {
    // Set an arbitrary start point so tests are more repeatable.
    clockMs = new AtomicLong(START.getMillis());
    setClockStep(clockStep, clockStepUnit);
}
#method_after
public static synchronized void resetWithClockStep(long clockStep, TimeUnit clockStepUnit) {
    // Set an arbitrary start point so tests are more repeatable.
    clockMs = new AtomicLong(START.toEpochMilli());
    setClockStep(clockStep, clockStepUnit);
}
#end_block

#method_before
public static synchronized void setClockStep(long clockStep, TimeUnit clockStepUnit) {
    checkState(clockMs != null, "call resetWithClockStep first");
    clockStepMs = MILLISECONDS.convert(clockStep, clockStepUnit);
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#method_after
public static synchronized void setClockStep(long clockStep, TimeUnit clockStepUnit) {
    checkState(clockMs != null, "call resetWithClockStep first");
    clockStepMs = MILLISECONDS.convert(clockStep, clockStepUnit);
    TimeUtil.setCurrentMillisSupplier(() -> clockMs.getAndAdd(clockStepMs));
}
#end_block

#method_before
public static synchronized void useSystemTime() {
    clockMs = null;
    DateTimeUtils.setCurrentMillisSystem();
}
#method_after
public static synchronized void useSystemTime() {
    clockMs = null;
    TimeUtil.resetCurrentMillisSupplier();
}
#end_block

#method_before
private void testOnlineMigration(StartServerWithMigration start) throws Exception {
    assertNotesMigrationState(NotesMigrationState.REVIEW_DB);
    int prevVersion = ChangeSchemaDefinitions.INSTANCE.getPrevious().getVersion();
    int currVersion = ChangeSchemaDefinitions.INSTANCE.getLatest().getVersion();
    // Before storing any changes, switch back to the previous version.
    GerritIndexStatus status = new GerritIndexStatus(sitePaths);
    status.setReady(ChangeSchemaDefinitions.NAME, currVersion, false);
    status.setReady(ChangeSchemaDefinitions.NAME, prevVersion, true);
    status.save();
    setOnlineUpgradeConfig(false);
    setUpOneChange();
    setOnlineUpgradeConfig(true);
    IndexUpgradeController u = new IndexUpgradeController(1);
    try (ServerContext ctx = start.start(u)) {
        ChangeIndexCollection indexes = ctx.getInjector().getInstance(ChangeIndexCollection.class);
        assertThat(indexes.getSearchIndex().getSchema().getVersion()).isEqualTo(prevVersion);
        // Index schema upgrades happen after NoteDb migration, so waiting for those to complete
        // should be sufficient.
        u.runUpgrades();
        assertThat(indexes.getSearchIndex().getSchema().getVersion()).isEqualTo(currVersion);
        assertNotesMigrationState(NotesMigrationState.NOTE_DB);
    }
}
#method_after
private void testOnlineMigration(StartServerWithMigration start) throws Exception {
    testOnlineMigration(start, NotesMigrationState.NOTE_DB);
}
#end_block

#method_before
private void testOnlineMigration(StartServerWithMigration start) throws Exception {
    assertNotesMigrationState(NotesMigrationState.REVIEW_DB);
    int prevVersion = ChangeSchemaDefinitions.INSTANCE.getPrevious().getVersion();
    int currVersion = ChangeSchemaDefinitions.INSTANCE.getLatest().getVersion();
    // Before storing any changes, switch back to the previous version.
    GerritIndexStatus status = new GerritIndexStatus(sitePaths);
    status.setReady(ChangeSchemaDefinitions.NAME, currVersion, false);
    status.setReady(ChangeSchemaDefinitions.NAME, prevVersion, true);
    status.save();
    setOnlineUpgradeConfig(false);
    setUpOneChange();
    setOnlineUpgradeConfig(true);
    IndexUpgradeController u = new IndexUpgradeController(1);
    try (ServerContext ctx = start.start(u)) {
        ChangeIndexCollection indexes = ctx.getInjector().getInstance(ChangeIndexCollection.class);
        assertThat(indexes.getSearchIndex().getSchema().getVersion()).isEqualTo(prevVersion);
        // Index schema upgrades happen after NoteDb migration, so waiting for those to complete
        // should be sufficient.
        u.runUpgrades();
        assertThat(indexes.getSearchIndex().getSchema().getVersion()).isEqualTo(currVersion);
        assertNotesMigrationState(NotesMigrationState.NOTE_DB);
    }
}
#method_after
private void testOnlineMigration(StartServerWithMigration start, NotesMigrationState expectedEndState) throws Exception {
    assertNotesMigrationState(NotesMigrationState.REVIEW_DB);
    int prevVersion = ChangeSchemaDefinitions.INSTANCE.getPrevious().getVersion();
    int currVersion = ChangeSchemaDefinitions.INSTANCE.getLatest().getVersion();
    // Before storing any changes, switch back to the previous version.
    GerritIndexStatus status = new GerritIndexStatus(sitePaths);
    status.setReady(ChangeSchemaDefinitions.NAME, currVersion, false);
    status.setReady(ChangeSchemaDefinitions.NAME, prevVersion, true);
    status.save();
    setOnlineUpgradeConfig(false);
    setUpOneChange();
    setOnlineUpgradeConfig(true);
    IndexUpgradeController u = new IndexUpgradeController(1);
    try (ServerContext ctx = start.start(u)) {
        ChangeIndexCollection indexes = ctx.getInjector().getInstance(ChangeIndexCollection.class);
        assertThat(indexes.getSearchIndex().getSchema().getVersion()).isEqualTo(prevVersion);
        // Index schema upgrades happen after NoteDb migration, so waiting for those to complete
        // should be sufficient.
        u.runUpgrades();
        assertThat(indexes.getSearchIndex().getSchema().getVersion()).isEqualTo(currVersion);
        assertNotesMigrationState(expectedEndState);
    }
}
#end_block

#method_before
protected static FakeEmailSenderSubject assertThat(FakeEmailSender sender) {
    return assertAbout(FAKE_EMAIL_SENDER_SUBJECT_FACTORY).that(sender);
}
#method_after
protected static FakeEmailSenderSubject assertThat(FakeEmailSender sender) {
    return assertAbout(FakeEmailSenderSubject::new).that(sender);
}
#end_block

#method_before
@Test
public void defaultMessage() throws Exception {
    String changeId = createChange().getChangeId();
    ChangeInfo c = get(changeId);
    assertThat(c.messages).isNotNull();
    assertThat(c.messages).hasSize(1);
    assertThat(c.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
}
#method_after
@Test
public void defaultMessage() throws Exception {
    String changeId = createChange().getChangeId();
    ChangeInfo c = get(changeId, MESSAGES);
    assertThat(c.messages).isNotNull();
    assertThat(c.messages).hasSize(1);
    assertThat(c.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
}
#end_block

#method_before
@Test
public void messagesReturnedInChronologicalOrder() throws Exception {
    String changeId = createChange().getChangeId();
    String firstMessage = "Some nits need to be fixed.";
    postMessage(changeId, firstMessage);
    String secondMessage = "I like this feature.";
    postMessage(changeId, secondMessage);
    ChangeInfo c = get(changeId);
    assertThat(c.messages).isNotNull();
    assertThat(c.messages).hasSize(3);
    Iterator<ChangeMessageInfo> it = c.messages.iterator();
    assertThat(it.next().message).isEqualTo("Uploaded patch set 1.");
    assertMessage(firstMessage, it.next().message);
    assertMessage(secondMessage, it.next().message);
}
#method_after
@Test
public void messagesReturnedInChronologicalOrder() throws Exception {
    String changeId = createChange().getChangeId();
    String firstMessage = "Some nits need to be fixed.";
    postMessage(changeId, firstMessage);
    String secondMessage = "I like this feature.";
    postMessage(changeId, secondMessage);
    ChangeInfo c = get(changeId, MESSAGES);
    assertThat(c.messages).isNotNull();
    assertThat(c.messages).hasSize(3);
    Iterator<ChangeMessageInfo> it = c.messages.iterator();
    assertThat(it.next().message).isEqualTo("Uploaded patch set 1.");
    assertMessage(firstMessage, it.next().message);
    assertMessage(secondMessage, it.next().message);
}
#end_block

#method_before
@Test
public void postMessageWithTag() throws Exception {
    String changeId = createChange().getChangeId();
    String tag = "jenkins";
    String msg = "Message with tag.";
    postMessage(changeId, msg, tag);
    ChangeInfo c = get(changeId);
    assertThat(c.messages).isNotNull();
    assertThat(c.messages).hasSize(2);
    Iterator<ChangeMessageInfo> it = c.messages.iterator();
    assertThat(it.next().message).isEqualTo("Uploaded patch set 1.");
    ChangeMessageInfo actual = it.next();
    assertMessage(msg, actual.message);
    assertThat(actual.tag).isEqualTo(tag);
}
#method_after
@Test
public void postMessageWithTag() throws Exception {
    String changeId = createChange().getChangeId();
    String tag = "jenkins";
    String msg = "Message with tag.";
    postMessage(changeId, msg, tag);
    ChangeInfo c = get(changeId, MESSAGES);
    assertThat(c.messages).isNotNull();
    assertThat(c.messages).hasSize(2);
    Iterator<ChangeMessageInfo> it = c.messages.iterator();
    assertThat(it.next().message).isEqualTo("Uploaded patch set 1.");
    ChangeMessageInfo actual = it.next();
    assertMessage(msg, actual.message);
    assertThat(actual.tag).isEqualTo(tag);
}
#end_block

#method_before
private RepoSequence newSequence(String name, final int start, int batchSize, Runnable afterReadRef, Retryer<RefUpdate.Result> retryer) {
    return new RepoSequence(repoManager, project, name, () -> start, batchSize, afterReadRef, retryer);
}
#method_after
private RepoSequence newSequence(String name, final int start, int batchSize, Runnable afterReadRef, Retryer<RefUpdate.Result> retryer) {
    return new RepoSequence(repoManager, GitReferenceUpdated.DISABLED, project, name, () -> start, batchSize, afterReadRef, retryer);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    testEnv.getInjector().injectMembers(this);
    db = testEnv.getDb();
}
#method_after
@Before
public void setUp() throws Exception {
    testEnv.getInjector().injectMembers(this);
    db = testEnv.getDb();
    assume().that(db instanceof JdbcSchema).isTrue();
    connection = ((JdbcSchema) db).getConnection();
    createdOnRetrieval = connection.prepareStatement("SELECT created_on FROM account_groups WHERE group_id = ?");
    createdOnUpdate = connection.prepareStatement("UPDATE account_groups SET created_on = ? WHERE group_id = ?");
    auditEntryDeletion = connection.prepareStatement("DELETE FROM account_group_members_audit WHERE group_id = ?");
}
#end_block

#method_before
@Test
public void createdOnIsPopulatedForGroupsCreatedAfterAudit() throws Exception {
    Timestamp testStartTime = TimeUtil.nowTs();
    AccountGroup.Id groupId = createGroup("Group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    schema151.migrateData(db, new TestUpdateUI());
    AccountGroup group = db.accountGroups().get(groupId);
    assertThat(group.getCreatedOn()).isAtLeast(testStartTime);
}
#method_after
@Test
public void createdOnIsPopulatedForGroupsCreatedAfterAudit() throws Exception {
    Timestamp testStartTime = TimeUtil.nowTs();
    AccountGroup.Id groupId = createGroup("Group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    schema151.migrateData(db, new TestUpdateUI());
    Timestamp createdOn = getCreatedOn(groupId);
    assertThat(createdOn).isAtLeast(testStartTime);
}
#end_block

#method_before
@Test
public void createdOnIsPopulatedForGroupsCreatedBeforeAudit() throws Exception {
    AccountGroup.Id groupId = createGroup("Ancient group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    removeAuditEntriesFor(groupId);
    schema151.migrateData(db, new TestUpdateUI());
    AccountGroup group = db.accountGroups().get(groupId);
    assertThat(group.getCreatedOn()).isEqualTo(AccountGroup.auditCreationInstantTs());
}
#method_after
@Test
public void createdOnIsPopulatedForGroupsCreatedBeforeAudit() throws Exception {
    AccountGroup.Id groupId = createGroup("Ancient group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    removeAuditEntriesFor(groupId);
    schema151.migrateData(db, new TestUpdateUI());
    Timestamp createdOn = getCreatedOn(groupId);
    assertThat(createdOn).isEqualTo(AccountGroup.auditCreationInstantTs());
}
#end_block

#method_before
private void setCreatedOnToVeryOldTimestamp(Id groupId) throws OrmException {
    AccountGroup group = db.accountGroups().get(groupId);
    Instant instant = LocalDateTime.of(1800, Month.JANUARY, 1, 0, 0).toInstant(ZoneOffset.UTC);
    group.setCreatedOn(Timestamp.from(instant));
    db.accountGroups().update(ImmutableList.of(group));
}
#method_after
private void setCreatedOnToVeryOldTimestamp(Id groupId) throws Exception {
    createdOnUpdate.setInt(1, groupId.get());
    Instant instant = LocalDateTime.of(1800, Month.JANUARY, 1, 0, 0).toInstant(ZoneOffset.UTC);
    createdOnUpdate.setTimestamp(1, Timestamp.from(instant));
    createdOnUpdate.setInt(2, groupId.get());
    createdOnUpdate.executeUpdate();
}
#end_block

#method_before
private void removeAuditEntriesFor(AccountGroup.Id groupId) throws Exception {
    ResultSet<AccountGroupMemberAudit> groupMemberAudits = db.accountGroupMembersAudit().byGroup(groupId);
    db.accountGroupMembersAudit().delete(groupMemberAudits);
}
#method_after
private void removeAuditEntriesFor(AccountGroup.Id groupId) throws Exception {
    auditEntryDeletion.setInt(1, groupId.get());
    auditEntryDeletion.executeUpdate();
}
#end_block

#method_before
@Test
public void create() throws Exception {
    // account creation + external ID creation
    create(2);
}
#method_after
@Test
public void create() throws Exception {
    // account creation + external ID creation
    Account.Id accountId = create(2);
    refUpdateCounter.assertRefUpdateFor(RefUpdateCounter.projectRef(allUsers, RefNames.refsUsers(accountId)), RefUpdateCounter.projectRef(allUsers, RefNames.REFS_EXTERNAL_IDS), RefUpdateCounter.projectRef(allUsers, RefNames.REFS_SEQUENCES + Sequences.NAME_ACCOUNTS));
}
#end_block

#method_before
@Test
@UseSsh
public void createWithSshKeys() throws Exception {
    // account creation + external ID creation + adding SSH keys
    create(3);
}
#method_after
@Test
@UseSsh
public void createWithSshKeys() throws Exception {
    // account creation + external ID creation + adding SSH keys
    Account.Id accountId = create(3);
    refUpdateCounter.assertRefUpdateFor(ImmutableMap.of(RefUpdateCounter.projectRef(allUsers, RefNames.refsUsers(accountId)), 2, RefUpdateCounter.projectRef(allUsers, RefNames.REFS_EXTERNAL_IDS), 1, RefUpdateCounter.projectRef(allUsers, RefNames.REFS_SEQUENCES + Sequences.NAME_ACCOUNTS), 1));
}
#end_block

#method_before
private void create(int expectedAccountReindexCalls) throws Exception {
    String name = "foo";
    TestAccount foo = accountCreator.create(name);
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.username).isEqualTo(name);
    assertThat(info.name).isEqualTo(name);
    accountIndexedCounter.assertReindexOf(foo, expectedAccountReindexCalls);
    assertUserBranch(foo.getId(), name, null);
}
#method_after
private Account.Id create(int expectedAccountReindexCalls) throws Exception {
    String name = "foo";
    TestAccount foo = accountCreator.create(name);
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.username).isEqualTo(name);
    assertThat(info.name).isEqualTo(name);
    accountIndexedCounter.assertReindexOf(foo, expectedAccountReindexCalls);
    assertUserBranch(foo.getId(), name, null);
    return foo.getId();
}
#end_block

#method_before
@Test
public void starUnstarChange() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.accounts().self().starChange(triplet);
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).contains(DEFAULT_LABEL);
    gApi.accounts().self().unstarChange(triplet);
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).isNull();
    accountIndexedCounter.assertNoReindex();
}
#method_after
@Test
public void starUnstarChange() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    refUpdateCounter.clear();
    gApi.accounts().self().starChange(triplet);
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).contains(DEFAULT_LABEL);
    refUpdateCounter.assertRefUpdateFor(RefUpdateCounter.projectRef(allUsers, RefNames.refsStarredChanges(new Change.Id(change._number), admin.id)));
    gApi.accounts().self().unstarChange(triplet);
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).isNull();
    refUpdateCounter.assertRefUpdateFor(RefUpdateCounter.projectRef(allUsers, RefNames.refsStarredChanges(new Change.Id(change._number), admin.id)));
    accountIndexedCounter.assertNoReindex();
}
#end_block

#method_before
@Test
public void starUnstarChangeWithLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    assertThat(gApi.accounts().self().getStars(triplet)).isEmpty();
    assertThat(gApi.accounts().self().getStarredChanges()).isEmpty();
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "red", "blue")));
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    List<ChangeInfo> starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    ChangeInfo starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isTrue();
    assertThat(starredChange.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of("yellow"), ImmutableSet.of(DEFAULT_LABEL, "blue")));
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).containsExactly("red", "yellow").inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("red", "yellow").inOrder();
    starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isNull();
    assertThat(starredChange.stars).containsExactly("red", "yellow").inOrder();
    accountIndexedCounter.assertNoReindex();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to get stars of another account");
    gApi.accounts().id(Integer.toString((admin.id.get()))).getStars(triplet);
}
#method_after
@Test
public void starUnstarChangeWithLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    refUpdateCounter.clear();
    assertThat(gApi.accounts().self().getStars(triplet)).isEmpty();
    assertThat(gApi.accounts().self().getStarredChanges()).isEmpty();
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "red", "blue")));
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    List<ChangeInfo> starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    ChangeInfo starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isTrue();
    assertThat(starredChange.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    refUpdateCounter.assertRefUpdateFor(RefUpdateCounter.projectRef(allUsers, RefNames.refsStarredChanges(new Change.Id(change._number), admin.id)));
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of("yellow"), ImmutableSet.of(DEFAULT_LABEL, "blue")));
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).containsExactly("red", "yellow").inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("red", "yellow").inOrder();
    starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isNull();
    assertThat(starredChange.stars).containsExactly("red", "yellow").inOrder();
    refUpdateCounter.assertRefUpdateFor(RefUpdateCounter.projectRef(allUsers, RefNames.refsStarredChanges(new Change.Id(change._number), admin.id)));
    accountIndexedCounter.assertNoReindex();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to get stars of another account");
    gApi.accounts().id(Integer.toString((admin.id.get()))).getStars(triplet);
}
#end_block

#method_before
@Test
@Sandboxed
public void fetchUserBranch() throws Exception {
    setApiUser(user);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers, user);
    String userRefName = RefNames.refsUsers(user.id);
    // remove default READ permissions
    ProjectConfig cfg = projectCache.checkedGet(allUsers).getConfig();
    cfg.getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true).remove(new Permission(Permission.READ));
    saveProjectConfig(allUsers, cfg);
    // deny READ permission that is inherited from All-Projects
    deny(allUsers, RefNames.REFS + "*", Permission.READ, ANONYMOUS_USERS);
    // fetching user branch without READ permission fails
    try {
        fetch(allUsersRepo, userRefName + ":userRef");
        Assert.fail("user branch is visible although no READ permission is granted");
    } catch (TransportException e) {
    // expected because no READ granted on user branch
    }
    // allow each user to read its own user branch
    grant(allUsers, RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", Permission.READ, false, REGISTERED_USERS);
    // fetch user branch using refs/users/YY/XXXXXXX
    fetch(allUsersRepo, userRefName + ":userRef");
    Ref userRef = allUsersRepo.getRepository().exactRef("userRef");
    assertThat(userRef).isNotNull();
    // fetch user branch using refs/users/self
    fetch(allUsersRepo, RefNames.REFS_USERS_SELF + ":userSelfRef");
    Ref userSelfRef = allUsersRepo.getRepository().getRefDatabase().exactRef("userSelfRef");
    assertThat(userSelfRef).isNotNull();
    assertThat(userSelfRef.getObjectId()).isEqualTo(userRef.getObjectId());
    accountIndexedCounter.assertNoReindex();
    // fetching user branch of another user fails
    String otherUserRefName = RefNames.refsUsers(admin.id);
    exception.expect(TransportException.class);
    exception.expectMessage("Remote does not have " + otherUserRefName + " available for fetch.");
    fetch(allUsersRepo, otherUserRefName + ":otherUserRef");
}
#method_after
@Test
@Sandboxed
public void fetchUserBranch() throws Exception {
    setApiUser(user);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers, user);
    String userRefName = RefNames.refsUsers(user.id);
    // remove default READ permissions
    ProjectConfig cfg = projectCache.checkedGet(allUsers).getConfig();
    cfg.getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true).remove(new Permission(Permission.READ));
    saveProjectConfig(allUsers, cfg);
    // deny READ permission that is inherited from All-Projects
    deny(allUsers, RefNames.REFS + "*", Permission.READ, ANONYMOUS_USERS);
    // fetching user branch without READ permission fails
    try {
        fetch(allUsersRepo, userRefName + ":userRef");
        fail("user branch is visible although no READ permission is granted");
    } catch (TransportException e) {
    // expected because no READ granted on user branch
    }
    // allow each user to read its own user branch
    grant(allUsers, RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", Permission.READ, false, REGISTERED_USERS);
    // fetch user branch using refs/users/YY/XXXXXXX
    fetch(allUsersRepo, userRefName + ":userRef");
    Ref userRef = allUsersRepo.getRepository().exactRef("userRef");
    assertThat(userRef).isNotNull();
    // fetch user branch using refs/users/self
    fetch(allUsersRepo, RefNames.REFS_USERS_SELF + ":userSelfRef");
    Ref userSelfRef = allUsersRepo.getRepository().getRefDatabase().exactRef("userSelfRef");
    assertThat(userSelfRef).isNotNull();
    assertThat(userSelfRef.getObjectId()).isEqualTo(userRef.getObjectId());
    accountIndexedCounter.assertNoReindex();
    // fetching user branch of another user fails
    String otherUserRefName = RefNames.refsUsers(admin.id);
    exception.expect(TransportException.class);
    exception.expectMessage("Remote does not have " + otherUserRefName + " available for fetch.");
    fetch(allUsersRepo, otherUserRefName + ":otherUserRef");
}
#end_block

#method_before
@Test
public void pushAccountConfigToUserBranchForReviewDeactivateOtherAccount() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isTrue();
    String userRef = RefNames.refsUsers(foo.id);
    accountIndexedCounter.clear();
    AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    grantLabel("Code-Review", -2, 2, allUsers, userRef, false, adminGroup.getGroupUUID(), false);
    grant(allUsers, userRef, Permission.SUBMIT, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    Config ac = getAccountConfig(allUsersRepo);
    ac.setBoolean(AccountConfig.ACCOUNT, null, AccountConfig.KEY_ACTIVE, false);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(MagicBranch.NEW_CHANGE + userRef);
    r.assertOkStatus();
    accountIndexedCounter.assertNoReindex();
    assertThat(r.getChange().change().getDest().get()).isEqualTo(userRef);
    gApi.changes().id(r.getChangeId()).current().review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).current().submit();
    accountIndexedCounter.assertReindexOf(foo);
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isFalse();
}
#method_after
@Test
public void pushAccountConfigToUserBranchForReviewDeactivateOtherAccount() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isTrue();
    String userRef = RefNames.refsUsers(foo.id);
    accountIndexedCounter.clear();
    InternalGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null);
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    grantLabel("Code-Review", -2, 2, allUsers, userRef, false, adminGroup.getGroupUUID(), false);
    grant(allUsers, userRef, Permission.SUBMIT, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    Config ac = getAccountConfig(allUsersRepo);
    ac.setBoolean(AccountConfig.ACCOUNT, null, AccountConfig.KEY_ACTIVE, false);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(MagicBranch.NEW_CHANGE + userRef);
    r.assertOkStatus();
    accountIndexedCounter.assertNoReindex();
    assertThat(r.getChange().change().getDest().get()).isEqualTo(userRef);
    gApi.changes().id(r.getChangeId()).current().review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).current().submit();
    accountIndexedCounter.assertReindexOf(foo);
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isFalse();
}
#end_block

#method_before
@Test
public void pushAccountConfigToUserBranchInvalidPreferredEmailButNotChanged() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    String userRef = RefNames.refsUsers(foo.id);
    String noEmail = "no.email";
    accountsUpdate.create().update(foo.id, a -> a.setPreferredEmail(noEmail));
    accountIndexedCounter.clear();
    AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    String status = "in vacation";
    Config ac = getAccountConfig(allUsersRepo);
    ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_STATUS, status);
    pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus();
    accountIndexedCounter.assertReindexOf(foo);
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.email).isEqualTo(noEmail);
    assertThat(info.name).isEqualTo(foo.fullName);
    assertThat(info.status).isEqualTo(status);
}
#method_after
@Test
public void pushAccountConfigToUserBranchInvalidPreferredEmailButNotChanged() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    String userRef = RefNames.refsUsers(foo.id);
    String noEmail = "no.email";
    accountsUpdate.create().update(foo.id, a -> a.setPreferredEmail(noEmail));
    accountIndexedCounter.clear();
    InternalGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null);
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    String status = "in vacation";
    Config ac = getAccountConfig(allUsersRepo);
    ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_STATUS, status);
    pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus();
    accountIndexedCounter.assertReindexOf(foo);
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.email).isEqualTo(noEmail);
    assertThat(info.name).isEqualTo(foo.fullName);
    assertThat(info.status).isEqualTo(status);
}
#end_block

#method_before
@Test
public void pushAccountConfigToUserBranchIfPreferredEmailDoesNotExistAsExtId() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    String userRef = RefNames.refsUsers(foo.id);
    accountIndexedCounter.clear();
    AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    String email = "some.email@example.com";
    Config ac = getAccountConfig(allUsersRepo);
    ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_PREFERRED_EMAIL, email);
    pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus();
    accountIndexedCounter.assertReindexOf(foo);
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.email).isEqualTo(email);
    assertThat(info.name).isEqualTo(foo.fullName);
}
#method_after
@Test
public void pushAccountConfigToUserBranchIfPreferredEmailDoesNotExistAsExtId() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    String userRef = RefNames.refsUsers(foo.id);
    accountIndexedCounter.clear();
    InternalGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null);
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    String email = "some.email@example.com";
    Config ac = getAccountConfig(allUsersRepo);
    ac.setString(AccountConfig.ACCOUNT, null, AccountConfig.KEY_PREFERRED_EMAIL, email);
    pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus();
    accountIndexedCounter.assertReindexOf(foo);
    AccountInfo info = gApi.accounts().id(foo.id.get()).get();
    assertThat(info.email).isEqualTo(email);
    assertThat(info.name).isEqualTo(foo.fullName);
}
#end_block

#method_before
@Test
public void pushAccountConfigToUserBranchDeactivateOtherAccount() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isTrue();
    String userRef = RefNames.refsUsers(foo.id);
    accountIndexedCounter.clear();
    AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    Config ac = getAccountConfig(allUsersRepo);
    ac.setBoolean(AccountConfig.ACCOUNT, null, AccountConfig.KEY_ACTIVE, false);
    pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus();
    accountIndexedCounter.assertReindexOf(foo);
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isFalse();
}
#method_after
@Test
public void pushAccountConfigToUserBranchDeactivateOtherAccount() throws Exception {
    TestAccount foo = accountCreator.create(name("foo"));
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isTrue();
    String userRef = RefNames.refsUsers(foo.id);
    accountIndexedCounter.clear();
    InternalGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null);
    grant(allUsers, userRef, Permission.PUSH, false, adminGroup.getGroupUUID());
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRef + ":userRef");
    allUsersRepo.reset("userRef");
    Config ac = getAccountConfig(allUsersRepo);
    ac.setBoolean(AccountConfig.ACCOUNT, null, AccountConfig.KEY_ACTIVE, false);
    pushFactory.create(db, admin.getIdent(), allUsersRepo, "Update account config", AccountConfig.ACCOUNT_CONFIG, ac.toText()).to(userRef).assertOkStatus();
    accountIndexedCounter.assertReindexOf(foo);
    assertThat(gApi.accounts().id(foo.id.get()).getActive()).isFalse();
}
#end_block

#method_before
public static FixSuggestionInfoSubject assertThat(FixSuggestionInfo fixSuggestionInfo) {
    return assertAbout(FIX_SUGGESTION_INFO_SUBJECT_FACTORY).that(fixSuggestionInfo);
}
#method_after
public static FixSuggestionInfoSubject assertThat(FixSuggestionInfo fixSuggestionInfo) {
    return assertAbout(FixSuggestionInfoSubject::new).that(fixSuggestionInfo);
}
#end_block

#method_before
public static RobotCommentInfoSubject assertThat(RobotCommentInfo robotCommentInfo) {
    return assertAbout(ROBOT_COMMENT_INFO_SUBJECT_FACTORY).that(robotCommentInfo);
}
#method_after
public static RobotCommentInfoSubject assertThat(RobotCommentInfo robotCommentInfo) {
    return assertAbout(RobotCommentInfoSubject::new).that(robotCommentInfo);
}
#end_block

#method_before
@Test
public void pushForMasterWithMessage() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId());
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.\nmy test message");
    }
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(1);
    for (RevisionInfo ri : revisions) {
        assertThat(ri.description).isEqualTo("my test message");
    }
}
#method_after
@Test
public void pushForMasterWithMessage() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId(), MESSAGES, ALL_REVISIONS);
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.\nmy test message");
    }
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(1);
    for (RevisionInfo ri : revisions) {
        assertThat(ri.description).isEqualTo("my test message");
    }
}
#end_block

#method_before
@Test
public void pushForMasterWithMessageTwiceWithDifferentMessages() throws Exception {
    enableCreateNewChangeForAllNotInTarget();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%m=new_test_message");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(2);
    for (RevisionInfo ri : revisions) {
        if (ri.isCurrent) {
            assertThat(ri.description).isEqualTo("new test message");
        } else {
            assertThat(ri.description).isEqualTo("my test message");
        }
    }
}
#method_after
@Test
public void pushForMasterWithMessageTwiceWithDifferentMessages() throws Exception {
    enableCreateNewChangeForAllNotInTarget();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    // %2C is comma; the value below tests that percent decoding happens after splitting.
    // All three ways of representing space ("%20", "+", and "_" are also exercised.
    PushOneCommit.Result r = push.to("refs/for/master/%m=my_test%20+_message%2Cm=");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%m=new_test_message");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId(), ALL_REVISIONS);
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(2);
    for (RevisionInfo ri : revisions) {
        if (ri.isCurrent) {
            assertThat(ri.description).isEqualTo("new test message");
        } else {
            assertThat(ri.description).isEqualTo("my test   message,m=");
        }
    }
}
#end_block

#method_before
@Test
public void pushForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(1);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3.");
}
#method_after
@Test
public void pushForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(1);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId(), MESSAGES);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3.");
}
#end_block

#method_before
@Test
public void pushNewPatchSetForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ChangeInfo ci = get(r.getChangeId());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the new patch set was added as a reviewer since they added
    // a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
}
#method_after
@Test
public void pushNewPatchSetForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ChangeInfo ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the new patch set was added as a reviewer since they added
    // a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
}
#end_block

#method_before
@Test
public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws Exception {
    // Create a commit with "User" as author and committer
    RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    // Push this commit as "Administrator" (requires Forge Committer Identity)
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false);
    // Expected Code-Review votes:
    // 1. 0 from User (committer):
    // When the committer is forged, the committer is automatically added as
    // reviewer, hence we expect a dummy 0 vote for the committer.
    // 2. +1 from Administrator (uploader):
    // On push Code-Review+1 was specified, hence we expect a +1 vote from
    // the uploader.
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(2);
    int indexAdmin = admin.fullName.equals(cr.all.get(0).name) ? 0 : 1;
    int indexUser = indexAdmin == 0 ? 1 : 0;
    assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName);
    assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1);
    assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName);
    assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#method_after
@Test
public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws Exception {
    // Create a commit with "User" as author and committer
    RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    // Push this commit as "Administrator" (requires Forge Committer Identity)
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false);
    // Expected Code-Review votes:
    // 1. 0 from User (committer):
    // When the committer is forged, the committer is automatically added as
    // reviewer, hence we expect a dummy 0 vote for the committer.
    // 2. +1 from Administrator (uploader):
    // On push Code-Review+1 was specified, hence we expect a +1 vote from
    // the uploader.
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(2);
    int indexAdmin = admin.fullName.equals(cr.all.get(0).name) ? 0 : 1;
    int indexUser = indexAdmin == 0 ? 1 : 0;
    assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName);
    assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1);
    assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName);
    assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#end_block

#method_before
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#method_after
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get(), DETAILED_LABELS, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#end_block

#method_before
private void assertTwoChangesWithSameRevision(PushOneCommit.Result result) throws Exception {
    List<ChangeInfo> changes = query(result.getCommit().name());
    assertThat(changes).hasSize(2);
    ChangeInfo c1 = get(changes.get(0).id);
    ChangeInfo c2 = get(changes.get(1).id);
    assertThat(c1.project).isEqualTo(c2.project);
    assertThat(c1.branch).isNotEqualTo(c2.branch);
    assertThat(c1.changeId).isEqualTo(c2.changeId);
    assertThat(c1.currentRevision).isEqualTo(c2.currentRevision);
}
#method_after
private void assertTwoChangesWithSameRevision(PushOneCommit.Result result) throws Exception {
    List<ChangeInfo> changes = query(result.getCommit().name());
    assertThat(changes).hasSize(2);
    ChangeInfo c1 = get(changes.get(0).id, CURRENT_REVISION);
    ChangeInfo c2 = get(changes.get(1).id, CURRENT_REVISION);
    assertThat(c1.project).isEqualTo(c2.project);
    assertThat(c1.branch).isNotEqualTo(c2.branch);
    assertThat(c1.changeId).isEqualTo(c2.changeId);
    assertThat(c1.currentRevision).isEqualTo(c2.currentRevision);
}
#end_block

#method_before
public static BinaryResultSubject assertThat(BinaryResult binaryResult) {
    return assertAbout(BINARY_RESULT_SUBJECT_FACTORY).that(binaryResult);
}
#method_after
public static BinaryResultSubject assertThat(BinaryResult binaryResult) {
    return assertAbout(BinaryResultSubject::new).that(binaryResult);
}
#end_block

#method_before
public static EditInfoSubject assertThat(EditInfo editInfo) {
    return assertAbout(EDIT_INFO_SUBJECT_FACTORY).that(editInfo);
}
#method_after
public static EditInfoSubject assertThat(EditInfo editInfo) {
    return assertAbout(EditInfoSubject::new).that(editInfo);
}
#end_block

#method_before
public static FixReplacementInfoSubject assertThat(FixReplacementInfo fixReplacementInfo) {
    return assertAbout(FIX_REPLACEMENT_INFO_SUBJECT_FACTORY).that(fixReplacementInfo);
}
#method_after
public static FixReplacementInfoSubject assertThat(FixReplacementInfo fixReplacementInfo) {
    return assertAbout(FixReplacementInfoSubject::new).that(fixReplacementInfo);
}
#end_block

#method_before
public static CommitInfoSubject assertThat(CommitInfo commitInfo) {
    return assertAbout(COMMIT_INFO_SUBJECT_FACTORY).that(commitInfo);
}
#method_after
public static CommitInfoSubject assertThat(CommitInfo commitInfo) {
    return assertAbout(CommitInfoSubject::new).that(commitInfo);
}
#end_block

#method_before
public static PathSubject assertThat(Path path) {
    return assertAbout(PATH_SUBJECT_FACTORY).that(path);
}
#method_after
public static PathSubject assertThat(Path path) {
    return assertAbout(PathSubject::new).that(path);
}
#end_block

#method_before
public static GitPersonSubject assertThat(GitPerson gitPerson) {
    return assertAbout(GIT_PERSON_SUBJECT_FACTORY).that(gitPerson);
}
#method_after
public static GitPersonSubject assertThat(GitPerson gitPerson) {
    return assertAbout(GitPersonSubject::new).that(gitPerson);
}
#end_block

#method_before
public static RangeSubject assertThat(Comment.Range range) {
    return assertAbout(RANGE_SUBJECT_FACTORY).that(range);
}
#method_after
public static RangeSubject assertThat(Comment.Range range) {
    return assertAbout(RangeSubject::new).that(range);
}
#end_block

#method_before
public static ContentEntrySubject assertThat(ContentEntry contentEntry) {
    return assertAbout(DIFF_INFO_SUBJECT_FACTORY).that(contentEntry);
}
#method_after
public static ContentEntrySubject assertThat(ContentEntry contentEntry) {
    return assertAbout(ContentEntrySubject::new).that(contentEntry);
}
#end_block

#method_before
public static DiffInfoSubject assertThat(DiffInfo diffInfo) {
    return assertAbout(DIFF_INFO_SUBJECT_FACTORY).that(diffInfo);
}
#method_after
public static DiffInfoSubject assertThat(DiffInfo diffInfo) {
    return assertAbout(DiffInfoSubject::new).that(diffInfo);
}
#end_block

#method_before
@Test
public void publishEdit() throws Exception {
    createArbitraryEditFor(changeId);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    assertThat(getEdit(changeId)).isAbsent();
    assertChangeMessages(changeId, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Published edit on patch set 2."));
    // The tag for the publish edit change message should vary according
    // to whether the change was WIP at the time of publishing.
    ChangeInfo info = get(changeId);
    assertThat(info.messages).isNotEmpty();
    assertThat(Iterables.getLast(info.messages).tag).isEqualTo(ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    // Move the change to WIP, repeat, and verify.
    gApi.changes().id(changeId).setWorkInProgress();
    createEmptyEditFor(changeId);
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW2));
    gApi.changes().id(changeId).edit().publish();
    info = get(changeId);
    assertThat(info.messages).isNotEmpty();
    assertThat(Iterables.getLast(info.messages).tag).isEqualTo(ChangeMessagesUtil.TAG_UPLOADED_WIP_PATCH_SET);
}
#method_after
@Test
public void publishEdit() throws Exception {
    createArbitraryEditFor(changeId);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    assertThat(getEdit(changeId)).isAbsent();
    assertChangeMessages(changeId, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch Set 3: Published edit on patch set 2."));
    // The tag for the publish edit change message should vary according
    // to whether the change was WIP at the time of publishing.
    ChangeInfo info = get(changeId, MESSAGES);
    assertThat(info.messages).isNotEmpty();
    assertThat(Iterables.getLast(info.messages).tag).isEqualTo(ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
    // Move the change to WIP, repeat, and verify.
    gApi.changes().id(changeId).setWorkInProgress();
    createEmptyEditFor(changeId);
    gApi.changes().id(changeId).edit().modifyFile(FILE_NAME, RawInputUtil.create(CONTENT_NEW2));
    gApi.changes().id(changeId).edit().publish();
    info = get(changeId, MESSAGES);
    assertThat(info.messages).isNotEmpty();
    assertThat(Iterables.getLast(info.messages).tag).isEqualTo(ChangeMessagesUtil.TAG_UPLOADED_WIP_PATCH_SET);
}
#end_block

#method_before
@Test
public void retrieveEdit() throws Exception {
    adminRestSession.get(urlEdit(changeId)).assertNoContent();
    createArbitraryEditFor(changeId);
    EditInfo editInfo = getEditInfo(changeId, false);
    ChangeInfo changeInfo = get(changeId);
    assertThat(editInfo.commit.commit).isNotEqualTo(changeInfo.currentRevision);
    assertThat(editInfo).commit().parents().hasSize(1);
    assertThat(editInfo).baseRevision().isEqualTo(changeInfo.currentRevision);
    gApi.changes().id(changeId).edit().delete();
    adminRestSession.get(urlEdit(changeId)).assertNoContent();
}
#method_after
@Test
public void retrieveEdit() throws Exception {
    adminRestSession.get(urlEdit(changeId)).assertNoContent();
    createArbitraryEditFor(changeId);
    EditInfo editInfo = getEditInfo(changeId, false);
    ChangeInfo changeInfo = get(changeId, CURRENT_REVISION, CURRENT_COMMIT);
    assertThat(editInfo.commit.commit).isNotEqualTo(changeInfo.currentRevision);
    assertThat(editInfo).commit().parents().hasSize(1);
    assertThat(editInfo).baseRevision().isEqualTo(changeInfo.currentRevision);
    gApi.changes().id(changeId).edit().delete();
    adminRestSession.get(urlEdit(changeId)).assertNoContent();
}
#end_block

#method_before
@Test
public void editCommitMessageCopiesLabelScores() throws Exception {
    String cr = "Code-Review";
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyAllScoresIfNoCodeChange(true);
    cfg.getLabelSections().put(cr, codeReview);
    saveProjectConfig(project, cfg);
    ReviewInput r = new ReviewInput();
    r.labels = ImmutableMap.of(cr, (short) 1);
    gApi.changes().id(changeId).current().review(r);
    createEmptyEditFor(changeId);
    String newSubj = "New commit message";
    String newMsg = newSubj + "\n\nChange-Id: " + changeId + "\n";
    gApi.changes().id(changeId).edit().modifyCommitMessage(newMsg);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    ChangeInfo info = get(changeId);
    assertThat(info.subject).isEqualTo(newSubj);
    List<ApprovalInfo> approvals = info.labels.get(cr).all;
    assertThat(approvals).hasSize(1);
    assertThat(approvals.get(0).value).isEqualTo(1);
}
#method_after
@Test
public void editCommitMessageCopiesLabelScores() throws Exception {
    String cr = "Code-Review";
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType codeReview = Util.codeReview();
    codeReview.setCopyAllScoresIfNoCodeChange(true);
    cfg.getLabelSections().put(cr, codeReview);
    saveProjectConfig(project, cfg);
    ReviewInput r = new ReviewInput();
    r.labels = ImmutableMap.of(cr, (short) 1);
    gApi.changes().id(changeId).current().review(r);
    createEmptyEditFor(changeId);
    String newSubj = "New commit message";
    String newMsg = newSubj + "\n\nChange-Id: " + changeId + "\n";
    gApi.changes().id(changeId).edit().modifyCommitMessage(newMsg);
    PublishChangeEditInput publishInput = new PublishChangeEditInput();
    publishInput.notify = NotifyHandling.NONE;
    gApi.changes().id(changeId).edit().publish(publishInput);
    ChangeInfo info = get(changeId, DETAILED_LABELS);
    assertThat(info.subject).isEqualTo(newSubj);
    List<ApprovalInfo> approvals = info.labels.get(cr).all;
    assertThat(approvals).hasSize(1);
    assertThat(approvals.get(0).value).isEqualTo(1);
}
#end_block

#method_before
private void assertChangeMessages(String changeId, List<String> expectedMessages) throws Exception {
    ChangeInfo ci = get(changeId);
    assertThat(ci.messages).isNotNull();
    assertThat(ci.messages).hasSize(expectedMessages.size());
    List<String> actualMessages = ci.messages.stream().map(message -> message.message).collect(toList());
    assertThat(actualMessages).containsExactlyElementsIn(expectedMessages).inOrder();
}
#method_after
private void assertChangeMessages(String changeId, List<String> expectedMessages) throws Exception {
    ChangeInfo ci = get(changeId, MESSAGES);
    assertThat(ci.messages).isNotNull();
    assertThat(ci.messages).hasSize(expectedMessages.size());
    List<String> actualMessages = ci.messages.stream().map(message -> message.message).collect(toList());
    assertThat(actualMessages).containsExactlyElementsIn(expectedMessages).inOrder();
}
#end_block

#method_before
public static FileInfoSubject assertThat(FileInfo fileInfo) {
    return assertAbout(FILE_INFO_SUBJECT_FACTORY).that(fileInfo);
}
#method_after
public static FileInfoSubject assertThat(FileInfo fileInfo) {
    return assertAbout(FileInfoSubject::new).that(fileInfo);
}
#end_block

#method_before
public List<SubmitRecord> evaluate() {
    initOptions();
    Change c = control.getChange();
    if (!opts.allowClosed() && c.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!opts.allowDraft()) {
        try {
            initPatchSet();
        } catch (OrmException e) {
            return ruleError("Error looking up patch set " + control.getChange().currentPatchSetId(), e);
        }
        if (c.getStatus() == Change.Status.DRAFT || patchSet.isDraft()) {
            return cannotSubmitDraft();
        }
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", control.getUser());
    } catch (RuleEvalException e) {
        return ruleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // whether or not that is actually possible given the permissions.
        return ruleError(String.format("Submit rule '%s' for change %s of %s has no solution.", getSubmitRuleName(), cd.getId(), getProjectName()));
    }
    return resultsToSubmitRecord(getSubmitRule(), results);
}
#method_after
public List<SubmitRecord> evaluate() {
    initOptions();
    try {
        init();
    } catch (OrmException e) {
        return ruleError("Error looking up change " + cd.getId(), e);
    }
    if (!opts.allowClosed() && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", user);
    } catch (RuleEvalException e) {
        return ruleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // whether or not that is actually possible given the permissions.
        return ruleError(String.format("Submit rule '%s' for change %s of %s has no solution.", getSubmitRuleName(), cd.getId(), getProjectName()));
    }
    return resultsToSubmitRecord(getSubmitRule(), results);
}
#end_block

#method_before
public SubmitTypeRecord getSubmitType() {
    initOptions();
    try {
        initPatchSet();
    } catch (OrmException e) {
        return typeError("Error looking up patch set " + control.getChange().currentPatchSetId(), e);
    }
    try {
        if (control.getChange().getStatus() == Change.Status.DRAFT && !control.isDraftVisible(cd.db(), cd)) {
            return SubmitTypeRecord.error("Patch set " + patchSet.getId() + " not found");
        }
        if (patchSet.isDraft() && !control.isDraftVisible(cd.db(), cd)) {
            return SubmitTypeRecord.error("Patch set " + patchSet.getId() + " not found");
        }
    } catch (OrmException err) {
        String msg = "Cannot read patch set " + patchSet.getId();
        log.error(msg, err);
        return SubmitTypeRecord.error(msg);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results", // have a consistent view of the submit type.
        null);
    } catch (RuleEvalException e) {
        return typeError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " has no solution.");
    }
    Term typeTerm = results.get(0);
    if (!(typeTerm instanceof SymbolTerm)) {
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " did not return a symbol.");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return typeError("Submit type rule " + getSubmitRule() + " for change " + cd.getId() + " of " + getProjectName() + " output invalid result: " + typeName);
    }
}
#method_after
public SubmitTypeRecord getSubmitType() {
    initOptions();
    try {
        init();
    } catch (OrmException e) {
        return typeError("Error looking up change " + cd.getId(), e);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results", // have a consistent view of the submit type.
        null);
    } catch (RuleEvalException e) {
        return typeError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " has no solution.");
    }
    Term typeTerm = results.get(0);
    if (!(typeTerm instanceof SymbolTerm)) {
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " did not return a symbol.");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return typeError("Submit type rule " + getSubmitRule() + " for change " + cd.getId() + " of " + getProjectName() + " output invalid result: " + typeName);
    }
}
#end_block

#method_before
private List<Term> evaluateImpl(String userRuleLocatorName, String userRuleWrapperName, String filterRuleLocatorName, String filterRuleWrapperName, CurrentUser user) throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment(user);
    try {
        Term sr = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        if (opts.fastEvalLabels()) {
            env.once("gerrit", "assume_range_from_label");
        }
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, sr, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), getProjectName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", sr, cd.getId().get(), getProjectName()), err);
        } finally {
            reductionsConsumed = env.getReductions();
        }
        Term resultsTerm = toListTerm(results);
        if (!opts.skipFilters()) {
            resultsTerm = runSubmitFilters(resultsTerm, env, filterRuleLocatorName, filterRuleWrapperName);
        }
        List<Term> r;
        if (resultsTerm instanceof ListTerm) {
            r = new ArrayList<>();
            for (Term t = resultsTerm; t instanceof ListTerm; ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
        } else {
            r = Collections.emptyList();
        }
        submitRule = sr;
        return r;
    } finally {
        env.close();
    }
}
#method_after
private List<Term> evaluateImpl(String userRuleLocatorName, String userRuleWrapperName, String filterRuleLocatorName, String filterRuleWrapperName, CurrentUser user) throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment(user);
    try {
        Term sr = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, sr, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), getProjectName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", sr, cd.getId().get(), getProjectName()), err);
        } finally {
            reductionsConsumed = env.getReductions();
        }
        Term resultsTerm = toListTerm(results);
        if (!opts.skipFilters()) {
            resultsTerm = runSubmitFilters(resultsTerm, env, filterRuleLocatorName, filterRuleWrapperName);
        }
        List<Term> r;
        if (resultsTerm instanceof ListTerm) {
            r = new ArrayList<>();
            for (Term t = resultsTerm; t instanceof ListTerm; ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
        } else {
            r = Collections.emptyList();
        }
        submitRule = sr;
        return r;
    } finally {
        env.close();
    }
}
#end_block

#method_before
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (opts.rule() == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new StringReader(opts.rule()));
        }
    } catch (CompileException err) {
        String msg;
        if (opts.rule() == null && control.getProjectControl().isOwner()) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else if (opts.rule() != null) {
            msg = err.getMessage();
        } else {
            msg = String.format("Cannot load rules.pl for %s", getProjectName());
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.ACCOUNTS, accounts);
    env.set(StoredValues.ACCOUNT_CACHE, accountCache);
    env.set(StoredValues.EMAILS, emails);
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.CHANGE_CONTROL, control);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    return env;
}
#method_after
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    PrologEnvironment env;
    try {
        if (opts.rule() == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new StringReader(opts.rule()));
        }
    } catch (CompileException err) {
        String msg;
        if (opts.rule() == null) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else {
            msg = err.getMessage();
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.ACCOUNTS, accounts);
    env.set(StoredValues.ACCOUNT_CACHE, accountCache);
    env.set(StoredValues.EMAILS, emails);
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    env.set(StoredValues.PROJECT_STATE, projectState);
    return env;
}
#end_block

#method_before
private Term runSubmitFilters(Term results, PrologEnvironment env, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment childEnv = env;
    for (ProjectState parentState : projectState.parents()) {
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            throw new RuleEvalException("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", filterRuleLocatorName, new VariableTerm());
        try {
            if (opts.fastEvalLabels()) {
                env.once("gerrit", "assume_range_from_label");
            }
            Term[] template = parentEnv.once("gerrit", filterRuleWrapperName, filterRule, results, new VariableTerm());
            results = template[2];
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), parentState.getProject().getName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", filterRule, cd.getId().get(), parentState.getProject().getName()), err);
        } finally {
            reductionsConsumed += env.getReductions();
        }
        childEnv = parentEnv;
    }
    return results;
}
#method_after
private Term runSubmitFilters(Term results, PrologEnvironment env, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    PrologEnvironment childEnv = env;
    for (ProjectState parentState : projectState.parents()) {
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            throw new RuleEvalException("Cannot consult rules.pl for " + parentState.getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", filterRuleLocatorName, new VariableTerm());
        try {
            Term[] template = parentEnv.once("gerrit", filterRuleWrapperName, filterRule, results, new VariableTerm());
            results = template[2];
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), parentState.getName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", filterRule, cd.getId().get(), parentState.getName()), err);
        } finally {
            reductionsConsumed += env.getReductions();
        }
        childEnv = parentEnv;
    }
    return results;
}
#end_block

#method_before
private String getProjectName() {
    return control.getProjectControl().getProjectState().getProject().getName();
}
#method_after
private String getProjectName() {
    return projectState.getName();
}
#end_block

#method_before
static Term export(LabelType type) {
    LabelValue min = type.getMin();
    LabelValue max = type.getMax();
    return new StructureTerm(symLabelType, SymbolTerm.intern(type.getName()), SymbolTerm.intern(type.getFunctionName()), min != null ? new IntegerTerm(min.getValue()) : NONE, max != null ? new IntegerTerm(max.getValue()) : NONE);
}
#method_after
static Term export(LabelType type) {
    LabelValue min = type.getMin();
    LabelValue max = type.getMax();
    return new StructureTerm(symLabelType, SymbolTerm.intern(type.getName()), SymbolTerm.intern(type.getFunction().getFunctionName()), min != null ? new IntegerTerm(min.getValue()) : NONE, max != null ? new IntegerTerm(max.getValue()) : NONE);
}
#end_block

#method_before
private void assertCanUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("can upload").isEqualTo(Capable.OK);
}
#method_after
private void assertCanUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("can upload").isTrue();
}
#end_block

#method_before
private void assertCannotUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("cannot upload").isNotEqualTo(Capable.OK);
}
#method_after
private void assertCannotUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("cannot upload").isFalse();
}
#end_block

#method_before
@Test
public void branchDelegation1() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwnerAnyRef(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
}
#method_after
@Test
public void branchDelegation1() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
}
#end_block

#method_before
@Test
public void branchDelegation2() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    allow(local, OWNER, fixers, "refs/heads/x/y/*");
    doNotInherit(local, OWNER, "refs/heads/x/y/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwnerAnyRef(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
    ProjectControl uFix = user(local, fixers);
    assertNotOwner(uFix);
    assertOwnerAnyRef(uFix);
    assertOwner("refs/heads/x/y/*", uFix);
    assertOwner("refs/heads/x/y/bar", uFix);
    assertNotOwner("refs/heads/x/*", uFix);
    assertNotOwner("refs/heads/x/y", uFix);
    assertNotOwner("refs/*", uFix);
    assertNotOwner("refs/heads/master", uFix);
}
#method_after
@Test
public void branchDelegation2() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    allow(local, OWNER, fixers, "refs/heads/x/y/*");
    doNotInherit(local, OWNER, "refs/heads/x/y/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
    ProjectControl uFix = user(local, fixers);
    assertNotOwner(uFix);
    assertOwner("refs/heads/x/y/*", uFix);
    assertOwner("refs/heads/x/y/bar", uFix);
    assertNotOwner("refs/heads/x/*", uFix);
    assertNotOwner("refs/heads/x/y", uFix);
    assertNotOwner("refs/*", uFix);
    assertNotOwner("refs/heads/master", uFix);
}
#end_block

#method_before
private ProjectControl user(ProjectConfig local, String name, AccountGroup.UUID... memberOf) {
    return new ProjectControl(Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountGroup.UUID>emptySet(), projectCache, sectionSorter, // commitsCollection
    null, changeControlFactory, // canonicalWebUrl
    "http://localhost", permissionBackend, new MockUser(name, memberOf), newProjectState(local), metrics);
}
#method_after
private ProjectControl user(ProjectConfig local, String name, AccountGroup.UUID... memberOf) {
    return new ProjectControl(Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountGroup.UUID>emptySet(), sectionSorter, // commitsCollection
    null, changeControlFactory, permissionBackend, new MockUser(name, memberOf), newProjectState(local));
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
protected void configure() {
    install(reviewDbModule);
    install(new DiffExecutorModule());
    install(new ReceiveCommitsExecutorModule());
    install(BatchUpdate.module());
    install(PatchListCacheImpl.module());
    // Plugins are not loaded and we're just running through each change
    // once, so don't worry about cache removal.
    bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
    }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
    bind(new TypeLiteral<DynamicMap<Cache<?, ?>>>() {
    }).toInstance(DynamicMap.<Cache<?, ?>>emptyMap());
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(new TypeLiteral<DynamicMap<ChangeQueryProcessor.ChangeAttributeFactory>>() {
    }).toInstance(DynamicMap.<ChangeQueryProcessor.ChangeAttributeFactory>emptyMap());
    bind(new TypeLiteral<DynamicMap<RestView<CommitResource>>>() {
    }).toInstance(DynamicMap.<RestView<CommitResource>>emptyMap());
    bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(Realm.class).to(FakeRealm.class);
    bind(IdentifiedUser.class).toProvider(Providers.<IdentifiedUser>of(null));
    bind(ReplacePatchSetSender.Factory.class).toProvider(Providers.<ReplacePatchSetSender.Factory>of(null));
    bind(CurrentUser.class).to(IdentifiedUser.class);
    factory(MergeUtil.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    // As Reindex is a batch program, don't assume the index is available for
    // the change cache.
    bind(SearchingChangeCacheImpl.class).toProvider(Providers.<SearchingChangeCacheImpl>of(null));
    bind(new TypeLiteral<ImmutableSet<GroupReference>>() {
    }).annotatedWith(AdministrateServerGroups.class).toInstance(ImmutableSet.<GroupReference>of());
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(GitUploadPackGroups.class).toInstance(Collections.<AccountGroup.UUID>emptySet());
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(GitReceivePackGroups.class).toInstance(Collections.<AccountGroup.UUID>emptySet());
    install(new BatchGitModule());
    install(new DefaultPermissionBackendModule());
    install(new DefaultCacheFactory.Module());
    install(new ExternalIdModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(ChangeKindCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(TagCache.module());
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.AssistedFactory.class);
    factory(ProjectState.Factory.class);
    bind(ChangeJson.Factory.class).toProvider(Providers.<ChangeJson.Factory>of(null));
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
protected void configure() {
    install(reviewDbModule);
    install(new DiffExecutorModule());
    install(new ReceiveCommitsExecutorModule());
    install(BatchUpdate.module());
    install(PatchListCacheImpl.module());
    // Plugins are not loaded and we're just running through each change
    // once, so don't worry about cache removal.
    bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
    }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
    bind(new TypeLiteral<DynamicMap<Cache<?, ?>>>() {
    }).toInstance(DynamicMap.<Cache<?, ?>>emptyMap());
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(new TypeLiteral<DynamicMap<ChangeQueryProcessor.ChangeAttributeFactory>>() {
    }).toInstance(DynamicMap.<ChangeQueryProcessor.ChangeAttributeFactory>emptyMap());
    bind(new TypeLiteral<DynamicMap<RestView<CommitResource>>>() {
    }).toInstance(DynamicMap.<RestView<CommitResource>>emptyMap());
    bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(Realm.class).to(FakeRealm.class);
    bind(IdentifiedUser.class).toProvider(Providers.<IdentifiedUser>of(null));
    bind(ReplacePatchSetSender.Factory.class).toProvider(Providers.<ReplacePatchSetSender.Factory>of(null));
    bind(CurrentUser.class).to(IdentifiedUser.class);
    factory(MergeUtil.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    // As Reindex is a batch program, don't assume the index is available for
    // the change cache.
    bind(SearchingChangeCacheImpl.class).toProvider(Providers.<SearchingChangeCacheImpl>of(null));
    bind(new TypeLiteral<ImmutableSet<GroupReference>>() {
    }).annotatedWith(AdministrateServerGroups.class).toInstance(ImmutableSet.<GroupReference>of());
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(GitUploadPackGroups.class).toInstance(Collections.<AccountGroup.UUID>emptySet());
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(GitReceivePackGroups.class).toInstance(Collections.<AccountGroup.UUID>emptySet());
    install(new BatchGitModule());
    install(new DefaultPermissionBackendModule());
    install(new DefaultCacheFactory.Module());
    install(new ExternalIdModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(ChangeKindCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(TagCache.module());
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.AssistedFactory.class);
    factory(ProjectState.Factory.class);
    factory(SubmitRuleEvaluator.Factory.class);
    bind(ChangeJson.Factory.class).toProvider(Providers.<ChangeJson.Factory>of(null));
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
}
#end_block

#method_before
private void logOrmExceptionForAccounts(String header, Account.Id me, Collection<AccountGroupMember> values, OrmException e) {
    List<String> descriptions = new ArrayList<>();
    for (AccountGroupMember m : values) {
        Account.Id accountId = m.getAccountId();
        String userName = accountCache.get(accountId).getUserName();
        AccountGroup.Id groupId = m.getAccountGroupId();
        String groupName = groupCache.get(groupId).getName();
        descriptions.add(MessageFormat.format("account {0}/{1}, group {2}/{3}", accountId, userName, groupId, groupName));
    }
    logOrmException(header, me, descriptions, e);
}
#method_after
private void logOrmExceptionForAccounts(String header, Account.Id me, Collection<AccountGroupMember> values, OrmException e) {
    List<String> descriptions = new ArrayList<>();
    for (AccountGroupMember m : values) {
        Account.Id accountId = m.getAccountId();
        String userName = accountCache.get(accountId).getUserName();
        AccountGroup.Id groupId = m.getAccountGroupId();
        String groupName = getGroupName(groupId);
        descriptions.add(MessageFormat.format("account {0}/{1}, group {2}/{3}", accountId, userName, groupId, groupName));
    }
    logOrmException(header, me, descriptions, e);
}
#end_block

#method_before
private void logOrmExceptionForGroups(String header, Account.Id me, Collection<AccountGroupById> values, OrmException e) {
    List<String> descriptions = new ArrayList<>();
    for (AccountGroupById m : values) {
        AccountGroup.UUID groupUuid = m.getIncludeUUID();
        String groupName = groupBackend.get(groupUuid).getName();
        AccountGroup.Id targetGroupId = m.getGroupId();
        String targetGroupName = groupCache.get(targetGroupId).getName();
        descriptions.add(MessageFormat.format("group {0}/{1}, group {2}/{3}", groupUuid, groupName, targetGroupId, targetGroupName));
    }
    logOrmException(header, me, descriptions, e);
}
#method_after
private void logOrmExceptionForGroups(String header, Account.Id me, Collection<AccountGroupById> values, OrmException e) {
    List<String> descriptions = new ArrayList<>();
    for (AccountGroupById m : values) {
        AccountGroup.UUID groupUuid = m.getIncludeUUID();
        String groupName = groupBackend.get(groupUuid).getName();
        AccountGroup.Id targetGroupId = m.getGroupId();
        String targetGroupName = getGroupName(targetGroupId);
        descriptions.add(MessageFormat.format("group {0}/{1}, group {2}/{3}", groupUuid, groupName, targetGroupId, targetGroupName));
    }
    logOrmException(header, me, descriptions, e);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountCacheImpl.module());
    install(BatchUpdate.module());
    install(ChangeKindCacheImpl.module());
    install(ChangeFinder.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new ExternalIdModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new ReceiveCommitsModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.AssistedFactory.class);
    factory(ChangeJson.AssistedFactory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    bind(UiActions.class);
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), AccountIndexedListener.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), GroupIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterRefUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicSet.setOf(binder(), TagWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    bind(MailFilter.class).annotatedWith(Exports.named("ListMailFilter")).to(ListMailFilter.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryProcessor.ChangeAttributeFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(AccountValidator.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountCacheImpl.module());
    install(BatchUpdate.module());
    install(ChangeKindCacheImpl.module());
    install(ChangeFinder.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new ExternalIdModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new ReceiveCommitsModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.AssistedFactory.class);
    factory(ChangeJson.AssistedFactory.class);
    factory(CreateChangeSender.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    factory(SubmitRuleEvaluator.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(AccountDeactivator.class);
    bind(ApprovalsUtil.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    bind(UiActions.class);
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), AccountIndexedListener.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), GroupIndexedListener.class);
    DynamicSet.setOf(binder(), ProjectIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterRefUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicSet.setOf(binder(), TagWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    DynamicItem.itemOf(binder(), MergeSuperSetComputation.class);
    DynamicItem.itemOf(binder(), ProjectNameLockManager.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    bind(MailFilter.class).annotatedWith(Exports.named("ListMailFilter")).to(ListMailFilter.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryProcessor.ChangeAttributeFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(AccountMergeValidator.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public SubmitType apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(accountCache, accounts, emails, changeDataFactory.create(db.get(), rsrc.getControl()));
    SubmitTypeRecord rec = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRuleName(), rec));
    }
    return rec.type;
}
#method_after
@Override
public SubmitType apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = submitRuleEvaluatorFactory.create(rsrc.getUser(), changeDataFactory.create(db.get(), rsrc.getNotes()));
    SubmitTypeRecord rec = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRuleName(), rec));
    }
    return rec.type;
}
#end_block

#method_before
@Override
public List<Record> apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(accountCache, accounts, emails, changeDataFactory.create(db.get(), rsrc.getControl()));
    List<SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluate();
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountLoader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    if (!out.isEmpty()) {
        out.get(0).prologReductionCount = evaluator.getReductionsConsumed();
    }
    accounts.fill();
    return out;
}
#method_after
@Override
public List<Record> apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = submitRuleEvaluatorFactory.create(rsrc.getUser(), changeDataFactory.create(db.get(), rsrc.getNotes()));
    List<SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluate();
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountLoader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    if (!out.isEmpty()) {
        out.get(0).prologReductionCount = evaluator.getReductionsConsumed();
    }
    accounts.fill();
    return out;
}
#end_block

#method_before
private boolean isRevisionOutOfDate() {
    try (Repository git = gitMgr.openRepository(getProject().getNameKey())) {
        Ref ref = git.getRefDatabase().exactRef(RefNames.REFS_CONFIG);
        if (ref == null || ref.getObjectId() == null) {
            return true;
        }
        return !ref.getObjectId().equals(config.getRevision());
    } catch (IOException gone) {
        return true;
    }
}
#method_after
private boolean isRevisionOutOfDate() {
    try (Repository git = gitMgr.openRepository(getNameKey())) {
        Ref ref = git.getRefDatabase().exactRef(RefNames.REFS_CONFIG);
        if (ref == null || ref.getObjectId() == null) {
            return true;
        }
        return !ref.getObjectId().equals(config.getRevision());
    } catch (IOException gone) {
        return true;
    }
}
#end_block

#method_before
public PrologEnvironment newPrologEnvironment() throws CompileException {
    PrologMachineCopy pmc = rulesMachine;
    if (pmc == null) {
        pmc = rulesCache.loadMachine(getProject().getNameKey(), config.getRulesId());
        rulesMachine = pmc;
    }
    return envFactory.create(pmc);
}
#method_after
public PrologEnvironment newPrologEnvironment() throws CompileException {
    PrologMachineCopy pmc = rulesMachine;
    if (pmc == null) {
        pmc = rulesCache.loadMachine(getNameKey(), config.getRulesId());
        rulesMachine = pmc;
    }
    return envFactory.create(pmc);
}
#end_block

#method_before
public ProjectLevelConfig getConfig(String fileName) {
    if (configs.containsKey(fileName)) {
        return configs.get(fileName);
    }
    ProjectLevelConfig cfg = new ProjectLevelConfig(fileName, this);
    try (Repository git = gitMgr.openRepository(getProject().getNameKey())) {
        cfg.load(git);
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Failed to load " + fileName + " for " + getProject().getName(), e);
    }
    configs.put(fileName, cfg);
    return cfg;
}
#method_after
public ProjectLevelConfig getConfig(String fileName) {
    if (configs.containsKey(fileName)) {
        return configs.get(fileName);
    }
    ProjectLevelConfig cfg = new ProjectLevelConfig(fileName, this);
    try (Repository git = gitMgr.openRepository(getNameKey())) {
        cfg.load(git);
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Failed to load " + fileName + " for " + getName(), e);
    }
    configs.put(fileName, cfg);
    return cfg;
}
#end_block

#method_before
List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(getProject().getNameKey(), section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#method_after
List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(getNameKey(), section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#end_block

#method_before
public LabelTypes getLabelTypes() {
    Map<String, LabelType> types = new LinkedHashMap<>();
    for (ProjectState s : treeInOrder()) {
        for (LabelType type : s.getConfig().getLabelSections().values()) {
            String lower = type.getName().toLowerCase();
            LabelType old = types.get(lower);
            if (old == null || old.canOverride()) {
                types.put(lower, type);
            }
        }
    }
    List<LabelType> all = Lists.newArrayListWithCapacity(types.size());
    for (LabelType type : types.values()) {
        if (!type.getValues().isEmpty()) {
            all.add(type);
        }
    }
    return new LabelTypes(Collections.unmodifiableList(all));
}
#method_after
public LabelTypes getLabelTypes() {
    if (labelTypes == null) {
        labelTypes = loadLabelTypes();
    }
    return labelTypes;
}
#end_block

#method_before
public LabelTypes getLabelTypes() {
    Map<String, LabelType> types = new LinkedHashMap<>();
    for (ProjectState s : treeInOrder()) {
        for (LabelType type : s.getConfig().getLabelSections().values()) {
            String lower = type.getName().toLowerCase();
            LabelType old = types.get(lower);
            if (old == null || old.canOverride()) {
                types.put(lower, type);
            }
        }
    }
    List<LabelType> all = Lists.newArrayListWithCapacity(types.size());
    for (LabelType type : types.values()) {
        if (!type.getValues().isEmpty()) {
            all.add(type);
        }
    }
    return new LabelTypes(Collections.unmodifiableList(all));
}
#method_after
public LabelTypes getLabelTypes(ChangeNotes notes, CurrentUser user) {
    return getLabelTypes(notes.getChange().getDest(), user);
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    ChangeControl control = StoredValues.CHANGE_CONTROL.get(engine);
    SubmitType submitType = control.getProject().getSubmitType();
    if (!a1.unify(term[submitType.ordinal()], engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    ProjectState projectState = StoredValues.PROJECT_STATE.get(engine);
    SubmitType submitType = projectState.getProject().getSubmitType();
    if (!a1.unify(term[submitType.ordinal()], engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    DynamicMap.mapOf(binder(), INCLUDED_GROUP_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    put(GROUP_KIND).to(PutGroup.class);
    get(GROUP_KIND, "detail").to(GetDetail.class);
    post(GROUP_KIND, "index").to(Index.class);
    post(GROUP_KIND, "members").to(AddMembers.class);
    post(GROUP_KIND, "members.add").to(AddMembers.class);
    post(GROUP_KIND, "members.delete").to(DeleteMembers.class);
    post(GROUP_KIND, "groups").to(AddIncludedGroups.class);
    post(GROUP_KIND, "groups.add").to(AddIncludedGroups.class);
    post(GROUP_KIND, "groups.delete").to(DeleteIncludedGroups.class);
    get(GROUP_KIND, "description").to(GetDescription.class);
    put(GROUP_KIND, "description").to(PutDescription.class);
    delete(GROUP_KIND, "description").to(PutDescription.class);
    get(GROUP_KIND, "name").to(GetName.class);
    put(GROUP_KIND, "name").to(PutName.class);
    get(GROUP_KIND, "owner").to(GetOwner.class);
    put(GROUP_KIND, "owner").to(PutOwner.class);
    get(GROUP_KIND, "options").to(GetOptions.class);
    put(GROUP_KIND, "options").to(PutOptions.class);
    get(GROUP_KIND, "log.audit").to(GetAuditLog.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
    get(MEMBER_KIND).to(GetMember.class);
    put(MEMBER_KIND).to(UpdateMember.class);
    delete(MEMBER_KIND).to(DeleteMember.class);
    child(GROUP_KIND, "groups").to(IncludedGroupsCollection.class);
    get(INCLUDED_GROUP_KIND).to(GetIncludedGroup.class);
    put(INCLUDED_GROUP_KIND).to(UpdateIncludedGroup.class);
    delete(INCLUDED_GROUP_KIND).to(DeleteIncludedGroup.class);
    factory(CreateGroup.Factory.class);
    factory(GroupsUpdate.Factory.class);
    DynamicSet.bind(binder(), GroupMemberAuditListener.class).to(DbGroupMemberAuditListener.class);
}
#method_after
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    DynamicMap.mapOf(binder(), SUBGROUP_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    put(GROUP_KIND).to(PutGroup.class);
    get(GROUP_KIND, "detail").to(GetDetail.class);
    post(GROUP_KIND, "index").to(Index.class);
    post(GROUP_KIND, "members").to(AddMembers.class);
    post(GROUP_KIND, "members.add").to(AddMembers.class);
    post(GROUP_KIND, "members.delete").to(DeleteMembers.class);
    post(GROUP_KIND, "groups").to(AddSubgroups.class);
    post(GROUP_KIND, "groups.add").to(AddSubgroups.class);
    post(GROUP_KIND, "groups.delete").to(DeleteSubgroups.class);
    get(GROUP_KIND, "description").to(GetDescription.class);
    put(GROUP_KIND, "description").to(PutDescription.class);
    delete(GROUP_KIND, "description").to(PutDescription.class);
    get(GROUP_KIND, "name").to(GetName.class);
    put(GROUP_KIND, "name").to(PutName.class);
    get(GROUP_KIND, "owner").to(GetOwner.class);
    put(GROUP_KIND, "owner").to(PutOwner.class);
    get(GROUP_KIND, "options").to(GetOptions.class);
    put(GROUP_KIND, "options").to(PutOptions.class);
    get(GROUP_KIND, "log.audit").to(GetAuditLog.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
    get(MEMBER_KIND).to(GetMember.class);
    put(MEMBER_KIND).to(UpdateMember.class);
    delete(MEMBER_KIND).to(DeleteMember.class);
    child(GROUP_KIND, "groups").to(SubgroupsCollection.class);
    get(SUBGROUP_KIND).to(GetSubgroup.class);
    put(SUBGROUP_KIND).to(UpdateSubgroup.class);
    delete(SUBGROUP_KIND).to(DeleteSubgroup.class);
    factory(CreateGroup.Factory.class);
    factory(GroupsUpdate.Factory.class);
    DynamicSet.bind(binder(), GroupMemberAuditListener.class).to(DbGroupMemberAuditListener.class);
}
#end_block

#method_before
private boolean shouldReplicate(Project.NameKey project, ReplicationState... states) {
    try {
        return threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException, PermissionBackendException {
                return shouldReplicate(controlFor(project));
            }
        }).call();
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, states);
    } catch (Exception e) {
        Throwables.throwIfUnchecked(e);
        throw new RuntimeException(e);
    }
    return false;
}
#method_after
private boolean shouldReplicate(ProjectState projectState, CurrentUser user) throws PermissionBackendException {
    if (!config.replicateHiddenProjects() && projectState.getProject().getState() == com.google.gerrit.extensions.client.ProjectState.HIDDEN) {
        return false;
    }
    try {
        permissionBackend.user(user).project(projectState.getNameKey()).check(ProjectPermission.ACCESS);
        return true;
    } catch (AuthException e) {
        return false;
    }
}
#end_block

#method_before
private boolean shouldReplicate(final Project.NameKey project, String ref, ReplicationState... states) {
    try {
        return threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException, PermissionBackendException {
                ProjectControl projectControl = controlFor(project);
                if (!shouldReplicate(projectControl)) {
                    return false;
                }
                if (PushOne.ALL_REFS.equals(ref)) {
                    return true;
                }
                try {
                    permissionBackend.user(projectControl.getUser()).project(project).ref(ref).check(RefPermission.READ);
                } catch (AuthException e) {
                    return false;
                }
                return true;
            }
        }).call();
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, states);
    } catch (Exception e) {
        Throwables.throwIfUnchecked(e);
        throw new RuntimeException(e);
    }
    return false;
}
#method_after
private boolean shouldReplicate(final Project.NameKey project, String ref, ReplicationState... states) {
    try {
        return threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException, PermissionBackendException {
                ProjectState projectState;
                try {
                    projectState = projectCache.checkedGet(project);
                } catch (IOException e) {
                    return false;
                }
                if (projectState == null) {
                    throw new NoSuchProjectException(project);
                }
                if (!shouldReplicate(projectState, userProvider.get())) {
                    return false;
                }
                if (PushOne.ALL_REFS.equals(ref)) {
                    return true;
                }
                try {
                    permissionBackend.user(userProvider).project(project).ref(ref).check(RefPermission.READ);
                } catch (AuthException e) {
                    return false;
                }
                return true;
            }
        }).call();
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, states);
    } catch (Exception e) {
        Throwables.throwIfUnchecked(e);
        throw new RuntimeException(e);
    }
    return false;
}
#end_block

#method_before
private boolean shouldReplicate(Project.NameKey project, ReplicationState... states) {
    try {
        return threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException, PermissionBackendException {
                return shouldReplicate(controlFor(project));
            }
        }).call();
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, states);
    } catch (Exception e) {
        Throwables.throwIfUnchecked(e);
        throw new RuntimeException(e);
    }
    return false;
}
#method_after
private boolean shouldReplicate(Project.NameKey project, ReplicationState... states) {
    try {
        return threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException, PermissionBackendException {
                return shouldReplicate(project);
            }
        }).call();
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, states);
    } catch (Exception e) {
        Throwables.throwIfUnchecked(e);
        throw new RuntimeException(e);
    }
    return false;
}
#end_block

#method_before
void schedule(Project.NameKey project, String ref, URIish uri, ReplicationState state, boolean now) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!shouldReplicate(project, ref, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            addRef(e, ref);
            pool.schedule(e, now ? 0 : config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        } else if (!e.getRefs().contains(ref)) {
            addRef(e, ref);
        }
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#method_after
void schedule(Project.NameKey project, String ref, URIish uri, ReplicationState state, boolean now) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!shouldReplicate(project, ref, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            addRef(e, ref);
            e.addState(ref, state);
            pool.schedule(e, now ? 0 : config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        } else if (!e.getRefs().contains(ref)) {
            addRef(e, ref);
            e.addState(ref, state);
        }
        state.increasePushTaskCount(project.get(), ref);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#end_block

#method_before
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.canceledByReplication();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, config.getDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    RemoteRefUpdate.Status status = RetryReason.REPOSITORY_MISSING.equals(reason) ? NON_EXISTING : REJECTED_OTHER_REASON;
                    postReplicationFailedEvent(pushOp, status);
                    if (pushOp.setToRetry()) {
                        postReplicationScheduledEvent(pushOp);
                        pool.schedule(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    } else {
                        pushOp.canceledByReplication();
                        pending.remove(uri);
                        stateLog.error("Push to " + pushOp.getURI() + " cancelled after maximum number of retries", pushOp.getStatesAsArray());
                    }
                    break;
            }
        }
    }
}
#method_after
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.canceledByReplication();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, config.getRescheduleDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    RemoteRefUpdate.Status status = RetryReason.REPOSITORY_MISSING.equals(reason) ? NON_EXISTING : REJECTED_OTHER_REASON;
                    postReplicationFailedEvent(pushOp, status);
                    if (pushOp.setToRetry()) {
                        postReplicationScheduledEvent(pushOp);
                        pool.schedule(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    } else {
                        pushOp.canceledByReplication();
                        pending.remove(uri);
                        stateLog.error("Push to " + pushOp.getURI() + " cancelled after maximum number of retries", pushOp.getStatesAsArray());
                    }
                    break;
            }
        }
    }
}
#end_block

#method_before
Destination create(DestinationConfiguration config) {
    return new Destination(injector, config, replicationUserFactory, pluginUser, gitRepositoryManager, permissionBackend, groupBackend, stateLog, groupIncludeCache, eventDispatcher);
}
#method_after
Destination create(DestinationConfiguration config) {
    return new Destination(injector, config, replicationUserFactory, pluginUser, gitRepositoryManager, permissionBackend, userProvider, projectCache, groupBackend, stateLog, groupIncludeCache, eventDispatcher);
}
#end_block

#method_before
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    checkValidCLA(rsrc.getControl());
    Project.NameKey project = rsrc.getNameKey();
    String refName = RefNames.fullName(input.branch);
    permissionBackend.user(user).project(project).ref(refName).check(RefPermission.CREATE_CHANGE);
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeNotes> notes = changeFinder.find(input.baseChange);
            if (notes.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeNotes change = Iterables.getOnlyElement(notes);
            if (!permissionBackend.user(user).change(change).database(db).test(ChangePermission.READ)) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), change);
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getProjectState(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        boolean privateByDefault = rsrc.getProjectState().isPrivateByDefault();
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setDraft(input.status == ChangeStatus.DRAFT);
        ins.setPrivate(input.isPrivate == null ? privateByDefault : input.isPrivate);
        ins.setWorkInProgress(input.workInProgress != null && input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW) {
            throw new BadRequestException("unsupported change status");
        }
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    contributorAgreements.check(rsrc.getNameKey(), rsrc.getUser());
    Project.NameKey project = rsrc.getNameKey();
    String refName = RefNames.fullName(input.branch);
    permissionBackend.user(user).project(project).ref(refName).check(RefPermission.CREATE_CHANGE);
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeNotes> notes = changeFinder.find(input.baseChange);
            if (notes.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeNotes change = Iterables.getOnlyElement(notes);
            try {
                permissionBackend.user(user).change(change).database(db).check(ChangePermission.READ);
            } catch (AuthException e) {
                throw new UnprocessableEntityException("Read not permitted for " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), change);
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
        ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getProjectState(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        boolean privateByDefault = rsrc.getProjectState().isPrivateByDefault();
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        String topic = input.topic;
        if (topic != null) {
            topic = Strings.emptyToNull(topic.trim());
        }
        ins.setTopic(topic);
        ins.setPrivate(input.isPrivate == null ? privateByDefault : input.isPrivate);
        ins.setWorkInProgress(input.workInProgress != null && input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public Response<DashboardInfo> apply(DashboardResource resource, SetDashboard.Input input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, MethodNotAllowedException, IOException, PermissionBackendException {
    if (resource.isProjectDefault()) {
        SetDashboard.Input in = new SetDashboard.Input();
        in.commitMessage = input != null ? input.commitMessage : null;
        return defaultSetter.get().apply(resource, in);
    }
    // TODO: Implement delete of dashboards by API.
    throw new MethodNotAllowedException();
}
#method_after
@Override
public Response<DashboardInfo> apply(DashboardResource resource, SetDashboardInput input) throws RestApiException, IOException, PermissionBackendException {
    if (resource.isProjectDefault()) {
        SetDashboardInput in = new SetDashboardInput();
        in.commitMessage = input != null ? input.commitMessage : null;
        return defaultSetter.get().apply(resource, in);
    }
    // TODO: Implement delete of dashboards by API.
    throw new MethodNotAllowedException();
}
#end_block

#method_before
@Override
public PluginInfo apply(PluginResource resource, Input input) throws MethodNotAllowedException {
    if (!loader.isRemoteAdminEnabled()) {
        throw new MethodNotAllowedException("remote plugin administration is disabled");
    }
    String name = resource.getName();
    loader.disablePlugins(ImmutableSet.of(name));
    return ListPlugins.toPluginInfo(loader.get(name));
}
#method_after
@Override
public PluginInfo apply(PluginResource resource, Input input) throws RestApiException {
    try {
        permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER);
    } catch (PermissionBackendException e) {
        throw new RestApiException("Could not check permission", e);
    }
    loader.checkRemoteAdminEnabled();
    String name = resource.getName();
    loader.disablePlugins(ImmutableSet.of(name));
    return ListPlugins.toPluginInfo(loader.get(name));
}
#end_block

#method_before
@Override
public BranchResource parse(ProjectResource parent, IdString id) throws ResourceNotFoundException, IOException, PermissionBackendException {
    Project.NameKey project = parent.getNameKey();
    try (Repository repo = repoManager.openRepository(project)) {
        Ref ref = repo.exactRef(RefNames.fullName(id.get()));
        if (ref == null) {
            throw new ResourceNotFoundException(id);
        }
        // ListBranches checks the target of a symbolic reference to determine access
        // rights on the symbolic reference itself. This check prevents seeing a hidden
        // branch simply because the symbolic reference name was visible.
        permissionBackend.user(user).project(project).ref(ref.isSymbolic() ? ref.getTarget().getName() : ref.getName()).check(RefPermission.READ);
        return new BranchResource(parent.getControl(), ref);
    } catch (AuthException notAllowed) {
        throw new ResourceNotFoundException(id);
    } catch (RepositoryNotFoundException noRepo) {
        throw new ResourceNotFoundException();
    }
}
#method_after
@Override
public BranchResource parse(ProjectResource parent, IdString id) throws ResourceNotFoundException, IOException, PermissionBackendException {
    Project.NameKey project = parent.getNameKey();
    try (Repository repo = repoManager.openRepository(project)) {
        Ref ref = repo.exactRef(RefNames.fullName(id.get()));
        if (ref == null) {
            throw new ResourceNotFoundException(id);
        }
        // ListBranches checks the target of a symbolic reference to determine access
        // rights on the symbolic reference itself. This check prevents seeing a hidden
        // branch simply because the symbolic reference name was visible.
        permissionBackend.user(user).project(project).ref(ref.isSymbolic() ? ref.getTarget().getName() : ref.getName()).check(RefPermission.READ);
        return new BranchResource(parent.getProjectState(), parent.getUser(), ref);
    } catch (AuthException notAllowed) {
        throw new ResourceNotFoundException(id);
    } catch (RepositoryNotFoundException noRepo) {
        throw new ResourceNotFoundException();
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public CreateBranch create(ProjectResource parent, IdString name) {
    return createBranchFactory.create(name.get());
}
#method_after
@Override
public CreateBranch create(ProjectResource parent, IdString name) {
    return createBranchFactory.create(name.get());
}
#end_block

#method_before
@Override
public Response<CommitInfo> apply(RevisionResource rsrc) throws IOException {
    Project.NameKey p = rsrc.getChange().getProject();
    try (Repository repo = repoManager.openRepository(p);
        RevWalk rw = new RevWalk(repo)) {
        String rev = rsrc.getPatchSet().getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        CommitInfo info = json.noOptions().toCommit(rsrc.getControl(), rw, commit, addLinks, true);
        Response<CommitInfo> r = Response.ok(info);
        if (rsrc.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    }
}
#method_after
@Override
public Response<CommitInfo> apply(RevisionResource rsrc) throws IOException {
    Project.NameKey p = rsrc.getChange().getProject();
    try (Repository repo = repoManager.openRepository(p);
        RevWalk rw = new RevWalk(repo)) {
        String rev = rsrc.getPatchSet().getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        CommitInfo info = json.noOptions().toCommit(rsrc.getProject(), rw, commit, addLinks, true);
        Response<CommitInfo> r = Response.ok(info);
        if (rsrc.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    }
}
#end_block

#method_before
public void fire(Change change, PatchSet ps, Account author, String comment, Map<String, Short> approvals, Map<String, Short> oldApprovals, Timestamp when) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        Event event = new Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(author), comment, util.approvals(author, approvals, when), util.approvals(author, oldApprovals, when), when);
        for (CommentAddedListener l : listeners) {
            try {
                l.onCommentAdded(event);
            } catch (Exception e) {
                util.logEventListenerError(this, l, e);
            }
        }
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException e) {
        log.error("Couldn't fire event", e);
    }
}
#method_after
public void fire(Change change, PatchSet ps, Account author, String comment, Map<String, Short> approvals, Map<String, Short> oldApprovals, Timestamp when) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        Event event = new Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(author), comment, util.approvals(author, approvals, when), util.approvals(author, oldApprovals, when), when);
        for (CommentAddedListener l : listeners) {
            try {
                l.onCommentAdded(event);
            } catch (Exception e) {
                util.logEventListenerError(this, l, e);
            }
        }
    } catch (PatchListObjectTooLargeException e) {
        log.warn("Couldn't fire event: " + e.getMessage());
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException | PermissionBackendException e) {
        log.error("Couldn't fire event", e);
    }
}
#end_block

#method_before
private void bypassSubmitRules(ChangeSet cs, boolean allowClosed) {
    checkArgument(!cs.furtherHiddenChanges(), "cannot bypass submit rules for topic with hidden change");
    for (ChangeData cd : cs.changes()) {
        List<SubmitRecord> records;
        try {
            records = new ArrayList<>(getSubmitRecords(cd, allowClosed));
        } catch (OrmException e) {
            log.warn("Error checking submit rules for change " + cd.getId(), e);
            records = new ArrayList<>(1);
        }
        SubmitRecord forced = new SubmitRecord();
        forced.status = SubmitRecord.Status.FORCED;
        records.add(forced);
        cd.setSubmitRecords(submitRuleOptions(allowClosed), records);
    }
}
#method_after
private void bypassSubmitRules(ChangeSet cs, boolean allowClosed) throws OrmException {
    checkArgument(!cs.furtherHiddenChanges(), "cannot bypass submit rules for topic with hidden change");
    for (ChangeData cd : cs.changes()) {
        List<SubmitRecord> records = new ArrayList<>(getSubmitRecords(cd, allowClosed));
        SubmitRecord forced = new SubmitRecord();
        forced.status = SubmitRecord.Status.FORCED;
        records.add(forced);
        cd.setSubmitRecords(submitRuleOptions(allowClosed), records);
    }
}
#end_block

#method_before
private BranchBatch validateChangeList(OpenRepo or, Collection<ChangeData> submitted) throws IntegrationException {
    logDebug("Validating {} changes", submitted.size());
    Set<CodeReviewCommit> toSubmit = new LinkedHashSet<>(submitted.size());
    SetMultimap<ObjectId, PatchSet.Id> revisions = getRevisions(or, submitted);
    SubmitType submitType = null;
    ChangeData choseSubmitTypeFrom = null;
    for (ChangeData cd : submitted) {
        Change.Id changeId = cd.getId();
        ChangeControl ctl;
        Change chg;
        try {
            ctl = cd.changeControl();
            chg = cd.change();
        } catch (OrmException e) {
            commitStatus.logProblem(changeId, e);
            continue;
        }
        SubmitType st = getSubmitType(cd);
        if (st == null) {
            commitStatus.logProblem(changeId, "No submit type for change");
            continue;
        }
        if (submitType == null) {
            submitType = st;
            choseSubmitTypeFrom = cd;
        } else if (st != submitType) {
            commitStatus.problem(changeId, String.format("Change has submit type %s, but previously chose submit type %s " + "from change %s in the same batch", st, submitType, choseSubmitTypeFrom.getId()));
            continue;
        }
        if (chg.currentPatchSetId() == null) {
            String msg = "Missing current patch set on change";
            logError(msg + " " + changeId);
            commitStatus.problem(changeId, msg);
            continue;
        }
        PatchSet ps;
        Branch.NameKey destBranch = chg.getDest();
        try {
            ps = cd.currentPatchSet();
        } catch (OrmException e) {
            commitStatus.logProblem(changeId, e);
            continue;
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commitStatus.logProblem(changeId, "Missing patch set or revision on change");
            continue;
        }
        String idstr = ps.getRevision().get();
        ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException e) {
            commitStatus.logProblem(changeId, e);
            continue;
        }
        if (!revisions.containsEntry(id, ps.getId())) {
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commitStatus.logProblem(changeId, "Revision " + idstr + " of patch set " + ps.getPatchSetId() + " does not match " + ps.getId().toRefName() + " for change");
            continue;
        }
        CodeReviewCommit commit;
        try {
            commit = or.rw.parseCommit(id);
        } catch (IOException e) {
            commitStatus.logProblem(changeId, e);
            continue;
        }
        // TODO(dborowitz): Consider putting ChangeData in CodeReviewCommit.
        commit.setControl(ctl);
        commit.setPatchsetId(ps.getId());
        commitStatus.put(commit);
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(or.repo, commit, or.project, destBranch, ps.getId(), caller);
        } catch (MergeValidationException mve) {
            commitStatus.problem(changeId, mve.getMessage());
            continue;
        }
        commit.add(or.canMergeFlag);
        toSubmit.add(commit);
    }
    logDebug("Submitting on this run: {}", toSubmit);
    return new AutoValue_MergeOp_BranchBatch(submitType, toSubmit);
}
#method_after
private BranchBatch validateChangeList(OpenRepo or, Collection<ChangeData> submitted) throws IntegrationException {
    logDebug("Validating {} changes", submitted.size());
    Set<CodeReviewCommit> toSubmit = new LinkedHashSet<>(submitted.size());
    SetMultimap<ObjectId, PatchSet.Id> revisions = getRevisions(or, submitted);
    SubmitType submitType = null;
    ChangeData choseSubmitTypeFrom = null;
    for (ChangeData cd : submitted) {
        Change.Id changeId = cd.getId();
        ChangeNotes notes;
        Change chg;
        SubmitType st;
        try {
            notes = cd.notes();
            chg = cd.change();
            st = getSubmitType(cd);
        } catch (OrmException e) {
            commitStatus.logProblem(changeId, e);
            continue;
        }
        if (st == null) {
            commitStatus.logProblem(changeId, "No submit type for change");
            continue;
        }
        if (submitType == null) {
            submitType = st;
            choseSubmitTypeFrom = cd;
        } else if (st != submitType) {
            commitStatus.problem(changeId, String.format("Change has submit type %s, but previously chose submit type %s " + "from change %s in the same batch", st, submitType, choseSubmitTypeFrom.getId()));
            continue;
        }
        if (chg.currentPatchSetId() == null) {
            String msg = "Missing current patch set on change";
            logError(msg + " " + changeId);
            commitStatus.problem(changeId, msg);
            continue;
        }
        PatchSet ps;
        Branch.NameKey destBranch = chg.getDest();
        try {
            ps = cd.currentPatchSet();
        } catch (OrmException e) {
            commitStatus.logProblem(changeId, e);
            continue;
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commitStatus.logProblem(changeId, "Missing patch set or revision on change");
            continue;
        }
        String idstr = ps.getRevision().get();
        ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException e) {
            commitStatus.logProblem(changeId, e);
            continue;
        }
        if (!revisions.containsEntry(id, ps.getId())) {
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commitStatus.logProblem(changeId, "Revision " + idstr + " of patch set " + ps.getPatchSetId() + " does not match " + ps.getId().toRefName() + " for change");
            continue;
        }
        CodeReviewCommit commit;
        try {
            commit = or.rw.parseCommit(id);
        } catch (IOException e) {
            commitStatus.logProblem(changeId, e);
            continue;
        }
        commit.setNotes(notes);
        commit.setPatchsetId(ps.getId());
        commitStatus.put(commit);
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(or.repo, commit, or.project, destBranch, ps.getId(), caller);
        } catch (MergeValidationException mve) {
            commitStatus.problem(changeId, mve.getMessage());
            continue;
        }
        commit.add(or.canMergeFlag);
        toSubmit.add(commit);
    }
    logDebug("Submitting on this run: {}", toSubmit);
    return new AutoValue_MergeOp_BranchBatch(submitType, toSubmit);
}
#end_block

#method_before
private SubmitType getSubmitType(ChangeData cd) {
    try {
        SubmitTypeRecord str = cd.submitTypeRecord();
        return str.isOk() ? str.type : null;
    } catch (OrmException e) {
        logError("Failed to get submit type for " + cd.getId(), e);
        return null;
    }
}
#method_after
private SubmitType getSubmitType(ChangeData cd) throws OrmException {
    SubmitTypeRecord str = cd.submitTypeRecord();
    return str.isOk() ? str.type : null;
}
#end_block

#method_before
public ProjectControl controlFor(Project.NameKey nameKey, CurrentUser user) throws NoSuchProjectException, IOException {
    final ProjectState p = projectCache.checkedGet(nameKey);
    if (p == null) {
        throw new NoSuchProjectException(nameKey);
    }
    return p.controlFor(user);
}
#method_after
ProjectControl controlFor(Project.NameKey nameKey, CurrentUser user) throws NoSuchProjectException, IOException {
    final ProjectState p = projectCache.checkedGet(nameKey);
    if (p == null) {
        throw new NoSuchProjectException(nameKey);
    }
    return p.controlFor(user);
}
#end_block

#method_before
public ProjectControl forUser(CurrentUser who) {
    ProjectControl r = state.controlFor(who);
    // Not per-user, and reusing saves lookup time.
    r.allSections = allSections;
    return r;
}
#method_after
ProjectControl forUser(CurrentUser who) {
    ProjectControl r = state.controlFor(who);
    // Not per-user, and reusing saves lookup time.
    r.allSections = allSections;
    return r;
}
#end_block

#method_before
public ChangeControl controlFor(ReviewDb db, Change change) throws OrmException {
    return changeControlFactory.create(controlForRef(change.getDest()), db, change.getProject(), change.getId());
}
#method_after
ChangeControl controlFor(ReviewDb db, Change change) throws OrmException {
    return changeControlFactory.create(controlForRef(change.getDest()), db, change.getProject(), change.getId());
}
#end_block

#method_before
public ChangeControl controlFor(ChangeNotes notes) {
    return changeControlFactory.create(controlForRef(notes.getChange().getDest()), notes);
}
#method_after
ChangeControl controlFor(ChangeNotes notes) {
    return changeControlFactory.create(controlForRef(notes.getChange().getDest()), notes);
}
#end_block

#method_before
public RefControl controlForRef(Branch.NameKey ref) {
    return controlForRef(ref.get());
}
#method_after
RefControl controlForRef(Branch.NameKey ref) {
    return controlForRef(ref.get());
}
#end_block

#method_before
public RefControl controlForRef(String refName) {
    if (refControls == null) {
        refControls = new HashMap<>();
    }
    RefControl ctl = refControls.get(refName);
    if (ctl == null) {
        PermissionCollection relevant = permissionFilter.filter(access(), refName, user);
        ctl = new RefControl(this, refName, relevant);
        refControls.put(refName, ctl);
    }
    return ctl;
}
#method_after
RefControl controlForRef(String refName) {
    if (refControls == null) {
        refControls = new HashMap<>();
    }
    RefControl ctl = refControls.get(refName);
    if (ctl == null) {
        PermissionCollection relevant = permissionFilter.filter(access(), refName, user);
        ctl = new RefControl(this, refName, relevant);
        refControls.put(refName, ctl);
    }
    return ctl;
}
#end_block

#method_before
public CurrentUser getUser() {
    return user;
}
#method_after
CurrentUser getUser() {
    return user;
}
#end_block

#method_before
public ProjectState getProjectState() {
    return state;
}
#method_after
ProjectState getProjectState() {
    return state;
}
#end_block

#method_before
public Project getProject() {
    return state.getProject();
}
#method_after
Project getProject() {
    return state.getProject();
}
#end_block

#method_before
public boolean isOwner() {
    return (isDeclaredOwner() && !controlForRef("refs/*").isBlocked(Permission.OWNER)) || isAdmin();
}
#method_after
boolean isOwner() {
    return (isDeclaredOwner() && !controlForRef("refs/*").isBlocked(Permission.OWNER)) || isAdmin();
}
#end_block

#method_before
public Capable canPushToAtLeastOneRef() {
    if (!canPerformOnAnyRef(Permission.PUSH) && !canPerformOnAnyRef(Permission.CREATE_TAG) && !isOwner()) {
        return new Capable("Upload denied for project '" + state.getName() + "'");
    }
    if (state.isUseContributorAgreements()) {
        return verifyActiveContributorAgreement();
    }
    return Capable.OK;
}
#method_after
boolean canPushToAtLeastOneRef() {
    return canPerformOnAnyRef(Permission.PUSH) || canPerformOnAnyRef(Permission.CREATE_TAG) || isOwner();
}
#end_block

#method_before
public boolean canRunUploadPack() {
    for (AccountGroup.UUID group : uploadGroups) {
        if (match(group)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean canRunUploadPack() {
    for (AccountGroup.UUID group : uploadGroups) {
        if (match(group)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public boolean canRunReceivePack() {
    for (AccountGroup.UUID group : receiveGroups) {
        if (match(group)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean canRunReceivePack() {
    for (AccountGroup.UUID group : receiveGroups) {
        if (match(group)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public boolean allRefsAreVisible(Set<String> ignore) {
    return user.isInternalUser() || canPerformOnAllRefs(Permission.READ, ignore);
}
#method_after
private boolean allRefsAreVisible(Set<String> ignore) {
    return user.isInternalUser() || canPerformOnAllRefs(Permission.READ, ignore);
}
#end_block

#method_before
private boolean canAddRefs() {
    return (canPerformOnAnyRef(Permission.CREATE) || isOwnerAnyRef());
}
#method_after
private boolean canAddRefs() {
    return (canPerformOnAnyRef(Permission.CREATE) || isAdmin());
}
#end_block

#method_before
private boolean can(ProjectPermission perm) throws PermissionBackendException {
    switch(perm) {
        case ACCESS:
            return (!isHidden() && (user.isInternalUser() || canPerformOnAnyRef(Permission.READ))) || isOwner();
        case READ:
            return !isHidden() && allRefsAreVisible(Collections.emptySet());
        case CREATE_REF:
            return canAddRefs();
        case CREATE_CHANGE:
            return canCreateChanges();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
private boolean can(ProjectPermission perm) throws PermissionBackendException {
    switch(perm) {
        case ACCESS:
            return (!isHidden() && (user.isInternalUser() || canPerformOnAnyRef(Permission.READ))) || isOwner();
        case READ:
            return !isHidden() && allRefsAreVisible(Collections.emptySet());
        case READ_NO_CONFIG:
            return !isHidden() && allRefsAreVisible(ImmutableSet.of(RefNames.REFS_CONFIG));
        case CREATE_REF:
            return canAddRefs();
        case CREATE_CHANGE:
            return canCreateChanges();
        case RUN_RECEIVE_PACK:
            return canRunReceivePack();
        case RUN_UPLOAD_PACK:
            return canRunUploadPack();
        case PUSH_AT_LEAST_ONE_REF:
            return canPushToAtLeastOneRef();
        case BAN_COMMIT:
        case READ_REFLOG:
        case READ_CONFIG:
        case WRITE_CONFIG:
            return isOwner();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    super.init();
    if (fromId != null) {
        // Don't call yourself a reviewer of your own patch set.
        // 
        reviewers.remove(fromId);
    }
    if (notify == NotifyHandling.ALL || notify == NotifyHandling.OWNER_REVIEWERS) {
        add(RecipientType.TO, reviewers);
        add(RecipientType.CC, extraCC);
    }
    rcptToAuthors(RecipientType.CC);
    bccStarredBy();
    includeWatchers(NotifyType.NEW_PATCHSETS, !patchSet.isDraft() && !change.isWorkInProgress() && !change.isPrivate());
    removeUsersThatIgnoredTheChange();
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    if (fromId != null) {
        // Don't call yourself a reviewer of your own patch set.
        // 
        reviewers.remove(fromId);
    }
    if (notify == NotifyHandling.ALL || notify == NotifyHandling.OWNER_REVIEWERS) {
        add(RecipientType.TO, reviewers);
        add(RecipientType.CC, extraCC);
    }
    rcptToAuthors(RecipientType.CC);
    bccStarredBy();
    includeWatchers(NotifyType.NEW_PATCHSETS, !change.isWorkInProgress() && !change.isPrivate());
    removeUsersThatIgnoredTheChange();
}
#end_block

#method_before
private IdentifiedUser parseIdOnBehalfOf(@Nullable CurrentUser caller, String id) throws AuthException, OrmException, IOException, ConfigInvalidException {
    if (id.equals("self")) {
        CurrentUser user = self.get();
        if (user.isIdentifiedUser()) {
            return user.asIdentifiedUser();
        } else if (user instanceof AnonymousUser) {
            throw new AuthException("Authentication required");
        } else {
            return null;
        }
    }
    Account match = resolver.find(db.get(), id);
    if (match == null) {
        return null;
    }
    CurrentUser realUser = caller != null ? caller.getRealUser() : null;
    return userFactory.runAs(null, match.getId(), realUser);
}
#method_after
private IdentifiedUser parseIdOnBehalfOf(@Nullable CurrentUser caller, String id) throws AuthException, OrmException, IOException, ConfigInvalidException {
    if (id.equals("self")) {
        CurrentUser user = self.get();
        if (user.isIdentifiedUser()) {
            return user.asIdentifiedUser();
        } else if (user instanceof AnonymousUser) {
            throw new AuthException("Authentication required");
        } else {
            return null;
        }
    }
    Account match = resolver.find(id);
    if (match == null) {
        return null;
    }
    CurrentUser realUser = caller != null ? caller.getRealUser() : null;
    return userFactory.runAs(null, match.getId(), realUser);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public CreateAccount create(TopLevelResource parent, IdString username) {
    return createAccountFactory.create(username.get());
}
#method_after
@Override
public CreateAccount create(TopLevelResource parent, IdString username) {
    return createAccountFactory.create(username.get());
}
#end_block

#method_before
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | PermissionBackendException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.throwIfInstanceOf(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#method_after
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | PermissionBackendException | NoSuchProjectException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.throwIfInstanceOf(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#end_block

#method_before
public ChangeInfo format(RevisionResource rsrc) throws OrmException {
    ChangeData cd = changeDataFactory.create(db.get(), rsrc.getControl());
    return format(cd, Optional.of(rsrc.getPatchSet().getId()), true);
}
#method_after
public ChangeInfo format(RevisionResource rsrc) throws OrmException {
    ChangeData cd = changeDataFactory.create(db.get(), rsrc.getNotes());
    return format(cd, Optional.of(rsrc.getPatchSet().getId()), true);
}
#end_block

#method_before
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | PermissionBackendException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#method_after
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | PermissionBackendException | NoSuchProjectException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else if (e instanceof NoSuchChangeException) {
                    log.info("NoSuchChangeException: Omitting corrupt change " + cd.getId() + " from results. Seems to be stale in the index.");
                    continue;
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#end_block

#method_before
private ChangeInfo checkOnly(ChangeData cd) {
    ChangeControl ctl;
    try {
        ctl = cd.changeControl().forUser(userProvider.get());
    } catch (OrmException e) {
        String msg = "Error loading change";
        log.warn(msg + " " + cd.getId(), e);
        ChangeInfo info = new ChangeInfo();
        info._number = cd.getId().get();
        ProblemInfo p = new ProblemInfo();
        p.message = msg;
        info.problems = Lists.newArrayList(p);
        return info;
    }
    ConsistencyChecker.Result result = checkerProvider.get().check(ctl, fix);
    ChangeInfo info;
    Change c = result.change();
    if (c != null) {
        info = new ChangeInfo();
        info.project = c.getProject().get();
        info.branch = c.getDest().getShortName();
        info.topic = c.getTopic();
        info.changeId = c.getKey().get();
        info.subject = c.getSubject();
        info.status = c.getStatus().asChangeStatus();
        info.owner = new AccountInfo(c.getOwner().get());
        info.created = c.getCreatedOn();
        info.updated = c.getLastUpdatedOn();
        info._number = c.getId().get();
        info.problems = result.problems();
        info.isPrivate = c.isPrivate() ? true : null;
        info.workInProgress = c.isWorkInProgress() ? true : null;
        info.hasReviewStarted = c.hasReviewStarted();
        finish(info);
    } else {
        info = new ChangeInfo();
        info._number = result.id().get();
        info.problems = result.problems();
    }
    return info;
}
#method_after
private ChangeInfo checkOnly(ChangeData cd) {
    ChangeNotes notes;
    try {
        notes = cd.notes();
    } catch (OrmException e) {
        String msg = "Error loading change";
        log.warn(msg + " " + cd.getId(), e);
        ChangeInfo info = new ChangeInfo();
        info._number = cd.getId().get();
        ProblemInfo p = new ProblemInfo();
        p.message = msg;
        info.problems = Lists.newArrayList(p);
        return info;
    }
    ConsistencyChecker.Result result = checkerProvider.get().check(notes, fix);
    ChangeInfo info;
    Change c = result.change();
    if (c != null) {
        info = new ChangeInfo();
        info.project = c.getProject().get();
        info.branch = c.getDest().getShortName();
        info.topic = c.getTopic();
        info.changeId = c.getKey().get();
        info.subject = c.getSubject();
        info.status = c.getStatus().asChangeStatus();
        info.owner = new AccountInfo(c.getOwner().get());
        info.created = c.getCreatedOn();
        info.updated = c.getLastUpdatedOn();
        info._number = c.getId().get();
        info.problems = result.problems();
        info.isPrivate = c.isPrivate() ? true : null;
        info.workInProgress = c.isWorkInProgress() ? true : null;
        info.hasReviewStarted = c.hasReviewStarted();
        finish(info);
    } else {
        info = new ChangeInfo();
        info._number = result.id().get();
        info.problems = result.problems();
    }
    return info;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.ForChange perm = permissionBackend.user(user).database(db).change(cd);
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
        }
    }
    out.labels = labelsFor(perm, ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(ctl, out);
    }
    setSubmitter(cd, out);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException, NoSuchProjectException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.ForChange perm = permissionBackendForChange(user, cd);
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        out.reviewed = cd.isReviewedBy(user.getAccountId()) ? true : null;
    }
    out.labels = labelsFor(perm, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(cd);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(PermissionBackend.ForChange perm, ChangeControl ctl, ChangeData cd, boolean standard, boolean detailed) throws OrmException, PermissionBackendException {
    if (!standard && !detailed) {
        return null;
    }
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = cd.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus() == Change.Status.MERGED ? labelsForSubmittedChange(perm, cd, labelTypes, standard, detailed) : labelsForUnsubmittedChange(perm, cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#method_after
private Map<String, LabelInfo> labelsFor(PermissionBackend.ForChange perm, ChangeData cd, boolean standard, boolean detailed) throws OrmException, PermissionBackendException {
    if (!standard && !detailed) {
        return null;
    }
    LabelTypes labelTypes = cd.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus() == Change.Status.MERGED ? labelsForSubmittedChange(perm, cd, labelTypes, standard, detailed) : labelsForUnsubmittedChange(perm, cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#end_block

#method_before
private Map<String, Short> currentLabels(PermissionBackend.ForChange perm, ChangeData cd) throws OrmException {
    IdentifiedUser user = perm.user().asIdentifiedUser();
    Map<String, Short> result = new HashMap<>();
    for (PatchSetApproval psa : approvalsUtil.byPatchSetUser(db.get(), cd.notes(), user, cd.change().currentPatchSetId(), user.getAccountId(), null, null)) {
        result.put(psa.getLabel(), psa.getValue());
    }
    return result;
}
#method_after
private Map<String, Short> currentLabels(PermissionBackend.ForChange perm, ChangeData cd) throws OrmException {
    IdentifiedUser user = perm.user().asIdentifiedUser();
    Map<String, Short> result = new HashMap<>();
    for (PatchSetApproval psa : approvalsUtil.byPatchSetUser(db.get(), lazyLoad ? cd.notes() : notesFactory.createFromIndexedChange(cd.change()), user, cd.change().currentPatchSetId(), user.getAccountId(), null, null)) {
        result.put(psa.getLabel(), psa.getValue());
    }
    return result;
}
#end_block

#method_before
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            Account.Id realAuthor = message.getRealAuthor();
            if (realAuthor != null) {
                cmi.realAuthor = accountLoader.get(realAuthor);
            }
            result.add(cmi);
        }
    }
    return result;
}
#method_after
private Collection<ChangeMessageInfo> messages(ChangeData cd) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        ChangeMessageInfo cmi = new ChangeMessageInfo();
        cmi.id = message.getKey().get();
        cmi.author = accountLoader.get(message.getAuthor());
        cmi.date = message.getWrittenOn();
        cmi.message = message.getMessage();
        cmi.tag = message.getTag();
        cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
        Account.Id realAuthor = message.getRealAuthor();
        if (realAuthor != null) {
            cmi.realAuthor = accountLoader.get(realAuthor);
        }
        result.add(cmi);
    }
    return result;
}
#end_block

#method_before
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) throws PermissionBackendException, NoSuchChangeException {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (removeReviewerControl.testRemoveReviewer(ctl.getNotes(), ctl.getUser(), id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            if (ai._accountId != null) {
                Account.Id id = new Account.Id(ai._accountId);
                if (removeReviewerControl.testRemoveReviewer(ctl.getNotes(), ctl.getUser(), id, 0)) {
                    removable.add(id);
                }
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    // Reviewers added by email are always removable
    for (Collection<AccountInfo> infos : out.reviewers.values()) {
        for (AccountInfo info : infos) {
            if (info._accountId == null) {
                result.add(info);
            }
        }
    }
    return result;
}
#method_after
private Collection<AccountInfo> removableReviewers(ChangeData cd, ChangeInfo out) throws PermissionBackendException, NoSuchProjectException, OrmException, IOException {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (removeReviewerControl.testRemoveReviewer(cd, userProvider.get(), id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            if (ai._accountId != null) {
                Account.Id id = new Account.Id(ai._accountId);
                if (removeReviewerControl.testRemoveReviewer(cd, userProvider.get(), id, 0)) {
                    removable.add(id);
                }
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    // Reviewers added by email are always removable
    for (Collection<AccountInfo> infos : out.reviewers.values()) {
        for (AccountInfo info : infos) {
            if (info._accountId == null) {
                result.add(info);
            }
        }
    }
    return result;
}
#end_block

#method_before
@Nullable
private Repository openRepoIfNecessary(ChangeControl ctl) throws IOException {
    if (has(ALL_COMMITS) || has(CURRENT_COMMIT) || has(COMMIT_FOOTERS)) {
        return repoManager.openRepository(ctl.getProject().getNameKey());
    }
    return null;
}
#method_after
@Nullable
private Repository openRepoIfNecessary(Project.NameKey project) throws IOException {
    if (has(ALL_COMMITS) || has(CURRENT_COMMIT) || has(COMMIT_FOOTERS)) {
        return repoManager.openRepository(project);
    }
    return null;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, Optional<PatchSet.Id> limitToPsId, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(ctl);
        RevWalk rw = newRevWalk(repo)) {
        for (PatchSet in : map.values()) {
            PatchSet.Id id = in.getId();
            boolean want = false;
            if (has(ALL_REVISIONS)) {
                want = true;
            } else if (limitToPsId.isPresent()) {
                want = id.equals(limitToPsId.get());
            } else {
                want = id.equals(ctl.getChange().currentPatchSetId());
            }
            if (want && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo, rw, false, changeInfo));
            }
        }
        return res;
    }
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeData cd, Map<PatchSet.Id, PatchSet> map, Optional<PatchSet.Id> limitToPsId, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    Boolean isWorldReadable = null;
    try (Repository repo = openRepoIfNecessary(cd.project());
        RevWalk rw = newRevWalk(repo)) {
        for (PatchSet in : map.values()) {
            PatchSet.Id id = in.getId();
            boolean want = false;
            if (has(ALL_REVISIONS)) {
                want = true;
            } else if (limitToPsId.isPresent()) {
                want = id.equals(limitToPsId.get());
            } else {
                want = id.equals(cd.change().currentPatchSetId());
            }
            if (want) {
                if (isWorldReadable == null) {
                    isWorldReadable = isWorldReadable(cd);
                }
                res.put(in.getRevision().get(), toRevisionInfo(cd, in, repo, rw, false, changeInfo, isWorldReadable));
            }
        }
        return res;
    }
}
#end_block

#method_before
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(ctl);
        RevWalk rw = newRevWalk(repo)) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, rw, true, null);
        accountLoader.fill();
        return rev;
    }
}
#method_after
public RevisionInfo getRevisionInfo(ChangeData cd, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(cd.project());
        RevWalk rw = newRevWalk(repo)) {
        RevisionInfo rev = toRevisionInfo(cd, in, repo, rw, true, null, isWorldReadable(cd));
        accountLoader.fill();
        return rev;
    }
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, @Nullable Repository repo, @Nullable RevWalk rw, boolean fillCommit, @Nullable ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(rw, repo != null ? repo.getConfig() : null, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        checkState(rw != null);
        checkState(repo != null);
        Project.NameKey project = c.getProject();
        String rev = in.getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        if (setCommit) {
            out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS), fillCommit);
        }
        if (addFooters) {
            Ref ref = repo.exactRef(ctl.getChange().getDest().get());
            RevCommit mergeTip = null;
            if (ref != null) {
                mergeTip = rw.parseCommit(ref.getObjectId());
                rw.parseBody(mergeTip);
            }
            out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, ctl, in.getId());
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in, @Nullable Repository repo, @Nullable RevWalk rw, boolean fillCommit, @Nullable ChangeInfo changeInfo, boolean isWorldReadable) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = cd.change();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.fetch = makeFetchMap(cd, in, isWorldReadable);
    out.kind = changeKindCache.getChangeKind(rw, repo != null ? repo.getConfig() : null, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        checkState(rw != null);
        checkState(repo != null);
        Project.NameKey project = c.getProject();
        String rev = in.getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        if (setCommit) {
            out.commit = toCommit(project, rw, commit, has(WEB_LINKS), fillCommit);
        }
        if (addFooters) {
            Ref ref = repo.exactRef(cd.change().getDest().get());
            RevCommit mergeTip = null;
            if (ref != null) {
                mergeTip = rw.parseCommit(ref.getObjectId());
                rw.parseBody(mergeTip);
            }
            out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, cd.notes(), userProvider.get(), in.getId());
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if (out.isCurrent && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(cd.notes(), userProvider.get()), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        List<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links;
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            List<WebLinkInfo> parentLinks = webLinks.getParentLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks;
        }
        info.parents.add(i);
    }
    return info;
}
#method_after
CommitInfo toCommit(Project.NameKey project, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        List<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links;
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            List<WebLinkInfo> parentLinks = webLinks.getParentLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks;
        }
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
private Map<String, FetchInfo> makeFetchMap(ChangeControl ctl, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = new LinkedHashMap<>();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.forUser(anonymous).isPatchVisible(in, db.get())) {
            continue;
        }
        String projectName = ctl.getProject().getNameKey().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#method_after
private Map<String, FetchInfo> makeFetchMap(ChangeData cd, PatchSet in, boolean isWorldReadable) {
    Map<String, FetchInfo> r = new LinkedHashMap<>();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !isWorldReadable) {
            continue;
        }
        String projectName = cd.project().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#end_block

#method_before
@Override
public String apply(GroupResource rsrc, Input input) throws MethodNotAllowedException, AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, IOException {
    GroupDescription.Internal internalGroup = rsrc.asInternalGroup().orElseThrow(MethodNotAllowedException::new);
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    } else if (input == null || Strings.isNullOrEmpty(input.name)) {
        throw new BadRequestException("name is required");
    }
    String newName = input.name.trim();
    if (newName.isEmpty()) {
        throw new BadRequestException("name is required");
    }
    if (internalGroup.getName().equals(newName)) {
        return newName;
    }
    renameGroup(internalGroup, newName);
    return newName;
}
#method_after
@Override
public String apply(GroupResource rsrc, NameInput input) throws MethodNotAllowedException, AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, IOException {
    GroupDescription.Internal internalGroup = rsrc.asInternalGroup().orElseThrow(MethodNotAllowedException::new);
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    } else if (input == null || Strings.isNullOrEmpty(input.name)) {
        throw new BadRequestException("name is required");
    }
    String newName = input.name.trim();
    if (newName.isEmpty()) {
        throw new BadRequestException("name is required");
    }
    if (internalGroup.getName().equals(newName)) {
        return newName;
    }
    renameGroup(internalGroup, newName);
    return newName;
}
#end_block

#method_before
@Override
protected Response<String> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource req, Input input) throws UpdateException, RestApiException, PermissionBackendException {
    req.permissions().check(ChangePermission.EDIT_TOPIC_NAME);
    Op op = new Op(input != null ? input : new Input());
    try (BatchUpdate u = updateFactory.create(dbProvider.get(), req.getChange().getProject(), req.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getId(), op);
        u.execute();
    }
    return Strings.isNullOrEmpty(op.newTopicName) ? Response.none() : Response.ok(op.newTopicName);
}
#method_after
@Override
protected Response<String> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource req, TopicInput input) throws UpdateException, RestApiException, PermissionBackendException {
    req.permissions().check(ChangePermission.EDIT_TOPIC_NAME);
    if (input != null && input.topic != null && input.topic.length() > ChangeUtil.TOPIC_MAX_LENGTH) {
        throw new BadRequestException(String.format("topic length exceeds the limit (%s)", ChangeUtil.TOPIC_MAX_LENGTH));
    }
    Op op = new Op(input != null ? input : new TopicInput());
    try (BatchUpdate u = updateFactory.create(dbProvider.get(), req.getChange().getProject(), req.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getId(), op);
        u.execute();
    }
    return Strings.isNullOrEmpty(op.newTopicName) ? Response.none() : Response.ok(op.newTopicName);
}
#end_block

#method_before
@Override
public TagInfo apply(ProjectResource resource, TagInput input) throws RestApiException, IOException, PermissionBackendException {
    if (input == null) {
        input = new TagInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    ref = RefUtil.normalizeTagRef(ref);
    RefControl refControl = resource.getControl().controlForRef(ref);
    PermissionBackend.ForRef perm = permissionBackend.user(identifiedUser).project(resource.getNameKey()).ref(ref);
    try (Repository repo = repoManager.openRepository(resource.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, resource.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        rw.reset();
        boolean isAnnotated = Strings.emptyToNull(input.message) != null;
        boolean isSigned = isAnnotated && input.message.contains("-----BEGIN PGP SIGNATURE-----\n");
        if (isSigned) {
            throw new MethodNotAllowedException("Cannot create signed tag \"" + ref + "\"");
        } else if (isAnnotated && !refControl.canPerform(Permission.CREATE_TAG)) {
            throw new AuthException("Cannot create annotated tag \"" + ref + "\"");
        } else {
            perm.check(RefPermission.CREATE);
        }
        if (repo.getRefDatabase().exactRef(ref) != null) {
            throw new ResourceConflictException("tag \"" + ref + "\" already exists");
        }
        try (Git git = new Git(repo)) {
            TagCommand tag = git.tag().setObjectId(object).setName(ref.substring(R_TAGS.length())).setAnnotated(isAnnotated).setSigned(isSigned);
            if (isAnnotated) {
                tag.setMessage(input.message).setTagger(identifiedUser.get().newCommitterIdent(TimeUtil.nowTs(), TimeZone.getDefault()));
            }
            Ref result = tag.call();
            tagCache.updateFastForward(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId());
            referenceUpdated.fire(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId(), identifiedUser.get().getAccount());
            try (RevWalk w = new RevWalk(repo)) {
                return ListTags.createTagInfo(perm, result, w, resource.getNameKey(), links);
            }
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("Invalid base revision");
    } catch (GitAPIException e) {
        log.error("Cannot create tag \"" + ref + "\"", e);
        throw new IOException(e);
    }
}
#method_after
@Override
public TagInfo apply(ProjectResource resource, TagInput input) throws RestApiException, IOException, PermissionBackendException, NoSuchProjectException {
    if (input == null) {
        input = new TagInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    ref = RefUtil.normalizeTagRef(ref);
    // TODO(hiesel): Remove dependency on RefControl
    RefControl refControl = projectControlFactory.controlFor(resource.getNameKey(), resource.getUser()).controlForRef(ref);
    PermissionBackend.ForRef perm = permissionBackend.user(identifiedUser).project(resource.getNameKey()).ref(ref);
    try (Repository repo = repoManager.openRepository(resource.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, resource.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        rw.reset();
        boolean isAnnotated = Strings.emptyToNull(input.message) != null;
        boolean isSigned = isAnnotated && input.message.contains("-----BEGIN PGP SIGNATURE-----\n");
        if (isSigned) {
            throw new MethodNotAllowedException("Cannot create signed tag \"" + ref + "\"");
        } else if (isAnnotated && !refControl.canPerform(Permission.CREATE_TAG)) {
            throw new AuthException("Cannot create annotated tag \"" + ref + "\"");
        } else {
            perm.check(RefPermission.CREATE);
        }
        if (repo.getRefDatabase().exactRef(ref) != null) {
            throw new ResourceConflictException("tag \"" + ref + "\" already exists");
        }
        try (Git git = new Git(repo)) {
            TagCommand tag = git.tag().setObjectId(object).setName(ref.substring(R_TAGS.length())).setAnnotated(isAnnotated).setSigned(isSigned);
            if (isAnnotated) {
                tag.setMessage(input.message).setTagger(identifiedUser.get().newCommitterIdent(TimeUtil.nowTs(), TimeZone.getDefault()));
            }
            Ref result = tag.call();
            tagCache.updateFastForward(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId());
            referenceUpdated.fire(resource.getNameKey(), ref, ObjectId.zeroId(), result.getObjectId(), identifiedUser.get().getAccount());
            try (RevWalk w = new RevWalk(repo)) {
                return ListTags.createTagInfo(perm, result, w, resource.getNameKey(), links);
            }
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("Invalid base revision");
    } catch (GitAPIException e) {
        log.error("Cannot create tag \"" + ref + "\"", e);
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public void configure() {
    factory(ChangeDraftUpdate.Factory.class);
    factory(ChangeUpdate.Factory.class);
    factory(DeleteCommentRewriter.Factory.class);
    factory(DraftCommentNotes.Factory.class);
    factory(NoteDbUpdateManager.Factory.class);
    factory(RobotCommentNotes.Factory.class);
    factory(RobotCommentUpdate.Factory.class);
    if (!useTestBindings) {
        install(ChangeNotesCache.module());
        if (cfg.getBoolean("noteDb", null, "testRebuilderWrapper", false)) {
            // Yes, another variety of test bindings with a different way of
            // configuring it.
            bind(ChangeRebuilder.class).to(TestChangeRebuilderWrapper.class);
        } else {
            bind(ChangeRebuilder.class).to(ChangeRebuilderImpl.class);
        }
    } else {
        bind(ChangeRebuilder.class).toInstance(new ChangeRebuilder(null) {

            @Override
            public Result rebuild(ReviewDb db, Change.Id changeId) {
                return null;
            }

            @Override
            public Result rebuildEvenIfReadOnly(ReviewDb db, Id changeId) {
                return null;
            }

            @Override
            public Result rebuild(NoteDbUpdateManager manager, ChangeBundle bundle) {
                return null;
            }

            @Override
            public NoteDbUpdateManager stage(ReviewDb db, Change.Id changeId) {
                return null;
            }

            @Override
            public Result execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) {
                return null;
            }

            @Override
            public void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) {
            // Do nothing.
            }

            @Override
            public void rebuildReviewDb(ReviewDb db, Project.NameKey project, Id changeId) {
            // Do nothing.
            }
        });
        bind(new TypeLiteral<Cache<ChangeNotesCache.Key, ChangeNotesState>>() {
        }).annotatedWith(Names.named(ChangeNotesCache.CACHE_NAME)).toInstance(CacheBuilder.newBuilder().<ChangeNotesCache.Key, ChangeNotesState>build());
    }
}
#method_after
@Override
public void configure() {
    factory(ChangeDraftUpdate.Factory.class);
    factory(ChangeUpdate.Factory.class);
    factory(DeleteCommentRewriter.Factory.class);
    factory(DraftCommentNotes.Factory.class);
    factory(NoteDbUpdateManager.Factory.class);
    factory(RobotCommentNotes.Factory.class);
    factory(RobotCommentUpdate.Factory.class);
    DynamicSet.setOf(binder(), NotesMigrationStateListener.class);
    if (!useTestBindings) {
        install(ChangeNotesCache.module());
        if (cfg.getBoolean("noteDb", null, "testRebuilderWrapper", false)) {
            // Yes, another variety of test bindings with a different way of
            // configuring it.
            bind(ChangeRebuilder.class).to(TestChangeRebuilderWrapper.class);
        } else {
            bind(ChangeRebuilder.class).to(ChangeRebuilderImpl.class);
        }
    } else {
        bind(ChangeRebuilder.class).toInstance(new ChangeRebuilder(null) {

            @Override
            public Result rebuild(ReviewDb db, Change.Id changeId) {
                return null;
            }

            @Override
            public Result rebuildEvenIfReadOnly(ReviewDb db, Id changeId) {
                return null;
            }

            @Override
            public Result rebuild(NoteDbUpdateManager manager, ChangeBundle bundle) {
                return null;
            }

            @Override
            public NoteDbUpdateManager stage(ReviewDb db, Change.Id changeId) {
                return null;
            }

            @Override
            public Result execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) {
                return null;
            }

            @Override
            public void buildUpdates(NoteDbUpdateManager manager, ChangeBundle bundle) {
            // Do nothing.
            }

            @Override
            public void rebuildReviewDb(ReviewDb db, Project.NameKey project, Id changeId) {
            // Do nothing.
            }
        });
        bind(new TypeLiteral<Cache<ChangeNotesCache.Key, ChangeNotesState>>() {
        }).annotatedWith(Names.named(ChangeNotesCache.CACHE_NAME)).toInstance(CacheBuilder.newBuilder().<ChangeNotesCache.Key, ChangeNotesState>build());
    }
}
#end_block

#method_before
@Override
public BinaryResult apply(RevisionResource rsrc) throws BadRequestException, IOException, MethodNotAllowedException {
    if (Strings.isNullOrEmpty(format)) {
        throw new BadRequestException("format is not specified");
    }
    final ArchiveFormat f = allowedFormats.extensions.get("." + format);
    if (f == null) {
        throw new BadRequestException("unknown archive format");
    }
    if (f == ArchiveFormat.ZIP) {
        throw new MethodNotAllowedException("zip format is disabled");
    }
    boolean close = true;
    final Repository repo = repoManager.openRepository(rsrc.getControl().getProject().getNameKey());
    try {
        final RevCommit commit;
        String name;
        try (RevWalk rw = new RevWalk(repo)) {
            commit = rw.parseCommit(ObjectId.fromString(rsrc.getPatchSet().getRevision().get()));
            name = name(f, rw, commit);
        }
        BinaryResult bin = new BinaryResult() {

            @Override
            public void writeTo(OutputStream out) throws IOException {
                try {
                    new ArchiveCommand(repo).setFormat(f.name()).setTree(commit.getTree()).setOutputStream(out).call();
                } catch (GitAPIException e) {
                    throw new IOException(e);
                }
            }

            @Override
            public void close() throws IOException {
                repo.close();
            }
        };
        bin.disableGzip().setContentType(f.getMimeType()).setAttachmentName(name);
        close = false;
        return bin;
    } finally {
        if (close) {
            repo.close();
        }
    }
}
#method_after
@Override
public BinaryResult apply(RevisionResource rsrc) throws BadRequestException, IOException, MethodNotAllowedException {
    if (Strings.isNullOrEmpty(format)) {
        throw new BadRequestException("format is not specified");
    }
    final ArchiveFormat f = allowedFormats.extensions.get("." + format);
    if (f == null) {
        throw new BadRequestException("unknown archive format");
    }
    if (f == ArchiveFormat.ZIP) {
        throw new MethodNotAllowedException("zip format is disabled");
    }
    boolean close = true;
    final Repository repo = repoManager.openRepository(rsrc.getProject());
    try {
        final RevCommit commit;
        String name;
        try (RevWalk rw = new RevWalk(repo)) {
            commit = rw.parseCommit(ObjectId.fromString(rsrc.getPatchSet().getRevision().get()));
            name = name(f, rw, commit);
        }
        BinaryResult bin = new BinaryResult() {

            @Override
            public void writeTo(OutputStream out) throws IOException {
                try {
                    new ArchiveCommand(repo).setFormat(f.name()).setTree(commit.getTree()).setOutputStream(out).call();
                } catch (GitAPIException e) {
                    throw new IOException(e);
                }
            }

            @Override
            public void close() throws IOException {
                repo.close();
            }
        };
        bin.disableGzip().setContentType(f.getMimeType()).setAttachmentName(name);
        close = false;
        return bin;
    } finally {
        if (close) {
            repo.close();
        }
    }
}
#end_block

#method_before
public static Predicate<AccountGroup> uuid(AccountGroup.UUID uuid) {
    return new GroupPredicate(GroupField.UUID, GroupQueryBuilder.FIELD_UUID, uuid.get());
}
#method_after
public static Predicate<InternalGroup> uuid(AccountGroup.UUID uuid) {
    return new GroupPredicate(GroupField.UUID, GroupQueryBuilder.FIELD_UUID, uuid.get());
}
#end_block

#method_before
public static Predicate<AccountGroup> description(String description) {
    return new GroupPredicate(GroupField.DESCRIPTION, GroupQueryBuilder.FIELD_DESCRIPTION, description);
}
#method_after
public static Predicate<InternalGroup> description(String description) {
    return new GroupPredicate(GroupField.DESCRIPTION, GroupQueryBuilder.FIELD_DESCRIPTION, description);
}
#end_block

#method_before
public static Predicate<AccountGroup> inname(String name) {
    return new GroupPredicate(GroupField.NAME_PART, GroupQueryBuilder.FIELD_INNAME, name.toLowerCase(Locale.US));
}
#method_after
public static Predicate<InternalGroup> inname(String name) {
    return new GroupPredicate(GroupField.NAME_PART, GroupQueryBuilder.FIELD_INNAME, name.toLowerCase(Locale.US));
}
#end_block

#method_before
public static Predicate<AccountGroup> name(String name) {
    return new GroupPredicate(GroupField.NAME, GroupQueryBuilder.FIELD_NAME, name);
}
#method_after
public static Predicate<InternalGroup> name(String name) {
    return new GroupPredicate(GroupField.NAME, GroupQueryBuilder.FIELD_NAME, name);
}
#end_block

#method_before
public static Predicate<AccountGroup> owner(AccountGroup.UUID ownerUuid) {
    return new GroupPredicate(GroupField.OWNER_UUID, GroupQueryBuilder.FIELD_OWNER, ownerUuid.get());
}
#method_after
public static Predicate<InternalGroup> owner(AccountGroup.UUID ownerUuid) {
    return new GroupPredicate(GroupField.OWNER_UUID, GroupQueryBuilder.FIELD_OWNER, ownerUuid.get());
}
#end_block

#method_before
public static Predicate<AccountGroup> isVisibleToAll() {
    return new GroupPredicate(GroupField.IS_VISIBLE_TO_ALL, "1");
}
#method_after
public static Predicate<InternalGroup> isVisibleToAll() {
    return new GroupPredicate(GroupField.IS_VISIBLE_TO_ALL, "1");
}
#end_block

#method_before
public Change getChange() {
    return getControl().getChange();
}
#method_after
public Change getChange() {
    return getChangeResource().getChange();
}
#end_block

#method_before
CurrentUser getUser() {
    return getControl().getUser();
}
#method_after
CurrentUser getUser() {
    return getChangeResource().getUser();
}
#end_block

#method_before
@Override
public List<AccountInfo> apply(GroupResource resource) throws MethodNotAllowedException, OrmException {
    GroupDescription.Internal group = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new);
    return apply(group.getGroupUUID());
}
#method_after
@Override
public List<AccountInfo> apply(GroupResource resource) throws MethodNotAllowedException, OrmException {
    GroupDescription.Internal group = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new);
    if (recursive) {
        return getTransitiveMembers(group, resource.getControl());
    }
    return getDirectMembers(group, resource.getControl());
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    JdbcSchema schema = (JdbcSchema) db;
    SqlDialect dialect = schema.getDialect();
    try (StatementExecutor e = newExecutor(db)) {
        dialect.dropIndex(e, "accounts", "accounts_byFullName");
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    JdbcSchema schema = (JdbcSchema) db;
    SqlDialect dialect = schema.getDialect();
    try (StatementExecutor e = newExecutor(db)) {
        dialect.dropIndex(e, "accounts", "accounts_byFullName");
    } catch (OrmException ex) {
    // Ignore. The index did not exist.
    }
}
#end_block

#method_before
public ListMultimap<RecipientType, Account.Id> resolveAccounts(@Nullable Map<RecipientType, NotifyInfo> notifyDetails) throws OrmException, BadRequestException, IOException, ConfigInvalidException {
    if (isNullOrEmpty(notifyDetails)) {
        return ImmutableListMultimap.of();
    }
    ListMultimap<RecipientType, Account.Id> m = null;
    for (Entry<RecipientType, NotifyInfo> e : notifyDetails.entrySet()) {
        List<String> accounts = e.getValue().accounts;
        if (accounts != null) {
            if (m == null) {
                m = MultimapBuilder.hashKeys().arrayListValues().build();
            }
            m.putAll(e.getKey(), find(dbProvider.get(), accounts));
        }
    }
    return m != null ? m : ImmutableListMultimap.of();
}
#method_after
public ListMultimap<RecipientType, Account.Id> resolveAccounts(@Nullable Map<RecipientType, NotifyInfo> notifyDetails) throws OrmException, BadRequestException, IOException, ConfigInvalidException {
    if (isNullOrEmpty(notifyDetails)) {
        return ImmutableListMultimap.of();
    }
    ListMultimap<RecipientType, Account.Id> m = null;
    for (Entry<RecipientType, NotifyInfo> e : notifyDetails.entrySet()) {
        List<String> accounts = e.getValue().accounts;
        if (accounts != null) {
            if (m == null) {
                m = MultimapBuilder.hashKeys().arrayListValues().build();
            }
            m.putAll(e.getKey(), find(accounts));
        }
    }
    return m != null ? m : ImmutableListMultimap.of();
}
#end_block

#method_before
private List<Account.Id> find(ReviewDb db, List<String> nameOrEmails) throws OrmException, BadRequestException, IOException, ConfigInvalidException {
    List<String> missing = new ArrayList<>(nameOrEmails.size());
    List<Account.Id> r = new ArrayList<>(nameOrEmails.size());
    for (String nameOrEmail : nameOrEmails) {
        Account a = accountResolver.find(db, nameOrEmail);
        if (a != null) {
            r.add(a.getId());
        } else {
            missing.add(nameOrEmail);
        }
    }
    if (!missing.isEmpty()) {
        throw new BadRequestException("The following accounts that should be notified could not be resolved: " + missing.stream().distinct().sorted().collect(joining(", ")));
    }
    return r;
}
#method_after
private List<Account.Id> find(List<String> nameOrEmails) throws OrmException, BadRequestException, IOException, ConfigInvalidException {
    List<String> missing = new ArrayList<>(nameOrEmails.size());
    List<Account.Id> r = new ArrayList<>(nameOrEmails.size());
    for (String nameOrEmail : nameOrEmails) {
        Account a = accountResolver.find(nameOrEmail);
        if (a != null) {
            r.add(a.getId());
        } else {
            missing.add(nameOrEmail);
        }
    }
    if (!missing.isEmpty()) {
        throw new BadRequestException("The following accounts that should be notified could not be resolved: " + missing.stream().distinct().sorted().collect(joining(", ")));
    }
    return r;
}
#end_block

#method_before
public static DashboardResource projectDefault(ProjectControl ctl) {
    return new DashboardResource(ctl, null, null, null, true);
}
#method_after
public static DashboardResource projectDefault(ProjectState projectState, CurrentUser user) {
    return new DashboardResource(projectState, user, null, null, null, true);
}
#end_block

#method_before
@Override
public ConfigInfo apply(ProjectResource rsrc, ConfigInput input) throws RestApiException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("restricted to project owner");
    }
    return apply(rsrc.getProjectState(), input);
}
#method_after
@Override
public ConfigInfo apply(ProjectResource rsrc, ConfigInput input) throws RestApiException, PermissionBackendException {
    permissionBackend.user(user).project(rsrc.getNameKey()).check(ProjectPermission.WRITE_CONFIG);
    return apply(rsrc.getProjectState(), input);
}
#end_block

#method_before
public ConfigInfo apply(ProjectState projectState, ConfigInput input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = projectState.getNameKey();
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(projectName)) {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.createNewChangeForAllNotInTarget != null) {
            p.setCreateNewChangeForAllNotInTarget(input.createNewChangeForAllNotInTarget);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (serverEnableSignedPush) {
            if (input.enableSignedPush != null) {
                p.setEnableSignedPush(input.enableSignedPush);
            }
            if (input.requireSignedPush != null) {
                p.setRequireSignedPush(input.requireSignedPush);
            }
        }
        if (input.rejectImplicitMerges != null) {
            p.setRejectImplicitMerges(input.rejectImplicitMerges);
        }
        if (input.privateByDefault != null) {
            p.setPrivateByDefault(input.privateByDefault);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        if (input.enableReviewerByEmail != null) {
            p.setEnableReviewerByEmail(input.enableReviewerByEmail);
        }
        if (input.matchAuthorToCommitterDate != null) {
            p.setMatchAuthorToCommitterDate(input.matchAuthorToCommitterDate);
        }
        if (input.pluginConfigValues != null) {
            setPluginConfigValues(projectState, projectConfig, input.pluginConfigValues);
        }
        md.setMessage("Modified project settings\n");
        try {
            projectConfig.commit(md);
            projectCache.evict(projectConfig.getProject());
            md.getRepository().setGitwebDescription(p.getDescription());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            }
            log.warn(String.format("Failed to update config of project %s.", projectName), e);
            throw new ResourceConflictException("Cannot update " + projectName);
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfoImpl(serverEnableSignedPush, state.controlFor(user.get()), config, pluginConfigEntries, cfgFactory, allProjects, uiActions, views);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    }
}
#method_after
public ConfigInfo apply(ProjectState projectState, ConfigInput input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = projectState.getNameKey();
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(projectName)) {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.createNewChangeForAllNotInTarget != null) {
            p.setCreateNewChangeForAllNotInTarget(input.createNewChangeForAllNotInTarget);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (serverEnableSignedPush) {
            if (input.enableSignedPush != null) {
                p.setEnableSignedPush(input.enableSignedPush);
            }
            if (input.requireSignedPush != null) {
                p.setRequireSignedPush(input.requireSignedPush);
            }
        }
        if (input.rejectImplicitMerges != null) {
            p.setRejectImplicitMerges(input.rejectImplicitMerges);
        }
        if (input.privateByDefault != null) {
            p.setPrivateByDefault(input.privateByDefault);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        if (input.enableReviewerByEmail != null) {
            p.setEnableReviewerByEmail(input.enableReviewerByEmail);
        }
        if (input.matchAuthorToCommitterDate != null) {
            p.setMatchAuthorToCommitterDate(input.matchAuthorToCommitterDate);
        }
        if (input.pluginConfigValues != null) {
            setPluginConfigValues(projectState, projectConfig, input.pluginConfigValues);
        }
        md.setMessage("Modified project settings\n");
        try {
            projectConfig.commit(md);
            projectCache.evict(projectConfig.getProject());
            md.getRepository().setGitwebDescription(p.getDescription());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            }
            log.warn(String.format("Failed to update config of project %s.", projectName), e);
            throw new ResourceConflictException("Cannot update " + projectName);
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfoImpl(serverEnableSignedPush, state, user.get(), config, pluginConfigEntries, cfgFactory, allProjects, uiActions, views);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    }
}
#end_block

#method_before
public List<ChangeNotes> find(String id) throws OrmException {
    if (id.isEmpty()) {
        return Collections.emptyList();
    }
    int z = id.lastIndexOf('~');
    int y = id.lastIndexOf('~', z - 1);
    if (y < 0 && z > 0) {
        // Try project~numericChangeId
        Integer n = Ints.tryParse(id.substring(z + 1));
        if (n != null) {
            return fromProjectNumber(id.substring(0, z), n.intValue());
        }
    }
    if (y < 0 && z < 0) {
        // Try numeric changeId
        Integer n = Ints.tryParse(id);
        if (n != null) {
            return find(new Change.Id(n));
        }
    }
    // Use the index to search for changes, but don't return any stored fields,
    // to force rereading in case the index is stale.
    InternalChangeQuery query = queryProvider.get().noFields();
    if (y > 0 && z > 0) {
        // Try change triplet (project~branch~Ihash...)
        Optional<ChangeTriplet> triplet = ChangeTriplet.parse(id, y, z);
        if (triplet.isPresent()) {
            ChangeTriplet t = triplet.get();
            return asChangeNotes(query.byBranchKey(t.branch(), t.id()));
        }
    }
    // Try isolated Ihash... format ("Change-Id: Ihash").
    return asChangeNotes(query.byKeyPrefix(id));
}
#method_after
public List<ChangeNotes> find(String id) throws OrmException {
    if (id.isEmpty()) {
        return Collections.emptyList();
    }
    int z = id.lastIndexOf('~');
    int y = id.lastIndexOf('~', z - 1);
    if (y < 0 && z > 0) {
        // Try project~numericChangeId
        Integer n = Ints.tryParse(id.substring(z + 1));
        if (n != null) {
            return fromProjectNumber(id.substring(0, z), n.intValue());
        }
    }
    if (y < 0 && z < 0) {
        // Try numeric changeId
        Integer n = Ints.tryParse(id);
        if (n != null) {
            return find(new Change.Id(n));
        }
    }
    // Use the index to search for changes, but don't return any stored fields,
    // to force rereading in case the index is stale.
    InternalChangeQuery query = queryProvider.get().noFields();
    // Try commit hash
    if (id.matches("^([0-9a-fA-F]{" + RevId.ABBREV_LEN + "," + RevId.LEN + "})$")) {
        return asChangeNotes(query.byCommit(id));
    }
    if (y > 0 && z > 0) {
        // Try change triplet (project~branch~Ihash...)
        Optional<ChangeTriplet> triplet = ChangeTriplet.parse(id, y, z);
        if (triplet.isPresent()) {
            ChangeTriplet t = triplet.get();
            return asChangeNotes(query.byBranchKey(t.branch(), t.id()));
        }
    }
    // Try isolated Ihash... format ("Change-Id: Ihash").
    return asChangeNotes(query.byKeyPrefix(id));
}
#end_block

#method_before
@Override
public Description getDescription(ChangeResource rsrc) {
    return new UiAction.Description().setLabel("Ignore").setTitle("Ignore the change").setVisible(!rsrc.isUserOwner() && !isIgnored(rsrc));
}
#method_after
@Override
public Description getDescription(ChangeResource rsrc) {
    return new UiAction.Description().setLabel("Ignore").setTitle("Ignore the change").setVisible(canIgnore(rsrc));
}
#end_block

#method_before
@Override
public Response<String> apply(ChangeResource rsrc, Input input) throws RestApiException {
    try {
        if (rsrc.isUserOwner() || isIgnored(rsrc)) {
            // early exit for own changes and already ignored changes
            return Response.ok("");
        }
        stars.ignore(self.get().getAccountId(), rsrc.getProject(), rsrc.getChange().getId());
    } catch (OrmException e) {
        throw new RestApiException("failed to ignore change", e);
    }
    return Response.ok("");
}
#method_after
@Override
public Response<String> apply(ChangeResource rsrc, Input input) throws RestApiException, OrmException, IllegalLabelException {
    try {
        if (rsrc.isUserOwner()) {
            throw new BadRequestException("cannot ignore own change");
        }
        if (!isIgnored(rsrc)) {
            stars.ignore(rsrc);
        }
        return Response.ok("");
    } catch (MutuallyExclusiveLabelsException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
private boolean isIgnored(ChangeResource rsrc) {
    try {
        return stars.isIgnoredBy(rsrc.getChange().getId(), self.get().getAccountId());
    } catch (OrmException e) {
        log.error("failed to check ignored star", e);
    }
    return false;
}
#method_after
private boolean isIgnored(ChangeResource rsrc) {
    try {
        return stars.isIgnored(rsrc);
    } catch (OrmException e) {
        log.error("failed to check ignored star", e);
    }
    return false;
}
#end_block

#method_before
@Override
public RelatedInfo apply(RevisionResource rsrc) throws RepositoryNotFoundException, IOException, OrmException {
    RelatedInfo relatedInfo = new RelatedInfo();
    relatedInfo.changes = getRelated(rsrc);
    return relatedInfo;
}
#method_after
@Override
public RelatedInfo apply(RevisionResource rsrc) throws RepositoryNotFoundException, IOException, OrmException, NoSuchProjectException, PermissionBackendException {
    RelatedInfo relatedInfo = new RelatedInfo();
    relatedInfo.changes = getRelated(rsrc);
    return relatedInfo;
}
#end_block

#method_before
private List<ChangeAndCommit> getRelated(RevisionResource rsrc) throws OrmException, IOException {
    Set<String> groups = getAllGroups(rsrc.getNotes());
    if (groups.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeData> cds = queryProvider.get().enforceVisibility(true).byProjectGroups(rsrc.getChange().getProject(), groups);
    if (cds.isEmpty()) {
        return Collections.emptyList();
    }
    if (cds.size() == 1 && cds.get(0).getId().equals(rsrc.getChange().getId())) {
        return Collections.emptyList();
    }
    List<ChangeAndCommit> result = new ArrayList<>(cds.size());
    boolean isEdit = rsrc.getEdit().isPresent();
    PatchSet basePs = isEdit ? rsrc.getEdit().get().getBasePatchSet() : rsrc.getPatchSet();
    reloadChangeIfStale(cds, basePs);
    for (PatchSetData d : sorter.sort(cds, basePs)) {
        PatchSet ps = d.patchSet();
        RevCommit commit;
        if (isEdit && ps.getId().equals(basePs.getId())) {
            // Replace base of an edit with the edit itself.
            ps = rsrc.getPatchSet();
            commit = rsrc.getEdit().get().getEditCommit();
        } else {
            commit = d.commit();
        }
        result.add(new ChangeAndCommit(rsrc.getProject(), d.data().change(), ps, commit));
    }
    if (result.size() == 1) {
        ChangeAndCommit r = result.get(0);
        if (r.commit != null && r.commit.commit.equals(rsrc.getPatchSet().getRevision().get())) {
            return Collections.emptyList();
        }
    }
    return result;
}
#method_after
private List<ChangeAndCommit> getRelated(RevisionResource rsrc) throws OrmException, IOException, PermissionBackendException {
    Set<String> groups = getAllGroups(rsrc.getNotes());
    if (groups.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeData> cds = queryProvider.get().enforceVisibility(true).byProjectGroups(rsrc.getChange().getProject(), groups);
    if (cds.isEmpty()) {
        return Collections.emptyList();
    }
    if (cds.size() == 1 && cds.get(0).getId().equals(rsrc.getChange().getId())) {
        return Collections.emptyList();
    }
    List<ChangeAndCommit> result = new ArrayList<>(cds.size());
    boolean isEdit = rsrc.getEdit().isPresent();
    PatchSet basePs = isEdit ? rsrc.getEdit().get().getBasePatchSet() : rsrc.getPatchSet();
    reloadChangeIfStale(cds, basePs);
    for (PatchSetData d : sorter.sort(cds, basePs, rsrc.getUser())) {
        PatchSet ps = d.patchSet();
        RevCommit commit;
        if (isEdit && ps.getId().equals(basePs.getId())) {
            // Replace base of an edit with the edit itself.
            ps = rsrc.getPatchSet();
            commit = rsrc.getEdit().get().getEditCommit();
        } else {
            commit = d.commit();
        }
        result.add(new ChangeAndCommit(rsrc.getProject(), d.data().change(), ps, commit));
    }
    if (result.size() == 1) {
        ChangeAndCommit r = result.get(0);
        if (r.commit != null && r.commit.commit.equals(rsrc.getPatchSet().getRevision().get())) {
            return Collections.emptyList();
        }
    }
    return result;
}
#end_block

#method_before
@Test
public void refStateFieldValues() throws Exception {
    AllUsersName allUsersName = new AllUsersName(AllUsersNameProvider.DEFAULT);
    Account account = new Account(new Account.Id(1), TimeUtil.nowTs());
    String metaId = "0e39795bb25dc914118224995c53c5c36923a461";
    account.setMetaId(metaId);
    List<String> values = toStrings(AccountField.REF_STATE.get(new AccountState(allUsersName, account, ImmutableSet.of(), ImmutableSet.of(), ImmutableMap.of())));
    assertThat(values).hasSize(1);
    String expectedValue = allUsersName.get() + ":" + RefNames.refsUsers(account.getId()) + ":" + metaId;
    assertThat(Iterables.getOnlyElement(values)).isEqualTo(expectedValue);
}
#method_after
@Test
public void refStateFieldValues() throws Exception {
    AllUsersName allUsersName = new AllUsersName(AllUsersNameProvider.DEFAULT);
    Account account = new Account(new Account.Id(1), TimeUtil.nowTs());
    String metaId = "0e39795bb25dc914118224995c53c5c36923a461";
    account.setMetaId(metaId);
    List<String> values = toStrings(AccountField.REF_STATE.get(new AccountState(allUsersName, account, ImmutableSet.of(), ImmutableMap.of())));
    assertThat(values).hasSize(1);
    String expectedValue = allUsersName.get() + ":" + RefNames.refsUsers(account.getId()) + ":" + metaId;
    assertThat(Iterables.getOnlyElement(values)).isEqualTo(expectedValue);
}
#end_block

#method_before
@Test
public void externalIdStateFieldValues() throws Exception {
    Account.Id id = new Account.Id(1);
    Account account = new Account(id, TimeUtil.nowTs());
    ExternalId extId1 = ExternalId.create(ExternalId.Key.create(ExternalId.SCHEME_MAILTO, "foo.bar@example.com"), id, "foo.bar@example.com", null, ObjectId.fromString("1b9a0cf038ea38a0ab08617c39aa8e28413a27ca"));
    ExternalId extId2 = ExternalId.create(ExternalId.Key.create(ExternalId.SCHEME_USERNAME, "foo"), id, null, "secret", ObjectId.fromString("5b3a73dc9a668a5b89b5f049225261e3e3291d1a"));
    List<String> values = toStrings(AccountField.EXTERNAL_ID_STATE.get(new AccountState(null, account, ImmutableSet.of(), ImmutableSet.of(extId1, extId2), ImmutableMap.of())));
    String expectedValue1 = extId1.key().sha1().name() + ":" + extId1.blobId().name();
    String expectedValue2 = extId2.key().sha1().name() + ":" + extId2.blobId().name();
    assertThat(values).containsExactly(expectedValue1, expectedValue2);
}
#method_after
@Test
public void externalIdStateFieldValues() throws Exception {
    Account.Id id = new Account.Id(1);
    Account account = new Account(id, TimeUtil.nowTs());
    ExternalId extId1 = ExternalId.create(ExternalId.Key.create(ExternalId.SCHEME_MAILTO, "foo.bar@example.com"), id, "foo.bar@example.com", null, ObjectId.fromString("1b9a0cf038ea38a0ab08617c39aa8e28413a27ca"));
    ExternalId extId2 = ExternalId.create(ExternalId.Key.create(ExternalId.SCHEME_USERNAME, "foo"), id, null, "secret", ObjectId.fromString("5b3a73dc9a668a5b89b5f049225261e3e3291d1a"));
    List<String> values = toStrings(AccountField.EXTERNAL_ID_STATE.get(new AccountState(null, account, ImmutableSet.of(extId1, extId2), ImmutableMap.of())));
    String expectedValue1 = extId1.key().sha1().name() + ":" + extId1.blobId().name();
    String expectedValue2 = extId2.key().sha1().name() + ":" + extId2.blobId().name();
    assertThat(values).containsExactly(expectedValue1, expectedValue2);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException, IOException, PermissionBackendException {
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ps = psUtil.current(db.get(), ctx.getNotes());
    boolean found = false;
    LabelTypes labelTypes = projectState.getLabelTypes(ctx.getNotes(), ctx.getUser());
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctx.getNotes(), ctx.getUser(), psId, account.getId(), ctx.getRevWalk(), ctx.getRepoView().getConfig())) {
        if (labelTypes.byLabel(a.getLabelId()) == null) {
            // Ignore undefined labels.
            continue;
        } else if (!a.getLabel().equals(label)) {
            // Populate map for non-matching labels, needed by VoteDeleted.
            newApprovals.put(a.getLabel(), a.getValue());
            continue;
        } else {
            try {
                removeReviewerControl.checkRemoveReviewer(ctx.getNotes(), ctx.getUser(), a);
            } catch (AuthException e) {
                throw new AuthException("delete vote not permitted", e);
            }
        }
        // Set the approval to 0 if vote is being removed.
        newApprovals.put(a.getLabel(), (short) 0);
        found = true;
        // Set old value, as required by VoteDeleted.
        oldApprovals.put(a.getLabel(), a.getValue());
        break;
    }
    if (!found) {
        throw new ResourceNotFoundException();
    }
    ctx.getUpdate(psId).removeApprovalFor(account.getId(), label);
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(deletedApproval(ctx)));
    StringBuilder msg = new StringBuilder();
    msg.append("Removed ");
    LabelVote.appendTo(msg, label, checkNotNull(oldApprovals.get(label)));
    msg.append(" by ").append(userFactory.create(account.getId()).getNameEmail()).append("\n");
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_VOTE);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException, IOException, PermissionBackendException, NoSuchProjectException {
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ps = psUtil.current(db.get(), ctx.getNotes());
    boolean found = false;
    LabelTypes labelTypes = projectState.getLabelTypes(ctx.getNotes(), ctx.getUser());
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctx.getNotes(), ctx.getUser(), psId, account.getId(), ctx.getRevWalk(), ctx.getRepoView().getConfig())) {
        if (labelTypes.byLabel(a.getLabelId()) == null) {
            // Ignore undefined labels.
            continue;
        } else if (!a.getLabel().equals(label)) {
            // Populate map for non-matching labels, needed by VoteDeleted.
            newApprovals.put(a.getLabel(), a.getValue());
            continue;
        } else {
            try {
                removeReviewerControl.checkRemoveReviewer(ctx.getNotes(), ctx.getUser(), a);
            } catch (AuthException e) {
                throw new AuthException("delete vote not permitted", e);
            }
        }
        // Set the approval to 0 if vote is being removed.
        newApprovals.put(a.getLabel(), (short) 0);
        found = true;
        // Set old value, as required by VoteDeleted.
        oldApprovals.put(a.getLabel(), a.getValue());
        break;
    }
    if (!found) {
        throw new ResourceNotFoundException();
    }
    ctx.getUpdate(psId).removeApprovalFor(account.getId(), label);
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(deletedApproval(ctx)));
    StringBuilder msg = new StringBuilder();
    msg.append("Removed ");
    LabelVote.appendTo(msg, label, checkNotNull(oldApprovals.get(label)));
    msg.append(" by ").append(userFactory.create(account.getId()).getNameEmail()).append("\n");
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_VOTE);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    return true;
}
#end_block

#method_before
public void fire(Change change, PatchSet ps, Account merger, String newRevisionId, Timestamp when) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        Event event = new Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(merger), newRevisionId, when);
        for (ChangeMergedListener l : listeners) {
            try {
                l.onChangeMerged(event);
            } catch (Exception e) {
                util.logEventListenerError(this, l, e);
            }
        }
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException e) {
        log.error("Couldn't fire event", e);
    }
}
#method_after
public void fire(Change change, PatchSet ps, Account merger, String newRevisionId, Timestamp when) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        Event event = new Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(merger), newRevisionId, when);
        for (ChangeMergedListener l : listeners) {
            try {
                l.onChangeMerged(event);
            } catch (Exception e) {
                util.logEventListenerError(this, l, e);
            }
        }
    } catch (PatchListObjectTooLargeException e) {
        log.warn("Couldn't fire event: " + e.getMessage());
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException | PermissionBackendException e) {
        log.error("Couldn't fire event", e);
    }
}
#end_block

#method_before
@Override
public InternalAccountQuery setRequestedFields(Set<String> fields) {
    super.setRequestedFields(fields);
    return this;
}
#method_after
@SafeVarargs
@Override
public final InternalAccountQuery setRequestedFields(FieldDef<AccountState, ?>... fields) {
    super.setRequestedFields(fields);
    return this;
}
#end_block

#method_before
public AccountState oneByExternalId(ExternalId.Key externalId) throws OrmException {
    List<AccountState> accountStates = byExternalId(externalId);
    if (accountStates.size() == 1) {
        return accountStates.get(0);
    } else if (accountStates.size() > 0) {
        StringBuilder msg = new StringBuilder();
        msg.append("Ambiguous external ID ").append(externalId).append("for accounts: ");
        Joiner.on(", ").appendTo(msg, Lists.transform(accountStates, AccountState.ACCOUNT_ID_FUNCTION));
        log.warn(msg.toString());
    }
    return null;
}
#method_after
public AccountState oneByExternalId(ExternalId.Key externalId) throws OrmException {
    List<AccountState> accountStates = byExternalId(externalId);
    if (accountStates.size() == 1) {
        return accountStates.get(0);
    } else if (accountStates.size() > 0) {
        StringBuilder msg = new StringBuilder();
        msg.append("Ambiguous external ID ").append(externalId).append(" for accounts: ");
        Joiner.on(", ").appendTo(msg, Lists.transform(accountStates, AccountState.ACCOUNT_ID_FUNCTION));
        log.warn(msg.toString());
    }
    return null;
}
#end_block

#method_before
public Multimap<String, AccountState> byPreferredEmail(String... emails) throws OrmException {
    List<String> emailList = Arrays.asList(emails);
    if (schema().hasField(AccountField.PREFERRED_EMAIL_EXACT)) {
        List<List<AccountState>> r = query(emailList.stream().map(e -> AccountPredicates.preferredEmailExact(e)).collect(toList()));
        Multimap<String, AccountState> accountsByEmail = ArrayListMultimap.create();
        for (int i = 0; i < emailList.size(); i++) {
            accountsByEmail.putAll(emailList.get(i), r.get(i));
        }
        return accountsByEmail;
    }
    List<List<AccountState>> r = query(emailList.stream().map(e -> AccountPredicates.preferredEmail(e)).collect(toList()));
    Multimap<String, AccountState> accountsByEmail = ArrayListMultimap.create();
    for (int i = 0; i < emailList.size(); i++) {
        String email = emailList.get(i);
        Set<AccountState> matchingAccounts = r.get(i).stream().filter(a -> a.getAccount().getPreferredEmail().equals(email)).collect(toSet());
        accountsByEmail.putAll(email, matchingAccounts);
    }
    return accountsByEmail;
}
#method_after
public List<AccountState> byPreferredEmail(String email) throws OrmException {
    if (hasPreferredEmailExact()) {
        return query(AccountPredicates.preferredEmailExact(email));
    }
    return query(AccountPredicates.preferredEmail(email)).stream().filter(a -> a.getAccount().getPreferredEmail().equals(email)).collect(toList());
}
#end_block

#method_before
public Multimap<String, AccountState> byPreferredEmail(String... emails) throws OrmException {
    List<String> emailList = Arrays.asList(emails);
    if (schema().hasField(AccountField.PREFERRED_EMAIL_EXACT)) {
        List<List<AccountState>> r = query(emailList.stream().map(e -> AccountPredicates.preferredEmailExact(e)).collect(toList()));
        Multimap<String, AccountState> accountsByEmail = ArrayListMultimap.create();
        for (int i = 0; i < emailList.size(); i++) {
            accountsByEmail.putAll(emailList.get(i), r.get(i));
        }
        return accountsByEmail;
    }
    List<List<AccountState>> r = query(emailList.stream().map(e -> AccountPredicates.preferredEmail(e)).collect(toList()));
    Multimap<String, AccountState> accountsByEmail = ArrayListMultimap.create();
    for (int i = 0; i < emailList.size(); i++) {
        String email = emailList.get(i);
        Set<AccountState> matchingAccounts = r.get(i).stream().filter(a -> a.getAccount().getPreferredEmail().equals(email)).collect(toSet());
        accountsByEmail.putAll(email, matchingAccounts);
    }
    return accountsByEmail;
}
#method_after
public Multimap<String, AccountState> byPreferredEmail(String... emails) throws OrmException {
    List<String> emailList = Arrays.asList(emails);
    if (hasPreferredEmailExact()) {
        List<List<AccountState>> r = query(emailList.stream().map(e -> AccountPredicates.preferredEmailExact(e)).collect(toList()));
        Multimap<String, AccountState> accountsByEmail = ArrayListMultimap.create();
        for (int i = 0; i < emailList.size(); i++) {
            accountsByEmail.putAll(emailList.get(i), r.get(i));
        }
        return accountsByEmail;
    }
    List<List<AccountState>> r = query(emailList.stream().map(e -> AccountPredicates.preferredEmail(e)).collect(toList()));
    Multimap<String, AccountState> accountsByEmail = ArrayListMultimap.create();
    for (int i = 0; i < emailList.size(); i++) {
        String email = emailList.get(i);
        Set<AccountState> matchingAccounts = r.get(i).stream().filter(a -> a.getAccount().getPreferredEmail().equals(email)).collect(toSet());
        accountsByEmail.putAll(email, matchingAccounts);
    }
    return accountsByEmail;
}
#end_block

#method_before
public void fire(Change change, PatchSet patchSet, Account reviewer, Account remover, String message, Map<String, Short> newApprovals, Map<String, Short> oldApprovals, NotifyHandling notify, Timestamp when) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        Event event = new Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(reviewer), util.accountInfo(remover), message, util.approvals(reviewer, newApprovals, when), util.approvals(reviewer, oldApprovals, when), notify, when);
        for (ReviewerDeletedListener listener : listeners) {
            try {
                listener.onReviewerDeleted(event);
            } catch (Exception e) {
                util.logEventListenerError(this, listener, e);
            }
        }
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException e) {
        log.error("Couldn't fire event", e);
    }
}
#method_after
public void fire(Change change, PatchSet patchSet, Account reviewer, Account remover, String message, Map<String, Short> newApprovals, Map<String, Short> oldApprovals, NotifyHandling notify, Timestamp when) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        Event event = new Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(reviewer), util.accountInfo(remover), message, util.approvals(reviewer, newApprovals, when), util.approvals(reviewer, oldApprovals, when), notify, when);
        for (ReviewerDeletedListener listener : listeners) {
            try {
                listener.onReviewerDeleted(event);
            } catch (Exception e) {
                util.logEventListenerError(this, listener, e);
            }
        }
    } catch (PatchListObjectTooLargeException e) {
        log.warn("Couldn't fire event: " + e.getMessage());
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException | PermissionBackendException e) {
        log.error("Couldn't fire event", e);
    }
}
#end_block

#method_before
private Change loadChangeFromDb(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException {
    checkArgument(project != null, "project is required");
    Change change = readOneReviewDbChange(db, changeId);
    if (change == null && args.migration.readChanges()) {
        // Change isn't in ReviewDb, but its primary storage might be in NoteDb.
        // Prepopulate the change exists with proper noteDbState field.
        change = newNoteDbOnlyChange(project, changeId);
    } else {
        checkNotNull(change, "change %s not found in ReviewDb", changeId);
        checkArgument(change.getProject().equals(project), "passed project %s when creating ChangeNotes for %s, but actual project is %s", project, changeId, change.getProject());
    }
    // database
    return change;
}
#method_after
private Change loadChangeFromDb(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException {
    checkArgument(project != null, "project is required");
    Change change = readOneReviewDbChange(db, changeId);
    if (change == null) {
        if (args.migration.readChanges()) {
            return newNoteDbOnlyChange(project, changeId);
        }
        throw new NoSuchChangeException(changeId);
    }
    checkArgument(change.getProject().equals(project), "passed project %s when creating ChangeNotes for %s, but actual project is %s", project, changeId, change.getProject());
    return change;
}
#end_block

#method_before
@Override
public ListRequest list() {
    return new ListRequest() {

        @Override
        public SortedMap<String, PluginInfo> getAsMap() throws RestApiException {
            ListPlugins list = listProvider.get();
            list.setAll(this.getAll());
            list.setStart(this.getStart());
            list.setLimit(this.getLimit());
            list.setMatchPrefix(this.getPrefix());
            list.setMatchSubstring(this.getSubstring());
            list.setMatchRegex(this.getRegex());
            return list.apply(TopLevelResource.INSTANCE);
        }
    };
}
#method_after
@Override
public ListRequest list() {
    return new ListRequest() {

        @Override
        public SortedMap<String, PluginInfo> getAsMap() throws RestApiException {
            return listProvider.get().request(this).apply(TopLevelResource.INSTANCE);
        }
    };
}
#end_block

#method_before
@Override
public Response<List<CommitInfo>> apply(RevisionResource rsrc) throws BadRequestException, IOException {
    Project.NameKey p = rsrc.getChange().getProject();
    try (Repository repo = repoManager.openRepository(p);
        RevWalk rw = new RevWalk(repo)) {
        String rev = rsrc.getPatchSet().getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        if (uninterestingParent < 1 || uninterestingParent > commit.getParentCount()) {
            throw new BadRequestException("No such parent: " + uninterestingParent);
        }
        if (commit.getParentCount() < 2) {
            return createResponse(rsrc, ImmutableList.<CommitInfo>of());
        }
        List<RevCommit> commits = MergeListBuilder.build(rw, commit, uninterestingParent);
        List<CommitInfo> result = new ArrayList<>(commits.size());
        ChangeJson changeJson = json.noOptions();
        for (RevCommit c : commits) {
            result.add(changeJson.toCommit(rsrc.getControl(), rw, c, addLinks, true));
        }
        return createResponse(rsrc, result);
    }
}
#method_after
@Override
public Response<List<CommitInfo>> apply(RevisionResource rsrc) throws BadRequestException, IOException {
    Project.NameKey p = rsrc.getChange().getProject();
    try (Repository repo = repoManager.openRepository(p);
        RevWalk rw = new RevWalk(repo)) {
        String rev = rsrc.getPatchSet().getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        if (uninterestingParent < 1 || uninterestingParent > commit.getParentCount()) {
            throw new BadRequestException("No such parent: " + uninterestingParent);
        }
        if (commit.getParentCount() < 2) {
            return createResponse(rsrc, ImmutableList.<CommitInfo>of());
        }
        List<RevCommit> commits = MergeListBuilder.build(rw, commit, uninterestingParent);
        List<CommitInfo> result = new ArrayList<>(commits.size());
        ChangeJson changeJson = json.noOptions();
        for (RevCommit c : commits) {
            result.add(changeJson.toCommit(rsrc.getProject(), rw, c, addLinks, true));
        }
        return createResponse(rsrc, result);
    }
}
#end_block

#method_before
public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
        return result;
    }
    if (receiveConfig.checkMagicRefs) {
        result = MagicBranch.checkMagicBranchRefs(repo, projectControl.getProject());
    }
    return result;
}
#method_after
public Capable canUpload() throws IOException, PermissionBackendException {
    try {
        perm.check(ProjectPermission.PUSH_AT_LEAST_ONE_REF);
    } catch (AuthException e) {
        return new Capable("Upload denied for project '" + projectState.getName() + "'");
    }
    try {
        contributorAgreements.check(projectState.getNameKey(), user);
    } catch (AuthException e) {
        return new Capable(e.getMessage());
    }
    if (receiveConfig.checkMagicRefs) {
        return MagicBranch.checkMagicBranchRefs(repo, projectState.getProject());
    }
    return Capable.OK;
}
#end_block

#method_before
@Override
public void onPreReceive(ReceivePack rp, Collection<ReceiveCommand> commands) {
    Worker w = new Worker(commands);
    try {
        w.progress.waitFor(executor.submit(scopePropagator.wrap(w)), timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (ExecutionException e) {
        log.warn(String.format("Error in ReceiveCommits while processing changes for project %s", projectControl.getProject().getName()), e);
        rp.sendError("internal error while processing changes");
        // point is very bad.
        for (ReceiveCommand c : commands) {
            if (c.getResult() == Result.NOT_ATTEMPTED) {
                c.setResult(Result.REJECTED_OTHER_REASON, "internal error");
            }
        }
    } finally {
        w.sendMessages();
    }
}
#method_after
@Override
public void onPreReceive(ReceivePack rp, Collection<ReceiveCommand> commands) {
    Worker w = new Worker(commands);
    try {
        w.progress.waitFor(executor.submit(scopePropagator.wrap(w)), timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (ExecutionException e) {
        log.warn(String.format("Error in ReceiveCommits while processing changes for project %s", projectState.getName()), e);
        rp.sendError("internal error while processing changes");
        // point is very bad.
        for (ReceiveCommand c : commands) {
            if (c.getResult() == Result.NOT_ATTEMPTED) {
                c.setResult(Result.REJECTED_OTHER_REASON, "internal error");
            }
        }
    } finally {
        w.sendMessages();
    }
}
#end_block

#method_before
public void fire(Change change, PatchSet ps, Account restorer, String reason, Timestamp when) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        Event event = new Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(restorer), reason, when);
        for (ChangeRestoredListener l : listeners) {
            try {
                l.onChangeRestored(event);
            } catch (Exception e) {
                util.logEventListenerError(this, l, e);
            }
        }
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException e) {
        log.error("Couldn't fire event", e);
    }
}
#method_after
public void fire(Change change, PatchSet ps, Account restorer, String reason, Timestamp when) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        Event event = new Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(restorer), reason, when);
        for (ChangeRestoredListener l : listeners) {
            try {
                l.onChangeRestored(event);
            } catch (Exception e) {
                util.logEventListenerError(this, l, e);
            }
        }
    } catch (PatchListObjectTooLargeException e) {
        log.warn("Couldn't fire event: " + e.getMessage());
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException | PermissionBackendException e) {
        log.error("Couldn't fire event", e);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, RepositoryNotFoundException, IOException {
    change = ctx.getChange();
    if (change.getStatus() != Status.NEW && change.getStatus() != Status.DRAFT) {
        throw new ResourceConflictException("Change is " + ChangeUtil.status(change));
    }
    Project.NameKey projectKey = change.getProject();
    newDestKey = new Branch.NameKey(projectKey, input.destinationBranch);
    Branch.NameKey changePrevDest = change.getDest();
    if (changePrevDest.equals(newDestKey)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    try (Repository repo = repoManager.openRepository(projectKey);
        RevWalk revWalk = new RevWalk(repo)) {
        RevCommit currPatchsetRevCommit = revWalk.parseCommit(ObjectId.fromString(psUtil.current(ctx.getDb(), ctx.getNotes()).getRevision().get()));
        if (currPatchsetRevCommit.getParentCount() > 1) {
            throw new ResourceConflictException("Merge commit cannot be moved");
        }
        ObjectId refId = repo.resolve(input.destinationBranch);
        // Check if destination ref exists in project repo
        if (refId == null) {
            throw new ResourceConflictException("Destination " + input.destinationBranch + " not found in the project");
        }
        RevCommit refCommit = revWalk.parseCommit(refId);
        if (revWalk.isMergedInto(currPatchsetRevCommit, refCommit)) {
            throw new ResourceConflictException("Current patchset revision is reachable from tip of " + input.destinationBranch);
        }
    }
    Change.Key changeKey = change.getKey();
    if (!asChanges(queryProvider.get().byBranchKey(newDestKey, changeKey)).isEmpty()) {
        throw new ResourceConflictException("Destination " + newDestKey.getShortName() + " has a different change with same change key " + changeKey);
    }
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new ResourceConflictException("Patch set is not current");
    }
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    update.setBranch(newDestKey.get());
    change.setDest(newDestKey);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change destination moved from ");
    msgBuf.append(changePrevDest.getShortName());
    msgBuf.append(" to ");
    msgBuf.append(newDestKey.getShortName());
    if (!Strings.isNullOrEmpty(input.message)) {
        msgBuf.append("\n\n");
        msgBuf.append(input.message);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msgBuf.toString(), ChangeMessagesUtil.TAG_MOVE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, IOException {
    change = ctx.getChange();
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("Change is " + ChangeUtil.status(change));
    }
    Project.NameKey projectKey = change.getProject();
    newDestKey = new Branch.NameKey(projectKey, input.destinationBranch);
    Branch.NameKey changePrevDest = change.getDest();
    if (changePrevDest.equals(newDestKey)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    try (Repository repo = repoManager.openRepository(projectKey);
        RevWalk revWalk = new RevWalk(repo)) {
        RevCommit currPatchsetRevCommit = revWalk.parseCommit(ObjectId.fromString(psUtil.current(ctx.getDb(), ctx.getNotes()).getRevision().get()));
        if (currPatchsetRevCommit.getParentCount() > 1) {
            throw new ResourceConflictException("Merge commit cannot be moved");
        }
        ObjectId refId = repo.resolve(input.destinationBranch);
        // Check if destination ref exists in project repo
        if (refId == null) {
            throw new ResourceConflictException("Destination " + input.destinationBranch + " not found in the project");
        }
        RevCommit refCommit = revWalk.parseCommit(refId);
        if (revWalk.isMergedInto(currPatchsetRevCommit, refCommit)) {
            throw new ResourceConflictException("Current patchset revision is reachable from tip of " + input.destinationBranch);
        }
    }
    Change.Key changeKey = change.getKey();
    if (!asChanges(queryProvider.get().byBranchKey(newDestKey, changeKey)).isEmpty()) {
        throw new ResourceConflictException("Destination " + newDestKey.getShortName() + " has a different change with same change key " + changeKey);
    }
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new ResourceConflictException("Patch set is not current");
    }
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setBranch(newDestKey.get());
    change.setDest(newDestKey);
    updateApprovals(ctx, update, psId, projectKey);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change destination moved from ");
    msgBuf.append(changePrevDest.getShortName());
    msgBuf.append(" to ");
    msgBuf.append(newDestKey.getShortName());
    if (!Strings.isNullOrEmpty(input.message)) {
        msgBuf.append("\n\n");
        msgBuf.append(input.message);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msgBuf.toString(), ChangeMessagesUtil.TAG_MOVE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#end_block

#method_before
private Set<Account> listAccounts(final AccountGroup.UUID groupUUID, final Project.NameKey project, final Set<AccountGroup.UUID> seen) throws NoSuchGroupException, OrmException, NoSuchProjectException, IOException {
    if (SystemGroupBackend.PROJECT_OWNERS.equals(groupUUID)) {
        return getProjectOwners(project, seen);
    }
    AccountGroup group = groupCache.get(groupUUID);
    if (group != null) {
        return getGroupMembers(group, project, seen);
    }
    return Collections.emptySet();
}
#method_after
private Set<Account> listAccounts(final AccountGroup.UUID groupUUID, final Project.NameKey project, final Set<AccountGroup.UUID> seen) throws NoSuchGroupException, OrmException, NoSuchProjectException, IOException {
    if (SystemGroupBackend.PROJECT_OWNERS.equals(groupUUID)) {
        return getProjectOwners(project, seen);
    }
    Optional<InternalGroup> group = groupCache.get(groupUUID);
    if (group.isPresent()) {
        return getGroupMembers(group.get(), project, seen);
    }
    return Collections.emptySet();
}
#end_block

#method_before
private Set<Account> getProjectOwners(final Project.NameKey project, Set<AccountGroup.UUID> seen) throws NoSuchProjectException, NoSuchGroupException, OrmException, IOException {
    seen.add(SystemGroupBackend.PROJECT_OWNERS);
    if (project == null) {
        return Collections.emptySet();
    }
    final Iterable<AccountGroup.UUID> ownerGroups = projectControl.controlFor(project, currentUser).getProjectState().getAllOwners();
    final HashSet<Account> projectOwners = new HashSet<>();
    for (AccountGroup.UUID ownerGroup : ownerGroups) {
        if (!seen.contains(ownerGroup)) {
            projectOwners.addAll(listAccounts(ownerGroup, project, seen));
        }
    }
    return projectOwners;
}
#method_after
private Set<Account> getProjectOwners(final Project.NameKey project, Set<AccountGroup.UUID> seen) throws NoSuchProjectException, NoSuchGroupException, OrmException, IOException {
    seen.add(SystemGroupBackend.PROJECT_OWNERS);
    if (project == null) {
        return Collections.emptySet();
    }
    ProjectState projectState = projectCache.checkedGet(project);
    if (projectState == null) {
        throw new NoSuchProjectException(project);
    }
    final HashSet<Account> projectOwners = new HashSet<>();
    for (AccountGroup.UUID ownerGroup : projectState.getAllOwners()) {
        if (!seen.contains(ownerGroup)) {
            projectOwners.addAll(listAccounts(ownerGroup, project, seen));
        }
    }
    return projectOwners;
}
#end_block

#method_before
private Set<Account> getGroupMembers(final AccountGroup group, Project.NameKey project, Set<AccountGroup.UUID> seen) throws NoSuchGroupException, OrmException, NoSuchProjectException, IOException {
    seen.add(group.getGroupUUID());
    final GroupDetail groupDetail = groupDetailFactory.create(group.getGroupUUID()).call();
    final Set<Account> members = new HashSet<>();
    for (Account.Id memberId : groupDetail.getMembers()) {
        members.add(accountCache.get(memberId).getAccount());
    }
    for (AccountGroup.UUID groupIncludeUuid : groupDetail.getIncludes()) {
        AccountGroup includedGroup = groupCache.get(groupIncludeUuid);
        if (includedGroup != null && !seen.contains(includedGroup.getGroupUUID())) {
            members.addAll(listAccounts(includedGroup.getGroupUUID(), project, seen));
        }
    }
    return members;
}
#method_after
private Set<Account> getGroupMembers(InternalGroup group, Project.NameKey project, Set<AccountGroup.UUID> seen) throws NoSuchGroupException, OrmException, NoSuchProjectException, IOException {
    seen.add(group.getGroupUUID());
    GroupControl groupControl = groupControlFactory.controlFor(new InternalGroupDescription(group));
    Set<Account> directMembers = group.getMembers().stream().filter(groupControl::canSeeMember).map(accountCache::get).map(AccountState::getAccount).collect(toImmutableSet());
    Set<Account> indirectMembers = new HashSet<>();
    if (groupControl.canSeeGroup()) {
        for (AccountGroup.UUID subgroupUuid : group.getSubgroups()) {
            if (!seen.contains(subgroupUuid)) {
                indirectMembers.addAll(listAccounts(subgroupUuid, project, seen));
            }
        }
    }
    return Sets.union(directMembers, indirectMembers);
}
#end_block

#method_before
@Override
protected String newHtmlBody(String changeMessage, String c1, String c2, String c3, String f1, String f2, String fc1) {
    String email = "" + "<div dir=\"ltr\">" + (changeMessage != null ? changeMessage : "") + "<div class=\"gmail_extra\"><br><div class=\"gmail_quote\">" + "On Fri, Nov 18, 2016 at 11:15 AM, foobar (Gerrit) noreply@gerrit.com" + "<span dir=\"ltr\">&lt;<a href=\"mailto:noreply@gerrit.com\" " + "target=\"_blank\">noreply@gerrit.com</a>&gt;</span> wrote:<br>" + "<blockquote class=\"gmail_quote\" " + "<p>foobar <strong>posted comments</strong> on this change.</p>" + "<p><a href=\"" + CHANGE_URL + "/1\" " + "target=\"_blank\">View Change</a></p><div>Patch Set 2: CR-1\n" + "\n" + "(3 comments)</div><ul><li>" + "<p>" + // File #1: test.txt
    "<a href=\"" + CHANGE_URL + "/1/gerrit-server/test.txt\">" + "File gerrit-server/<wbr>test.txt:</a></p>" + commentBlock(f1) + "<li><p>" + "<a href=\"" + CHANGE_URL + "/1/gerrit-server/test.txt\">" + "Patch Set #2:</a> </p>" + "<blockquote><pre>Some inline comment from Gerrit</pre>" + "</blockquote><p>Some comment on file 1</p>" + "</li>" + commentBlock(fc1) + "<li><p>" + "<a href=\"" + CHANGE_URL + "/1/gerrit-server/test.txt@2\">" + "Patch Set #2, Line 31:</a> </p>" + "<blockquote><pre>Some inline comment from Gerrit</pre>" + "</blockquote><p>Some text from original comment</p>" + "</li>" + commentBlock(c1) + "" + // Inline comment #2
    "<li><p>" + "<a href=\"" + CHANGE_URL + "/1/gerrit-server/test.txt@3\">" + "Patch Set #2, Line 47:</a> </p>" + "<blockquote><pre>Some comment posted on Gerrit</pre>" + "</blockquote><p>Some more comments from Gerrit</p>" + "</li>" + commentBlock(c2) + "<li><p>" + "<a href=\"" + CHANGE_URL + "/1/gerrit-server/test.txt@115\">" + "Patch Set #2, Line 115:</a> <code>some code</code></p>" + "<p>some comment</p></li></ul></li>" + "" + "<li><p>" + // File #2: test.txt
    "<a href=\"" + CHANGE_URL + "/1/gerrit-server/readme.txt\">" + "File gerrit-server/<wbr>readme.txt:</a></p>" + commentBlock(f2) + "<li><p>" + "<a href=\"" + CHANGE_URL + "/1/gerrit-server/readme.txt@3\">" + "Patch Set #2, Line 31:</a> </p>" + "<blockquote><pre>Some inline comment from Gerrit</pre>" + "</blockquote><p>Some text from original comment</p>" + "</li>" + commentBlock(c3) + "" + // Inline comment #2
    "</ul></li></ul>" + "" + // Footer
    "<p>To view, visit <a href=\"" + CHANGE_URL + "/1\">this change</a>. " + "To unsubscribe, visit <a href=\"https://someurl\">settings</a>." + "</p><p>Gerrit-MessageType: comment<br>" + "Footer omitted</p>" + "<div><div></div></div>" + "<p>Gerrit-HasComments: Yes</p></blockquote></div><br></div></div>";
    return email;
}
#method_after
@Override
protected String newHtmlBody(String changeMessage, String c1, String c2, String c3, String f1, String f2, String fc1) {
    String email = "" + "<div class=\"gmail_default\" dir=\"ltr\">" + (changeMessage != null ? changeMessage : "") + "<div class=\"gmail_extra\"><br><div class=\"gmail_quote\">" + "On Fri, Nov 18, 2016 at 11:15 AM, foobar (Gerrit) noreply@gerrit.com" + "<span dir=\"ltr\">&lt;<a href=\"mailto:noreply@gerrit.com\" " + "target=\"_blank\">noreply@gerrit.com</a>&gt;</span> wrote:<br>" + "<blockquote class=\"gmail_quote\" " + "<p>foobar <strong>posted comments</strong> on this change.</p>" + "<p><a href=\"" + CHANGE_URL + "/1\" " + "target=\"_blank\">View Change</a></p><div>Patch Set 2: CR-1\n" + "\n" + "(3 comments)</div><ul><li>" + "<p>" + // File #1: test.txt
    "<a href=\"" + CHANGE_URL + "/1/gerrit-server/test.txt\">" + "File gerrit-server/<wbr>test.txt:</a></p>" + commentBlock(f1) + "<li><p>" + "<a href=\"" + CHANGE_URL + "/1/gerrit-server/test.txt\">" + "Patch Set #2:</a> </p>" + "<blockquote><pre>Some inline comment from Gerrit</pre>" + "</blockquote><p>Some comment on file 1</p>" + "</li>" + commentBlock(fc1) + "<li><p>" + "<a href=\"" + CHANGE_URL + "/1/gerrit-server/test.txt@2\">" + "Patch Set #2, Line 31:</a> </p>" + "<blockquote><pre>Some inline comment from Gerrit</pre>" + "</blockquote><p>Some text from original comment</p>" + "</li>" + commentBlock(c1) + "" + // Inline comment #2
    "<li><p>" + "<a href=\"" + CHANGE_URL + "/1/gerrit-server/test.txt@3\">" + "Patch Set #2, Line 47:</a> </p>" + "<blockquote><pre>Some comment posted on Gerrit</pre>" + "</blockquote><p>Some more comments from Gerrit</p>" + "</li>" + commentBlock(c2) + "<li><p>" + "<a href=\"" + CHANGE_URL + "/1/gerrit-server/test.txt@115\">" + "Patch Set #2, Line 115:</a> <code>some code</code></p>" + "<p>some comment</p></li></ul></li>" + "" + "<li><p>" + // File #2: test.txt
    "<a href=\"" + CHANGE_URL + "/1/gerrit-server/readme.txt\">" + "File gerrit-server/<wbr>readme.txt:</a></p>" + commentBlock(f2) + "<li><p>" + "<a href=\"" + CHANGE_URL + "/1/gerrit-server/readme.txt@3\">" + "Patch Set #2, Line 31:</a> </p>" + "<blockquote><pre>Some inline comment from Gerrit</pre>" + "</blockquote><p>Some text from original comment</p>" + "</li>" + commentBlock(c3) + "" + // Inline comment #2
    "</ul></li></ul>" + "" + // Footer
    "<p>To view, visit <a href=\"" + CHANGE_URL + "/1\">this change</a>. " + "To unsubscribe, visit <a href=\"https://someurl\">settings</a>." + "</p><p>Gerrit-MessageType: comment<br>" + "Footer omitted</p>" + "<div><div></div></div>" + "<p>Gerrit-HasComments: Yes</p></blockquote></div><br></div></div>";
    return email;
}
#end_block

#method_before
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ResourceNotFoundException, IOException, ConfigInvalidException, PermissionBackendException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(ProjectUtil.stripGitSuffix(name));
    String parentName = MoreObjects.firstNonNull(Strings.emptyToNull(input.parent), allProjects.get());
    args.newParent = projectsCollection.get().parse(parentName, false).getNameKey();
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = normalizeBranchNames(input.branches);
    if (input.owners == null || input.owners.isEmpty()) {
        args.ownerIds = new ArrayList<>(projectOwnerGroups.create(args.getProject()).get());
    } else {
        args.ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            args.ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.newChangeForAllNotInTarget = MoreObjects.firstNonNull(input.createNewChangeForAllNotInTarget, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    ProjectState projectState = createProject(args);
    if (input.pluginConfigValues != null) {
        ConfigInput in = new ConfigInput();
        in.pluginConfigValues = input.pluginConfigValues;
        putConfig.get().apply(projectState, in);
    }
    return Response.created(json.format(projectState));
}
#method_after
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ResourceNotFoundException, IOException, ConfigInvalidException, PermissionBackendException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(ProjectUtil.stripGitSuffix(name));
    String parentName = MoreObjects.firstNonNull(Strings.emptyToNull(input.parent), allProjects.get());
    args.newParent = projectsCollection.get().parse(parentName, false).getNameKey();
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = normalizeBranchNames(input.branches);
    if (input.owners == null || input.owners.isEmpty()) {
        args.ownerIds = new ArrayList<>(projectOwnerGroups.create(args.getProject()).get());
    } else {
        args.ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            args.ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.newChangeForAllNotInTarget = MoreObjects.firstNonNull(input.createNewChangeForAllNotInTarget, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    Lock nameLock = lockManager.get().getLock(args.getProject());
    nameLock.lock();
    try {
        for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
            try {
                l.validateNewProject(args);
            } catch (ValidationException e) {
                throw new ResourceConflictException(e.getMessage(), e);
            }
        }
        ProjectState projectState = createProject(args);
        if (input.pluginConfigValues != null) {
            ConfigInput in = new ConfigInput();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(projectState, in);
        }
        return Response.created(json.format(projectState));
    } finally {
        nameLock.unlock();
    }
}
#end_block

#method_before
@Override
public String apply(AccountResource rsrc, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, ResourceConflictException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        throw new MethodNotAllowedException("realm does not allow editing username");
    }
    if (input == null) {
        input = new Input();
    }
    try {
        changeUserNameFactory.create(rsrc.getUser(), input.username).call();
    } catch (IllegalStateException e) {
        if (ChangeUserName.USERNAME_CANNOT_BE_CHANGED.equals(e.getMessage())) {
            throw new MethodNotAllowedException(e.getMessage());
        }
        throw e;
    } catch (InvalidUserNameException e) {
        throw new UnprocessableEntityException("invalid username");
    } catch (NameAlreadyUsedException e) {
        throw new ResourceConflictException("username already used");
    }
    return input.username;
}
#method_after
@Override
public String apply(AccountResource rsrc, UsernameInput input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, ResourceConflictException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        throw new MethodNotAllowedException("realm does not allow editing username");
    }
    if (input == null) {
        input = new UsernameInput();
    }
    try {
        changeUserNameFactory.create(rsrc.getUser(), input.username).call();
    } catch (IllegalStateException e) {
        if (ChangeUserName.USERNAME_CANNOT_BE_CHANGED.equals(e.getMessage())) {
            throw new MethodNotAllowedException(e.getMessage());
        }
        throw e;
    } catch (InvalidUserNameException e) {
        throw new UnprocessableEntityException("invalid username");
    } catch (NameAlreadyUsedException e) {
        throw new ResourceConflictException("username already used");
    }
    return input.username;
}
#end_block

#method_before
@Test
public void patchSetStates() throws Exception {
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementCurrentPatchSetFieldOnly(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.setPatchSetState(PatchSetState.DRAFT);
    update.putApproval("Code-Review", (short) 1);
    update.setChangeMessage("This is a message");
    update.putComment(Status.PUBLISHED, newComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name(), false));
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isTrue();
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getApprovals()).isNotEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isNotEmpty();
    assertThat(notes.getChangeMessages()).isNotEmpty();
    assertThat(notes.getComments()).isNotEmpty();
    // publish ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.PUBLISHED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isFalse();
    // delete ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.DELETED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1);
    assertThat(notes.getApprovals()).isEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isEmpty();
    assertThat(notes.getChangeMessages()).isEmpty();
    assertThat(notes.getComments()).isEmpty();
}
#method_after
@Test
public void patchSetStates() throws Exception {
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    incrementCurrentPatchSetFieldOnly(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.putApproval("Code-Review", (short) 1);
    update.setChangeMessage("This is a message");
    update.putComment(Status.PUBLISHED, newComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name(), false));
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getApprovals()).isNotEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isNotEmpty();
    assertThat(notes.getChangeMessages()).isNotEmpty();
    assertThat(notes.getComments()).isNotEmpty();
    // publish ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.PUBLISHED);
    update.commit();
    // delete ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.DELETED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1);
    assertThat(notes.getApprovals()).isEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isEmpty();
    assertThat(notes.getChangeMessages()).isEmpty();
    assertThat(notes.getComments()).isEmpty();
}
#end_block

#method_before
@Override
public BinaryResult apply(RevisionResource rsrc) throws OrmException, RestApiException, UpdateException, IOException, ConfigInvalidException, PermissionBackendException {
    if (Strings.isNullOrEmpty(format)) {
        throw new BadRequestException("format is not specified");
    }
    ArchiveFormat f = allowedFormats.extensions.get("." + format);
    if (f == null && format.equals("tgz")) {
        // Always allow tgz, even when the allowedFormats doesn't contain it.
        // Then we allow at least one format even if the list of allowed
        // formats is empty.
        f = ArchiveFormat.TGZ;
    }
    if (f == null) {
        throw new BadRequestException("unknown archive format");
    }
    Change change = rsrc.getChange();
    if (!change.getStatus().isOpen()) {
        throw new PreconditionFailedException("change is " + ChangeUtil.status(change));
    }
    ChangeControl control = rsrc.getControl();
    if (!control.getUser().isIdentifiedUser()) {
        throw new MethodNotAllowedException("Anonymous users cannot submit");
    }
    return getBundles(rsrc, f);
}
#method_after
@Override
public BinaryResult apply(RevisionResource rsrc) throws OrmException, RestApiException, UpdateException, IOException, ConfigInvalidException, PermissionBackendException {
    if (Strings.isNullOrEmpty(format)) {
        throw new BadRequestException("format is not specified");
    }
    ArchiveFormat f = allowedFormats.extensions.get("." + format);
    if (f == null && format.equals("tgz")) {
        // Always allow tgz, even when the allowedFormats doesn't contain it.
        // Then we allow at least one format even if the list of allowed
        // formats is empty.
        f = ArchiveFormat.TGZ;
    }
    if (f == null) {
        throw new BadRequestException("unknown archive format");
    }
    Change change = rsrc.getChange();
    if (!change.getStatus().isOpen()) {
        throw new PreconditionFailedException("change is " + ChangeUtil.status(change));
    }
    if (!rsrc.getUser().isIdentifiedUser()) {
        throw new MethodNotAllowedException("Anonymous users cannot submit");
    }
    return getBundles(rsrc, f);
}
#end_block

#method_before
private BinaryResult getBundles(RevisionResource rsrc, ArchiveFormat f) throws OrmException, RestApiException, UpdateException, IOException, ConfigInvalidException, PermissionBackendException {
    ReviewDb db = dbProvider.get();
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    // Returned BinaryResult takes ownership and handles closing.
    @SuppressWarnings("resource")
    MergeOp op = mergeOpProvider.get();
    try {
        op.merge(db, change, caller, false, new SubmitInput(), true);
        BinaryResult bin = new SubmitPreviewResult(op, f, maxBundleSize);
        bin.disableGzip().setContentType(f.getMimeType()).setAttachmentName("submit-preview-" + change.getChangeId() + "." + format);
        return bin;
    } catch (OrmException | RestApiException | UpdateException | IOException | ConfigInvalidException | RuntimeException | PermissionBackendException e) {
        op.close();
        throw e;
    }
}
#method_after
private BinaryResult getBundles(RevisionResource rsrc, ArchiveFormat f) throws OrmException, RestApiException, UpdateException, IOException, ConfigInvalidException, PermissionBackendException {
    ReviewDb db = dbProvider.get();
    IdentifiedUser caller = rsrc.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    // Returned BinaryResult takes ownership and handles closing.
    @SuppressWarnings("resource")
    MergeOp op = mergeOpProvider.get();
    try {
        op.merge(db, change, caller, false, new SubmitInput(), true);
        BinaryResult bin = new SubmitPreviewResult(op, f, maxBundleSize);
        bin.disableGzip().setContentType(f.getMimeType()).setAttachmentName("submit-preview-" + change.getChangeId() + "." + format);
        return bin;
    } catch (OrmException | RestApiException | UpdateException | IOException | ConfigInvalidException | RuntimeException | PermissionBackendException e) {
        op.close();
        throw e;
    }
}
#end_block

#method_before
@Override
public ChangeUpdate getUpdate(PatchSet.Id psId) {
    ChangeUpdate u = updates.get(psId);
    if (u == null) {
        u = changeUpdateFactory.create(ctl, when);
        if (newChanges.containsKey(ctl.getId())) {
            u.setAllowWriteToNewRef(true);
        }
        u.setPatchSetId(psId);
        updates.put(psId, u);
    }
    return u;
}
#method_after
@Override
public ChangeUpdate getUpdate(PatchSet.Id psId) {
    ChangeUpdate u = updates.get(psId);
    if (u == null) {
        u = changeUpdateFactory.create(notes, user, when);
        if (newChanges.containsKey(notes.getChangeId())) {
            u.setAllowWriteToNewRef(true);
        }
        u.setPatchSetId(psId);
        updates.put(psId, u);
    }
    return u;
}
#end_block

#method_before
private ChangeContextImpl newChangeContext(ReviewDb db, Repository repo, RevWalk rw, Change.Id id) throws OrmException {
    Change c = newChanges.get(id);
    boolean isNew = c != null;
    if (isNew) {
        // New change: populate noteDbState.
        checkState(c.getNoteDbState() == null, "noteDbState should not be filled in by callers");
        if (notesMigration.changePrimaryStorage() == PrimaryStorage.NOTE_DB) {
            c.setNoteDbState(NoteDbChangeState.NOTE_DB_PRIMARY_STATE);
        }
    } else {
        // Existing change.
        c = ChangeNotes.readOneReviewDbChange(db, id);
        if (c == null) {
            // Not in ReviewDb, but new changes are created with default primary
            // storage as NOTE_DB, so we can assume that a missing change is
            // NoteDb primary. Pass a synthetic change into ChangeNotes.Factory,
            // which lets ChangeNotes take care of the existence check.
            // 
            // TODO(dborowitz): This assumption is potentially risky, because
            // it means once we turn this option on and start creating changes
            // without writing anything to ReviewDb, we can't turn this option
            // back off without making those changes inaccessible. The problem
            // is we have no way of distinguishing a change that only exists in
            // NoteDb because it only ever existed in NoteDb, from a change that
            // only exists in NoteDb because it used to exist in ReviewDb and
            // deleting from ReviewDb succeeded but deleting from NoteDb failed.
            // 
            // TODO(dborowitz): We actually still have that problem anyway. Maybe
            // we need a cutoff timestamp? Or maybe we need to start leaving
            // tombstones in ReviewDb?
            c = ChangeNotes.Factory.newNoteDbOnlyChange(project, id);
        }
        NoteDbChangeState.checkNotReadOnly(c, skewMs);
    }
    ChangeNotes notes = changeNotesFactory.createForBatchUpdate(c, !isNew);
    ChangeControl ctl = changeControlFactory.controlFor(notes, user);
    return new ChangeContextImpl(ctl, new BatchUpdateReviewDb(db), repo, rw);
}
#method_after
private ChangeContextImpl newChangeContext(ReviewDb db, Repository repo, RevWalk rw, Change.Id id) throws OrmException {
    Change c = newChanges.get(id);
    boolean isNew = c != null;
    if (isNew) {
        // New change: populate noteDbState.
        checkState(c.getNoteDbState() == null, "noteDbState should not be filled in by callers");
        if (notesMigration.changePrimaryStorage() == PrimaryStorage.NOTE_DB) {
            c.setNoteDbState(NoteDbChangeState.NOTE_DB_PRIMARY_STATE);
        }
    } else {
        // Existing change.
        c = ChangeNotes.readOneReviewDbChange(db, id);
        if (c == null) {
            // Not in ReviewDb, but new changes are created with default primary
            // storage as NOTE_DB, so we can assume that a missing change is
            // NoteDb primary. Pass a synthetic change into ChangeNotes.Factory,
            // which lets ChangeNotes take care of the existence check.
            // 
            // TODO(dborowitz): This assumption is potentially risky, because
            // it means once we turn this option on and start creating changes
            // without writing anything to ReviewDb, we can't turn this option
            // back off without making those changes inaccessible. The problem
            // is we have no way of distinguishing a change that only exists in
            // NoteDb because it only ever existed in NoteDb, from a change that
            // only exists in NoteDb because it used to exist in ReviewDb and
            // deleting from ReviewDb succeeded but deleting from NoteDb failed.
            // 
            // TODO(dborowitz): We actually still have that problem anyway. Maybe
            // we need a cutoff timestamp? Or maybe we need to start leaving
            // tombstones in ReviewDb?
            c = ChangeNotes.Factory.newNoteDbOnlyChange(project, id);
        }
        NoteDbChangeState.checkNotReadOnly(c, skewMs);
    }
    ChangeNotes notes = changeNotesFactory.createForBatchUpdate(c, !isNew);
    return new ChangeContextImpl(notes, new BatchUpdateReviewDb(db), repo, rw);
}
#end_block

#method_before
private ChangeAttribute buildChangeAttribute(ChangeData d, Map<Project.NameKey, Repository> repos, Map<Project.NameKey, RevWalk> revWalks) throws OrmException, IOException {
    LabelTypes labelTypes = d.getLabelTypes();
    ChangeAttribute c = eventFactory.asChangeAttribute(db, d.change());
    eventFactory.extend(c, d.change());
    if (!trackingFooters.isEmpty()) {
        eventFactory.addTrackingIds(c, d.trackingFooters());
    }
    if (includeAllReviewers) {
        eventFactory.addAllReviewers(db, c, d.notes());
    }
    if (includeSubmitRecords) {
        eventFactory.addSubmitRecords(c, new SubmitRuleEvaluator(accountCache, accounts, emails, d).setAllowClosed(true).setAllowDraft(true).evaluate());
    }
    if (includeCommitMessage) {
        eventFactory.addCommitMessage(c, d.commitMessage());
    }
    RevWalk rw = null;
    if (includePatchSets || includeCurrentPatchSet || includeDependencies) {
        Project.NameKey p = d.change().getProject();
        rw = revWalks.get(p);
        // Cache and reuse repos and revwalks.
        if (rw == null) {
            Repository repo = repoManager.openRepository(p);
            checkState(repos.put(p, repo) == null);
            rw = new RevWalk(repo);
            revWalks.put(p, rw);
        }
    }
    if (includePatchSets) {
        eventFactory.addPatchSets(db, rw, c, d.visiblePatchSets(), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
    }
    if (includeCurrentPatchSet) {
        PatchSet current = d.currentPatchSet();
        ChangeControl cc = d.changeControl().forUser(user);
        if (current != null && cc.isPatchVisible(current, d.db())) {
            c.currentPatchSet = eventFactory.asPatchSetAttribute(db, rw, d.change(), current);
            eventFactory.addApprovals(c.currentPatchSet, d.currentApprovals(), labelTypes);
            if (includeFiles) {
                eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(), d.currentPatchSet());
            }
            if (includeComments) {
                eventFactory.addPatchSetComments(c.currentPatchSet, d.publishedComments());
            }
        }
    }
    if (includeComments) {
        eventFactory.addComments(c, d.messages());
        if (includePatchSets) {
            eventFactory.addPatchSets(db, rw, c, d.visiblePatchSets(), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
            for (PatchSetAttribute attribute : c.patchSets) {
                eventFactory.addPatchSetComments(attribute, d.publishedComments());
            }
        }
    }
    if (includeDependencies) {
        eventFactory.addDependencies(rw, c, d.change(), d.currentPatchSet());
    }
    c.plugins = queryProcessor.create(d);
    return c;
}
#method_after
private ChangeAttribute buildChangeAttribute(ChangeData d, Map<Project.NameKey, Repository> repos, Map<Project.NameKey, RevWalk> revWalks) throws OrmException, IOException {
    LabelTypes labelTypes = d.getLabelTypes();
    ChangeAttribute c = eventFactory.asChangeAttribute(db, d.change());
    eventFactory.extend(c, d.change());
    if (!trackingFooters.isEmpty()) {
        eventFactory.addTrackingIds(c, d.trackingFooters());
    }
    if (includeAllReviewers) {
        eventFactory.addAllReviewers(db, c, d.notes());
    }
    if (includeSubmitRecords) {
        eventFactory.addSubmitRecords(c, submitRuleEvaluatorFactory.create(user, d).setAllowClosed(true).evaluate());
    }
    if (includeCommitMessage) {
        eventFactory.addCommitMessage(c, d.commitMessage());
    }
    RevWalk rw = null;
    if (includePatchSets || includeCurrentPatchSet || includeDependencies) {
        Project.NameKey p = d.change().getProject();
        rw = revWalks.get(p);
        // Cache and reuse repos and revwalks.
        if (rw == null) {
            Repository repo = repoManager.openRepository(p);
            checkState(repos.put(p, repo) == null);
            rw = new RevWalk(repo);
            revWalks.put(p, rw);
        }
    }
    if (includePatchSets) {
        eventFactory.addPatchSets(db, rw, c, d.patchSets(), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
    }
    if (includeCurrentPatchSet) {
        PatchSet current = d.currentPatchSet();
        if (current != null) {
            c.currentPatchSet = eventFactory.asPatchSetAttribute(db, rw, d.change(), current);
            eventFactory.addApprovals(c.currentPatchSet, d.currentApprovals(), labelTypes);
            if (includeFiles) {
                eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(), d.currentPatchSet());
            }
            if (includeComments) {
                eventFactory.addPatchSetComments(c.currentPatchSet, d.publishedComments());
            }
        }
    }
    if (includeComments) {
        eventFactory.addComments(c, d.messages());
        if (includePatchSets) {
            eventFactory.addPatchSets(db, rw, c, d.patchSets(), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
            for (PatchSetAttribute attribute : c.patchSets) {
                eventFactory.addPatchSetComments(attribute, d.publishedComments());
            }
        }
    }
    if (includeDependencies) {
        eventFactory.addDependencies(rw, c, d.change(), d.currentPatchSet());
    }
    c.plugins = queryProcessor.create(d);
    return c;
}
#end_block

#method_before
private void showField(String field, Object value, int depth) {
    final int spacesDepthRatio = 2;
    String indent = indent(depth * spacesDepthRatio);
    out.print(indent);
    out.print(field);
    out.print(':');
    if (value instanceof String && ((String) value).contains("\n")) {
        out.print(' ');
        // Idention for multi-line text is
        // current depth indetion + length of field + length of ": "
        indent = indent(indent.length() + field.length() + spacesDepthRatio);
        out.print(((String) value).replaceAll("\n", "\n" + indent).trim());
        out.print('\n');
    } else if (value instanceof Long && isDateField(field)) {
        out.print(' ');
        out.print(dtf.print(((Long) value) * 1000L));
        out.print('\n');
    } else if (isPrimitive(value)) {
        out.print(' ');
        out.print(value);
        out.print('\n');
    } else if (value instanceof Collection) {
        out.print('\n');
        boolean firstElement = true;
        for (Object thing : ((Collection<?>) value)) {
            // 
            if (firstElement) {
                firstElement = false;
            } else {
                out.print(indent);
                out.print(field);
                out.print(":\n");
            }
            if (isPrimitive(thing)) {
                out.print(' ');
                out.print(value);
                out.print('\n');
            } else {
                showText(thing, depth + 1);
            }
        }
    } else {
        out.print('\n');
        showText(value, depth + 1);
    }
}
#method_after
private void showField(String field, Object value, int depth) {
    final int spacesDepthRatio = 2;
    String indent = indent(depth * spacesDepthRatio);
    out.print(indent);
    out.print(field);
    out.print(':');
    if (value instanceof String && ((String) value).contains("\n")) {
        out.print(' ');
        // Idention for multi-line text is
        // current depth indetion + length of field + length of ": "
        indent = indent(indent.length() + field.length() + spacesDepthRatio);
        out.print(((String) value).replaceAll("\n", "\n" + indent).trim());
        out.print('\n');
    } else if (value instanceof Long && isDateField(field)) {
        out.print(' ');
        out.print(dtf.format(Instant.ofEpochSecond((Long) value)));
        out.print('\n');
    } else if (isPrimitive(value)) {
        out.print(' ');
        out.print(value);
        out.print('\n');
    } else if (value instanceof Collection) {
        out.print('\n');
        boolean firstElement = true;
        for (Object thing : ((Collection<?>) value)) {
            // 
            if (firstElement) {
                firstElement = false;
            } else {
                out.print(indent);
                out.print(field);
                out.print(":\n");
            }
            if (isPrimitive(thing)) {
                out.print(' ');
                out.print(value);
                out.print('\n');
            } else {
                showText(thing, depth + 1);
            }
        }
    } else {
        out.print('\n');
        showText(value, depth + 1);
    }
}
#end_block

#method_before
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, MergePatchSetInput in) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException {
    rsrc.permissions().database(db).check(ChangePermission.ADD_PATCH_SET);
    MergeInput merge = in.merge;
    if (merge == null || Strings.isNullOrEmpty(merge.source)) {
        throw new BadRequestException("merge.source must be non-empty");
    }
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    ProjectState projectState = projectCache.checkedGet(rsrc.getProject());
    Change change = rsrc.getChange();
    Project.NameKey project = change.getProject();
    Branch.NameKey dest = change.getDest();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        RevCommit sourceCommit = MergeUtil.resolveCommit(git, rw, merge.source);
        if (!commits.canRead(projectState, git, sourceCommit)) {
            throw new ResourceNotFoundException("cannot find source commit: " + merge.source + " to merge.");
        }
        RevCommit currentPsCommit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        RevCommit newCommit = createMergeCommit(in, projectState, dest, git, oi, rw, currentPsCommit, sourceCommit, author, ObjectId.fromString(change.getKey().get().substring(1)));
        PatchSet.Id nextPsId = ChangeUtil.nextPatchSetId(ps.getId());
        PatchSetInserter psInserter = patchSetInserterFactory.create(rsrc.getNotes(), nextPsId, newCommit);
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.addOp(rsrc.getId(), psInserter.setMessage("Uploaded patch set " + nextPsId.get() + ".").setDraft(ps.isDraft()).setNotify(NotifyHandling.NONE).setCheckAddPatchSetPermission(false));
            bu.execute();
        }
        ChangeJson json = jsonFactory.create(ListChangesOption.CURRENT_REVISION);
        return Response.ok(json.format(psInserter.getChange()));
    }
}
#method_after
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, MergePatchSetInput in) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException {
    rsrc.permissions().database(db).check(ChangePermission.ADD_PATCH_SET);
    MergeInput merge = in.merge;
    if (merge == null || Strings.isNullOrEmpty(merge.source)) {
        throw new BadRequestException("merge.source must be non-empty");
    }
    in.baseChange = Strings.nullToEmpty(in.baseChange).trim();
    PatchSet ps = psUtil.current(db.get(), rsrc.getNotes());
    ProjectState projectState = projectCache.checkedGet(rsrc.getProject());
    Change change = rsrc.getChange();
    Project.NameKey project = change.getProject();
    Branch.NameKey dest = change.getDest();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        RevCommit sourceCommit = MergeUtil.resolveCommit(git, rw, merge.source);
        if (!commits.canRead(projectState, git, sourceCommit)) {
            throw new ResourceNotFoundException("cannot find source commit: " + merge.source + " to merge.");
        }
        RevCommit currentPsCommit;
        List<String> groups = null;
        if (!in.inheritParent && !in.baseChange.isEmpty()) {
            PatchSet basePS = findBasePatchSet(in.baseChange);
            currentPsCommit = rw.parseCommit(ObjectId.fromString(basePS.getRevision().get()));
            groups = basePS.getGroups();
        } else {
            currentPsCommit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        }
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        RevCommit newCommit = createMergeCommit(in, projectState, dest, git, oi, rw, currentPsCommit, sourceCommit, author, ObjectId.fromString(change.getKey().get().substring(1)));
        PatchSet.Id nextPsId = ChangeUtil.nextPatchSetId(ps.getId());
        PatchSetInserter psInserter = patchSetInserterFactory.create(rsrc.getNotes(), nextPsId, newCommit);
        try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
            bu.setRepository(git, rw, oi);
            psInserter.setMessage("Uploaded patch set " + nextPsId.get() + ".").setNotify(NotifyHandling.NONE).setCheckAddPatchSetPermission(false).setNotify(NotifyHandling.NONE);
            if (groups != null) {
                psInserter.setGroups(groups);
            }
            bu.addOp(rsrc.getId(), psInserter);
            bu.execute();
        }
        ChangeJson json = jsonFactory.create(ListChangesOption.CURRENT_REVISION);
        return Response.ok(json.format(psInserter.getChange()));
    }
}
#end_block

#method_before
private RevCommit createMergeCommit(MergePatchSetInput in, ProjectState projectState, Branch.NameKey dest, Repository git, ObjectInserter oi, RevWalk rw, RevCommit currentPsCommit, RevCommit sourceCommit, PersonIdent author, ObjectId changeId) throws ResourceNotFoundException, MergeIdenticalTreeException, MergeConflictException, IOException {
    ObjectId parentCommit;
    if (in.inheritParent) {
        // inherit first parent from previous patch set
        parentCommit = currentPsCommit.getParent(0);
    } else {
        // get the current branch tip of destination branch
        Ref destRef = git.getRefDatabase().exactRef(dest.get());
        if (destRef != null) {
            parentCommit = destRef.getObjectId();
        } else {
            throw new ResourceNotFoundException("cannot find destination branch");
        }
    }
    RevCommit mergeTip = rw.parseCommit(parentCommit);
    String commitMsg;
    if (Strings.emptyToNull(in.subject) != null) {
        commitMsg = ChangeIdUtil.insertId(in.subject, changeId);
    } else {
        // reuse previous patch set commit message
        commitMsg = currentPsCommit.getFullMessage();
    }
    String mergeStrategy = MoreObjects.firstNonNull(Strings.emptyToNull(in.merge.strategy), mergeUtilFactory.create(projectState).mergeStrategyName());
    return MergeUtil.createMergeCommit(oi, git.getConfig(), mergeTip, sourceCommit, mergeStrategy, author, commitMsg, rw);
}
#method_after
private RevCommit createMergeCommit(MergePatchSetInput in, ProjectState projectState, Branch.NameKey dest, Repository git, ObjectInserter oi, RevWalk rw, RevCommit currentPsCommit, RevCommit sourceCommit, PersonIdent author, ObjectId changeId) throws ResourceNotFoundException, MergeIdenticalTreeException, MergeConflictException, IOException {
    ObjectId parentCommit;
    if (in.inheritParent) {
        // inherit first parent from previous patch set
        parentCommit = currentPsCommit.getParent(0);
    } else if (!in.baseChange.isEmpty()) {
        parentCommit = currentPsCommit.getId();
    } else {
        // get the current branch tip of destination branch
        Ref destRef = git.getRefDatabase().exactRef(dest.get());
        if (destRef != null) {
            parentCommit = destRef.getObjectId();
        } else {
            throw new ResourceNotFoundException("cannot find destination branch");
        }
    }
    RevCommit mergeTip = rw.parseCommit(parentCommit);
    String commitMsg;
    if (Strings.emptyToNull(in.subject) != null) {
        commitMsg = ChangeIdUtil.insertId(in.subject, changeId);
    } else {
        // reuse previous patch set commit message
        commitMsg = currentPsCommit.getFullMessage();
    }
    String mergeStrategy = MoreObjects.firstNonNull(Strings.emptyToNull(in.merge.strategy), mergeUtilFactory.create(projectState).mergeStrategyName());
    return MergeUtil.createMergeCommit(oi, git.getConfig(), mergeTip, sourceCommit, mergeStrategy, author, commitMsg, rw);
}
#end_block

#method_before
@Override
public Response<DashboardInfo> apply(DashboardResource resource, Input input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, IOException, PermissionBackendException {
    if (input == null) {
        // Delete would set input to null.
        input = new Input();
    }
    input.id = Strings.emptyToNull(input.id);
    ProjectControl ctl = resource.getControl();
    if (!ctl.isOwner()) {
        throw new AuthException("not project owner");
    }
    DashboardResource target = null;
    if (input.id != null) {
        try {
            target = dashboards.parse(new ProjectResource(ctl), IdString.fromUrl(input.id));
        } catch (ResourceNotFoundException e) {
            throw new BadRequestException("dashboard " + input.id + " not found");
        } catch (ConfigInvalidException e) {
            throw new ResourceConflictException(e.getMessage());
        }
    }
    try (MetaDataUpdate md = updateFactory.create(ctl.getProject().getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        if (inherited) {
            project.setDefaultDashboard(input.id);
        } else {
            project.setLocalDefaultDashboard(input.id);
        }
        String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), input.id == null ? "Removed default dashboard.\n" : String.format("Changed default dashboard to %s.\n", input.id));
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(ctl.getUser().asIdentifiedUser());
        md.setMessage(msg);
        config.commit(md);
        cache.evict(ctl.getProject());
        if (target != null) {
            DashboardInfo info = get.get().apply(target);
            info.isDefault = true;
            return Response.ok(info);
        }
        return Response.none();
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(ctl.getProject().getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#method_after
@Override
public Response<DashboardInfo> apply(DashboardResource rsrc, SetDashboardInput input) throws RestApiException, IOException, PermissionBackendException {
    if (input == null) {
        // Delete would set input to null.
        input = new SetDashboardInput();
    }
    input.id = Strings.emptyToNull(input.id);
    permissionBackend.user(rsrc.getUser()).project(rsrc.getProjectState().getNameKey()).check(ProjectPermission.WRITE_CONFIG);
    DashboardResource target = null;
    if (input.id != null) {
        try {
            target = dashboards.parse(new ProjectResource(rsrc.getProjectState(), rsrc.getUser()), IdString.fromUrl(input.id));
        } catch (ResourceNotFoundException e) {
            throw new BadRequestException("dashboard " + input.id + " not found");
        } catch (ConfigInvalidException e) {
            throw new ResourceConflictException(e.getMessage());
        }
    }
    try (MetaDataUpdate md = updateFactory.create(rsrc.getProjectState().getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        if (inherited) {
            project.setDefaultDashboard(input.id);
        } else {
            project.setLocalDefaultDashboard(input.id);
        }
        String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), input.id == null ? "Removed default dashboard.\n" : String.format("Changed default dashboard to %s.\n", input.id));
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(rsrc.getUser().asIdentifiedUser());
        md.setMessage(msg);
        config.commit(md);
        cache.evict(rsrc.getProjectState().getProject());
        if (target != null) {
            DashboardInfo info = get.get().apply(target);
            info.isDefault = true;
            return Response.ok(info);
        }
        return Response.none();
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(rsrc.getProjectState().getProject().getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#end_block

#method_before
@Override
public Response<DashboardInfo> apply(ProjectResource resource, Input input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, IOException, PermissionBackendException {
    SetDefaultDashboard set = setDefault.get();
    set.inherited = inherited;
    return set.apply(DashboardResource.projectDefault(resource.getControl()), input);
}
#method_after
@Override
public Response<DashboardInfo> apply(ProjectResource resource, SetDashboardInput input) throws RestApiException, IOException, PermissionBackendException {
    SetDefaultDashboard set = setDefault.get();
    set.inherited = inherited;
    return set.apply(DashboardResource.projectDefault(resource.getProjectState(), resource.getUser()), input);
}
#end_block

#method_before
public String getName() {
    return control.getProject().getName();
}
#method_after
public String getName() {
    return projectState.getName();
}
#end_block

#method_before
public Project.NameKey getNameKey() {
    return control.getProject().getNameKey();
}
#method_after
public Project.NameKey getNameKey() {
    return projectState.getNameKey();
}
#end_block

#method_before
public ProjectState getProjectState() {
    return control.getProjectState();
}
#method_after
public ProjectState getProjectState() {
    return projectState;
}
#end_block

#method_before
public CurrentUser getUser() {
    return getControl().getUser();
}
#method_after
public CurrentUser getUser() {
    return user;
}
#end_block

#method_before
@Override
public boolean match(ChangeData object) throws OrmException {
    List<String> files = object.currentFilePaths();
    if (files != null) {
        return RegexListSearcher.ofStrings(getValue()).hasMatch(files);
    }
    // 
    return true;
}
#method_after
@Override
public boolean match(ChangeData object) throws OrmException {
    List<String> files;
    try {
        files = object.currentFilePaths();
    } catch (IOException e) {
        throw new OrmException(e);
    }
    return RegexListSearcher.ofStrings(getValue()).hasMatch(files);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Projects.class).to(ProjectsImpl.class);
    factory(BranchApiImpl.Factory.class);
    factory(TagApiImpl.Factory.class);
    factory(ProjectApiImpl.Factory.class);
    factory(ChildProjectApiImpl.Factory.class);
    factory(CommitApiImpl.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(Projects.class).to(ProjectsImpl.class);
    factory(BranchApiImpl.Factory.class);
    factory(TagApiImpl.Factory.class);
    factory(ProjectApiImpl.Factory.class);
    factory(ChildProjectApiImpl.Factory.class);
    factory(CommitApiImpl.Factory.class);
    factory(DashboardApiImpl.Factory.class);
}
#end_block

#method_before
@Override
public RestView<TopLevelResource> list() {
    return list.get().setFormat(OutputFormat.JSON);
}
#method_after
@Override
public RestView<TopLevelResource> list() {
    if (hasQuery) {
        return queryProjects.get();
    }
    return list.get().setFormat(OutputFormat.JSON);
}
#end_block

#method_before
@Nullable
private ProjectResource _parse(String id, boolean checkAccess) throws IOException, PermissionBackendException {
    if (id.endsWith(Constants.DOT_GIT_EXT)) {
        id = id.substring(0, id.length() - Constants.DOT_GIT_EXT.length());
    }
    Project.NameKey nameKey = new Project.NameKey(id);
    ProjectControl ctl;
    try {
        ctl = controlFactory.controlFor(nameKey, user.get());
    } catch (NoSuchProjectException e) {
        return null;
    }
    if (checkAccess) {
        try {
            permissionBackend.user(user).project(nameKey).check(ProjectPermission.ACCESS);
        } catch (AuthException e) {
            // Pretend like not found on access denied.
            return null;
        }
    }
    return new ProjectResource(ctl);
}
#method_after
@Nullable
private ProjectResource _parse(String id, boolean checkAccess) throws IOException, PermissionBackendException {
    if (id.endsWith(Constants.DOT_GIT_EXT)) {
        id = id.substring(0, id.length() - Constants.DOT_GIT_EXT.length());
    }
    Project.NameKey nameKey = new Project.NameKey(id);
    ProjectState state = projectCache.checkedGet(nameKey);
    if (state == null) {
        return null;
    }
    if (checkAccess) {
        try {
            permissionBackend.user(user).project(nameKey).check(ProjectPermission.ACCESS);
        } catch (AuthException e) {
            // Pretend like not found on access denied.
            return null;
        }
    }
    return new ProjectResource(state, user.get());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public CreateProject create(TopLevelResource parent, IdString name) {
    return createProjectFactory.create(name.get());
}
#method_after
@Override
public CreateProject create(TopLevelResource parent, IdString name) {
    return createProjectFactory.create(name.get());
}
#end_block

#method_before
public static GroupOptionsInfo createOptions(GroupDescription.Basic group) {
    GroupOptionsInfo options = new GroupOptionsInfo();
    if (isInternalGroup(group) && ((GroupDescription.Internal) group).isVisibleToAll()) {
        options.visibleToAll = true;
    }
    return options;
}
#method_after
public static GroupOptionsInfo createOptions(GroupDescription.Basic group) {
    GroupOptionsInfo options = new GroupOptionsInfo();
    if (group instanceof GroupDescription.Internal && ((GroupDescription.Internal) group).isVisibleToAll()) {
        options.visibleToAll = true;
    }
    return options;
}
#end_block

#method_before
public GroupInfo format(GroupResource rsrc) throws OrmException {
    GroupInfo info = init(rsrc.getGroup());
    initMembersAndIncludes(rsrc, info);
    return info;
}
#method_after
public GroupInfo format(GroupResource rsrc) throws OrmException {
    return createGroupInfo(rsrc.getGroup(), rsrc::getControl);
}
#end_block

#method_before
public GroupInfo format(GroupDescription.Basic group) throws OrmException {
    GroupInfo info = init(group);
    if (options.contains(MEMBERS) || options.contains(INCLUDES)) {
        GroupResource rsrc = new GroupResource(groupControlFactory.controlFor(group));
        initMembersAndIncludes(rsrc, info);
    }
    return info;
}
#method_after
public GroupInfo format(GroupDescription.Basic group) throws OrmException {
    return createGroupInfo(group, Suppliers.memoize(() -> groupControlFactory.controlFor(group)));
}
#end_block

#method_before
@Override
public void publish() throws RestApiException {
    try {
        publish.apply(revision, new PublishDraftPatchSet.Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot publish draft patch set", e);
    }
}
#method_after
@Override
public void publish() throws RestApiException {
    throw new UnsupportedOperationException("draft workflow is discontinued");
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    try {
        deleteDraft.apply(revision, null);
    } catch (Exception e) {
        throw asRestApiException("Cannot delete draft ps", e);
    }
}
#method_after
@Override
public void delete() throws RestApiException {
    throw new UnsupportedOperationException("draft workflow is discontinued");
}
#end_block

#method_before
@Override
public void setReviewed(String path, boolean reviewed) throws RestApiException {
    try {
        RestModifyView<FileResource, Reviewed.Input> view;
        if (reviewed) {
            view = putReviewed;
        } else {
            view = deleteReviewed;
        }
        view.apply(files.parse(revision, IdString.fromDecoded(path)), new Reviewed.Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot update reviewed flag", e);
    }
}
#method_after
@Override
public void setReviewed(String path, boolean reviewed) throws RestApiException {
    try {
        RestModifyView<FileResource, Input> view;
        if (reviewed) {
            view = putReviewed;
        } else {
            view = deleteReviewed;
        }
        view.apply(files.parse(revision, IdString.fromDecoded(path)), new Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot update reviewed flag", e);
    }
}
#end_block

#method_before
@Override
public void description(String description) throws RestApiException {
    PutDescription.Input in = new PutDescription.Input();
    in.description = description;
    try {
        putDescription.apply(revision, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot set description", e);
    }
}
#method_after
@Override
public void description(String description) throws RestApiException {
    DescriptionInput in = new DescriptionInput();
    in.description = description;
    try {
        putDescription.apply(revision, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot set description", e);
    }
}
#end_block

#method_before
@Override
public MailMessage expectedMailMessage() {
    System.out.println("\uD83D\uDE1B test");
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114da7ae26e2eb053fe0c29c@google.com>").from(new Address("Jonathan Nieder (Gerrit)", "noreply-gerritcodereview-CtTy0igsBrnvL7dKoWEIEg@google.com")).addTo(new Address("ekempin", "ekempin@google.com")).textContent(textContent).subject("âme vulgaire").dateReceived(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC));
    return expect.build();
}
#method_after
@Override
public MailMessage expectedMailMessage() {
    System.out.println("\uD83D\uDE1B test");
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114da7ae26e2eb053fe0c29c@google.com>").from(new Address("Jonathan Nieder (Gerrit)", "noreply-gerritcodereview-CtTy0igsBrnvL7dKoWEIEg@google.com")).addTo(new Address("ekempin", "ekempin@google.com")).textContent(textContent).subject("âme vulgaire").dateReceived(LocalDateTime.of(2016, Month.OCTOBER, 25, 9, 11, 35).atOffset(ZoneOffset.UTC).toInstant());
    return expect.build();
}
#end_block

#method_before
@Override
public BinaryResult apply(FileResource rsrc) throws ResourceNotFoundException, IOException, BadRequestException, OrmException {
    String path = rsrc.getPatchKey().get();
    if (Patch.COMMIT_MSG.equals(path)) {
        String msg = getMessage(rsrc.getRevision().getChangeResource().getNotes());
        return BinaryResult.create(msg).setContentType(FileContentUtil.TEXT_X_GERRIT_COMMIT_MESSAGE).base64();
    } else if (Patch.MERGE_LIST.equals(path)) {
        byte[] mergeList = getMergeList(rsrc.getRevision().getChangeResource().getNotes());
        return BinaryResult.create(mergeList).setContentType(FileContentUtil.TEXT_X_GERRIT_MERGE_LIST).base64();
    }
    return fileContentUtil.getContent(rsrc.getRevision().getControl().getProjectControl().getProjectState(), ObjectId.fromString(rsrc.getRevision().getPatchSet().getRevision().get()), path, parent);
}
#method_after
@Override
public BinaryResult apply(FileResource rsrc) throws ResourceNotFoundException, IOException, BadRequestException, OrmException {
    String path = rsrc.getPatchKey().get();
    if (Patch.COMMIT_MSG.equals(path)) {
        String msg = getMessage(rsrc.getRevision().getChangeResource().getNotes());
        return BinaryResult.create(msg).setContentType(FileContentUtil.TEXT_X_GERRIT_COMMIT_MESSAGE).base64();
    } else if (Patch.MERGE_LIST.equals(path)) {
        byte[] mergeList = getMergeList(rsrc.getRevision().getChangeResource().getNotes());
        return BinaryResult.create(mergeList).setContentType(FileContentUtil.TEXT_X_GERRIT_MERGE_LIST).base64();
    }
    return fileContentUtil.getContent(projectCache.checkedGet(rsrc.getRevision().getProject()), ObjectId.fromString(rsrc.getRevision().getPatchSet().getRevision().get()), path, parent);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    correctBranch = refName.equals(change.getDest().get());
    if (!correctBranch) {
        return false;
    }
    if (patchSetProvider != null) {
        // Caller might have also arranged for construction of a new patch set
        // that is not present in the old notes so we can't use PatchSetUtil.
        patchSet = patchSetProvider.get();
    } else {
        patchSet = checkNotNull(psUtil.get(ctx.getDb(), ctx.getNotes(), psId), "patch set %s not found", psId);
    }
    info = getPatchSetInfo(ctx);
    ChangeUpdate update = ctx.getUpdate(psId);
    Change.Status status = change.getStatus();
    if (status == Change.Status.MERGED) {
        return true;
    }
    if (status.isOpen()) {
        change.setCurrentPatchSet(info);
        change.setStatus(Change.Status.MERGED);
        // we cannot reconstruct the submit records for when this change was
        // submitted, this is why we must fix the status
        update.fixStatus(Change.Status.MERGED);
        update.setCurrentPatchSet();
    }
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!refName.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (refName.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(refName));
        } else {
            msgBuf.append(refName);
        }
    }
    msgBuf.append(".");
    ChangeMessage msg = ChangeMessagesUtil.newMessage(psId, ctx.getUser(), ctx.getWhen(), msgBuf.toString(), ChangeMessagesUtil.TAG_MERGED);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    PatchSetApproval submitter = ApprovalsUtil.newApproval(change.currentPatchSetId(), ctx.getUser(), LabelId.legacySubmit(), 1, ctx.getWhen());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    correctBranch = refName.equals(change.getDest().get());
    if (!correctBranch) {
        return false;
    }
    if (patchSetProvider != null) {
        // Caller might have also arranged for construction of a new patch set
        // that is not present in the old notes so we can't use PatchSetUtil.
        patchSet = patchSetProvider.get();
    } else {
        patchSet = checkNotNull(psUtil.get(ctx.getDb(), ctx.getNotes(), psId), "patch set %s not found", psId);
    }
    info = getPatchSetInfo(ctx);
    ChangeUpdate update = ctx.getUpdate(psId);
    Change.Status status = change.getStatus();
    if (status == Change.Status.MERGED) {
        return true;
    }
    change.setCurrentPatchSet(info);
    change.setStatus(Change.Status.MERGED);
    // we cannot reconstruct the submit records for when this change was
    // submitted, this is why we must fix the status
    update.fixStatus(Change.Status.MERGED);
    update.setCurrentPatchSet();
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!refName.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (refName.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(refName));
        } else {
            msgBuf.append(refName);
        }
    }
    msgBuf.append(".");
    ChangeMessage msg = ChangeMessagesUtil.newMessage(psId, ctx.getUser(), ctx.getWhen(), msgBuf.toString(), ChangeMessagesUtil.TAG_MERGED);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    PatchSetApproval submitter = ApprovalsUtil.newApproval(change.currentPatchSetId(), ctx.getUser(), LabelId.legacySubmit(), 1, ctx.getWhen());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
    return true;
}
#end_block

#method_before
protected void init() throws EmailException {
    setupVelocityContext();
    setupSoyContext();
    smtpFromAddress = args.fromAddressGenerator.from(fromId);
    setHeader("Date", new Date());
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    setHeader("Message-ID", "");
    for (RecipientType recipientType : accountsToNotify.keySet()) {
        add(recipientType, accountsToNotify.get(recipientType));
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    textBody = new StringBuilder();
    htmlBody = new StringBuilder();
    if (fromId != null && args.fromAddressGenerator.isGenericAddress(fromId)) {
        appendText(getFromLine());
    }
}
#method_after
protected void init() throws EmailException {
    setupSoyContext();
    smtpFromAddress = args.fromAddressGenerator.from(fromId);
    setHeader("Date", new Date());
    headers.put("From", new EmailHeader.AddressList(smtpFromAddress));
    headers.put(HDR_TO, new EmailHeader.AddressList());
    headers.put(HDR_CC, new EmailHeader.AddressList());
    setHeader("Message-ID", "");
    for (RecipientType recipientType : accountsToNotify.keySet()) {
        add(recipientType, accountsToNotify.get(recipientType));
    }
    setHeader("X-Gerrit-MessageType", messageClass);
    textBody = new StringBuilder();
    htmlBody = new StringBuilder();
    if (fromId != null && args.fromAddressGenerator.isGenericAddress(fromId)) {
        appendText(getFromLine());
    }
}
#end_block

#method_before
protected String textTemplate(String name) throws EmailException {
    String velocityName = name + ".vm";
    Path filePath = args.site.mail_dir.resolve(velocityName);
    if (Files.isRegularFile(filePath)) {
        return velocifyFile(velocityName);
    }
    return soyTextTemplate(name);
}
#method_after
protected String textTemplate(String name) {
    return soyTemplate(name, SanitizedContent.ContentKind.TEXT);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public CreateEmail create(AccountResource parent, IdString email) {
    return createEmailFactory.create(email.get());
}
#method_after
@Override
public CreateEmail create(AccountResource parent, IdString email) {
    return createEmailFactory.create(email.get());
}
#end_block

#method_before
@Override
protected void configure() {
    factory(CmdLineParser.Factory.class);
    bind(OptionHandlers.class);
    registerOptionHandler(Account.Id.class, AccountIdHandler.class);
    registerOptionHandler(AccountGroup.Id.class, AccountGroupIdHandler.class);
    registerOptionHandler(AccountGroup.UUID.class, AccountGroupUUIDHandler.class);
    registerOptionHandler(Change.Id.class, ChangeIdHandler.class);
    registerOptionHandler(ObjectId.class, ObjectIdHandler.class);
    registerOptionHandler(PatchSet.Id.class, PatchSetIdHandler.class);
    registerOptionHandler(ProjectControl.class, ProjectControlHandler.class);
    registerOptionHandler(SocketAddress.class, SocketAddressHandler.class);
    registerOptionHandler(Timestamp.class, TimestampHandler.class);
}
#method_after
@Override
protected void configure() {
    factory(CmdLineParser.Factory.class);
    bind(OptionHandlers.class);
    registerOptionHandler(Account.Id.class, AccountIdHandler.class);
    registerOptionHandler(AccountGroup.Id.class, AccountGroupIdHandler.class);
    registerOptionHandler(AccountGroup.UUID.class, AccountGroupUUIDHandler.class);
    registerOptionHandler(Change.Id.class, ChangeIdHandler.class);
    registerOptionHandler(ObjectId.class, ObjectIdHandler.class);
    registerOptionHandler(PatchSet.Id.class, PatchSetIdHandler.class);
    registerOptionHandler(ProjectState.class, ProjectHandler.class);
    registerOptionHandler(SocketAddress.class, SocketAddressHandler.class);
    registerOptionHandler(Timestamp.class, TimestampHandler.class);
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    Set<ExternalId> toAdd = new HashSet<>();
    try (Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
        ResultSet rs = stmt.executeQuery("SELECT " + "account_id, " + "email_address, " + "password, " + "external_id " + "FROM account_external_ids")) {
        while (rs.next()) {
            Account.Id accountId = new Account.Id(rs.getInt(1));
            String email = rs.getString(2);
            String password = rs.getString(3);
            String externalId = rs.getString(4);
            toAdd.add(ExternalId.create(ExternalId.Key.parse(externalId), accountId, email, password));
        }
    }
    try {
        try (Repository repo = repoManager.openRepository(allUsersName);
            RevWalk rw = new RevWalk(repo);
            ObjectInserter ins = repo.newObjectInserter()) {
            ObjectId rev = ExternalIdReader.readRevision(repo);
            NoteMap noteMap = ExternalIdReader.readNoteMap(rw, rev);
            for (ExternalId extId : toAdd) {
                ExternalIdsUpdate.upsert(rw, ins, noteMap, extId);
            }
            ExternalIdsUpdate.commit(repo, rw, ins, rev, noteMap, COMMIT_MSG, serverIdent, serverIdent);
        }
    } catch (IOException | ConfigInvalidException e) {
        throw new OrmException("Failed to migrate external IDs to NoteDb", e);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    Set<ExternalId> toAdd = new HashSet<>();
    try (Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
        ResultSet rs = stmt.executeQuery("SELECT " + "account_id, " + "email_address, " + "password, " + "external_id " + "FROM account_external_ids")) {
        while (rs.next()) {
            Account.Id accountId = new Account.Id(rs.getInt(1));
            String email = rs.getString(2);
            String password = rs.getString(3);
            String externalId = rs.getString(4);
            toAdd.add(ExternalId.create(ExternalId.Key.parse(externalId), accountId, email, password));
        }
    }
    try {
        try (Repository repo = repoManager.openRepository(allUsersName);
            RevWalk rw = new RevWalk(repo);
            ObjectInserter ins = repo.newObjectInserter()) {
            ObjectId rev = ExternalIdReader.readRevision(repo);
            NoteMap noteMap = ExternalIdReader.readNoteMap(rw, rev);
            for (ExternalId extId : toAdd) {
                ExternalIdsUpdate.upsert(rw, ins, noteMap, extId);
            }
            ExternalIdsUpdate.commit(allUsersName, repo, rw, ins, rev, noteMap, COMMIT_MSG, serverIdent, serverIdent, null, GitReferenceUpdated.DISABLED);
        }
    } catch (IOException | ConfigInvalidException e) {
        throw new OrmException("Failed to migrate external IDs to NoteDb", e);
    }
}
#end_block

#method_before
public Response<?> deactivate(IdentifiedUser user) throws RestApiException, IOException, ConfigInvalidException {
    AtomicBoolean alreadyInactive = new AtomicBoolean(false);
    Account account = accountsUpdate.create().update(user.getAccountId(), a -> {
        if (!a.isActive()) {
            alreadyInactive.set(true);
        } else {
            a.setActive(false);
        }
    });
    if (account == null) {
        throw new ResourceNotFoundException("account not found");
    }
    if (alreadyInactive.get()) {
        throw new ResourceConflictException("account not active");
    }
    return Response.none();
}
#method_after
public Response<?> deactivate(Account.Id accountId) throws RestApiException, IOException, ConfigInvalidException {
    AtomicBoolean alreadyInactive = new AtomicBoolean(false);
    Account account = accountsUpdate.create().update(accountId, a -> {
        if (!a.isActive()) {
            alreadyInactive.set(true);
        } else {
            a.setActive(false);
        }
    });
    if (account == null) {
        throw new ResourceNotFoundException("account not found");
    }
    if (alreadyInactive.get()) {
        throw new ResourceConflictException("account not active");
    }
    return Response.none();
}
#end_block

#method_before
public Response<String> activate(IdentifiedUser user) throws ResourceNotFoundException, IOException, ConfigInvalidException {
    AtomicBoolean alreadyActive = new AtomicBoolean(false);
    Account account = accountsUpdate.create().update(user.getAccountId(), a -> {
        if (a.isActive()) {
            alreadyActive.set(true);
        } else {
            a.setActive(true);
        }
    });
    if (account == null) {
        throw new ResourceNotFoundException("account not found");
    }
    return alreadyActive.get() ? Response.ok("") : Response.created("");
}
#method_after
public Response<String> activate(Account.Id accountId) throws ResourceNotFoundException, IOException, ConfigInvalidException {
    AtomicBoolean alreadyActive = new AtomicBoolean(false);
    Account account = accountsUpdate.create().update(accountId, a -> {
        if (a.isActive()) {
            alreadyActive.set(true);
        } else {
            a.setActive(true);
        }
    });
    if (account == null) {
        throw new ResourceNotFoundException("account not found");
    }
    return alreadyActive.get() ? Response.ok("") : Response.created("");
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, UnprocessableEntityException {
    changeControl = ctx.getControl();
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (patchSet == null) {
        throw new OrmException("patch set not found: " + psId);
    }
    changeMessage = generateChangeMessage(ctx);
    changeMessagesUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    comments = new ArrayList<>();
    for (MailComment c : parsedComments) {
        if (c.type == MailComment.CommentType.CHANGE_MESSAGE) {
            continue;
        }
        comments.add(persistentCommentFromMailComment(ctx, c, targetPatchSetForComment(ctx, c, patchSet)));
    }
    commentsUtil.putComments(ctx.getDb(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), Status.PUBLISHED, comments);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, UnprocessableEntityException {
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    notes = ctx.getNotes();
    if (patchSet == null) {
        throw new OrmException("patch set not found: " + psId);
    }
    changeMessage = generateChangeMessage(ctx);
    changeMessagesUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    comments = new ArrayList<>();
    for (MailComment c : parsedComments) {
        if (c.type == MailComment.CommentType.CHANGE_MESSAGE) {
            continue;
        }
        comments.add(persistentCommentFromMailComment(ctx, c, targetPatchSetForComment(ctx, c, patchSet)));
    }
    commentsUtil.putComments(ctx.getDb(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), Status.PUBLISHED, comments);
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws Exception {
    String patchSetComment = null;
    if (parsedComments.get(0).type == MailComment.CommentType.CHANGE_MESSAGE) {
        patchSetComment = parsedComments.get(0).message;
    }
    // Send email notifications
    outgoingMailFactory.create(NotifyHandling.ALL, ArrayListMultimap.create(), changeControl.getNotes(), patchSet, ctx.getUser().asIdentifiedUser(), changeMessage, comments, patchSetComment, ImmutableList.of()).sendAsync();
    // Get previous approvals from this user
    Map<String, Short> approvals = new HashMap<>();
    approvalsUtil.byPatchSetUser(ctx.getDb(), changeControl.getNotes(), changeControl.getUser(), psId, ctx.getAccountId(), ctx.getRevWalk(), ctx.getRepoView().getConfig()).forEach(a -> approvals.put(a.getLabel(), a.getValue()));
    // Fire Gerrit event. Note that approvals can't be granted via email, so old and new approvals
    // are always the same here.
    commentAdded.fire(changeControl.getChange(), patchSet, ctx.getAccount(), changeMessage.getMessage(), approvals, approvals, ctx.getWhen());
}
#method_after
@Override
public void postUpdate(Context ctx) throws Exception {
    String patchSetComment = null;
    if (parsedComments.get(0).type == MailComment.CommentType.CHANGE_MESSAGE) {
        patchSetComment = parsedComments.get(0).message;
    }
    // Send email notifications
    outgoingMailFactory.create(NotifyHandling.ALL, ArrayListMultimap.create(), notes, patchSet, ctx.getUser().asIdentifiedUser(), changeMessage, comments, patchSetComment, ImmutableList.of()).sendAsync();
    // Get previous approvals from this user
    Map<String, Short> approvals = new HashMap<>();
    approvalsUtil.byPatchSetUser(ctx.getDb(), notes, ctx.getUser(), psId, ctx.getAccountId(), ctx.getRevWalk(), ctx.getRepoView().getConfig()).forEach(a -> approvals.put(a.getLabel(), a.getValue()));
    // Fire Gerrit event. Note that approvals can't be granted via email, so old and new approvals
    // are always the same here.
    commentAdded.fire(notes.getChange(), patchSet, ctx.getAccount(), changeMessage.getMessage(), approvals, approvals, ctx.getWhen());
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, AccountGroup.Id.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByIdLoader.class);
            cache(BYNAME_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByNameLoader.class);
            cache(BYUUID_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByUUIDLoader.class);
            bind(GroupCacheImpl.class);
            bind(GroupCache.class).to(GroupCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, AccountGroup.Id.class, new TypeLiteral<Optional<InternalGroup>>() {
            }).loader(ByIdLoader.class);
            cache(BYNAME_NAME, String.class, new TypeLiteral<Optional<InternalGroup>>() {
            }).loader(ByNameLoader.class);
            cache(BYUUID_NAME, String.class, new TypeLiteral<Optional<InternalGroup>>() {
            }).loader(ByUUIDLoader.class);
            bind(GroupCacheImpl.class);
            bind(GroupCache.class).to(GroupCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Override
public AccountGroup get(AccountGroup.Id groupId) {
    try {
        Optional<AccountGroup> g = byId.get(groupId);
        return g.isPresent() ? g.get() : missing(groupId);
    } catch (ExecutionException e) {
        log.warn("Cannot load group " + groupId, e);
        return missing(groupId);
    }
}
#method_after
@Override
public Optional<InternalGroup> get(AccountGroup.Id groupId) {
    try {
        return byId.get(groupId);
    } catch (ExecutionException e) {
        log.warn("Cannot load group " + groupId, e);
        return Optional.empty();
    }
}
#end_block

#method_before
@Override
public void evict(AccountGroup group) throws IOException {
    if (group.getId() != null) {
        byId.invalidate(group.getId());
    }
    if (group.getNameKey() != null) {
        byName.invalidate(group.getNameKey().get());
    }
    if (group.getGroupUUID() != null) {
        byUUID.invalidate(group.getGroupUUID().get());
    }
    indexer.get().index(group.getGroupUUID());
}
#method_after
@Override
public void evict(AccountGroup.UUID groupUuid, AccountGroup.Id groupId, AccountGroup.NameKey groupName) throws IOException {
    if (groupId != null) {
        byId.invalidate(groupId);
    }
    if (groupName != null) {
        byName.invalidate(groupName.get());
    }
    if (groupUuid != null) {
        byUUID.invalidate(groupUuid.get());
    }
    indexer.get().index(groupUuid);
}
#end_block

#method_before
@Override
public void evictAfterRename(final AccountGroup.NameKey oldName, AccountGroup.NameKey newName) throws IOException {
    if (oldName != null) {
        byName.invalidate(oldName.get());
    }
    if (newName != null) {
        byName.invalidate(newName.get());
    }
    indexer.get().index(get(newName).getGroupUUID());
}
#method_after
@Override
public void evictAfterRename(AccountGroup.NameKey oldName) throws IOException {
    if (oldName != null) {
        byName.invalidate(oldName.get());
    }
}
#end_block

#method_before
@Override
public AccountGroup get(AccountGroup.NameKey name) {
    if (name == null) {
        return null;
    }
    try {
        return byName.get(name.get()).orElse(null);
    } catch (ExecutionException e) {
        log.warn(String.format("Cannot lookup group %s by name", name.get()), e);
        return null;
    }
}
#method_after
@Override
public Optional<InternalGroup> get(AccountGroup.NameKey name) {
    if (name == null) {
        return Optional.empty();
    }
    try {
        return byName.get(name.get());
    } catch (ExecutionException e) {
        log.warn(String.format("Cannot look up group %s by name", name.get()), e);
        return Optional.empty();
    }
}
#end_block

#method_before
@Override
public AccountGroup get(AccountGroup.UUID uuid) {
    if (uuid == null) {
        return null;
    }
    try {
        return byUUID.get(uuid.get()).orElse(null);
    } catch (ExecutionException e) {
        log.warn(String.format("Cannot lookup group %s by name", uuid.get()), e);
        return null;
    }
}
#method_after
@Override
public Optional<InternalGroup> get(AccountGroup.UUID groupUuid) {
    if (groupUuid == null) {
        return Optional.empty();
    }
    try {
        return byUUID.get(groupUuid.get());
    } catch (ExecutionException e) {
        log.warn(String.format("Cannot look up group %s by uuid", groupUuid.get()), e);
        return Optional.empty();
    }
}
#end_block

#method_before
@Override
public void onCreateGroup(AccountGroup.NameKey newGroupName) throws IOException {
    byName.invalidate(newGroupName.get());
    indexer.get().index(get(newGroupName).getGroupUUID());
}
#method_after
@Override
public void onCreateGroup(AccountGroup.UUID groupUuid) throws IOException {
    indexer.get().index(groupUuid);
}
#end_block

#method_before
@Override
public Optional<AccountGroup> load(AccountGroup.Id key) throws Exception {
    try (ReviewDb db = schema.open()) {
        return groups.getGroup(db, key);
    }
}
#method_after
@Override
public Optional<InternalGroup> load(AccountGroup.Id key) throws Exception {
    if (hasGroupIndex.getAsBoolean()) {
        return groupQueryProvider.get().byId(key);
    }
    try (ReviewDb db = schema.open()) {
        return groups.getGroup(db, key);
    }
}
#end_block

#method_before
@Override
public Optional<AccountGroup> load(String name) throws Exception {
    try (ReviewDb db = schema.open()) {
        return groups.getGroup(db, new AccountGroup.NameKey(name));
    }
}
#method_after
@Override
public Optional<InternalGroup> load(String name) throws Exception {
    return groupQueryProvider.get().byName(new AccountGroup.NameKey(name));
}
#end_block

#method_before
@Override
public Optional<AccountGroup> load(String uuid) throws Exception {
    try (ReviewDb db = schema.open()) {
        return groups.getGroup(db, new AccountGroup.UUID(uuid));
    }
}
#method_after
@Override
public Optional<InternalGroup> load(String uuid) throws Exception {
    try (ReviewDb db = schema.open()) {
        return groups.getGroup(db, new AccountGroup.UUID(uuid));
    }
}
#end_block

#method_before
private void ensureDeletable(ChangeContext ctx, Change.Id id, Collection<PatchSet> patchSets) throws ResourceConflictException, MethodNotAllowedException, IOException {
    Change.Status status = ctx.getChange().getStatus();
    if (status == Change.Status.MERGED) {
        throw new MethodNotAllowedException("Deleting merged change " + id + " is not allowed");
    }
    for (PatchSet patchSet : patchSets) {
        if (isPatchSetMerged(ctx, patchSet)) {
            throw new ResourceConflictException(String.format("Cannot delete change %s: patch set %s is already merged", id, patchSet.getPatchSetId()));
        }
    }
    if (status == Change.Status.DRAFT) {
        for (PatchSet ps : patchSets) {
            if (!ps.isDraft()) {
                throw new ResourceConflictException("Cannot delete draft change " + id + ": patch set " + ps.getPatchSetId() + " is not a draft");
            }
        }
    }
}
#method_after
private void ensureDeletable(ChangeContext ctx, Change.Id id, Collection<PatchSet> patchSets) throws ResourceConflictException, MethodNotAllowedException, IOException {
    Change.Status status = ctx.getChange().getStatus();
    if (status == Change.Status.MERGED) {
        throw new MethodNotAllowedException("Deleting merged change " + id + " is not allowed");
    }
    for (PatchSet patchSet : patchSets) {
        if (isPatchSetMerged(ctx, patchSet)) {
            throw new ResourceConflictException(String.format("Cannot delete change %s: patch set %s is already merged", id, patchSet.getPatchSetId()));
        }
    }
}
#end_block

#method_before
public Account find(ReviewDb db, String nameOrEmail) throws OrmException, IOException, ConfigInvalidException {
    Set<Account.Id> r = findAll(db, nameOrEmail);
    if (r.size() == 1) {
        return byId.get(r.iterator().next()).getAccount();
    }
    Account match = null;
    for (Account.Id id : r) {
        Account account = byId.get(id).getAccount();
        if (!account.isActive()) {
            continue;
        }
        if (match != null) {
            return null;
        }
        match = account;
    }
    return match;
}
#method_after
public Account find(String nameOrEmail) throws OrmException, IOException, ConfigInvalidException {
    Set<Account.Id> r = findAll(nameOrEmail);
    if (r.size() == 1) {
        return byId.get(r.iterator().next()).getAccount();
    }
    Account match = null;
    for (Account.Id id : r) {
        Account account = byId.get(id).getAccount();
        if (!account.isActive()) {
            continue;
        }
        if (match != null) {
            return null;
        }
        match = account;
    }
    return match;
}
#end_block

#method_before
public Set<Account.Id> findAll(ReviewDb db, String nameOrEmail) throws OrmException, IOException, ConfigInvalidException {
    Matcher m = Pattern.compile("^.* \\(([1-9][0-9]*)\\)$").matcher(nameOrEmail);
    if (m.matches()) {
        Account.Id id = Account.Id.parse(m.group(1));
        if (accounts.get(id) != null) {
            return Collections.singleton(id);
        }
        return Collections.emptySet();
    }
    if (nameOrEmail.matches("^[1-9][0-9]*$")) {
        Account.Id id = Account.Id.parse(nameOrEmail);
        if (accounts.get(id) != null) {
            return Collections.singleton(id);
        }
        return Collections.emptySet();
    }
    if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) {
        AccountState who = byId.getByUsername(nameOrEmail);
        if (who != null) {
            return Collections.singleton(who.getAccount().getId());
        }
    }
    return findAllByNameOrEmail(db, nameOrEmail);
}
#method_after
public Set<Account.Id> findAll(String nameOrEmail) throws OrmException, IOException, ConfigInvalidException {
    Matcher m = Pattern.compile("^.* \\(([1-9][0-9]*)\\)$").matcher(nameOrEmail);
    if (m.matches()) {
        Account.Id id = Account.Id.parse(m.group(1));
        if (accounts.get(id) != null) {
            return Collections.singleton(id);
        }
        return Collections.emptySet();
    }
    if (nameOrEmail.matches("^[1-9][0-9]*$")) {
        Account.Id id = Account.Id.parse(nameOrEmail);
        if (accounts.get(id) != null) {
            return Collections.singleton(id);
        }
        return Collections.emptySet();
    }
    if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) {
        AccountState who = byId.getByUsername(nameOrEmail);
        if (who != null) {
            return Collections.singleton(who.getAccount().getId());
        }
    }
    return findAllByNameOrEmail(nameOrEmail);
}
#end_block

#method_before
public Account findByNameOrEmail(ReviewDb db, String nameOrEmail) throws OrmException, IOException {
    Set<Account.Id> r = findAllByNameOrEmail(db, nameOrEmail);
    return r.size() == 1 ? byId.get(r.iterator().next()).getAccount() : null;
}
#method_after
public Account findByNameOrEmail(String nameOrEmail) throws OrmException, IOException {
    Set<Account.Id> r = findAllByNameOrEmail(nameOrEmail);
    return r.size() == 1 ? byId.get(r.iterator().next()).getAccount() : null;
}
#end_block

#method_before
public Set<Account.Id> findAllByNameOrEmail(ReviewDb db, String nameOrEmail) throws OrmException, IOException {
    int lt = nameOrEmail.indexOf('<');
    int gt = nameOrEmail.indexOf('>');
    if (lt >= 0 && gt > lt && nameOrEmail.contains("@")) {
        Set<Account.Id> ids = emails.getAccountFor(nameOrEmail.substring(lt + 1, gt));
        if (ids.isEmpty() || ids.size() == 1) {
            return ids;
        }
        // more than one match, try to return the best one
        String name = nameOrEmail.substring(0, lt - 1);
        Set<Account.Id> nameMatches = new HashSet<>();
        for (Account.Id id : ids) {
            Account a = byId.get(id).getAccount();
            if (name.equals(a.getFullName())) {
                nameMatches.add(id);
            }
        }
        return nameMatches.isEmpty() ? ids : nameMatches;
    }
    if (nameOrEmail.contains("@")) {
        return emails.getAccountFor(nameOrEmail);
    }
    Account.Id id = realm.lookup(nameOrEmail);
    if (id != null) {
        return Collections.singleton(id);
    }
    List<AccountState> m = accountQueryProvider.get().byFullName(nameOrEmail);
    if (m.size() == 1) {
        return Collections.singleton(m.get(0).getAccount().getId());
    }
    // and pray we come up with a reasonable result list.
    return accountQueryProvider.get().byDefault(nameOrEmail).stream().map(a -> a.getAccount().getId()).collect(toSet());
}
#method_after
public Set<Account.Id> findAllByNameOrEmail(String nameOrEmail) throws OrmException, IOException {
    int lt = nameOrEmail.indexOf('<');
    int gt = nameOrEmail.indexOf('>');
    if (lt >= 0 && gt > lt && nameOrEmail.contains("@")) {
        Set<Account.Id> ids = emails.getAccountFor(nameOrEmail.substring(lt + 1, gt));
        if (ids.isEmpty() || ids.size() == 1) {
            return ids;
        }
        // more than one match, try to return the best one
        String name = nameOrEmail.substring(0, lt - 1);
        Set<Account.Id> nameMatches = new HashSet<>();
        for (Account.Id id : ids) {
            Account a = byId.get(id).getAccount();
            if (name.equals(a.getFullName())) {
                nameMatches.add(id);
            }
        }
        return nameMatches.isEmpty() ? ids : nameMatches;
    }
    if (nameOrEmail.contains("@")) {
        return emails.getAccountFor(nameOrEmail);
    }
    Account.Id id = realm.lookup(nameOrEmail);
    if (id != null) {
        return Collections.singleton(id);
    }
    List<AccountState> m = accountQueryProvider.get().byFullName(nameOrEmail);
    if (m.size() == 1) {
        return Collections.singleton(m.get(0).getAccount().getId());
    }
    // and pray we come up with a reasonable result list.
    return accountQueryProvider.get().byDefault(nameOrEmail).stream().map(a -> a.getAccount().getId()).collect(toSet());
}
#end_block

#method_before
@Override
public Response<DiffInfo> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    DiffPreferencesInfo prefs = new DiffPreferencesInfo();
    if (whitespace != null) {
        prefs.ignoreWhitespace = whitespace;
    } else if (ignoreWhitespace != null) {
        prefs.ignoreWhitespace = ignoreWhitespace.whitespace;
    } else {
        prefs.ignoreWhitespace = Whitespace.IGNORE_LEADING_AND_TRAILING;
    }
    prefs.context = context;
    prefs.intralineDifference = intraline;
    PatchScriptFactory psf;
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
        psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet.getId(), resource.getPatchKey().getParentKey(), prefs);
    } else if (parentNum > 0) {
        psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), parentNum - 1, resource.getPatchKey().getParentKey(), prefs);
    } else {
        psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), null, resource.getPatchKey().getParentKey(), prefs);
    }
    try {
        psf.setLoadHistory(false);
        psf.setLoadComments(context != DiffPreferencesInfo.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        Set<Edit> editsDueToRebase = ps.getEditsDueToRebase();
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %s; want %s", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %s; want %s", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    boolean dueToRebase = editsDueToRebase.contains(edit);
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit, dueToRebase);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        DiffInfo result = new DiffInfo();
        // TODO referring to the parent commit by refs/changes/12/60012/1^1
        // will likely not work for inline edits
        String revA = basePatchSet != null ? basePatchSet.getRefName() : resource.getRevision().getPatchSet().getRefName() + "^1";
        String revB = resource.getRevision().getEdit().isPresent() ? resource.getRevision().getEdit().get().getRefName() : resource.getRevision().getPatchSet().getRefName();
        List<DiffWebLinkInfo> links = webLinks.getDiffLinks(state.getName(), resource.getPatchKey().getParentKey().getParentKey().get(), basePatchSet != null ? basePatchSet.getId().get() : null, revA, MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName()), resource.getPatchKey().getParentKey().get(), revB, ps.getNewName());
        result.webLinks = links.isEmpty() ? null : links;
        if (!webLinksOnly) {
            if (ps.isBinary()) {
                result.binary = true;
            }
            if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
                result.metaA = new FileMeta();
                result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
                result.metaA.contentType = FileContentUtil.resolveContentType(state, result.metaA.name, ps.getFileModeA(), ps.getMimeTypeA());
                result.metaA.lines = ps.getA().size();
                result.metaA.webLinks = getFileWebLinks(state.getProject(), revA, result.metaA.name);
                result.metaA.commitId = content.commitIdA;
            }
            if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
                result.metaB = new FileMeta();
                result.metaB.name = ps.getNewName();
                result.metaB.contentType = FileContentUtil.resolveContentType(state, result.metaB.name, ps.getFileModeB(), ps.getMimeTypeB());
                result.metaB.lines = ps.getB().size();
                result.metaB.webLinks = getFileWebLinks(state.getProject(), revB, result.metaB.name);
                result.metaB.commitId = content.commitIdB;
            }
            if (intraline) {
                if (ps.hasIntralineTimeout()) {
                    result.intralineStatus = IntraLineStatus.TIMEOUT;
                } else if (ps.hasIntralineFailure()) {
                    result.intralineStatus = IntraLineStatus.FAILURE;
                } else {
                    result.intralineStatus = IntraLineStatus.OK;
                }
            }
            result.changeType = CHANGE_TYPE.get(ps.getChangeType());
            if (result.changeType == null) {
                throw new IllegalStateException("unknown change type: " + ps.getChangeType());
            }
            if (ps.getPatchHeader().size() > 0) {
                result.diffHeader = ps.getPatchHeader();
            }
            result.content = content.lines;
        }
        Response<DiffInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage(), e);
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    }
}
#method_after
@Override
public Response<DiffInfo> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException, PermissionBackendException {
    DiffPreferencesInfo prefs = new DiffPreferencesInfo();
    if (whitespace != null) {
        prefs.ignoreWhitespace = whitespace;
    } else if (ignoreWhitespace != null) {
        prefs.ignoreWhitespace = ignoreWhitespace.whitespace;
    } else {
        prefs.ignoreWhitespace = Whitespace.IGNORE_LEADING_AND_TRAILING;
    }
    prefs.context = context;
    prefs.intralineDifference = intraline;
    PatchScriptFactory psf;
    PatchSet basePatchSet = null;
    PatchSet.Id pId = resource.getPatchKey().getParentKey();
    String fileName = resource.getPatchKey().getFileName();
    ChangeNotes notes = resource.getRevision().getNotes();
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
        psf = patchScriptFactoryFactory.create(notes, fileName, basePatchSet.getId(), pId, prefs);
    } else if (parentNum > 0) {
        psf = patchScriptFactoryFactory.create(notes, fileName, parentNum - 1, pId, prefs);
    } else {
        psf = patchScriptFactoryFactory.create(notes, fileName, null, pId, prefs);
    }
    try {
        psf.setLoadHistory(false);
        psf.setLoadComments(context != DiffPreferencesInfo.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        Set<Edit> editsDueToRebase = ps.getEditsDueToRebase();
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %s; want %s", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %s; want %s", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    boolean dueToRebase = editsDueToRebase.contains(edit);
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit, dueToRebase);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        DiffInfo result = new DiffInfo();
        String revA = basePatchSet != null ? basePatchSet.getRefName() : content.commitIdA;
        String revB = resource.getRevision().getEdit().isPresent() ? resource.getRevision().getEdit().get().getRefName() : resource.getRevision().getPatchSet().getRefName();
        List<DiffWebLinkInfo> links = webLinks.getDiffLinks(state.getName(), resource.getPatchKey().getParentKey().getParentKey().get(), basePatchSet != null ? basePatchSet.getId().get() : null, revA, MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName()), resource.getPatchKey().getParentKey().get(), revB, ps.getNewName());
        result.webLinks = links.isEmpty() ? null : links;
        if (!webLinksOnly) {
            if (ps.isBinary()) {
                result.binary = true;
            }
            if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
                result.metaA = new FileMeta();
                result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
                result.metaA.contentType = FileContentUtil.resolveContentType(state, result.metaA.name, ps.getFileModeA(), ps.getMimeTypeA());
                result.metaA.lines = ps.getA().size();
                result.metaA.webLinks = getFileWebLinks(state.getProject(), revA, result.metaA.name);
                result.metaA.commitId = content.commitIdA;
            }
            if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
                result.metaB = new FileMeta();
                result.metaB.name = ps.getNewName();
                result.metaB.contentType = FileContentUtil.resolveContentType(state, result.metaB.name, ps.getFileModeB(), ps.getMimeTypeB());
                result.metaB.lines = ps.getB().size();
                result.metaB.webLinks = getFileWebLinks(state.getProject(), revB, result.metaB.name);
                result.metaB.commitId = content.commitIdB;
            }
            if (intraline) {
                if (ps.hasIntralineTimeout()) {
                    result.intralineStatus = IntraLineStatus.TIMEOUT;
                } else if (ps.hasIntralineFailure()) {
                    result.intralineStatus = IntraLineStatus.FAILURE;
                } else {
                    result.intralineStatus = IntraLineStatus.OK;
                }
            }
            result.changeType = CHANGE_TYPE.get(ps.getChangeType());
            if (result.changeType == null) {
                throw new IllegalStateException("unknown change type: " + ps.getChangeType());
            }
            if (ps.getPatchHeader().size() > 0) {
                result.diffHeader = ps.getPatchHeader();
            }
            result.content = content.lines;
        }
        Response<DiffInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage(), e);
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    }
}
#end_block

#method_before
@Override
public ProjectAccessInfo apply(ProjectResource rsrc, ProjectAccessInput input) throws ResourceNotFoundException, ResourceConflictException, IOException, AuthException, BadRequestException, UnprocessableEntityException, OrmException, PermissionBackendException {
    MetaDataUpdate.User metaDataUpdateUser = metaDataUpdateFactory.get();
    ProjectConfig config;
    List<AccessSection> removals = accessUtil.getAccessSections(input.remove);
    List<AccessSection> additions = accessUtil.getAccessSections(input.add);
    try (MetaDataUpdate md = metaDataUpdateUser.create(rsrc.getNameKey())) {
        config = ProjectConfig.read(md);
        // Check that the user has the right permissions.
        boolean checkedAdmin = false;
        for (AccessSection section : Iterables.concat(additions, removals)) {
            boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(section.getName());
            if (isGlobalCapabilities) {
                if (!checkedAdmin) {
                    permissionBackend.user(identifiedUser).check(GlobalPermission.ADMINISTRATE_SERVER);
                    checkedAdmin = true;
                }
            } else if (!rsrc.getControl().controlForRef(section.getName()).isOwner()) {
                throw new AuthException("You are not allowed to edit permissions for ref: " + section.getName());
            }
        }
        accessUtil.validateChanges(config, removals, additions);
        accessUtil.applyChanges(config, removals, additions);
        accessUtil.setParentName(identifiedUser.get(), config, rsrc.getNameKey(), input.parent == null ? null : new Project.NameKey(input.parent), !checkedAdmin);
        if (!Strings.isNullOrEmpty(input.message)) {
            if (!input.message.endsWith("\n")) {
                input.message += "\n";
            }
            md.setMessage(input.message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        config.commit(md);
        projectCache.evict(config.getProject());
    } catch (InvalidNameException e) {
        throw new BadRequestException(e.toString());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(rsrc.getName());
    }
    return getAccess.apply(rsrc.getNameKey());
}
#method_after
@Override
public ProjectAccessInfo apply(ProjectResource rsrc, ProjectAccessInput input) throws ResourceNotFoundException, ResourceConflictException, IOException, AuthException, BadRequestException, UnprocessableEntityException, OrmException, PermissionBackendException {
    MetaDataUpdate.User metaDataUpdateUser = metaDataUpdateFactory.get();
    ProjectConfig config;
    List<AccessSection> removals = accessUtil.getAccessSections(input.remove);
    List<AccessSection> additions = accessUtil.getAccessSections(input.add);
    try (MetaDataUpdate md = metaDataUpdateUser.create(rsrc.getNameKey())) {
        config = ProjectConfig.read(md);
        // Check that the user has the right permissions.
        boolean checkedAdmin = false;
        for (AccessSection section : Iterables.concat(additions, removals)) {
            boolean isGlobalCapabilities = AccessSection.GLOBAL_CAPABILITIES.equals(section.getName());
            if (isGlobalCapabilities) {
                if (!checkedAdmin) {
                    permissionBackend.user(identifiedUser).check(GlobalPermission.ADMINISTRATE_SERVER);
                    checkedAdmin = true;
                }
            } else {
                permissionBackend.user(identifiedUser).project(rsrc.getNameKey()).ref(section.getName()).check(RefPermission.WRITE_CONFIG);
            }
        }
        accessUtil.validateChanges(config, removals, additions);
        accessUtil.applyChanges(config, removals, additions);
        accessUtil.setParentName(identifiedUser.get(), config, rsrc.getNameKey(), input.parent == null ? null : new Project.NameKey(input.parent), !checkedAdmin);
        if (!Strings.isNullOrEmpty(input.message)) {
            if (!input.message.endsWith("\n")) {
                input.message += "\n";
            }
            md.setMessage(input.message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        config.commit(md);
        projectCache.evict(config.getProject());
    } catch (InvalidNameException e) {
        throw new BadRequestException(e.toString());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(rsrc.getName());
    }
    return getAccess.apply(rsrc.getNameKey());
}
#end_block

#method_before
@Override
public PatchSet updateChangeImpl(ChangeContext ctx) throws OrmException, NoSuchChangeException, IOException {
    if (newCommit == null && toMerge.getStatusCode() == SKIPPED_IDENTICAL_TREE) {
        return null;
    }
    checkNotNull(newCommit, "no new commit produced by CherryPick of %s, expected to fail fast", toMerge.change().getId());
    PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
    PatchSet newPs = args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, newCommit, false, prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of(), null, null);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    // Don't copy approvals, as this is already taken care of by
    // SubmitStrategyOp.
    newCommit.setControl(ctx.getControl());
    return newPs;
}
#method_after
@Override
public PatchSet updateChangeImpl(ChangeContext ctx) throws OrmException, NoSuchChangeException, IOException {
    if (newCommit == null && toMerge.getStatusCode() == SKIPPED_IDENTICAL_TREE) {
        return null;
    }
    checkNotNull(newCommit, "no new commit produced by CherryPick of %s, expected to fail fast", toMerge.change().getId());
    PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
    PatchSet newPs = args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, newCommit, prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of(), null, null);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    // Don't copy approvals, as this is already taken care of by
    // SubmitStrategyOp.
    newCommit.setNotes(ctx.getNotes());
    return newPs;
}
#end_block

#method_before
public void fire(Change change, PatchSet ps, Account abandoner, String reason, Timestamp when, NotifyHandling notifyHandling) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        Event event = new Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(abandoner), reason, when, notifyHandling);
        for (ChangeAbandonedListener l : listeners) {
            try {
                l.onChangeAbandoned(event);
            } catch (Exception e) {
                util.logEventListenerError(this, l, e);
            }
        }
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException e) {
        log.error("Couldn't fire event", e);
    }
}
#method_after
public void fire(Change change, PatchSet ps, Account abandoner, String reason, Timestamp when, NotifyHandling notifyHandling) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        Event event = new Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(abandoner), reason, when, notifyHandling);
        for (ChangeAbandonedListener l : listeners) {
            try {
                l.onChangeAbandoned(event);
            } catch (Exception e) {
                util.logEventListenerError(this, l, e);
            }
        }
    } catch (PatchListObjectTooLargeException e) {
        log.warn("Couldn't fire event: " + e.getMessage());
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException | PermissionBackendException e) {
        log.error("Couldn't fire event", e);
    }
}
#end_block

#method_before
@Override
public ChangeResource parse(TopLevelResource root, IdString id) throws ResourceNotFoundException, OrmException, PermissionBackendException {
    List<ChangeNotes> notes = changeFinder.find(id.encoded());
    if (notes.isEmpty()) {
        throw new ResourceNotFoundException(id);
    } else if (notes.size() != 1) {
        throw new ResourceNotFoundException("Multiple changes found for " + id);
    }
    ChangeNotes change = notes.get(0);
    if (!canRead(change)) {
        throw new ResourceNotFoundException(id);
    }
    return changeResourceFactory.create(controlFor(change));
}
#method_after
@Override
public ChangeResource parse(TopLevelResource root, IdString id) throws ResourceNotFoundException, OrmException, PermissionBackendException {
    List<ChangeNotes> notes = changeFinder.find(id.encoded());
    if (notes.isEmpty()) {
        throw new ResourceNotFoundException(id);
    } else if (notes.size() != 1) {
        throw new ResourceNotFoundException("Multiple changes found for " + id);
    }
    ChangeNotes change = notes.get(0);
    if (!canRead(change)) {
        throw new ResourceNotFoundException(id);
    }
    return changeResourceFactory.create(change, user.get());
}
#end_block

#method_before
public ChangeResource parse(Change.Id id) throws ResourceNotFoundException, OrmException, PermissionBackendException {
    List<ChangeNotes> notes = changeFinder.find(id);
    if (notes.isEmpty()) {
        throw new ResourceNotFoundException(toIdString(id));
    } else if (notes.size() != 1) {
        throw new ResourceNotFoundException("Multiple changes found for " + id);
    }
    ChangeNotes change = notes.get(0);
    if (!canRead(change)) {
        throw new ResourceNotFoundException(toIdString(id));
    }
    return changeResourceFactory.create(controlFor(change));
}
#method_after
public ChangeResource parse(Change.Id id) throws ResourceNotFoundException, OrmException, PermissionBackendException {
    List<ChangeNotes> notes = changeFinder.find(id);
    if (notes.isEmpty()) {
        throw new ResourceNotFoundException(toIdString(id));
    } else if (notes.size() != 1) {
        throw new ResourceNotFoundException("Multiple changes found for " + id);
    }
    ChangeNotes change = notes.get(0);
    if (!canRead(change)) {
        throw new ResourceNotFoundException(toIdString(id));
    }
    return changeResourceFactory.create(change, user.get());
}
#end_block

#method_before
public ChangeResource parse(ChangeControl control) {
    return changeResourceFactory.create(control);
}
#method_after
public ChangeResource parse(ChangeNotes notes, CurrentUser user) {
    return changeResourceFactory.create(notes, user);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public CreateChange post(TopLevelResource parent) throws RestApiException {
    return createChange;
}
#method_after
@Override
public CreateChange post(TopLevelResource parent) throws RestApiException {
    return createChange;
}
#end_block

#method_before
private boolean canRead(ChangeNotes notes) throws PermissionBackendException {
    return permissionBackend.user(user).change(notes).database(db).test(ChangePermission.READ);
}
#method_after
private boolean canRead(ChangeNotes notes) throws PermissionBackendException {
    try {
        permissionBackend.user(user).change(notes).database(db).check(ChangePermission.READ);
        return true;
    } catch (AuthException e) {
        return false;
    }
}
#end_block

#method_before
@Override
public String apply(ProjectResource rsrc) throws AuthException, ResourceNotFoundException, IOException, PermissionBackendException {
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        Ref head = repo.getRefDatabase().exactRef(Constants.HEAD);
        if (head == null) {
            throw new ResourceNotFoundException(Constants.HEAD);
        } else if (head.isSymbolic()) {
            String n = head.getTarget().getName();
            permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey()).ref(n).check(RefPermission.READ);
            return n;
        } else if (head.getObjectId() != null) {
            try (RevWalk rw = new RevWalk(repo)) {
                RevCommit commit = rw.parseCommit(head.getObjectId());
                if (commits.canRead(rsrc.getProjectState(), repo, commit)) {
                    return head.getObjectId().name();
                }
                throw new AuthException("not allowed to see HEAD");
            } catch (MissingObjectException | IncorrectObjectTypeException e) {
                if (rsrc.getControl().isOwner()) {
                    return head.getObjectId().name();
                }
                throw new AuthException("not allowed to see HEAD");
            }
        }
        throw new ResourceNotFoundException(Constants.HEAD);
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
}
#method_after
@Override
public String apply(ProjectResource rsrc) throws AuthException, ResourceNotFoundException, IOException, PermissionBackendException {
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        Ref head = repo.getRefDatabase().exactRef(Constants.HEAD);
        if (head == null) {
            throw new ResourceNotFoundException(Constants.HEAD);
        } else if (head.isSymbolic()) {
            String n = head.getTarget().getName();
            permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey()).ref(n).check(RefPermission.READ);
            return n;
        } else if (head.getObjectId() != null) {
            try (RevWalk rw = new RevWalk(repo)) {
                RevCommit commit = rw.parseCommit(head.getObjectId());
                if (commits.canRead(rsrc.getProjectState(), repo, commit)) {
                    return head.getObjectId().name();
                }
                throw new AuthException("not allowed to see HEAD");
            } catch (MissingObjectException | IncorrectObjectTypeException e) {
                try {
                    permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey()).check(ProjectPermission.WRITE_CONFIG);
                } catch (AuthException ae) {
                    throw new AuthException("not allowed to see HEAD");
                }
            }
        }
        throw new ResourceNotFoundException(Constants.HEAD);
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    super.init();
    if (notify.compareTo(NotifyHandling.OWNER_REVIEWERS) >= 0) {
        ccAllApprovals();
    }
    if (notify.compareTo(NotifyHandling.ALL) >= 0) {
        bccStarredBy();
        includeWatchers(NotifyType.ALL_COMMENTS, !patchSet.isDraft() && !change.isWorkInProgress() && !change.isPrivate());
    }
    removeUsersThatIgnoredTheChange();
    // Add header that enables identifying comments on parsed email.
    // Grouping is currently done by timestamp.
    setHeader("X-Gerrit-Comment-Date", timestamp);
    if (incomingEmailEnabled) {
        if (replyToAddress == null) {
            // Remove Reply-To and use outbound SMTP (default) instead.
            removeHeader("Reply-To");
        } else {
            setHeader("Reply-To", replyToAddress);
        }
    }
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    if (notify.compareTo(NotifyHandling.OWNER_REVIEWERS) >= 0) {
        ccAllApprovals();
    }
    if (notify.compareTo(NotifyHandling.ALL) >= 0) {
        bccStarredBy();
        includeWatchers(NotifyType.ALL_COMMENTS, !change.isWorkInProgress() && !change.isPrivate());
    }
    removeUsersThatIgnoredTheChange();
    // Add header that enables identifying comments on parsed email.
    // Grouping is currently done by timestamp.
    setHeader("X-Gerrit-Comment-Date", timestamp);
    if (incomingEmailEnabled) {
        if (replyToAddress == null) {
            // Remove Reply-To and use outbound SMTP (default) instead.
            removeHeader("Reply-To");
        } else {
            setHeader("Reply-To", replyToAddress);
        }
    }
}
#end_block

#method_before
private List<CommentSender.FileCommentGroup> getGroupedInlineComments(Repository repo) {
    List<CommentSender.FileCommentGroup> groups = new ArrayList<>();
    // Get the patch list:
    PatchList patchList = null;
    if (repo != null) {
        try {
            patchList = getPatchList();
        } catch (PatchListNotAvailableException e) {
            log.error("Failed to get patch list", e);
        }
    }
    // Loop over the comments and collect them into groups based on the file
    // location of the comment.
    FileCommentGroup currentGroup = null;
    for (Comment c : inlineComments) {
        // If it's a new group:
        if (currentGroup == null || !c.key.filename.equals(currentGroup.filename) || c.key.patchSetId != currentGroup.patchSetId) {
            currentGroup = new FileCommentGroup();
            currentGroup.filename = c.key.filename;
            currentGroup.patchSetId = c.key.patchSetId;
            groups.add(currentGroup);
            if (patchList != null) {
                try {
                    currentGroup.fileData = new PatchFile(repo, patchList, c.key.filename);
                } catch (IOException e) {
                    log.warn(String.format("Cannot load %s from %s in %s", c.key.filename, patchList.getNewId().name(), projectState.getName()), e);
                    currentGroup.fileData = null;
                }
            }
        }
        if (currentGroup.fileData != null) {
            currentGroup.comments.add(c);
        }
    }
    Collections.sort(groups, Comparator.comparing(g -> g.filename, FilenameComparator.INSTANCE));
    return groups;
}
#method_after
private List<CommentSender.FileCommentGroup> getGroupedInlineComments(Repository repo) {
    List<CommentSender.FileCommentGroup> groups = new ArrayList<>();
    // Get the patch list:
    PatchList patchList = null;
    if (repo != null) {
        try {
            patchList = getPatchList();
        } catch (PatchListObjectTooLargeException e) {
            log.warn("Failed to get patch list: " + e.getMessage());
        } catch (PatchListNotAvailableException e) {
            log.error("Failed to get patch list", e);
        }
    }
    // Loop over the comments and collect them into groups based on the file
    // location of the comment.
    FileCommentGroup currentGroup = null;
    for (Comment c : inlineComments) {
        // If it's a new group:
        if (currentGroup == null || !c.key.filename.equals(currentGroup.filename) || c.key.patchSetId != currentGroup.patchSetId) {
            currentGroup = new FileCommentGroup();
            currentGroup.filename = c.key.filename;
            currentGroup.patchSetId = c.key.patchSetId;
            groups.add(currentGroup);
            if (patchList != null) {
                try {
                    currentGroup.fileData = new PatchFile(repo, patchList, c.key.filename);
                } catch (IOException e) {
                    log.warn(String.format("Cannot load %s from %s in %s", c.key.filename, patchList.getNewId().name(), projectState.getName()), e);
                    currentGroup.fileData = null;
                }
            }
        }
        if (currentGroup.fileData != null) {
            currentGroup.comments.add(c);
        }
    }
    Collections.sort(groups, Comparator.comparing(g -> g.filename, FilenameComparator.INSTANCE));
    return groups;
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
    } else {
        projectState = null;
    }
    if (patchSet == null) {
        try {
            patchSet = changeData.currentPatchSet();
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null) {
        setHeader("X-Gerrit-PatchSet", patchSet.getPatchSetId() + "");
        if (patchSetInfo == null) {
            try {
                patchSetInfo = args.patchSetInfoFactory.get(args.db.get(), changeData.notes(), patchSet.getId());
            } catch (PatchSetInfoNotAvailableException | OrmException err) {
                patchSetInfo = null;
            }
        }
    }
    authors = getAuthors();
    try {
        stars = args.starredChangesUtil.byChangeFromIndex(change.getId());
    } catch (OrmException e) {
        throw new EmailException("Failed to load stars for change " + change.getChangeId(), e);
    }
    super.init();
    if (timestamp != null) {
        setHeader("Date", new Date(timestamp.getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setHeader("X-Gerrit-Change-Number", "" + change.getChangeId());
    setChangeUrlHeader();
    setCommitIdHeader();
    if (notify.ordinal() >= NotifyHandling.OWNER_REVIEWERS.ordinal()) {
        try {
            addByEmail(RecipientType.CC, changeData.reviewersByEmail().byState(ReviewerStateInternal.CC));
            addByEmail(RecipientType.CC, changeData.reviewersByEmail().byState(ReviewerStateInternal.REVIEWER));
        } catch (OrmException e) {
            throw new EmailException("Failed to add unregistered CCs " + change.getChangeId(), e);
        }
    }
}
#method_after
@Override
protected void init() throws EmailException {
    if (args.projectCache != null) {
        projectState = args.projectCache.get(change.getProject());
    } else {
        projectState = null;
    }
    if (patchSet == null) {
        try {
            patchSet = changeData.currentPatchSet();
        } catch (OrmException err) {
            patchSet = null;
        }
    }
    if (patchSet != null) {
        setHeader("X-Gerrit-PatchSet", patchSet.getPatchSetId() + "");
        if (patchSetInfo == null) {
            try {
                patchSetInfo = args.patchSetInfoFactory.get(args.db.get(), changeData.notes(), patchSet.getId());
            } catch (PatchSetInfoNotAvailableException | OrmException err) {
                patchSetInfo = null;
            }
        }
    }
    authors = getAuthors();
    try {
        stars = changeData.stars();
    } catch (OrmException e) {
        throw new EmailException("Failed to load stars for change " + change.getChangeId(), e);
    }
    super.init();
    if (timestamp != null) {
        setHeader("Date", new Date(timestamp.getTime()));
    }
    setChangeSubjectHeader();
    setHeader("X-Gerrit-Change-Id", "" + change.getKey().get());
    setHeader("X-Gerrit-Change-Number", "" + change.getChangeId());
    setChangeUrlHeader();
    setCommitIdHeader();
    if (notify.ordinal() >= NotifyHandling.OWNER_REVIEWERS.ordinal()) {
        try {
            addByEmail(RecipientType.CC, changeData.reviewersByEmail().byState(ReviewerStateInternal.CC));
            addByEmail(RecipientType.CC, changeData.reviewersByEmail().byState(ReviewerStateInternal.REVIEWER));
        } catch (OrmException e) {
            throw new EmailException("Failed to add unregistered CCs " + change.getChangeId(), e);
        }
    }
}
#end_block

#method_before
private void setChangeSubjectHeader() throws EmailException {
    setHeader("Subject", textTemplate("ChangeSubject"));
}
#method_after
private void setChangeSubjectHeader() {
    setHeader("Subject", textTemplate("ChangeSubject"));
}
#end_block

#method_before
public String getChangeMessageThreadId() throws EmailException {
    return velocify("<gerrit.${change.createdOn.time}.$change.key.get()@$email.gerritHost>");
}
#method_after
public String getChangeMessageThreadId() {
    return "<gerrit." + change.getCreatedOn().getTime() + "." + change.getKey().get() + "@" + this.getGerritHost() + ">";
}
#end_block

#method_before
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContext.put("fromEmail", getNameEmailFor(fromId));
    soyContext.put("diffLines", getDiffTemplateData());
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    changeData.put("subject", change.getSubject());
    changeData.put("originalSubject", change.getOriginalSubject());
    changeData.put("ownerName", getNameFor(change.getOwner()));
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    changeData.put("changeNumber", Integer.toString(change.getChangeId()));
    soyContext.put("change", changeData);
    String subject = change.getSubject();
    changeData.put("subject", subject);
    // it exceeds that.
    if (subject.length() < 73) {
        changeData.put("shortSubject", subject);
    } else {
        changeData.put("shortSubject", subject.substring(0, 69) + "...");
    }
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
    // TODO(wyatta): patchSetInfo
    footers.add("Gerrit-MessageType: " + messageClass);
    footers.add("Gerrit-Change-Id: " + change.getKey().get());
    footers.add("Gerrit-Change-Number: " + Integer.toString(change.getChangeId()));
    footers.add("Gerrit-PatchSet: " + patchSet.getPatchSetId());
    footers.add("Gerrit-Owner: " + getNameEmailFor(change.getOwner()));
    if (change.getAssignee() != null) {
        footers.add("Gerrit-Assignee: " + getNameEmailFor(change.getAssignee()));
    }
    for (String reviewer : getEmailsByState(ReviewerStateInternal.REVIEWER)) {
        footers.add("Gerrit-Reviewer: " + reviewer);
    }
    for (String reviewer : getEmailsByState(ReviewerStateInternal.CC)) {
        footers.add("Gerrit-CC: " + reviewer);
    }
}
#method_after
@Override
protected void setupSoyContext() {
    super.setupSoyContext();
    soyContext.put("changeId", change.getKey().get());
    soyContext.put("coverLetter", getCoverLetter());
    soyContext.put("fromName", getNameFor(fromId));
    soyContext.put("fromEmail", getNameEmailFor(fromId));
    soyContext.put("diffLines", getDiffTemplateData());
    soyContextEmailData.put("unifiedDiff", getUnifiedDiff());
    soyContextEmailData.put("changeDetail", getChangeDetail());
    soyContextEmailData.put("changeUrl", getChangeUrl());
    soyContextEmailData.put("includeDiff", getIncludeDiff());
    Map<String, String> changeData = new HashMap<>();
    String subject = change.getSubject();
    String originalSubject = change.getOriginalSubject();
    changeData.put("subject", subject);
    changeData.put("originalSubject", originalSubject);
    changeData.put("shortSubject", shortenSubject(subject));
    changeData.put("shortOriginalSubject", shortenSubject(originalSubject));
    changeData.put("ownerName", getNameFor(change.getOwner()));
    changeData.put("ownerEmail", getNameEmailFor(change.getOwner()));
    changeData.put("changeNumber", Integer.toString(change.getChangeId()));
    soyContext.put("change", changeData);
    Map<String, Object> patchSetData = new HashMap<>();
    patchSetData.put("patchSetId", patchSet.getPatchSetId());
    patchSetData.put("refName", patchSet.getRefName());
    soyContext.put("patchSet", patchSetData);
    Map<String, Object> patchSetInfoData = new HashMap<>();
    patchSetInfoData.put("authorName", patchSetInfo.getAuthor().getName());
    patchSetInfoData.put("authorEmail", patchSetInfo.getAuthor().getEmail());
    soyContext.put("patchSetInfo", patchSetInfoData);
    footers.add("Gerrit-MessageType: " + messageClass);
    footers.add("Gerrit-Change-Id: " + change.getKey().get());
    footers.add("Gerrit-Change-Number: " + Integer.toString(change.getChangeId()));
    footers.add("Gerrit-PatchSet: " + patchSet.getPatchSetId());
    footers.add("Gerrit-Owner: " + getNameEmailFor(change.getOwner()));
    if (change.getAssignee() != null) {
        footers.add("Gerrit-Assignee: " + getNameEmailFor(change.getAssignee()));
    }
    for (String reviewer : getEmailsByState(ReviewerStateInternal.REVIEWER)) {
        footers.add("Gerrit-Reviewer: " + reviewer);
    }
    for (String reviewer : getEmailsByState(ReviewerStateInternal.CC)) {
        footers.add("Gerrit-CC: " + reviewer);
    }
}
#end_block

#method_before
public String getUnifiedDiff() {
    PatchList patchList;
    try {
        patchList = getPatchList();
        if (patchList.getOldId() == null) {
            // Currently these always have a null oldId in the PatchList.
            return "[Octopus merge; cannot be formatted as a diff.]\n";
        }
    } catch (PatchListNotAvailableException e) {
        log.error("Cannot format patch", e);
        return "";
    }
    int maxSize = args.settings.maximumDiffSize;
    TemporaryBuffer.Heap buf = new TemporaryBuffer.Heap(Math.min(HEAP_EST_SIZE, maxSize), maxSize);
    try (DiffFormatter fmt = new DiffFormatter(buf)) {
        try (Repository git = args.server.openRepository(change.getProject())) {
            try {
                fmt.setRepository(git);
                fmt.setDetectRenames(true);
                fmt.format(patchList.getOldId(), patchList.getNewId());
                return RawParseUtils.decode(buf.toByteArray());
            } catch (IOException e) {
                if (JGitText.get().inMemoryBufferLimitExceeded.equals(e.getMessage())) {
                    return "";
                }
                log.error("Cannot format patch", e);
                return "";
            }
        } catch (IOException e) {
            log.error("Cannot open repository to format patch", e);
            return "";
        }
    }
}
#method_after
public String getUnifiedDiff() {
    PatchList patchList;
    try {
        patchList = getPatchList();
        if (patchList.getOldId() == null) {
            // Currently these always have a null oldId in the PatchList.
            return "[Octopus merge; cannot be formatted as a diff.]\n";
        }
    } catch (PatchListObjectTooLargeException e) {
        log.warn("Cannot format patch " + e.getMessage());
        return "";
    } catch (PatchListNotAvailableException e) {
        log.error("Cannot format patch", e);
        return "";
    }
    int maxSize = args.settings.maximumDiffSize;
    TemporaryBuffer.Heap buf = new TemporaryBuffer.Heap(Math.min(HEAP_EST_SIZE, maxSize), maxSize);
    try (DiffFormatter fmt = new DiffFormatter(buf)) {
        try (Repository git = args.server.openRepository(change.getProject())) {
            try {
                fmt.setRepository(git);
                fmt.setDetectRenames(true);
                fmt.format(patchList.getOldId(), patchList.getNewId());
                return RawParseUtils.decode(buf.toByteArray());
            } catch (IOException e) {
                if (JGitText.get().inMemoryBufferLimitExceeded.equals(e.getMessage())) {
                    return "";
                }
                log.error("Cannot format patch", e);
                return "";
            }
        } catch (IOException e) {
            log.error("Cannot open repository to format patch", e);
            return "";
        }
    }
}
#end_block

#method_before
@Override
protected Response<ReviewResult> applyImpl(BatchUpdate.Factory updateFactory, RevisionResource revision, ReviewInput input) throws RestApiException, UpdateException, OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    return apply(updateFactory, revision, input, TimeUtil.nowTs());
}
#method_after
@Override
protected Response<ReviewResult> applyImpl(BatchUpdate.Factory updateFactory, RevisionResource revision, ReviewInput input) throws RestApiException, UpdateException, OrmException, IOException, PermissionBackendException, ConfigInvalidException, PatchListNotAvailableException {
    return apply(updateFactory, revision, input, TimeUtil.nowTs());
}
#end_block

#method_before
public Response<ReviewResult> apply(BatchUpdate.Factory updateFactory, RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    ProjectState projectState = projectCache.checkedGet(revision.getProject());
    LabelTypes labelTypes = projectState.getLabelTypes(revision.getNotes(), revision.getUser());
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, labelTypes, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, labelTypes, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        cleanUpComments(input.comments);
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    NotifyHandling reviewerNotify = input.notify;
    if (input.notify == null) {
        input.notify = defaultNotify(revision.getChange(), input);
    }
    ListMultimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        output.error = ERROR_ADDING_REVIEWER;
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = updateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = revision.getUser().getAccountId();
        boolean ccOrReviewer = false;
        if (input.labels != null && !input.labels.isEmpty()) {
            ccOrReviewer = input.labels.values().stream().filter(v -> v != 0).findFirst().isPresent();
        }
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(revision.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        // Add WorkInProgressOp if requested.
        if (input.ready || input.workInProgress) {
            if (input.ready && input.workInProgress) {
                output.error = ERROR_WIP_READY_MUTUALLY_EXCLUSIVE;
                return Response.withStatusCode(SC_BAD_REQUEST, output);
            }
            if (!revision.getChange().getOwner().equals(revision.getUser().getAccountId())) {
                output.error = ERROR_ONLY_OWNER_CAN_MODIFY_WORK_IN_PROGRESS;
                return Response.withStatusCode(SC_BAD_REQUEST, output);
            }
            if (input.ready) {
                output.ready = true;
            }
            // Suppress notifications in WorkInProgressOp, we'll take care of
            // them in this endpoint.
            WorkInProgressOp.Input wipIn = new WorkInProgressOp.Input();
            wipIn.notify = NotifyHandling.NONE;
            bu.addOp(revision.getChange().getId(), workInProgressOpFactory.create(input.workInProgress, wipIn));
        }
        // Add the review op.
        bu.addOp(revision.getChange().getId(), new Op(projectState, revision.getPatchSet().getId(), input, accountsToNotify));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, reviewerNotify, accountsToNotify);
    }
    return Response.ok(output);
}
#method_after
public Response<ReviewResult> apply(BatchUpdate.Factory updateFactory, RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException, PermissionBackendException, ConfigInvalidException, PatchListNotAvailableException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    ProjectState projectState = projectCache.checkedGet(revision.getProject());
    LabelTypes labelTypes = projectState.getLabelTypes(revision.getNotes(), revision.getUser());
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, labelTypes, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, labelTypes, input.labels);
    }
    if (input.comments != null) {
        cleanUpComments(input.comments);
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    NotifyHandling reviewerNotify = input.notify;
    if (input.notify == null) {
        input.notify = defaultNotify(revision.getChange(), input);
    }
    ListMultimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        output.error = ERROR_ADDING_REVIEWER;
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = updateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = revision.getUser().getAccountId();
        boolean ccOrReviewer = false;
        if (input.labels != null && !input.labels.isEmpty()) {
            ccOrReviewer = input.labels.values().stream().filter(v -> v != 0).findFirst().isPresent();
        }
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(revision.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        // Add WorkInProgressOp if requested.
        if (input.ready || input.workInProgress) {
            if (input.ready && input.workInProgress) {
                output.error = ERROR_WIP_READY_MUTUALLY_EXCLUSIVE;
                return Response.withStatusCode(SC_BAD_REQUEST, output);
            }
            if (!revision.getChange().getOwner().equals(revision.getUser().getAccountId())) {
                output.error = ERROR_ONLY_OWNER_CAN_MODIFY_WORK_IN_PROGRESS;
                return Response.withStatusCode(SC_BAD_REQUEST, output);
            }
            if (input.ready) {
                output.ready = true;
            }
            // Suppress notifications in WorkInProgressOp, we'll take care of
            // them in this endpoint.
            WorkInProgressOp.Input wipIn = new WorkInProgressOp.Input();
            wipIn.notify = NotifyHandling.NONE;
            bu.addOp(revision.getChange().getId(), workInProgressOpFactory.create(input.workInProgress, wipIn));
        }
        // Add the review op.
        bu.addOp(revision.getChange().getId(), new Op(projectState, revision.getPatchSet().getId(), input, accountsToNotify));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, reviewerNotify, accountsToNotify);
    }
    return Response.ok(output);
}
#end_block

#method_before
private RevisionResource onBehalfOf(RevisionResource rev, LabelTypes labelTypes, ReviewInput in) throws BadRequestException, AuthException, UnprocessableEntityException, OrmException, PermissionBackendException, IOException, ConfigInvalidException {
    if (in.labels == null || in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    if (in.drafts == null) {
        in.drafts = DraftHandling.KEEP;
    }
    if (in.drafts != DraftHandling.KEEP) {
        throw new AuthException("not allowed to modify other user's drafts");
    }
    CurrentUser caller = rev.getUser();
    PermissionBackend.ForChange perm = rev.permissions().database(db);
    Iterator<Map.Entry<String, Short>> itr = in.labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType type = labelTypes.byLabel(ent.getKey());
        if (type == null && in.strictLabels) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        } else if (type == null) {
            itr.remove();
            continue;
        }
        if (!caller.isInternalUser()) {
            try {
                perm.check(new LabelPermission.WithValue(ON_BEHALF_OF, type, ent.getValue()));
            } catch (AuthException e) {
                throw new AuthException(String.format("not permitted to modify label \"%s\" on behalf of \"%s\"", type.getName(), in.onBehalfOf));
            }
        }
    }
    if (in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    IdentifiedUser reviewer = accounts.parseOnBehalfOf(caller, in.onBehalfOf);
    try {
        perm.user(reviewer).check(ChangePermission.READ);
    } catch (AuthException e) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see change", reviewer.getAccountId()));
    }
    ChangeControl ctl = rev.getControl().forUser(reviewer);
    return new RevisionResource(changes.parse(ctl), rev.getPatchSet());
}
#method_after
private RevisionResource onBehalfOf(RevisionResource rev, LabelTypes labelTypes, ReviewInput in) throws BadRequestException, AuthException, UnprocessableEntityException, OrmException, PermissionBackendException, IOException, ConfigInvalidException {
    if (in.labels == null || in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    if (in.drafts == null) {
        in.drafts = DraftHandling.KEEP;
    }
    if (in.drafts != DraftHandling.KEEP) {
        throw new AuthException("not allowed to modify other user's drafts");
    }
    CurrentUser caller = rev.getUser();
    PermissionBackend.ForChange perm = rev.permissions().database(db);
    Iterator<Map.Entry<String, Short>> itr = in.labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType type = labelTypes.byLabel(ent.getKey());
        if (type == null) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        }
        if (!caller.isInternalUser()) {
            try {
                perm.check(new LabelPermission.WithValue(ON_BEHALF_OF, type, ent.getValue()));
            } catch (AuthException e) {
                throw new AuthException(String.format("not permitted to modify label \"%s\" on behalf of \"%s\"", type.getName(), in.onBehalfOf));
            }
        }
    }
    if (in.labels.isEmpty()) {
        throw new AuthException(String.format("label required to post review on behalf of \"%s\"", in.onBehalfOf));
    }
    IdentifiedUser reviewer = accounts.parseOnBehalfOf(caller, in.onBehalfOf);
    try {
        perm.user(reviewer).check(ChangePermission.READ);
    } catch (AuthException e) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see change", reviewer.getAccountId()));
    }
    return new RevisionResource(changeResourceFactory.create(rev.getNotes(), reviewer), rev.getPatchSet());
}
#end_block

#method_before
private void checkLabels(RevisionResource rsrc, LabelTypes labelTypes, boolean strict, Map<String, Short> labels) throws BadRequestException, AuthException, PermissionBackendException {
    PermissionBackend.ForChange perm = rsrc.permissions();
    Iterator<Map.Entry<String, Short>> itr = labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType lt = labelTypes.byLabel(ent.getKey());
        if (lt == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
            }
            itr.remove();
            continue;
        }
        if (ent.getValue() == null || ent.getValue() == 0) {
            // Later null/0 will be deleted and revoke the label.
            continue;
        }
        if (lt.getValue(ent.getValue()) == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\": %d is not a valid value", ent.getKey(), ent.getValue()));
            }
            itr.remove();
            continue;
        }
        short val = ent.getValue();
        try {
            perm.check(new LabelPermission.WithValue(lt, val));
        } catch (AuthException e) {
            if (strict) {
                throw new AuthException(String.format("Applying label \"%s\": %d is restricted", lt.getName(), val));
            }
            ent.setValue(perm.squashThenCheck(lt, val));
        }
    }
}
#method_after
private void checkLabels(RevisionResource rsrc, LabelTypes labelTypes, Map<String, Short> labels) throws BadRequestException, AuthException, PermissionBackendException {
    PermissionBackend.ForChange perm = rsrc.permissions();
    Iterator<Map.Entry<String, Short>> itr = labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType lt = labelTypes.byLabel(ent.getKey());
        if (lt == null) {
            throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
        }
        if (ent.getValue() == null || ent.getValue() == 0) {
            // Later null/0 will be deleted and revoke the label.
            continue;
        }
        if (lt.getValue(ent.getValue()) == null) {
            throw new BadRequestException(String.format("label \"%s\": %d is not a valid value", ent.getKey(), ent.getValue()));
        }
        short val = ent.getValue();
        try {
            perm.check(new LabelPermission.WithValue(lt, val));
        } catch (AuthException e) {
            throw new AuthException(String.format("Applying label \"%s\": %d is restricted", lt.getName(), val));
        }
    }
}
#end_block

#method_before
private <T extends CommentInput> void checkComments(RevisionResource revision, Map<String, List<T>> commentsPerPath) throws OrmException, BadRequestException {
    Set<String> revisionFilePaths = getAffectedFilePaths(revision);
    for (Map.Entry<String, List<T>> entry : commentsPerPath.entrySet()) {
        String path = entry.getKey();
        PatchSet.Id patchSetId = revision.getChange().currentPatchSetId();
        ensurePathRefersToAvailableOrMagicFile(path, revisionFilePaths, patchSetId);
        List<T> comments = entry.getValue();
        for (T comment : comments) {
            ensureLineIsNonNegative(comment.line, path);
            ensureCommentNotOnMagicFilesOfAutoMerge(path, comment);
            ensureRangeIsValid(path, comment.range);
        }
    }
}
#method_after
private <T extends CommentInput> void checkComments(RevisionResource revision, Map<String, List<T>> commentsPerPath) throws BadRequestException, PatchListNotAvailableException {
    Set<String> revisionFilePaths = getAffectedFilePaths(revision);
    for (Map.Entry<String, List<T>> entry : commentsPerPath.entrySet()) {
        String path = entry.getKey();
        PatchSet.Id patchSetId = revision.getChange().currentPatchSetId();
        ensurePathRefersToAvailableOrMagicFile(path, revisionFilePaths, patchSetId);
        List<T> comments = entry.getValue();
        for (T comment : comments) {
            ensureLineIsNonNegative(comment.line, path);
            ensureCommentNotOnMagicFilesOfAutoMerge(path, comment);
            ensureRangeIsValid(path, comment.range);
        }
    }
}
#end_block

#method_before
private Set<String> getAffectedFilePaths(RevisionResource revision) throws OrmException {
    ChangeData changeData = changeDataFactory.create(db.get(), revision.getControl());
    return new HashSet<>(changeData.filePaths(revision.getPatchSet()));
}
#method_after
private Set<String> getAffectedFilePaths(RevisionResource revision) throws PatchListNotAvailableException {
    ObjectId newId = ObjectId.fromString(revision.getPatchSet().getRevision().get());
    DiffSummaryKey key = DiffSummaryKey.fromPatchListKey(PatchListKey.againstDefaultBase(newId, Whitespace.IGNORE_NONE));
    DiffSummary ds = patchListCache.getDiffSummary(key, revision.getProject());
    return new HashSet<>(ds.getPaths());
}
#end_block

#method_before
private void checkRobotComments(RevisionResource revision, Map<String, List<RobotCommentInput>> in) throws BadRequestException, OrmException {
    cleanUpComments(in);
    for (Map.Entry<String, List<RobotCommentInput>> e : in.entrySet()) {
        String commentPath = e.getKey();
        for (RobotCommentInput c : e.getValue()) {
            ensureSizeOfJsonInputIsWithinBounds(c);
            ensureRobotIdIsSet(c.robotId, commentPath);
            ensureRobotRunIdIsSet(c.robotRunId, commentPath);
            ensureFixSuggestionsAreAddable(c.fixSuggestions, commentPath);
        }
    }
    checkComments(revision, in);
}
#method_after
private void checkRobotComments(RevisionResource revision, Map<String, List<RobotCommentInput>> in) throws BadRequestException, PatchListNotAvailableException {
    cleanUpComments(in);
    for (Map.Entry<String, List<RobotCommentInput>> e : in.entrySet()) {
        String commentPath = e.getKey();
        for (RobotCommentInput c : e.getValue()) {
            ensureSizeOfJsonInputIsWithinBounds(c);
            ensureRobotIdIsSet(c.robotId, commentPath);
            ensureRobotRunIdIsSet(c.robotRunId, commentPath);
            ensureFixSuggestionsAreAddable(c.fixSuggestions, commentPath);
        }
    }
    checkComments(revision, in);
}
#end_block

#method_before
private boolean isReviewer(ChangeContext ctx) throws OrmException {
    if (ctx.getAccountId().equals(ctx.getChange().getOwner())) {
        return true;
    }
    ChangeData cd = changeDataFactory.create(db.get(), ctx.getControl());
    ReviewerSet reviewers = cd.reviewers();
    if (reviewers.byState(REVIEWER).contains(ctx.getAccountId())) {
        return true;
    }
    return false;
}
#method_after
private boolean isReviewer(ChangeContext ctx) throws OrmException {
    if (ctx.getAccountId().equals(ctx.getChange().getOwner())) {
        return true;
    }
    ChangeData cd = changeDataFactory.create(db.get(), ctx.getNotes());
    ReviewerSet reviewers = cd.reviewers();
    if (reviewers.byState(REVIEWER).contains(ctx.getAccountId())) {
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
protected void configure() {
    // TODO(sop) Hide ProjectControl, RefControl, ChangeControl related bindings.
    bind(ProjectControl.GenericFactory.class);
    factory(ProjectControl.AssistedFactory.class);
    bind(ChangeControl.GenericFactory.class);
    bind(ChangeControl.Factory.class);
}
#method_after
@Override
protected void configure() {
    // TODO(sop) Hide ProjectControl, RefControl, ChangeControl related bindings.
    bind(ProjectControl.GenericFactory.class);
    factory(ProjectControl.AssistedFactory.class);
    bind(ChangeControl.Factory.class);
}
#end_block

#method_before
public List<ReviewerInfo> format(Collection<ReviewerResource> rsrcs) throws OrmException, PermissionBackendException {
    List<ReviewerInfo> infos = Lists.newArrayListWithCapacity(rsrcs.size());
    AccountLoader loader = accountLoaderFactory.create(true);
    ChangeData cd = null;
    for (ReviewerResource rsrc : rsrcs) {
        if (cd == null || !cd.getId().equals(rsrc.getChangeId())) {
            cd = changeDataFactory.create(db.get(), rsrc.getChangeResource().getNotes());
        }
        ReviewerInfo info = format(new ReviewerInfo(rsrc.getReviewerUser().getAccountId().get()), permissionBackend.user(rsrc.getReviewerUser()).database(db).change(cd), cd);
        loader.put(info);
        infos.add(info);
    }
    loader.fill();
    return infos;
}
#method_after
public List<ReviewerInfo> format(Collection<ReviewerResource> rsrcs) throws OrmException, PermissionBackendException {
    List<ReviewerInfo> infos = Lists.newArrayListWithCapacity(rsrcs.size());
    AccountLoader loader = accountLoaderFactory.create(true);
    ChangeData cd = null;
    for (ReviewerResource rsrc : rsrcs) {
        if (cd == null || !cd.getId().equals(rsrc.getChangeId())) {
            cd = changeDataFactory.create(db.get(), rsrc.getChangeResource().getNotes());
        }
        ReviewerInfo info = format(rsrc.getChangeResource().getUser(), new ReviewerInfo(rsrc.getReviewerUser().getAccountId().get()), permissionBackend.user(rsrc.getReviewerUser()).database(db).change(cd), cd);
        loader.put(info);
        infos.add(info);
    }
    loader.fill();
    return infos;
}
#end_block

#method_before
public ReviewerInfo format(ReviewerInfo out, PermissionBackend.ForChange perm, ChangeData cd, Iterable<PatchSetApproval> approvals) throws OrmException, PermissionBackendException {
    LabelTypes labelTypes = cd.getLabelTypes();
    out.approvals = new TreeMap<>(labelTypes.nameComparator());
    for (PatchSetApproval ca : approvals) {
        LabelType at = labelTypes.byLabel(ca.getLabelId());
        if (at != null) {
            out.approvals.put(at.getName(), formatValue(ca.getValue()));
        }
    }
    // Add dummy approvals for all permitted labels for the user even if they
    // do not exist in the DB.
    PatchSet ps = cd.currentPatchSet();
    if (ps != null) {
        for (SubmitRecord rec : new SubmitRuleEvaluator(accountCache, accounts, emails, cd).setFastEvalLabels(true).setAllowDraft(true).evaluate()) {
            if (rec.labels == null) {
                continue;
            }
            for (SubmitRecord.Label label : rec.labels) {
                String name = label.label;
                LabelType type = labelTypes.byLabel(name);
                if (!out.approvals.containsKey(name) && type != null && perm.test(new LabelPermission(type))) {
                    out.approvals.put(name, formatValue((short) 0));
                }
            }
        }
    }
    if (out.approvals.isEmpty()) {
        out.approvals = null;
    }
    return out;
}
#method_after
public ReviewerInfo format(CurrentUser user, ReviewerInfo out, PermissionBackend.ForChange perm, ChangeData cd) throws OrmException, PermissionBackendException {
    PatchSet.Id psId = cd.change().currentPatchSetId();
    return format(user, out, perm, cd, approvalsUtil.byPatchSetUser(db.get(), cd.notes(), perm.user(), psId, new Account.Id(out._accountId), null, null));
}
#end_block

#method_before
public GeneralPreferencesInfo loadMyMenusAndUrlAliases(GeneralPreferencesInfo r, VersionedAccountPreferences v, VersionedAccountPreferences d) {
    r.my = my(v);
    if (r.my.isEmpty() && !v.isDefaults()) {
        r.my = my(d);
    }
    if (r.my.isEmpty()) {
        r.my.add(new MenuItem("Changes", "#/dashboard/self", null));
        r.my.add(new MenuItem("Drafts", "#/q/owner:self+is:draft", null));
        r.my.add(new MenuItem("Draft Comments", "#/q/has:draft", null));
        r.my.add(new MenuItem("Edits", "#/q/has:edit", null));
        r.my.add(new MenuItem("Watched Changes", "#/q/is:watched+is:open", null));
        r.my.add(new MenuItem("Starred Changes", "#/q/is:starred", null));
        r.my.add(new MenuItem("Groups", "#/groups/self", null));
    }
    r.urlAliases = urlAliases(v);
    if (r.urlAliases == null && !v.isDefaults()) {
        r.urlAliases = urlAliases(d);
    }
    return r;
}
#method_after
public GeneralPreferencesInfo loadMyMenusAndUrlAliases(GeneralPreferencesInfo r, VersionedAccountPreferences v, VersionedAccountPreferences d) {
    r.my = my(v);
    if (r.my.isEmpty() && !v.isDefaults()) {
        r.my = my(d);
    }
    if (r.my.isEmpty()) {
        r.my.add(new MenuItem("Changes", "#/dashboard/self", null));
        r.my.add(new MenuItem("Draft Comments", "#/q/has:draft", null));
        r.my.add(new MenuItem("Edits", "#/q/has:edit", null));
        r.my.add(new MenuItem("Watched Changes", "#/q/is:watched+is:open", null));
        r.my.add(new MenuItem("Starred Changes", "#/q/is:starred", null));
        r.my.add(new MenuItem("Groups", "#/groups/self", null));
    }
    r.urlAliases = urlAliases(v);
    if (r.urlAliases == null && !v.isDefaults()) {
        r.urlAliases = urlAliases(d);
    }
    return r;
}
#end_block

#method_before
public static Predicate<ChangeData> parse(String value) throws QueryParseException {
    String lower = value.toLowerCase();
    NavigableMap<String, Predicate<ChangeData>> head = PREDICATES.tailMap(lower, true);
    if (!head.isEmpty()) {
        // Assume no statuses share a common prefix so we can only walk one entry.
        Map.Entry<String, Predicate<ChangeData>> e = head.entrySet().iterator().next();
        if (e.getKey().startsWith(lower)) {
            return e.getValue();
        }
    }
    throw new QueryParseException("invalid change status: " + value);
}
#method_after
public static Predicate<ChangeData> parse(String value) {
    String lower = value.toLowerCase();
    NavigableMap<String, Predicate<ChangeData>> head = PREDICATES.tailMap(lower, true);
    if (!head.isEmpty()) {
        // Assume no statuses share a common prefix so we can only walk one entry.
        Map.Entry<String, Predicate<ChangeData>> e = head.entrySet().iterator().next();
        if (e.getKey().startsWith(lower)) {
            return e.getValue();
        }
    }
    return NONE;
}
#end_block

#method_before
public Change.Status getStatus() {
    return status;
}
#method_after
@Nullable
public Change.Status getStatus() {
    return status;
}
#end_block

#method_before
@Override
public boolean match(ChangeData object) throws OrmException {
    Change change = object.change();
    return change != null && status.equals(change.getStatus());
}
#method_after
@Override
public boolean match(ChangeData object) throws OrmException {
    Change change = object.change();
    return change != null && Objects.equals(status, change.getStatus());
}
#end_block

#method_before
@Override
public int hashCode() {
    return status.hashCode();
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(status);
}
#end_block

#method_before
@Override
public boolean equals(Object other) {
    if (other instanceof ChangeStatusPredicate) {
        final ChangeStatusPredicate p = (ChangeStatusPredicate) other;
        return status.equals(p.status);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object other) {
    return (other instanceof ChangeStatusPredicate) && Objects.equals(status, ((ChangeStatusPredicate) other).status);
}
#end_block

#method_before
@Override
public ConfigInfo config(ConfigInput in) throws RestApiException {
    return putConfig.apply(checkExists(), in);
}
#method_after
@Override
public ConfigInfo config(ConfigInput in) throws RestApiException {
    try {
        return putConfig.apply(checkExists(), in);
    } catch (Exception e) {
        throw asRestApiException("Cannot list tags", e);
    }
}
#end_block

#method_before
@Override
public ListRefsRequest<BranchInfo> branches() {
    return new ListRefsRequest<BranchInfo>() {

        @Override
        public List<BranchInfo> get() throws RestApiException {
            return listBranches(this);
        }
    };
}
#method_after
@Override
public ListRefsRequest<BranchInfo> branches() {
    return new ListRefsRequest<BranchInfo>() {

        @Override
        public List<BranchInfo> get() throws RestApiException {
            try {
                return listBranches.get().request(this).apply(checkExists());
            } catch (Exception e) {
                throw asRestApiException("Cannot list branches", e);
            }
        }
    };
}
#end_block

#method_before
@Override
public ListRefsRequest<TagInfo> tags() {
    return new ListRefsRequest<TagInfo>() {

        @Override
        public List<TagInfo> get() throws RestApiException {
            return listTags(this);
        }
    };
}
#method_after
@Override
public ListRefsRequest<TagInfo> tags() {
    return new ListRefsRequest<TagInfo>() {

        @Override
        public List<TagInfo> get() throws RestApiException {
            try {
                return listTags.get().request(this).apply(checkExists());
            } catch (Exception e) {
                throw asRestApiException("Cannot list tags", e);
            }
        }
    };
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public RestModifyView<ProjectResource, ?> create(ProjectResource parent, IdString id) throws RestApiException {
    if (id.toString().equals("default")) {
        return createDefault.get();
    }
    throw new ResourceNotFoundException(id);
}
#method_after
@Override
public RestModifyView<ProjectResource, ?> create(ProjectResource parent, IdString id) throws RestApiException {
    if (isDefaultDashboard(id)) {
        return createDefault.get();
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
@Override
public DashboardResource parse(ProjectResource parent, IdString id) throws ResourceNotFoundException, IOException, ConfigInvalidException, PermissionBackendException {
    ProjectControl myCtl = parent.getControl();
    if (id.toString().equals("default")) {
        return DashboardResource.projectDefault(myCtl);
    }
    List<String> parts = Lists.newArrayList(Splitter.on(':').limit(2).split(id.get()));
    if (parts.size() != 2) {
        throw new ResourceNotFoundException(id);
    }
    CurrentUser user = myCtl.getUser();
    String ref = parts.get(0);
    String path = parts.get(1);
    for (ProjectState ps : myCtl.getProjectState().tree()) {
        try {
            return parse(ps.controlFor(user), ref, path, myCtl);
        } catch (AmbiguousObjectException | ConfigInvalidException | IncorrectObjectTypeException e) {
            throw new ResourceNotFoundException(id);
        } catch (ResourceNotFoundException e) {
            continue;
        }
    }
    throw new ResourceNotFoundException(id);
}
#method_after
@Override
public DashboardResource parse(ProjectResource parent, IdString id) throws ResourceNotFoundException, IOException, ConfigInvalidException, PermissionBackendException {
    if (isDefaultDashboard(id)) {
        return DashboardResource.projectDefault(parent.getProjectState(), parent.getUser());
    }
    DashboardInfo info;
    try {
        info = newDashboardInfo(id.get());
    } catch (InvalidDashboardId e) {
        throw new ResourceNotFoundException(id);
    }
    for (ProjectState ps : parent.getProjectState().tree()) {
        try {
            return parse(ps, parent.getProjectState(), parent.getUser(), info);
        } catch (AmbiguousObjectException | ConfigInvalidException | IncorrectObjectTypeException e) {
            throw new ResourceNotFoundException(id);
        } catch (ResourceNotFoundException e) {
            continue;
        }
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
static DashboardInfo parse(Project definingProject, String refName, String path, Config config, String project, boolean setDefault) {
    DashboardInfo info = new DashboardInfo(refName, path);
    info.project = project;
    info.definingProject = definingProject.getName();
    String query = config.getString("dashboard", null, "title");
    info.title = replace(project, query == null ? info.path : query);
    info.description = replace(project, config.getString("dashboard", null, "description"));
    info.foreach = config.getString("dashboard", null, "foreach");
    if (setDefault) {
        String id = refName + ":" + path;
        info.isDefault = id.equals(defaultOf(definingProject)) ? true : null;
    }
    UrlEncoded u = new UrlEncoded("/dashboard/");
    u.put("title", MoreObjects.firstNonNull(info.title, info.path));
    if (info.foreach != null) {
        u.put("foreach", replace(project, info.foreach));
    }
    for (String name : config.getSubsections("section")) {
        Section s = new Section();
        s.name = name;
        s.query = config.getString("section", name, "query");
        u.put(s.name, replace(project, s.query));
        info.sections.add(s);
    }
    info.url = u.toString().replace("%3A", ":");
    return info;
}
#method_after
private DashboardResource parse(ProjectState parent, ProjectState current, CurrentUser user, DashboardInfo info) throws ResourceNotFoundException, IOException, AmbiguousObjectException, IncorrectObjectTypeException, ConfigInvalidException, PermissionBackendException {
    String ref = normalizeDashboardRef(info.ref);
    try {
        permissionBackend.user(user).project(parent.getNameKey()).ref(ref).check(RefPermission.READ);
    } catch (AuthException e) {
        // Don't leak the project's existence
        throw new ResourceNotFoundException(info.id);
    }
    if (!Repository.isValidRefName(ref)) {
        throw new ResourceNotFoundException(info.id);
    }
    try (Repository git = gitManager.openRepository(parent.getNameKey())) {
        ObjectId objId = git.resolve(ref + ":" + info.path);
        if (objId == null) {
            throw new ResourceNotFoundException(info.id);
        }
        BlobBasedConfig cfg = new BlobBasedConfig(null, git, objId);
        return new DashboardResource(current, user, ref, info.path, cfg, false);
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(info.id);
    }
}
#end_block

#method_before
static DashboardInfo parse(Project definingProject, String refName, String path, Config config, String project, boolean setDefault) {
    DashboardInfo info = new DashboardInfo(refName, path);
    info.project = project;
    info.definingProject = definingProject.getName();
    String query = config.getString("dashboard", null, "title");
    info.title = replace(project, query == null ? info.path : query);
    info.description = replace(project, config.getString("dashboard", null, "description"));
    info.foreach = config.getString("dashboard", null, "foreach");
    if (setDefault) {
        String id = refName + ":" + path;
        info.isDefault = id.equals(defaultOf(definingProject)) ? true : null;
    }
    UrlEncoded u = new UrlEncoded("/dashboard/");
    u.put("title", MoreObjects.firstNonNull(info.title, info.path));
    if (info.foreach != null) {
        u.put("foreach", replace(project, info.foreach));
    }
    for (String name : config.getSubsections("section")) {
        Section s = new Section();
        s.name = name;
        s.query = config.getString("section", name, "query");
        u.put(s.name, replace(project, s.query));
        info.sections.add(s);
    }
    info.url = u.toString().replace("%3A", ":");
    return info;
}
#method_after
static DashboardInfo parse(Project definingProject, String refName, String path, Config config, String project, boolean setDefault) {
    DashboardInfo info = newDashboardInfo(refName, path);
    info.project = project;
    info.definingProject = definingProject.getName();
    String title = config.getString("dashboard", null, "title");
    info.title = replace(project, title == null ? info.path : title);
    info.description = replace(project, config.getString("dashboard", null, "description"));
    info.foreach = config.getString("dashboard", null, "foreach");
    if (setDefault) {
        String id = refName + ":" + path;
        info.isDefault = id.equals(defaultOf(definingProject)) ? true : null;
    }
    UrlEncoded u = new UrlEncoded("/dashboard/");
    u.put("title", MoreObjects.firstNonNull(info.title, info.path));
    if (info.foreach != null) {
        u.put("foreach", replace(project, info.foreach));
    }
    for (String name : config.getSubsections("section")) {
        DashboardSectionInfo s = new DashboardSectionInfo();
        s.name = name;
        s.query = config.getString("section", name, "query");
        u.put(s.name, replace(project, s.query));
        info.sections.add(s);
    }
    info.url = u.toString().replace("%3A", ":");
    return info;
}
#end_block

#method_before
private static String replace(String project, String query) {
    return query.replace("${project}", project);
}
#method_after
private static String replace(String project, String input) {
    return input == null ? input : input.replace("${project}", project);
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource rsrc, Input input) throws RestApiException, OrmException, IOException, ConfigInvalidException {
    if (self.get() == rsrc.getUser()) {
        throw new ResourceConflictException("cannot deactivate own account");
    }
    return setInactiveFlag.deactivate(rsrc.getUser());
}
#method_after
@Override
public Response<?> apply(AccountResource rsrc, Input input) throws RestApiException, OrmException, IOException, ConfigInvalidException {
    if (self.get() == rsrc.getUser()) {
        throw new ResourceConflictException("cannot deactivate own account");
    }
    return setInactiveFlag.deactivate(rsrc.getUser().getAccountId());
}
#end_block

#method_before
private static long initialDelay(Config rc, String section, String subsection, String keyStartTime, DateTime now, long interval) {
    long delay = MISSING_CONFIG;
    String start = rc.getString(section, subsection, keyStartTime);
    try {
        if (start != null) {
            DateTimeFormatter formatter;
            MutableDateTime startTime = now.toMutableDateTime();
            try {
                formatter = ISODateTimeFormat.hourMinute();
                LocalTime firstStartTime = formatter.parseLocalTime(start);
                startTime.hourOfDay().set(firstStartTime.getHourOfDay());
                startTime.minuteOfHour().set(firstStartTime.getMinuteOfHour());
            } catch (IllegalArgumentException e1) {
                formatter = DateTimeFormat.forPattern("E HH:mm").withLocale(Locale.US);
                LocalDateTime firstStartDateTime = formatter.parseLocalDateTime(start);
                startTime.dayOfWeek().set(firstStartDateTime.getDayOfWeek());
                startTime.hourOfDay().set(firstStartDateTime.getHourOfDay());
                startTime.minuteOfHour().set(firstStartDateTime.getMinuteOfHour());
            }
            startTime.secondOfMinute().set(0);
            startTime.millisOfSecond().set(0);
            long s = startTime.getMillis();
            long n = now.getMillis();
            delay = (s - n) % interval;
            if (delay <= 0) {
                delay += interval;
            }
        } else {
            log.info(MessageFormat.format("{0} schedule parameter \"{0}.{1}\" is not configured", section, keyStartTime));
        }
    } catch (IllegalArgumentException e2) {
        log.error(MessageFormat.format("Invalid {0} schedule parameter \"{0}.{1}\"", section, keyStartTime), e2);
        delay = INVALID_CONFIG;
    }
    return delay;
}
#method_after
private static long initialDelay(Config rc, String section, String subsection, String keyStartTime, ZonedDateTime now, long interval) {
    long delay = MISSING_CONFIG;
    String start = rc.getString(section, subsection, keyStartTime);
    try {
        if (start != null) {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("[E ]HH:mm").withLocale(Locale.US);
            LocalTime firstStartTime = LocalTime.parse(start, formatter);
            ZonedDateTime startTime = now.with(firstStartTime);
            try {
                DayOfWeek dayOfWeek = formatter.parse(start, DayOfWeek::from);
                startTime = startTime.with(dayOfWeek);
            } catch (DateTimeParseException ignored) {
            // Day of week is an optional parameter.
            }
            startTime = startTime.truncatedTo(ChronoUnit.MINUTES);
            delay = Duration.between(now, startTime).toMillis() % interval;
            if (delay <= 0) {
                delay += interval;
            }
        } else {
            log.info(MessageFormat.format("{0} schedule parameter \"{0}.{1}\" is not configured", section, keyStartTime));
        }
    } catch (IllegalArgumentException e2) {
        log.error(MessageFormat.format("Invalid {0} schedule parameter \"{0}.{1}\"", section, keyStartTime), e2);
        delay = INVALID_CONFIG;
    }
    return delay;
}
#end_block

#method_before
@Override
public GroupInfo apply(TopLevelResource resource, GroupInput input) throws AuthException, BadRequestException, UnprocessableEntityException, ResourceConflictException, OrmException, IOException, ConfigInvalidException, ResourceNotFoundException {
    if (input == null) {
        input = new GroupInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    AccountGroup.Id ownerId = owner(input);
    CreateGroupArgs args = new CreateGroupArgs();
    args.setGroupName(name);
    args.groupDescription = Strings.emptyToNull(input.description);
    args.visibleToAll = MoreObjects.firstNonNull(input.visibleToAll, defaultVisibleToAll);
    args.ownerGroupId = ownerId;
    if (input.members != null && !input.members.isEmpty()) {
        List<Account.Id> members = new ArrayList<>();
        for (String nameOrEmailOrId : input.members) {
            Account a = addMembers.findAccount(nameOrEmailOrId);
            if (!a.isActive()) {
                throw new UnprocessableEntityException(String.format("Account Inactive: %s", nameOrEmailOrId));
            }
            members.add(a.getId());
        }
        args.initialMembers = members;
    } else {
        args.initialMembers = ownerId == null ? Collections.singleton(self.get().getAccountId()) : Collections.<Account.Id>emptySet();
    }
    for (GroupCreationValidationListener l : groupCreationValidationListeners) {
        try {
            l.validateNewGroup(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    return json.format(GroupDescriptions.forAccountGroup(createGroup(args)));
}
#method_after
@Override
public GroupInfo apply(TopLevelResource resource, GroupInput input) throws AuthException, BadRequestException, UnprocessableEntityException, ResourceConflictException, OrmException, IOException, ConfigInvalidException, ResourceNotFoundException {
    if (input == null) {
        input = new GroupInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    AccountGroup.Id ownerId = owner(input);
    CreateGroupArgs args = new CreateGroupArgs();
    args.setGroupName(name);
    args.groupDescription = Strings.emptyToNull(input.description);
    args.visibleToAll = MoreObjects.firstNonNull(input.visibleToAll, defaultVisibleToAll);
    args.ownerGroupId = ownerId;
    if (input.members != null && !input.members.isEmpty()) {
        List<Account.Id> members = new ArrayList<>();
        for (String nameOrEmailOrId : input.members) {
            Account a = addMembers.findAccount(nameOrEmailOrId);
            if (!a.isActive()) {
                throw new UnprocessableEntityException(String.format("Account Inactive: %s", nameOrEmailOrId));
            }
            members.add(a.getId());
        }
        args.initialMembers = members;
    } else {
        args.initialMembers = ownerId == null ? Collections.singleton(self.get().getAccountId()) : Collections.<Account.Id>emptySet();
    }
    for (GroupCreationValidationListener l : groupCreationValidationListeners) {
        try {
            l.validateNewGroup(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    return json.format(new InternalGroupDescription(createGroup(args)));
}
#end_block

#method_before
private AccountGroup createGroup(CreateGroupArgs createGroupArgs) throws OrmException, ResourceConflictException, IOException {
    // Do not allow creating groups with the same name as system groups
    for (String name : systemGroupBackend.getNames()) {
        if (name.toLowerCase(Locale.US).equals(createGroupArgs.getGroupName().toLowerCase(Locale.US))) {
            throw new ResourceConflictException("group '" + name + "' already exists");
        }
    }
    for (String name : systemGroupBackend.getReservedNames()) {
        if (name.toLowerCase(Locale.US).equals(createGroupArgs.getGroupName().toLowerCase(Locale.US))) {
            throw new ResourceConflictException("group name '" + name + "' is reserved");
        }
    }
    AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    AccountGroup.UUID uuid = GroupUUID.make(createGroupArgs.getGroupName(), self.get().newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone()));
    AccountGroup group = new AccountGroup(createGroupArgs.getGroup(), groupId, uuid, TimeUtil.nowTs());
    group.setVisibleToAll(createGroupArgs.visibleToAll);
    if (createGroupArgs.ownerGroupId != null) {
        AccountGroup ownerGroup = groupCache.get(createGroupArgs.ownerGroupId);
        if (ownerGroup != null) {
            group.setOwnerGroupUUID(ownerGroup.getGroupUUID());
        }
    }
    if (createGroupArgs.groupDescription != null) {
        group.setDescription(createGroupArgs.groupDescription);
    }
    try {
        groupsUpdateProvider.get().addGroup(db, group, ImmutableSet.copyOf(createGroupArgs.initialMembers));
    } catch (OrmDuplicateKeyException e) {
        throw new ResourceConflictException("group '" + createGroupArgs.getGroupName() + "' already exists");
    }
    return group;
}
#method_after
private InternalGroup createGroup(CreateGroupArgs createGroupArgs) throws OrmException, ResourceConflictException, IOException {
    String nameLower = createGroupArgs.getGroupName().toLowerCase(Locale.US);
    for (String name : systemGroupBackend.getNames()) {
        if (name.toLowerCase(Locale.US).equals(nameLower)) {
            throw new ResourceConflictException("group '" + name + "' already exists");
        }
    }
    for (String name : systemGroupBackend.getReservedNames()) {
        if (name.toLowerCase(Locale.US).equals(nameLower)) {
            throw new ResourceConflictException("group name '" + name + "' is reserved");
        }
    }
    AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    AccountGroup.UUID uuid = GroupUUID.make(createGroupArgs.getGroupName(), self.get().newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone()));
    AccountGroup group = new AccountGroup(createGroupArgs.getGroup(), groupId, uuid, TimeUtil.nowTs());
    group.setVisibleToAll(createGroupArgs.visibleToAll);
    if (createGroupArgs.ownerGroupId != null) {
        Optional<InternalGroup> ownerGroup = groupCache.get(createGroupArgs.ownerGroupId);
        ownerGroup.map(InternalGroup::getGroupUUID).ifPresent(group::setOwnerGroupUUID);
    }
    if (createGroupArgs.groupDescription != null) {
        group.setDescription(createGroupArgs.groupDescription);
    }
    try {
        return groupsUpdateProvider.get().addGroup(db, group, ImmutableSet.copyOf(createGroupArgs.initialMembers));
    } catch (OrmDuplicateKeyException e) {
        throw new ResourceConflictException("group '" + createGroupArgs.getGroupName() + "' already exists");
    }
}
#end_block

#method_before
@Override
public final int parseArguments(Parameters params) throws CmdLineException {
    final String n = params.getParameter(0);
    final AccountGroup group = groupCache.get(new AccountGroup.NameKey(n));
    if (group == null) {
        throw new CmdLineException(owner, "Group \"" + n + "\" does not exist");
    }
    setter.addValue(group.getId());
    return 1;
}
#method_after
@Override
public final int parseArguments(Parameters params) throws CmdLineException {
    final String n = params.getParameter(0);
    Optional<InternalGroup> group = groupCache.get(new AccountGroup.NameKey(n));
    if (!group.isPresent()) {
        throw new CmdLineException(owner, "Group \"" + n + "\" does not exist");
    }
    setter.addValue(group.get().getId());
    return 1;
}
#end_block

#method_before
private ObjectId setReadOnlyInNoteDb(Project.NameKey project, Change.Id id) throws OrmException, IOException {
    Timestamp now = TimeUtil.nowTs();
    Timestamp until = new Timestamp(now.getTime() + timeoutMs);
    ChangeUpdate update = updateFactory.create(changeControlFactory.controlFor(db.get(), project, id, internalUserFactory.create()));
    update.setReadOnlyUntil(until);
    return update.commit();
}
#method_after
private ObjectId setReadOnlyInNoteDb(Project.NameKey project, Change.Id id) throws OrmException, IOException {
    Timestamp now = TimeUtil.nowTs();
    Timestamp until = new Timestamp(now.getTime() + timeoutMs);
    ChangeUpdate update = updateFactory.create(changeNotesFactory.createChecked(db.get(), project, id), internalUserFactory.create());
    update.setReadOnlyUntil(until);
    return update.commit();
}
#end_block

#method_before
private Project.NameKey getProject(Change.Id id) throws OrmException {
    List<ChangeData> cds = queryProvider.get().setRequestedFields(ImmutableSet.of(ChangeField.PROJECT.getName())).byLegacyChangeId(id);
    Set<Project.NameKey> projects = new TreeSet<>();
    for (ChangeData cd : cds) {
        projects.add(cd.project());
    }
    if (projects.size() != 1) {
        throw new OrmException("zero or multiple projects found for change " + id + ", must specify project explicitly: " + projects);
    }
    return projects.iterator().next();
}
#method_after
private Project.NameKey getProject(Change.Id id) throws OrmException {
    List<ChangeData> cds = queryProvider.get().setRequestedFields(ChangeField.PROJECT).byLegacyChangeId(id);
    Set<Project.NameKey> projects = new TreeSet<>();
    for (ChangeData cd : cds) {
        projects.add(cd.project());
    }
    if (projects.size() != 1) {
        throw new OrmException("zero or multiple projects found for change " + id + ", must specify project explicitly: " + projects);
    }
    return projects.iterator().next();
}
#end_block

#method_before
public ChangeInfo addChangeActions(ChangeInfo to, ChangeControl ctl) {
    List<ActionVisitor> visitors = visitors();
    to.actions = toActionMap(ctl, visitors, copy(visitors, to));
    return to;
}
#method_after
public ChangeInfo addChangeActions(ChangeInfo to, ChangeNotes notes) {
    List<ActionVisitor> visitors = visitors();
    to.actions = toActionMap(notes, visitors, copy(visitors, to));
    return to;
}
#end_block

#method_before
private RevisionInfo copy(List<ActionVisitor> visitors, RevisionInfo revisionInfo) {
    if (visitors.isEmpty()) {
        return null;
    }
    // Include all fields from ChangeJson#toRevisionInfo that are not protected
    // by any ListChangesOptions.
    RevisionInfo copy = new RevisionInfo();
    copy.isCurrent = revisionInfo.isCurrent;
    copy._number = revisionInfo._number;
    copy.ref = revisionInfo.ref;
    copy.created = revisionInfo.created;
    copy.uploader = revisionInfo.uploader;
    copy.draft = revisionInfo.draft;
    copy.fetch = revisionInfo.fetch;
    copy.kind = revisionInfo.kind;
    copy.description = revisionInfo.description;
    return copy;
}
#method_after
private RevisionInfo copy(List<ActionVisitor> visitors, RevisionInfo revisionInfo) {
    if (visitors.isEmpty()) {
        return null;
    }
    // Include all fields from ChangeJson#toRevisionInfo that are not protected
    // by any ListChangesOptions.
    RevisionInfo copy = new RevisionInfo();
    copy.isCurrent = revisionInfo.isCurrent;
    copy._number = revisionInfo._number;
    copy.ref = revisionInfo.ref;
    copy.created = revisionInfo.created;
    copy.uploader = revisionInfo.uploader;
    copy.fetch = revisionInfo.fetch;
    copy.kind = revisionInfo.kind;
    copy.description = revisionInfo.description;
    return copy;
}
#end_block

#method_before
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc, List<ActionVisitor> visitors, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
    if (!rsrc.getControl().getUser().isIdentifiedUser()) {
        return ImmutableMap.of();
    }
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    ACTION: for (UiAction.Description d : uiActions.from(revisions, rsrc)) {
        ActionInfo actionInfo = new ActionInfo(d);
        for (ActionVisitor visitor : visitors) {
            if (!visitor.visit(d.getId(), actionInfo, changeInfo, revisionInfo)) {
                continue ACTION;
            }
        }
        out.put(d.getId(), actionInfo);
    }
    return out;
}
#method_after
private Map<String, ActionInfo> toActionMap(ChangeNotes notes, List<ActionVisitor> visitors, ChangeInfo changeInfo) {
    CurrentUser user = userProvider.get();
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (!user.isIdentifiedUser()) {
        return out;
    }
    Iterable<UiAction.Description> descs = uiActions.from(changeViews, changeResourceFactory.create(notes, user));
    // The followup action is a client-side only operation that does not
    // have a server side handler. It must be manually registered into the
    // resulting action map.
    Status status = notes.getChange().getStatus();
    if (status.isOpen() || status.equals(Status.MERGED)) {
        UiAction.Description descr = new UiAction.Description();
        PrivateInternals_UiActionDescription.setId(descr, "followup");
        PrivateInternals_UiActionDescription.setMethod(descr, "POST");
        descr.setTitle("Create follow-up change");
        descr.setLabel("Follow-Up");
        descs = Iterables.concat(descs, Collections.singleton(descr));
    }
    ACTION: for (UiAction.Description d : descs) {
        ActionInfo actionInfo = new ActionInfo(d);
        for (ActionVisitor visitor : visitors) {
            if (!visitor.visit(d.getId(), actionInfo, changeInfo)) {
                continue ACTION;
            }
        }
        out.put(d.getId(), actionInfo);
    }
    return out;
}
#end_block

#method_before
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc, List<ActionVisitor> visitors, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
    if (!rsrc.getControl().getUser().isIdentifiedUser()) {
        return ImmutableMap.of();
    }
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    ACTION: for (UiAction.Description d : uiActions.from(revisions, rsrc)) {
        ActionInfo actionInfo = new ActionInfo(d);
        for (ActionVisitor visitor : visitors) {
            if (!visitor.visit(d.getId(), actionInfo, changeInfo, revisionInfo)) {
                continue ACTION;
            }
        }
        out.put(d.getId(), actionInfo);
    }
    return out;
}
#method_after
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc, List<ActionVisitor> visitors, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
    if (!rsrc.getUser().isIdentifiedUser()) {
        return ImmutableMap.of();
    }
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    ACTION: for (UiAction.Description d : uiActions.from(revisions, rsrc)) {
        ActionInfo actionInfo = new ActionInfo(d);
        for (ActionVisitor visitor : visitors) {
            if (!visitor.visit(d.getId(), actionInfo, changeInfo, revisionInfo)) {
                continue ACTION;
            }
        }
        out.put(d.getId(), actionInfo);
    }
    return out;
}
#end_block

#method_before
public AuthResult authenticate(AuthRequest who) throws AccountException, IOException {
    who = realm.authenticate(who);
    try {
        try (ReviewDb db = schema.open()) {
            ExternalId id = externalIds.get(who.getExternalIdKey());
            if (id == null) {
                // 
                return create(db, who);
            }
            // Account exists
            Account act = byIdCache.get(id.accountId()).getAccount();
            if (!act.isActive()) {
                throw new AccountException("Authentication error, account inactive");
            }
            // return the identity to the caller.
            update(who, id);
            return new AuthResult(id.accountId(), who.getExternalIdKey(), false);
        }
    } catch (OrmException | ConfigInvalidException e) {
        throw new AccountException("Authentication error", e);
    }
}
#method_after
public AuthResult authenticate(AuthRequest who) throws AccountException, IOException {
    who = realm.authenticate(who);
    try {
        try (ReviewDb db = schema.open()) {
            ExternalId id = externalIds.get(who.getExternalIdKey());
            if (id == null) {
                // 
                return create(db, who);
            }
            // Account exists
            Account act = byIdCache.get(id.accountId()).getAccount();
            if (autoUpdateAccountActiveStatus && who.authProvidesAccountActiveStatus()) {
                if (who.isActive() && !act.isActive()) {
                    try {
                        setInactiveFlag.activate(act.getId());
                        act = byIdCache.get(id.accountId()).getAccount();
                    } catch (ResourceNotFoundException e) {
                        throw new AccountException("Unable to activate account " + act.getId(), e);
                    }
                } else if (!who.isActive() && act.isActive()) {
                    try {
                        setInactiveFlag.deactivate(act.getId());
                        act = byIdCache.get(id.accountId()).getAccount();
                    } catch (RestApiException e) {
                        throw new AccountException("Unable to deactivate account " + act.getId(), e);
                    }
                }
            }
            if (!act.isActive()) {
                throw new AccountException("Authentication error, account inactive");
            }
            // return the identity to the caller.
            update(who, id);
            return new AuthResult(id.accountId(), who.getExternalIdKey(), false);
        }
    } catch (OrmException | ConfigInvalidException e) {
        throw new AccountException("Authentication error", e);
    }
}
#end_block

#method_before
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException, IOException, ConfigInvalidException {
    Account.Id newId = new Account.Id(sequences.nextAccountId());
    ExternalId extId = ExternalId.createWithEmail(who.getExternalIdKey(), newId, who.getEmailAddress());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && !accounts.hasAnyAccount();
    Account account;
    try {
        AccountsUpdate accountsUpdate = accountsUpdateFactory.create();
        account = accountsUpdate.insert(newId, a -> {
            a.setFullName(who.getDisplayName());
            a.setPreferredEmail(extId.email());
        });
        ExternalId existingExtId = externalIds.get(extId.key());
        if (existingExtId != null && !existingExtId.accountId().equals(extId.accountId())) {
            // external ID is assigned to another account, do not overwrite
            accountsUpdate.delete(account);
            throw new AccountException("Cannot assign external ID \"" + extId.key().get() + "\" to account " + newId + "; external ID already in use.");
        }
        externalIdsUpdateFactory.create().upsert(extId);
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    IdentifiedUser user = userFactory.create(newId);
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        GroupsUpdate groupsUpdate = groupsUpdateProvider.get();
        // The user initiated this request by logging in. -> Attribute all modifications to that user.
        groupsUpdate.setCurrentUser(user);
        try {
            groupsUpdate.addGroupMember(db, uuid, newId);
        } catch (NoSuchGroupException e) {
            throw new AccountException(String.format("Group %s not found", uuid));
        }
    }
    if (who.getUserName() != null) {
        // 
        try {
            changeUserNameFactory.create(user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(account, extId, message, e, true);
        }
    }
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.key(), true);
}
#method_after
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException, IOException, ConfigInvalidException {
    Account.Id newId = new Account.Id(sequences.nextAccountId());
    ExternalId extId = ExternalId.createWithEmail(who.getExternalIdKey(), newId, who.getEmailAddress());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && !accounts.hasAnyAccount();
    Account account;
    try {
        AccountsUpdate accountsUpdate = accountsUpdateFactory.create();
        account = accountsUpdate.insert(newId, a -> {
            a.setFullName(who.getDisplayName());
            a.setPreferredEmail(extId.email());
        });
        ExternalId existingExtId = externalIds.get(extId.key());
        if (existingExtId != null && !existingExtId.accountId().equals(extId.accountId())) {
            // external ID is assigned to another account, do not overwrite
            accountsUpdate.delete(account);
            throw new AccountException("Cannot assign external ID \"" + extId.key().get() + "\" to account " + newId + "; external ID already in use.");
        }
        externalIdsUpdateFactory.create().upsert(extId);
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    IdentifiedUser user = userFactory.create(newId);
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        // The user initiated this request by logging in. -> Attribute all modifications to that user.
        GroupsUpdate groupsUpdate = groupsUpdateFactory.create(user);
        try {
            groupsUpdate.addGroupMember(db, uuid, newId);
        } catch (NoSuchGroupException e) {
            throw new AccountException(String.format("Group %s not found", uuid));
        }
    }
    if (who.getUserName() != null) {
        // 
        try {
            changeUserNameFactory.create(user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(account, extId, message, e, true);
        }
    }
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.key(), true);
}
#end_block

#method_before
@Override
public ServerInfo apply(ConfigResource rsrc) throws MalformedURLException {
    ServerInfo info = new ServerInfo();
    info.auth = getAuthInfo(authConfig, realm);
    info.change = getChangeInfo(config);
    info.download = getDownloadInfo(downloadSchemes, downloadCommands, cloneCommands, archiveFormats);
    info.gerrit = getGerritInfo(config, allProjectsName, allUsersName);
    info.noteDbEnabled = toBoolean(isNoteDbEnabled());
    info.plugin = getPluginInfo();
    if (Files.exists(sitePaths.site_theme)) {
        info.defaultTheme = "/static/" + SitePaths.THEME_FILENAME;
    }
    info.sshd = getSshdInfo(config);
    info.suggest = getSuggestInfo(config);
    Map<String, String> urlAliases = getUrlAliasesInfo(config);
    info.urlAliases = !urlAliases.isEmpty() ? urlAliases : null;
    info.user = getUserInfo(anonymousCowardName);
    info.receive = getReceiveInfo();
    return info;
}
#method_after
@Override
public ServerInfo apply(ConfigResource rsrc) throws MalformedURLException {
    ServerInfo info = new ServerInfo();
    info.accounts = getAccountsInfo(accountVisibilityProvider);
    info.auth = getAuthInfo(authConfig, realm);
    info.change = getChangeInfo(config);
    info.download = getDownloadInfo(downloadSchemes, downloadCommands, cloneCommands, archiveFormats);
    info.gerrit = getGerritInfo(config, allProjectsName, allUsersName);
    info.noteDbEnabled = toBoolean(isNoteDbEnabled());
    info.plugin = getPluginInfo();
    if (Files.exists(sitePaths.site_theme)) {
        info.defaultTheme = "/static/" + SitePaths.THEME_FILENAME;
    }
    info.sshd = getSshdInfo(config);
    info.suggest = getSuggestInfo(config);
    Map<String, String> urlAliases = getUrlAliasesInfo(config);
    info.urlAliases = !urlAliases.isEmpty() ? urlAliases : null;
    info.user = getUserInfo(anonymousCowardName);
    info.receive = getReceiveInfo();
    return info;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = ctx.getDb();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new ResourceConflictException(String.format("Cannot create new patch set of change %s because it is %s", change.getId(), ChangeUtil.status(change)));
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        PatchSet prevPs = psUtil.current(db, ctx.getNotes());
        if (prevPs != null) {
            newGroups = prevPs.getGroups();
        }
    }
    patchSet = psUtil.insert(db, ctx.getRevWalk(), ctx.getUpdate(psId), psId, commitId, draft, newGroups, null, description);
    if (notify != NotifyHandling.NONE) {
        oldReviewers = approvalsUtil.getReviewers(db, ctx.getNotes());
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), ctx.getWhen(), message, ChangeMessagesUtil.uploadedPatchSetTag(change.isWorkInProgress()));
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    if (copyApprovals) {
        approvalCopier.copyInReviewDb(db, ctx.getNotes(), ctx.getUser(), patchSet, ctx.getRevWalk(), ctx.getRepoView().getConfig());
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = ctx.getDb();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new ResourceConflictException(String.format("Cannot create new patch set of change %s because it is %s", change.getId(), ChangeUtil.status(change)));
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        PatchSet prevPs = psUtil.current(db, ctx.getNotes());
        if (prevPs != null) {
            newGroups = prevPs.getGroups();
        }
    }
    patchSet = psUtil.insert(db, ctx.getRevWalk(), ctx.getUpdate(psId), psId, commitId, newGroups, null, description);
    if (notify != NotifyHandling.NONE) {
        oldReviewers = approvalsUtil.getReviewers(db, ctx.getNotes());
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), ctx.getWhen(), message, ChangeMessagesUtil.uploadedPatchSetTag(change.isWorkInProgress()));
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    if (!allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    if (copyApprovals) {
        approvalCopier.copyInReviewDb(db, ctx.getNotes(), ctx.getUser(), patchSet, ctx.getRevWalk(), ctx.getRepoView().getConfig());
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
public static Predicate<ChangeData> create(Arguments args, String value, Change c) throws QueryParseException, OrmException {
    ChangeDataCache changeDataCache = new ChangeDataCache(c, args.db, args.changeDataFactory, args.projectCache);
    List<String> files = listFiles(c, args, changeDataCache);
    if (3 + files.size() > args.indexConfig.maxTerms()) {
        // later on in the query parsing.
        throw new QueryParseException(TOO_MANY_FILES);
    }
    List<Predicate<ChangeData>> filePredicates = new ArrayList<>(files.size());
    for (String file : files) {
        filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
    }
    List<Predicate<ChangeData>> and = new ArrayList<>(5);
    and.add(new ProjectPredicate(c.getProject().get()));
    and.add(new RefPredicate(c.getDest().get()));
    and.add(Predicate.not(new LegacyChangeIdPredicate(c.getId())));
    and.add(Predicate.or(filePredicates));
    and.add(new CheckConflict(ChangeQueryBuilder.FIELD_CONFLICTS, value, args, c, changeDataCache));
    return Predicate.and(and);
}
#method_after
public static Predicate<ChangeData> create(Arguments args, String value, Change c) throws QueryParseException, OrmException {
    ChangeData cd;
    List<String> files;
    try {
        cd = args.changeDataFactory.create(args.db.get(), c);
        files = cd.currentFilePaths();
    } catch (IOException e) {
        throw new OrmException(e);
    }
    if (3 + files.size() > args.indexConfig.maxTerms()) {
        // later on in the query parsing.
        throw new QueryParseException(TOO_MANY_FILES);
    }
    List<Predicate<ChangeData>> filePredicates = new ArrayList<>(files.size());
    for (String file : files) {
        filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
    }
    List<Predicate<ChangeData>> and = new ArrayList<>(5);
    and.add(new ProjectPredicate(c.getProject().get()));
    and.add(new RefPredicate(c.getDest().get()));
    and.add(Predicate.not(new LegacyChangeIdPredicate(c.getId())));
    and.add(Predicate.or(filePredicates));
    ChangeDataCache changeDataCache = new ChangeDataCache(cd, args.projectCache);
    and.add(new CheckConflict(ChangeQueryBuilder.FIELD_CONFLICTS, value, args, c, changeDataCache));
    return Predicate.and(and);
}
#end_block

#method_before
@Override
public boolean match(ChangeData object) throws OrmException {
    Change otherChange = object.change();
    if (otherChange == null || !otherChange.getDest().equals(c.getDest())) {
        return false;
    }
    SubmitTypeRecord str = object.submitTypeRecord();
    if (!str.isOk()) {
        return false;
    }
    ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
    ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, str.type, changeDataCache.getProjectState().isUseContentMerge());
    Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
    if (conflicts != null) {
        return conflicts;
    }
    try (Repository repo = args.repoManager.openRepository(otherChange.getProject());
        CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
        conflicts = !args.submitDryRun.run(str.type, repo, rw, otherChange.getDest(), changeDataCache.getTestAgainst(), other, getAlreadyAccepted(repo, rw));
        args.conflictsCache.put(conflictsKey, conflicts);
        return conflicts;
    } catch (IntegrationException | NoSuchProjectException | IOException e) {
        throw new OrmException(e);
    }
}
#method_after
@Override
public boolean match(ChangeData object) throws OrmException {
    Change otherChange = object.change();
    if (otherChange == null || !otherChange.getDest().equals(dest)) {
        return false;
    }
    SubmitTypeRecord str = object.submitTypeRecord();
    if (!str.isOk()) {
        return false;
    }
    ProjectState projectState;
    try {
        projectState = changeDataCache.getProjectState();
    } catch (NoSuchProjectException e) {
        return false;
    }
    ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
    ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, str.type, projectState.isUseContentMerge());
    Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
    if (conflicts != null) {
        return conflicts;
    }
    try (Repository repo = args.repoManager.openRepository(otherChange.getProject());
        CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
        conflicts = !args.submitDryRun.run(str.type, repo, rw, otherChange.getDest(), changeDataCache.getTestAgainst(), other, getAlreadyAccepted(repo, rw));
        args.conflictsCache.put(conflictsKey, conflicts);
        return conflicts;
    } catch (IntegrationException | NoSuchProjectException | IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
protected ObjectId getTestAgainst() throws OrmException {
    if (testAgainst == null) {
        testAgainst = ObjectId.fromString(changeDataFactory.create(db.get(), change).currentPatchSet().getRevision().get());
    }
    return testAgainst;
}
#method_after
ObjectId getTestAgainst() throws OrmException {
    if (testAgainst == null) {
        testAgainst = ObjectId.fromString(cd.currentPatchSet().getRevision().get());
    }
    return testAgainst;
}
#end_block

#method_before
protected ProjectState getProjectState() {
    if (projectState == null) {
        projectState = projectCache.get(change.getProject());
        if (projectState == null) {
            throw new IllegalStateException(new NoSuchProjectException(change.getProject()));
        }
    }
    return projectState;
}
#method_after
ProjectState getProjectState() throws NoSuchProjectException {
    if (projectState == null) {
        projectState = projectCache.get(cd.project());
        if (projectState == null) {
            throw new NoSuchProjectException(cd.project());
        }
    }
    return projectState;
}
#end_block

#method_before
private AccountState missing(Account.Id accountId) {
    Account account = new Account(accountId, TimeUtil.nowTs());
    account.setActive(false);
    Set<AccountGroup.UUID> anon = ImmutableSet.of();
    return new AccountState(allUsersName, account, anon, Collections.emptySet(), new HashMap<ProjectWatchKey, Set<NotifyType>>());
}
#method_after
private AccountState missing(Account.Id accountId) {
    Account account = new Account(accountId, TimeUtil.nowTs());
    account.setActive(false);
    return new AccountState(allUsersName, account, Collections.emptySet(), new HashMap<>());
}
#end_block

#method_before
@Override
public Optional<AccountState> load(Account.Id key) throws Exception {
    try (ReviewDb db = schema.open()) {
        return load(db, key);
    }
}
#method_after
@Override
public Optional<AccountState> load(Account.Id who) throws Exception {
    Account account = accounts.get(who);
    if (account == null) {
        return Optional.empty();
    }
    try {
        account.setGeneralPreferences(loader.load(who));
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Cannot load GeneralPreferences for " + who + " (using default)", e);
        account.setGeneralPreferences(GeneralPreferencesInfo.defaults());
    }
    return Optional.of(new AccountState(allUsersName, account, externalIds.byAccount(who), watchConfig.get().getProjectWatches(who)));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Publish post(ChangeResource parent) throws RestApiException {
    return publish;
}
#method_after
@Override
public Publish post(ChangeResource parent) throws RestApiException {
    return publish;
}
#end_block

#method_before
@Override
protected Response<?> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, PublishChangeEditInput in) throws IOException, OrmException, RestApiException, UpdateException, ConfigInvalidException {
    CreateChange.checkValidCLA(rsrc.getControl().getProjectControl());
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getNotes(), rsrc.getUser());
    if (!edit.isPresent()) {
        throw new ResourceConflictException(String.format("no edit exists for change %s", rsrc.getChange().getChangeId()));
    }
    if (in == null) {
        in = new PublishChangeEditInput();
    }
    editUtil.publish(updateFactory, rsrc.getControl(), edit.get(), in.notify, notifyUtil.resolveAccounts(in.notifyDetails));
    return Response.none();
}
#method_after
@Override
protected Response<?> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, PublishChangeEditInput in) throws IOException, OrmException, RestApiException, UpdateException, ConfigInvalidException, NoSuchProjectException {
    contributorAgreementsChecker.check(rsrc.getProject(), rsrc.getUser());
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getNotes(), rsrc.getUser());
    if (!edit.isPresent()) {
        throw new ResourceConflictException(String.format("no edit exists for change %s", rsrc.getChange().getChangeId()));
    }
    if (in == null) {
        in = new PublishChangeEditInput();
    }
    editUtil.publish(updateFactory, rsrc.getNotes(), rsrc.getUser(), edit.get(), in.notify, notifyUtil.resolveAccounts(in.notifyDetails));
    return Response.none();
}
#end_block

#method_before
private static Base create(ChangeControl ctl, PatchSet ps) {
    if (ctl == null) {
        return null;
    }
    return new AutoValue_RebaseUtil_Base(ctl, ps);
}
#method_after
private static Base create(ChangeNotes notes, PatchSet ps) {
    if (notes == null) {
        return null;
    }
    return new AutoValue_RebaseUtil_Base(notes, ps);
}
#end_block

#method_before
Base parseBase(RevisionResource rsrc, String base) throws OrmException {
    ReviewDb db = dbProvider.get();
    // Try parsing the base as a ref string.
    PatchSet.Id basePatchSetId = PatchSet.Id.fromRef(base);
    if (basePatchSetId != null) {
        Change.Id baseChangeId = basePatchSetId.getParentKey();
        ChangeControl baseCtl = controlFor(rsrc, baseChangeId);
        if (baseCtl != null) {
            return Base.create(controlFor(rsrc, basePatchSetId.getParentKey()), psUtil.get(db, baseCtl.getNotes(), basePatchSetId));
        }
    }
    // Try parsing base as a change number (assume current patch set).
    Integer baseChangeId = Ints.tryParse(base);
    if (baseChangeId != null) {
        ChangeControl baseCtl = controlFor(rsrc, new Change.Id(baseChangeId));
        if (baseCtl != null) {
            return Base.create(baseCtl, psUtil.current(db, baseCtl.getNotes()));
        }
    }
    // Try parsing as SHA-1.
    Base ret = null;
    for (ChangeData cd : queryProvider.get().byProjectCommit(rsrc.getProject(), base)) {
        for (PatchSet ps : cd.patchSets()) {
            if (!ps.getRevision().matches(base)) {
                continue;
            }
            if (ret == null || ret.patchSet().getId().get() < ps.getId().get()) {
                ret = Base.create(rsrc.getControl().getProjectControl().controlFor(cd.notes()), ps);
            }
        }
    }
    return ret;
}
#method_after
Base parseBase(RevisionResource rsrc, String base) throws OrmException {
    ReviewDb db = dbProvider.get();
    // Try parsing the base as a ref string.
    PatchSet.Id basePatchSetId = PatchSet.Id.fromRef(base);
    if (basePatchSetId != null) {
        Change.Id baseChangeId = basePatchSetId.getParentKey();
        ChangeNotes baseNotes = notesFor(rsrc, baseChangeId);
        if (baseNotes != null) {
            return Base.create(notesFor(rsrc, basePatchSetId.getParentKey()), psUtil.get(db, baseNotes, basePatchSetId));
        }
    }
    // Try parsing base as a change number (assume current patch set).
    Integer baseChangeId = Ints.tryParse(base);
    if (baseChangeId != null) {
        ChangeNotes baseNotes = notesFor(rsrc, new Change.Id(baseChangeId));
        if (baseNotes != null) {
            return Base.create(baseNotes, psUtil.current(db, baseNotes));
        }
    }
    // Try parsing as SHA-1.
    Base ret = null;
    for (ChangeData cd : queryProvider.get().byProjectCommit(rsrc.getProject(), base)) {
        for (PatchSet ps : cd.patchSets()) {
            if (!ps.getRevision().matches(base)) {
                continue;
            }
            if (ret == null || ret.patchSet().getId().get() < ps.getId().get()) {
                ret = Base.create(cd.notes(), ps);
            }
        }
    }
    return ret;
}
#end_block

#method_before
public static MailRecipients getRecipientsFromFooters(ReviewDb db, AccountResolver accountResolver, boolean draftPatchSet, List<FooterLine> footerLines) throws OrmException, IOException {
    MailRecipients recipients = new MailRecipients();
    if (!draftPatchSet) {
        for (FooterLine footerLine : footerLines) {
            try {
                if (isReviewer(footerLine)) {
                    recipients.reviewers.add(toAccountId(db, accountResolver, footerLine.getValue().trim()));
                } else if (footerLine.matches(FooterKey.CC)) {
                    recipients.cc.add(toAccountId(db, accountResolver, footerLine.getValue().trim()));
                }
            } catch (NoSuchAccountException e) {
                continue;
            }
        }
    }
    return recipients;
}
#method_after
public static MailRecipients getRecipientsFromFooters(AccountResolver accountResolver, List<FooterLine> footerLines) throws OrmException, IOException {
    MailRecipients recipients = new MailRecipients();
    for (FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                recipients.reviewers.add(toAccountId(accountResolver, footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                recipients.cc.add(toAccountId(accountResolver, footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    return recipients;
}
#end_block

#method_before
private static Account.Id toAccountId(ReviewDb db, AccountResolver accountResolver, String nameOrEmail) throws OrmException, NoSuchAccountException, IOException {
    Account a = accountResolver.findByNameOrEmail(db, nameOrEmail);
    if (a == null) {
        throw new NoSuchAccountException("\"" + nameOrEmail + "\" is not registered");
    }
    return a.getId();
}
#method_after
private static Account.Id toAccountId(AccountResolver accountResolver, String nameOrEmail) throws OrmException, NoSuchAccountException, IOException {
    Account a = accountResolver.findByNameOrEmail(nameOrEmail);
    if (a == null) {
        throw new NoSuchAccountException("\"" + nameOrEmail + "\" is not registered");
    }
    return a.getId();
}
#end_block

#method_before
public Response<SshKeyInfo> apply(IdentifiedUser user, Input input) throws BadRequestException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (input.raw == null) {
        throw new BadRequestException("SSH public key missing");
    }
    final RawInput rawKey = input.raw;
    String sshPublicKey = new ByteSource() {

        @Override
        public InputStream openStream() throws IOException {
            return rawKey.getInputStream();
        }
    }.asCharSource(UTF_8).read();
    try {
        AccountSshKey sshKey = authorizedKeys.addKey(user.getAccountId(), sshPublicKey);
        try {
            addKeyFactory.create(user, sshKey).send();
        } catch (EmailException e) {
            log.error("Cannot send SSH key added message to " + user.getAccount().getPreferredEmail(), e);
        }
        sshKeyCache.evict(user.getUserName());
        return Response.<SshKeyInfo>created(GetSshKeys.newSshKeyInfo(sshKey));
    } catch (InvalidSshKeyException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
public Response<SshKeyInfo> apply(AccountResource rsrc, SshKeyInput input) throws AuthException, BadRequestException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    return apply(rsrc.getUser(), input);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public DynamicBean getDynamicBean(Object bean, DynamicBean dynamicBean) {
    ClassLoader coreCl = getClass().getClassLoader();
    ClassLoader beanCl = bean.getClass().getClassLoader();
    if (beanCl != coreCl) {
        // bean from a plugin?
        ClassLoader dynamicBeanCl = dynamicBean.getClass().getClassLoader();
        if (beanCl != dynamicBeanCl) {
            // in a different plugin?
            ClassLoader mergedCL = new DelegatingClassLoader(beanCl, dynamicBeanCl);
            try {
                return injector.createChildInjector().getInstance((Class<DynamicOptions.DynamicBean>) mergedCL.loadClass(dynamicBean.getClass().getCanonicalName()));
            } catch (ClassNotFoundException e) {
                throw new RuntimeException(e);
            }
        }
    }
    return dynamicBean;
}
#method_after
@SuppressWarnings("unchecked")
public DynamicBean getDynamicBean(Object bean, DynamicBean dynamicBean) {
    ClassLoader coreCl = getClass().getClassLoader();
    ClassLoader beanCl = bean.getClass().getClassLoader();
    ClassLoader loader = beanCl;
    if (beanCl != coreCl) {
        // bean from a plugin?
        ClassLoader dynamicBeanCl = dynamicBean.getClass().getClassLoader();
        if (beanCl != dynamicBeanCl) {
            // in a different plugin?
            loader = getMergedClassLoader(beanCl, dynamicBeanCl);
        }
    }
    String className = null;
    if (dynamicBean instanceof ClassNameProvider) {
        className = ((ClassNameProvider) dynamicBean).getClassName();
    } else if (loader != beanCl) {
        // in a different plugin?
        className = dynamicBean.getClass().getCanonicalName();
    }
    if (className != null) {
        try {
            List<Module> modules = new ArrayList<>();
            Injector modulesInjector = injector;
            if (dynamicBean instanceof ModulesClassNamesProvider) {
                modulesInjector = injector.createChildInjector();
                for (String moduleName : ((ModulesClassNamesProvider) dynamicBean).getModulesClassNames()) {
                    Class<Module> mClass = (Class<Module>) loader.loadClass(moduleName);
                    modules.add(modulesInjector.getInstance(mClass));
                }
            }
            return modulesInjector.createChildInjector(modules).getInstance((Class<DynamicOptions.DynamicBean>) loader.loadClass(className));
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
    }
    return dynamicBean;
}
#end_block

#method_before
@Override
public List<GroupInfo> apply(TopLevelResource resource) throws BadRequestException, MethodNotAllowedException, OrmException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    GroupIndex searchIndex = indexes.getSearchIndex();
    if (searchIndex == null) {
        throw new MethodNotAllowedException("no group index");
    }
    if (start != 0) {
        queryProcessor.setStart(start);
    }
    if (limit != 0) {
        queryProcessor.setUserProvidedLimit(limit);
    }
    try {
        QueryResult<AccountGroup> result = queryProcessor.query(queryBuilder.parse(query));
        List<AccountGroup> groups = result.entities();
        ArrayList<GroupInfo> groupInfos = Lists.newArrayListWithCapacity(groups.size());
        json.addOptions(options);
        for (AccountGroup group : groups) {
            groupInfos.add(json.format(GroupDescriptions.forAccountGroup(group)));
        }
        if (!groupInfos.isEmpty() && result.more()) {
            groupInfos.get(groupInfos.size() - 1)._moreGroups = true;
        }
        return groupInfos;
    } catch (QueryParseException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
public List<GroupInfo> apply(TopLevelResource resource) throws BadRequestException, MethodNotAllowedException, OrmException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (queryProcessor.isDisabled()) {
        throw new MethodNotAllowedException("query disabled");
    }
    if (start != 0) {
        queryProcessor.setStart(start);
    }
    if (limit != 0) {
        queryProcessor.setUserProvidedLimit(limit);
    }
    try {
        QueryResult<InternalGroup> result = queryProcessor.query(queryBuilder.parse(query));
        List<InternalGroup> groups = result.entities();
        ArrayList<GroupInfo> groupInfos = Lists.newArrayListWithCapacity(groups.size());
        json.addOptions(options);
        for (InternalGroup group : groups) {
            groupInfos.add(json.format(new InternalGroupDescription(group)));
        }
        if (!groupInfos.isEmpty() && result.more()) {
            groupInfos.get(groupInfos.size() - 1)._moreGroups = true;
        }
        return groupInfos;
    } catch (QueryParseException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    final ConfigSection dbs = new ConfigSection(cfg, "database");
    b.append("jdbc:mysql://");
    b.append(hostname(dbs.optional("hostname")));
    b.append(port(dbs.optional("port")));
    b.append("/");
    b.append(dbs.required("database"));
    return b.toString();
}
#method_after
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    final ConfigSection dbs = new ConfigSection(cfg, "database");
    b.append("jdbc:mysql://");
    b.append(hostname(dbs.optional("hostname")));
    b.append(port(dbs.optional("port")));
    b.append("/");
    b.append(dbs.required("database"));
    // See https://stackoverflow.com/questions/42084633/table-name-pattern-can-not-be-null-or-empty-in-java
    b.append("?nullNamePatternMatchesAll=true");
    return b.toString();
}
#end_block

#method_before
@Override
public List<CachedChange> load(Project.NameKey key) throws Exception {
    try (ManualRequestContext ctx = requestContext.open()) {
        List<ChangeData> cds = queryProvider.get().setRequestedFields(ImmutableSet.of(ChangeField.CHANGE.getName(), ChangeField.REVIEWER.getName())).byProject(key);
        List<CachedChange> result = new ArrayList<>(cds.size());
        for (ChangeData cd : cds) {
            result.add(new AutoValue_SearchingChangeCacheImpl_CachedChange(cd.change(), cd.getReviewers()));
        }
        return Collections.unmodifiableList(result);
    }
}
#method_after
@Override
public List<CachedChange> load(Project.NameKey key) throws Exception {
    try (ManualRequestContext ctx = requestContext.open()) {
        List<ChangeData> cds = queryProvider.get().setRequestedFields(ChangeField.CHANGE, ChangeField.REVIEWER).byProject(key);
        List<CachedChange> result = new ArrayList<>(cds.size());
        for (ChangeData cd : cds) {
            result.add(new AutoValue_SearchingChangeCacheImpl_CachedChange(cd.change(), cd.getReviewers()));
        }
        return Collections.unmodifiableList(result);
    }
}
#end_block

#method_before
private void sortAndFillEvents(Change change, Change noteDbChange, ImmutableCollection<PatchSet> patchSets, List<Event> events, Integer minPsNum) {
    Event finalUpdates = new FinalUpdatesEvent(change, noteDbChange, patchSets);
    events.add(finalUpdates);
    setPostSubmitDeps(events);
    new EventSorter(events).sort();
    // Ensure the first event in the list creates the change, setting the author and any required
    // footers.
    Event first = events.get(0);
    if (first instanceof PatchSetEvent && change.getOwner().equals(first.user)) {
        ((PatchSetEvent) first).createChange = true;
    } else {
        events.add(0, new CreateChangeEvent(change, minPsNum));
    }
    // Final pass to correct some inconsistencies.
    // 
    // First, fill in any missing patch set IDs using the latest patch set of the change at the time
    // of the event, because NoteDb can't represent actions with no associated patch set ID. This
    // workaround is as if a user added a ChangeMessage on the change by replying from the latest
    // patch set.
    // 
    // Start with the first patch set that actually exists. If there are no patch sets at all,
    // minPsNum will be null, so just bail and use 1 as the patch set ID. The corresponding patch
    // set won't exist, but this change is probably corrupt anyway, as deleting the last draft patch
    // set should have deleted the whole change.
    // 
    // Second, ensure timestamps are nondecreasing, by copying the previous timestamp if this
    // happens. This assumes that the only way this can happen is due to dependency constraints, and
    // it is ok to give an event the same timestamp as one of its dependencies.
    int ps = firstNonNull(minPsNum, 1);
    for (int i = 0; i < events.size(); i++) {
        Event e = events.get(i);
        if (e.psId == null) {
            e.psId = new PatchSet.Id(change.getId(), ps);
        } else {
            ps = Math.max(ps, e.psId.get());
        }
        if (i > 0) {
            Event p = events.get(i - 1);
            if (e.when.before(p.when)) {
                e.when = p.when;
            }
        }
    }
}
#method_after
private void sortAndFillEvents(Change change, Change noteDbChange, ImmutableCollection<PatchSet> patchSets, List<Event> events, Integer minPsNum) {
    Event finalUpdates = new FinalUpdatesEvent(change, noteDbChange, patchSets);
    events.add(finalUpdates);
    setPostSubmitDeps(events);
    new EventSorter(events).sort();
    // Ensure the first event in the list creates the change, setting the author and any required
    // footers.
    Event first = events.get(0);
    if (first instanceof PatchSetEvent && change.getOwner().equals(first.user)) {
        ((PatchSetEvent) first).createChange = true;
    } else {
        events.add(0, new CreateChangeEvent(change, minPsNum));
    }
    // Final pass to correct some inconsistencies.
    // 
    // First, fill in any missing patch set IDs using the latest patch set of the change at the time
    // of the event, because NoteDb can't represent actions with no associated patch set ID. This
    // workaround is as if a user added a ChangeMessage on the change by replying from the latest
    // patch set.
    // 
    // Start with the first patch set that actually exists. If there are no patch sets at all,
    // minPsNum will be null, so just bail and use 1 as the patch set ID.
    // 
    // Second, ensure timestamps are nondecreasing, by copying the previous timestamp if this
    // happens. This assumes that the only way this can happen is due to dependency constraints, and
    // it is ok to give an event the same timestamp as one of its dependencies.
    int ps = firstNonNull(minPsNum, 1);
    for (int i = 0; i < events.size(); i++) {
        Event e = events.get(i);
        if (e.psId == null) {
            e.psId = new PatchSet.Id(change.getId(), ps);
        } else {
            ps = Math.max(ps, e.psId.get());
        }
        if (i > 0) {
            Event p = events.get(i - 1);
            if (e.when.before(p.when)) {
                e.when = p.when;
            }
        }
    }
}
#end_block

#method_before
public String getRefName() {
    return refName;
}
#method_after
String getRefName() {
    return refName;
}
#end_block

#method_before
public ProjectControl getProjectControl() {
    return projectControl;
}
#method_after
ProjectControl getProjectControl() {
    return projectControl;
}
#end_block

#method_before
public CurrentUser getUser() {
    return projectControl.getUser();
}
#method_after
CurrentUser getUser() {
    return projectControl.getUser();
}
#end_block

#method_before
public RefControl forUser(CurrentUser who) {
    ProjectControl newCtl = projectControl.forUser(who);
    if (relevant.isUserSpecific()) {
        return newCtl.controlForRef(getRefName());
    }
    return new RefControl(newCtl, getRefName(), relevant);
}
#method_after
RefControl forUser(CurrentUser who) {
    ProjectControl newCtl = projectControl.forUser(who);
    if (relevant.isUserSpecific()) {
        return newCtl.controlForRef(getRefName());
    }
    return new RefControl(newCtl, getRefName(), relevant);
}
#end_block

#method_before
public boolean isOwner() {
    if (owner == null) {
        if (canPerform(Permission.OWNER)) {
            owner = true;
        } else {
            owner = projectControl.isOwner();
        }
    }
    return owner;
}
#method_after
boolean isOwner() {
    if (owner == null) {
        if (canPerform(Permission.OWNER)) {
            owner = true;
        } else {
            owner = projectControl.isOwner();
        }
    }
    return owner;
}
#end_block

#method_before
public boolean isBlocked(String permissionName) {
    return !doCanPerform(permissionName, false, true);
}
#method_after
boolean isBlocked(String permissionName) {
    return !doCanPerform(permissionName, false, true);
}
#end_block

#method_before
@Override
public ForChange change(ChangeData cd) {
    try {
        return cd.changeControl().forUser(getUser()).asForChange(cd, db);
    } catch (OrmException e) {
        return FailedPermissionBackend.change("unavailable", e);
    }
}
#method_after
@Override
public ForChange change(ChangeData cd) {
    try {
        // TODO(hiesel) Force callers to call database() and use db instead of cd.db()
        return getProjectControl().controlFor(cd.db(), cd.change()).asForChange(cd, Providers.of(cd.db()));
    } catch (OrmException e) {
        return FailedPermissionBackend.change("unavailable", e);
    }
}
#end_block

#method_before
private boolean can(RefPermission perm) throws PermissionBackendException {
    switch(perm) {
        case READ:
            return isVisible();
        case CREATE:
            // TODO This isn't an accurate test.
            return canPerform(perm.permissionName().get());
        case DELETE:
            return canDelete();
        case UPDATE:
            return canUpdate();
        case FORCE_UPDATE:
            return canForceUpdate();
        case FORGE_AUTHOR:
            return canForgeAuthor();
        case FORGE_COMMITTER:
            return canForgeCommitter();
        case FORGE_SERVER:
            return canForgeGerritServerIdentity();
        case MERGE:
            return canUploadMerges();
        case CREATE_CHANGE:
            return canUpload();
        case UPDATE_BY_SUBMIT:
            return projectControl.controlForRef("refs/for/" + getRefName()).canSubmit(true);
        case SKIP_VALIDATION:
            return canForgeAuthor() && canForgeCommitter() && canForgeGerritServerIdentity() && canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
private boolean can(RefPermission perm) throws PermissionBackendException {
    switch(perm) {
        case READ:
            return isVisible();
        case CREATE:
            // TODO This isn't an accurate test.
            return canPerform(perm.permissionName().get());
        case DELETE:
            return canDelete();
        case UPDATE:
            return canUpdate();
        case FORCE_UPDATE:
            return canForceUpdate();
        case SET_HEAD:
            return projectControl.isOwner();
        case FORGE_AUTHOR:
            return canForgeAuthor();
        case FORGE_COMMITTER:
            return canForgeCommitter();
        case FORGE_SERVER:
            return canForgeGerritServerIdentity();
        case MERGE:
            return canUploadMerges();
        case CREATE_CHANGE:
            return canUpload();
        case UPDATE_BY_SUBMIT:
            return projectControl.controlForRef("refs/for/" + getRefName()).canSubmit(true);
        case READ_PRIVATE_CHANGES:
            return canViewPrivateChanges();
        case READ_CONFIG:
            return projectControl.controlForRef(RefNames.REFS_CONFIG).canPerform(RefPermission.READ.name());
        case WRITE_CONFIG:
            return isOwner();
        case SKIP_VALIDATION:
            return canForgeAuthor() && canForgeCommitter() && canForgeGerritServerIdentity() && canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
public ChangeNotes notes() {
    return getControl().getNotes();
}
#method_after
public ChangeNotes notes() {
    return notes;
}
#end_block

#method_before
public void copyFrom(CodeReviewCommit src) {
    control = src.control;
    patchsetId = src.patchsetId;
    statusCode = src.statusCode;
}
#method_after
public void copyFrom(CodeReviewCommit src) {
    notes = src.notes;
    patchsetId = src.patchsetId;
    statusCode = src.statusCode;
}
#end_block

#method_before
public Change change() {
    return getControl().getChange();
}
#method_after
public Change change() {
    return getNotes().getChange();
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    super.init();
    boolean isDraft = change.getStatus() == Change.Status.DRAFT;
    try {
        // Try to mark interested owners with TO and CC or BCC line.
        Watchers matching = getWatchers(NotifyType.NEW_CHANGES, !isDraft && !change.isWorkInProgress() && !change.isPrivate());
        for (Account.Id user : Iterables.concat(matching.to.accounts, matching.cc.accounts, matching.bcc.accounts)) {
            if (isOwnerOfProjectOrBranch(user)) {
                add(RecipientType.TO, user);
            }
        }
        // Add everyone else. Owners added above will not be duplicated.
        add(RecipientType.TO, matching.to);
        add(RecipientType.CC, matching.cc);
        add(RecipientType.BCC, matching.bcc);
    } catch (OrmException err) {
        // Just don't CC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot notify watchers for new change", err);
    }
    includeWatchers(NotifyType.NEW_PATCHSETS, !isDraft && !change.isWorkInProgress() && !change.isPrivate());
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    try {
        // Upgrade watching owners from CC and BCC to TO.
        Watchers matching = getWatchers(NotifyType.NEW_CHANGES, !change.isWorkInProgress() && !change.isPrivate());
        // TODO(hiesel): Remove special handling for owners
        StreamSupport.stream(matching.all().accounts.spliterator(), false).filter(acc -> isOwnerOfProjectOrBranch(acc)).forEach(acc -> add(RecipientType.TO, acc));
        // Add everyone else. Owners added above will not be duplicated.
        add(RecipientType.TO, matching.to);
        add(RecipientType.CC, matching.cc);
        add(RecipientType.BCC, matching.bcc);
    } catch (OrmException err) {
        // Just don't CC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot notify watchers for new change", err);
    }
    includeWatchers(NotifyType.NEW_PATCHSETS, !change.isWorkInProgress() && !change.isPrivate());
}
#end_block

#method_before
private boolean isOwnerOfProjectOrBranch(Account.Id user) {
    return projectState != null && projectState.controlFor(args.identifiedUserFactory.create(user)).controlForRef(change.getDest()).isOwner();
}
#method_after
private boolean isOwnerOfProjectOrBranch(Account.Id userId) {
    return permissionBackend.user(identifiedUserFactory.create(userId)).ref(change.getDest()).testOrFalse(RefPermission.WRITE_CONFIG);
}
#end_block

#method_before
@Override
protected Response<CommentInfo> applyImpl(BatchUpdate.Factory updateFactory, DraftCommentResource rsrc, DraftInput in) throws RestApiException, UpdateException, OrmException {
    if (in == null || in.message == null || in.message.trim().isEmpty()) {
        return delete.applyImpl(updateFactory, rsrc, null);
    } else if (in.id != null && !rsrc.getId().equals(in.id)) {
        throw new BadRequestException("id must match URL");
    } else if (in.line != null && in.line < 0) {
        throw new BadRequestException("line must be >= 0");
    } else if (in.line != null && in.range != null && in.line != in.range.endLine) {
        throw new BadRequestException("range endLine must be on the same line as the comment");
    }
    try (BatchUpdate bu = updateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getControl().getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc.getComment().key, in);
        bu.addOp(rsrc.getChange().getId(), op);
        bu.execute();
        return Response.ok(commentJson.get().setFillAccounts(false).newCommentFormatter().format(op.comment));
    }
}
#method_after
@Override
protected Response<CommentInfo> applyImpl(BatchUpdate.Factory updateFactory, DraftCommentResource rsrc, DraftInput in) throws RestApiException, UpdateException, OrmException {
    if (in == null || in.message == null || in.message.trim().isEmpty()) {
        return delete.applyImpl(updateFactory, rsrc, null);
    } else if (in.id != null && !rsrc.getId().equals(in.id)) {
        throw new BadRequestException("id must match URL");
    } else if (in.line != null && in.line < 0) {
        throw new BadRequestException("line must be >= 0");
    } else if (in.line != null && in.range != null && in.line != in.range.endLine) {
        throw new BadRequestException("range endLine must be on the same line as the comment");
    }
    try (BatchUpdate bu = updateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc.getComment().key, in);
        bu.addOp(rsrc.getChange().getId(), op);
        bu.execute();
        return Response.ok(commentJson.get().setFillAccounts(false).newCommentFormatter().format(op.comment));
    }
}
#end_block

#method_before
void init() {
    for (ReceivePackInitializer i : initializers) {
        i.init(projectControl.getProject().getNameKey(), rp);
    }
}
#method_after
void init() {
    for (ReceivePackInitializer i : initializers) {
        i.init(projectState.getNameKey(), rp);
    }
}
#end_block

#method_before
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(changeFormatter.newChange(new ChangeReportFormatter.Input(c.change)));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        Boolean isPrivate = null;
        Boolean wip = null;
        if (magicBranch != null) {
            if (magicBranch.isPrivate) {
                isPrivate = true;
            } else if (magicBranch.removePrivate) {
                isPrivate = false;
            }
            if (magicBranch.workInProgress) {
                wip = true;
            } else if (magicBranch.ready) {
                wip = false;
            }
        }
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            if (isPrivate == null) {
                isPrivate = u.notes.getChange().isPrivate();
            }
            if (wip == null) {
                wip = u.notes.getChange().isWorkInProgress();
            }
            ChangeReportFormatter.Input input = new ChangeReportFormatter.Input(u.notes.getChange()).setSubject(subject).setDraft(u.replaceOp != null && u.replaceOp.getPatchSet().isDraft()).setEdit(edit).setPrivate(isPrivate).setWorkInProgress(wip);
            addMessage(changeFormatter.changeUpdated(input));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(changeFormatter.newChange(ChangeReportFormatter.Input.builder().setChange(c.change).build()));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && (magicBranch.edit || magicBranch.draft);
        Boolean isPrivate = null;
        Boolean wip = null;
        if (magicBranch != null) {
            if (magicBranch.isPrivate) {
                isPrivate = true;
            } else if (magicBranch.removePrivate) {
                isPrivate = false;
            }
            if (magicBranch.workInProgress) {
                wip = true;
            } else if (magicBranch.ready) {
                wip = false;
            }
        }
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            if (isPrivate == null) {
                isPrivate = u.notes.getChange().isPrivate();
            }
            if (wip == null) {
                wip = u.notes.getChange().isWorkInProgress();
            }
            ChangeReportFormatter.Input input = ChangeReportFormatter.Input.builder().setChange(u.notes.getChange()).setSubject(subject).setIsEdit(edit).setIsPrivate(isPrivate).setIsWorkInProgress(wip).build();
            addMessage(changeFormatter.changeUpdated(input));
        }
        addMessage("");
    }
    // TODO(xchangcheng): remove after migrating tools which are using this magic branch.
    if (magicBranch != null && magicBranch.publish) {
        addMessage("Pushing to refs/publish/* is deprecated, use refs/for/* instead.");
    }
}
#end_block

#method_before
private void parseCommands(Collection<ReceiveCommand> commands) throws PermissionBackendException, NoSuchProjectException, IOException {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET_PATTERN.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd, "prohibited by Gerrit: unknown command type " + cmd.getType());
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent)) {
                                try {
                                    permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER);
                                } catch (AuthException e) {
                                    reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                    continue;
                                }
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                oldValue = Arrays.stream(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName())).collect(joining("\n"));
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd, "prohibited by Gerrit: don't know how to handle config update of type " + cmd.getType());
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) throws PermissionBackendException, NoSuchProjectException, IOException {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectState.isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET_PATTERN.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd, "prohibited by Gerrit: unknown command type " + cmd.getType());
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            try {
                permissions.check(ProjectPermission.WRITE_CONFIG);
            } catch (AuthException e) {
                reject(cmd, String.format("must be either project owner or have %s permission", ProjectPermission.WRITE_CONFIG.describeForException()));
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent)) {
                                try {
                                    permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER);
                                } catch (AuthException e) {
                                    reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                    continue;
                                }
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectState.getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                oldValue = Arrays.stream(projectState.getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName())).collect(joining("\n"));
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectState)) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd, "prohibited by Gerrit: don't know how to handle config update of type " + cmd.getType());
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(ReceiveCommand cmd) throws PermissionBackendException, NoSuchProjectException, IOException {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    Branch.NameKey branch = new Branch.NameKey(project.getName(), cmd.getRefName());
    try {
        createRefControl.checkCreateRef(rp.getRepository(), branch, obj);
    } catch (AuthException denied) {
        reject(cmd, "prohibited by Gerrit: " + denied.getMessage());
        return;
    }
    if (!validRefOperation(cmd)) {
        // validRefOperation sets messages, so no need to provide more feedback.
        return;
    }
    validateNewCommits(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), cmd);
    actualCommands.add(cmd);
}
#method_after
private void parseCreate(ReceiveCommand cmd) throws PermissionBackendException, NoSuchProjectException, IOException {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        logError("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    logDebug("Creating {}", cmd);
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    Branch.NameKey branch = new Branch.NameKey(project.getName(), cmd.getRefName());
    try {
        // Must pass explicit user instead of injecting a provider into CreateRefControl, since
        // Provider<CurrentUser> within ReceiveCommits will always return anonymous.
        createRefControl.checkCreateRef(Providers.of(user), rp.getRepository(), branch, obj);
    } catch (AuthException denied) {
        reject(cmd, "prohibited by Gerrit: " + denied.getMessage());
        return;
    }
    if (!validRefOperation(cmd)) {
        // validRefOperation sets messages, so no need to provide more feedback.
        return;
    }
    validateNewCommits(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), cmd);
    actualCommands.add(cmd);
}
#end_block

#method_before
@Option(name = "--message", aliases = { "-m" }, metaVar = "MESSAGE", usage = "Comment message to apply to the review")
void addMessage(String token) {
    // git push does not allow spaces in refs.
    message = token.replace("_", " ");
}
#method_after
@Option(name = "--message", aliases = { "-m" }, metaVar = "MESSAGE", usage = "Comment message to apply to the review")
void addMessage(String token) {
    // Many characters have special meaning in the context of a git ref.
    // 
    // Clients can use underscores to represent spaces.
    message = token.replace("_", " ");
    try {
        // Other characters can be represented using percent-encoding.
        message = URLDecoder.decode(message, UTF_8.name());
    } catch (IllegalArgumentException e) {
    // Ignore decoding errors; leave message as percent-encoded.
    } catch (UnsupportedEncodingException e) {
        // This shouldn't happen; surely URLDecoder recognizes UTF-8.
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) throws PermissionBackendException {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(user, cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(extraReviewers.get(ReviewerStateInternal.REVIEWER));
    magicBranch.cc.addAll(extraReviewers.get(ReviewerStateInternal.CC));
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo)) && !ref.equals(RefNames.REFS_CONFIG)) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.perm = permissions.ref(ref);
    if (!projectControl.getProject().getState().permitsWrite()) {
        reject(cmd, "project state does not permit write");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(ReceiveError.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef(MagicBranch.NEW_DRAFT_CHANGE + ref).isBlocked(Permission.PUSH)) {
            errors.put(ReceiveError.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    try {
        magicBranch.perm.check(RefPermission.CREATE_CHANGE);
    } catch (AuthException denied) {
        errors.put(ReceiveError.CODE_REVIEW, ref);
        reject(cmd, denied.getMessage());
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.publishComments && magicBranch.noPublishComments) {
        reject(cmd, "the options 'publish-comments' and 'no-publish-comments' are mutually exclusive");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit) {
        try {
            permissions.ref(ref).check(RefPermission.UPDATE_BY_SUBMIT);
        } catch (AuthException e) {
            reject(cmd, e.getMessage());
            return;
        }
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.draft) {
                reject(cmd, "cannot be draft & merged");
                return;
            }
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.dest.get());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) throws PermissionBackendException {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    logDebug("Found magic branch {}", cmd.getRefName());
    magicBranch = new MagicBranchInput(user, cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(extraReviewers.get(ReviewerStateInternal.REVIEWER));
    magicBranch.cc.addAll(extraReviewers.get(ReviewerStateInternal.CC));
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            logDebug("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (magicBranch.topic != null && magicBranch.topic.length() > ChangeUtil.TOPIC_MAX_LENGTH) {
        reject(cmd, String.format("topic length exceeds the limit (%s)", ChangeUtil.TOPIC_MAX_LENGTH));
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectState.isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logDebug("Handling {}", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo)) && !ref.equals(RefNames.REFS_CONFIG)) {
        logDebug("Ref {} not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.perm = permissions.ref(ref);
    if (!projectState.getProject().getState().permitsWrite()) {
        reject(cmd, "project state does not permit write");
        return;
    }
    try {
        magicBranch.perm.check(RefPermission.CREATE_CHANGE);
    } catch (AuthException denied) {
        errors.put(ReceiveError.CODE_REVIEW, ref);
        reject(cmd, denied.getMessage());
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.publishComments && magicBranch.noPublishComments) {
        reject(cmd, "the options 'publish-comments' and 'no-publish-comments' are mutually exclusive");
        return;
    }
    if (magicBranch.submit) {
        try {
            permissions.ref(ref).check(RefPermission.UPDATE_BY_SUBMIT);
        } catch (AuthException e) {
            reject(cmd, e.getMessage());
            return;
        }
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logDebug("Tip of push: {}", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logDebug("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logDebug("Handling %base: {}", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logWarn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logDebug("Set baseCommit = {}", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logWarn(String.format("Error walking to %s in project %s", destBranch, project.getName()), ex);
        reject(cmd, "internal server error");
        return;
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.dest.get());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // The destination branch does not yet exist. Assume the
            // history being sent for review will start it and thus
            // is "connected" to the branch.
            logDebug("Branch is unborn");
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        logDebug("Current branch tip: {}", h.name());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logError("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, changeFormatter.changeClosed(new ChangeReportFormatter.Input(change)));
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#method_after
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, changeFormatter.changeClosed(ChangeReportFormatter.Input.builder().setChange(change).build()));
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void setChangeId(int id) {
    boolean privateByDefault = projectCache.get(project.getNameKey()).isPrivateByDefault();
    changeId = new Change.Id(id);
    ins = changeInserterFactory.create(changeId, commit, refName).setTopic(magicBranch.topic).setPrivate(magicBranch.isPrivate || (privateByDefault && !magicBranch.removePrivate)).setWorkInProgress(magicBranch.workInProgress).setValidate(false);
    if (magicBranch.draft) {
        ins.setDraft(magicBranch.draft);
    } else if (magicBranch.merged) {
        ins.setStatus(Change.Status.MERGED);
    }
    cmd = new ReceiveCommand(ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName());
    if (rp.getPushCertificate() != null) {
        ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
}
#method_after
private void setChangeId(int id) {
    boolean privateByDefault = projectCache.get(project.getNameKey()).isPrivateByDefault();
    changeId = new Change.Id(id);
    ins = changeInserterFactory.create(changeId, commit, refName).setTopic(magicBranch.topic).setPrivate(magicBranch.draft || magicBranch.isPrivate || (privateByDefault && !magicBranch.removePrivate)).setWorkInProgress(magicBranch.workInProgress).setValidate(false);
    if (magicBranch.merged) {
        ins.setStatus(Change.Status.MERGED);
    }
    cmd = new ReceiveCommand(ObjectId.zeroId(), commit, ins.getPatchSetId().toRefName());
    if (rp.getPushCertificate() != null) {
        ins.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
}
#end_block

#method_before
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(db, accountResolver, magicBranch.draft, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.getNotify()).setAccountsToNotify(magicBranch.getAccountsToNotify()).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setPatchSetDescription(magicBranch.message));
        if (!magicBranch.hashtags.isEmpty()) {
            // Any change owner is allowed to add hashtags when creating a change.
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdateOp() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#method_after
private void addOps(BatchUpdate bu) throws RestApiException {
    checkState(changeId != null, "must call setChangeId before addOps");
    try {
        RevWalk rw = rp.getRevWalk();
        rw.parseBody(commit);
        final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
        Account.Id me = user.getAccountId();
        List<FooterLine> footerLines = commit.getFooterLines();
        MailRecipients recipients = new MailRecipients();
        Map<String, Short> approvals = new HashMap<>();
        checkNotNull(magicBranch);
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        recipients.add(getRecipientsFromFooters(accountResolver, footerLines));
        recipients.remove(me);
        StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
        msg.append('.');
        if (!Strings.isNullOrEmpty(magicBranch.message)) {
            msg.append("\n").append(magicBranch.message);
        }
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.getNotify()).setAccountsToNotify(magicBranch.getAccountsToNotify()).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setPatchSetDescription(magicBranch.message));
        if (!magicBranch.hashtags.isEmpty()) {
            // Any change owner is allowed to add hashtags when creating a change.
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setFireEvent(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdateOp() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.addOp(changeId, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) {
                change = ctx.getChange();
                return false;
            }
        });
        bu.addOp(changeId, new ChangeProgressOp(newProgress));
    } catch (Exception e) {
        throw INSERT_EXCEPTION.apply(e);
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException, PermissionBackendException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    Change change = notes.getChange();
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    try {
        permissions.change(notes).database(db).check(ChangePermission.ADD_PATCH_SET);
    } catch (AuthException no) {
        reject(inputCommand, "cannot add patch set to " + ontoChange + ".");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    PermissionBackend.ForRef perm = permissions.ref(change.getDest().get());
    if (!validCommit(rp.getRevWalk(), perm, change.getDest(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && (magicBranch.workInProgress || magicBranch.ready) && magicBranch.workInProgress != change.isWorkInProgress() && !user.getAccountId().equals(change.getOwner())) {
        reject(inputCommand, ONLY_OWNER_CAN_MODIFY_WIP);
        return false;
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException, PermissionBackendException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    Change change = notes.getChange();
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    try {
        permissions.change(notes).database(db).check(ChangePermission.ADD_PATCH_SET);
    } catch (AuthException no) {
        reject(inputCommand, "cannot add patch set to " + ontoChange + ".");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    PermissionBackend.ForRef perm = permissions.ref(change.getDest().get());
    if (!validCommit(rp.getRevWalk(), perm, change.getDest(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && (magicBranch.workInProgress || magicBranch.ready) && magicBranch.workInProgress != change.isWorkInProgress() && !user.getAccountId().equals(change.getOwner())) {
        reject(inputCommand, ONLY_OWNER_CAN_MODIFY_WIP);
        return false;
    }
    if (magicBranch != null && (magicBranch.edit || magicBranch.draft)) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (magicBranch != null && magicBranch.edit) {
        bu.addOp(notes.getChangeId(), new ReindexOnlyOp());
        if (prev != null) {
            bu.addRepoOnlyOp(new UpdateOneRefOp(prev));
        }
        bu.addRepoOnlyOp(new UpdateOneRefOp(cmd));
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator);
    bu.addOp(notes.getChangeId(), replaceOp);
    if (progress != null) {
        bu.addOp(notes.getChangeId(), new ChangeProgressOp(progress));
    }
}
#method_after
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (magicBranch != null && (magicBranch.edit || magicBranch.draft)) {
        bu.addOp(notes.getChangeId(), new ReindexOnlyOp());
        if (prev != null) {
            bu.addRepoOnlyOp(new UpdateOneRefOp(prev));
        }
        bu.addRepoOnlyOp(new UpdateOneRefOp(cmd));
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(projectState, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate()).setRequestScopePropagator(requestScopePropagator);
    bu.addOp(notes.getChangeId(), replaceOp);
    if (progress != null) {
        bu.addOp(notes.getChangeId(), new ChangeProgressOp(progress));
    }
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    String refName = cmd.getRefName();
    if (cmd.getType() == ReceiveCommand.Type.UPDATE) {
        // aka fast-forward
        logDebug("Updating tag cache on fast-forward of {}", cmd.getRefName());
        tagCache.updateFastForward(project.getNameKey(), refName, cmd.getOldId(), cmd.getNewId());
    }
    if (isConfig(cmd)) {
        logDebug("Reloading project in cache");
        projectCache.evict(project);
        ProjectState ps = projectCache.get(project.getNameKey());
        try {
            logDebug("Updating project description");
            repo.setGitwebDescription(ps.getProject().getDescription());
        } catch (IOException e) {
            log.warn("cannot update description of " + project.getName(), e);
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) {
    String refName = cmd.getRefName();
    if (cmd.getType() == ReceiveCommand.Type.UPDATE) {
        // aka fast-forward
        logDebug("Updating tag cache on fast-forward of {}", cmd.getRefName());
        tagCache.updateFastForward(project.getNameKey(), refName, cmd.getOldId(), cmd.getNewId());
    }
    if (isConfig(cmd)) {
        logDebug("Reloading project in cache");
        try {
            projectCache.evict(project);
        } catch (IOException e) {
            log.warn("Cannot evict from project cache, name key: " + project.getName(), e);
        }
        ProjectState ps = projectCache.get(project.getNameKey());
        try {
            logDebug("Updating project description");
            repo.setGitwebDescription(ps.getProject().getDescription());
        } catch (IOException e) {
            log.warn("cannot update description of " + project.getName(), e);
        }
    }
}
#end_block

#method_before
private void autoCloseChanges(ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException | PermissionBackendException e) {
        logError("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(ReceiveCommand cmd) {
    logDebug("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectState.getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRequestId(receiveId);
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        int existingPatchSets = 0;
        int newPatchSets = 0;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                existingPatchSets++;
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    newPatchSets++;
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                logDebug("Not closing {} because validation failed", id);
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        logDebug("Auto-closing {} changes with existing patch sets and {} with new patch sets", existingPatchSets, newPatchSets);
        bu.execute();
    } catch (RestApiException e) {
        logError("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException | PermissionBackendException e) {
        logError("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Set<ObjectId> advertiseOpenChanges(Set<ObjectId> allPatchSets) {
    // Advertise some recent open changes, in case a commit is based on one.
    int limit = 32;
    try {
        Set<ObjectId> r = Sets.newHashSetWithExpectedSize(limit);
        for (ChangeData cd : queryProvider.get().setRequestedFields(OPEN_CHANGES_FIELDS).enforceVisibility(true).setLimit(limit).byProjectOpen(projectName)) {
            PatchSet ps = cd.currentPatchSet();
            if (ps != null) {
                ObjectId id = ObjectId.fromString(ps.getRevision().get());
                // object doesn't actually exist.
                if (allPatchSets.contains(id)) {
                    r.add(id);
                }
            }
        }
        return r;
    } catch (OrmException err) {
        log.error("Cannot list open changes of " + projectName, err);
        return Collections.emptySet();
    }
}
#method_after
private Set<ObjectId> advertiseOpenChanges(Set<ObjectId> allPatchSets) {
    // Advertise some recent open changes, in case a commit is based on one.
    int limit = 32;
    try {
        Set<ObjectId> r = Sets.newHashSetWithExpectedSize(limit);
        for (ChangeData cd : queryProvider.get().setRequestedFields(// Required for ChangeIsVisibleToPrdicate.
        ChangeField.CHANGE, ChangeField.REVIEWER, // Required during advertiseOpenChanges.
        ChangeField.PATCH_SET).enforceVisibility(true).setLimit(limit).byProjectOpen(projectName)) {
            PatchSet ps = cd.currentPatchSet();
            if (ps != null) {
                ObjectId id = ObjectId.fromString(ps.getRevision().get());
                // object doesn't actually exist.
                if (allPatchSets.contains(id)) {
                    r.add(id);
                }
            }
        }
        return r;
    } catch (OrmException err) {
        log.error("Cannot list open changes of " + projectName, err);
        return Collections.emptySet();
    }
}
#end_block

#method_before
private static Predicate<ChangeData> status(Change.Status status) {
    return new ChangeStatusPredicate(status);
}
#method_after
private static Predicate<ChangeData> status(Change.Status status) {
    return ChangeStatusPredicate.forStatus(status);
}
#end_block

#method_before
@Override
public InternalChangeQuery setRequestedFields(Set<String> fields) {
    super.setRequestedFields(fields);
    return this;
}
#method_after
@SafeVarargs
@Override
public final InternalChangeQuery setRequestedFields(FieldDef<ChangeData, ?>... fields) {
    super.setRequestedFields(fields);
    return this;
}
#end_block

#method_before
public static void reloadChanges(ChangeSet cs) throws OrmException {
    // Clear exactly the fields requested by query() below.
    for (ChangeData cd : cs.changes()) {
        cd.reloadChange();
        cd.setPatchSets(null);
        cd.setMergeable(null);
    }
}
#method_after
public static void reloadChanges(ChangeSet changeSet) throws OrmException {
    // Clear exactly the fields requested by query(InternalChangeQuery) below.
    for (ChangeData cd : changeSet.changes()) {
        cd.reloadChange();
        cd.setPatchSets(null);
        cd.setMergeable(null);
    }
}
#end_block

#method_before
private InternalChangeQuery query() {
    // Request fields required for completing the ChangeSet and converting to
    // ChangeInfo without having to touch the database or opening the repository
    // more than necessary. This provides reasonable performance when loading
    // the change screen; callers that care about reading the latest value of
    // these fields should clear them explicitly using reloadChanges().
    Set<String> fields = ImmutableSet.of(ChangeField.CHANGE.getName(), ChangeField.PATCH_SET.getName(), ChangeField.MERGEABLE.getName());
    return queryProvider.get().setRequestedFields(fields);
}
#method_after
public static InternalChangeQuery query(InternalChangeQuery q) {
    // these fields should clear them explicitly using reloadChanges().
    return q.setRequestedFields(ChangeField.CHANGE, ChangeField.PATCH_SET, ChangeField.MERGEABLE);
}
#end_block

#method_before
public ChangeSet completeChangeSet(ReviewDb db, Change change, CurrentUser user) throws IOException, OrmException, PermissionBackendException {
    try {
        ChangeData cd = changeDataFactory.create(db, change.getProject(), change.getId());
        cd.changeControl(user);
        ChangeSet cs = new ChangeSet(cd, permissionBackend.user(user).change(cd).database(db).test(ChangePermission.READ));
        if (Submit.wholeTopicEnabled(cfg)) {
            return completeChangeSetIncludingTopics(db, cs, user);
        }
        return completeChangeSetWithoutTopic(db, cs, user);
    } finally {
        if (closeOrm && orm != null) {
            orm.close();
            orm = null;
        }
    }
}
#method_after
public ChangeSet completeChangeSet(ReviewDb db, Change change, CurrentUser user) throws IOException, OrmException, PermissionBackendException {
    try {
        if (orm == null) {
            orm = repoManagerProvider.get();
            closeOrm = true;
        }
        ChangeData cd = changeDataFactory.create(db, change.getProject(), change.getId());
        ChangeSet changeSet = new ChangeSet(cd, permissionBackend.user(user).change(cd).database(db).test(ChangePermission.READ));
        if (Submit.wholeTopicEnabled(cfg)) {
            return completeChangeSetIncludingTopics(db, changeSet, user);
        }
        return mergeSuperSetComputation.get().completeWithoutTopic(db, orm, changeSet, user);
    } finally {
        if (closeOrm && orm != null) {
            orm.close();
            orm = null;
        }
    }
}
#end_block

#method_before
private ChangeSet topicClosure(ReviewDb db, ChangeSet cs, CurrentUser user, Set<String> topicsSeen, Set<String> visibleTopicsSeen) throws OrmException, PermissionBackendException {
    List<ChangeData> visibleChanges = new ArrayList<>();
    List<ChangeData> nonVisibleChanges = new ArrayList<>();
    for (ChangeData cd : cs.changes()) {
        visibleChanges.add(cd);
        String topic = cd.change().getTopic();
        if (Strings.isNullOrEmpty(topic) || visibleTopicsSeen.contains(topic)) {
            continue;
        }
        for (ChangeData topicCd : query().byTopicOpen(topic)) {
            try {
                topicCd.changeControl(user);
                if (canRead(db, user, topicCd)) {
                    visibleChanges.add(topicCd);
                } else {
                    nonVisibleChanges.add(topicCd);
                }
            } catch (OrmException e) {
                if (e.getCause() instanceof NoSuchChangeException) {
                // Ignore and skip this change
                } else {
                    throw e;
                }
            }
        }
        topicsSeen.add(topic);
        visibleTopicsSeen.add(topic);
    }
    for (ChangeData cd : cs.nonVisibleChanges()) {
        nonVisibleChanges.add(cd);
        String topic = cd.change().getTopic();
        if (Strings.isNullOrEmpty(topic) || topicsSeen.contains(topic)) {
            continue;
        }
        for (ChangeData topicCd : query().byTopicOpen(topic)) {
            topicCd.changeControl(user);
            nonVisibleChanges.add(topicCd);
        }
        topicsSeen.add(topic);
    }
    return new ChangeSet(visibleChanges, nonVisibleChanges);
}
#method_after
private ChangeSet topicClosure(ReviewDb db, ChangeSet changeSet, CurrentUser user, Set<String> topicsSeen, Set<String> visibleTopicsSeen) throws OrmException, PermissionBackendException {
    List<ChangeData> visibleChanges = new ArrayList<>();
    List<ChangeData> nonVisibleChanges = new ArrayList<>();
    for (ChangeData cd : changeSet.changes()) {
        visibleChanges.add(cd);
        String topic = cd.change().getTopic();
        if (Strings.isNullOrEmpty(topic) || visibleTopicsSeen.contains(topic)) {
            continue;
        }
        for (ChangeData topicCd : byTopicOpen(topic)) {
            if (canRead(db, user, topicCd)) {
                visibleChanges.add(topicCd);
            } else {
                nonVisibleChanges.add(topicCd);
            }
        }
        topicsSeen.add(topic);
        visibleTopicsSeen.add(topic);
    }
    for (ChangeData cd : changeSet.nonVisibleChanges()) {
        nonVisibleChanges.add(cd);
        String topic = cd.change().getTopic();
        if (Strings.isNullOrEmpty(topic) || topicsSeen.contains(topic)) {
            continue;
        }
        for (ChangeData topicCd : byTopicOpen(topic)) {
            nonVisibleChanges.add(topicCd);
        }
        topicsSeen.add(topic);
    }
    return new ChangeSet(visibleChanges, nonVisibleChanges);
}
#end_block

#method_before
private ChangeSet completeChangeSetIncludingTopics(ReviewDb db, ChangeSet changes, CurrentUser user) throws IOException, OrmException, PermissionBackendException {
    Set<String> topicsSeen = new HashSet<>();
    Set<String> visibleTopicsSeen = new HashSet<>();
    int oldSeen;
    int seen = 0;
    do {
        oldSeen = seen;
        changes = completeChangeSetWithoutTopic(db, changes, user);
        changes = topicClosure(db, changes, user, topicsSeen, visibleTopicsSeen);
        seen = topicsSeen.size() + visibleTopicsSeen.size();
    } while (seen != oldSeen);
    return changes;
}
#method_after
private ChangeSet completeChangeSetIncludingTopics(ReviewDb db, ChangeSet changeSet, CurrentUser user) throws IOException, OrmException, PermissionBackendException {
    Set<String> topicsSeen = new HashSet<>();
    Set<String> visibleTopicsSeen = new HashSet<>();
    int oldSeen;
    int seen = 0;
    changeSet = topicClosure(db, changeSet, user, topicsSeen, visibleTopicsSeen);
    seen = topicsSeen.size() + visibleTopicsSeen.size();
    do {
        oldSeen = seen;
        changeSet = mergeSuperSetComputation.get().completeWithoutTopic(db, orm, changeSet, user);
        changeSet = topicClosure(db, changeSet, user, topicsSeen, visibleTopicsSeen);
        seen = topicsSeen.size() + visibleTopicsSeen.size();
    } while (seen != oldSeen);
    return changeSet;
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, Input input) throws MethodNotAllowedException, ResourceNotFoundException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME)) {
        throw new MethodNotAllowedException("realm does not allow editing name");
    }
    String newName = input.name;
    Account account = accountsUpdate.create().update(user.getAccountId(), a -> a.setFullName(newName));
    if (account == null) {
        throw new ResourceNotFoundException("account not found");
    }
    return Strings.isNullOrEmpty(account.getFullName()) ? Response.none() : Response.ok(account.getFullName());
}
#method_after
@Override
public Response<String> apply(AccountResource rsrc, NameInput input) throws AuthException, MethodNotAllowedException, ResourceNotFoundException, OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    return apply(rsrc.getUser(), input);
}
#end_block

#method_before
public Map<String, Ref> filter(Map<String, Ref> refs, boolean filterTagsSeparately) {
    if (projectState.isAllUsers()) {
        refs = addUsersSelfSymref(refs);
    }
    projectCtl = projectState.controlFor(user.get());
    if (projectCtl.allRefsAreVisible(ImmutableSet.of(REFS_CONFIG))) {
        return fastHideRefsMetaConfig(refs);
    }
    Account.Id userId;
    boolean viewMetadata;
    if (user.get().isIdentifiedUser()) {
        viewMetadata = permissionBackend.user(user).testOrFalse(GlobalPermission.ACCESS_DATABASE);
        IdentifiedUser u = user.get().asIdentifiedUser();
        userId = u.getAccountId();
        userEditPrefix = RefNames.refsEditPrefix(userId);
    } else {
        userId = null;
        viewMetadata = false;
    }
    Map<String, Ref> result = new HashMap<>();
    List<Ref> deferredTags = new ArrayList<>();
    for (Ref ref : refs.values()) {
        String name = ref.getName();
        Change.Id changeId;
        Account.Id accountId;
        if (name.startsWith(REFS_CACHE_AUTOMERGE) || (!showMetadata && isMetadata(name))) {
            continue;
        } else if (RefNames.isRefsEdit(name)) {
            // Edits are visible only to the owning user, if change is visible.
            if (viewMetadata || visibleEdit(name)) {
                result.put(name, ref);
            }
        } else if ((changeId = Change.Id.fromRef(name)) != null) {
            // Change ref is visible only if the change is visible.
            if (viewMetadata || visible(changeId)) {
                result.put(name, ref);
            }
        } else if ((accountId = Account.Id.fromRef(name)) != null) {
            // Account ref is visible only to corresponding account.
            if (viewMetadata || (accountId.equals(userId) && canReadRef(name))) {
                result.put(name, ref);
            }
        } else if (isTag(ref)) {
            // If its a tag, consider it later.
            if (ref.getObjectId() != null) {
                deferredTags.add(ref);
            }
        } else if (name.startsWith(RefNames.REFS_SEQUENCES)) {
            // Sequences are internal database implementation details.
            if (viewMetadata) {
                result.put(name, ref);
            }
        } else if (projectState.isAllUsers() && name.equals(RefNames.REFS_EXTERNAL_IDS)) {
            // The notes branch with the external IDs of all users must not be exposed to normal users.
            if (viewMetadata) {
                result.put(name, ref);
            }
        } else if (canReadRef(ref.getLeaf().getName())) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            result.put(name, ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && (!result.isEmpty() || filterTagsSeparately)) {
        TagMatcher tags = tagCache.get(projectState.getNameKey()).matcher(tagCache, git, filterTagsSeparately ? filter(git.getAllRefs()).values() : result.values());
        for (Ref tag : deferredTags) {
            if (tags.isReachable(tag)) {
                result.put(tag.getName(), tag);
            }
        }
    }
    return result;
}
#method_after
public Map<String, Ref> filter(Map<String, Ref> refs, boolean filterTagsSeparately) {
    if (projectState.isAllUsers()) {
        refs = addUsersSelfSymref(refs);
    }
    PermissionBackend.WithUser withUser = permissionBackend.user(user);
    PermissionBackend.ForProject forProject = withUser.project(projectState.getNameKey());
    if (checkProjectPermission(forProject, ProjectPermission.READ)) {
        return refs;
    } else if (checkProjectPermission(forProject, ProjectPermission.READ_NO_CONFIG)) {
        return fastHideRefsMetaConfig(refs);
    }
    Account.Id userId;
    boolean viewMetadata;
    if (user.get().isIdentifiedUser()) {
        viewMetadata = withUser.testOrFalse(GlobalPermission.ACCESS_DATABASE);
        IdentifiedUser u = user.get().asIdentifiedUser();
        userId = u.getAccountId();
        userEditPrefix = RefNames.refsEditPrefix(userId);
    } else {
        userId = null;
        viewMetadata = false;
    }
    Map<String, Ref> result = new HashMap<>();
    List<Ref> deferredTags = new ArrayList<>();
    for (Ref ref : refs.values()) {
        String name = ref.getName();
        Change.Id changeId;
        Account.Id accountId;
        if (name.startsWith(REFS_CACHE_AUTOMERGE) || (!showMetadata && isMetadata(name))) {
            continue;
        } else if (RefNames.isRefsEdit(name)) {
            // Edits are visible only to the owning user, if change is visible.
            if (viewMetadata || visibleEdit(name)) {
                result.put(name, ref);
            }
        } else if ((changeId = Change.Id.fromRef(name)) != null) {
            // Change ref is visible only if the change is visible.
            if (viewMetadata || visible(changeId)) {
                result.put(name, ref);
            }
        } else if ((accountId = Account.Id.fromRef(name)) != null) {
            // Account ref is visible only to corresponding account.
            if (viewMetadata || (accountId.equals(userId) && canReadRef(name))) {
                result.put(name, ref);
            }
        } else if (isTag(ref)) {
            // If its a tag, consider it later.
            if (ref.getObjectId() != null) {
                deferredTags.add(ref);
            }
        } else if (name.startsWith(RefNames.REFS_SEQUENCES)) {
            // Sequences are internal database implementation details.
            if (viewMetadata) {
                result.put(name, ref);
            }
        } else if (projectState.isAllUsers() && name.equals(RefNames.REFS_EXTERNAL_IDS)) {
            // The notes branch with the external IDs of all users must not be exposed to normal users.
            if (viewMetadata) {
                result.put(name, ref);
            }
        } else if (canReadRef(ref.getLeaf().getName())) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            result.put(name, ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && (!result.isEmpty() || filterTagsSeparately)) {
        TagMatcher tags = tagCache.get(projectState.getNameKey()).matcher(tagCache, git, filterTagsSeparately ? filter(git.getAllRefs()).values() : result.values());
        for (Ref tag : deferredTags) {
            if (tags.isReachable(tag)) {
                result.put(tag.getName(), tag);
            }
        }
    }
    return result;
}
#end_block

#method_before
private boolean visibleEdit(String name) {
    Change.Id id = Change.Id.fromEditRefPart(name);
    // Initialize if it wasn't yet
    if (visibleChanges == null) {
        visible(id);
    }
    if (id != null) {
        return (userEditPrefix != null && name.startsWith(userEditPrefix) && visible(id)) || (visibleChanges.containsKey(id) && projectCtl.controlForRef(visibleChanges.get(id)).isEditVisible());
    }
    return false;
}
#method_after
private boolean visibleEdit(String name) {
    Change.Id id = Change.Id.fromEditRefPart(name);
    // Initialize if it wasn't yet
    if (visibleChanges == null) {
        visible(id);
    }
    if (id == null) {
        return false;
    }
    if (userEditPrefix != null && name.startsWith(userEditPrefix) && visible(id)) {
        return true;
    }
    if (visibleChanges.containsKey(id)) {
        try {
            // Default to READ_PRIVATE_CHANGES as there is no special permission for reading edits.
            perm.ref(visibleChanges.get(id).get()).check(RefPermission.READ_PRIVATE_CHANGES);
            return true;
        } catch (PermissionBackendException | AuthException e) {
            return false;
        }
    }
    return false;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public InstallPlugin create(TopLevelResource parent, IdString id) throws ResourceNotFoundException, MethodNotAllowedException {
    if (!loader.isRemoteAdminEnabled()) {
        throw new MethodNotAllowedException("remote installation is disabled");
    }
    return install.get().setName(id.get()).setCreated(true);
}
#method_after
@Override
public InstallPlugin create(TopLevelResource parent, IdString id) throws RestApiException {
    loader.checkRemoteAdminEnabled();
    return install.get().setName(id.get()).setCreated(true);
}
#end_block

#method_before
@Override
public ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, CommitResource rsrc, CherryPickInput input) throws OrmException, IOException, UpdateException, RestApiException, PermissionBackendException, ConfigInvalidException, NoSuchProjectException {
    RevCommit commit = rsrc.getCommit();
    String message = Strings.nullToEmpty(input.message).trim();
    input.message = message.isEmpty() ? commit.getFullMessage() : message;
    String destination = Strings.nullToEmpty(input.destination).trim();
    input.parent = input.parent == null ? 1 : input.parent;
    Project.NameKey projectName = rsrc.getProjectState().getNameKey();
    if (destination.isEmpty()) {
        throw new BadRequestException("destination must be non-empty");
    }
    String refName = RefNames.fullName(destination);
    CreateChange.checkValidCLA(rsrc.getProjectState().controlFor(user.get()));
    permissionBackend.user(user).project(projectName).ref(refName).check(RefPermission.CREATE_CHANGE);
    try {
        Change.Id cherryPickedChangeId = cherryPickChange.cherryPick(updateFactory, null, null, projectName, commit, input, new Branch.NameKey(rsrc.getProjectState().getNameKey(), refName));
        return json.noOptions().format(projectName, cherryPickedChangeId);
    } catch (InvalidChangeOperationException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IntegrationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
@Override
public ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, CommitResource rsrc, CherryPickInput input) throws OrmException, IOException, UpdateException, RestApiException, PermissionBackendException, ConfigInvalidException, NoSuchProjectException {
    RevCommit commit = rsrc.getCommit();
    String message = Strings.nullToEmpty(input.message).trim();
    input.message = message.isEmpty() ? commit.getFullMessage() : message;
    String destination = Strings.nullToEmpty(input.destination).trim();
    input.parent = input.parent == null ? 1 : input.parent;
    Project.NameKey projectName = rsrc.getProjectState().getNameKey();
    if (destination.isEmpty()) {
        throw new BadRequestException("destination must be non-empty");
    }
    String refName = RefNames.fullName(destination);
    contributorAgreements.check(projectName, user.get());
    permissionBackend.user(user).project(projectName).ref(refName).check(RefPermission.CREATE_CHANGE);
    try {
        Change.Id cherryPickedChangeId = cherryPickChange.cherryPick(updateFactory, null, null, projectName, commit, input, new Branch.NameKey(rsrc.getProjectState().getNameKey(), refName));
        return json.noOptions().format(projectName, cherryPickedChangeId);
    } catch (InvalidChangeOperationException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IntegrationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    JdbcSchema schema = (JdbcSchema) db;
    SqlDialect dialect = schema.getDialect();
    try (StatementExecutor e = newExecutor(db)) {
        dialect.dropIndex(e, "accounts", "accounts_byPreferredEmail");
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    JdbcSchema schema = (JdbcSchema) db;
    SqlDialect dialect = schema.getDialect();
    try (StatementExecutor e = newExecutor(db)) {
        dialect.dropIndex(e, "accounts", "accounts_byPreferredEmail");
    } catch (OrmException ex) {
    // Ignore. The index did not exist.
    }
}
#end_block

#method_before
public static MailMessage parse(String raw) throws MailParsingException {
    MailMessage.Builder messageBuilder = MailMessage.builder();
    messageBuilder.rawContentUTF(raw);
    Message mimeMessage;
    try {
        MessageBuilder builder = new DefaultMessageBuilder();
        mimeMessage = builder.parseMessage(new ByteArrayInputStream(raw.getBytes(UTF_8)));
    } catch (IOException | MimeException e) {
        throw new MailParsingException("Can't parse email", e);
    }
    // Add general headers
    if (mimeMessage.getMessageId() != null) {
        messageBuilder.id(mimeMessage.getMessageId());
    }
    if (mimeMessage.getSubject() != null) {
        messageBuilder.subject(mimeMessage.getSubject());
    }
    messageBuilder.dateReceived(new DateTime(mimeMessage.getDate()));
    // Add From, To and Cc
    if (mimeMessage.getFrom() != null && mimeMessage.getFrom().size() > 0) {
        Mailbox from = mimeMessage.getFrom().get(0);
        messageBuilder.from(new Address(from.getName(), from.getAddress()));
    }
    if (mimeMessage.getTo() != null) {
        for (Mailbox m : mimeMessage.getTo().flatten()) {
            messageBuilder.addTo(new Address(m.getName(), m.getAddress()));
        }
    }
    if (mimeMessage.getCc() != null) {
        for (Mailbox m : mimeMessage.getCc().flatten()) {
            messageBuilder.addCc(new Address(m.getName(), m.getAddress()));
        }
    }
    // Add additional headers
    mimeMessage.getHeader().getFields().stream().filter(f -> !MAIN_HEADERS.contains(f.getName().toLowerCase())).forEach(f -> messageBuilder.addAdditionalHeader(f.getName() + ": " + f.getBody()));
    // Add text and html body parts
    StringBuilder textBuilder = new StringBuilder();
    StringBuilder htmlBuilder = new StringBuilder();
    try {
        handleMimePart(mimeMessage, textBuilder, htmlBuilder);
    } catch (IOException e) {
        throw new MailParsingException("Can't parse email", e);
    }
    messageBuilder.textContent(Strings.emptyToNull(textBuilder.toString()));
    messageBuilder.htmlContent(Strings.emptyToNull(htmlBuilder.toString()));
    try {
        // required attributes are missing, so that the caller doesn't fall over.
        return messageBuilder.build();
    } catch (IllegalStateException e) {
        throw new MailParsingException("Missing required attributes after email was parsed", e);
    }
}
#method_after
public static MailMessage parse(String raw) throws MailParsingException {
    MailMessage.Builder messageBuilder = MailMessage.builder();
    messageBuilder.rawContentUTF(raw);
    Message mimeMessage;
    try {
        MessageBuilder builder = new DefaultMessageBuilder();
        mimeMessage = builder.parseMessage(new ByteArrayInputStream(raw.getBytes(UTF_8)));
    } catch (IOException | MimeException e) {
        throw new MailParsingException("Can't parse email", e);
    }
    // Add general headers
    if (mimeMessage.getMessageId() != null) {
        messageBuilder.id(mimeMessage.getMessageId());
    }
    if (mimeMessage.getSubject() != null) {
        messageBuilder.subject(mimeMessage.getSubject());
    }
    if (mimeMessage.getDate() != null) {
        messageBuilder.dateReceived(mimeMessage.getDate().toInstant());
    }
    // Add From, To and Cc
    if (mimeMessage.getFrom() != null && mimeMessage.getFrom().size() > 0) {
        Mailbox from = mimeMessage.getFrom().get(0);
        messageBuilder.from(new Address(from.getName(), from.getAddress()));
    }
    if (mimeMessage.getTo() != null) {
        for (Mailbox m : mimeMessage.getTo().flatten()) {
            messageBuilder.addTo(new Address(m.getName(), m.getAddress()));
        }
    }
    if (mimeMessage.getCc() != null) {
        for (Mailbox m : mimeMessage.getCc().flatten()) {
            messageBuilder.addCc(new Address(m.getName(), m.getAddress()));
        }
    }
    // Add additional headers
    mimeMessage.getHeader().getFields().stream().filter(f -> !MAIN_HEADERS.contains(f.getName().toLowerCase())).forEach(f -> messageBuilder.addAdditionalHeader(f.getName() + ": " + f.getBody()));
    // Add text and html body parts
    StringBuilder textBuilder = new StringBuilder();
    StringBuilder htmlBuilder = new StringBuilder();
    try {
        handleMimePart(mimeMessage, textBuilder, htmlBuilder);
    } catch (IOException e) {
        throw new MailParsingException("Can't parse email", e);
    }
    messageBuilder.textContent(Strings.emptyToNull(textBuilder.toString()));
    messageBuilder.htmlContent(Strings.emptyToNull(htmlBuilder.toString()));
    try {
        // required attributes are missing, so that the caller doesn't fall over.
        return messageBuilder.build();
    } catch (IllegalStateException e) {
        throw new MailParsingException("Missing required attributes after email was parsed", e);
    }
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, BranchInput input) throws BadRequestException, AuthException, ResourceConflictException, IOException, PermissionBackendException, NoSuchProjectException {
    if (input == null) {
        input = new BranchInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        createRefControl.checkCreateRef(repo, name, object);
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            refCreationValidator.validateRefOperation(rsrc.getName(), identifiedUser.get(), u);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = RefUtil.getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = RefUtil.getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                case FORCED:
                case IO_FAILURE:
                case NOT_ATTEMPTED:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                case REJECTED_MISSING_OBJECT:
                case REJECTED_OTHER_REASON:
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = permissionBackend.user(identifiedUser).ref(name).testOrFalse(RefPermission.DELETE) ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (RefUtil.InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, BranchInput input) throws BadRequestException, AuthException, ResourceConflictException, IOException, PermissionBackendException, NoSuchProjectException {
    if (input == null) {
        input = new BranchInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        createRefControl.checkCreateRef(identifiedUser, repo, name, object);
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            refCreationValidator.validateRefOperation(rsrc.getName(), identifiedUser.get(), u);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = RefUtil.getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = RefUtil.getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                case FORCED:
                case IO_FAILURE:
                case NOT_ATTEMPTED:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                case REJECTED_MISSING_OBJECT:
                case REJECTED_OTHER_REASON:
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = permissionBackend.user(identifiedUser).ref(name).testOrFalse(RefPermission.DELETE) ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (RefUtil.InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    Injector injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    lifecycle = new LifecycleManager();
    lifecycle.add(injector);
    lifecycle.start();
    db = schemaFactory.open();
    schemaCreator.create(db);
    // Need to create at least one user to be admin before creating a "normal"
    // registered user.
    // See AccountManager#create().
    accountManager.authenticate(AuthRequest.forUser("admin")).getAccountId();
    admins = groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID();
    setUpPermissions();
    Account.Id userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    user = userFactory.create(userId);
    Project.NameKey name = new Project.NameKey("project");
    InMemoryRepository inMemoryRepo = repoManager.createRepository(name);
    project = new ProjectConfig(name);
    project.load(inMemoryRepo);
    repo = new TestRepository<>(inMemoryRepo);
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return user;
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return Providers.of(db);
        }
    });
}
#method_after
@Before
public void setUp() throws Exception {
    Injector injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    lifecycle = new LifecycleManager();
    lifecycle.add(injector);
    lifecycle.start();
    db = schemaFactory.open();
    schemaCreator.create(db);
    // Need to create at least one user to be admin before creating a "normal"
    // registered user.
    // See AccountManager#create().
    accountManager.authenticate(AuthRequest.forUser("admin")).getAccountId();
    admins = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID();
    setUpPermissions();
    Account.Id userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    user = userFactory.create(userId);
    Project.NameKey name = new Project.NameKey("project");
    InMemoryRepository inMemoryRepo = repoManager.createRepository(name);
    project = new ProjectConfig(name);
    project.load(inMemoryRepo);
    repo = new TestRepository<>(inMemoryRepo);
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return user;
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return Providers.of(db);
        }
    });
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, Input input) throws ResourceNotFoundException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    String newStatus = input.status;
    Account account = accountsUpdate.create().update(user.getAccountId(), a -> a.setStatus(Strings.nullToEmpty(newStatus)));
    if (account == null) {
        throw new ResourceNotFoundException("account not found");
    }
    return Strings.isNullOrEmpty(account.getStatus()) ? Response.none() : Response.ok(account.getStatus());
}
#method_after
@Override
public Response<String> apply(AccountResource rsrc, StatusInput input) throws AuthException, ResourceNotFoundException, OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.MODIFY_ACCOUNT);
    }
    return apply(rsrc.getUser(), input);
}
#end_block

#method_before
public void checkCreateRef(Repository repo, Branch.NameKey branch, RevObject object) throws AuthException, PermissionBackendException, NoSuchProjectException, IOException {
    ProjectState ps = projectCache.checkedGet(branch.getParentKey());
    if (ps == null) {
        throw new NoSuchProjectException(branch.getParentKey());
    }
    if (!ps.getProject().getState().permitsWrite()) {
        throw new AuthException("project state does not permit write");
    }
    PermissionBackend.ForRef perm = permissionBackend.user(user).ref(branch);
    if (object instanceof RevCommit) {
        perm.check(RefPermission.CREATE);
        checkCreateCommit(repo, (RevCommit) object, ps, perm);
    } else if (object instanceof RevTag) {
        RevTag tag = (RevTag) object;
        try (RevWalk rw = new RevWalk(repo)) {
            rw.parseBody(tag);
        } catch (IOException e) {
            log.error(String.format("RevWalk(%s) parsing %s:", branch.getParentKey(), tag.name()), e);
            throw e;
        }
        // If tagger is present, require it matches the user's email.
        PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null && (!user.get().isIdentifiedUser() || !user.get().asIdentifiedUser().hasEmailAddress(tagger.getEmailAddress()))) {
            perm.check(RefPermission.FORGE_COMMITTER);
        }
        RevObject target = tag.getObject();
        if (target instanceof RevCommit) {
            checkCreateCommit(repo, (RevCommit) target, ps, perm);
        } else {
            checkCreateRef(repo, branch, target);
        }
        // If the tag has a PGP signature, allow a lower level of permission
        // than if it doesn't have a PGP signature.
        RefControl refControl = ps.controlFor(user.get()).controlForRef(branch);
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            if (!refControl.canPerform(Permission.CREATE_SIGNED_TAG)) {
                throw new AuthException(Permission.CREATE_SIGNED_TAG + " not permitted");
            }
        } else if (!refControl.canPerform(Permission.CREATE_TAG)) {
            throw new AuthException(Permission.CREATE_TAG + " not permitted");
        }
    }
}
#method_after
public void checkCreateRef(Provider<? extends CurrentUser> user, Repository repo, Branch.NameKey branch, RevObject object) throws AuthException, PermissionBackendException, NoSuchProjectException, IOException {
    ProjectState ps = projectCache.checkedGet(branch.getParentKey());
    if (ps == null) {
        throw new NoSuchProjectException(branch.getParentKey());
    }
    if (!ps.getProject().getState().permitsWrite()) {
        throw new AuthException("project state does not permit write");
    }
    PermissionBackend.ForRef perm = permissionBackend.user(user).ref(branch);
    if (object instanceof RevCommit) {
        perm.check(RefPermission.CREATE);
        checkCreateCommit(user, repo, (RevCommit) object, ps, perm);
    } else if (object instanceof RevTag) {
        RevTag tag = (RevTag) object;
        try (RevWalk rw = new RevWalk(repo)) {
            rw.parseBody(tag);
        } catch (IOException e) {
            log.error(String.format("RevWalk(%s) parsing %s:", branch.getParentKey(), tag.name()), e);
            throw e;
        }
        // If tagger is present, require it matches the user's email.
        PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null && (!user.get().isIdentifiedUser() || !user.get().asIdentifiedUser().hasEmailAddress(tagger.getEmailAddress()))) {
            perm.check(RefPermission.FORGE_COMMITTER);
        }
        RevObject target = tag.getObject();
        if (target instanceof RevCommit) {
            checkCreateCommit(user, repo, (RevCommit) target, ps, perm);
        } else {
            checkCreateRef(user, repo, branch, target);
        }
        // If the tag has a PGP signature, allow a lower level of permission
        // than if it doesn't have a PGP signature.
        RefControl refControl = ps.controlFor(user.get()).controlForRef(branch);
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            if (!refControl.canPerform(Permission.CREATE_SIGNED_TAG)) {
                throw new AuthException(Permission.CREATE_SIGNED_TAG + " not permitted");
            }
        } else if (!refControl.canPerform(Permission.CREATE_TAG)) {
            throw new AuthException(Permission.CREATE_TAG + " not permitted");
        }
    }
}
#end_block

#method_before
private void checkCreateCommit(Repository repo, RevCommit commit, ProjectState projectState, PermissionBackend.ForRef forRef) throws AuthException, PermissionBackendException {
    try {
        // If the user has update (push) permission, they can create the ref regardless
        // of whether they are pushing any new objects along with the create.
        forRef.check(RefPermission.UPDATE);
        return;
    } catch (AuthException denied) {
    // Fall through to check reachability.
    }
    if (projectState.controlFor(user.get()).isReachableFromHeadsOrTags(repo, commit)) {
        // even if they don't have push permission.
        return;
    }
    throw new AuthException(String.format("%s for creating new commit object not permitted", RefPermission.UPDATE.describeForException()));
}
#method_after
private void checkCreateCommit(Provider<? extends CurrentUser> user, Repository repo, RevCommit commit, ProjectState projectState, PermissionBackend.ForRef forRef) throws AuthException, PermissionBackendException {
    try {
        // If the user has update (push) permission, they can create the ref regardless
        // of whether they are pushing any new objects along with the create.
        forRef.check(RefPermission.UPDATE);
        return;
    } catch (AuthException denied) {
    // Fall through to check reachability.
    }
    if (projectState.controlFor(user.get()).isReachableFromHeadsOrTags(repo, commit)) {
        // even if they don't have push permission.
        return;
    }
    throw new AuthException(String.format("%s for creating new commit object not permitted", RefPermission.UPDATE.describeForException()));
}
#end_block

#method_before
private Repository openRepository(Path path, Project.NameKey name) throws RepositoryNotFoundException {
    if (isUnreasonableName(name)) {
        throw new RepositoryNotFoundException("Invalid name: " + name);
    }
    File gitDir = path.resolve(name.get()).toFile();
    if (!names.contains(name)) {
        // 
        if (!name.get().endsWith(Constants.DOT_GIT_EXT)) {
            if (FileKey.resolve(gitDir, FS.DETECTED) != null) {
                onCreateProject(name);
            } else {
                throw new RepositoryNotFoundException(gitDir);
            }
        } else {
            final File directory = gitDir;
            if (FileKey.isGitRepository(new File(directory, Constants.DOT_GIT), FS.DETECTED)) {
                onCreateProject(name);
            } else if (FileKey.isGitRepository(new File(directory.getParentFile(), directory.getName() + Constants.DOT_GIT_EXT), FS.DETECTED)) {
                onCreateProject(name);
            } else {
                throw new RepositoryNotFoundException(gitDir);
            }
        }
    }
    final FileKey loc = FileKey.lenient(gitDir, FS.DETECTED);
    try {
        return RepositoryCache.open(loc);
    } catch (IOException e1) {
        final RepositoryNotFoundException e2;
        e2 = new RepositoryNotFoundException("Cannot open repository " + name);
        e2.initCause(e1);
        throw e2;
    }
}
#method_after
private Repository openRepository(Path path, Project.NameKey name) throws RepositoryNotFoundException {
    if (isUnreasonableName(name)) {
        throw new RepositoryNotFoundException("Invalid name: " + name);
    }
    FileKey loc = FileKey.lenient(path.resolve(name.get()).toFile(), FS.DETECTED);
    try {
        return RepositoryCache.open(loc);
    } catch (IOException e1) {
        final RepositoryNotFoundException e2;
        e2 = new RepositoryNotFoundException("Cannot open repository " + name);
        e2.initCause(e1);
        throw e2;
    }
}
#end_block

#method_before
@Override
public Repository createRepository(Project.NameKey name) throws RepositoryNotFoundException, RepositoryCaseMismatchException, IOException {
    Path path = getBasePath(name);
    if (isUnreasonableName(name)) {
        throw new RepositoryNotFoundException("Invalid name: " + name);
    }
    File dir = FileKey.resolve(path.resolve(name.get()).toFile(), FS.DETECTED);
    FileKey loc;
    if (dir != null) {
        // Already exists on disk, use the repository we found.
        // 
        Project.NameKey onDiskName = getProjectName(path, dir.getCanonicalFile().toPath());
        onCreateProject(onDiskName);
        loc = FileKey.exact(dir, FS.DETECTED);
        if (!names.contains(name)) {
            throw new RepositoryCaseMismatchException(name);
        }
    } else {
        // It doesn't exist under any of the standard permutations
        // of the repository name, so prefer the standard bare name.
        // 
        String n = name.get() + Constants.DOT_GIT_EXT;
        loc = FileKey.exact(path.resolve(n).toFile(), FS.DETECTED);
    }
    try {
        Repository db = RepositoryCache.open(loc, false);
        db.create(true);
        StoredConfig config = db.getConfig();
        config.setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_LOGALLREFUPDATES, true);
        config.save();
        // JGit only writes to the reflog for refs/meta/config if the log file
        // already exists.
        // 
        File metaConfigLog = new File(db.getDirectory(), "logs/" + RefNames.REFS_CONFIG);
        if (!metaConfigLog.getParentFile().mkdirs() || !metaConfigLog.createNewFile()) {
            log.error(String.format("Failed to create ref log for %s in repository %s", RefNames.REFS_CONFIG, name));
        }
        onCreateProject(name);
        return db;
    } catch (IOException e1) {
        final RepositoryNotFoundException e2;
        e2 = new RepositoryNotFoundException("Cannot create repository " + name);
        e2.initCause(e1);
        throw e2;
    }
}
#method_after
@Override
public Repository createRepository(Project.NameKey name) throws RepositoryNotFoundException, RepositoryCaseMismatchException, IOException {
    Path path = getBasePath(name);
    if (isUnreasonableName(name)) {
        throw new RepositoryNotFoundException("Invalid name: " + name);
    }
    File dir = FileKey.resolve(path.resolve(name.get()).toFile(), FS.DETECTED);
    if (dir != null) {
        // Already exists on disk, use the repository we found.
        // 
        Project.NameKey onDiskName = getProjectName(path, dir.getCanonicalFile().toPath());
        if (!onDiskName.equals(name)) {
            throw new RepositoryCaseMismatchException(name);
        }
        throw new IllegalStateException("Repository already exists: " + name);
    }
    // It doesn't exist under any of the standard permutations
    // of the repository name, so prefer the standard bare name.
    // 
    String n = name.get() + Constants.DOT_GIT_EXT;
    FileKey loc = FileKey.exact(path.resolve(n).toFile(), FS.DETECTED);
    try {
        Repository db = RepositoryCache.open(loc, false);
        db.create(true);
        StoredConfig config = db.getConfig();
        config.setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_LOGALLREFUPDATES, true);
        config.save();
        // JGit only writes to the reflog for refs/meta/config if the log file
        // already exists.
        // 
        File metaConfigLog = new File(db.getDirectory(), "logs/" + RefNames.REFS_CONFIG);
        if (!metaConfigLog.getParentFile().mkdirs() || !metaConfigLog.createNewFile()) {
            log.error(String.format("Failed to create ref log for %s in repository %s", RefNames.REFS_CONFIG, name));
        }
        return db;
    } catch (IOException e1) {
        final RepositoryNotFoundException e2;
        e2 = new RepositoryNotFoundException("Cannot create repository " + name);
        e2.initCause(e1);
        throw e2;
    }
}
#end_block

#method_before
@Override
public SortedSet<Project.NameKey> list() {
    // The results of this method are cached by ProjectCacheImpl. Control only
    // enters here if the cache was flushed by the administrator to force
    // scanning the filesystem.
    // Don't rely on the cached names collection but update it to contain
    // the set of found project names
    ProjectVisitor visitor = new ProjectVisitor(basePath);
    scanProjects(visitor);
    namesUpdateLock.lock();
    try {
        names = Collections.unmodifiableSortedSet(visitor.found);
    } finally {
        namesUpdateLock.unlock();
    }
    return names;
}
#method_after
@Override
public SortedSet<Project.NameKey> list() {
    ProjectVisitor visitor = new ProjectVisitor(basePath);
    scanProjects(visitor);
    return Collections.unmodifiableSortedSet(visitor.found);
}
#end_block

#method_before
public List<PatchSetData> sort(List<ChangeData> in, PatchSet startPs) throws OrmException, IOException {
    checkArgument(!in.isEmpty(), "Input may not be empty");
    // Map of all patch sets, keyed by commit SHA-1.
    Map<String, PatchSetData> byId = collectById(in);
    PatchSetData start = byId.get(startPs.getRevision().get());
    checkArgument(start != null, "%s not found in %s", startPs, in);
    ProjectControl ctl = start.data().changeControl().getProjectControl();
    // Map of patch set -> immediate parent.
    ListMultimap<PatchSetData, PatchSetData> parents = MultimapBuilder.hashKeys(in.size()).arrayListValues(3).build();
    // Map of patch set -> immediate children.
    ListMultimap<PatchSetData, PatchSetData> children = MultimapBuilder.hashKeys(in.size()).arrayListValues(3).build();
    // All other patch sets of the same change as startPs.
    List<PatchSetData> otherPatchSetsOfStart = new ArrayList<>();
    for (ChangeData cd : in) {
        for (PatchSet ps : cd.patchSets()) {
            PatchSetData thisPsd = checkNotNull(byId.get(ps.getRevision().get()));
            if (cd.getId().equals(start.id()) && !ps.getId().equals(start.psId())) {
                otherPatchSetsOfStart.add(thisPsd);
            }
            for (RevCommit p : thisPsd.commit().getParents()) {
                PatchSetData parentPsd = byId.get(p.name());
                if (parentPsd != null) {
                    parents.put(thisPsd, parentPsd);
                    children.put(parentPsd, thisPsd);
                }
            }
        }
    }
    Collection<PatchSetData> ancestors = walkAncestors(ctl, parents, start);
    List<PatchSetData> descendants = walkDescendants(ctl, children, start, otherPatchSetsOfStart, ancestors);
    List<PatchSetData> result = new ArrayList<>(ancestors.size() + descendants.size() - 1);
    result.addAll(Lists.reverse(descendants));
    result.addAll(ancestors);
    return result;
}
#method_after
public List<PatchSetData> sort(List<ChangeData> in, PatchSet startPs, CurrentUser user) throws OrmException, IOException, PermissionBackendException {
    checkArgument(!in.isEmpty(), "Input may not be empty");
    // Map of all patch sets, keyed by commit SHA-1.
    Map<String, PatchSetData> byId = collectById(in);
    PatchSetData start = byId.get(startPs.getRevision().get());
    checkArgument(start != null, "%s not found in %s", startPs, in);
    PermissionBackend.WithUser perm = permissionBackend.user(user).database(dbProvider);
    // Map of patch set -> immediate parent.
    ListMultimap<PatchSetData, PatchSetData> parents = MultimapBuilder.hashKeys(in.size()).arrayListValues(3).build();
    // Map of patch set -> immediate children.
    ListMultimap<PatchSetData, PatchSetData> children = MultimapBuilder.hashKeys(in.size()).arrayListValues(3).build();
    // All other patch sets of the same change as startPs.
    List<PatchSetData> otherPatchSetsOfStart = new ArrayList<>();
    for (ChangeData cd : in) {
        for (PatchSet ps : cd.patchSets()) {
            PatchSetData thisPsd = checkNotNull(byId.get(ps.getRevision().get()));
            if (cd.getId().equals(start.id()) && !ps.getId().equals(start.psId())) {
                otherPatchSetsOfStart.add(thisPsd);
            }
            for (RevCommit p : thisPsd.commit().getParents()) {
                PatchSetData parentPsd = byId.get(p.name());
                if (parentPsd != null) {
                    parents.put(thisPsd, parentPsd);
                    children.put(parentPsd, thisPsd);
                }
            }
        }
    }
    Collection<PatchSetData> ancestors = walkAncestors(perm, parents, start);
    List<PatchSetData> descendants = walkDescendants(perm, children, start, otherPatchSetsOfStart, ancestors);
    List<PatchSetData> result = new ArrayList<>(ancestors.size() + descendants.size() - 1);
    result.addAll(Lists.reverse(descendants));
    result.addAll(ancestors);
    return result;
}
#end_block

#method_before
private static Collection<PatchSetData> walkAncestors(ProjectControl ctl, ListMultimap<PatchSetData, PatchSetData> parents, PatchSetData start) throws OrmException {
    LinkedHashSet<PatchSetData> result = new LinkedHashSet<>();
    Deque<PatchSetData> pending = new ArrayDeque<>();
    pending.add(start);
    while (!pending.isEmpty()) {
        PatchSetData psd = pending.remove();
        if (result.contains(psd) || !isVisible(psd, ctl)) {
            continue;
        }
        result.add(psd);
        pending.addAll(Lists.reverse(parents.get(psd)));
    }
    return result;
}
#method_after
private static Collection<PatchSetData> walkAncestors(PermissionBackend.WithUser perm, ListMultimap<PatchSetData, PatchSetData> parents, PatchSetData start) throws PermissionBackendException {
    LinkedHashSet<PatchSetData> result = new LinkedHashSet<>();
    Deque<PatchSetData> pending = new ArrayDeque<>();
    pending.add(start);
    while (!pending.isEmpty()) {
        PatchSetData psd = pending.remove();
        if (result.contains(psd) || !isVisible(psd, perm)) {
            continue;
        }
        result.add(psd);
        pending.addAll(Lists.reverse(parents.get(psd)));
    }
    return result;
}
#end_block

#method_before
private static List<PatchSetData> walkDescendants(ProjectControl ctl, ListMultimap<PatchSetData, PatchSetData> children, PatchSetData start, List<PatchSetData> otherPatchSetsOfStart, Iterable<PatchSetData> ancestors) throws OrmException {
    Set<Change.Id> alreadyEmittedChanges = new HashSet<>();
    addAllChangeIds(alreadyEmittedChanges, ancestors);
    // Prefer descendants found by following the original patch set passed in.
    List<PatchSetData> result = walkDescendentsImpl(ctl, alreadyEmittedChanges, children, ImmutableList.of(start));
    addAllChangeIds(alreadyEmittedChanges, result);
    // Then, go back and add new indirect descendants found by following any
    // other patch sets of start. These show up after all direct descendants,
    // because we wouldn't know where in the walk to insert them.
    result.addAll(walkDescendentsImpl(ctl, alreadyEmittedChanges, children, otherPatchSetsOfStart));
    return result;
}
#method_after
private static List<PatchSetData> walkDescendants(PermissionBackend.WithUser perm, ListMultimap<PatchSetData, PatchSetData> children, PatchSetData start, List<PatchSetData> otherPatchSetsOfStart, Iterable<PatchSetData> ancestors) throws PermissionBackendException {
    Set<Change.Id> alreadyEmittedChanges = new HashSet<>();
    addAllChangeIds(alreadyEmittedChanges, ancestors);
    // Prefer descendants found by following the original patch set passed in.
    List<PatchSetData> result = walkDescendentsImpl(perm, alreadyEmittedChanges, children, ImmutableList.of(start));
    addAllChangeIds(alreadyEmittedChanges, result);
    // Then, go back and add new indirect descendants found by following any
    // other patch sets of start. These show up after all direct descendants,
    // because we wouldn't know where in the walk to insert them.
    result.addAll(walkDescendentsImpl(perm, alreadyEmittedChanges, children, otherPatchSetsOfStart));
    return result;
}
#end_block

#method_before
private static List<PatchSetData> walkDescendentsImpl(ProjectControl ctl, Set<Change.Id> alreadyEmittedChanges, ListMultimap<PatchSetData, PatchSetData> children, List<PatchSetData> start) throws OrmException {
    if (start.isEmpty()) {
        return ImmutableList.of();
    }
    Map<Change.Id, PatchSet.Id> maxPatchSetIds = new HashMap<>();
    Set<PatchSetData> seen = new HashSet<>();
    List<PatchSetData> allPatchSets = new ArrayList<>();
    Deque<PatchSetData> pending = new ArrayDeque<>();
    pending.addAll(start);
    while (!pending.isEmpty()) {
        PatchSetData psd = pending.remove();
        if (seen.contains(psd) || !isVisible(psd, ctl)) {
            continue;
        }
        seen.add(psd);
        if (!alreadyEmittedChanges.contains(psd.id())) {
            // Don't emit anything for changes that were previously emitted, even
            // though different patch sets might show up later. However, do
            // continue walking through them for the purposes of finding indirect
            // descendants.
            PatchSet.Id oldMax = maxPatchSetIds.get(psd.id());
            if (oldMax == null || psd.psId().get() > oldMax.get()) {
                maxPatchSetIds.put(psd.id(), psd.psId());
            }
            allPatchSets.add(psd);
        }
        // Depth-first search with newest children first.
        for (PatchSetData child : children.get(psd)) {
            pending.addFirst(child);
        }
    }
    // If we saw the same change multiple times, prefer the latest patch set.
    List<PatchSetData> result = new ArrayList<>(allPatchSets.size());
    for (PatchSetData psd : allPatchSets) {
        if (checkNotNull(maxPatchSetIds.get(psd.id())).equals(psd.psId())) {
            result.add(psd);
        }
    }
    return result;
}
#method_after
private static List<PatchSetData> walkDescendentsImpl(PermissionBackend.WithUser perm, Set<Change.Id> alreadyEmittedChanges, ListMultimap<PatchSetData, PatchSetData> children, List<PatchSetData> start) throws PermissionBackendException {
    if (start.isEmpty()) {
        return ImmutableList.of();
    }
    Map<Change.Id, PatchSet.Id> maxPatchSetIds = new HashMap<>();
    Set<PatchSetData> seen = new HashSet<>();
    List<PatchSetData> allPatchSets = new ArrayList<>();
    Deque<PatchSetData> pending = new ArrayDeque<>();
    pending.addAll(start);
    while (!pending.isEmpty()) {
        PatchSetData psd = pending.remove();
        if (seen.contains(psd) || !isVisible(psd, perm)) {
            continue;
        }
        seen.add(psd);
        if (!alreadyEmittedChanges.contains(psd.id())) {
            // Don't emit anything for changes that were previously emitted, even
            // though different patch sets might show up later. However, do
            // continue walking through them for the purposes of finding indirect
            // descendants.
            PatchSet.Id oldMax = maxPatchSetIds.get(psd.id());
            if (oldMax == null || psd.psId().get() > oldMax.get()) {
                maxPatchSetIds.put(psd.id(), psd.psId());
            }
            allPatchSets.add(psd);
        }
        // Depth-first search with newest children first.
        for (PatchSetData child : children.get(psd)) {
            pending.addFirst(child);
        }
    }
    // If we saw the same change multiple times, prefer the latest patch set.
    List<PatchSetData> result = new ArrayList<>(allPatchSets.size());
    for (PatchSetData psd : allPatchSets) {
        if (checkNotNull(maxPatchSetIds.get(psd.id())).equals(psd.psId())) {
            result.add(psd);
        }
    }
    return result;
}
#end_block

#method_before
private static boolean isVisible(PatchSetData psd, ProjectControl ctl) throws OrmException {
    // each ChangeData.
    return ctl.controlFor(psd.data().notes()).isPatchVisible(psd.patchSet(), psd.data());
}
#method_after
private static boolean isVisible(PatchSetData psd, PermissionBackend.WithUser perm) throws PermissionBackendException {
    try {
        perm.change(psd.data()).check(ChangePermission.READ);
        return true;
    } catch (AuthException e) {
        return false;
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountCacheImpl.module());
    install(BatchUpdate.module());
    install(ChangeKindCacheImpl.module());
    install(ChangeFinder.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new ExternalIdModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new ReceiveCommitsModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.AssistedFactory.class);
    factory(ChangeJson.AssistedFactory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    bind(UiActions.class);
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), AccountIndexedListener.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), GroupIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterRefUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicSet.setOf(binder(), TagWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    bind(MailFilter.class).annotatedWith(Exports.named("ListMailFilter")).to(ListMailFilter.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryProcessor.ChangeAttributeFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(AccountMergeValidator.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountCacheImpl.module());
    install(BatchUpdate.module());
    install(ChangeKindCacheImpl.module());
    install(ChangeFinder.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new ExternalIdModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new ReceiveCommitsModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.AssistedFactory.class);
    factory(ChangeJson.AssistedFactory.class);
    factory(CreateChangeSender.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    factory(SubmitRuleEvaluator.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(AccountDeactivator.class);
    bind(ApprovalsUtil.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    bind(UiActions.class);
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), AccountIndexedListener.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), GroupIndexedListener.class);
    DynamicSet.setOf(binder(), ProjectIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterRefUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicSet.setOf(binder(), TagWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    DynamicItem.itemOf(binder(), MergeSuperSetComputation.class);
    DynamicItem.itemOf(binder(), ProjectNameLockManager.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    bind(MailFilter.class).annotatedWith(Exports.named("ListMailFilter")).to(ListMailFilter.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryProcessor.ChangeAttributeFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(AccountMergeValidator.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> enforceVisibility(Predicate<ChangeData> pred) {
    return new AndChangeSource(pred, new ChangeIsVisibleToPredicate(db, notesFactory, changeControlFactory, userProvider.get(), permissionBackend), start);
}
#method_after
@Override
protected Predicate<ChangeData> enforceVisibility(Predicate<ChangeData> pred) {
    return new AndChangeSource(pred, new ChangeIsVisibleToPredicate(db, notesFactory, userProvider.get(), permissionBackend), start);
}
#end_block

#method_before
public BanCommitResult ban(ProjectControl projectControl, List<ObjectId> commitsToBan, String reason) throws PermissionDeniedException, LockFailureException, IOException {
    if (!projectControl.isOwner()) {
        throw new PermissionDeniedException("Not project owner: not permitted to ban commits");
    }
    final BanCommitResult result = new BanCommitResult();
    NoteMap banCommitNotes = NoteMap.newEmptyMap();
    // Add a note for each banned commit to notes.
    final Project.NameKey project = projectControl.getProject().getNameKey();
    try (Repository repo = repoManager.openRepository(project);
        RevWalk revWalk = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter()) {
        ObjectId noteId = null;
        for (ObjectId commitToBan : commitsToBan) {
            try {
                revWalk.parseCommit(commitToBan);
            } catch (MissingObjectException e) {
            // Ignore exception, non-existing commits can be banned.
            } catch (IncorrectObjectTypeException e) {
                result.notACommit(commitToBan);
                continue;
            }
            if (noteId == null) {
                noteId = createNoteContent(reason, inserter);
            }
            banCommitNotes.set(commitToBan, noteId);
        }
        NotesBranchUtil notesBranchUtil = notesBranchUtilFactory.create(project, repo, inserter);
        NoteMap newlyCreated = notesBranchUtil.commitNewNotes(banCommitNotes, REFS_REJECT_COMMITS, createPersonIdent(), buildCommitMessage(commitsToBan, reason));
        for (Note n : banCommitNotes) {
            if (newlyCreated.contains(n)) {
                result.commitBanned(n);
            } else {
                result.commitAlreadyBanned(n);
            }
        }
        return result;
    }
}
#method_after
public BanCommitResult ban(Project.NameKey project, CurrentUser user, List<ObjectId> commitsToBan, String reason) throws AuthException, LockFailureException, IOException, PermissionBackendException {
    permissionBackend.user(user).project(project).check(ProjectPermission.BAN_COMMIT);
    final BanCommitResult result = new BanCommitResult();
    NoteMap banCommitNotes = NoteMap.newEmptyMap();
    // Add a note for each banned commit to notes.
    try (Repository repo = repoManager.openRepository(project);
        RevWalk revWalk = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter()) {
        ObjectId noteId = null;
        for (ObjectId commitToBan : commitsToBan) {
            try {
                revWalk.parseCommit(commitToBan);
            } catch (MissingObjectException e) {
            // Ignore exception, non-existing commits can be banned.
            } catch (IncorrectObjectTypeException e) {
                result.notACommit(commitToBan);
                continue;
            }
            if (noteId == null) {
                noteId = createNoteContent(reason, inserter);
            }
            banCommitNotes.set(commitToBan, noteId);
        }
        NotesBranchUtil notesBranchUtil = notesBranchUtilFactory.create(project, repo, inserter);
        NoteMap newlyCreated = notesBranchUtil.commitNewNotes(banCommitNotes, REFS_REJECT_COMMITS, createPersonIdent(), buildCommitMessage(commitsToBan, reason));
        for (Note n : banCommitNotes) {
            if (newlyCreated.contains(n)) {
                result.commitBanned(n);
            } else {
                result.commitAlreadyBanned(n);
            }
        }
        return result;
    }
}
#end_block

#method_before
public Result normalize(ChangeNotes notes, Collection<PatchSetApproval> approvals) throws OrmException, PermissionBackendException, IOException {
    IdentifiedUser user = userFactory.create(notes.getChange().getOwner());
    return normalize(notes, user, approvals);
}
#method_after
public Result normalize(ChangeNotes notes, Collection<PatchSetApproval> approvals) throws OrmException, IOException {
    IdentifiedUser user = userFactory.create(notes.getChange().getOwner());
    return normalize(notes, user, approvals);
}
#end_block

#method_before
public Result normalize(ChangeNotes notes, CurrentUser user, Collection<PatchSetApproval> approvals) throws PermissionBackendException, IOException {
    List<PatchSetApproval> unchanged = Lists.newArrayListWithCapacity(approvals.size());
    List<PatchSetApproval> updated = Lists.newArrayListWithCapacity(approvals.size());
    List<PatchSetApproval> deleted = Lists.newArrayListWithCapacity(approvals.size());
    LabelTypes labelTypes = projectCache.checkedGet(notes.getProjectName()).getLabelTypes(notes, user);
    for (PatchSetApproval psa : approvals) {
        Change.Id changeId = psa.getKey().getParentKey().getParentKey();
        checkArgument(changeId.equals(notes.getChangeId()), "Approval %s does not match change %s", psa.getKey(), notes.getChange().getKey());
        if (psa.isLegacySubmit()) {
            unchanged.add(psa);
            continue;
        }
        LabelType label = labelTypes.byLabel(psa.getLabelId());
        if (label == null) {
            deleted.add(psa);
            continue;
        }
        PatchSetApproval copy = copy(psa);
        applyTypeFloor(label, copy);
        if (!applyRightFloor(notes, label, copy)) {
            deleted.add(psa);
        } else if (copy.getValue() != psa.getValue()) {
            updated.add(copy);
        } else {
            unchanged.add(psa);
        }
    }
    return Result.create(unchanged, updated, deleted);
}
#method_after
public Result normalize(ChangeNotes notes, CurrentUser user, Collection<PatchSetApproval> approvals) throws IOException {
    List<PatchSetApproval> unchanged = Lists.newArrayListWithCapacity(approvals.size());
    List<PatchSetApproval> updated = Lists.newArrayListWithCapacity(approvals.size());
    List<PatchSetApproval> deleted = Lists.newArrayListWithCapacity(approvals.size());
    LabelTypes labelTypes = projectCache.checkedGet(notes.getProjectName()).getLabelTypes(notes, user);
    for (PatchSetApproval psa : approvals) {
        Change.Id changeId = psa.getKey().getParentKey().getParentKey();
        checkArgument(changeId.equals(notes.getChangeId()), "Approval %s does not match change %s", psa.getKey(), notes.getChange().getKey());
        if (psa.isLegacySubmit()) {
            unchanged.add(psa);
            continue;
        }
        LabelType label = labelTypes.byLabel(psa.getLabelId());
        if (label == null) {
            deleted.add(psa);
            continue;
        }
        PatchSetApproval copy = copy(psa);
        applyTypeFloor(label, copy);
        if (copy.getValue() != psa.getValue()) {
            updated.add(copy);
        } else {
            unchanged.add(psa);
        }
    }
    return Result.create(unchanged, updated, deleted);
}
#end_block

#method_before
public RevisionInfo revisionInfo(Project project, PatchSet ps) throws OrmException, PatchListNotAvailableException, GpgException, IOException {
    return revisionInfo(project.getNameKey(), ps);
}
#method_after
public RevisionInfo revisionInfo(Project project, PatchSet ps) throws OrmException, PatchListNotAvailableException, GpgException, IOException, PermissionBackendException {
    return revisionInfo(project.getNameKey(), ps);
}
#end_block

#method_before
public RevisionInfo revisionInfo(Project.NameKey project, PatchSet ps) throws OrmException, PatchListNotAvailableException, GpgException, IOException {
    ChangeData cd = changeDataFactory.create(db.get(), project, ps.getId().getParentKey());
    ChangeControl ctl = cd.changeControl();
    return changeJson.getRevisionInfo(ctl, ps);
}
#method_after
public RevisionInfo revisionInfo(Project.NameKey project, PatchSet ps) throws OrmException, PatchListNotAvailableException, GpgException, IOException, PermissionBackendException {
    ChangeData cd = changeDataFactory.create(db.get(), project, ps.getId().getParentKey());
    return changeJson.getRevisionInfo(cd, ps);
}
#end_block

#method_before
public PatchSet insert(ReviewDb db, RevWalk rw, ChangeUpdate update, PatchSet.Id psId, ObjectId commit, boolean draft, List<String> groups, String pushCertificate, String description) throws OrmException, IOException {
    checkNotNull(groups, "groups may not be null");
    ensurePatchSetMatches(psId, update);
    PatchSet ps = new PatchSet(psId);
    ps.setRevision(new RevId(commit.name()));
    ps.setUploader(update.getAccountId());
    ps.setCreatedOn(new Timestamp(update.getWhen().getTime()));
    ps.setDraft(draft);
    ps.setGroups(groups);
    ps.setPushCertificate(pushCertificate);
    ps.setDescription(description);
    db.patchSets().insert(Collections.singleton(ps));
    update.setCommit(rw, commit, pushCertificate);
    update.setPsDescription(description);
    update.setGroups(groups);
    if (draft) {
        update.setPatchSetState(DRAFT);
    }
    return ps;
}
#method_after
public PatchSet insert(ReviewDb db, RevWalk rw, ChangeUpdate update, PatchSet.Id psId, ObjectId commit, List<String> groups, String pushCertificate, String description) throws OrmException, IOException {
    checkNotNull(groups, "groups may not be null");
    ensurePatchSetMatches(psId, update);
    PatchSet ps = new PatchSet(psId);
    ps.setRevision(new RevId(commit.name()));
    ps.setUploader(update.getAccountId());
    ps.setCreatedOn(new Timestamp(update.getWhen().getTime()));
    ps.setGroups(groups);
    ps.setPushCertificate(pushCertificate);
    ps.setDescription(description);
    db.patchSets().insert(Collections.singleton(ps));
    update.setCommit(rw, commit, pushCertificate);
    update.setPsDescription(description);
    update.setGroups(groups);
    return ps;
}
#end_block

#method_before
public void publish(ReviewDb db, ChangeUpdate update, PatchSet ps) throws OrmException {
    ensurePatchSetMatches(ps.getId(), update);
    ps.setDraft(false);
    update.setPatchSetState(PUBLISHED);
    db.patchSets().update(Collections.singleton(ps));
}
#method_after
public void publish(ReviewDb db, ChangeUpdate update, PatchSet ps) throws OrmException {
    ensurePatchSetMatches(ps.getId(), update);
    update.setPatchSetState(PUBLISHED);
    db.patchSets().update(Collections.singleton(ps));
}
#end_block

#method_before
public static Set<String> getFileParts(ChangeData cd) throws OrmException {
    List<String> paths = cd.currentFilePaths();
    if (paths == null) {
        return ImmutableSet.of();
    }
    Splitter s = Splitter.on('/').omitEmptyStrings();
    Set<String> r = new HashSet<>();
    for (String path : paths) {
        for (String part : s.split(path)) {
            r.add(part);
        }
    }
    return r;
}
#method_after
public static Set<String> getFileParts(ChangeData cd) throws OrmException {
    List<String> paths;
    try {
        paths = cd.currentFilePaths();
    } catch (IOException e) {
        throw new OrmException(e);
    }
    Splitter s = Splitter.on('/').omitEmptyStrings();
    Set<String> r = new HashSet<>();
    for (String path : paths) {
        for (String part : s.split(path)) {
            r.add(part);
        }
    }
    return r;
}
#end_block

#method_before
public static void parseSubmitRecords(Collection<String> values, SubmitRuleOptions opts, ChangeData out) {
    checkArgument(!opts.fastEvalLabels());
    List<SubmitRecord> records = parseSubmitRecords(values);
    if (records.isEmpty()) {
        // SubmitRuleEvaluator ensures the list is non-empty.
        return;
    }
    out.setSubmitRecords(opts, records);
    // Cache the fastEvalLabels variant as well so it can be used by
    // ChangeJson.
    out.setSubmitRecords(opts.toBuilder().fastEvalLabels(true).build(), records);
}
#method_after
public static void parseSubmitRecords(Collection<String> values, SubmitRuleOptions opts, ChangeData out) {
    List<SubmitRecord> records = parseSubmitRecords(values);
    if (records.isEmpty()) {
        // SubmitRuleEvaluator ensures the list is non-empty.
        return;
    }
    out.setSubmitRecords(opts, records);
}
#end_block

#method_before
@Override
public boolean match(AccountGroup group) throws OrmException {
    try {
        return groupControlFactory.controlFor(user, group.getGroupUUID()).isVisible();
    } catch (NoSuchGroupException e) {
        // Ignored
        return false;
    }
}
#method_after
@Override
public boolean match(InternalGroup group) throws OrmException {
    try {
        return groupControlFactory.controlFor(user, group.getGroupUUID()).isVisible();
    } catch (NoSuchGroupException e) {
        // Ignored
        return false;
    }
}
#end_block

#method_before
@Override
public void name(String name) throws RestApiException {
    PutName.Input in = new PutName.Input();
    in.name = name;
    try {
        putName.apply(rsrc, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot put group name", e);
    }
}
#method_after
@Override
public void name(String name) throws RestApiException {
    NameInput in = new NameInput();
    in.name = name;
    try {
        putName.apply(rsrc, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot put group name", e);
    }
}
#end_block

#method_before
@Override
public void owner(String owner) throws RestApiException {
    PutOwner.Input in = new PutOwner.Input();
    in.owner = owner;
    try {
        putOwner.apply(rsrc, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot put group owner", e);
    }
}
#method_after
@Override
public void owner(String owner) throws RestApiException {
    OwnerInput in = new OwnerInput();
    in.owner = owner;
    try {
        putOwner.apply(rsrc, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot put group owner", e);
    }
}
#end_block

#method_before
@Override
public void description(String description) throws RestApiException {
    PutDescription.Input in = new PutDescription.Input();
    in.description = description;
    try {
        putDescription.apply(rsrc, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot put group description", e);
    }
}
#method_after
@Override
public void description(String description) throws RestApiException {
    DescriptionInput in = new DescriptionInput();
    in.description = description;
    try {
        putDescription.apply(rsrc, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot put group description", e);
    }
}
#end_block

#method_before
@Override
public List<GroupInfo> includedGroups() throws RestApiException {
    try {
        return listGroups.apply(rsrc);
    } catch (Exception e) {
        throw asRestApiException("Cannot list included groups", e);
    }
}
#method_after
@Override
public List<GroupInfo> includedGroups() throws RestApiException {
    try {
        return listSubgroups.apply(rsrc);
    } catch (Exception e) {
        throw asRestApiException("Cannot list subgroups", e);
    }
}
#end_block

#method_before
@Override
public void addGroups(String... groups) throws RestApiException {
    try {
        addGroups.apply(rsrc, AddIncludedGroups.Input.fromGroups(Arrays.asList(groups)));
    } catch (Exception e) {
        throw asRestApiException("Cannot add group members", e);
    }
}
#method_after
@Override
public void addGroups(String... groups) throws RestApiException {
    try {
        addSubgroups.apply(rsrc, AddSubgroups.Input.fromGroups(Arrays.asList(groups)));
    } catch (Exception e) {
        throw asRestApiException("Cannot add subgroups", e);
    }
}
#end_block

#method_before
@Override
public void removeGroups(String... groups) throws RestApiException {
    try {
        deleteGroups.apply(rsrc, AddIncludedGroups.Input.fromGroups(Arrays.asList(groups)));
    } catch (Exception e) {
        throw asRestApiException("Cannot remove group members", e);
    }
}
#method_after
@Override
public void removeGroups(String... groups) throws RestApiException {
    try {
        deleteSubgroups.apply(rsrc, AddSubgroups.Input.fromGroups(Arrays.asList(groups)));
    } catch (Exception e) {
        throw asRestApiException("Cannot remove subgroups", e);
    }
}
#end_block

#method_before
@Override
public void index() throws RestApiException {
    try {
        index.apply(rsrc, new Index.Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot index group", e);
    }
}
#method_after
@Override
public void index() throws RestApiException {
    try {
        index.apply(rsrc, new Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot index group", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public PostCaches post(ConfigResource parent) throws RestApiException {
    return postCaches;
}
#method_after
@Override
public PostCaches post(ConfigResource parent) throws RestApiException {
    return postCaches;
}
#end_block

#method_before
@Override
public AuthRequest authenticate(AuthRequest who) throws AccountException {
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        who.setLocalUser(who.getLocalUser().toLowerCase(Locale.US));
    }
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, who.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username, fetchMemberOfEagerly);
            if (authConfig.getAuthType() == AuthType.LDAP && !who.isSkipAuthentication()) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), who.getPassword()).close();
            }
            who.setDisplayName(apply(schema.accountFullName, m));
            who.setUserName(apply(schema.accountSshUserName, m));
            if (schema.accountEmailAddress != null) {
                who.setEmailAddress(apply(schema.accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // 
            if (fetchMemberOfEagerly || mandatoryGroup != null) {
                Set<AccountGroup.UUID> groups = helper.queryForGroups(ctx, username, m);
                if (mandatoryGroup != null) {
                    GroupReference mandatoryGroupRef = GroupBackends.findExactSuggestion(groupBackend, mandatoryGroup);
                    if (mandatoryGroupRef == null) {
                        throw new AccountException("Could not identify mandatory group: " + mandatoryGroup);
                    }
                    if (!groups.contains(mandatoryGroupRef.getUUID())) {
                        throw new AccountException("Not member of mandatory LDAP group: " + mandatoryGroupRef.getName());
                    }
                }
                // Regardless if we enabled fetchMemberOfEagerly, we already have the
                // groups and it would be a waste not to cache them.
                membershipCache.put(username, groups);
            }
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    }
}
#method_after
@Override
public AuthRequest authenticate(AuthRequest who) throws AccountException {
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        who.setLocalUser(who.getLocalUser().toLowerCase(Locale.US));
    }
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, who.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            LdapQuery.Result m;
            who.setAuthProvidesAccountActiveStatus(true);
            try {
                m = helper.findAccount(schema, ctx, username, fetchMemberOfEagerly);
                who.setActive(true);
            } catch (NoSuchUserException e) {
                who.setActive(false);
                return who;
            }
            if (authConfig.getAuthType() == AuthType.LDAP && !who.isSkipAuthentication()) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), who.getPassword()).close();
            }
            who.setDisplayName(apply(schema.accountFullName, m));
            who.setUserName(apply(schema.accountSshUserName, m));
            if (schema.accountEmailAddress != null) {
                who.setEmailAddress(apply(schema.accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // 
            if (fetchMemberOfEagerly || mandatoryGroup != null) {
                Set<AccountGroup.UUID> groups = helper.queryForGroups(ctx, username, m);
                if (mandatoryGroup != null) {
                    GroupReference mandatoryGroupRef = GroupBackends.findExactSuggestion(groupBackend, mandatoryGroup);
                    if (mandatoryGroupRef == null) {
                        throw new AccountException("Could not identify mandatory group: " + mandatoryGroup);
                    }
                    if (!groups.contains(mandatoryGroupRef.getUUID())) {
                        throw new AccountException("Not member of mandatory LDAP group: " + mandatoryGroupRef.getName());
                    }
                }
                // Regardless if we enabled fetchMemberOfEagerly, we already have the
                // groups and it would be a waste not to cache them.
                membershipCache.put(username, groups);
            }
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
public void checkRemoveReviewer(ChangeNotes notes, CurrentUser currentUser, PatchSetApproval approval) throws PermissionBackendException, AuthException, NoSuchChangeException {
    if (canRemoveReviewerWithoutPermissionCheck(notes, currentUser, approval.getAccountId(), approval.getValue())) {
        return;
    }
    permissionBackend.user(currentUser).change(notes).database(dbProvider).check(ChangePermission.REMOVE_REVIEWER);
}
#method_after
public void checkRemoveReviewer(ChangeNotes notes, CurrentUser currentUser, PatchSetApproval approval) throws PermissionBackendException, AuthException, NoSuchProjectException, IOException {
    if (canRemoveReviewerWithoutPermissionCheck(notes.getChange(), currentUser, approval.getAccountId(), approval.getValue())) {
        return;
    }
    permissionBackend.user(currentUser).change(notes).database(dbProvider).check(ChangePermission.REMOVE_REVIEWER);
}
#end_block

#method_before
public boolean testRemoveReviewer(ChangeNotes notes, CurrentUser currentUser, Account.Id reviewer, int value) throws PermissionBackendException, NoSuchChangeException {
    if (canRemoveReviewerWithoutPermissionCheck(notes, currentUser, reviewer, value)) {
        return true;
    }
    return permissionBackend.user(currentUser).change(notes).database(dbProvider).test(ChangePermission.REMOVE_REVIEWER);
}
#method_after
public boolean testRemoveReviewer(ChangeData cd, CurrentUser currentUser, Account.Id reviewer, int value) throws PermissionBackendException, NoSuchProjectException, OrmException, IOException {
    if (canRemoveReviewerWithoutPermissionCheck(cd.change(), currentUser, reviewer, value)) {
        return true;
    }
    return permissionBackend.user(currentUser).change(cd).database(dbProvider).test(ChangePermission.REMOVE_REVIEWER);
}
#end_block

#method_before
private boolean canRemoveReviewerWithoutPermissionCheck(ChangeNotes notes, CurrentUser currentUser, Account.Id reviewer, int value) throws NoSuchChangeException {
    ChangeControl changeControl = changeControlFactory.controlFor(notes, currentUser);
    if (!changeControl.getChange().getStatus().isOpen()) {
        return false;
    }
    // A user can always remove themselves.
    if (changeControl.getUser().isIdentifiedUser()) {
        if (changeControl.getUser().getAccountId().equals(reviewer)) {
            // can remove self
            return true;
        }
    }
    // The change owner may remove any zero or positive score.
    if (currentUser.isIdentifiedUser() && currentUser.getAccountId().equals(notes.getChange().getOwner()) && 0 <= value) {
        return true;
    }
    // owner and site admin can remove anyone
    if (// branch owner
    changeControl.getRefControl().isOwner() || // project owner
    changeControl.getProjectControl().isOwner() || changeControl.getProjectControl().isAdmin()) {
        // project admin
        return true;
    }
    return false;
}
#method_after
private boolean canRemoveReviewerWithoutPermissionCheck(Change change, CurrentUser currentUser, Account.Id reviewer, int value) throws NoSuchProjectException, IOException {
    if (!change.getStatus().isOpen()) {
        return false;
    }
    if (currentUser.isIdentifiedUser()) {
        Account.Id aId = currentUser.getAccountId();
        if (aId.equals(reviewer)) {
            // A user can always remove themselves.
            return true;
        } else if (aId.equals(change.getOwner()) && 0 <= value) {
            // The change owner may remove any zero or positive score.
            return true;
        }
    }
    // Users with the remove reviewer permission, the branch owner, project
    // owner and site admin can remove anyone
    // TODO(hiesel): Remove all Control usage
    ProjectControl ctl = projectControlFactory.controlFor(change.getProject(), currentUser);
    if (// branch owner
    ctl.controlForRef(change.getDest()).isOwner() || // project owner
    ctl.isOwner() || ctl.isAdmin()) {
        // project admin
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try (StatementExecutor e = newExecutor(db)) {
        // Initialize review_started to a sensible default value according to
        // whether change is currently WIP. No migration is needed in NoteDb,
        // where the value of review_started is always derived from the history
        // of assignments to work_in_progress.
        e.execute("UPDATE changes SET review_started = 'Y' WHERE work_in_progress = 'N'");
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try (StatementExecutor e = newExecutor(db)) {
        // Initialize review_started to a sensible default value according to
        // whether change is currently WIP. No migration is needed in NoteDb,
        // where the value of review_started is always derived from the history
        // of assignments to work_in_progress.
        e.execute("UPDATE changes SET review_started = 'Y', created_on = created_on WHERE work_in_progress = 'N'");
    }
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, InvalidChangeOperationException, RestApiException, IOException, OrmException, PermissionBackendException {
    if (args.mergeUtil.canFastForward(args.mergeSorter, args.mergeTip.getCurrentTip(), args.rw, toMerge)) {
        if (!rebaseAlways) {
            args.mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
            toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            acceptMergeTip(args.mergeTip);
            return;
        }
        // RebaseAlways means we modify commit message.
        args.rw.parseBody(toMerge);
        newPatchSetId = ChangeUtil.nextPatchSetIdFromChangeRefsMap(ctx.getRepoView().getRefs(getId().toRefPrefix()), toMerge.change().currentPatchSetId());
        RevCommit mergeTip = args.mergeTip.getCurrentTip();
        args.rw.parseBody(mergeTip);
        String cherryPickCmtMsg = args.mergeUtil.createCommitMessageOnSubmit(toMerge, mergeTip);
        PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
        try {
            newCommit = args.mergeUtil.createCherryPickFromCommit(ctx.getInserter(), ctx.getRepoView().getConfig(), args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, true);
        } catch (MergeConflictException mce) {
            // Unlike in Cherry-pick case, this should never happen.
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IllegalStateException("MergeConflictException on message edit must not happen");
        } catch (MergeIdenticalTreeException mie) {
            // this should not happen
            toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
            return;
        }
        ctx.addRefUpdate(ObjectId.zeroId(), newCommit, newPatchSetId.toRefName());
    } else {
        // Stale read of patch set is ok; see comments in RebaseChangeOp.
        PatchSet origPs = args.psUtil.get(ctx.getDb(), toMerge.getControl().getNotes(), toMerge.getPatchsetId());
        rebaseOp = args.rebaseFactory.create(toMerge.getControl(), origPs, args.mergeTip.getCurrentTip()).setFireRevisionCreated(false).setCopyApprovals(false).setValidate(false).setCheckAddPatchSetPermission(false).setDetailedCommitMessage(rebaseAlways).setPostMessage(false).setMatchAuthorToCommitterDate(args.project.isMatchAuthorToCommitterDate());
        try {
            rebaseOp.updateRepo(ctx);
        } catch (MergeConflictException | NoSuchChangeException e) {
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IntegrationException("Cannot rebase " + toMerge.name() + ": " + e.getMessage(), e);
        }
        newCommit = args.rw.parseCommit(rebaseOp.getRebasedCommit());
        newPatchSetId = rebaseOp.getPatchSetId();
    }
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(newPatchSetId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_REBASE);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commitStatus.put(args.mergeTip.getCurrentTip());
    acceptMergeTip(args.mergeTip);
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, InvalidChangeOperationException, RestApiException, IOException, OrmException, PermissionBackendException {
    if (args.mergeUtil.canFastForward(args.mergeSorter, args.mergeTip.getCurrentTip(), args.rw, toMerge)) {
        if (!rebaseAlways) {
            args.mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
            toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            acceptMergeTip(args.mergeTip);
            return;
        }
        // RebaseAlways means we modify commit message.
        args.rw.parseBody(toMerge);
        newPatchSetId = ChangeUtil.nextPatchSetIdFromChangeRefsMap(ctx.getRepoView().getRefs(getId().toRefPrefix()), toMerge.change().currentPatchSetId());
        RevCommit mergeTip = args.mergeTip.getCurrentTip();
        args.rw.parseBody(mergeTip);
        String cherryPickCmtMsg = args.mergeUtil.createCommitMessageOnSubmit(toMerge, mergeTip);
        PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
        try {
            newCommit = args.mergeUtil.createCherryPickFromCommit(ctx.getInserter(), ctx.getRepoView().getConfig(), args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, true);
        } catch (MergeConflictException mce) {
            // Unlike in Cherry-pick case, this should never happen.
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IllegalStateException("MergeConflictException on message edit must not happen");
        } catch (MergeIdenticalTreeException mie) {
            // this should not happen
            toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
            return;
        }
        ctx.addRefUpdate(ObjectId.zeroId(), newCommit, newPatchSetId.toRefName());
    } else {
        // Stale read of patch set is ok; see comments in RebaseChangeOp.
        PatchSet origPs = args.psUtil.get(ctx.getDb(), toMerge.getNotes(), toMerge.getPatchsetId());
        rebaseOp = args.rebaseFactory.create(toMerge.notes(), origPs, args.mergeTip.getCurrentTip()).setFireRevisionCreated(false).setCopyApprovals(false).setValidate(false).setCheckAddPatchSetPermission(false).setDetailedCommitMessage(rebaseAlways).setPostMessage(false).setMatchAuthorToCommitterDate(args.project.isMatchAuthorToCommitterDate());
        try {
            rebaseOp.updateRepo(ctx);
        } catch (MergeConflictException | NoSuchChangeException e) {
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IntegrationException("Cannot rebase " + toMerge.name() + ": " + e.getMessage(), e);
        }
        newCommit = args.rw.parseCommit(rebaseOp.getRebasedCommit());
        newPatchSetId = rebaseOp.getPatchSetId();
    }
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(newPatchSetId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_REBASE);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commitStatus.put(args.mergeTip.getCurrentTip());
    acceptMergeTip(args.mergeTip);
}
#end_block

#method_before
@Override
public PatchSet updateChangeImpl(ChangeContext ctx) throws NoSuchChangeException, ResourceConflictException, OrmException, IOException {
    if (newCommit == null) {
        checkState(!rebaseAlways, "RebaseAlways must never fast forward");
        // otherwise, took the fast-forward option, nothing to do.
        return null;
    }
    PatchSet newPs;
    if (rebaseOp != null) {
        rebaseOp.updateChange(ctx);
        newPs = rebaseOp.getPatchSet();
    } else {
        // CherryPick
        PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
        newPs = args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(newPatchSetId), newPatchSetId, newCommit, false, prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of(), null, null);
    }
    ctx.getChange().setCurrentPatchSet(args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, newPatchSetId));
    newCommit.setControl(ctx.getControl());
    return newPs;
}
#method_after
@Override
public PatchSet updateChangeImpl(ChangeContext ctx) throws NoSuchChangeException, ResourceConflictException, OrmException, IOException {
    if (newCommit == null) {
        checkState(!rebaseAlways, "RebaseAlways must never fast forward");
        // otherwise, took the fast-forward option, nothing to do.
        return null;
    }
    PatchSet newPs;
    if (rebaseOp != null) {
        rebaseOp.updateChange(ctx);
        newPs = rebaseOp.getPatchSet();
    } else {
        // CherryPick
        PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
        newPs = args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(newPatchSetId), newPatchSetId, newCommit, prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of(), null, null);
    }
    ctx.getChange().setCurrentPatchSet(args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, newPatchSetId));
    newCommit.setNotes(ctx.getNotes());
    return newPs;
}
#end_block

#method_before
@Override
public PatchList get(PatchListKey key, Project.NameKey project) throws PatchListNotAvailableException {
    try {
        PatchList pl = fileCache.get(key, fileLoaderFactory.create(key, project));
        if (pl instanceof LargeObjectTombstone) {
            throw new PatchListNotAvailableException("Error computing " + key + ". Previous attempt failed with LargeObjectException");
        }
        if (key.getAlgorithm() == PatchListKey.Algorithm.OPTIMIZED_DIFF) {
            diffSummaryCache.put(DiffSummaryKey.fromPatchListKey(key), toDiffSummary(pl));
        }
        return pl;
    } catch (ExecutionException e) {
        PatchListLoader.log.warn("Error computing " + key, e);
        throw new PatchListNotAvailableException(e);
    } catch (UncheckedExecutionException e) {
        if (e.getCause() instanceof LargeObjectException) {
            // Cache negative result so we don't need to redo expensive computations that would yield
            // the same result.
            fileCache.put(key, new LargeObjectTombstone());
            PatchListLoader.log.warn("Error computing " + key, e);
            throw new PatchListNotAvailableException(e);
        }
        throw e;
    }
}
#method_after
@Override
public PatchList get(PatchListKey key, Project.NameKey project) throws PatchListNotAvailableException {
    try {
        PatchList pl = fileCache.get(key, fileLoaderFactory.create(key, project));
        if (pl instanceof LargeObjectTombstone) {
            throw new PatchListObjectTooLargeException("Error computing " + key + ". Previous attempt failed with LargeObjectException");
        }
        if (key.getAlgorithm() == PatchListKey.Algorithm.OPTIMIZED_DIFF) {
            diffSummaryCache.put(DiffSummaryKey.fromPatchListKey(key), toDiffSummary(pl));
        }
        return pl;
    } catch (ExecutionException e) {
        PatchListLoader.log.warn("Error computing " + key, e);
        throw new PatchListNotAvailableException(e);
    } catch (UncheckedExecutionException e) {
        if (e.getCause() instanceof LargeObjectException) {
            // Cache negative result so we don't need to redo expensive computations that would yield
            // the same result.
            fileCache.put(key, new LargeObjectTombstone());
            PatchListLoader.log.warn("Error computing " + key, e);
            throw new PatchListNotAvailableException(e);
        }
        throw e;
    }
}
#end_block

#method_before
@Override
void apply(ChangeUpdate update) throws IOException, OrmException {
    checkUpdate(update);
    if (createChange) {
        ChangeRebuilderImpl.createChange(update, change);
    } else {
        update.setSubject(change.getSubject());
        update.setSubjectForCommit("Create patch set " + ps.getPatchSetId());
    }
    setRevision(update, ps);
    update.setPsDescription(ps.getDescription());
    List<String> groups = ps.getGroups();
    if (!groups.isEmpty()) {
        update.setGroups(ps.getGroups());
    }
    if (ps.isDraft()) {
        update.setPatchSetState(PatchSetState.DRAFT);
    }
}
#method_after
@Override
void apply(ChangeUpdate update) throws IOException, OrmException {
    checkUpdate(update);
    if (createChange) {
        ChangeRebuilderImpl.createChange(update, change);
    } else {
        update.setSubject(change.getSubject());
        update.setSubjectForCommit("Create patch set " + ps.getPatchSetId());
    }
    setRevision(update, ps);
    update.setPsDescription(ps.getDescription());
    List<String> groups = ps.getGroups();
    if (!groups.isEmpty()) {
        update.setGroups(ps.getGroups());
    }
}
#end_block

#method_before
static Predicate<ChangeData> forState(Arguments args, Address adr, ReviewerStateInternal state) {
    checkArgument(state != ReviewerStateInternal.REMOVED, "can't query by removed reviewer");
    return create(args, new ReviewerByEmailPredicate(state, adr));
}
#method_after
static Predicate<ChangeData> forState(Address adr, ReviewerStateInternal state) {
    checkArgument(state != ReviewerStateInternal.REMOVED, "can't query by removed reviewer");
    return new ReviewerByEmailPredicate(state, adr);
}
#end_block

#method_before
@Override
public boolean match(ChangeData cd) throws OrmException {
    if (cd.fastIsVisibleTo(user)) {
        return true;
    }
    Change change = cd.change();
    if (change == null) {
        return false;
    }
    ChangeControl changeControl;
    ChangeNotes notes = notesFactory.createFromIndexedChange(change);
    try {
        changeControl = changeControlFactory.controlFor(notes, user);
    } catch (NoSuchChangeException e) {
        // Ignored
        return false;
    }
    boolean visible;
    try {
        visible = permissionBackend.user(user).indexedChange(cd, notes).database(db).test(ChangePermission.READ);
    } catch (PermissionBackendException e) {
        throw new OrmException("unable to check permissions", e);
    }
    if (visible) {
        cd.cacheVisibleTo(changeControl);
        return true;
    }
    return false;
}
#method_after
@Override
public boolean match(ChangeData cd) throws OrmException {
    if (cd.fastIsVisibleTo(user)) {
        return true;
    }
    Change change = cd.change();
    if (change == null) {
        return false;
    }
    ChangeNotes notes = notesFactory.createFromIndexedChange(change);
    boolean visible;
    try {
        visible = permissionBackend.user(user).indexedChange(cd, notes).database(db).test(ChangePermission.READ);
    } catch (PermissionBackendException e) {
        if (e.getCause() instanceof NoSuchProjectException) {
            logger.info("No such project: {}", cd.project());
            return false;
        }
        throw new OrmException("unable to check permissions", e);
    }
    if (visible) {
        cd.cacheVisibleTo(user);
        return true;
    }
    return false;
}
#end_block

#method_before
public Change getChange() {
    return getControl().getChange();
}
#method_after
public Change getChange() {
    return rev.getChange();
}
#end_block

#method_before
@Test
public void duplicateCompoundNonIndexOnlyPredicates() throws Exception {
    Predicate<ChangeData> in = parse("(status:new OR status:draft) bar:p file:a");
    Predicate<ChangeData> out = rewrite(in);
    assertThat(out.getClass()).isEqualTo(AndChangeSource.class);
    assertThat(out.getChildren()).containsExactly(query(and(in.getChild(0), in.getChild(2))), in.getChild(1)).inOrder();
}
#method_after
@Test
public void duplicateCompoundNonIndexOnlyPredicates() throws Exception {
    Predicate<ChangeData> in = parse("status:new bar:p file:a");
    Predicate<ChangeData> out = rewrite(in);
    assertThat(out.getClass()).isEqualTo(AndChangeSource.class);
    assertThat(out.getChildren()).containsExactly(query(and(in.getChild(0), in.getChild(2))), in.getChild(1)).inOrder();
}
#end_block

#method_before
@Test
public void getPossibleStatus() throws Exception {
    assertThat(status("file:a")).isEqualTo(EnumSet.allOf(Change.Status.class));
    assertThat(status("is:new")).containsExactly(NEW);
    assertThat(status("-is:new")).containsExactly(DRAFT, MERGED, ABANDONED);
    assertThat(status("is:new OR is:merged")).containsExactly(NEW, MERGED);
    assertThat(status("is:new is:merged")).isEmpty();
    assertThat(status("(is:new is:draft) (is:merged)")).isEmpty();
    assertThat(status("(is:new is:draft) (is:merged)")).isEmpty();
    assertThat(status("(is:new is:draft) OR (is:merged)")).containsExactly(MERGED);
}
#method_after
@Test
public void getPossibleStatus() throws Exception {
    Set<Change.Status> all = EnumSet.allOf(Change.Status.class);
    assertThat(status("file:a")).isEqualTo(all);
    assertThat(status("is:new")).containsExactly(NEW);
    assertThat(status("is:new OR is:merged")).containsExactly(NEW, MERGED);
    assertThat(status("is:new OR is:x")).isEqualTo(all);
    assertThat(status("is:new is:merged")).isEmpty();
    assertThat(status("(is:new) (is:merged)")).isEmpty();
    assertThat(status("(is:new) (is:merged)")).isEmpty();
    assertThat(status("is:new is:x")).containsExactly(NEW);
}
#end_block

#method_before
@Override
public ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, RevertInput input) throws IOException, OrmException, RestApiException, UpdateException, NoSuchChangeException, PermissionBackendException {
    Change change = rsrc.getChange();
    if (change.getStatus() != Change.Status.MERGED) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    CreateChange.checkValidCLA(rsrc.getControl().getProjectControl());
    permissionBackend.user(rsrc.getUser()).ref(change.getDest()).check(CREATE_CHANGE);
    Change.Id revertId = revert(updateFactory, rsrc.getNotes(), rsrc.getUser(), Strings.emptyToNull(input.message));
    return json.noOptions().format(rsrc.getProject(), revertId);
}
#method_after
@Override
public ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, RevertInput input) throws IOException, OrmException, RestApiException, UpdateException, NoSuchChangeException, PermissionBackendException, NoSuchProjectException {
    Change change = rsrc.getChange();
    if (change.getStatus() != Change.Status.MERGED) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    contributorAgreements.check(rsrc.getProject(), rsrc.getUser());
    permissionBackend.user(rsrc.getUser()).ref(change.getDest()).check(CREATE_CHANGE);
    Change.Id revertId = revert(updateFactory, rsrc.getNotes(), rsrc.getUser(), Strings.emptyToNull(input.message));
    return json.noOptions().format(rsrc.getProject(), revertId);
}
#end_block

#method_before
@Override
public PatchScript call() throws OrmException, LargeObjectException, AuthException, InvalidChangeOperationException, IOException {
    if (parentNum < 0) {
        validatePatchSetId(psa);
    }
    validatePatchSetId(psb);
    change = control.getChange();
    project = change.getProject();
    PatchSet psEntityA = psa != null ? psUtil.get(db, control.getNotes(), psa) : null;
    PatchSet psEntityB = psb.get() == 0 ? new PatchSet(psb) : psUtil.get(db, control.getNotes(), psb);
    if ((psEntityA != null && !control.isPatchVisible(psEntityA, db)) || (psEntityB != null && !control.isPatchVisible(psEntityB, db))) {
        throw new NoSuchChangeException(changeId);
    }
    try (Repository git = repoManager.openRepository(project)) {
        bId = toObjectId(psEntityB);
        if (parentNum < 0) {
            aId = psEntityA != null ? toObjectId(psEntityA) : null;
        }
        try {
            final PatchList list = listFor(keyFor(diffPrefs.ignoreWhitespace));
            final PatchScriptBuilder b = newBuilder(list, git);
            final PatchListEntry content = list.get(fileName);
            loadCommentsAndHistory(control.getNotes(), content.getChangeType(), content.getOldName(), content.getNewName());
            return b.toPatchScript(content, comments, history);
        } catch (PatchListNotAvailableException e) {
            throw new NoSuchChangeException(changeId, e);
        } catch (IOException e) {
            log.error("File content unavailable", e);
            throw new NoSuchChangeException(changeId, e);
        } catch (org.eclipse.jgit.errors.LargeObjectException err) {
            throw new LargeObjectException("File content is too large", err);
        }
    } catch (RepositoryNotFoundException e) {
        log.error("Repository " + project + " not found", e);
        throw new NoSuchChangeException(changeId, e);
    } catch (IOException e) {
        log.error("Cannot open repository " + project, e);
        throw new NoSuchChangeException(changeId, e);
    }
}
#method_after
@Override
public PatchScript call() throws OrmException, LargeObjectException, AuthException, InvalidChangeOperationException, IOException, PermissionBackendException {
    if (parentNum < 0) {
        validatePatchSetId(psa);
    }
    validatePatchSetId(psb);
    PatchSet psEntityA = psa != null ? psUtil.get(db, notes, psa) : null;
    PatchSet psEntityB = psb.get() == 0 ? new PatchSet(psb) : psUtil.get(db, notes, psb);
    if (psEntityA != null || psEntityB != null) {
        try {
            permissionBackend.user(userProvider).change(notes).database(db).check(ChangePermission.READ);
        } catch (AuthException e) {
            throw new NoSuchChangeException(changeId);
        }
    }
    try (Repository git = repoManager.openRepository(notes.getProjectName())) {
        bId = toObjectId(psEntityB);
        if (parentNum < 0) {
            aId = psEntityA != null ? toObjectId(psEntityA) : null;
        }
        try {
            final PatchList list = listFor(keyFor(diffPrefs.ignoreWhitespace));
            final PatchScriptBuilder b = newBuilder(list, git);
            final PatchListEntry content = list.get(fileName);
            loadCommentsAndHistory(content.getChangeType(), content.getOldName(), content.getNewName());
            return b.toPatchScript(content, comments, history);
        } catch (PatchListNotAvailableException e) {
            throw new NoSuchChangeException(changeId, e);
        } catch (IOException e) {
            log.error("File content unavailable", e);
            throw new NoSuchChangeException(changeId, e);
        } catch (org.eclipse.jgit.errors.LargeObjectException err) {
            throw new LargeObjectException("File content is too large", err);
        }
    } catch (RepositoryNotFoundException e) {
        log.error("Repository " + notes.getProjectName() + " not found", e);
        throw new NoSuchChangeException(changeId, e);
    } catch (IOException e) {
        log.error("Cannot open repository " + notes.getProjectName(), e);
        throw new NoSuchChangeException(changeId, e);
    }
}
#end_block

#method_before
private PatchList listFor(PatchListKey key) throws PatchListNotAvailableException {
    return patchListCache.get(key, project);
}
#method_after
private PatchList listFor(PatchListKey key) throws PatchListNotAvailableException {
    return patchListCache.get(key, notes.getProjectName());
}
#end_block

#method_before
private PatchScriptBuilder newBuilder(PatchList list, Repository git) {
    final PatchScriptBuilder b = builderFactory.get();
    b.setRepository(git, project);
    b.setChange(change);
    b.setDiffPrefs(diffPrefs);
    b.setTrees(list.getComparisonType(), list.getOldId(), list.getNewId());
    return b;
}
#method_after
private PatchScriptBuilder newBuilder(PatchList list, Repository git) {
    final PatchScriptBuilder b = builderFactory.get();
    b.setRepository(git, notes.getProjectName());
    b.setChange(notes.getChange());
    b.setDiffPrefs(diffPrefs);
    b.setTrees(list.getComparisonType(), list.getOldId(), list.getNewId());
    return b;
}
#end_block

#method_before
private ObjectId getEditRev() throws AuthException, IOException, OrmException {
    edit = editReader.byChange(control.getNotes());
    if (edit.isPresent()) {
        return edit.get().getEditCommit();
    }
    throw new NoSuchChangeException(change.getId());
}
#method_after
private ObjectId getEditRev() throws AuthException, IOException, OrmException {
    edit = editReader.byChange(notes);
    if (edit.isPresent()) {
        return edit.get().getEditCommit();
    }
    throw new NoSuchChangeException(notes.getChangeId());
}
#end_block

#method_before
private void loadCommentsAndHistory(ChangeNotes notes, ChangeType changeType, String oldName, String newName) throws OrmException {
    Map<Patch.Key, Patch> byKey = new HashMap<>();
    if (loadHistory) {
        // This seems like a cheap trick. It doesn't properly account for a
        // file that gets renamed between patch set 1 and patch set 2. We
        // will wind up packing the wrong Patch object because we didn't do
        // proper rename detection between the patch sets.
        // 
        history = new ArrayList<>();
        for (PatchSet ps : psUtil.byChange(db, notes)) {
            if (!control.isPatchVisible(ps, db)) {
                continue;
            }
            String name = fileName;
            if (psa != null) {
                switch(changeType) {
                    case COPIED:
                    case RENAMED:
                        if (ps.getId().equals(psa)) {
                            name = oldName;
                        }
                        break;
                    case MODIFIED:
                    case DELETED:
                    case ADDED:
                    case REWRITE:
                        break;
                }
            }
            Patch p = new Patch(new Patch.Key(ps.getId(), name));
            history.add(p);
            byKey.put(p.getKey(), p);
        }
        if (edit != null && edit.isPresent()) {
            Patch p = new Patch(new Patch.Key(new PatchSet.Id(psb.getParentKey(), 0), fileName));
            history.add(p);
            byKey.put(p.getKey(), p);
        }
    }
    if (loadComments && edit == null) {
        comments = new CommentDetail(psa, psb);
        switch(changeType) {
            case ADDED:
            case MODIFIED:
                loadPublished(byKey, newName);
                break;
            case DELETED:
                loadPublished(byKey, newName);
                break;
            case COPIED:
            case RENAMED:
                if (psa != null) {
                    loadPublished(byKey, oldName);
                }
                loadPublished(byKey, newName);
                break;
            case REWRITE:
                break;
        }
        CurrentUser user = control.getUser();
        if (user.isIdentifiedUser()) {
            Account.Id me = user.getAccountId();
            switch(changeType) {
                case ADDED:
                case MODIFIED:
                    loadDrafts(byKey, me, newName);
                    break;
                case DELETED:
                    loadDrafts(byKey, me, newName);
                    break;
                case COPIED:
                case RENAMED:
                    if (psa != null) {
                        loadDrafts(byKey, me, oldName);
                    }
                    loadDrafts(byKey, me, newName);
                    break;
                case REWRITE:
                    break;
            }
        }
    }
}
#method_after
private void loadCommentsAndHistory(ChangeType changeType, String oldName, String newName) throws OrmException {
    Map<Patch.Key, Patch> byKey = new HashMap<>();
    if (loadHistory) {
        // This seems like a cheap trick. It doesn't properly account for a
        // file that gets renamed between patch set 1 and patch set 2. We
        // will wind up packing the wrong Patch object because we didn't do
        // proper rename detection between the patch sets.
        // 
        history = new ArrayList<>();
        for (PatchSet ps : psUtil.byChange(db, notes)) {
            String name = fileName;
            if (psa != null) {
                switch(changeType) {
                    case COPIED:
                    case RENAMED:
                        if (ps.getId().equals(psa)) {
                            name = oldName;
                        }
                        break;
                    case MODIFIED:
                    case DELETED:
                    case ADDED:
                    case REWRITE:
                        break;
                }
            }
            Patch p = new Patch(new Patch.Key(ps.getId(), name));
            history.add(p);
            byKey.put(p.getKey(), p);
        }
        if (edit != null && edit.isPresent()) {
            Patch p = new Patch(new Patch.Key(new PatchSet.Id(psb.getParentKey(), 0), fileName));
            history.add(p);
            byKey.put(p.getKey(), p);
        }
    }
    if (loadComments && edit == null) {
        comments = new CommentDetail(psa, psb);
        switch(changeType) {
            case ADDED:
            case MODIFIED:
                loadPublished(byKey, newName);
                break;
            case DELETED:
                loadPublished(byKey, newName);
                break;
            case COPIED:
            case RENAMED:
                if (psa != null) {
                    loadPublished(byKey, oldName);
                }
                loadPublished(byKey, newName);
                break;
            case REWRITE:
                break;
        }
        CurrentUser user = userProvider.get();
        if (user.isIdentifiedUser()) {
            Account.Id me = user.getAccountId();
            switch(changeType) {
                case ADDED:
                case MODIFIED:
                    loadDrafts(byKey, me, newName);
                    break;
                case DELETED:
                    loadDrafts(byKey, me, newName);
                    break;
                case COPIED:
                case RENAMED:
                    if (psa != null) {
                        loadDrafts(byKey, me, oldName);
                    }
                    loadDrafts(byKey, me, newName);
                    break;
                case REWRITE:
                    break;
            }
        }
    }
}
#end_block

#method_before
private void loadPublished(Map<Patch.Key, Patch> byKey, String file) throws OrmException {
    ChangeNotes notes = control.getNotes();
    for (Comment c : commentsUtil.publishedByChangeFile(db, notes, changeId, file)) {
        comments.include(change.getId(), c);
        PatchSet.Id psId = new PatchSet.Id(change.getId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
}
#method_after
private void loadPublished(Map<Patch.Key, Patch> byKey, String file) throws OrmException {
    for (Comment c : commentsUtil.publishedByChangeFile(db, notes, changeId, file)) {
        comments.include(notes.getChangeId(), c);
        PatchSet.Id psId = new PatchSet.Id(notes.getChangeId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
}
#end_block

#method_before
private void loadDrafts(Map<Patch.Key, Patch> byKey, Account.Id me, String file) throws OrmException {
    for (Comment c : commentsUtil.draftByChangeFileAuthor(db, control.getNotes(), file, me)) {
        comments.include(change.getId(), c);
        PatchSet.Id psId = new PatchSet.Id(change.getId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setDraftCount(p.getDraftCount() + 1);
        }
    }
}
#method_after
private void loadDrafts(Map<Patch.Key, Patch> byKey, Account.Id me, String file) throws OrmException {
    for (Comment c : commentsUtil.draftByChangeFileAuthor(db, notes, file, me)) {
        comments.include(notes.getChangeId(), c);
        PatchSet.Id psId = new PatchSet.Id(notes.getChangeId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setDraftCount(p.getDraftCount() + 1);
        }
    }
}
#end_block

#method_before
protected void setUpDatabase() throws Exception {
    db = schemaFactory.open();
    schemaCreator.create(db);
    Account.Id userId = createAccount("user", "User", "user@example.com", true);
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userId));
    currentUserInfo = gApi.accounts().id(userId.get()).get();
}
#method_after
protected void setUpDatabase() throws Exception {
    db = schemaFactory.open();
    schemaCreator.create(db);
    Account.Id userId = createAccountOutsideRequestContext("user", "User", "user@example.com", true);
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userId));
    currentUserInfo = gApi.accounts().id(userId.get()).get();
}
#end_block

#method_before
@After
public void tearDownInjector() {
    if (lifecycle != null) {
        lifecycle.stop();
    }
    requestContext.setContext(null);
    if (db != null) {
        db.close();
    }
    InMemoryDatabase.drop(schemaFactory);
}
#method_after
@After
public void tearDownInjector() {
    if (lifecycle != null) {
        lifecycle.stop();
    }
    if (requestContext != null) {
        requestContext.setContext(null);
    }
    if (db != null) {
        db.close();
    }
    InMemoryDatabase.drop(schemaFactory);
}
#end_block

#method_before
private Account.Id createAccount(String username, String fullName, String email, boolean active) throws Exception {
    try (ManualRequestContext ctx = oneOffRequestContext.open()) {
        Account.Id id = accountManager.authenticate(AuthRequest.forUser(username)).getAccountId();
        if (email != null) {
            accountManager.link(id, AuthRequest.forEmail(email));
        }
        accountsUpdate.create().update(id, a -> {
            a.setFullName(fullName);
            a.setPreferredEmail(email);
            a.setActive(active);
        });
        return id;
    }
}
#method_after
protected AccountInfo createAccount(String username, String fullName, String email) throws Exception {
    String uniqueName = name(username);
    AccountInput accountInput = new AccountInput();
    accountInput.username = uniqueName;
    accountInput.name = fullName;
    accountInput.email = email;
    return gApi.accounts().create(accountInput).get();
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(ChangeResource rsrc, FixInput input) throws RestApiException, OrmException, PermissionBackendException {
    if (!rsrc.isUserOwner() && !rsrc.getControl().getProjectControl().isOwner()) {
        permissionBackend.user(user).check(GlobalPermission.MAINTAIN_SERVER);
    }
    return Response.withMustRevalidate(newChangeJson().fix(input).format(rsrc));
}
#method_after
@Override
public Response<ChangeInfo> apply(ChangeResource rsrc, FixInput input) throws RestApiException, OrmException, PermissionBackendException, NoSuchProjectException, IOException {
    PermissionBackend.WithUser perm = permissionBackend.user(user);
    if (!rsrc.isUserOwner()) {
        try {
            perm.project(rsrc.getProject()).check(ProjectPermission.READ_CONFIG);
        } catch (AuthException e) {
            perm.check(GlobalPermission.MAINTAIN_SERVER);
        }
    }
    return Response.withMustRevalidate(newChangeJson().fix(input).format(rsrc));
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    if (revision != null) {
        rw.markStart(revision);
        rw.sort(RevSort.REVERSE);
        registeredOn = new Timestamp(rw.next().getCommitTime() * 1000L);
        Config cfg = readConfig(ACCOUNT_CONFIG);
        account = parse(cfg);
        account.setMetaId(revision.name());
    }
    isLoaded = true;
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    if (revision != null) {
        rw.reset();
        rw.markStart(revision);
        rw.sort(RevSort.REVERSE);
        registeredOn = new Timestamp(rw.next().getCommitTime() * 1000L);
        Config cfg = readConfig(ACCOUNT_CONFIG);
        account = parse(cfg);
        account.setMetaId(revision.name());
    }
    isLoaded = true;
}
#end_block

#method_before
@Override
public boolean match(ChangeData object) throws OrmException {
    Change c = object.change();
    if (c == null) {
        // 
        return false;
    }
    ProjectState project = projectCache.get(c.getDest().getParentKey());
    if (project == null) {
        // 
        return false;
    }
    LabelType labelType = type(project.getLabelTypes(), label);
    if (labelType == null) {
        // Label is not defined by this project.
        return false;
    }
    boolean hasVote = false;
    for (PatchSetApproval p : object.currentApprovals()) {
        if (labelType.matches(p)) {
            hasVote = true;
            if (match(object, p.getValue(), p.getAccountId(), labelType)) {
                return true;
            }
        }
    }
    if (!hasVote && expVal == 0) {
        return true;
    }
    return false;
}
#method_after
@Override
public boolean match(ChangeData object) throws OrmException {
    Change c = object.change();
    if (c == null) {
        // 
        return false;
    }
    ProjectState project = projectCache.get(c.getDest().getParentKey());
    if (project == null) {
        // 
        return false;
    }
    LabelType labelType = type(project.getLabelTypes(), label);
    if (labelType == null) {
        // Label is not defined by this project.
        return false;
    }
    boolean hasVote = false;
    for (PatchSetApproval p : object.currentApprovals()) {
        if (labelType.matches(p)) {
            hasVote = true;
            if (match(object, p.getValue(), p.getAccountId())) {
                return true;
            }
        }
    }
    if (!hasVote && expVal == 0) {
        return true;
    }
    return false;
}
#end_block

#method_before
protected boolean match(ChangeData cd, short value, Account.Id approver, LabelType type) {
    if (value != expVal) {
        return false;
    }
    if (account != null && !account.equals(approver)) {
        return false;
    }
    IdentifiedUser reviewer = userFactory.create(approver);
    if (group != null && !reviewer.getEffectiveGroups().contains(group)) {
        return false;
    }
    // Double check the value is still permitted for the user.
    try {
        PermissionBackend.ForChange perm = permissionBackend.user(reviewer).database(dbProvider).change(cd);
        return perm.test(ChangePermission.READ) && expVal == perm.squashByTest(type, value);
    } catch (PermissionBackendException e) {
        return false;
    }
}
#method_after
protected boolean match(ChangeData cd, short value, Account.Id approver) {
    if (value != expVal) {
        return false;
    }
    if (account != null && !account.equals(approver)) {
        return false;
    }
    IdentifiedUser reviewer = userFactory.create(approver);
    if (group != null && !reviewer.getEffectiveGroups().contains(group)) {
        return false;
    }
    // Check the user has 'READ' permission.
    try {
        PermissionBackend.ForChange perm = permissionBackend.user(reviewer).database(dbProvider).change(cd);
        return perm.test(ChangePermission.READ);
    } catch (PermissionBackendException e) {
        return false;
    }
}
#end_block

#method_before
private void assertCanUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("can upload").isEqualTo(Capable.OK);
}
#method_after
private void assertCanUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("can upload").isTrue();
}
#end_block

#method_before
private void assertCannotUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("cannot upload").isNotEqualTo(Capable.OK);
}
#method_after
private void assertCannotUpload(ProjectControl u) {
    assertThat(u.canPushToAtLeastOneRef()).named("cannot upload").isFalse();
}
#end_block

#method_before
@Test
public void branchDelegation1() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwnerAnyRef(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
}
#method_after
@Test
public void branchDelegation1() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
}
#end_block

#method_before
@Test
public void branchDelegation2() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    allow(local, OWNER, fixers, "refs/heads/x/y/*");
    doNotInherit(local, OWNER, "refs/heads/x/y/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwnerAnyRef(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
    ProjectControl uFix = user(local, fixers);
    assertNotOwner(uFix);
    assertOwnerAnyRef(uFix);
    assertOwner("refs/heads/x/y/*", uFix);
    assertOwner("refs/heads/x/y/bar", uFix);
    assertNotOwner("refs/heads/x/*", uFix);
    assertNotOwner("refs/heads/x/y", uFix);
    assertNotOwner("refs/*", uFix);
    assertNotOwner("refs/heads/master", uFix);
}
#method_after
@Test
public void branchDelegation2() {
    allow(local, OWNER, ADMIN, "refs/*");
    allow(local, OWNER, DEVS, "refs/heads/x/*");
    allow(local, OWNER, fixers, "refs/heads/x/y/*");
    doNotInherit(local, OWNER, "refs/heads/x/y/*");
    ProjectControl uDev = user(local, DEVS);
    assertNotOwner(uDev);
    assertOwner("refs/heads/x/*", uDev);
    assertOwner("refs/heads/x/y", uDev);
    assertOwner("refs/heads/x/y/*", uDev);
    assertNotOwner("refs/*", uDev);
    assertNotOwner("refs/heads/master", uDev);
    ProjectControl uFix = user(local, fixers);
    assertNotOwner(uFix);
    assertOwner("refs/heads/x/y/*", uFix);
    assertOwner("refs/heads/x/y/bar", uFix);
    assertNotOwner("refs/heads/x/*", uFix);
    assertNotOwner("refs/heads/x/y", uFix);
    assertNotOwner("refs/*", uFix);
    assertNotOwner("refs/heads/master", uFix);
}
#end_block

#method_before
private ProjectControl user(ProjectConfig local, String name, AccountGroup.UUID... memberOf) {
    return new ProjectControl(Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountGroup.UUID>emptySet(), projectCache, sectionSorter, // commitsCollection
    null, changeControlFactory, // canonicalWebUrl
    "http://localhost", permissionBackend, new MockUser(name, memberOf), newProjectState(local), metrics);
}
#method_after
private ProjectControl user(ProjectConfig local, String name, AccountGroup.UUID... memberOf) {
    return new ProjectControl(Collections.<AccountGroup.UUID>emptySet(), Collections.<AccountGroup.UUID>emptySet(), sectionSorter, // commitsCollection
    null, changeControlFactory, permissionBackend, new MockUser(name, memberOf), newProjectState(local));
}
#end_block

#method_before
private void checkResult(RefUpdate.Result result) throws OrmException {
    if (result != RefUpdate.Result.NEW && result != RefUpdate.Result.FORCED) {
        throw new OrmException("failed to update " + refName + ": " + result);
    }
}
#method_after
private void checkResult(RefUpdate.Result result) throws OrmException {
    if (!refUpdated(result)) {
        throw new OrmException("failed to update " + refName + ": " + result);
    }
}
#end_block

#method_before
private RefUpdate.Result store(Repository repo, RevWalk rw, @Nullable ObjectId oldId, int val) throws IOException {
    ObjectId newId;
    try (ObjectInserter ins = repo.newObjectInserter()) {
        newId = ins.insert(OBJ_BLOB, Integer.toString(val).getBytes(UTF_8));
        ins.flush();
    }
    RefUpdate ru = repo.updateRef(refName);
    if (oldId != null) {
        ru.setExpectedOldObjectId(oldId);
    }
    ru.setNewObjectId(newId);
    // Required for non-commitish updates.
    ru.setForceUpdate(true);
    return ru.update(rw);
}
#method_after
private RefUpdate.Result store(Repository repo, RevWalk rw, @Nullable ObjectId oldId, int val) throws IOException {
    ObjectId newId;
    try (ObjectInserter ins = repo.newObjectInserter()) {
        newId = ins.insert(OBJ_BLOB, Integer.toString(val).getBytes(UTF_8));
        ins.flush();
    }
    RefUpdate ru = repo.updateRef(refName);
    if (oldId != null) {
        ru.setExpectedOldObjectId(oldId);
    }
    ru.setNewObjectId(newId);
    // Required for non-commitish updates.
    ru.setForceUpdate(true);
    RefUpdate.Result result = ru.update(rw);
    if (refUpdated(result)) {
        gitRefUpdated.fire(projectName, ru, null);
    }
    return result;
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    try {
        deleteTag.apply(resource(), new DeleteTag.Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot delete tag", e);
    }
}
#method_after
@Override
public void delete() throws RestApiException {
    try {
        deleteTag.apply(resource(), new Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot delete tag", e);
    }
}
#end_block

#method_before
public ProjectAccessInfo apply(Project.NameKey nameKey) throws ResourceNotFoundException, ResourceConflictException, IOException, PermissionBackendException, OrmException {
    try {
        return apply(new ProjectResource(projectControlFactory.controlFor(nameKey, user.get())));
    } catch (NoSuchProjectException e) {
        throw new ResourceNotFoundException(nameKey.get());
    }
}
#method_after
public ProjectAccessInfo apply(Project.NameKey nameKey) throws ResourceNotFoundException, ResourceConflictException, IOException, PermissionBackendException, OrmException {
    ProjectState state = projectCache.checkedGet(nameKey);
    if (state == null) {
        throw new ResourceNotFoundException(nameKey.get());
    }
    return apply(new ProjectResource(state, user.get()));
}
#end_block

#method_before
@Override
public ProjectAccessInfo apply(ProjectResource rsrc) throws ResourceNotFoundException, ResourceConflictException, IOException, PermissionBackendException, OrmException {
    // Load the current configuration from the repository, ensuring it's the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    Project.NameKey projectName = rsrc.getNameKey();
    ProjectAccessInfo info = new ProjectAccessInfo();
    ProjectControl pc = createProjectControl(projectName);
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(projectName);
    ProjectConfig config;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            pc = createProjectControl(projectName);
            perm = permissionBackend.user(user).project(projectName);
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = createProjectControl(projectName);
            perm = permissionBackend.user(user).project(projectName);
        }
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
    info.local = new HashMap<>();
    info.ownerOf = new HashSet<>();
    Map<AccountGroup.UUID, GroupInfo> visibleGroups = new HashMap<>();
    boolean checkReadConfig = check(perm, RefNames.REFS_CONFIG, READ);
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                info.local.put(name, createAccessSection(visibleGroups, section));
                info.ownerOf.add(name);
            } else if (checkReadConfig) {
                info.local.put(section.getName(), createAccessSection(visibleGroups, section));
            }
        } else if (RefConfigSection.isValid(name)) {
            if (pc.controlForRef(name).isOwner()) {
                info.local.put(name, createAccessSection(visibleGroups, section));
                info.ownerOf.add(name);
            } else if (checkReadConfig) {
                info.local.put(name, createAccessSection(visibleGroups, section));
            } else if (check(perm, name, READ)) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID groupId = srcRule.getGroup().getUUID();
                        if (groupId == null) {
                            continue;
                        }
                        GroupInfo group = loadGroup(visibleGroups, groupId);
                        if (group != INVISIBLE_SENTINEL) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    info.local.put(name, createAccessSection(visibleGroups, dst));
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(pc.getProjectState().parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (projectName.equals(allProjectsName) && permissionBackend.user(user).testOrFalse(ADMINISTRATE_SERVER)) {
        info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
    }
    info.isOwner = toBoolean(pc.isOwner());
    info.canUpload = toBoolean(pc.isOwner() || (checkReadConfig && perm.ref(RefNames.REFS_CONFIG).testOrFalse(CREATE_CHANGE)));
    info.canAdd = toBoolean(perm.testOrFalse(CREATE_REF));
    info.configVisible = checkReadConfig || pc.isOwner();
    info.groups = visibleGroups.entrySet().stream().filter(e -> e.getValue() != INVISIBLE_SENTINEL).collect(toMap(e -> e.getKey().get(), e -> e.getValue()));
    return info;
}
#method_after
@Override
public ProjectAccessInfo apply(ProjectResource rsrc) throws ResourceNotFoundException, ResourceConflictException, IOException, PermissionBackendException, OrmException {
    // Load the current configuration from the repository, ensuring it's the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    Project.NameKey projectName = rsrc.getNameKey();
    ProjectAccessInfo info = new ProjectAccessInfo();
    ProjectState projectState = projectCache.checkedGet(projectName);
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(projectName);
    ProjectConfig config;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            projectState = projectCache.checkedGet(projectName);
            perm = permissionBackend.user(user).project(projectName);
        } else if (config.getRevision() != null && !config.getRevision().equals(projectState.getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            projectState = projectCache.checkedGet(projectName);
            perm = permissionBackend.user(user).project(projectName);
        }
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
    // The following implementation must match the ProjectAccessFactory JSON RPC endpoint.
    info.local = new HashMap<>();
    info.ownerOf = new HashSet<>();
    Map<AccountGroup.UUID, GroupInfo> visibleGroups = new HashMap<>();
    boolean canReadConfig = check(perm, RefNames.REFS_CONFIG, READ);
    boolean canWriteConfig = check(perm, ProjectPermission.WRITE_CONFIG);
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (canWriteConfig) {
                info.local.put(name, createAccessSection(visibleGroups, section));
                info.ownerOf.add(name);
            } else if (canReadConfig) {
                info.local.put(section.getName(), createAccessSection(visibleGroups, section));
            }
        } else if (RefConfigSection.isValid(name)) {
            if (check(perm, name, WRITE_CONFIG)) {
                info.local.put(name, createAccessSection(visibleGroups, section));
                info.ownerOf.add(name);
            } else if (canReadConfig) {
                info.local.put(name, createAccessSection(visibleGroups, section));
            } else if (check(perm, name, READ)) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID groupId = srcRule.getGroup().getUUID();
                        if (groupId == null) {
                            continue;
                        }
                        GroupInfo group = loadGroup(visibleGroups, groupId);
                        if (group != INVISIBLE_SENTINEL) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    info.local.put(name, createAccessSection(visibleGroups, dst));
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && permissionBackend.user(user).test(GlobalPermission.ADMINISTRATE_SERVER)) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Fall back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(projectState.parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (projectName.equals(allProjectsName) && permissionBackend.user(user).testOrFalse(ADMINISTRATE_SERVER)) {
        info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
    }
    info.isOwner = toBoolean(canWriteConfig);
    info.canUpload = toBoolean(canWriteConfig || (canReadConfig && perm.ref(RefNames.REFS_CONFIG).testOrFalse(CREATE_CHANGE)));
    info.canAdd = toBoolean(perm.testOrFalse(CREATE_REF));
    info.configVisible = canReadConfig || canWriteConfig;
    info.groups = visibleGroups.entrySet().stream().filter(e -> e.getValue() != INVISIBLE_SENTINEL).collect(toMap(e -> e.getKey().get(), e -> e.getValue()));
    return info;
}
#end_block

#method_before
private static boolean check(PermissionBackend.ForProject ctx, String ref, RefPermission perm) throws PermissionBackendException {
    try {
        ctx.ref(ref).check(perm);
        return true;
    } catch (AuthException denied) {
        return false;
    }
}
#method_after
private static boolean check(PermissionBackend.ForProject ctx, ProjectPermission perm) throws PermissionBackendException {
    try {
        ctx.check(perm);
        return true;
    } catch (AuthException denied) {
        return false;
    }
}
#end_block

#method_before
private static Result create(ChangeControl ctl, List<ProblemInfo> problems) {
    return new AutoValue_ConsistencyChecker_Result(ctl.getId(), ctl.getChange(), problems);
}
#method_after
private static Result create(ChangeNotes notes, List<ProblemInfo> problems) {
    return new AutoValue_ConsistencyChecker_Result(notes.getChangeId(), notes.getChange(), problems);
}
#end_block

#method_before
private void reset() {
    updateFactory = null;
    ctl = null;
    repo = null;
    rw = null;
    problems = new ArrayList<>();
}
#method_after
private void reset() {
    updateFactory = null;
    notes = null;
    repo = null;
    rw = null;
    problems = new ArrayList<>();
}
#end_block

#method_before
private Change change() {
    return ctl.getChange();
}
#method_after
private Change change() {
    return notes.getChange();
}
#end_block

#method_before
public Result check(ChangeControl cc, @Nullable FixInput f) {
    checkNotNull(cc);
    try {
        return retryHelper.execute(buf -> {
            try {
                reset();
                this.updateFactory = buf;
                ctl = cc;
                fix = f;
                checkImpl();
                return result();
            } finally {
                if (rw != null) {
                    rw.getObjectReader().close();
                    rw.close();
                    oi.close();
                }
                if (repo != null) {
                    repo.close();
                }
            }
        });
    } catch (RestApiException e) {
        return logAndReturnOneProblem(e, cc, "Error checking change: " + e.getMessage());
    } catch (UpdateException e) {
        return logAndReturnOneProblem(e, cc, "Error checking change");
    }
}
#method_after
public Result check(ChangeNotes notes, @Nullable FixInput f) {
    checkNotNull(notes);
    try {
        return retryHelper.execute(buf -> {
            try {
                reset();
                this.updateFactory = buf;
                this.notes = notes;
                fix = f;
                checkImpl();
                return result();
            } finally {
                if (rw != null) {
                    rw.getObjectReader().close();
                    rw.close();
                    oi.close();
                }
                if (repo != null) {
                    repo.close();
                }
            }
        });
    } catch (RestApiException e) {
        return logAndReturnOneProblem(e, notes, "Error checking change: " + e.getMessage());
    } catch (UpdateException e) {
        return logAndReturnOneProblem(e, notes, "Error checking change");
    }
}
#end_block

#method_before
private Result logAndReturnOneProblem(Exception e, ChangeControl cc, String problem) {
    log.warn("Error checking change " + cc.getId(), e);
    return Result.create(cc, ImmutableList.of(problem(problem)));
}
#method_after
private Result logAndReturnOneProblem(Exception e, ChangeNotes notes, String problem) {
    log.warn("Error checking change " + notes.getChangeId(), e);
    return Result.create(notes, ImmutableList.of(problem(problem)));
}
#end_block

#method_before
private void checkCurrentPatchSetEntity() {
    try {
        currPs = psUtil.current(db.get(), ctl.getNotes());
        if (currPs == null) {
            problem(String.format("Current patch set %d not found", change().currentPatchSetId().get()));
        }
    } catch (OrmException e) {
        error("Failed to look up current patch set", e);
    }
}
#method_after
private void checkCurrentPatchSetEntity() {
    try {
        currPs = psUtil.current(db.get(), notes);
        if (currPs == null) {
            problem(String.format("Current patch set %d not found", change().currentPatchSetId().get()));
        }
    } catch (OrmException e) {
        error("Failed to look up current patch set", e);
    }
}
#end_block

#method_before
private boolean checkPatchSets() {
    List<PatchSet> all;
    try {
        // Iterate in descending order.
        all = PS_ID_ORDER.sortedCopy(psUtil.byChange(db.get(), ctl.getNotes()));
    } catch (OrmException e) {
        return error("Failed to look up patch sets", e);
    }
    patchSetsBySha = MultimapBuilder.hashKeys(all.size()).treeSetValues(PS_ID_ORDER).build();
    Map<String, Ref> refs;
    try {
        refs = repo.getRefDatabase().exactRef(all.stream().map(ps -> ps.getId().toRefName()).toArray(String[]::new));
    } catch (IOException e) {
        error("error reading refs", e);
        refs = Collections.emptyMap();
    }
    List<DeletePatchSetFromDbOp> deletePatchSetOps = new ArrayList<>();
    for (PatchSet ps : all) {
        // Check revision format.
        int psNum = ps.getId().get();
        String refName = ps.getId().toRefName();
        ObjectId objId = parseObjectId(ps.getRevision().get(), "patch set " + psNum);
        if (objId == null) {
            continue;
        }
        patchSetsBySha.put(objId, ps);
        // Check ref existence.
        ProblemInfo refProblem = null;
        Ref ref = refs.get(refName);
        if (ref == null) {
            refProblem = problem("Ref missing: " + refName);
        } else if (!objId.equals(ref.getObjectId())) {
            String actual = ref.getObjectId() != null ? ref.getObjectId().name() : "null";
            refProblem = problem(String.format("Expected %s to point to %s, found %s", ref.getName(), objId.name(), actual));
        }
        // Check object existence.
        RevCommit psCommit = parseCommit(objId, String.format("patch set %d", psNum));
        if (psCommit == null) {
            if (fix != null && fix.deletePatchSetIfCommitMissing) {
                deletePatchSetOps.add(new DeletePatchSetFromDbOp(lastProblem(), ps.getId()));
            }
            continue;
        } else if (refProblem != null && fix != null) {
            fixPatchSetRef(refProblem, ps);
        }
        if (ps.getId().equals(change().currentPatchSetId())) {
            currPsCommit = psCommit;
        }
    }
    // Delete any bad patch sets found above, in a single update.
    deletePatchSets(deletePatchSetOps);
    // Check for duplicates.
    for (Map.Entry<ObjectId, Collection<PatchSet>> e : patchSetsBySha.asMap().entrySet()) {
        if (e.getValue().size() > 1) {
            problem(String.format("Multiple patch sets pointing to %s: %s", e.getKey().name(), Collections2.transform(e.getValue(), PatchSet::getPatchSetId)));
        }
    }
    return currPs != null && currPsCommit != null;
}
#method_after
private boolean checkPatchSets() {
    List<PatchSet> all;
    try {
        // Iterate in descending order.
        all = PS_ID_ORDER.sortedCopy(psUtil.byChange(db.get(), notes));
    } catch (OrmException e) {
        return error("Failed to look up patch sets", e);
    }
    patchSetsBySha = MultimapBuilder.hashKeys(all.size()).treeSetValues(PS_ID_ORDER).build();
    Map<String, Ref> refs;
    try {
        refs = repo.getRefDatabase().exactRef(all.stream().map(ps -> ps.getId().toRefName()).toArray(String[]::new));
    } catch (IOException e) {
        error("error reading refs", e);
        refs = Collections.emptyMap();
    }
    List<DeletePatchSetFromDbOp> deletePatchSetOps = new ArrayList<>();
    for (PatchSet ps : all) {
        // Check revision format.
        int psNum = ps.getId().get();
        String refName = ps.getId().toRefName();
        ObjectId objId = parseObjectId(ps.getRevision().get(), "patch set " + psNum);
        if (objId == null) {
            continue;
        }
        patchSetsBySha.put(objId, ps);
        // Check ref existence.
        ProblemInfo refProblem = null;
        Ref ref = refs.get(refName);
        if (ref == null) {
            refProblem = problem("Ref missing: " + refName);
        } else if (!objId.equals(ref.getObjectId())) {
            String actual = ref.getObjectId() != null ? ref.getObjectId().name() : "null";
            refProblem = problem(String.format("Expected %s to point to %s, found %s", ref.getName(), objId.name(), actual));
        }
        // Check object existence.
        RevCommit psCommit = parseCommit(objId, String.format("patch set %d", psNum));
        if (psCommit == null) {
            if (fix != null && fix.deletePatchSetIfCommitMissing) {
                deletePatchSetOps.add(new DeletePatchSetFromDbOp(lastProblem(), ps.getId()));
            }
            continue;
        } else if (refProblem != null && fix != null) {
            fixPatchSetRef(refProblem, ps);
        }
        if (ps.getId().equals(change().currentPatchSetId())) {
            currPsCommit = psCommit;
        }
    }
    // Delete any bad patch sets found above, in a single update.
    deletePatchSets(deletePatchSetOps);
    // Check for duplicates.
    for (Map.Entry<ObjectId, Collection<PatchSet>> e : patchSetsBySha.asMap().entrySet()) {
        if (e.getValue().size() > 1) {
            problem(String.format("Multiple patch sets pointing to %s: %s", e.getKey().name(), Collections2.transform(e.getValue(), PatchSet::getPatchSetId)));
        }
    }
    return currPs != null && currPsCommit != null;
}
#end_block

#method_before
private void insertMergedPatchSet(final RevCommit commit, @Nullable PatchSet.Id psIdToDelete, boolean reuseOldPsId) {
    ProblemInfo notFound = problem("No patch set found for merged commit " + commit.name());
    if (!user.get().isIdentifiedUser()) {
        notFound.status = Status.FIX_FAILED;
        notFound.outcome = "Must be called by an identified user to insert new patch set";
        return;
    }
    ProblemInfo insertPatchSetProblem;
    ProblemInfo deleteOldPatchSetProblem;
    if (psIdToDelete == null) {
        insertPatchSetProblem = problem(String.format("Expected merged commit %s has no associated patch set", commit.name()));
        deleteOldPatchSetProblem = null;
    } else {
        String msg = String.format("Expected merge commit %s corresponds to patch set %s," + " not the current patch set %s", commit.name(), psIdToDelete.get(), change().currentPatchSetId().get());
        // Maybe an identical problem, but different fix.
        deleteOldPatchSetProblem = reuseOldPsId ? null : problem(msg);
        insertPatchSetProblem = problem(msg);
    }
    List<ProblemInfo> currProblems = new ArrayList<>(3);
    currProblems.add(notFound);
    if (deleteOldPatchSetProblem != null) {
        currProblems.add(insertPatchSetProblem);
    }
    currProblems.add(insertPatchSetProblem);
    try {
        PatchSet.Id psId = (psIdToDelete != null && reuseOldPsId) ? psIdToDelete : ChangeUtil.nextPatchSetId(repo, change().currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(ctl.getNotes(), psId, commit);
        try (BatchUpdate bu = newBatchUpdate()) {
            bu.setRepository(repo, rw, oi);
            if (psIdToDelete != null) {
                // Delete the given patch set ref. If reuseOldPsId is true,
                // PatchSetInserter will reinsert the same ref, making it a no-op.
                bu.addOp(ctl.getId(), new BatchUpdateOp() {

                    @Override
                    public void updateRepo(RepoContext ctx) throws IOException {
                        ctx.addRefUpdate(commit, ObjectId.zeroId(), psIdToDelete.toRefName());
                    }
                });
                if (!reuseOldPsId) {
                    bu.addOp(ctl.getId(), new DeletePatchSetFromDbOp(checkNotNull(deleteOldPatchSetProblem), psIdToDelete));
                }
            }
            bu.addOp(ctl.getId(), inserter.setValidate(false).setFireRevisionCreated(false).setNotify(NotifyHandling.NONE).setAllowClosed(true).setMessage("Patch set for merged commit inserted by consistency checker"));
            bu.addOp(ctl.getId(), new FixMergedOp(notFound));
            bu.execute();
        }
        ctl = changeControlFactory.controlFor(db.get(), inserter.getChange(), ctl.getUser());
        insertPatchSetProblem.status = Status.FIXED;
        insertPatchSetProblem.outcome = "Inserted as patch set " + psId.get();
    } catch (OrmException | IOException | UpdateException | RestApiException e) {
        warn(e);
        for (ProblemInfo pi : currProblems) {
            pi.status = Status.FIX_FAILED;
            pi.outcome = "Error inserting merged patch set";
        }
        return;
    }
}
#method_after
private void insertMergedPatchSet(final RevCommit commit, @Nullable PatchSet.Id psIdToDelete, boolean reuseOldPsId) {
    ProblemInfo notFound = problem("No patch set found for merged commit " + commit.name());
    if (!user.get().isIdentifiedUser()) {
        notFound.status = Status.FIX_FAILED;
        notFound.outcome = "Must be called by an identified user to insert new patch set";
        return;
    }
    ProblemInfo insertPatchSetProblem;
    ProblemInfo deleteOldPatchSetProblem;
    if (psIdToDelete == null) {
        insertPatchSetProblem = problem(String.format("Expected merged commit %s has no associated patch set", commit.name()));
        deleteOldPatchSetProblem = null;
    } else {
        String msg = String.format("Expected merge commit %s corresponds to patch set %s," + " not the current patch set %s", commit.name(), psIdToDelete.get(), change().currentPatchSetId().get());
        // Maybe an identical problem, but different fix.
        deleteOldPatchSetProblem = reuseOldPsId ? null : problem(msg);
        insertPatchSetProblem = problem(msg);
    }
    List<ProblemInfo> currProblems = new ArrayList<>(3);
    currProblems.add(notFound);
    if (deleteOldPatchSetProblem != null) {
        currProblems.add(insertPatchSetProblem);
    }
    currProblems.add(insertPatchSetProblem);
    try {
        PatchSet.Id psId = (psIdToDelete != null && reuseOldPsId) ? psIdToDelete : ChangeUtil.nextPatchSetId(repo, change().currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(notes, psId, commit);
        try (BatchUpdate bu = newBatchUpdate()) {
            bu.setRepository(repo, rw, oi);
            if (psIdToDelete != null) {
                // Delete the given patch set ref. If reuseOldPsId is true,
                // PatchSetInserter will reinsert the same ref, making it a no-op.
                bu.addOp(notes.getChangeId(), new BatchUpdateOp() {

                    @Override
                    public void updateRepo(RepoContext ctx) throws IOException {
                        ctx.addRefUpdate(commit, ObjectId.zeroId(), psIdToDelete.toRefName());
                    }
                });
                if (!reuseOldPsId) {
                    bu.addOp(notes.getChangeId(), new DeletePatchSetFromDbOp(checkNotNull(deleteOldPatchSetProblem), psIdToDelete));
                }
            }
            bu.addOp(notes.getChangeId(), inserter.setValidate(false).setFireRevisionCreated(false).setNotify(NotifyHandling.NONE).setAllowClosed(true).setMessage("Patch set for merged commit inserted by consistency checker"));
            bu.addOp(notes.getChangeId(), new FixMergedOp(notFound));
            bu.execute();
        }
        notes = notesFactory.createChecked(db.get(), inserter.getChange());
        insertPatchSetProblem.status = Status.FIXED;
        insertPatchSetProblem.outcome = "Inserted as patch set " + psId.get();
    } catch (OrmException | IOException | UpdateException | RestApiException e) {
        warn(e);
        for (ProblemInfo pi : currProblems) {
            pi.status = Status.FIX_FAILED;
            pi.outcome = "Error inserting merged patch set";
        }
        return;
    }
}
#end_block

#method_before
private void fixMerged(ProblemInfo p) {
    try (BatchUpdate bu = newBatchUpdate()) {
        bu.setRepository(repo, rw, oi);
        bu.addOp(ctl.getId(), new FixMergedOp(p));
        bu.execute();
    } catch (UpdateException | RestApiException e) {
        log.warn("Error marking " + ctl.getId() + "as merged", e);
        p.status = Status.FIX_FAILED;
        p.outcome = "Error updating status to merged";
    }
}
#method_after
private void fixMerged(ProblemInfo p) {
    try (BatchUpdate bu = newBatchUpdate()) {
        bu.setRepository(repo, rw, oi);
        bu.addOp(notes.getChangeId(), new FixMergedOp(p));
        bu.execute();
    } catch (UpdateException | RestApiException e) {
        log.warn("Error marking " + notes.getChangeId() + "as merged", e);
        p.status = Status.FIX_FAILED;
        p.outcome = "Error updating status to merged";
    }
}
#end_block

#method_before
private BatchUpdate newBatchUpdate() {
    return updateFactory.create(db.get(), change().getProject(), ctl.getUser(), TimeUtil.nowTs());
}
#method_after
private BatchUpdate newBatchUpdate() {
    return updateFactory.create(db.get(), change().getProject(), user.get(), TimeUtil.nowTs());
}
#end_block

#method_before
private void deletePatchSets(List<DeletePatchSetFromDbOp> ops) {
    try (BatchUpdate bu = newBatchUpdate()) {
        bu.setRepository(repo, rw, oi);
        for (DeletePatchSetFromDbOp op : ops) {
            checkArgument(op.psId.getParentKey().equals(ctl.getId()));
            bu.addOp(ctl.getId(), op);
        }
        bu.addOp(ctl.getId(), new UpdateCurrentPatchSetOp(ops));
        bu.execute();
    } catch (NoPatchSetsWouldRemainException e) {
        for (DeletePatchSetFromDbOp op : ops) {
            op.p.status = Status.FIX_FAILED;
            op.p.outcome = e.getMessage();
        }
    } catch (UpdateException | RestApiException e) {
        String msg = "Error deleting patch set";
        log.warn(msg + " of change " + ops.get(0).psId.getParentKey(), e);
        for (DeletePatchSetFromDbOp op : ops) {
            // Overwrite existing statuses that were set before the transaction was
            // rolled back.
            op.p.status = Status.FIX_FAILED;
            op.p.outcome = msg;
        }
    }
}
#method_after
private void deletePatchSets(List<DeletePatchSetFromDbOp> ops) {
    try (BatchUpdate bu = newBatchUpdate()) {
        bu.setRepository(repo, rw, oi);
        for (DeletePatchSetFromDbOp op : ops) {
            checkArgument(op.psId.getParentKey().equals(notes.getChangeId()));
            bu.addOp(notes.getChangeId(), op);
        }
        bu.addOp(notes.getChangeId(), new UpdateCurrentPatchSetOp(ops));
        bu.execute();
    } catch (NoPatchSetsWouldRemainException e) {
        for (DeletePatchSetFromDbOp op : ops) {
            op.p.status = Status.FIX_FAILED;
            op.p.outcome = e.getMessage();
        }
    } catch (UpdateException | RestApiException e) {
        String msg = "Error deleting patch set";
        log.warn(msg + " of change " + ops.get(0).psId.getParentKey(), e);
        for (DeletePatchSetFromDbOp op : ops) {
            // Overwrite existing statuses that were set before the transaction was
            // rolled back.
            op.p.status = Status.FIX_FAILED;
            op.p.outcome = msg;
        }
    }
}
#end_block

#method_before
private void warn(Throwable t) {
    log.warn("Error in consistency check of change " + ctl.getId(), t);
}
#method_after
private void warn(Throwable t) {
    log.warn("Error in consistency check of change " + notes.getChangeId(), t);
}
#end_block

#method_before
private Result result() {
    return Result.create(ctl, problems);
}
#method_after
private Result result() {
    return Result.create(notes, problems);
}
#end_block

#method_before
@Override
protected void configure() {
    DynamicSet.bind(binder(), AssigneeChangedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), ChangeAbandonedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), ChangeMergedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), ChangeRestoredListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), CommentAddedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), DraftPublishedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), HashtagsEditedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), ReviewerAddedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), ReviewerDeletedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), RevisionCreatedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), TopicEditedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), VoteDeletedListener.class).to(StreamEventsApiListener.class);
}
#method_after
@Override
protected void configure() {
    DynamicSet.bind(binder(), AssigneeChangedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), ChangeAbandonedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), ChangeMergedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), ChangeRestoredListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), CommentAddedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), HashtagsEditedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), ReviewerAddedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), ReviewerDeletedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), RevisionCreatedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), TopicEditedListener.class).to(StreamEventsApiListener.class);
    DynamicSet.bind(binder(), VoteDeletedListener.class).to(StreamEventsApiListener.class);
}
#end_block

#method_before
@Test
public void explicitZeroVoteOnNonEmptyRangeIsPresent() throws Exception {
    ProjectConfig pc = loadAllProjects();
    allow(pc, forLabel("Code-Review"), -1, 1, REGISTERED_USERS, "refs/heads/*");
    save(pc);
    PatchSetApproval cr = psa(userId, "Code-Review", 0);
    PatchSetApproval v = psa(userId, "Verified", 0);
    assertEquals(Result.create(list(cr), list(), list(v)), norm.normalize(notes, list(cr, v)));
}
#method_after
@Test
public void explicitZeroVoteOnNonEmptyRangeIsPresent() throws Exception {
    ProjectConfig pc = loadAllProjects();
    allow(pc, forLabel("Code-Review"), -1, 1, REGISTERED_USERS, "refs/heads/*");
    save(pc);
    PatchSetApproval cr = psa(userId, "Code-Review", 0);
    PatchSetApproval v = psa(userId, "Verified", 0);
    assertEquals(Result.create(list(cr, v), list(), list()), norm.normalize(notes, list(cr, v)));
}
#end_block

#method_before
@Override
public DashboardInfo apply(DashboardResource resource) throws ResourceNotFoundException, ResourceConflictException, IOException, PermissionBackendException {
    if (inherited && !resource.isProjectDefault()) {
        // inherited flag can only be used with default.
        throw new ResourceNotFoundException("inherited");
    }
    String project = resource.getControl().getProject().getName();
    if (resource.isProjectDefault()) {
        // The default is not resolved to a definition yet.
        try {
            resource = defaultOf(resource.getControl());
        } catch (ConfigInvalidException e) {
            throw new ResourceConflictException(e.getMessage());
        }
    }
    return DashboardsCollection.parse(resource.getControl().getProject(), resource.getRefName().substring(REFS_DASHBOARDS.length()), resource.getPathName(), resource.getConfig(), project, true);
}
#method_after
@Override
public DashboardInfo apply(DashboardResource rsrc) throws RestApiException, IOException, PermissionBackendException {
    if (inherited && !rsrc.isProjectDefault()) {
        throw new BadRequestException("inherited flag can only be used with default");
    }
    if (rsrc.isProjectDefault()) {
        // The default is not resolved to a definition yet.
        try {
            rsrc = defaultOf(rsrc.getProjectState(), rsrc.getUser());
        } catch (ConfigInvalidException e) {
            throw new ResourceConflictException(e.getMessage());
        }
    }
    return DashboardsCollection.parse(rsrc.getProjectState().getProject(), rsrc.getRefName().substring(REFS_DASHBOARDS.length()), rsrc.getPathName(), rsrc.getConfig(), rsrc.getProjectState().getName(), true);
}
#end_block

#method_before
private DashboardResource defaultOf(ProjectControl ctl) throws ResourceNotFoundException, IOException, ConfigInvalidException, PermissionBackendException {
    String id = ctl.getProject().getLocalDefaultDashboard();
    if (Strings.isNullOrEmpty(id)) {
        id = ctl.getProject().getDefaultDashboard();
    }
    if ("default".equals(id)) {
        throw new ResourceNotFoundException();
    } else if (!Strings.isNullOrEmpty(id)) {
        return parse(ctl, id);
    } else if (!inherited) {
        throw new ResourceNotFoundException();
    }
    for (ProjectState ps : ctl.getProjectState().tree()) {
        id = ps.getProject().getDefaultDashboard();
        if ("default".equals(id)) {
            throw new ResourceNotFoundException();
        } else if (!Strings.isNullOrEmpty(id)) {
            ctl = ps.controlFor(ctl.getUser());
            return parse(ctl, id);
        }
    }
    throw new ResourceNotFoundException();
}
#method_after
private DashboardResource defaultOf(ProjectState projectState, CurrentUser user) throws ResourceNotFoundException, IOException, ConfigInvalidException, PermissionBackendException {
    String id = projectState.getProject().getLocalDefaultDashboard();
    if (Strings.isNullOrEmpty(id)) {
        id = projectState.getProject().getDefaultDashboard();
    }
    if (isDefaultDashboard(id)) {
        throw new ResourceNotFoundException();
    } else if (!Strings.isNullOrEmpty(id)) {
        return parse(projectState, user, id);
    } else if (!inherited) {
        throw new ResourceNotFoundException();
    }
    for (ProjectState ps : projectState.tree()) {
        id = ps.getProject().getDefaultDashboard();
        if (isDefaultDashboard(id)) {
            throw new ResourceNotFoundException();
        } else if (!Strings.isNullOrEmpty(id)) {
            return parse(projectState, user, id);
        }
    }
    throw new ResourceNotFoundException();
}
#end_block

#method_before
private DashboardResource parse(ProjectControl ctl, String id) throws ResourceNotFoundException, IOException, ConfigInvalidException, PermissionBackendException {
    List<String> p = Lists.newArrayList(Splitter.on(':').limit(2).split(id));
    String ref = Url.encode(p.get(0));
    String path = Url.encode(p.get(1));
    return dashboards.parse(new ProjectResource(ctl), IdString.fromUrl(ref + ':' + path));
}
#method_after
private DashboardResource parse(ProjectState projectState, CurrentUser user, String id) throws ResourceNotFoundException, IOException, ConfigInvalidException, PermissionBackendException {
    List<String> p = Lists.newArrayList(Splitter.on(':').limit(2).split(id));
    String ref = Url.encode(p.get(0));
    String path = Url.encode(p.get(1));
    return dashboards.parse(new ProjectResource(projectState, user), IdString.fromUrl(ref + ':' + path));
}
#end_block

#method_before
@Override
public MailMessage expectedMailMessage() {
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114da7ae26e2eb053fe0c29c@google.com>").from(new Address("Jonathan Nieder (Gerrit)", "noreply-gerritcodereview-CtTy0igsBrnvL7dKoWEIEg@google.com")).addTo(new Address("ekempin", "ekempin@google.com")).textContent(textContent).subject("\uD83D\uDE1B test").dateReceived(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC));
    return expect.build();
}
#method_after
@Override
public MailMessage expectedMailMessage() {
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114da7ae26e2eb053fe0c29c@google.com>").from(new Address("Jonathan Nieder (Gerrit)", "noreply-gerritcodereview-CtTy0igsBrnvL7dKoWEIEg@google.com")).addTo(new Address("ekempin", "ekempin@google.com")).textContent(textContent).subject("\uD83D\uDE1B test").dateReceived(LocalDateTime.of(2016, Month.OCTOBER, 25, 9, 11, 35).atOffset(ZoneOffset.UTC).toInstant());
    return expect.build();
}
#end_block

#method_before
@Override
public boolean match(ChangeData object) throws OrmException {
    List<String> files = object.currentFilePaths();
    return files != null && Collections.binarySearch(files, value) >= 0;
}
#method_after
@Override
public boolean match(ChangeData object) throws OrmException {
    List<String> files;
    try {
        files = object.currentFilePaths();
    } catch (IOException e) {
        throw new OrmException(e);
    }
    return Collections.binarySearch(files, value) >= 0;
}
#end_block

#method_before
@Override
protected Response<?> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, Input input) throws RestApiException, UpdateException, PermissionBackendException {
    if (rsrc.getChange().getStatus() == Change.Status.MERGED) {
        throw new MethodNotAllowedException("delete not permitted");
    } else if (!allowDrafts && rsrc.getChange().getStatus() == Change.Status.DRAFT) {
        // If drafts are disabled, only an administrator can delete a draft.
        try {
            permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER);
        } catch (AuthException e) {
            throw new MethodNotAllowedException("Draft workflow is disabled");
        }
    } else {
        rsrc.permissions().database(db).check(ChangePermission.DELETE);
    }
    try (BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Change.Id id = rsrc.getChange().getId();
        bu.setOrder(Order.DB_BEFORE_REPO);
        bu.addOp(id, opProvider.get());
        bu.execute();
    }
    return Response.none();
}
#method_after
@Override
protected Response<?> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, Input input) throws RestApiException, UpdateException, PermissionBackendException {
    if (rsrc.getChange().getStatus() == Change.Status.MERGED) {
        throw new MethodNotAllowedException("delete not permitted");
    }
    rsrc.permissions().database(db).check(ChangePermission.DELETE);
    try (BatchUpdate bu = updateFactory.create(db.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Change.Id id = rsrc.getChange().getId();
        bu.setOrder(Order.DB_BEFORE_REPO);
        bu.addOp(id, opProvider.get());
        bu.execute();
    }
    return Response.none();
}
#end_block

#method_before
private boolean couldDeleteWhenIn(Change.Status status) {
    switch(status) {
        case NEW:
        case ABANDONED:
            // New or abandoned changes can be deleted with the right permissions.
            return true;
        case MERGED:
            // Merged changes should never be deleted.
            return false;
        case DRAFT:
            if (allowDrafts) {
                // Drafts can only be deleted if the server has drafts enabled.
                return true;
            }
            // If drafts are disabled, only administrators may delete.
            return permissionBackend.user(user).testOrFalse(GlobalPermission.ADMINISTRATE_SERVER);
    }
    return false;
}
#method_after
private boolean couldDeleteWhenIn(Change.Status status) {
    switch(status) {
        case NEW:
        case ABANDONED:
            // New or abandoned changes can be deleted with the right permissions.
            return true;
        case MERGED:
            // Merged changes should never be deleted.
            return false;
    }
    return false;
}
#end_block

#method_before
@Override
public PluginInfo apply(PluginResource resource, Input input) throws ResourceConflictException, MethodNotAllowedException {
    if (!loader.isRemoteAdminEnabled()) {
        throw new MethodNotAllowedException("remote plugin administration is disabled");
    }
    String name = resource.getName();
    try {
        loader.enablePlugins(ImmutableSet.of(name));
    } catch (PluginInstallException e) {
        StringWriter buf = new StringWriter();
        buf.write(String.format("cannot enable %s\n", name));
        PrintWriter pw = new PrintWriter(buf);
        e.printStackTrace(pw);
        pw.flush();
        throw new ResourceConflictException(buf.toString());
    }
    return ListPlugins.toPluginInfo(loader.get(name));
}
#method_after
@Override
public PluginInfo apply(PluginResource resource, Input input) throws RestApiException {
    loader.checkRemoteAdminEnabled();
    String name = resource.getName();
    try {
        loader.enablePlugins(ImmutableSet.of(name));
    } catch (PluginInstallException e) {
        StringWriter buf = new StringWriter();
        buf.write(String.format("cannot enable %s\n", name));
        PrintWriter pw = new PrintWriter(buf);
        e.printStackTrace(pw);
        pw.flush();
        throw new ResourceConflictException(buf.toString());
    }
    return ListPlugins.toPluginInfo(loader.get(name));
}
#end_block

#method_before
@Override
public Response<DashboardInfo> apply(DashboardResource resource, Input input) throws AuthException, BadRequestException, ResourceConflictException, MethodNotAllowedException, ResourceNotFoundException, IOException, PermissionBackendException {
    if (resource.isProjectDefault()) {
        return defaultSetter.get().apply(resource, input);
    }
    // TODO: Implement creation/update of dashboards by API.
    throw new MethodNotAllowedException();
}
#method_after
@Override
public Response<DashboardInfo> apply(DashboardResource resource, SetDashboardInput input) throws RestApiException, IOException, PermissionBackendException {
    if (resource.isProjectDefault()) {
        return defaultSetter.get().apply(resource, input);
    }
    // TODO: Implement creation/update of dashboards by API.
    throw new MethodNotAllowedException();
}
#end_block

#method_before
@Override
public ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, RevisionResource rsrc, CherryPickInput input) throws OrmException, IOException, UpdateException, RestApiException, PermissionBackendException, ConfigInvalidException, NoSuchProjectException {
    input.parent = input.parent == null ? 1 : input.parent;
    if (input.message == null || input.message.trim().isEmpty()) {
        throw new BadRequestException("message must be non-empty");
    } else if (input.destination == null || input.destination.trim().isEmpty()) {
        throw new BadRequestException("destination must be non-empty");
    }
    String refName = RefNames.fullName(input.destination);
    CreateChange.checkValidCLA(rsrc.getControl().getProjectControl());
    permissionBackend.user(user).project(rsrc.getChange().getProject()).ref(refName).check(RefPermission.CREATE_CHANGE);
    try {
        Change.Id cherryPickedChangeId = cherryPickChange.cherryPick(updateFactory, rsrc.getChange(), rsrc.getPatchSet(), input, new Branch.NameKey(rsrc.getProject(), refName));
        return json.noOptions().format(rsrc.getProject(), cherryPickedChangeId);
    } catch (InvalidChangeOperationException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IntegrationException | NoSuchChangeException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
@Override
public ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, RevisionResource rsrc, CherryPickInput input) throws OrmException, IOException, UpdateException, RestApiException, PermissionBackendException, ConfigInvalidException, NoSuchProjectException {
    input.parent = input.parent == null ? 1 : input.parent;
    if (input.message == null || input.message.trim().isEmpty()) {
        throw new BadRequestException("message must be non-empty");
    } else if (input.destination == null || input.destination.trim().isEmpty()) {
        throw new BadRequestException("destination must be non-empty");
    }
    String refName = RefNames.fullName(input.destination);
    contributorAgreements.check(rsrc.getProject(), rsrc.getUser());
    permissionBackend.user(user).project(rsrc.getChange().getProject()).ref(refName).check(RefPermission.CREATE_CHANGE);
    try {
        Change.Id cherryPickedChangeId = cherryPickChange.cherryPick(updateFactory, rsrc.getChange(), rsrc.getPatchSet(), input, new Branch.NameKey(rsrc.getProject(), refName));
        return json.noOptions().format(rsrc.getProject(), cherryPickedChangeId);
    } catch (InvalidChangeOperationException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IntegrationException | NoSuchChangeException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
private Map<Account.Id, MutableDouble> baseRankingForEmptyQuery(double baseWeight) throws OrmException, IOException, ConfigInvalidException {
    // Get the user's last 25 changes, check approvals
    try {
        List<ChangeData> result = queryProvider.get().setLimit(25).setRequestedFields(ImmutableSet.of(ChangeField.REVIEWER.getName())).query(changeQueryBuilder.owner("self"));
        Map<Account.Id, MutableDouble> suggestions = new HashMap<>();
        for (ChangeData cd : result) {
            for (PatchSetApproval approval : cd.currentApprovals()) {
                Account.Id id = approval.getAccountId();
                if (suggestions.containsKey(id)) {
                    suggestions.get(id).add(baseWeight);
                } else {
                    suggestions.put(id, new MutableDouble(baseWeight));
                }
            }
        }
        return suggestions;
    } catch (QueryParseException e) {
        // Unhandled, because owner:self will never provoke a QueryParseException
        log.error("Exception while suggesting reviewers", e);
        return ImmutableMap.of();
    }
}
#method_after
private Map<Account.Id, MutableDouble> baseRankingForEmptyQuery(double baseWeight) throws OrmException, IOException, ConfigInvalidException {
    // Get the user's last 25 changes, check approvals
    try {
        List<ChangeData> result = queryProvider.get().setLimit(25).setRequestedFields(ChangeField.APPROVAL).query(changeQueryBuilder.owner("self"));
        Map<Account.Id, MutableDouble> suggestions = new HashMap<>();
        for (ChangeData cd : result) {
            for (PatchSetApproval approval : cd.currentApprovals()) {
                Account.Id id = approval.getAccountId();
                if (suggestions.containsKey(id)) {
                    suggestions.get(id).add(baseWeight);
                } else {
                    suggestions.put(id, new MutableDouble(baseWeight));
                }
            }
        }
        return suggestions;
    } catch (QueryParseException e) {
        // Unhandled, because owner:self will never provoke a QueryParseException
        log.error("Exception while suggesting reviewers", e);
        return ImmutableMap.of();
    }
}
#end_block

#method_before
private Map<Account.Id, MutableDouble> baseRankingForCandidateList(List<Account.Id> candidates, ProjectState projectState, double baseWeight) throws OrmException, IOException, ConfigInvalidException {
    // Get each reviewer's activity based on number of applied labels
    // (weighted 10d), number of comments (weighted 0.5d) and number of owned
    // changes (weighted 1d).
    Map<Account.Id, MutableDouble> reviewers = new LinkedHashMap<>();
    if (candidates.size() == 0) {
        return reviewers;
    }
    List<Predicate<ChangeData>> predicates = new ArrayList<>();
    for (Account.Id id : candidates) {
        try {
            Predicate<ChangeData> projectQuery = changeQueryBuilder.project(projectState.getName());
            // Get all labels for this project and create a compound OR query to
            // fetch all changes where users have applied one of these labels
            List<LabelType> labelTypes = projectState.getLabelTypes().getLabelTypes();
            List<Predicate<ChangeData>> labelPredicates = new ArrayList<>(labelTypes.size());
            for (LabelType type : labelTypes) {
                labelPredicates.add(changeQueryBuilder.label(type.getName() + ",user=" + id));
            }
            Predicate<ChangeData> reviewerQuery = Predicate.and(projectQuery, Predicate.or(labelPredicates));
            Predicate<ChangeData> ownerQuery = Predicate.and(projectQuery, changeQueryBuilder.owner(id.toString()));
            Predicate<ChangeData> commentedByQuery = Predicate.and(projectQuery, changeQueryBuilder.commentby(id.toString()));
            predicates.add(reviewerQuery);
            predicates.add(ownerQuery);
            predicates.add(commentedByQuery);
            reviewers.put(id, new MutableDouble());
        } catch (QueryParseException e) {
            // Unhandled: If an exception is thrown, we won't increase the
            // candidates's score
            log.error("Exception while suggesting reviewers", e);
        }
    }
    List<List<ChangeData>> result = queryProvider.get().setLimit(25).setRequestedFields(ImmutableSet.of()).query(predicates);
    Iterator<List<ChangeData>> queryResultIterator = result.iterator();
    Iterator<Account.Id> reviewersIterator = reviewers.keySet().iterator();
    int i = 0;
    Account.Id currentId = null;
    while (queryResultIterator.hasNext()) {
        List<ChangeData> currentResult = queryResultIterator.next();
        if (i % WEIGHTS.length == 0) {
            currentId = reviewersIterator.next();
        }
        reviewers.get(currentId).add(WEIGHTS[i % WEIGHTS.length] * baseWeight * currentResult.size());
        i++;
    }
    return reviewers;
}
#method_after
private Map<Account.Id, MutableDouble> baseRankingForCandidateList(List<Account.Id> candidates, ProjectState projectState, double baseWeight) throws OrmException, IOException, ConfigInvalidException {
    // Get each reviewer's activity based on number of applied labels
    // (weighted 10d), number of comments (weighted 0.5d) and number of owned
    // changes (weighted 1d).
    Map<Account.Id, MutableDouble> reviewers = new LinkedHashMap<>();
    if (candidates.size() == 0) {
        return reviewers;
    }
    List<Predicate<ChangeData>> predicates = new ArrayList<>();
    for (Account.Id id : candidates) {
        try {
            Predicate<ChangeData> projectQuery = changeQueryBuilder.project(projectState.getName());
            // Get all labels for this project and create a compound OR query to
            // fetch all changes where users have applied one of these labels
            List<LabelType> labelTypes = projectState.getLabelTypes().getLabelTypes();
            List<Predicate<ChangeData>> labelPredicates = new ArrayList<>(labelTypes.size());
            for (LabelType type : labelTypes) {
                labelPredicates.add(changeQueryBuilder.label(type.getName() + ",user=" + id));
            }
            Predicate<ChangeData> reviewerQuery = Predicate.and(projectQuery, Predicate.or(labelPredicates));
            Predicate<ChangeData> ownerQuery = Predicate.and(projectQuery, changeQueryBuilder.owner(id.toString()));
            Predicate<ChangeData> commentedByQuery = Predicate.and(projectQuery, changeQueryBuilder.commentby(id.toString()));
            predicates.add(reviewerQuery);
            predicates.add(ownerQuery);
            predicates.add(commentedByQuery);
            reviewers.put(id, new MutableDouble());
        } catch (QueryParseException e) {
            // Unhandled: If an exception is thrown, we won't increase the
            // candidates's score
            log.error("Exception while suggesting reviewers", e);
        }
    }
    List<List<ChangeData>> result = queryProvider.get().setLimit(25).noFields().query(predicates);
    Iterator<List<ChangeData>> queryResultIterator = result.iterator();
    Iterator<Account.Id> reviewersIterator = reviewers.keySet().iterator();
    int i = 0;
    Account.Id currentId = null;
    while (queryResultIterator.hasNext()) {
        List<ChangeData> currentResult = queryResultIterator.next();
        if (i % WEIGHTS.length == 0) {
            currentId = reviewersIterator.next();
        }
        reviewers.get(currentId).add(WEIGHTS[i % WEIGHTS.length] * baseWeight * currentResult.size());
        i++;
    }
    return reviewers;
}
#end_block

#method_before
@Override
public GroupInfo apply(GroupResource resource, Input input) throws ResourceNotFoundException, MethodNotAllowedException, AuthException, BadRequestException, UnprocessableEntityException, OrmException, IOException {
    GroupDescription.Internal internalGroup = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new);
    if (!resource.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.owner)) {
        throw new BadRequestException("owner is required");
    }
    GroupDescription.Basic owner = groupsCollection.parse(input.owner);
    if (!internalGroup.getOwnerGroupUUID().equals(owner.getGroupUUID())) {
        AccountGroup.UUID groupUuid = internalGroup.getGroupUUID();
        try {
            groupsUpdateProvider.get().updateGroup(db.get(), groupUuid, group -> group.setOwnerGroupUUID(owner.getGroupUUID()));
        } catch (NoSuchGroupException e) {
            throw new ResourceNotFoundException(String.format("Group %s not found", groupUuid));
        }
    }
    return json.format(owner);
}
#method_after
@Override
public GroupInfo apply(GroupResource resource, OwnerInput input) throws ResourceNotFoundException, MethodNotAllowedException, AuthException, BadRequestException, UnprocessableEntityException, OrmException, IOException {
    GroupDescription.Internal internalGroup = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new);
    if (!resource.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.owner)) {
        throw new BadRequestException("owner is required");
    }
    GroupDescription.Basic owner = groupsCollection.parse(input.owner);
    if (!internalGroup.getOwnerGroupUUID().equals(owner.getGroupUUID())) {
        AccountGroup.UUID groupUuid = internalGroup.getGroupUUID();
        try {
            groupsUpdateProvider.get().updateGroup(db.get(), groupUuid, group -> group.setOwnerGroupUUID(owner.getGroupUUID()));
        } catch (NoSuchGroupException e) {
            throw new ResourceNotFoundException(String.format("Group %s not found", groupUuid));
        }
    }
    return json.format(owner);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    DynamicMap.mapOf(binder(), INCLUDED_GROUP_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    put(GROUP_KIND).to(PutGroup.class);
    get(GROUP_KIND, "detail").to(GetDetail.class);
    post(GROUP_KIND, "index").to(Index.class);
    post(GROUP_KIND, "members").to(AddMembers.class);
    post(GROUP_KIND, "members.add").to(AddMembers.class);
    post(GROUP_KIND, "members.delete").to(DeleteMembers.class);
    post(GROUP_KIND, "groups").to(AddIncludedGroups.class);
    post(GROUP_KIND, "groups.add").to(AddIncludedGroups.class);
    post(GROUP_KIND, "groups.delete").to(DeleteIncludedGroups.class);
    get(GROUP_KIND, "description").to(GetDescription.class);
    put(GROUP_KIND, "description").to(PutDescription.class);
    delete(GROUP_KIND, "description").to(PutDescription.class);
    get(GROUP_KIND, "name").to(GetName.class);
    put(GROUP_KIND, "name").to(PutName.class);
    get(GROUP_KIND, "owner").to(GetOwner.class);
    put(GROUP_KIND, "owner").to(PutOwner.class);
    get(GROUP_KIND, "options").to(GetOptions.class);
    put(GROUP_KIND, "options").to(PutOptions.class);
    get(GROUP_KIND, "log.audit").to(GetAuditLog.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
    get(MEMBER_KIND).to(GetMember.class);
    put(MEMBER_KIND).to(UpdateMember.class);
    delete(MEMBER_KIND).to(DeleteMember.class);
    child(GROUP_KIND, "groups").to(IncludedGroupsCollection.class);
    get(INCLUDED_GROUP_KIND).to(GetIncludedGroup.class);
    put(INCLUDED_GROUP_KIND).to(UpdateIncludedGroup.class);
    delete(INCLUDED_GROUP_KIND).to(DeleteIncludedGroup.class);
    factory(CreateGroup.Factory.class);
    factory(GroupsUpdate.Factory.class);
    DynamicSet.bind(binder(), GroupMemberAuditListener.class).to(DbGroupMemberAuditListener.class);
}
#method_after
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    DynamicMap.mapOf(binder(), SUBGROUP_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    put(GROUP_KIND).to(PutGroup.class);
    get(GROUP_KIND, "detail").to(GetDetail.class);
    post(GROUP_KIND, "index").to(Index.class);
    post(GROUP_KIND, "members").to(AddMembers.class);
    post(GROUP_KIND, "members.add").to(AddMembers.class);
    post(GROUP_KIND, "members.delete").to(DeleteMembers.class);
    post(GROUP_KIND, "groups").to(AddSubgroups.class);
    post(GROUP_KIND, "groups.add").to(AddSubgroups.class);
    post(GROUP_KIND, "groups.delete").to(DeleteSubgroups.class);
    get(GROUP_KIND, "description").to(GetDescription.class);
    put(GROUP_KIND, "description").to(PutDescription.class);
    delete(GROUP_KIND, "description").to(PutDescription.class);
    get(GROUP_KIND, "name").to(GetName.class);
    put(GROUP_KIND, "name").to(PutName.class);
    get(GROUP_KIND, "owner").to(GetOwner.class);
    put(GROUP_KIND, "owner").to(PutOwner.class);
    get(GROUP_KIND, "options").to(GetOptions.class);
    put(GROUP_KIND, "options").to(PutOptions.class);
    get(GROUP_KIND, "log.audit").to(GetAuditLog.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
    get(MEMBER_KIND).to(GetMember.class);
    put(MEMBER_KIND).to(UpdateMember.class);
    delete(MEMBER_KIND).to(DeleteMember.class);
    child(GROUP_KIND, "groups").to(SubgroupsCollection.class);
    get(SUBGROUP_KIND).to(GetSubgroup.class);
    put(SUBGROUP_KIND).to(UpdateSubgroup.class);
    delete(SUBGROUP_KIND).to(DeleteSubgroup.class);
    factory(CreateGroup.Factory.class);
    factory(GroupsUpdate.Factory.class);
    DynamicSet.bind(binder(), GroupMemberAuditListener.class).to(DbGroupMemberAuditListener.class);
}
#end_block

#method_before
@Override
public void setActive(boolean active) throws RestApiException {
    try {
        if (active) {
            putActive.apply(account, new PutActive.Input());
        } else {
            deleteActive.apply(account, new DeleteActive.Input());
        }
    } catch (Exception e) {
        throw asRestApiException("Cannot set active", e);
    }
}
#method_after
@Override
public void setActive(boolean active) throws RestApiException {
    try {
        if (active) {
            putActive.apply(account, new Input());
        } else {
            deleteActive.apply(account, new Input());
        }
    } catch (Exception e) {
        throw asRestApiException("Cannot set active", e);
    }
}
#end_block

#method_before
@Override
public void setStatus(String status) throws RestApiException {
    PutStatus.Input in = new PutStatus.Input(status);
    try {
        putStatus.apply(account, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot set status", e);
    }
}
#method_after
@Override
public void setStatus(String status) throws RestApiException {
    StatusInput in = new StatusInput(status);
    try {
        putStatus.apply(account, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot set status", e);
    }
}
#end_block

#method_before
@Override
public SshKeyInfo addSshKey(String key) throws RestApiException {
    AddSshKey.Input in = new AddSshKey.Input();
    in.raw = RawInputUtil.create(key);
    try {
        return addSshKey.apply(account, in).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot add SSH key", e);
    }
}
#method_after
@Override
public SshKeyInfo addSshKey(String key) throws RestApiException {
    SshKeyInput in = new SshKeyInput();
    in.raw = RawInputUtil.create(key);
    try {
        return addSshKey.apply(account, in).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot add SSH key", e);
    }
}
#end_block

#method_before
@Override
public void index() throws RestApiException {
    try {
        index.apply(account, new Index.Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot index account", e);
    }
}
#method_after
@Override
public void index() throws RestApiException {
    try {
        index.apply(account, new Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot index account", e);
    }
}
#end_block

#method_before
@Override
public String getETag(RevisionResource rsrc) {
    Hasher h = Hashing.murmur3_128().newHasher();
    CurrentUser user = rsrc.getControl().getUser();
    try {
        rsrc.getChangeResource().prepareETag(h, user);
        h.putBoolean(Submit.wholeTopicEnabled(config));
        ReviewDb db = dbProvider.get();
        ChangeSet cs = mergeSuperSet.get().completeChangeSet(db, rsrc.getChange(), user);
        for (ChangeData cd : cs.changes()) {
            changeResourceFactory.create(cd.changeControl()).prepareETag(h, user);
        }
        h.putBoolean(cs.furtherHiddenChanges());
    } catch (IOException | OrmException | PermissionBackendException e) {
        throw new OrmRuntimeException(e);
    }
    return h.hash().toString();
}
#method_after
@Override
public String getETag(RevisionResource rsrc) {
    Hasher h = Hashing.murmur3_128().newHasher();
    CurrentUser user = rsrc.getUser();
    try {
        rsrc.getChangeResource().prepareETag(h, user);
        h.putBoolean(Submit.wholeTopicEnabled(config));
        ReviewDb db = dbProvider.get();
        ChangeSet cs = mergeSuperSet.get().completeChangeSet(db, rsrc.getChange(), user);
        for (ChangeData cd : cs.changes()) {
            changeResourceFactory.create(cd.notes(), user).prepareETag(h, user);
        }
        h.putBoolean(cs.furtherHiddenChanges());
    } catch (IOException | OrmException | PermissionBackendException e) {
        throw new OrmRuntimeException(e);
    }
    return h.hash().toString();
}
#end_block

#method_before
private RepoSequence newSequence(String name, final int start, int batchSize, Runnable afterReadRef, Retryer<RefUpdate.Result> retryer) {
    return new RepoSequence(repoManager, project, name, () -> start, batchSize, afterReadRef, retryer);
}
#method_after
private RepoSequence newSequence(String name, final int start, int batchSize, Runnable afterReadRef, Retryer<RefUpdate.Result> retryer) {
    return new RepoSequence(repoManager, GitReferenceUpdated.DISABLED, project, name, () -> start, batchSize, afterReadRef, retryer);
}
#end_block

#method_before
@Override
public BinaryResult apply(RevisionResource rsrc) throws ResourceConflictException, IOException, ResourceNotFoundException {
    Project.NameKey project = rsrc.getControl().getProject().getNameKey();
    final Repository repo = repoManager.openRepository(project);
    boolean close = true;
    try {
        final RevWalk rw = new RevWalk(repo);
        try {
            final RevCommit commit = rw.parseCommit(ObjectId.fromString(rsrc.getPatchSet().getRevision().get()));
            RevCommit[] parents = commit.getParents();
            if (parents.length > 1) {
                throw new ResourceConflictException("Revision has more than 1 parent.");
            } else if (parents.length == 0) {
                throw new ResourceConflictException("Revision has no parent.");
            }
            final RevCommit base = parents[0];
            rw.parseBody(base);
            BinaryResult bin = new BinaryResult() {

                @Override
                public void writeTo(OutputStream out) throws IOException {
                    if (zip) {
                        ZipOutputStream zos = new ZipOutputStream(out);
                        ZipEntry e = new ZipEntry(fileName(rw, commit));
                        e.setTime(commit.getCommitTime() * 1000L);
                        zos.putNextEntry(e);
                        format(zos);
                        zos.closeEntry();
                        zos.finish();
                    } else {
                        format(out);
                    }
                }

                private void format(OutputStream out) throws IOException {
                    // Only add header if no path is specified
                    if (path == null) {
                        out.write(formatEmailHeader(commit).getBytes(UTF_8));
                    }
                    try (DiffFormatter fmt = new DiffFormatter(out)) {
                        fmt.setRepository(repo);
                        if (path != null) {
                            fmt.setPathFilter(PathFilter.create(path));
                        }
                        fmt.format(base.getTree(), commit.getTree());
                        fmt.flush();
                    }
                }

                @Override
                public void close() throws IOException {
                    rw.close();
                    repo.close();
                }
            };
            if (path != null && bin.asString().isEmpty()) {
                throw new ResourceNotFoundException(String.format(FILE_NOT_FOUND, path));
            }
            if (zip) {
                bin.disableGzip().setContentType("application/zip").setAttachmentName(fileName(rw, commit) + ".zip");
            } else {
                bin.base64().setContentType("application/mbox").setAttachmentName(download ? fileName(rw, commit) + ".base64" : null);
            }
            close = false;
            return bin;
        } finally {
            if (close) {
                rw.close();
            }
        }
    } finally {
        if (close) {
            repo.close();
        }
    }
}
#method_after
@Override
public BinaryResult apply(RevisionResource rsrc) throws ResourceConflictException, IOException, ResourceNotFoundException {
    final Repository repo = repoManager.openRepository(rsrc.getProject());
    boolean close = true;
    try {
        final RevWalk rw = new RevWalk(repo);
        try {
            final RevCommit commit = rw.parseCommit(ObjectId.fromString(rsrc.getPatchSet().getRevision().get()));
            RevCommit[] parents = commit.getParents();
            if (parents.length > 1) {
                throw new ResourceConflictException("Revision has more than 1 parent.");
            } else if (parents.length == 0) {
                throw new ResourceConflictException("Revision has no parent.");
            }
            final RevCommit base = parents[0];
            rw.parseBody(base);
            BinaryResult bin = new BinaryResult() {

                @Override
                public void writeTo(OutputStream out) throws IOException {
                    if (zip) {
                        ZipOutputStream zos = new ZipOutputStream(out);
                        ZipEntry e = new ZipEntry(fileName(rw, commit));
                        e.setTime(commit.getCommitTime() * 1000L);
                        zos.putNextEntry(e);
                        format(zos);
                        zos.closeEntry();
                        zos.finish();
                    } else {
                        format(out);
                    }
                }

                private void format(OutputStream out) throws IOException {
                    // Only add header if no path is specified
                    if (path == null) {
                        out.write(formatEmailHeader(commit).getBytes(UTF_8));
                    }
                    try (DiffFormatter fmt = new DiffFormatter(out)) {
                        fmt.setRepository(repo);
                        if (path != null) {
                            fmt.setPathFilter(PathFilter.create(path));
                        }
                        fmt.format(base.getTree(), commit.getTree());
                        fmt.flush();
                    }
                }

                @Override
                public void close() throws IOException {
                    rw.close();
                    repo.close();
                }
            };
            if (path != null && bin.asString().isEmpty()) {
                throw new ResourceNotFoundException(String.format(FILE_NOT_FOUND, path));
            }
            if (zip) {
                bin.disableGzip().setContentType("application/zip").setAttachmentName(fileName(rw, commit) + ".zip");
            } else {
                bin.base64().setContentType("application/mbox").setAttachmentName(download ? fileName(rw, commit) + ".base64" : null);
            }
            close = false;
            return bin;
        } finally {
            if (close) {
                rw.close();
            }
        }
    } finally {
        if (close) {
            repo.close();
        }
    }
}
#end_block

#method_before
@Before
public void setUp() {
    String tz = "US/Eastern";
    systemTimeZoneProperty = System.setProperty("user.timezone", tz);
    systemTimeZone = TimeZone.getDefault();
    TimeZone.setDefault(TimeZone.getTimeZone(tz));
    long maxMs = ChangeRebuilderImpl.MAX_WINDOW_MS;
    assertThat(maxMs).isGreaterThan(1000L);
    TestTimeUtil.resetWithClockStep(maxMs * 2, MILLISECONDS);
    project = new Project.NameKey("project");
    accountId = new Account.Id(100);
}
#method_after
@Before
public void setUp() {
    systemTimeZoneProperty = System.setProperty("user.timezone", TIMEZONE_ID);
    systemTimeZone = TimeZone.getDefault();
    TimeZone.setDefault(TimeZone.getTimeZone(TIMEZONE_ID));
    long maxMs = ChangeRebuilderImpl.MAX_WINDOW_MS;
    assertThat(maxMs).isGreaterThan(1000L);
    TestTimeUtil.resetWithClockStep(maxMs * 2, MILLISECONDS);
    project = new Project.NameKey("project");
    accountId = new Account.Id(100);
}
#end_block

#method_before
@Test
public void diffPatchSetApprovalsAllowsTruncatedTimestampInNoteDb() throws Exception {
    Change c = TestChanges.newChange(project, accountId);
    PatchSetApproval a1 = new PatchSetApproval(new PatchSetApproval.Key(c.currentPatchSetId(), accountId, new LabelId("Code-Review")), (short) 1, c.getCreatedOn());
    PatchSetApproval a2 = clone(a1);
    a2.setGranted(new Timestamp(new DateTime(1900, 1, 1, 0, 0, 0, DateTimeZone.forTimeZone(TimeZone.getDefault())).getMillis()));
    // Both are ReviewDb, exact match is required.
    ChangeBundle b1 = new ChangeBundle(c, messages(), latest(c), approvals(a1), comments(), reviewers(), REVIEW_DB);
    ChangeBundle b2 = new ChangeBundle(c, messages(), latest(c), approvals(a2), comments(), reviewers(), REVIEW_DB);
    assertDiffs(b1, b2, "granted differs for PatchSetApproval.Key " + c.getId() + "%2C1,100,Code-Review:" + " {2009-09-30 17:00:00.0} != {1900-01-01 00:00:00.0}");
    // Truncating NoteDb timestamp is allowed.
    b1 = new ChangeBundle(c, messages(), latest(c), approvals(a1), comments(), reviewers(), NOTE_DB);
    b2 = new ChangeBundle(c, messages(), latest(c), approvals(a2), comments(), reviewers(), REVIEW_DB);
    assertNoDiffs(b1, b2);
    assertNoDiffs(b2, b1);
}
#method_after
@Test
public void diffPatchSetApprovalsAllowsTruncatedTimestampInNoteDb() throws Exception {
    Change c = TestChanges.newChange(project, accountId);
    PatchSetApproval a1 = new PatchSetApproval(new PatchSetApproval.Key(c.currentPatchSetId(), accountId, new LabelId("Code-Review")), (short) 1, c.getCreatedOn());
    PatchSetApproval a2 = clone(a1);
    a2.setGranted(new Timestamp(LocalDate.of(1900, Month.JANUARY, 1).atStartOfDay().atZone(ZoneId.of(TIMEZONE_ID)).toInstant().toEpochMilli()));
    // Both are ReviewDb, exact match is required.
    ChangeBundle b1 = new ChangeBundle(c, messages(), latest(c), approvals(a1), comments(), reviewers(), REVIEW_DB);
    ChangeBundle b2 = new ChangeBundle(c, messages(), latest(c), approvals(a2), comments(), reviewers(), REVIEW_DB);
    assertDiffs(b1, b2, "granted differs for PatchSetApproval.Key " + c.getId() + "%2C1,100,Code-Review:" + " {2009-09-30 17:00:00.0} != {1900-01-01 00:00:00.0}");
    // Truncating NoteDb timestamp is allowed.
    b1 = new ChangeBundle(c, messages(), latest(c), approvals(a1), comments(), reviewers(), NOTE_DB);
    b2 = new ChangeBundle(c, messages(), latest(c), approvals(a2), comments(), reviewers(), REVIEW_DB);
    assertNoDiffs(b1, b2);
    assertNoDiffs(b2, b1);
}
#end_block

#method_before
private List<BranchInfo> toBranchInfo(ProjectResource rsrc, List<Ref> refs) throws PermissionBackendException {
    Set<String> targets = Sets.newHashSetWithExpectedSize(1);
    for (Ref ref : refs) {
        if (ref.isSymbolic()) {
            targets.add(ref.getTarget().getName());
        }
    }
    ProjectControl pctl = rsrc.getControl();
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(rsrc.getNameKey());
    List<BranchInfo> branches = new ArrayList<>(refs.size());
    for (Ref ref : refs) {
        if (ref.isSymbolic()) {
            // A symbolic reference to another branch, instead of
            // showing the resolved value, show the name it references.
            // 
            String target = ref.getTarget().getName();
            if (!perm.ref(target).test(RefPermission.READ)) {
                continue;
            }
            if (target.startsWith(Constants.R_HEADS)) {
                target = target.substring(Constants.R_HEADS.length());
            }
            BranchInfo b = new BranchInfo();
            b.ref = ref.getName();
            b.revision = target;
            branches.add(b);
            if (!Constants.HEAD.equals(ref.getName())) {
                b.canDelete = perm.ref(ref.getName()).testOrFalse(RefPermission.DELETE) ? true : null;
            }
            continue;
        }
        if (perm.ref(ref.getName()).test(RefPermission.READ)) {
            branches.add(createBranchInfo(perm.ref(ref.getName()), ref, pctl, targets));
        }
    }
    Collections.sort(branches, new BranchComparator());
    return branches;
}
#method_after
private List<BranchInfo> toBranchInfo(ProjectResource rsrc, List<Ref> refs) throws PermissionBackendException {
    Set<String> targets = Sets.newHashSetWithExpectedSize(1);
    for (Ref ref : refs) {
        if (ref.isSymbolic()) {
            targets.add(ref.getTarget().getName());
        }
    }
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(rsrc.getNameKey());
    List<BranchInfo> branches = new ArrayList<>(refs.size());
    for (Ref ref : refs) {
        if (ref.isSymbolic()) {
            // A symbolic reference to another branch, instead of
            // showing the resolved value, show the name it references.
            // 
            String target = ref.getTarget().getName();
            if (!perm.ref(target).test(RefPermission.READ)) {
                continue;
            }
            if (target.startsWith(Constants.R_HEADS)) {
                target = target.substring(Constants.R_HEADS.length());
            }
            BranchInfo b = new BranchInfo();
            b.ref = ref.getName();
            b.revision = target;
            branches.add(b);
            if (!Constants.HEAD.equals(ref.getName())) {
                b.canDelete = perm.ref(ref.getName()).testOrFalse(RefPermission.DELETE) ? true : null;
            }
            continue;
        }
        if (perm.ref(ref.getName()).test(RefPermission.READ)) {
            branches.add(createBranchInfo(perm.ref(ref.getName()), ref, rsrc.getProjectState(), rsrc.getUser(), targets));
        }
    }
    Collections.sort(branches, new BranchComparator());
    return branches;
}
#end_block

#method_before
private BranchInfo createBranchInfo(PermissionBackend.ForRef perm, Ref ref, ProjectControl pctl, Set<String> targets) {
    BranchInfo info = new BranchInfo();
    info.ref = ref.getName();
    info.revision = ref.getObjectId() != null ? ref.getObjectId().name() : null;
    info.canDelete = !targets.contains(ref.getName()) && perm.testOrFalse(RefPermission.DELETE) ? true : null;
    BranchResource rsrc = new BranchResource(pctl, ref);
    for (UiAction.Description d : uiActions.from(branchViews, rsrc)) {
        if (info.actions == null) {
            info.actions = new TreeMap<>();
        }
        info.actions.put(d.getId(), new ActionInfo(d));
    }
    List<WebLinkInfo> links = webLinks.getBranchLinks(pctl.getProject().getName(), ref.getName());
    info.webLinks = links.isEmpty() ? null : links;
    return info;
}
#method_after
private BranchInfo createBranchInfo(PermissionBackend.ForRef perm, Ref ref, ProjectState projectState, CurrentUser user, Set<String> targets) {
    BranchInfo info = new BranchInfo();
    info.ref = ref.getName();
    info.revision = ref.getObjectId() != null ? ref.getObjectId().name() : null;
    info.canDelete = !targets.contains(ref.getName()) && perm.testOrFalse(RefPermission.DELETE) ? true : null;
    BranchResource rsrc = new BranchResource(projectState, user, ref);
    for (UiAction.Description d : uiActions.from(branchViews, rsrc)) {
        if (info.actions == null) {
            info.actions = new TreeMap<>();
        }
        info.actions.put(d.getId(), new ActionInfo(d));
    }
    List<WebLinkInfo> links = webLinks.getBranchLinks(projectState.getName(), ref.getName());
    info.webLinks = links.isEmpty() ? null : links;
    return info;
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    ListMultimap<Account.Id, Change.Id> imports = MultimapBuilder.hashKeys().arrayListValues().build();
    try (Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
        ResultSet rs = stmt.executeQuery("SELECT account_id, change_id FROM starred_changes")) {
        while (rs.next()) {
            Account.Id accountId = new Account.Id(rs.getInt(1));
            Change.Id changeId = new Change.Id(rs.getInt(2));
            imports.put(accountId, changeId);
        }
    }
    if (imports.isEmpty()) {
        return;
    }
    try (Repository git = repoManager.openRepository(allUsersName);
        RevWalk rw = new RevWalk(git)) {
        BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate();
        ObjectId id = StarredChangesUtil.writeLabels(git, StarredChangesUtil.DEFAULT_LABELS);
        for (Map.Entry<Account.Id, Change.Id> e : imports.entries()) {
            bru.addCommand(new ReceiveCommand(ObjectId.zeroId(), id, RefNames.refsStarredChanges(e.getValue(), e.getKey())));
        }
        bru.execute(rw, new TextProgressMonitor());
    } catch (IOException ex) {
        throw new OrmException(ex);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    ListMultimap<Account.Id, Change.Id> imports = MultimapBuilder.hashKeys().arrayListValues().build();
    try (Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
        ResultSet rs = stmt.executeQuery("SELECT account_id, change_id FROM starred_changes")) {
        while (rs.next()) {
            Account.Id accountId = new Account.Id(rs.getInt(1));
            Change.Id changeId = new Change.Id(rs.getInt(2));
            imports.put(accountId, changeId);
        }
    }
    if (imports.isEmpty()) {
        return;
    }
    try (Repository git = repoManager.openRepository(allUsersName);
        RevWalk rw = new RevWalk(git)) {
        BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate();
        ObjectId id = StarredChangesUtil.writeLabels(git, StarredChangesUtil.DEFAULT_LABELS);
        for (Map.Entry<Account.Id, Change.Id> e : imports.entries()) {
            bru.addCommand(new ReceiveCommand(ObjectId.zeroId(), id, RefNames.refsStarredChanges(e.getValue(), e.getKey())));
        }
        bru.execute(rw, new TextProgressMonitor());
    } catch (IOException | IllegalLabelException ex) {
        throw new OrmException(ex);
    }
}
#end_block

#method_before
public ChangeControl forUser(CurrentUser who) {
    if (getUser().equals(who)) {
        return this;
    }
    return new ChangeControl(changeDataFactory, approvalsUtil, getRefControl().forUser(who), notes, patchSetUtil);
}
#method_after
ChangeControl forUser(CurrentUser who) {
    if (getUser().equals(who)) {
        return this;
    }
    return new ChangeControl(changeDataFactory, approvalsUtil, getRefControl().forUser(who), notes, patchSetUtil);
}
#end_block

#method_before
public RefControl getRefControl() {
    return refControl;
}
#method_after
private RefControl getRefControl() {
    return refControl;
}
#end_block

#method_before
public CurrentUser getUser() {
    return getRefControl().getUser();
}
#method_after
private CurrentUser getUser() {
    return getRefControl().getUser();
}
#end_block

#method_before
public ProjectControl getProjectControl() {
    return getRefControl().getProjectControl();
}
#method_after
private ProjectControl getProjectControl() {
    return getRefControl().getProjectControl();
}
#end_block

#method_before
public Change getChange() {
    return notes.getChange();
}
#method_after
private Change getChange() {
    return notes.getChange();
}
#end_block

#method_before
public ChangeNotes getNotes() {
    return notes;
}
#method_after
private ChangeNotes getNotes() {
    return notes;
}
#end_block

#method_before
private boolean isVisible(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getChange().isPrivate() && !isPrivateVisible(db, cd)) {
        return false;
    }
    if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
        return false;
    }
    return getRefControl().isVisible();
}
#method_after
private boolean isVisible(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getChange().isPrivate() && !isPrivateVisible(db, cd)) {
        return false;
    }
    return isRefVisible();
}
#end_block

#method_before
private boolean canDelete(ReviewDb db, Change.Status status) throws OrmException {
    if (!isVisible(db)) {
        return false;
    }
    switch(status) {
        case DRAFT:
            return isOwner() || getRefControl().canDeleteDrafts() || getProjectControl().isAdmin();
        case NEW:
        case ABANDONED:
            return (isOwner() && getRefControl().canDeleteOwnChanges()) || getProjectControl().isAdmin();
        case MERGED:
        default:
            return false;
    }
}
#method_after
private boolean canDelete(Change.Status status) {
    switch(status) {
        case NEW:
        case ABANDONED:
            return (isOwner() && getRefControl().canDeleteOwnChanges()) || getProjectControl().isAdmin();
        case MERGED:
        default:
            return false;
    }
}
#end_block

#method_before
private boolean canAddPatchSet(ReviewDb db) throws OrmException {
    if (!refControl.asForRef().testOrFalse(RefPermission.CREATE_CHANGE) || isPatchSetLocked(db) || !isPatchVisible(patchSetUtil.current(db, notes), db)) {
        return false;
    }
    if (isOwner()) {
        return true;
    }
    return getRefControl().canAddPatchSet();
}
#method_after
private boolean canAddPatchSet(ReviewDb db) throws OrmException {
    if (!refControl.asForRef().testOrFalse(RefPermission.CREATE_CHANGE) || isPatchSetLocked(db)) {
        return false;
    }
    if (isOwner()) {
        return true;
    }
    return getRefControl().canAddPatchSet();
}
#end_block

#method_before
boolean isPatchSetLocked(ReviewDb db) throws OrmException {
    if (getChange().getStatus() == Change.Status.MERGED) {
        return false;
    }
    for (PatchSetApproval ap : approvalsUtil.byPatchSet(db, getNotes(), getUser(), getChange().currentPatchSetId(), null, null)) {
        LabelType type = getProjectControl().getProjectState().getLabelTypes(getNotes(), getUser()).byLabel(ap.getLabel());
        if (type != null && ap.getValue() == 1 && type.getFunctionName().equalsIgnoreCase("PatchSetLock")) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isPatchSetLocked(ReviewDb db) throws OrmException {
    if (getChange().getStatus() == Change.Status.MERGED) {
        return false;
    }
    for (PatchSetApproval ap : approvalsUtil.byPatchSet(db, getNotes(), getUser(), getChange().currentPatchSetId(), null, null)) {
        LabelType type = getProjectControl().getProjectState().getLabelTypes(getNotes(), getUser()).byLabel(ap.getLabel());
        if (type != null && ap.getValue() == 1 && type.getFunction() == LabelFunction.PATCH_SET_LOCK) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private ChangeData changeData(ReviewDb db, @Nullable ChangeData cd) {
    return cd != null ? cd : changeDataFactory.create(db, this);
}
#method_after
private ChangeData changeData(ReviewDb db, @Nullable ChangeData cd) {
    return cd != null ? cd : changeDataFactory.create(db, getNotes());
}
#end_block

#method_before
private ChangeData changeData() {
    if (cd == null) {
        ReviewDb reviewDb = db();
        checkState(reviewDb != null, "need ReviewDb");
        cd = changeDataFactory.create(reviewDb, ChangeControl.this);
    }
    return cd;
}
#method_after
private ChangeData changeData() {
    if (cd == null) {
        ReviewDb reviewDb = db();
        checkState(reviewDb != null, "need ReviewDb");
        cd = changeDataFactory.create(reviewDb, getNotes());
    }
    return cd;
}
#end_block

#method_before
private boolean can(ChangePermission perm) throws PermissionBackendException {
    try {
        switch(perm) {
            case READ:
                return isVisible(db(), changeData());
            case ABANDON:
                return canAbandon(db());
            case DELETE:
                return canDelete(db(), getChange().getStatus());
            case ADD_PATCH_SET:
                return canAddPatchSet(db());
            case EDIT_ASSIGNEE:
                return canEditAssignee();
            case EDIT_DESCRIPTION:
                return canEditDescription();
            case EDIT_HASHTAGS:
                return canEditHashtags();
            case EDIT_TOPIC_NAME:
                return canEditTopicName();
            case REBASE:
                return canRebase(db());
            case RESTORE:
                return canRestore(db());
            case SUBMIT:
                return getRefControl().canSubmit(isOwner());
            case REMOVE_REVIEWER:
            case SUBMIT_AS:
                return getRefControl().canPerform(perm.permissionName().get());
        }
    } catch (OrmException e) {
        throw new PermissionBackendException("unavailable", e);
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
private boolean can(ChangePermission perm) throws PermissionBackendException {
    try {
        switch(perm) {
            case READ:
                return isVisible(db(), changeData());
            case ABANDON:
                return canAbandon(db());
            case DELETE:
                return canDelete(getChange().getStatus());
            case ADD_PATCH_SET:
                return canAddPatchSet(db());
            case EDIT_ASSIGNEE:
                return canEditAssignee();
            case EDIT_DESCRIPTION:
                return canEditDescription();
            case EDIT_HASHTAGS:
                return canEditHashtags();
            case EDIT_TOPIC_NAME:
                return canEditTopicName();
            case REBASE:
                return canRebase(db());
            case RESTORE:
                return canRestore(db());
            case SUBMIT:
                return getRefControl().canSubmit(isOwner());
            case REMOVE_REVIEWER:
            case SUBMIT_AS:
                return getRefControl().canPerform(perm.permissionName().get());
        }
    } catch (OrmException e) {
        throw new PermissionBackendException("unavailable", e);
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
private SortedMap<String, GroupInfo> list(ListRequest req) throws RestApiException {
    TopLevelResource tlr = TopLevelResource.INSTANCE;
    ListGroups list = listGroups.get();
    list.setOptions(req.getOptions());
    for (String project : req.getProjects()) {
        try {
            list.addProject(projects.parse(tlr, IdString.fromDecoded(project)).getControl());
        } catch (Exception e) {
            throw asRestApiException("Error looking up project " + project, e);
        }
    }
    for (String group : req.getGroups()) {
        list.addGroup(groups.parse(group).getGroupUUID());
    }
    list.setVisibleToAll(req.getVisibleToAll());
    if (req.getUser() != null) {
        try {
            list.setUser(accounts.parse(req.getUser()).getAccountId());
        } catch (Exception e) {
            throw asRestApiException("Error looking up user " + req.getUser(), e);
        }
    }
    list.setOwned(req.getOwned());
    list.setLimit(req.getLimit());
    list.setStart(req.getStart());
    list.setMatchSubstring(req.getSubstring());
    list.setMatchRegex(req.getRegex());
    list.setSuggest(req.getSuggest());
    try {
        return list.apply(tlr);
    } catch (Exception e) {
        throw asRestApiException("Cannot list groups", e);
    }
}
#method_after
private SortedMap<String, GroupInfo> list(ListRequest req) throws RestApiException {
    TopLevelResource tlr = TopLevelResource.INSTANCE;
    ListGroups list = listGroups.get();
    list.setOptions(req.getOptions());
    for (String project : req.getProjects()) {
        try {
            ProjectResource rsrc = projects.parse(tlr, IdString.fromDecoded(project));
            list.addProject(rsrc.getProjectState());
        } catch (Exception e) {
            throw asRestApiException("Error looking up project " + project, e);
        }
    }
    for (String group : req.getGroups()) {
        list.addGroup(groups.parse(group).getGroupUUID());
    }
    list.setVisibleToAll(req.getVisibleToAll());
    if (req.getOwnedBy() != null) {
        list.setOwnedBy(req.getOwnedBy());
    }
    if (req.getUser() != null) {
        try {
            list.setUser(accounts.parse(req.getUser()).getAccountId());
        } catch (Exception e) {
            throw asRestApiException("Error looking up user " + req.getUser(), e);
        }
    }
    list.setOwned(req.getOwned());
    list.setLimit(req.getLimit());
    list.setStart(req.getStart());
    list.setMatchSubstring(req.getSubstring());
    list.setMatchRegex(req.getRegex());
    list.setSuggest(req.getSuggest());
    try {
        return list.apply(tlr);
    } catch (Exception e) {
        throw asRestApiException("Cannot list groups", e);
    }
}
#end_block

#method_before
@Override
public MailMessage expectedMailMessage() {
    System.out.println("\uD83D\uDE1B test");
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<CAM7sg=3meaAVUxW3KXeJEVs8sv_ADw1BnvpcHHiYVR2TQQi__w@mail.gmail.com>").from(new Address("Patrick Hiesel", "hiesel@google.com")).addTo(new Address("Patrick Hiesel", "hiesel@google.com")).textContent("Contains unwanted attachment").htmlContent("<div dir=\"ltr\">Contains unwanted attachment</div>").subject("Test Subject").addAdditionalHeader("MIME-Version: 1.0").dateReceived(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC));
    return expect.build();
}
#method_after
@Override
public MailMessage expectedMailMessage() {
    System.out.println("\uD83D\uDE1B test");
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<CAM7sg=3meaAVUxW3KXeJEVs8sv_ADw1BnvpcHHiYVR2TQQi__w@mail.gmail.com>").from(new Address("Patrick Hiesel", "hiesel@google.com")).addTo(new Address("Patrick Hiesel", "hiesel@google.com")).textContent("Contains unwanted attachment").htmlContent("<div dir=\"ltr\">Contains unwanted attachment</div>").subject("Test Subject").addAdditionalHeader("MIME-Version: 1.0").dateReceived(LocalDateTime.of(2016, Month.OCTOBER, 25, 9, 11, 35).atOffset(ZoneOffset.UTC).toInstant());
    return expect.build();
}
#end_block

#method_before
private void setListIdHeader() throws EmailException {
    // Set a reasonable list id so that filters can be used to sort messages
    setVHeader("List-Id", "<$email.listId.replace('@', '.')>");
    if (getSettingsUrl() != null) {
        setVHeader("List-Unsubscribe", "<$email.settingsUrl>");
    }
}
#method_after
private void setListIdHeader() {
    // Set a reasonable list id so that filters can be used to sort messages
    setHeader("List-Id", "<gerrit-" + branch.getParentKey().get().replace('/', '-') + "." + getGerritHost() + ">");
    if (getSettingsUrl() != null) {
        setHeader("List-Unsubscribe", "<" + getSettingsUrl() + ">");
    }
}
#end_block

#method_before
@Override
public MailMessage expectedMailMessage() {
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114cd8be55b4ab053face5cd@google.com>").from(new Address("ekempin (Gerrit)", "noreply-gerritcodereview-qUgXfQecoDLHwp0MldAzig@google.com")).addCc(new Address("ekempin", "ekempin@google.com")).addTo(new Address("Patrick Hiesel", "hiesel@google.com")).textContent(textContent).htmlContent(unencodedHtmlContent).subject("Change in gerrit[master]: Implement receiver class structure and bindings").addAdditionalHeader("MIME-Version: 1.0").dateReceived(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC));
    return expect.build();
}
#method_after
@Override
public MailMessage expectedMailMessage() {
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114cd8be55b4ab053face5cd@google.com>").from(new Address("ekempin (Gerrit)", "noreply-gerritcodereview-qUgXfQecoDLHwp0MldAzig@google.com")).addCc(new Address("ekempin", "ekempin@google.com")).addTo(new Address("Patrick Hiesel", "hiesel@google.com")).textContent(textContent).htmlContent(unencodedHtmlContent).subject("Change in gerrit[master]: Implement receiver class structure and bindings").addAdditionalHeader("MIME-Version: 1.0").dateReceived(LocalDateTime.of(2016, Month.OCTOBER, 25, 9, 11, 35).atOffset(ZoneOffset.UTC).toInstant());
    return expect.build();
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    testEnv.getInjector().injectMembers(this);
    db = testEnv.getDb();
}
#method_after
@Before
public void setUp() throws Exception {
    testEnv.getInjector().injectMembers(this);
    db = testEnv.getDb();
    assume().that(db instanceof JdbcSchema).isTrue();
    connection = ((JdbcSchema) db).getConnection();
    createdOnRetrieval = connection.prepareStatement("SELECT created_on FROM account_groups WHERE group_id = ?");
    createdOnUpdate = connection.prepareStatement("UPDATE account_groups SET created_on = ? WHERE group_id = ?");
    auditEntryDeletion = connection.prepareStatement("DELETE FROM account_group_members_audit WHERE group_id = ?");
}
#end_block

#method_before
@Test
public void createdOnIsPopulatedForGroupsCreatedAfterAudit() throws Exception {
    Timestamp testStartTime = TimeUtil.nowTs();
    AccountGroup.Id groupId = createGroup("Group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    schema151.migrateData(db, new TestUpdateUI());
    AccountGroup group = db.accountGroups().get(groupId);
    assertThat(group.getCreatedOn()).isAtLeast(testStartTime);
}
#method_after
@Test
public void createdOnIsPopulatedForGroupsCreatedAfterAudit() throws Exception {
    Timestamp testStartTime = TimeUtil.nowTs();
    AccountGroup.Id groupId = createGroup("Group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    schema151.migrateData(db, new TestUpdateUI());
    Timestamp createdOn = getCreatedOn(groupId);
    assertThat(createdOn).isAtLeast(testStartTime);
}
#end_block

#method_before
@Test
public void createdOnIsPopulatedForGroupsCreatedBeforeAudit() throws Exception {
    AccountGroup.Id groupId = createGroup("Ancient group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    removeAuditEntriesFor(groupId);
    schema151.migrateData(db, new TestUpdateUI());
    AccountGroup group = db.accountGroups().get(groupId);
    assertThat(group.getCreatedOn()).isEqualTo(AccountGroup.auditCreationInstantTs());
}
#method_after
@Test
public void createdOnIsPopulatedForGroupsCreatedBeforeAudit() throws Exception {
    AccountGroup.Id groupId = createGroup("Ancient group for schema migration");
    setCreatedOnToVeryOldTimestamp(groupId);
    removeAuditEntriesFor(groupId);
    schema151.migrateData(db, new TestUpdateUI());
    Timestamp createdOn = getCreatedOn(groupId);
    assertThat(createdOn).isEqualTo(AccountGroup.auditCreationInstantTs());
}
#end_block

#method_before
private void setCreatedOnToVeryOldTimestamp(Id groupId) throws OrmException {
    AccountGroup group = db.accountGroups().get(groupId);
    Instant instant = LocalDateTime.of(1800, Month.JANUARY, 1, 0, 0).toInstant(ZoneOffset.UTC);
    group.setCreatedOn(Timestamp.from(instant));
    db.accountGroups().update(ImmutableList.of(group));
}
#method_after
private void setCreatedOnToVeryOldTimestamp(Id groupId) throws Exception {
    createdOnUpdate.setInt(1, groupId.get());
    Instant instant = LocalDateTime.of(1800, Month.JANUARY, 1, 0, 0).toInstant(ZoneOffset.UTC);
    createdOnUpdate.setTimestamp(1, Timestamp.from(instant));
    createdOnUpdate.setInt(2, groupId.get());
    createdOnUpdate.executeUpdate();
}
#end_block

#method_before
private void removeAuditEntriesFor(AccountGroup.Id groupId) throws Exception {
    ResultSet<AccountGroupMemberAudit> groupMemberAudits = db.accountGroupMembersAudit().byGroup(groupId);
    db.accountGroupMembersAudit().delete(groupMemberAudits);
}
#method_after
private void removeAuditEntriesFor(AccountGroup.Id groupId) throws Exception {
    auditEntryDeletion.setInt(1, groupId.get());
    auditEntryDeletion.executeUpdate();
}
#end_block

#method_before
@Override
public void configure() {
    listener().to(OnlineNoteDbMigrator.class);
}
#method_after
@Override
public void configure() {
    listener().to(OnlineNoteDbMigrator.class);
    bindConstant().annotatedWith(Names.named(TRIAL)).to(trial);
}
#end_block

#method_before
private void migrate() {
    log.info("Starting online NoteDb migration");
    if (upgradeIndex) {
        log.info("Online index schema upgrades will be deferred until NoteDb migration is complete");
    }
    Stopwatch sw = Stopwatch.createStarted();
    // TODO(dborowitz): Tune threads, maybe expose a progress monitor somewhere.
    try (NoteDbMigrator migrator = migratorBuilderProvider.get().setAutoMigrate(true).build()) {
        migrator.migrate();
    } catch (Exception e) {
        log.error("Error in online NoteDb migration", e);
    }
    log.info("Online NoteDb migration completed in {}s", sw.elapsed(TimeUnit.SECONDS));
    if (upgradeIndex) {
        log.info("Starting deferred index schema upgrades");
        indexUpgrader.start();
    }
}
#method_after
private void migrate() {
    log.info("Starting online NoteDb migration");
    if (upgradeIndex) {
        log.info("Online index schema upgrades will be deferred until NoteDb migration is complete");
    }
    Stopwatch sw = Stopwatch.createStarted();
    // TODO(dborowitz): Tune threads, maybe expose a progress monitor somewhere.
    try (NoteDbMigrator migrator = migratorBuilderProvider.get().setAutoMigrate(true).setTrialMode(trial).build()) {
        migrator.migrate();
    } catch (Exception e) {
        log.error("Error in online NoteDb migration", e);
    }
    log.info("Online NoteDb migration completed in {}s", sw.elapsed(TimeUnit.SECONDS));
    if (upgradeIndex) {
        log.info("Starting deferred index schema upgrades");
        indexUpgrader.start();
    }
}
#end_block

#method_before
private void updatePatchSetStates() {
    Set<PatchSet.Id> missing = new TreeSet<>(ReviewDbUtil.intKeyOrdering());
    for (Iterator<PatchSet> it = patchSets.values().iterator(); it.hasNext(); ) {
        PatchSet ps = it.next();
        if (ps.getRevision().equals(PARTIAL_PATCH_SET)) {
            missing.add(ps.getId());
            it.remove();
        }
    }
    for (Map.Entry<PatchSet.Id, PatchSetState> e : patchSetStates.entrySet()) {
        switch(e.getValue()) {
            case PUBLISHED:
            default:
                break;
            case DELETED:
                patchSets.remove(e.getKey());
                break;
            case DRAFT:
                PatchSet ps = patchSets.get(e.getKey());
                if (ps != null) {
                    ps.setDraft(true);
                }
                break;
        }
    }
    // Post-process other collections to remove items corresponding to deleted
    // (or otherwise missing) patch sets. This is safer than trying to prevent
    // insertion, as it will also filter out items racily added after the patch
    // set was deleted.
    changeMessagesByPatchSet.keys().retainAll(patchSets.keySet());
    int pruned = pruneEntitiesForMissingPatchSets(allChangeMessages, ChangeMessage::getPatchSetId, missing);
    pruned += pruneEntitiesForMissingPatchSets(comments.values(), c -> new PatchSet.Id(id, c.key.patchSetId), missing);
    pruned += pruneEntitiesForMissingPatchSets(approvals.values(), PatchSetApproval::getPatchSetId, missing);
    if (!missing.isEmpty()) {
        log.warn("ignoring {} additional entities due to missing patch sets: {}", pruned, missing);
    }
}
#method_after
private void updatePatchSetStates() {
    Set<PatchSet.Id> missing = new TreeSet<>(ReviewDbUtil.intKeyOrdering());
    for (Iterator<PatchSet> it = patchSets.values().iterator(); it.hasNext(); ) {
        PatchSet ps = it.next();
        if (ps.getRevision().equals(PARTIAL_PATCH_SET)) {
            missing.add(ps.getId());
            it.remove();
        }
    }
    for (Map.Entry<PatchSet.Id, PatchSetState> e : patchSetStates.entrySet()) {
        switch(e.getValue()) {
            case PUBLISHED:
            default:
                break;
            case DELETED:
                patchSets.remove(e.getKey());
                break;
        }
    }
    // Post-process other collections to remove items corresponding to deleted
    // (or otherwise missing) patch sets. This is safer than trying to prevent
    // insertion, as it will also filter out items racily added after the patch
    // set was deleted.
    changeMessagesByPatchSet.keys().retainAll(patchSets.keySet());
    int pruned = pruneEntitiesForMissingPatchSets(allChangeMessages, ChangeMessage::getPatchSetId, missing);
    pruned += pruneEntitiesForMissingPatchSets(comments.values(), c -> new PatchSet.Id(id, c.key.patchSetId), missing);
    pruned += pruneEntitiesForMissingPatchSets(approvals.values(), PatchSetApproval::getPatchSetId, missing);
    if (!missing.isEmpty()) {
        log.warn("ignoring {} additional entities due to missing patch sets: {}", pruned, missing);
    }
}
#end_block

#method_before
public void fire(Change change, PatchSet patchSet, List<Account> reviewers, Account adder, Timestamp when) {
    if (!listeners.iterator().hasNext() || reviewers.isEmpty()) {
        return;
    }
    try {
        Event event = new Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), Lists.transform(reviewers, util::accountInfo), util.accountInfo(adder), when);
        for (ReviewerAddedListener l : listeners) {
            try {
                l.onReviewersAdded(event);
            } catch (Exception e) {
                util.logEventListenerError(this, l, e);
            }
        }
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException e) {
        log.error("Couldn't fire event", e);
    }
}
#method_after
public void fire(Change change, PatchSet patchSet, List<Account> reviewers, Account adder, Timestamp when) {
    if (!listeners.iterator().hasNext() || reviewers.isEmpty()) {
        return;
    }
    try {
        Event event = new Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), Lists.transform(reviewers, util::accountInfo), util.accountInfo(adder), when);
        for (ReviewerAddedListener l : listeners) {
            try {
                l.onReviewersAdded(event);
            } catch (Exception e) {
                util.logEventListenerError(this, l, e);
            }
        }
    } catch (PatchListObjectTooLargeException e) {
        log.warn("Couldn't fire event: " + e.getMessage());
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException | PermissionBackendException e) {
        log.error("Couldn't fire event", e);
    }
}
#end_block

#method_before
@Override
public List<?> apply(TopLevelResource rsrc) throws BadRequestException, AuthException, OrmException {
    List<List<ChangeInfo>> out;
    try {
        out = query();
    } catch (QueryParseException e) {
        // This is a hack to detect an operator that requires authentication.
        Pattern p = Pattern.compile("^Error in operator (.*:self|is:watched|is:owner|is:reviewer|has:.*)$");
        Matcher m = p.matcher(e.getMessage());
        if (m.matches()) {
            String op = m.group(1);
            throw new AuthException("Must be signed-in to use " + op);
        }
        throw new BadRequestException(e.getMessage(), e);
    }
    return out.size() == 1 ? out.get(0) : out;
}
#method_after
@Override
public List<?> apply(TopLevelResource rsrc) throws BadRequestException, AuthException, OrmException {
    List<List<ChangeInfo>> out;
    try {
        out = query();
    } catch (QueryRequiresAuthException e) {
        throw new AuthException("Must be signed-in to use this operator");
    } catch (QueryParseException e) {
        log.debug("Reject change query with 400 Bad Request: " + queries, e);
        throw new BadRequestException(e.getMessage(), e);
    }
    return out.size() == 1 ? out.get(0) : out;
}
#end_block

#method_before
private List<List<ChangeInfo>> query() throws OrmException, QueryParseException {
    if (imp.isDisabled()) {
        throw new QueryParseException("query disabled");
    }
    if (queries == null || queries.isEmpty()) {
        queries = Collections.singletonList("status:open");
    } else if (queries.size() > 10) {
        // users from submitting too much to the server in a single call.
        throw new QueryParseException("limit of 10 queries");
    }
    int cnt = queries.size();
    List<QueryResult<ChangeData>> results = imp.query(qb.parse(queries));
    boolean requireLazyLoad = containsAnyOf(options, ImmutableSet.of(DETAILED_LABELS, LABELS)) && !qb.getArgs().getSchema().hasField(ChangeField.STORED_SUBMIT_RECORD_LENIENT);
    ChangeJson cjson = json.create(options);
    cjson.setPluginDefinedAttributesFactory(this.imp);
    List<List<ChangeInfo>> res = cjson.lazyLoad(requireLazyLoad || containsAnyOf(options, ChangeJson.REQUIRE_LAZY_LOAD)).formatQueryResults(results);
    for (int n = 0; n < cnt; n++) {
        List<ChangeInfo> info = res.get(n);
        if (results.get(n).more()) {
            info.get(info.size() - 1)._moreChanges = true;
        }
    }
    return res;
}
#method_after
private List<List<ChangeInfo>> query() throws OrmException, QueryParseException {
    if (imp.isDisabled()) {
        throw new QueryParseException("query disabled");
    }
    if (queries == null || queries.isEmpty()) {
        queries = Collections.singletonList("status:open");
    } else if (queries.size() > 10) {
        // users from submitting too much to the server in a single call.
        throw new QueryParseException("limit of 10 queries");
    }
    int cnt = queries.size();
    List<QueryResult<ChangeData>> results = imp.query(qb.parse(queries));
    ChangeJson cjson = json.create(options);
    cjson.setPluginDefinedAttributesFactory(this.imp);
    List<List<ChangeInfo>> res = cjson.lazyLoad(containsAnyOf(options, ChangeJson.REQUIRE_LAZY_LOAD)).formatQueryResults(results);
    for (int n = 0; n < cnt; n++) {
        List<ChangeInfo> info = res.get(n);
        if (results.get(n).more() && !info.isEmpty()) {
            Iterables.getLast(info)._moreChanges = true;
        }
    }
    return res;
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(ChangeResource rsrc) {
    Change change = rsrc.getChange();
    return new UiAction.Description().setLabel("Abandon").setTitle("Abandon the change").setVisible(and(change.getStatus().isOpen() && change.getStatus() != Change.Status.DRAFT, rsrc.permissions().database(dbProvider).testCond(ChangePermission.ABANDON)));
}
#method_after
@Override
public UiAction.Description getDescription(ChangeResource rsrc) {
    Change change = rsrc.getChange();
    return new UiAction.Description().setLabel("Abandon").setTitle("Abandon the change").setVisible(and(change.getStatus().isOpen(), rsrc.permissions().database(dbProvider).testCond(ChangePermission.ABANDON)));
}
#end_block

#method_before
private AccountState makeUser(String name, String email) {
    final Account.Id userId = new Account.Id(42);
    final Account account = new Account(userId, TimeUtil.nowTs());
    account.setFullName(name);
    account.setPreferredEmail(email);
    return new AccountState(new AllUsersName(AllUsersNameProvider.DEFAULT), account, Collections.emptySet(), Collections.emptySet(), new HashMap<>());
}
#method_after
private AccountState makeUser(String name, String email) {
    final Account.Id userId = new Account.Id(42);
    final Account account = new Account(userId, TimeUtil.nowTs());
    account.setFullName(name);
    account.setPreferredEmail(email);
    return new AccountState(new AllUsersName(AllUsersNameProvider.DEFAULT), account, Collections.emptySet(), new HashMap<>());
}
#end_block

#method_before
@Override
public PureRevertInfo apply(ChangeResource rsrc) throws ResourceConflictException, IOException, BadRequestException, OrmException, AuthException {
    PatchSet currentPatchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    if (currentPatchSet == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(currentPatchSet, dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    if (claimedOriginal == null) {
        if (rsrc.getChange().getRevertOf() == null) {
            throw new BadRequestException("no ID was provided and change isn't a revert");
        }
        PatchSet ps = psUtil.current(dbProvider.get(), notesFactory.createChecked(dbProvider.get(), rsrc.getProject(), rsrc.getChange().getRevertOf()));
        claimedOriginal = ps.getRevision().get();
    }
    try (Repository repo = repoManager.openRepository(rsrc.getProject());
        ObjectInserter oi = repo.newObjectInserter();
        RevWalk rw = new RevWalk(repo)) {
        RevCommit claimedOriginalCommit;
        try {
            claimedOriginalCommit = rw.parseCommit(ObjectId.fromString(claimedOriginal));
        } catch (InvalidObjectIdException | MissingObjectException e) {
            throw new BadRequestException("invalid object ID");
        }
        if (claimedOriginalCommit.getParentCount() == 0) {
            throw new BadRequestException("can't check against initial commit");
        }
        RevCommit claimedRevertCommit = rw.parseCommit(ObjectId.fromString(currentPatchSet.getRevision().get()));
        if (claimedRevertCommit.getParentCount() == 0) {
            throw new BadRequestException("claimed revert has no parents");
        }
        // Rebase claimed revert onto claimed original
        ThreeWayMerger merger = mergeUtilFactory.create(projectCache.checkedGet(rsrc.getProject())).newThreeWayMerger(oi, repo.getConfig());
        merger.setBase(claimedRevertCommit.getParent(0));
        merger.merge(claimedRevertCommit, claimedOriginalCommit);
        if (merger.getResultTreeId() == null) {
            // Merge conflict during rebase
            return new PureRevertInfo(false);
        }
        // claimedRevert is not a pure revert but made content changes
        try (DiffFormatter df = new DiffFormatter(new ByteArrayOutputStream())) {
            df.setRepository(repo);
            List<DiffEntry> entries = df.scan(claimedOriginalCommit.getParent(0), merger.getResultTreeId());
            return new PureRevertInfo(entries.isEmpty());
        }
    }
}
#method_after
@Override
public PureRevertInfo apply(ChangeResource rsrc) throws ResourceConflictException, IOException, BadRequestException, OrmException, AuthException {
    PatchSet currentPatchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    if (currentPatchSet == null) {
        throw new ResourceConflictException("current revision is missing");
    }
    return getPureRevert(rsrc.getNotes());
}
#end_block

#method_before
private GroupAsReviewer suggestGroupAsReviewer(SuggestReviewers suggestReviewers, Project project, GroupReference group, VisibilityControl visibilityControl) throws OrmException, IOException {
    GroupAsReviewer result = new GroupAsReviewer();
    int maxAllowed = suggestReviewers.getMaxAllowed();
    int maxAllowedWithoutConfirmation = suggestReviewers.getMaxAllowedWithoutConfirmation();
    if (!PostReviewers.isLegalReviewerGroup(group.getUUID())) {
        return result;
    }
    try {
        Set<Account> members = groupMembersFactory.create(currentUser.get()).listAccounts(group.getUUID(), project.getNameKey());
        if (members.isEmpty()) {
            return result;
        }
        result.size = members.size();
        if (maxAllowed > 0 && result.size > maxAllowed) {
            return result;
        }
        boolean needsConfirmation = result.size > maxAllowedWithoutConfirmation;
        // require that at least one member in the group can see the change
        for (Account account : members) {
            if (visibilityControl.isVisibleTo(account.getId())) {
                if (needsConfirmation) {
                    result.allowedWithConfirmation = true;
                } else {
                    result.allowed = true;
                }
                return result;
            }
        }
    } catch (NoSuchGroupException e) {
        return result;
    } catch (NoSuchProjectException e) {
        return result;
    }
    return result;
}
#method_after
private GroupAsReviewer suggestGroupAsReviewer(SuggestReviewers suggestReviewers, Project project, GroupReference group, VisibilityControl visibilityControl) throws OrmException, IOException {
    GroupAsReviewer result = new GroupAsReviewer();
    int maxAllowed = suggestReviewers.getMaxAllowed();
    int maxAllowedWithoutConfirmation = suggestReviewers.getMaxAllowedWithoutConfirmation();
    if (!PostReviewers.isLegalReviewerGroup(group.getUUID())) {
        return result;
    }
    try {
        Set<Account> members = groupMembers.listAccounts(group.getUUID(), project.getNameKey());
        if (members.isEmpty()) {
            return result;
        }
        result.size = members.size();
        if (maxAllowed > 0 && result.size > maxAllowed) {
            return result;
        }
        boolean needsConfirmation = result.size > maxAllowedWithoutConfirmation;
        // require that at least one member in the group can see the change
        for (Account account : members) {
            if (visibilityControl.isVisibleTo(account.getId())) {
                if (needsConfirmation) {
                    result.allowedWithConfirmation = true;
                } else {
                    result.allowed = true;
                }
                return result;
            }
        }
    } catch (NoSuchGroupException | NoSuchProjectException e) {
        return result;
    }
    return result;
}
#end_block

#method_before
@Override
protected Predicate<AccountGroup> enforceVisibility(Predicate<AccountGroup> pred) {
    return new AndSource<>(pred, new GroupIsVisibleToPredicate(groupControlFactory, userProvider.get()), start);
}
#method_after
@Override
protected Predicate<InternalGroup> enforceVisibility(Predicate<InternalGroup> pred) {
    return new AndSource<>(pred, new GroupIsVisibleToPredicate(groupControlFactory, userProvider.get()), start);
}
#end_block

#method_before
private void updateReference(Repository repository, String refName, ObjectId currentObjectId, ObjectId targetObjectId, Timestamp timestamp) throws IOException {
    RefUpdate ru = repository.updateRef(refName);
    ru.setExpectedOldObjectId(currentObjectId);
    ru.setNewObjectId(targetObjectId);
    ru.setRefLogIdent(getRefLogIdent(timestamp));
    ru.setRefLogMessage("inline edit (amend)", false);
    ru.setForceUpdate(true);
    try (RevWalk revWalk = new RevWalk(repository)) {
        RefUpdate.Result res = ru.update(revWalk);
        if (res != RefUpdate.Result.NEW && res != RefUpdate.Result.FORCED) {
            throw new IOException("update failed: " + ru);
        }
    }
}
#method_after
private void updateReference(Repository repository, String refName, ObjectId currentObjectId, ObjectId targetObjectId, Timestamp timestamp) throws IOException {
    RefUpdate ru = repository.updateRef(refName);
    ru.setExpectedOldObjectId(currentObjectId);
    ru.setNewObjectId(targetObjectId);
    ru.setRefLogIdent(getRefLogIdent(timestamp));
    ru.setRefLogMessage("inline edit (amend)", false);
    ru.setForceUpdate(true);
    try (RevWalk revWalk = new RevWalk(repository)) {
        RefUpdate.Result res = ru.update(revWalk);
        if (res != RefUpdate.Result.NEW && res != RefUpdate.Result.FORCED) {
            throw new IOException("cannot update " + ru.getName() + " in " + repository.getDirectory() + ": " + ru.getResult());
        }
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Create create(ChangeResource parent, IdString id) throws RestApiException {
    return createFactory.create(id.get());
}
#method_after
@Override
public Create create(ChangeResource parent, IdString id) throws RestApiException {
    return createFactory.create(id.get());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Post post(ChangeResource parent) throws RestApiException {
    return post;
}
#method_after
@Override
public Post post(ChangeResource parent) throws RestApiException {
    return post;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public DeleteFile delete(ChangeResource parent, IdString id) throws RestApiException {
    // deleting of change edits and not a file in change edit
    return deleteFileFactory.create(id.get());
}
#method_after
@Override
public DeleteFile delete(ChangeResource parent, IdString id) throws RestApiException {
    // deleting of change edits and not a file in change edit
    return deleteFileFactory.create(id.get());
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, DeleteFile.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, PermissionBackendException {
    return deleteContent.apply(rsrc, path);
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, Input in) throws IOException, AuthException, ResourceConflictException, OrmException, PermissionBackendException {
    return deleteContent.apply(rsrc, path);
}
#end_block

#method_before
@Override
public Response<EditInfo> apply(ChangeResource rsrc) throws AuthException, IOException, ResourceNotFoundException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getNotes(), rsrc.getUser());
    if (!edit.isPresent()) {
        return Response.none();
    }
    EditInfo editInfo = editJson.toEditInfo(edit.get(), downloadCommands);
    if (list) {
        PatchSet basePatchSet = null;
        if (base != null) {
            RevisionResource baseResource = revisions.parse(rsrc, IdString.fromDecoded(base));
            basePatchSet = baseResource.getPatchSet();
        }
        try {
            editInfo.files = fileInfoJson.toFileInfoMap(rsrc.getChange(), edit.get().getEditCommit(), basePatchSet);
        } catch (PatchListNotAvailableException e) {
            throw new ResourceNotFoundException(e.getMessage());
        }
    }
    return Response.ok(editInfo);
}
#method_after
@Override
public Response<EditInfo> apply(ChangeResource rsrc) throws AuthException, IOException, ResourceNotFoundException, OrmException, PermissionBackendException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getNotes(), rsrc.getUser());
    if (!edit.isPresent()) {
        return Response.none();
    }
    EditInfo editInfo = editJson.toEditInfo(edit.get(), downloadCommands);
    if (list) {
        PatchSet basePatchSet = null;
        if (base != null) {
            RevisionResource baseResource = revisions.parse(rsrc, IdString.fromDecoded(base));
            basePatchSet = baseResource.getPatchSet();
        }
        try {
            editInfo.files = fileInfoJson.toFileInfoMap(rsrc.getChange(), edit.get().getEditCommit(), basePatchSet);
        } catch (PatchListNotAvailableException e) {
            throw new ResourceNotFoundException(e.getMessage());
        }
    }
    return Response.ok(editInfo);
}
#end_block

#method_before
public Response<?> apply(ChangeResource rsrc, String filePath) throws AuthException, IOException, OrmException, ResourceConflictException, PermissionBackendException {
    try (Repository repository = repositoryManager.openRepository(rsrc.getProject())) {
        editModifier.deleteFile(repository, rsrc.getNotes(), filePath);
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException, PermissionBackendException {
    return apply(rsrc.getChangeResource(), rsrc.getPath());
}
#end_block

#method_before
@Override
public Response<BinaryResult> apply(ChangeEditResource rsrc) throws IOException {
    try {
        ChangeEdit edit = rsrc.getChangeEdit();
        return Response.ok(fileContentUtil.getContent(rsrc.getChangeResource().getControl().getProjectControl().getProjectState(), base ? ObjectId.fromString(edit.getBasePatchSet().getRevision().get()) : edit.getEditCommit(), rsrc.getPath(), null));
    } catch (ResourceNotFoundException | BadRequestException e) {
        return Response.none();
    }
}
#method_after
@Override
public Response<BinaryResult> apply(ChangeEditResource rsrc) throws IOException {
    try {
        ChangeEdit edit = rsrc.getChangeEdit();
        return Response.ok(fileContentUtil.getContent(projectCache.checkedGet(rsrc.getChangeResource().getProject()), base ? ObjectId.fromString(edit.getBasePatchSet().getRevision().get()) : edit.getEditCommit(), rsrc.getPath(), null));
    } catch (ResourceNotFoundException | BadRequestException e) {
        return Response.none();
    }
}
#end_block

#method_before
protected static List<Predicate<ChangeData>> predicates(ProjectCache projectCache, Provider<ListChildProjects> listChildProjects, Provider<CurrentUser> self, String value) {
    ProjectState projectState = projectCache.get(new Project.NameKey(value));
    if (projectState == null) {
        return Collections.emptyList();
    }
    List<Predicate<ChangeData>> r = new ArrayList<>();
    r.add(new ProjectPredicate(projectState.getName()));
    try {
        ProjectResource proj = new ProjectResource(projectState.controlFor(self.get()));
        ListChildProjects children = listChildProjects.get();
        children.setRecursive(true);
        for (ProjectInfo p : children.apply(proj)) {
            r.add(new ProjectPredicate(p.name));
        }
    } catch (PermissionBackendException e) {
        log.warn("cannot check permissions to expand child projects", e);
    }
    return r;
}
#method_after
protected static List<Predicate<ChangeData>> predicates(ProjectCache projectCache, Provider<ListChildProjects> listChildProjects, Provider<CurrentUser> self, String value) {
    ProjectState projectState = projectCache.get(new Project.NameKey(value));
    if (projectState == null) {
        return Collections.emptyList();
    }
    List<Predicate<ChangeData>> r = new ArrayList<>();
    r.add(new ProjectPredicate(projectState.getName()));
    try {
        ProjectResource proj = new ProjectResource(projectState, self.get());
        ListChildProjects children = listChildProjects.get();
        children.setRecursive(true);
        for (ProjectInfo p : children.apply(proj)) {
            r.add(new ProjectPredicate(p.name));
        }
    } catch (PermissionBackendException e) {
        log.warn("cannot check permissions to expand child projects", e);
    }
    return r;
}
#end_block

#method_before
@Test
public void createSchema_Label_CodeReview() throws Exception {
    LabelType codeReview = getLabelTypes().byLabel("Code-Review");
    assertThat(codeReview).isNotNull();
    assertThat(codeReview.getName()).isEqualTo("Code-Review");
    assertThat(codeReview.getDefaultValue()).isEqualTo(0);
    assertThat(codeReview.getFunctionName()).isEqualTo("MaxWithBlock");
    assertThat(codeReview.isCopyMinScore()).isTrue();
    assertValueRange(codeReview, 2, 1, 0, -1, -2);
}
#method_after
@Test
public void createSchema_Label_CodeReview() throws Exception {
    LabelType codeReview = getLabelTypes().byLabel("Code-Review");
    assertThat(codeReview).isNotNull();
    assertThat(codeReview.getName()).isEqualTo("Code-Review");
    assertThat(codeReview.getDefaultValue()).isEqualTo(0);
    assertThat(codeReview.getFunction()).isEqualTo(LabelFunction.MAX_WITH_BLOCK);
    assertThat(codeReview.isCopyMinScore()).isTrue();
    assertValueRange(codeReview, 2, 1, 0, -1, -2);
}
#end_block

#method_before
@Override
public Response<?> apply(RevisionResource resource) throws AuthException, BadRequestException, ResourceNotFoundException, OrmException, RepositoryNotFoundException, IOException, PatchListNotAvailableException {
    checkOptions();
    if (reviewed) {
        return Response.ok(reviewed(resource));
    } else if (query != null) {
        return Response.ok(query(resource));
    }
    Response<Map<String, FileInfo>> r;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getChangeResource(), IdString.fromDecoded(base));
        r = Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet().getRevision(), baseResource.getPatchSet()));
    } else if (parentNum > 0) {
        r = Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet().getRevision(), parentNum - 1));
    } else {
        r = Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet()));
    }
    if (resource.isCacheable()) {
        r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
    }
    return r;
}
#method_after
@Override
public Response<?> apply(RevisionResource resource) throws AuthException, BadRequestException, ResourceNotFoundException, OrmException, RepositoryNotFoundException, IOException, PatchListNotAvailableException, PermissionBackendException {
    checkOptions();
    if (reviewed) {
        return Response.ok(reviewed(resource));
    } else if (query != null) {
        return Response.ok(query(resource));
    }
    Response<Map<String, FileInfo>> r;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getChangeResource(), IdString.fromDecoded(base));
        r = Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet().getRevision(), baseResource.getPatchSet()));
    } else if (parentNum > 0) {
        r = Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet().getRevision(), parentNum - 1));
    } else {
        r = Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet()));
    }
    if (resource.isCacheable()) {
        r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
    }
    return r;
}
#end_block

#method_before
private Collection<String> reviewed(RevisionResource resource) throws AuthException, OrmException {
    CurrentUser user = self.get();
    if (!(user.isIdentifiedUser())) {
        throw new AuthException("Authentication required");
    }
    Account.Id userId = user.getAccountId();
    PatchSet patchSetId = resource.getPatchSet();
    Optional<PatchSetWithReviewedFiles> o = accountPatchReviewStore.get().findReviewed(patchSetId.getId(), userId);
    if (o.isPresent()) {
        PatchSetWithReviewedFiles res = o.get();
        if (res.patchSetId().equals(patchSetId.getId())) {
            return res.files();
        }
        try {
            return copy(res.files(), res.patchSetId(), resource, userId);
        } catch (IOException | PatchListNotAvailableException e) {
            log.warn("Cannot copy patch review flags", e);
        }
    }
    return Collections.emptyList();
}
#method_after
private Collection<String> reviewed(RevisionResource resource) throws AuthException, OrmException {
    CurrentUser user = self.get();
    if (!(user.isIdentifiedUser())) {
        throw new AuthException("Authentication required");
    }
    Account.Id userId = user.getAccountId();
    PatchSet patchSetId = resource.getPatchSet();
    Optional<PatchSetWithReviewedFiles> o = accountPatchReviewStore.get().findReviewed(patchSetId.getId(), userId);
    if (o.isPresent()) {
        PatchSetWithReviewedFiles res = o.get();
        if (res.patchSetId().equals(patchSetId.getId())) {
            return res.files();
        }
        try {
            return copy(res.files(), res.patchSetId(), resource, userId);
        } catch (PatchListObjectTooLargeException e) {
            log.warn("Cannot copy patch review flags: " + e.getMessage());
        } catch (IOException | PatchListNotAvailableException e) {
            log.warn("Cannot copy patch review flags", e);
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
protected ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, RevisionResource rsrc, RebaseInput input) throws EmailException, OrmException, UpdateException, RestApiException, IOException, NoSuchChangeException, PermissionBackendException {
    rsrc.permissions().database(dbProvider).check(ChangePermission.REBASE);
    ChangeControl control = rsrc.getControl();
    Change change = rsrc.getChange();
    try (Repository repo = repoManager.openRepository(change.getProject());
        ObjectInserter oi = repo.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader);
        BatchUpdate bu = updateFactory.create(dbProvider.get(), change.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        if (!change.getStatus().isOpen()) {
            throw new ResourceConflictException("change is " + ChangeUtil.status(change));
        } else if (!hasOneParent(rw, rsrc.getPatchSet())) {
            throw new ResourceConflictException("cannot rebase merge commits or commit with no ancestor");
        }
        bu.setRepository(repo, rw, oi);
        bu.addOp(change.getId(), rebaseFactory.create(control, rsrc.getPatchSet(), findBaseRev(repo, rw, rsrc, input)).setForceContentMerge(true).setFireRevisionCreated(true));
        bu.execute();
    }
    return json.create(OPTIONS).format(change.getProject(), change.getId());
}
#method_after
@Override
protected ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, RevisionResource rsrc, RebaseInput input) throws EmailException, OrmException, UpdateException, RestApiException, IOException, NoSuchChangeException, PermissionBackendException {
    rsrc.permissions().database(dbProvider).check(ChangePermission.REBASE);
    Change change = rsrc.getChange();
    try (Repository repo = repoManager.openRepository(change.getProject());
        ObjectInserter oi = repo.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader);
        BatchUpdate bu = updateFactory.create(dbProvider.get(), change.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        if (!change.getStatus().isOpen()) {
            throw new ResourceConflictException("change is " + ChangeUtil.status(change));
        } else if (!hasOneParent(rw, rsrc.getPatchSet())) {
            throw new ResourceConflictException("cannot rebase merge commits or commit with no ancestor");
        }
        bu.setRepository(repo, rw, oi);
        bu.addOp(change.getId(), rebaseFactory.create(rsrc.getNotes(), rsrc.getPatchSet(), findBaseRev(repo, rw, rsrc, input)).setForceContentMerge(true).setFireRevisionCreated(true));
        bu.execute();
    }
    return json.create(OPTIONS).format(change.getProject(), change.getId());
}
#end_block

#method_before
private ObjectId findBaseRev(Repository repo, RevWalk rw, RevisionResource rsrc, RebaseInput input) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    Branch.NameKey destRefKey = rsrc.getChange().getDest();
    if (input == null || input.base == null) {
        return rebaseUtil.findBaseRevision(rsrc.getPatchSet(), destRefKey, repo, rw);
    }
    Change change = rsrc.getChange();
    String str = input.base.trim();
    if (str.equals("")) {
        // Remove existing dependency to other patch set.
        Ref destRef = repo.exactRef(destRefKey.get());
        if (destRef == null) {
            throw new ResourceConflictException("can't rebase onto tip of branch " + destRefKey.get() + "; branch doesn't exist");
        }
        return destRef.getObjectId();
    }
    @SuppressWarnings("resource")
    ReviewDb db = dbProvider.get();
    Base base = rebaseUtil.parseBase(rsrc, str);
    if (base == null) {
        throw new ResourceConflictException("base revision is missing: " + str);
    }
    PatchSet.Id baseId = base.patchSet().getId();
    if (!base.control().isPatchVisible(base.patchSet(), db)) {
        throw new AuthException("base revision not accessible: " + str);
    } else if (change.getId().equals(baseId.getParentKey())) {
        throw new ResourceConflictException("cannot rebase change onto itself");
    }
    Change baseChange = base.control().getChange();
    if (!baseChange.getProject().equals(change.getProject())) {
        throw new ResourceConflictException("base change is in wrong project: " + baseChange.getProject());
    } else if (!baseChange.getDest().equals(change.getDest())) {
        throw new ResourceConflictException("base change is targeting wrong branch: " + baseChange.getDest());
    } else if (baseChange.getStatus() == Status.ABANDONED) {
        throw new ResourceConflictException("base change is abandoned: " + baseChange.getKey());
    } else if (isMergedInto(rw, rsrc.getPatchSet(), base.patchSet())) {
        throw new ResourceConflictException("base change " + baseChange.getKey() + " is a descendant of the current change - recursion not allowed");
    }
    return ObjectId.fromString(base.patchSet().getRevision().get());
}
#method_after
private ObjectId findBaseRev(Repository repo, RevWalk rw, RevisionResource rsrc, RebaseInput input) throws RestApiException, OrmException, IOException, NoSuchChangeException, AuthException, PermissionBackendException {
    Branch.NameKey destRefKey = rsrc.getChange().getDest();
    if (input == null || input.base == null) {
        return rebaseUtil.findBaseRevision(rsrc.getPatchSet(), destRefKey, repo, rw);
    }
    Change change = rsrc.getChange();
    String str = input.base.trim();
    if (str.equals("")) {
        // Remove existing dependency to other patch set.
        Ref destRef = repo.exactRef(destRefKey.get());
        if (destRef == null) {
            throw new ResourceConflictException("can't rebase onto tip of branch " + destRefKey.get() + "; branch doesn't exist");
        }
        return destRef.getObjectId();
    }
    Base base = rebaseUtil.parseBase(rsrc, str);
    if (base == null) {
        throw new ResourceConflictException("base revision is missing: " + str);
    }
    PatchSet.Id baseId = base.patchSet().getId();
    if (change.getId().equals(baseId.getParentKey())) {
        throw new ResourceConflictException("cannot rebase change onto itself");
    }
    permissionBackend.user(rsrc.getUser()).database(dbProvider).change(base.notes()).check(ChangePermission.READ);
    Change baseChange = base.notes().getChange();
    if (!baseChange.getProject().equals(change.getProject())) {
        throw new ResourceConflictException("base change is in wrong project: " + baseChange.getProject());
    } else if (!baseChange.getDest().equals(change.getDest())) {
        throw new ResourceConflictException("base change is targeting wrong branch: " + baseChange.getDest());
    } else if (baseChange.getStatus() == Status.ABANDONED) {
        throw new ResourceConflictException("base change is abandoned: " + baseChange.getKey());
    } else if (isMergedInto(rw, rsrc.getPatchSet(), base.patchSet())) {
        throw new ResourceConflictException("base change " + baseChange.getKey() + " is a descendant of the current change - recursion not allowed");
    }
    return ObjectId.fromString(base.patchSet().getRevision().get());
}
#end_block

#method_before
@Override
protected ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, RebaseInput input) throws EmailException, OrmException, UpdateException, RestApiException, IOException, PermissionBackendException {
    PatchSet ps = psUtil.current(rebase.dbProvider.get(), rsrc.getNotes());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(ps, rebase.dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    return rebase.applyImpl(updateFactory, new RevisionResource(rsrc, ps), input);
}
#method_after
@Override
protected ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, RebaseInput input) throws EmailException, OrmException, UpdateException, RestApiException, IOException, PermissionBackendException {
    PatchSet ps = psUtil.current(rebase.dbProvider.get(), rsrc.getNotes());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    }
    return rebase.applyImpl(updateFactory, new RevisionResource(rsrc, ps), input);
}
#end_block

#method_before
@Override
protected void configure() {
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), CONFIG_KIND);
    DynamicMap.mapOf(binder(), TASK_KIND);
    DynamicMap.mapOf(binder(), TOP_MENU_KIND);
    child(CONFIG_KIND, "capabilities").to(CapabilitiesCollection.class);
    child(CONFIG_KIND, "tasks").to(TasksCollection.class);
    get(TASK_KIND).to(GetTask.class);
    delete(TASK_KIND).to(DeleteTask.class);
    child(CONFIG_KIND, "top-menus").to(TopMenuCollection.class);
    get(CONFIG_KIND, "version").to(GetVersion.class);
    get(CONFIG_KIND, "info").to(GetServerInfo.class);
    post(CONFIG_KIND, "check.consistency").to(CheckConsistency.class);
    post(CONFIG_KIND, "check.access").to(CheckAccess.class);
    get(CONFIG_KIND, "preferences").to(GetPreferences.class);
    put(CONFIG_KIND, "preferences").to(SetPreferences.class);
    get(CONFIG_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(CONFIG_KIND, "preferences.diff").to(SetDiffPreferences.class);
    put(CONFIG_KIND, "email.confirm").to(ConfirmEmail.class);
}
#method_after
@Override
protected void configure() {
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), CONFIG_KIND);
    DynamicMap.mapOf(binder(), TASK_KIND);
    DynamicMap.mapOf(binder(), TOP_MENU_KIND);
    child(CONFIG_KIND, "capabilities").to(CapabilitiesCollection.class);
    child(CONFIG_KIND, "tasks").to(TasksCollection.class);
    get(TASK_KIND).to(GetTask.class);
    delete(TASK_KIND).to(DeleteTask.class);
    child(CONFIG_KIND, "top-menus").to(TopMenuCollection.class);
    get(CONFIG_KIND, "version").to(GetVersion.class);
    get(CONFIG_KIND, "info").to(GetServerInfo.class);
    post(CONFIG_KIND, "check.consistency").to(CheckConsistency.class);
    get(CONFIG_KIND, "preferences").to(GetPreferences.class);
    put(CONFIG_KIND, "preferences").to(SetPreferences.class);
    get(CONFIG_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(CONFIG_KIND, "preferences.diff").to(SetDiffPreferences.class);
    put(CONFIG_KIND, "email.confirm").to(ConfirmEmail.class);
}
#end_block

#method_before
protected static MailMessage.Builder newMailMessageBuilder() {
    MailMessage.Builder b = MailMessage.builder();
    b.id("id");
    b.from(new Address("Foo Bar", "foo@bar.com"));
    b.dateReceived(new DateTime());
    b.subject("");
    return b;
}
#method_after
protected static MailMessage.Builder newMailMessageBuilder() {
    MailMessage.Builder b = MailMessage.builder();
    b.id("id");
    b.from(new Address("Foo Bar", "foo@bar.com"));
    b.dateReceived(Instant.now());
    b.subject("");
    return b;
}
#end_block

#method_before
public void addPatchSetFileNames(PatchSetAttribute patchSetAttribute, Change change, PatchSet patchSet) {
    try {
        PatchList patchList = patchListCache.get(change, patchSet);
        for (PatchListEntry patch : patchList.getPatches()) {
            if (patchSetAttribute.files == null) {
                patchSetAttribute.files = new ArrayList<>();
            }
            PatchAttribute p = new PatchAttribute();
            p.file = patch.getNewName();
            p.fileOld = patch.getOldName();
            p.type = patch.getChangeType();
            p.deletions -= patch.getDeletions();
            p.insertions = patch.getInsertions();
            patchSetAttribute.files.add(p);
        }
    } catch (PatchListNotAvailableException e) {
        log.warn("Cannot get patch list", e);
    }
}
#method_after
public void addPatchSetFileNames(PatchSetAttribute patchSetAttribute, Change change, PatchSet patchSet) {
    try {
        PatchList patchList = patchListCache.get(change, patchSet);
        for (PatchListEntry patch : patchList.getPatches()) {
            if (patchSetAttribute.files == null) {
                patchSetAttribute.files = new ArrayList<>();
            }
            PatchAttribute p = new PatchAttribute();
            p.file = patch.getNewName();
            p.fileOld = patch.getOldName();
            p.type = patch.getChangeType();
            p.deletions -= patch.getDeletions();
            p.insertions = patch.getInsertions();
            patchSetAttribute.files.add(p);
        }
    } catch (PatchListObjectTooLargeException e) {
        log.warn("Cannot get patch list: " + e.getMessage());
    } catch (PatchListNotAvailableException e) {
        log.warn("Cannot get patch list", e);
    }
}
#end_block

#method_before
public PatchSetAttribute asPatchSetAttribute(ReviewDb db, RevWalk revWalk, Change change, PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = patchSet.getPatchSetId();
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    p.isDraft = patchSet.isDraft();
    PatchSet.Id pId = patchSet.getId();
    try {
        p.parents = new ArrayList<>();
        RevCommit c = revWalk.parseCommit(ObjectId.fromString(p.revision));
        for (RevCommit parent : c.getParents()) {
            p.parents.add(parent.name());
        }
        UserIdentity author = toUserIdentity(c.getAuthorIdent());
        if (author.getAccount() == null) {
            p.author = new AccountAttribute();
            p.author.email = author.getEmail();
            p.author.name = author.getName();
            p.author.username = "";
        } else {
            p.author = asAccountAttribute(author.getAccount());
        }
        List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
        for (Patch pe : list) {
            if (!Patch.isMagic(pe.getFileName())) {
                p.sizeDeletions -= pe.getDeletions();
                p.sizeInsertions += pe.getInsertions();
            }
        }
        p.kind = changeKindCache.getChangeKind(db, change, patchSet);
    } catch (IOException | OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#method_after
public PatchSetAttribute asPatchSetAttribute(ReviewDb db, RevWalk revWalk, Change change, PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = patchSet.getPatchSetId();
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    PatchSet.Id pId = patchSet.getId();
    try {
        p.parents = new ArrayList<>();
        RevCommit c = revWalk.parseCommit(ObjectId.fromString(p.revision));
        for (RevCommit parent : c.getParents()) {
            p.parents.add(parent.name());
        }
        UserIdentity author = toUserIdentity(c.getAuthorIdent());
        if (author.getAccount() == null) {
            p.author = new AccountAttribute();
            p.author.email = author.getEmail();
            p.author.name = author.getName();
            p.author.username = "";
        } else {
            p.author = asAccountAttribute(author.getAccount());
        }
        List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
        for (Patch pe : list) {
            if (!Patch.isMagic(pe.getFileName())) {
                p.sizeDeletions -= pe.getDeletions();
                p.sizeInsertions += pe.getInsertions();
            }
        }
        p.kind = changeKindCache.getChangeKind(db, change, patchSet);
    } catch (IOException | OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchListObjectTooLargeException e) {
        log.warn(String.format("Cannot get size information for %s: %s", pId, e.getMessage()));
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#end_block

#method_before
@Override
public String changeClosed(ChangeReportFormatter.Input input) {
    return String.format("change %s closed", ChangeUtil.formatChangeUrl(canonicalWebUrl, input.getChange()));
}
#method_after
@Override
public String changeClosed(ChangeReportFormatter.Input input) {
    return String.format("change %s closed", ChangeUtil.formatChangeUrl(canonicalWebUrl, input.change()));
}
#end_block

#method_before
private String formatChangeUrl(String url, Input input) {
    StringBuilder m = new StringBuilder().append("  ").append(ChangeUtil.formatChangeUrl(url, input.getChange())).append(" ").append(ChangeUtil.cropSubject(input.getSubject()));
    if (input.isDraft()) {
        m.append(" [DRAFT]");
    }
    if (input.isEdit()) {
        m.append(" [EDIT]");
    }
    if (input.isPrivate()) {
        m.append(" [PRIVATE]");
    }
    if (input.isWorkInProgress()) {
        m.append(" [WIP]");
    }
    return m.toString();
}
#method_after
private String formatChangeUrl(String url, Input input) {
    StringBuilder m = new StringBuilder().append("  ").append(ChangeUtil.formatChangeUrl(url, input.change())).append(" ").append(ChangeUtil.cropSubject(input.subject()));
    if (input.isEdit()) {
        m.append(" [EDIT]");
    }
    if (input.isPrivate()) {
        m.append(" [PRIVATE]");
    }
    if (input.isWorkInProgress()) {
        m.append(" [WIP]");
    }
    return m.toString();
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(PARENT_GROUPS_NAME, AccountGroup.UUID.class, new TypeLiteral<ImmutableList<AccountGroup.UUID>>() {
            }).loader(ParentGroupsLoader.class);
            cache(SUBGROUPS_NAME, AccountGroup.UUID.class, new TypeLiteral<ImmutableList<AccountGroup.UUID>>() {
            }).loader(SubgroupsLoader.class);
            cache(EXTERNAL_NAME, String.class, new TypeLiteral<ImmutableList<AccountGroup.UUID>>() {
            }).loader(AllExternalLoader.class);
            bind(GroupIncludeCacheImpl.class);
            bind(GroupIncludeCache.class).to(GroupIncludeCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(GROUPS_WITH_MEMBER_NAME, Account.Id.class, new TypeLiteral<ImmutableSet<AccountGroup.UUID>>() {
            }).loader(GroupsWithMemberLoader.class);
            cache(PARENT_GROUPS_NAME, AccountGroup.UUID.class, new TypeLiteral<ImmutableList<AccountGroup.UUID>>() {
            }).loader(ParentGroupsLoader.class);
            cache(EXTERNAL_NAME, String.class, new TypeLiteral<ImmutableList<AccountGroup.UUID>>() {
            }).loader(AllExternalLoader.class);
            bind(GroupIncludeCacheImpl.class);
            bind(GroupIncludeCache.class).to(GroupIncludeCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Override
public ImmutableList<AccountGroup.UUID> load(AccountGroup.UUID key) throws OrmException {
    try (ReviewDb db = schema.open()) {
        return groups.getParentGroups(db, key).map(groupCache::get).map(AccountGroup::getGroupUUID).filter(Objects::nonNull).collect(toImmutableList());
    }
}
#method_after
@Override
public ImmutableList<AccountGroup.UUID> load(AccountGroup.UUID key) throws OrmException {
    if (groupIndexProvider.get().getSchema().hasField(GroupField.SUBGROUP)) {
        return groupQueryProvider.get().bySubgroup(key).stream().map(InternalGroup::getGroupUUID).collect(toImmutableList());
    }
    try (ReviewDb db = schema.open()) {
        return Groups.getParentGroupsFromReviewDb(db, key).map(groupCache::get).flatMap(Streams::stream).map(InternalGroup::getGroupUUID).collect(toImmutableList());
    }
}
#end_block

#method_before
@Override
default Predicate<AccountGroup> keyPredicate(AccountGroup.UUID uuid) {
    return GroupPredicates.uuid(uuid);
}
#method_after
@Override
default Predicate<InternalGroup> keyPredicate(AccountGroup.UUID uuid) {
    return GroupPredicates.uuid(uuid);
}
#end_block

#method_before
public void publish(BatchUpdate.Factory updateFactory, ChangeControl ctl, final ChangeEdit edit, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws IOException, OrmException, RestApiException, UpdateException {
    Change change = edit.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject());
        ObjectInserter oi = repo.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        PatchSet basePatchSet = edit.getBasePatchSet();
        if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
            throw new ResourceConflictException("only edit for current patch set can be published");
        }
        RevCommit squashed = squashEdit(rw, oi, edit.getEditCommit(), basePatchSet);
        PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(ctl.getNotes(), psId, squashed).setNotify(notify).setAccountsToNotify(accountsToNotify);
        StringBuilder message = new StringBuilder("Patch Set ").append(inserter.getPatchSetId().get()).append(": ");
        // Previously checked that the base patch set is the current patch set.
        ObjectId prior = ObjectId.fromString(basePatchSet.getRevision().get());
        ChangeKind kind = changeKindCache.getChangeKind(change.getProject(), rw, repo.getConfig(), prior, squashed);
        if (kind == ChangeKind.NO_CODE_CHANGE) {
            message.append("Commit message was updated.");
            inserter.setDescription("Edit commit message");
        } else {
            message.append("Published edit on patch set ").append(basePatchSet.getPatchSetId()).append(".");
        }
        try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), ctl.getUser(), TimeUtil.nowTs())) {
            bu.setRepository(repo, rw, oi);
            bu.addOp(change.getId(), inserter.setDraft(change.getStatus() == Status.DRAFT || basePatchSet.isDraft()).setMessage(message.toString()));
            bu.addOp(change.getId(), new BatchUpdateOp() {

                @Override
                public void updateRepo(RepoContext ctx) throws Exception {
                    ctx.addRefUpdate(edit.getEditCommit().copy(), ObjectId.zeroId(), edit.getRefName());
                }
            });
            bu.execute();
        }
    }
}
#method_after
public void publish(BatchUpdate.Factory updateFactory, ChangeNotes notes, CurrentUser user, final ChangeEdit edit, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws IOException, OrmException, RestApiException, UpdateException {
    Change change = edit.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject());
        ObjectInserter oi = repo.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        PatchSet basePatchSet = edit.getBasePatchSet();
        if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
            throw new ResourceConflictException("only edit for current patch set can be published");
        }
        RevCommit squashed = squashEdit(rw, oi, edit.getEditCommit(), basePatchSet);
        PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(notes, psId, squashed).setNotify(notify).setAccountsToNotify(accountsToNotify);
        StringBuilder message = new StringBuilder("Patch Set ").append(inserter.getPatchSetId().get()).append(": ");
        // Previously checked that the base patch set is the current patch set.
        ObjectId prior = ObjectId.fromString(basePatchSet.getRevision().get());
        ChangeKind kind = changeKindCache.getChangeKind(change.getProject(), rw, repo.getConfig(), prior, squashed);
        if (kind == ChangeKind.NO_CODE_CHANGE) {
            message.append("Commit message was updated.");
            inserter.setDescription("Edit commit message");
        } else {
            message.append("Published edit on patch set ").append(basePatchSet.getPatchSetId()).append(".");
        }
        try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), user, TimeUtil.nowTs())) {
            bu.setRepository(repo, rw, oi);
            bu.addOp(change.getId(), inserter.setMessage(message.toString()));
            bu.addOp(change.getId(), new BatchUpdateOp() {

                @Override
                public void updateRepo(RepoContext ctx) throws Exception {
                    ctx.addRefUpdate(edit.getEditCommit().copy(), ObjectId.zeroId(), edit.getRefName());
                }
            });
            bu.execute();
        }
    }
}
#end_block

#method_before
@Override
public Response<EditInfo> apply(FixResource fixResource, Void nothing) throws AuthException, OrmException, ResourceConflictException, IOException, ResourceNotFoundException, PermissionBackendException {
    RevisionResource revisionResource = fixResource.getRevisionResource();
    Project.NameKey project = revisionResource.getProject();
    ProjectState projectState = revisionResource.getControl().getProjectControl().getProjectState();
    PatchSet patchSet = revisionResource.getPatchSet();
    ObjectId patchSetCommitId = ObjectId.fromString(patchSet.getRevision().get());
    try (Repository repository = gitRepositoryManager.openRepository(project)) {
        List<TreeModification> treeModifications = fixReplacementInterpreter.toTreeModifications(repository, projectState, patchSetCommitId, fixResource.getFixReplacements());
        ChangeEdit changeEdit = changeEditModifier.combineWithModifiedPatchSetTree(repository, revisionResource.getNotes(), patchSet, treeModifications);
        return Response.ok(changeEditJson.toEditInfo(changeEdit, false));
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
@Override
public Response<EditInfo> apply(FixResource fixResource, Void nothing) throws AuthException, OrmException, ResourceConflictException, IOException, ResourceNotFoundException, PermissionBackendException {
    RevisionResource revisionResource = fixResource.getRevisionResource();
    Project.NameKey project = revisionResource.getProject();
    ProjectState projectState = projectCache.checkedGet(project);
    PatchSet patchSet = revisionResource.getPatchSet();
    ObjectId patchSetCommitId = ObjectId.fromString(patchSet.getRevision().get());
    try (Repository repository = gitRepositoryManager.openRepository(project)) {
        List<TreeModification> treeModifications = fixReplacementInterpreter.toTreeModifications(repository, projectState, patchSetCommitId, fixResource.getFixReplacements());
        ChangeEdit changeEdit = changeEditModifier.combineWithModifiedPatchSetTree(repository, revisionResource.getNotes(), patchSet, treeModifications);
        return Response.ok(changeEditJson.toEditInfo(changeEdit, false));
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
private void createDefaultGroups(ReviewDb db) throws OrmException, IOException {
    admin = newGroup(db, "Administrators");
    admin.setDescription("Gerrit Site Administrators");
    GroupsUpdate.addNewGroup(db, admin);
    index(admin);
    batch = newGroup(db, "Non-Interactive Users");
    batch.setDescription("Users who perform batch actions on Gerrit");
    batch.setOwnerGroupUUID(admin.getGroupUUID());
    GroupsUpdate.addNewGroup(db, batch);
    index(batch);
}
#method_after
private void createDefaultGroups(ReviewDb db) throws OrmException, IOException {
    admin = newGroup(db, "Administrators");
    admin.setDescription("Gerrit Site Administrators");
    GroupsUpdate.addNewGroup(db, admin);
    index(InternalGroup.create(admin, ImmutableSet.of(), ImmutableSet.of()));
    batch = newGroup(db, "Non-Interactive Users");
    batch.setDescription("Users who perform batch actions on Gerrit");
    batch.setOwnerGroupUUID(admin.getGroupUUID());
    GroupsUpdate.addNewGroup(db, batch);
    index(InternalGroup.create(batch, ImmutableSet.of(), ImmutableSet.of()));
}
#end_block

#method_before
private void index(AccountGroup group) throws IOException {
    for (GroupIndex groupIndex : indexCollection.getWriteIndexes()) {
        groupIndex.replace(group);
    }
}
#method_after
private void index(InternalGroup group) throws IOException {
    for (GroupIndex groupIndex : indexCollection.getWriteIndexes()) {
        groupIndex.replace(group);
    }
}
#end_block

#method_before
@Override
public MailMessage expectedMailMessage() {
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114da7ae26e2eb053fe0c29c@google.com>").from(new Address("Jonathan Nieder (Gerrit)", "noreply-gerritcodereview-CtTy0igsBrnvL7dKoWEIEg@google.com")).addTo(new Address("ekempin", "ekempin@google.com")).textContent(textContent).subject("\uD83D\uDE1B test").dateReceived(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC));
    return expect.build();
}
#method_after
@Override
public MailMessage expectedMailMessage() {
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114da7ae26e2eb053fe0c29c@google.com>").from(new Address("Jonathan Nieder (Gerrit)", "noreply-gerritcodereview-CtTy0igsBrnvL7dKoWEIEg@google.com")).addTo(new Address("ekempin", "ekempin@google.com")).textContent(textContent).subject("\uD83D\uDE1B test").dateReceived(LocalDateTime.of(2016, Month.OCTOBER, 25, 9, 11, 35).atOffset(ZoneOffset.UTC).toInstant());
    return expect.build();
}
#end_block

#method_before
@Override
public int parseArguments(Parameters params) throws CmdLineException {
    String token = params.getParameter(0);
    Account.Id accountId;
    try {
        Account a = accountResolver.find(db.get(), token);
        if (a != null) {
            accountId = a.getId();
        } else {
            switch(authType) {
                case HTTP_LDAP:
                case CLIENT_SSL_CERT_LDAP:
                case LDAP:
                    accountId = createAccountByLdap(token);
                    break;
                case CUSTOM_EXTENSION:
                case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                case HTTP:
                case LDAP_BIND:
                case OAUTH:
                case OPENID:
                case OPENID_SSO:
                default:
                    throw new CmdLineException(owner, "user \"" + token + "\" not found");
            }
        }
    } catch (OrmException e) {
        throw new CmdLineException(owner, "database is down");
    } catch (IOException e) {
        throw new CmdLineException(owner, "Failed to load account", e);
    } catch (ConfigInvalidException e) {
        throw new CmdLineException(owner, "Invalid account config", e);
    }
    setter.addValue(accountId);
    return 1;
}
#method_after
@Override
public int parseArguments(Parameters params) throws CmdLineException {
    String token = params.getParameter(0);
    Account.Id accountId;
    try {
        Account a = accountResolver.find(token);
        if (a != null) {
            accountId = a.getId();
        } else {
            switch(authType) {
                case HTTP_LDAP:
                case CLIENT_SSL_CERT_LDAP:
                case LDAP:
                    accountId = createAccountByLdap(token);
                    break;
                case CUSTOM_EXTENSION:
                case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                case HTTP:
                case LDAP_BIND:
                case OAUTH:
                case OPENID:
                case OPENID_SSO:
                default:
                    throw new CmdLineException(owner, "user \"" + token + "\" not found");
            }
        }
    } catch (OrmException e) {
        throw new CmdLineException(owner, "database is down");
    } catch (IOException e) {
        throw new CmdLineException(owner, "Failed to load account", e);
    } catch (ConfigInvalidException e) {
        throw new CmdLineException(owner, "Invalid account config", e);
    }
    setter.addValue(accountId);
    return 1;
}
#end_block

#method_before
@Override
public String apply(ProjectResource rsrc, Input input) throws AuthException, ResourceNotFoundException, BadRequestException, UnprocessableEntityException, IOException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("restricted to project owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.ref)) {
        throw new BadRequestException("ref required");
    }
    String ref = RefNames.fullName(input.ref);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        Map<String, Ref> cur = repo.getRefDatabase().exactRef(Constants.HEAD, ref);
        if (!cur.containsKey(ref)) {
            throw new UnprocessableEntityException(String.format("Ref Not Found: %s", ref));
        }
        final String oldHead = cur.get(Constants.HEAD).getTarget().getName();
        final String newHead = ref;
        if (!oldHead.equals(newHead)) {
            final RefUpdate u = repo.updateRef(Constants.HEAD, true);
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            RefUpdate.Result res = u.link(newHead);
            switch(res) {
                case NO_CHANGE:
                case RENAMED:
                case FORCED:
                case NEW:
                    break;
                case FAST_FORWARD:
                case IO_FAILURE:
                case LOCK_FAILURE:
                case NOT_ATTEMPTED:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case REJECTED_MISSING_OBJECT:
                case REJECTED_OTHER_REASON:
                default:
                    throw new IOException("Setting HEAD failed with " + res);
            }
            fire(rsrc.getNameKey(), oldHead, newHead);
        }
        return ref;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
}
#method_after
@Override
public String apply(ProjectResource rsrc, HeadInput input) throws AuthException, ResourceNotFoundException, BadRequestException, UnprocessableEntityException, IOException, PermissionBackendException {
    if (input == null || Strings.isNullOrEmpty(input.ref)) {
        throw new BadRequestException("ref required");
    }
    String ref = RefNames.fullName(input.ref);
    permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey()).ref(ref).check(RefPermission.SET_HEAD);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        Map<String, Ref> cur = repo.getRefDatabase().exactRef(Constants.HEAD, ref);
        if (!cur.containsKey(ref)) {
            throw new UnprocessableEntityException(String.format("Ref Not Found: %s", ref));
        }
        final String oldHead = cur.get(Constants.HEAD).getTarget().getName();
        final String newHead = ref;
        if (!oldHead.equals(newHead)) {
            final RefUpdate u = repo.updateRef(Constants.HEAD, true);
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            RefUpdate.Result res = u.link(newHead);
            switch(res) {
                case NO_CHANGE:
                case RENAMED:
                case FORCED:
                case NEW:
                    break;
                case FAST_FORWARD:
                case IO_FAILURE:
                case LOCK_FAILURE:
                case NOT_ATTEMPTED:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case REJECTED_MISSING_OBJECT:
                case REJECTED_OTHER_REASON:
                default:
                    throw new IOException("Setting HEAD failed with " + res);
            }
            fire(rsrc.getNameKey(), oldHead, newHead);
        }
        return ref;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
}
#end_block

#method_before
public void evict(Project project) {
    projectCache.evict(project);
    controls.remove(project.getNameKey());
}
#method_after
public void evict(Project project) throws IOException {
    projectCache.evict(project);
    controls.remove(project.getNameKey());
}
#end_block

#method_before
protected static Predicate<ChangeData> forState(Arguments args, Account.Id id, ReviewerStateInternal state) {
    checkArgument(state != ReviewerStateInternal.REMOVED, "can't query by removed reviewer");
    return create(args, new ReviewerPredicate(state, id));
}
#method_after
protected static Predicate<ChangeData> forState(Account.Id id, ReviewerStateInternal state) {
    checkArgument(state != ReviewerStateInternal.REMOVED, "can't query by removed reviewer");
    return new ReviewerPredicate(state, id);
}
#end_block

#method_before
protected static Predicate<ChangeData> reviewer(Arguments args, Account.Id id) {
    Predicate<ChangeData> p;
    if (args.notesMigration.readChanges()) {
        // With NoteDb, Reviewer/CC are clearly distinct states, so only choose reviewer.
        p = new ReviewerPredicate(ReviewerStateInternal.REVIEWER, id);
    } else {
        // Without NoteDb, Reviewer/CC are a bit unpredictable; maintain the old behavior of matching
        // any reviewer state.
        p = anyReviewerState(id);
    }
    return create(args, p);
}
#method_after
protected static Predicate<ChangeData> reviewer(Arguments args, Account.Id id) {
    if (args.notesMigration.readChanges()) {
        // With NoteDb, Reviewer/CC are clearly distinct states, so only choose reviewer.
        return new ReviewerPredicate(ReviewerStateInternal.REVIEWER, id);
    }
    // any reviewer state.
    return anyReviewerState(id);
}
#end_block

#method_before
protected static Predicate<ChangeData> cc(Arguments args, Account.Id id) {
    // it out.
    return create(args, new ReviewerPredicate(ReviewerStateInternal.CC, id));
}
#method_after
protected static Predicate<ChangeData> cc(Account.Id id) {
    // it out.
    return new ReviewerPredicate(ReviewerStateInternal.CC, id);
}
#end_block

#method_before
@Option(name = "--project", aliases = { "-p" }, usage = "projects for which the groups should be listed")
public void addProject(ProjectControl project) {
    projects.add(project);
}
#method_after
@Option(name = "--project", aliases = { "-p" }, usage = "projects for which the groups should be listed")
public void addProject(ProjectState project) {
    projects.add(project);
}
#end_block

#method_before
public List<ProjectControl> getProjects() {
    return projects;
}
#method_after
public List<ProjectState> getProjects() {
    return projects;
}
#end_block

#method_before
@Override
public SortedMap<String, GroupInfo> apply(TopLevelResource resource) throws OrmException, BadRequestException {
    SortedMap<String, GroupInfo> output = new TreeMap<>();
    for (GroupInfo info : get()) {
        output.put(MoreObjects.firstNonNull(info.name, "Group " + Url.decode(info.id)), info);
        info.name = null;
    }
    return output;
}
#method_after
@Override
public SortedMap<String, GroupInfo> apply(TopLevelResource resource) throws OrmException, RestApiException {
    SortedMap<String, GroupInfo> output = new TreeMap<>();
    for (GroupInfo info : get()) {
        output.put(MoreObjects.firstNonNull(info.name, "Group " + Url.decode(info.id)), info);
        info.name = null;
    }
    return output;
}
#end_block

#method_before
public List<GroupInfo> get() throws OrmException, BadRequestException {
    if (!Strings.isNullOrEmpty(suggest)) {
        return suggestGroups();
    }
    if (!Strings.isNullOrEmpty(matchSubstring) && !Strings.isNullOrEmpty(matchRegex)) {
        throw new BadRequestException("Specify one of m/r");
    }
    if (owned) {
        return getGroupsOwnedBy(user != null ? userFactory.create(user) : identifiedUser.get());
    }
    if (user != null) {
        return accountGetGroups.apply(new AccountResource(userFactory.create(user)));
    }
    return getAllGroups();
}
#method_after
public List<GroupInfo> get() throws OrmException, RestApiException {
    if (!Strings.isNullOrEmpty(suggest)) {
        return suggestGroups();
    }
    if (!Strings.isNullOrEmpty(matchSubstring) && !Strings.isNullOrEmpty(matchRegex)) {
        throw new BadRequestException("Specify one of m/r");
    }
    if (ownedBy != null) {
        return getGroupsOwnedBy(ownedBy);
    }
    if (owned) {
        return getGroupsOwnedBy(user != null ? userFactory.create(user) : identifiedUser.get());
    }
    if (user != null) {
        return accountGetGroups.apply(new AccountResource(userFactory.create(user)));
    }
    return getAllGroups();
}
#end_block

#method_before
private List<GroupInfo> getAllGroups() throws OrmException {
    List<GroupInfo> groupInfos;
    List<AccountGroup> groupList;
    if (!projects.isEmpty()) {
        Map<AccountGroup.UUID, AccountGroup> groups = new HashMap<>();
        for (ProjectControl projectControl : projects) {
            final Set<GroupReference> groupsRefs = projectControl.getAllGroups();
            for (GroupReference groupRef : groupsRefs) {
                final AccountGroup group = groupCache.get(groupRef.getUUID());
                if (group != null) {
                    groups.put(group.getGroupUUID(), group);
                }
            }
        }
        groupList = filterGroups(groups.values());
    } else {
        groupList = filterGroups(groupCache.all());
    }
    groupInfos = Lists.newArrayListWithCapacity(groupList.size());
    int found = 0;
    int foundIndex = 0;
    for (AccountGroup group : groupList) {
        if (foundIndex++ < start) {
            continue;
        }
        if (limit > 0 && ++found > limit) {
            break;
        }
        groupInfos.add(json.addOptions(options).format(GroupDescriptions.forAccountGroup(group)));
    }
    return groupInfos;
}
#method_after
private List<GroupInfo> getAllGroups() throws OrmException {
    Pattern pattern = getRegexPattern();
    Stream<GroupDescription.Internal> existingGroups = getAllExistingGroups().filter(group -> !isNotRelevant(pattern, group)).sorted(GROUP_COMPARATOR).skip(start);
    if (limit > 0) {
        existingGroups = existingGroups.limit(limit);
    }
    List<GroupDescription.Internal> relevantGroups = existingGroups.collect(toImmutableList());
    List<GroupInfo> groupInfos = Lists.newArrayListWithCapacity(relevantGroups.size());
    for (GroupDescription.Internal group : relevantGroups) {
        groupInfos.add(json.addOptions(options).format(group));
    }
    return groupInfos;
}
#end_block

#method_before
private List<GroupInfo> suggestGroups() throws OrmException, BadRequestException {
    if (conflictingSuggestParameters()) {
        throw new BadRequestException("You should only have no more than one --project and -n with --suggest");
    }
    List<GroupReference> groupRefs = Lists.newArrayList(Iterables.limit(groupBackend.suggest(suggest, projects.stream().findFirst().map(pc -> pc.getProjectState()).orElse(null)), limit <= 0 ? 10 : Math.min(limit, 10)));
    List<GroupInfo> groupInfos = Lists.newArrayListWithCapacity(groupRefs.size());
    for (GroupReference ref : groupRefs) {
        GroupDescription.Basic desc = groupBackend.get(ref.getUUID());
        if (desc != null) {
            groupInfos.add(json.addOptions(options).format(desc));
        }
    }
    return groupInfos;
}
#method_after
private List<GroupInfo> suggestGroups() throws OrmException, BadRequestException {
    if (conflictingSuggestParameters()) {
        throw new BadRequestException("You should only have no more than one --project and -n with --suggest");
    }
    List<GroupReference> groupRefs = Lists.newArrayList(Iterables.limit(groupBackend.suggest(suggest, projects.stream().findFirst().orElse(null)), limit <= 0 ? 10 : Math.min(limit, 10)));
    List<GroupInfo> groupInfos = Lists.newArrayListWithCapacity(groupRefs.size());
    for (GroupReference ref : groupRefs) {
        GroupDescription.Basic desc = groupBackend.get(ref.getUUID());
        if (desc != null) {
            groupInfos.add(json.addOptions(options).format(desc));
        }
    }
    return groupInfos;
}
#end_block

#method_before
private boolean conflictingSuggestParameters() {
    if (Strings.isNullOrEmpty(suggest)) {
        return false;
    }
    if (projects.size() > 1) {
        return true;
    }
    if (visibleToAll) {
        return true;
    }
    if (user != null) {
        return true;
    }
    if (owned) {
        return true;
    }
    if (start != 0) {
        return true;
    }
    if (!groupsToInspect.isEmpty()) {
        return true;
    }
    if (!Strings.isNullOrEmpty(matchSubstring)) {
        return true;
    }
    if (!Strings.isNullOrEmpty(matchRegex)) {
        return true;
    }
    return false;
}
#method_after
private boolean conflictingSuggestParameters() {
    if (Strings.isNullOrEmpty(suggest)) {
        return false;
    }
    if (projects.size() > 1) {
        return true;
    }
    if (visibleToAll) {
        return true;
    }
    if (user != null) {
        return true;
    }
    if (owned) {
        return true;
    }
    if (ownedBy != null) {
        return true;
    }
    if (start != 0) {
        return true;
    }
    if (!groupsToInspect.isEmpty()) {
        return true;
    }
    if (!Strings.isNullOrEmpty(matchSubstring)) {
        return true;
    }
    if (!Strings.isNullOrEmpty(matchRegex)) {
        return true;
    }
    return false;
}
#end_block

#method_before
private List<GroupInfo> getGroupsOwnedBy(IdentifiedUser user) throws OrmException {
    List<GroupInfo> groups = new ArrayList<>();
    int found = 0;
    int foundIndex = 0;
    for (AccountGroup g : filterGroups(groupCache.all())) {
        GroupControl ctl = groupControlFactory.controlFor(g);
        try {
            if (genericGroupControlFactory.controlFor(user, g.getGroupUUID()).isOwner()) {
                if (foundIndex++ < start) {
                    continue;
                }
                if (limit > 0 && ++found > limit) {
                    break;
                }
                groups.add(json.addOptions(options).format(ctl.getGroup()));
            }
        } catch (NoSuchGroupException e) {
            continue;
        }
    }
    return groups;
}
#method_after
private List<GroupInfo> getGroupsOwnedBy(String id) throws OrmException, RestApiException {
    String uuid = groupsCollection.parse(id).getGroupUUID().get();
    return filterGroupsOwnedBy(group -> group.getOwnerGroupUUID().get().equals(uuid));
}
#end_block

#method_before
private List<GroupInfo> getGroupsOwnedBy(IdentifiedUser user) throws OrmException {
    List<GroupInfo> groups = new ArrayList<>();
    int found = 0;
    int foundIndex = 0;
    for (AccountGroup g : filterGroups(groupCache.all())) {
        GroupControl ctl = groupControlFactory.controlFor(g);
        try {
            if (genericGroupControlFactory.controlFor(user, g.getGroupUUID()).isOwner()) {
                if (foundIndex++ < start) {
                    continue;
                }
                if (limit > 0 && ++found > limit) {
                    break;
                }
                groups.add(json.addOptions(options).format(ctl.getGroup()));
            }
        } catch (NoSuchGroupException e) {
            continue;
        }
    }
    return groups;
}
#method_after
private List<GroupInfo> getGroupsOwnedBy(IdentifiedUser user) throws OrmException {
    return filterGroupsOwnedBy(group -> isOwner(user, group));
}
#end_block

#method_before
private void deliverToMembers(Watchers.List matching, AccountGroup.UUID startUUID) throws OrmException {
    ReviewDb db = args.db.get();
    Set<AccountGroup.UUID> seen = new HashSet<>();
    List<AccountGroup.UUID> q = new ArrayList<>();
    seen.add(startUUID);
    q.add(startUUID);
    while (!q.isEmpty()) {
        AccountGroup.UUID uuid = q.remove(q.size() - 1);
        GroupDescription.Basic group = args.groupBackend.get(uuid);
        if (group == null) {
            continue;
        }
        if (!Strings.isNullOrEmpty(group.getEmailAddress())) {
            // If the group has an email address, do not expand membership.
            matching.emails.add(new Address(group.getEmailAddress()));
            continue;
        }
        if (!(group instanceof GroupDescription.Internal)) {
            // Non-internal groups cannot be expanded by the server.
            continue;
        }
        GroupDescription.Internal ig = (GroupDescription.Internal) group;
        try {
            args.groups.getMembers(db, ig.getGroupUUID()).forEach(matching.accounts::add);
        } catch (NoSuchGroupException e) {
            continue;
        }
        for (AccountGroup.UUID m : args.groupIncludes.subgroupsOf(uuid)) {
            if (seen.add(m)) {
                q.add(m);
            }
        }
    }
}
#method_after
private void deliverToMembers(Watchers.List matching, AccountGroup.UUID startUUID) {
    Set<AccountGroup.UUID> seen = new HashSet<>();
    List<AccountGroup.UUID> q = new ArrayList<>();
    seen.add(startUUID);
    q.add(startUUID);
    while (!q.isEmpty()) {
        AccountGroup.UUID uuid = q.remove(q.size() - 1);
        GroupDescription.Basic group = args.groupBackend.get(uuid);
        if (group == null) {
            continue;
        }
        if (!Strings.isNullOrEmpty(group.getEmailAddress())) {
            // If the group has an email address, do not expand membership.
            matching.emails.add(new Address(group.getEmailAddress()));
            continue;
        }
        if (!(group instanceof GroupDescription.Internal)) {
            // Non-internal groups cannot be expanded by the server.
            continue;
        }
        GroupDescription.Internal ig = (GroupDescription.Internal) group;
        matching.accounts.addAll(ig.getMembers());
        for (AccountGroup.UUID m : ig.getSubgroups()) {
            if (seen.add(m)) {
                q.add(m);
            }
        }
    }
}
#end_block

#method_before
@Override
public Predicate<AccountGroup> rewrite(Predicate<AccountGroup> in, QueryOptions opts) throws QueryParseException {
    GroupIndex index = indexes.getSearchIndex();
    checkNotNull(index, "no active search index configured for groups");
    return new IndexedGroupQuery(index, in, opts);
}
#method_after
@Override
public Predicate<InternalGroup> rewrite(Predicate<InternalGroup> in, QueryOptions opts) throws QueryParseException {
    GroupIndex index = indexes.getSearchIndex();
    checkNotNull(index, "no active search index configured for groups");
    return new IndexedGroupQuery(index, in, opts);
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws Exception {
    commit = ctx.getRevWalk().parseCommit(commitId);
    ctx.getRevWalk().parseBody(commit);
    changeKind = changeKindCache.getChangeKind(projectControl.getProject().getNameKey(), ctx.getRevWalk(), ctx.getRepoView().getConfig(), priorCommitId, commitId);
    if (checkMergedInto) {
        String mergedInto = findMergedInto(ctx, dest.get(), commit);
        if (mergedInto != null) {
            mergedByPushOp = mergedByPushOpFactory.create(requestScopePropagator, patchSetId, mergedInto);
        }
    }
    cmd = new ReceiveCommand(ObjectId.zeroId(), commitId, patchSetId.toRefName());
    ctx.addRefUpdate(cmd);
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws Exception {
    commit = ctx.getRevWalk().parseCommit(commitId);
    ctx.getRevWalk().parseBody(commit);
    changeKind = changeKindCache.getChangeKind(projectState.getNameKey(), ctx.getRevWalk(), ctx.getRepoView().getConfig(), priorCommitId, commitId);
    if (checkMergedInto) {
        String mergedInto = findMergedInto(ctx, dest.get(), commit);
        if (mergedInto != null) {
            mergedByPushOp = mergedByPushOpFactory.create(requestScopePropagator, patchSetId, mergedInto);
        }
    }
    cmd = new ReceiveCommand(ObjectId.zeroId(), commitId, patchSetId.toRefName());
    ctx.addRefUpdate(cmd);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, PermissionBackendException {
    notes = ctx.getNotes();
    Change change = notes.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), notes);
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    String psDescription = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        psDescription = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
        if (magicBranch.removePrivate) {
            change.setPrivate(false);
            update.setPrivate(false);
        } else if (magicBranch.isPrivate) {
            change.setPrivate(true);
            update.setPrivate(true);
        }
        if (magicBranch.ready) {
            change.setWorkInProgress(false);
            change.setReviewStarted(true);
            update.setWorkInProgress(false);
        } else if (magicBranch.workInProgress) {
            change.setWorkInProgress(true);
            update.setWorkInProgress(true);
        }
        if (shouldPublishComments()) {
            boolean workInProgress = change.isWorkInProgress();
            if (magicBranch != null && magicBranch.workInProgress) {
                workInProgress = true;
            }
            comments = publishComments(ctx, workInProgress);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    if (change.getStatus() == Change.Status.DRAFT && !draft) {
        update.setStatus(Change.Status.NEW);
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commitId, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null, psDescription);
    update.setPsDescription(psDescription);
    recipients.add(getRecipientsFromFooters(ctx.getDb(), accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovalsForNewPatchSet(ctx.getDb(), update, projectControl.getProjectState().getLabelTypes(), newPatchSet, ctx.getUser(), approvals);
    approvalCopier.copyInReviewDb(ctx.getDb(), ctx.getNotes(), ctx.getUser(), newPatchSet, ctx.getRevWalk(), ctx.getRepoView().getConfig(), newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getProjectState().getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    // reviewer which is needed in several other code paths.
    if (magicBranch != null && !magicBranch.labels.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    recipients.add(oldRecipients);
    msg = createChangeMessage(ctx, reviewMessage);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, PermissionBackendException {
    notes = ctx.getNotes();
    Change change = notes.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), notes);
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    String psDescription = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        psDescription = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
        if (magicBranch.removePrivate) {
            change.setPrivate(false);
            update.setPrivate(false);
        } else if (magicBranch.isPrivate) {
            change.setPrivate(true);
            update.setPrivate(true);
        }
        if (magicBranch.ready) {
            change.setWorkInProgress(false);
            change.setReviewStarted(true);
            update.setWorkInProgress(false);
        } else if (magicBranch.workInProgress) {
            change.setWorkInProgress(true);
            update.setWorkInProgress(true);
        }
        if (shouldPublishComments()) {
            boolean workInProgress = change.isWorkInProgress();
            if (magicBranch != null && magicBranch.workInProgress) {
                workInProgress = true;
            }
            comments = publishComments(ctx, workInProgress);
        }
    }
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commitId, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null, psDescription);
    update.setPsDescription(psDescription);
    recipients.add(getRecipientsFromFooters(accountResolver, commit.getFooterLines()));
    recipients.remove(ctx.getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getNotes());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    Iterable<PatchSetApproval> newApprovals = approvalsUtil.addApprovalsForNewPatchSet(ctx.getDb(), update, projectState.getLabelTypes(), newPatchSet, ctx.getUser(), approvals);
    approvalCopier.copyInReviewDb(ctx.getDb(), ctx.getNotes(), ctx.getUser(), newPatchSet, ctx.getRevWalk(), ctx.getRepoView().getConfig(), newApprovals);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectState.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    // reviewer which is needed in several other code paths.
    if (magicBranch != null && !magicBranch.labels.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    recipients.add(oldRecipients);
    msg = createChangeMessage(ctx, reviewMessage);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedByPushOp == null) {
        resetChange(ctx);
    } else {
        mergedByPushOp.setPatchSetProvider(Providers.of(newPatchSet)).updateChange(ctx);
    }
    return true;
}
#end_block

#method_before
private Map<String, PatchSetApproval> scanLabels(ChangeContext ctx, Map<String, Short> approvals) throws OrmException, IOException {
    Map<String, PatchSetApproval> current = new HashMap<>();
    // We optimize here and only retrieve current when approvals provided
    if (!approvals.isEmpty()) {
        for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctx.getNotes(), ctx.getUser(), priorPatchSetId, ctx.getAccountId(), ctx.getRevWalk(), ctx.getRepoView().getConfig())) {
            if (a.isLegacySubmit()) {
                continue;
            }
            LabelType lt = projectControl.getProjectState().getLabelTypes().byLabel(a.getLabelId());
            if (lt != null) {
                current.put(lt.getName(), a);
            }
        }
    }
    return current;
}
#method_after
private Map<String, PatchSetApproval> scanLabels(ChangeContext ctx, Map<String, Short> approvals) throws OrmException, IOException {
    Map<String, PatchSetApproval> current = new HashMap<>();
    // We optimize here and only retrieve current when approvals provided
    if (!approvals.isEmpty()) {
        for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctx.getNotes(), ctx.getUser(), priorPatchSetId, ctx.getAccountId(), ctx.getRevWalk(), ctx.getRepoView().getConfig())) {
            if (a.isLegacySubmit()) {
                continue;
            }
            LabelType lt = projectState.getLabelTypes().byLabel(a.getLabelId());
            if (lt != null) {
                current.put(lt.getName(), a);
            }
        }
    }
    return current;
}
#end_block

#method_before
private void resetChange(ChangeContext ctx) {
    Change change = ctx.getChange();
    if (!change.currentPatchSetId().equals(priorPatchSetId)) {
        return;
    }
    if (magicBranch != null && magicBranch.topic != null) {
        change.setTopic(magicBranch.topic);
    }
    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
    // Leave in draft status.
    } else {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(info);
    List<String> idList = commit.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        change.setKey(new Change.Key("I" + commitId.name()));
    } else {
        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
    }
}
#method_after
private void resetChange(ChangeContext ctx) {
    Change change = ctx.getChange();
    if (!change.currentPatchSetId().equals(priorPatchSetId)) {
        return;
    }
    if (magicBranch != null && magicBranch.topic != null) {
        change.setTopic(magicBranch.topic);
    }
    change.setStatus(Change.Status.NEW);
    change.setCurrentPatchSet(info);
    List<String> idList = commit.getFooterLines(CHANGE_ID);
    if (idList.isEmpty()) {
        change.setKey(new Change.Key("I" + commitId.name()));
    } else {
        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
    }
}
#end_block

#method_before
@Override
public void run() {
    try {
        ReplacePatchSetSender cm = replacePatchSetFactory.create(projectControl.getProject().getNameKey(), notes.getChangeId());
        cm.setFrom(ctx.getAccount().getId());
        cm.setPatchSet(newPatchSet, info);
        cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
        if (magicBranch != null) {
            cm.setNotify(magicBranch.getNotify(notes));
            cm.setAccountsToNotify(magicBranch.getAccountsToNotify());
        }
        cm.addReviewers(recipients.getReviewers());
        cm.addExtraCC(recipients.getCcOnly());
        cm.send();
    } catch (Exception e) {
        log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
    }
}
#method_after
@Override
public void run() {
    try {
        ReplacePatchSetSender cm = replacePatchSetFactory.create(projectState.getNameKey(), notes.getChangeId());
        cm.setFrom(ctx.getAccount().getId());
        cm.setPatchSet(newPatchSet, info);
        cm.setChangeMessage(msg.getMessage(), ctx.getWhen());
        if (magicBranch != null) {
            cm.setNotify(magicBranch.getNotify(notes));
            cm.setAccountsToNotify(magicBranch.getAccountsToNotify());
        }
        cm.addReviewers(recipients.getReviewers());
        cm.addExtraCC(recipients.getCcOnly());
        cm.send();
    } catch (Exception e) {
        log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
    }
}
#end_block

#method_before
private void assertMail(MailMessage have, MailMessage want) {
    assertThat(have.id()).isEqualTo(want.id());
    assertThat(have.to()).isEqualTo(want.to());
    assertThat(have.from()).isEqualTo(want.from());
    assertThat(have.cc()).isEqualTo(want.cc());
    assertThat(have.dateReceived().getMillis()).isEqualTo(want.dateReceived().getMillis());
    assertThat(have.additionalHeaders()).isEqualTo(want.additionalHeaders());
    assertThat(have.subject()).isEqualTo(want.subject());
    assertThat(have.textContent()).isEqualTo(want.textContent());
    assertThat(have.htmlContent()).isEqualTo(want.htmlContent());
}
#method_after
private void assertMail(MailMessage have, MailMessage want) {
    assertThat(have.id()).isEqualTo(want.id());
    assertThat(have.to()).isEqualTo(want.to());
    assertThat(have.from()).isEqualTo(want.from());
    assertThat(have.cc()).isEqualTo(want.cc());
    assertThat(have.dateReceived()).isEqualTo(want.dateReceived());
    assertThat(have.additionalHeaders()).isEqualTo(want.additionalHeaders());
    assertThat(have.subject()).isEqualTo(want.subject());
    assertThat(have.textContent()).isEqualTo(want.textContent());
    assertThat(have.htmlContent()).isEqualTo(want.htmlContent());
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    try {
        deleteBranch.apply(resource(), new DeleteBranch.Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot delete branch", e);
    }
}
#method_after
@Override
public void delete() throws RestApiException {
    try {
        deleteBranch.apply(resource(), new Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot delete branch", e);
    }
}
#end_block

#method_before
@Test
public void parsePatchSetState() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1 (PUBLISHED)\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Subject: Some subject of a change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1 (DRAFT)\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Subject: Some subject of a change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1 (DELETED)\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Subject: Some subject of a change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1 (NOT A STATUS)\n" + "Branch: refs/heads/master\n" + "Subject: Some subject of a change\n");
}
#method_after
@Test
public void parsePatchSetState() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1 (PUBLISHED)\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Subject: Some subject of a change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1 (DRAFT)\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Subject: Some subject of a change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1 (DELETED)\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Subject: Some subject of a change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1 (NOT A STATUS)\n" + "Branch: refs/heads/master\n" + "Subject: Some subject of a change\n");
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public CreateGroup create(TopLevelResource root, IdString name) {
    return createGroup.create(name.get());
}
#method_after
@Override
public CreateGroup create(TopLevelResource root, IdString name) {
    return createGroup.create(name.get());
}
#end_block

#method_before
@Override
public ChildProjectResource parse(ProjectResource parent, IdString id) throws ResourceNotFoundException, IOException, PermissionBackendException {
    ProjectResource p = projectsCollection.parse(TopLevelResource.INSTANCE, id);
    for (ProjectState pp : p.getControl().getProjectState().parents()) {
        if (parent.getNameKey().equals(pp.getProject().getNameKey())) {
            return new ChildProjectResource(parent, p.getProjectState());
        }
    }
    throw new ResourceNotFoundException(id);
}
#method_after
@Override
public ChildProjectResource parse(ProjectResource parent, IdString id) throws ResourceNotFoundException, IOException, PermissionBackendException {
    ProjectResource p = projectsCollection.parse(TopLevelResource.INSTANCE, id);
    for (ProjectState pp : p.getProjectState().parents()) {
        if (parent.getNameKey().equals(pp.getProject().getNameKey())) {
            return new ChildProjectResource(parent, p.getProjectState());
        }
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public RestModifyView<AccountResource, EmptyInput> create(AccountResource parent, IdString id) throws UnprocessableEntityException {
    try {
        return createProvider.get().setChange(changes.parse(TopLevelResource.INSTANCE, id));
    } catch (ResourceNotFoundException e) {
        throw new UnprocessableEntityException(String.format("change %s not found", id.get()));
    } catch (OrmException | PermissionBackendException e) {
        log.error("cannot resolve change", e);
        throw new UnprocessableEntityException("internal server error");
    }
}
#method_after
@Override
public RestModifyView<AccountResource, EmptyInput> create(AccountResource parent, IdString id) throws UnprocessableEntityException {
    try {
        return createProvider.get().setChange(changes.parse(TopLevelResource.INSTANCE, id));
    } catch (ResourceNotFoundException e) {
        throw new UnprocessableEntityException(String.format("change %s not found", id.get()));
    } catch (OrmException | PermissionBackendException e) {
        log.error("cannot resolve change", e);
        throw new UnprocessableEntityException("internal server error");
    }
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource rsrc, EmptyInput in) throws AuthException, OrmException, IOException {
    if (self.get() != rsrc.getUser()) {
        throw new AuthException("not allowed to add starred change");
    }
    try {
        starredChangesUtil.star(self.get().getAccountId(), change.getProject(), change.getId(), StarredChangesUtil.DEFAULT_LABELS, null);
    } catch (OrmDuplicateKeyException e) {
        return Response.none();
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource rsrc, EmptyInput in) throws RestApiException, OrmException, IOException {
    if (self.get() != rsrc.getUser()) {
        throw new AuthException("not allowed to add starred change");
    }
    try {
        starredChangesUtil.star(self.get().getAccountId(), change.getProject(), change.getId(), StarredChangesUtil.DEFAULT_LABELS, null);
    } catch (MutuallyExclusiveLabelsException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (IllegalLabelException e) {
        throw new BadRequestException(e.getMessage());
    } catch (OrmDuplicateKeyException e) {
        return Response.none();
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource.StarredChange rsrc, EmptyInput in) throws AuthException, OrmException, IOException {
    if (self.get() != rsrc.getUser()) {
        throw new AuthException("not allowed remove starred change");
    }
    starredChangesUtil.star(self.get().getAccountId(), rsrc.getChange().getProject(), rsrc.getChange().getId(), null, StarredChangesUtil.DEFAULT_LABELS);
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource.StarredChange rsrc, EmptyInput in) throws AuthException, OrmException, IOException, IllegalLabelException {
    if (self.get() != rsrc.getUser()) {
        throw new AuthException("not allowed remove starred change");
    }
    starredChangesUtil.star(self.get().getAccountId(), rsrc.getChange().getProject(), rsrc.getChange().getId(), null, StarredChangesUtil.DEFAULT_LABELS);
    return Response.none();
}
#end_block

#method_before
@Override
public boolean containsAnyOf(Iterable<AccountGroup.UUID> queryIds) {
    // Prefer lookup of a cached result over expanding includes.
    boolean tryExpanding = false;
    for (AccountGroup.UUID id : queryIds) {
        Boolean b = memberOf.get(id);
        if (b == null) {
            tryExpanding = true;
        } else if (b) {
            return true;
        }
    }
    if (tryExpanding) {
        for (AccountGroup.UUID id : queryIds) {
            if (memberOf.containsKey(id)) {
                // Membership was earlier proven to be false.
                continue;
            }
            memberOf.put(id, false);
            AccountGroup group = groupCache.get(id);
            if (group == null) {
                continue;
            }
            if (search(includeCache.subgroupsOf(id))) {
                memberOf.put(id, true);
                return true;
            }
        }
    }
    return false;
}
#method_after
@Override
public boolean containsAnyOf(Iterable<AccountGroup.UUID> queryIds) {
    // Prefer lookup of a cached result over expanding includes.
    boolean tryExpanding = false;
    for (AccountGroup.UUID id : queryIds) {
        Boolean b = memberOf.get(id);
        if (b == null) {
            tryExpanding = true;
        } else if (b) {
            return true;
        }
    }
    if (tryExpanding) {
        for (AccountGroup.UUID id : queryIds) {
            if (memberOf.containsKey(id)) {
                // Membership was earlier proven to be false.
                continue;
            }
            memberOf.put(id, false);
            Optional<InternalGroup> group = groupCache.get(id);
            if (!group.isPresent()) {
                continue;
            }
            if (group.get().getMembers().contains(user.getAccountId())) {
                memberOf.put(id, true);
                return true;
            }
            if (search(group.get().getSubgroups())) {
                memberOf.put(id, true);
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
private ImmutableSet<AccountGroup.UUID> computeKnownGroups() {
    GroupMembership membership = user.getEffectiveGroups();
    Set<AccountGroup.UUID> direct = user.state().getInternalGroups();
    Set<AccountGroup.UUID> r = Sets.newHashSet(direct);
    r.remove(null);
    List<AccountGroup.UUID> q = Lists.newArrayList(r);
    for (AccountGroup.UUID g : membership.intersection(includeCache.allExternalMembers())) {
        if (g != null && r.add(g)) {
            q.add(g);
        }
    }
    while (!q.isEmpty()) {
        AccountGroup.UUID id = q.remove(q.size() - 1);
        for (AccountGroup.UUID g : includeCache.parentGroupsOf(id)) {
            if (g != null && r.add(g)) {
                q.add(g);
                memberOf.put(g, true);
            }
        }
    }
    return ImmutableSet.copyOf(r);
}
#method_after
private ImmutableSet<AccountGroup.UUID> computeKnownGroups() {
    GroupMembership membership = user.getEffectiveGroups();
    Collection<AccountGroup.UUID> direct = includeCache.getGroupsWithMember(user.getAccountId());
    direct.forEach(groupUuid -> memberOf.put(groupUuid, true));
    Set<AccountGroup.UUID> r = Sets.newHashSet(direct);
    r.remove(null);
    List<AccountGroup.UUID> q = Lists.newArrayList(r);
    for (AccountGroup.UUID g : membership.intersection(includeCache.allExternalMembers())) {
        if (g != null && r.add(g)) {
            q.add(g);
        }
    }
    while (!q.isEmpty()) {
        AccountGroup.UUID id = q.remove(q.size() - 1);
        for (AccountGroup.UUID g : includeCache.parentGroupsOf(id)) {
            if (g != null && r.add(g)) {
                q.add(g);
                memberOf.put(g, true);
            }
        }
    }
    return ImmutableSet.copyOf(r);
}
#end_block

#method_before
public Change.Id cherryPick(BatchUpdate.Factory batchUpdateFactory, @Nullable Change sourceChange, @Nullable PatchSet.Id sourcePatchId, Project.NameKey project, ObjectId sourceCommit, CherryPickInput input, Branch.NameKey dest) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException, ConfigInvalidException, NoSuchProjectException {
    IdentifiedUser identifiedUser = user.get();
    try (Repository git = gitManager.openRepository(project);
        // before patch sets are updated.
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(reader)) {
        Ref destRef = git.getRefDatabase().exactRef(dest.get());
        if (destRef == null) {
            throw new InvalidChangeOperationException(String.format("Branch %s does not exist.", dest.get()));
        }
        RevCommit baseCommit = getBaseCommit(destRef, project.get(), revWalk, input.base);
        CodeReviewCommit commitToCherryPick = revWalk.parseCommit(sourceCommit);
        if (input.parent <= 0 || input.parent > commitToCherryPick.getParentCount()) {
            throw new InvalidChangeOperationException(String.format("Cherry Pick: Parent %s does not exist. Please specify a parent in" + " range [1, %s].", input.parent, commitToCherryPick.getParentCount()));
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = identifiedUser.newCommitterIdent(now, serverTimeZone);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), baseCommit, commitToCherryPick.getAuthorIdent(), committerIdent, input.message);
        String commitMessage = ChangeIdUtil.insertId(input.message, computedChangeId).trim() + '\n';
        CodeReviewCommit cherryPickCommit;
        ProjectControl projectControl = projectControlFactory.controlFor(dest.getParentKey(), identifiedUser);
        try {
            ProjectState projectState = projectControl.getProjectState();
            cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(oi, git.getConfig(), baseCommit, commitToCherryPick, committerIdent, commitMessage, revWalk, input.parent - 1, false);
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            Branch.NameKey newDest = new Branch.NameKey(project, destRef.getName());
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " reside on the same branch. " + "Cannot create a new patch set.");
            }
            try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), project, identifiedUser, now)) {
                bu.setRepository(git, revWalk, oi);
                Change.Id result;
                if (destChanges.size() == 1) {
                    // The change key exists on the destination branch. The cherry pick
                    // will be added as a new patch set.
                    result = insertPatchSet(bu, git, destChanges.get(0).notes(), cherryPickCommit, input);
                } else {
                    // Change key not found on destination branch. We can create a new
                    // change.
                    String newTopic = null;
                    if (sourceChange != null && !Strings.isNullOrEmpty(sourceChange.getTopic())) {
                        newTopic = sourceChange.getTopic() + "-" + newDest.getShortName();
                    }
                    result = createNewChange(bu, cherryPickCommit, dest.get(), newTopic, sourceChange, sourceCommit, input);
                    if (sourceChange != null && sourcePatchId != null) {
                        bu.addOp(sourceChange.getId(), new AddMessageToSourceChangeOp(changeMessagesUtil, sourcePatchId, dest.getShortName(), cherryPickCommit));
                    }
                }
                bu.execute();
                return result;
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    }
}
#method_after
public Change.Id cherryPick(BatchUpdate.Factory batchUpdateFactory, @Nullable Change sourceChange, @Nullable PatchSet.Id sourcePatchId, Project.NameKey project, ObjectId sourceCommit, CherryPickInput input, Branch.NameKey dest) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException, ConfigInvalidException, NoSuchProjectException {
    IdentifiedUser identifiedUser = user.get();
    try (Repository git = gitManager.openRepository(project);
        // before patch sets are updated.
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(reader)) {
        Ref destRef = git.getRefDatabase().exactRef(dest.get());
        if (destRef == null) {
            throw new InvalidChangeOperationException(String.format("Branch %s does not exist.", dest.get()));
        }
        RevCommit baseCommit = getBaseCommit(destRef, project.get(), revWalk, input.base);
        CodeReviewCommit commitToCherryPick = revWalk.parseCommit(sourceCommit);
        if (input.parent <= 0 || input.parent > commitToCherryPick.getParentCount()) {
            throw new InvalidChangeOperationException(String.format("Cherry Pick: Parent %s does not exist. Please specify a parent in" + " range [1, %s].", input.parent, commitToCherryPick.getParentCount()));
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = identifiedUser.newCommitterIdent(now, serverTimeZone);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), baseCommit, commitToCherryPick.getAuthorIdent(), committerIdent, input.message);
        String commitMessage = ChangeIdUtil.insertId(input.message, computedChangeId).trim() + '\n';
        CodeReviewCommit cherryPickCommit;
        ProjectState projectState = projectCache.checkedGet(dest.getParentKey());
        if (projectState == null) {
            throw new NoSuchProjectException(dest.getParentKey());
        }
        try {
            cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(oi, git.getConfig(), baseCommit, commitToCherryPick, committerIdent, commitMessage, revWalk, input.parent - 1, false);
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            Branch.NameKey newDest = new Branch.NameKey(project, destRef.getName());
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " reside on the same branch. " + "Cannot create a new patch set.");
            }
            try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), project, identifiedUser, now)) {
                bu.setRepository(git, revWalk, oi);
                Change.Id result;
                if (destChanges.size() == 1) {
                    // The change key exists on the destination branch. The cherry pick
                    // will be added as a new patch set.
                    result = insertPatchSet(bu, git, destChanges.get(0).notes(), cherryPickCommit, input);
                } else {
                    // Change key not found on destination branch. We can create a new
                    // change.
                    String newTopic = null;
                    if (sourceChange != null && !Strings.isNullOrEmpty(sourceChange.getTopic())) {
                        newTopic = sourceChange.getTopic() + "-" + newDest.getShortName();
                    }
                    result = createNewChange(bu, cherryPickCommit, dest.get(), newTopic, sourceChange, sourceCommit, input);
                    if (sourceChange != null && sourcePatchId != null) {
                        bu.addOp(sourceChange.getId(), new AddMessageToSourceChangeOp(changeMessagesUtil, sourcePatchId, dest.getShortName(), cherryPickCommit));
                    }
                }
                bu.execute();
                return result;
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    }
}
#end_block

#method_before
private Change.Id insertPatchSet(BatchUpdate bu, Repository git, ChangeNotes destNotes, CodeReviewCommit cherryPickCommit, CherryPickInput input) throws IOException, OrmException, BadRequestException, ConfigInvalidException {
    Change destChange = destNotes.getChange();
    PatchSet.Id psId = ChangeUtil.nextPatchSetId(git, destChange.currentPatchSetId());
    PatchSet current = psUtil.current(dbProvider.get(), destNotes);
    PatchSetInserter inserter = patchSetInserterFactory.create(destNotes, psId, cherryPickCommit);
    inserter.setMessage("Uploaded patch set " + inserter.getPatchSetId().get() + ".").setDraft(current.isDraft()).setNotify(input.notify).setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
    bu.addOp(destChange.getId(), inserter);
    return destChange.getId();
}
#method_after
private Change.Id insertPatchSet(BatchUpdate bu, Repository git, ChangeNotes destNotes, CodeReviewCommit cherryPickCommit, CherryPickInput input) throws IOException, OrmException, BadRequestException, ConfigInvalidException {
    Change destChange = destNotes.getChange();
    PatchSet.Id psId = ChangeUtil.nextPatchSetId(git, destChange.currentPatchSetId());
    PatchSetInserter inserter = patchSetInserterFactory.create(destNotes, psId, cherryPickCommit);
    inserter.setMessage("Uploaded patch set " + inserter.getPatchSetId().get() + ".").setNotify(input.notify).setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
    bu.addOp(destChange.getId(), inserter);
    return destChange.getId();
}
#end_block

#method_before
@Override
public Description getDescription(ChangeResource rsrc) {
    return new UiAction.Description().setLabel("Unignore").setTitle("Unignore the change").setVisible(!rsrc.isUserOwner() && isIgnored(rsrc));
}
#method_after
@Override
public Description getDescription(ChangeResource rsrc) {
    return new UiAction.Description().setLabel("Unignore").setTitle("Unignore the change").setVisible(isIgnored(rsrc));
}
#end_block

#method_before
@Override
public Response<String> apply(ChangeResource rsrc, Input input) throws RestApiException {
    try {
        if (rsrc.isUserOwner() || !isIgnored(rsrc)) {
            // early exit for own changes and not ignored changes
            return Response.ok("");
        }
        stars.unignore(self.get().getAccountId(), rsrc.getProject(), rsrc.getChange().getId());
    } catch (OrmException e) {
        throw new RestApiException("failed to unignore change", e);
    }
    return Response.ok("");
}
#method_after
@Override
public Response<String> apply(ChangeResource rsrc, Input input) throws OrmException, IllegalLabelException {
    if (isIgnored(rsrc)) {
        stars.unignore(rsrc);
    }
    return Response.ok("");
}
#end_block

#method_before
private boolean isIgnored(ChangeResource rsrc) {
    try {
        return stars.isIgnoredBy(rsrc.getChange().getId(), self.get().getAccountId());
    } catch (OrmException e) {
        log.error("failed to check ignored star", e);
    }
    return false;
}
#method_after
private boolean isIgnored(ChangeResource rsrc) {
    try {
        return stars.isIgnored(rsrc);
    } catch (OrmException e) {
        log.error("failed to check ignored star", e);
    }
    return false;
}
#end_block

#method_before
public static TreeModificationSubject assertThat(TreeModification treeModification) {
    return assertAbout(TREE_MODIFICATION_SUBJECT_FACTORY).that(treeModification);
}
#method_after
public static TreeModificationSubject assertThat(TreeModification treeModification) {
    return assertAbout(TreeModificationSubject::new).that(treeModification);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Fixes.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FIX_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    get(CHANGE_KIND, "pure_revert").to(GetPureRevert.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "private").to(PostPrivate.class);
    post(CHANGE_KIND, "private.delete").to(DeletePrivateByPost.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    put(CHANGE_KIND, "ignore").to(Ignore.class);
    put(CHANGE_KIND, "unignore").to(Unignore.class);
    put(CHANGE_KIND, "mute").to(Mute.class);
    put(CHANGE_KIND, "unmute").to(Unmute.class);
    post(CHANGE_KIND, "wip").to(SetWorkInProgress.class);
    post(CHANGE_KIND, "ready").to(SetReadyForReview.class);
    put(CHANGE_KIND, "message").to(PutMessage.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    delete(COMMENT_KIND).to(DeleteComment.class);
    post(COMMENT_KIND, "delete").to(DeleteComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "fixes").to(Fixes.class);
    post(FIX_KIND, "apply").to(ApplyFix.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(ChangeResource.Factory.class);
    factory(DeleteReviewerByEmailOp.Factory.class);
    factory(DeleteReviewerOp.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(PostReviewersOp.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(WorkInProgressOp.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Fixes.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FIX_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    get(CHANGE_KIND, "pure_revert").to(GetPureRevert.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "private").to(PostPrivate.class);
    post(CHANGE_KIND, "private.delete").to(DeletePrivateByPost.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    put(CHANGE_KIND, "ignore").to(Ignore.class);
    put(CHANGE_KIND, "unignore").to(Unignore.class);
    put(CHANGE_KIND, "reviewed").to(MarkAsReviewed.class);
    put(CHANGE_KIND, "unreviewed").to(MarkAsUnreviewed.class);
    post(CHANGE_KIND, "wip").to(SetWorkInProgress.class);
    post(CHANGE_KIND, "ready").to(SetReadyForReview.class);
    put(CHANGE_KIND, "message").to(PutMessage.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    delete(COMMENT_KIND).to(DeleteComment.class);
    post(COMMENT_KIND, "delete").to(DeleteComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "fixes").to(Fixes.class);
    post(FIX_KIND, "apply").to(ApplyFix.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(ChangeResource.Factory.class);
    factory(DeleteReviewerByEmailOp.Factory.class);
    factory(DeleteReviewerOp.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(PostReviewersOp.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(WorkInProgressOp.Factory.class);
}
#end_block

#method_before
private boolean isMember(GroupDescription.Internal group, IdentifiedUser user) throws OrmException, ResourceNotFoundException {
    AccountGroup.UUID groupUuid = group.getGroupUUID();
    try {
        return groups.isMember(db.get(), groupUuid, user.getAccountId());
    } catch (NoSuchGroupException e) {
        throw new ResourceNotFoundException(String.format("Group %s not found", groupUuid));
    }
}
#method_after
private static boolean isMember(GroupDescription.Internal group, IdentifiedUser user) {
    return group.getMembers().contains(user.getAccountId());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public PutMember create(GroupResource group, IdString id) {
    return new PutMember(put, id.get());
}
#method_after
@Override
public PutMember create(GroupResource group, IdString id) {
    return new PutMember(put, id.get());
}
#end_block

#method_before
@Override
public RevisionResource parse(ChangeResource change, IdString id) throws ResourceNotFoundException, AuthException, OrmException, IOException {
    if (id.get().equals("current")) {
        PatchSet ps = psUtil.current(dbProvider.get(), change.getNotes());
        if (ps != null && visible(change, ps)) {
            return new RevisionResource(change, ps).doNotCache();
        }
        throw new ResourceNotFoundException(id);
    }
    List<RevisionResource> match = Lists.newArrayListWithExpectedSize(2);
    for (RevisionResource rsrc : find(change, id.get())) {
        if (visible(change, rsrc.getPatchSet())) {
            match.add(rsrc);
        }
    }
    switch(match.size()) {
        case 0:
            throw new ResourceNotFoundException(id);
        case 1:
            return match.get(0);
        default:
            throw new ResourceNotFoundException("Multiple patch sets for \"" + id.get() + "\": " + Joiner.on("; ").join(match));
    }
}
#method_after
@Override
public RevisionResource parse(ChangeResource change, IdString id) throws ResourceNotFoundException, AuthException, OrmException, IOException, PermissionBackendException {
    if (id.get().equals("current")) {
        PatchSet ps = psUtil.current(dbProvider.get(), change.getNotes());
        if (ps != null && visible(change)) {
            return new RevisionResource(change, ps).doNotCache();
        }
        throw new ResourceNotFoundException(id);
    }
    List<RevisionResource> match = Lists.newArrayListWithExpectedSize(2);
    for (RevisionResource rsrc : find(change, id.get())) {
        if (visible(change)) {
            match.add(rsrc);
        }
    }
    switch(match.size()) {
        case 0:
            throw new ResourceNotFoundException(id);
        case 1:
            return match.get(0);
        default:
            throw new ResourceNotFoundException("Multiple patch sets for \"" + id.get() + "\": " + Joiner.on("; ").join(match));
    }
}
#end_block

#method_before
private boolean visible(ChangeResource change, PatchSet ps) throws OrmException {
    return change.getControl().isPatchVisible(ps, dbProvider.get());
}
#method_after
private boolean visible(ChangeResource change) throws PermissionBackendException {
    try {
        permissionBackend.user(change.getUser()).change(change.getNotes()).database(dbProvider).check(ChangePermission.READ);
        return true;
    } catch (AuthException e) {
        return false;
    }
}
#end_block

#method_before
public void fire(Change change, PatchSet ps, Account reviewer, Map<String, Short> approvals, Map<String, Short> oldApprovals, NotifyHandling notify, String message, Account remover, Timestamp when) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        Event event = new Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(reviewer), util.approvals(remover, approvals, when), util.approvals(remover, oldApprovals, when), notify, message, util.accountInfo(remover), when);
        for (VoteDeletedListener l : listeners) {
            try {
                l.onVoteDeleted(event);
            } catch (Exception e) {
                util.logEventListenerError(this, l, e);
            }
        }
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException e) {
        log.error("Couldn't fire event", e);
    }
}
#method_after
public void fire(Change change, PatchSet ps, Account reviewer, Map<String, Short> approvals, Map<String, Short> oldApprovals, NotifyHandling notify, String message, Account remover, Timestamp when) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        Event event = new Event(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(reviewer), util.approvals(remover, approvals, when), util.approvals(remover, oldApprovals, when), notify, message, util.accountInfo(remover), when);
        for (VoteDeletedListener l : listeners) {
            try {
                l.onVoteDeleted(event);
            } catch (Exception e) {
                util.logEventListenerError(this, l, e);
            }
        }
    } catch (PatchListObjectTooLargeException e) {
        log.warn("Couldn't fire event: " + e.getMessage());
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException | PermissionBackendException e) {
        log.error("Couldn't fire event", e);
    }
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws MergeConflictException, InvalidChangeOperationException, RestApiException, IOException, OrmException, NoSuchChangeException, PermissionBackendException {
    // Ok that originalPatchSet was not read in a transaction, since we just
    // need its revision.
    RevId oldRev = originalPatchSet.getRevision();
    RevWalk rw = ctx.getRevWalk();
    RevCommit original = rw.parseCommit(ObjectId.fromString(oldRev.get()));
    rw.parseBody(original);
    RevCommit baseCommit = rw.parseCommit(baseCommitId);
    String newCommitMessage;
    if (detailedCommitMessage) {
        rw.parseBody(baseCommit);
        newCommitMessage = newMergeUtil().createCommitMessageOnSubmit(original, baseCommit, ctl, originalPatchSet.getId());
    } else {
        newCommitMessage = original.getFullMessage();
    }
    rebasedCommit = rebaseCommit(ctx, original, baseCommit, newCommitMessage);
    Base base = rebaseUtil.parseBase(new RevisionResource(changeResourceFactory.create(ctl), originalPatchSet), baseCommitId.name());
    rebasedPatchSetId = ChangeUtil.nextPatchSetIdFromChangeRefsMap(ctx.getRepoView().getRefs(originalPatchSet.getId().getParentKey().toRefPrefix()), ctl.getChange().currentPatchSetId());
    patchSetInserter = patchSetInserterFactory.create(ctl.getNotes(), rebasedPatchSetId, rebasedCommit).setDescription("Rebase").setDraft(originalPatchSet.isDraft()).setNotify(NotifyHandling.NONE).setFireRevisionCreated(fireRevisionCreated).setCopyApprovals(copyApprovals).setCheckAddPatchSetPermission(checkAddPatchSetPermission).setValidate(validate);
    if (postMessage) {
        patchSetInserter.setMessage("Patch Set " + rebasedPatchSetId.get() + ": Patch Set " + originalPatchSet.getId().get() + " was rebased");
    }
    if (base != null) {
        patchSetInserter.setGroups(base.patchSet().getGroups());
    }
    patchSetInserter.updateRepo(ctx);
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws MergeConflictException, InvalidChangeOperationException, RestApiException, IOException, OrmException, NoSuchChangeException, PermissionBackendException {
    // Ok that originalPatchSet was not read in a transaction, since we just
    // need its revision.
    RevId oldRev = originalPatchSet.getRevision();
    RevWalk rw = ctx.getRevWalk();
    RevCommit original = rw.parseCommit(ObjectId.fromString(oldRev.get()));
    rw.parseBody(original);
    RevCommit baseCommit = rw.parseCommit(baseCommitId);
    CurrentUser changeOwner = identifiedUserFactory.create(notes.getChange().getOwner());
    String newCommitMessage;
    if (detailedCommitMessage) {
        rw.parseBody(baseCommit);
        newCommitMessage = newMergeUtil().createCommitMessageOnSubmit(original, baseCommit, notes, changeOwner, originalPatchSet.getId());
    } else {
        newCommitMessage = original.getFullMessage();
    }
    rebasedCommit = rebaseCommit(ctx, original, baseCommit, newCommitMessage);
    Base base = rebaseUtil.parseBase(new RevisionResource(changeResourceFactory.create(notes, changeOwner), originalPatchSet), baseCommitId.name());
    rebasedPatchSetId = ChangeUtil.nextPatchSetIdFromChangeRefsMap(ctx.getRepoView().getRefs(originalPatchSet.getId().getParentKey().toRefPrefix()), notes.getChange().currentPatchSetId());
    patchSetInserter = patchSetInserterFactory.create(notes, rebasedPatchSetId, rebasedCommit).setDescription("Rebase").setNotify(NotifyHandling.NONE).setFireRevisionCreated(fireRevisionCreated).setCopyApprovals(copyApprovals).setCheckAddPatchSetPermission(checkAddPatchSetPermission).setValidate(validate);
    if (postMessage) {
        patchSetInserter.setMessage("Patch Set " + rebasedPatchSetId.get() + ": Patch Set " + originalPatchSet.getId().get() + " was rebased");
    }
    if (base != null) {
        patchSetInserter.setGroups(base.patchSet().getGroups());
    }
    patchSetInserter.updateRepo(ctx);
}
#end_block

#method_before
private MergeUtil newMergeUtil() {
    ProjectState project = ctl.getProjectControl().getProjectState();
    return forceContentMerge ? mergeUtilFactory.create(project, true) : mergeUtilFactory.create(project);
}
#method_after
private MergeUtil newMergeUtil() throws IOException {
    ProjectState project = projectCache.checkedGet(notes.getProjectName());
    return forceContentMerge ? mergeUtilFactory.create(project, true) : mergeUtilFactory.create(project);
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(Event event) {
    if (allUsersName.get().equals(event.getProjectName())) {
        Account.Id accountId = Account.Id.fromRef(event.getRefName());
        if (accountId != null) {
            try {
                accountCache.evict(accountId);
            } catch (IOException e) {
                log.error(String.format("Reindex account %s failed.", accountId), e);
            }
        }
    }
    if (!enabled || event.getRefName().startsWith(RefNames.REFS_CHANGES) || event.getRefName().startsWith(RefNames.REFS_DRAFT_COMMENTS) || event.getRefName().startsWith(RefNames.REFS_USERS)) {
        return;
    }
    Futures.addCallback(executor.submit(new GetChanges(event)), new FutureCallback<List<Change>>() {

        @Override
        public void onSuccess(List<Change> changes) {
            for (Change c : changes) {
                // Don't retry indefinitely; if this fails changes may be stale.
                @SuppressWarnings("unused")
                Future<?> possiblyIgnoredError = executor.submit(new Index(event, c.getId()));
            }
        }

        @Override
        public void onFailure(Throwable ignored) {
        // Logged by {@link GetChanges#call()}.
        }
    }, directExecutor());
}
#method_after
@Override
public void onGitReferenceUpdated(Event event) {
    if (allUsersName.get().equals(event.getProjectName())) {
        Account.Id accountId = Account.Id.fromRef(event.getRefName());
        if (accountId != null && !event.getRefName().startsWith(RefNames.REFS_STARRED_CHANGES)) {
            try {
                accountCache.evict(accountId);
            } catch (IOException e) {
                log.error(String.format("Reindex account %s failed.", accountId), e);
            }
        }
    }
    if (!enabled || event.getRefName().startsWith(RefNames.REFS_CHANGES) || event.getRefName().startsWith(RefNames.REFS_DRAFT_COMMENTS) || event.getRefName().startsWith(RefNames.REFS_USERS)) {
        return;
    }
    Futures.addCallback(executor.submit(new GetChanges(event)), new FutureCallback<List<Change>>() {

        @Override
        public void onSuccess(List<Change> changes) {
            for (Change c : changes) {
                // Don't retry indefinitely; if this fails changes may be stale.
                @SuppressWarnings("unused")
                Future<?> possiblyIgnoredError = executor.submit(new Index(event, c.getId()));
            }
        }

        @Override
        public void onFailure(Throwable ignored) {
        // Logged by {@link GetChanges#call()}.
        }
    }, directExecutor());
}
#end_block

#method_before
public static ChangeFileContentModificationSubject assertThat(ChangeFileContentModification modification) {
    return assertAbout(MODIFICATION_SUBJECT_FACTORY).that(modification);
}
#method_after
public static ChangeFileContentModificationSubject assertThat(ChangeFileContentModification modification) {
    return assertAbout(ChangeFileContentModificationSubject::new).that(modification);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, ResourceNotFoundException, OrmException, PermissionBackendException, IOException {
    Account.Id reviewerId = reviewer.getId();
    if (!approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).all().contains(reviewerId)) {
        throw new ResourceNotFoundException();
    }
    currChange = ctx.getChange();
    currPs = psUtil.current(ctx.getDb(), ctx.getNotes());
    LabelTypes labelTypes = projectCache.checkedGet(ctx.getProject()).getLabelTypes(ctx.getNotes(), ctx.getUser());
    // removing a reviewer will remove all her votes
    for (LabelType lt : labelTypes.getLabelTypes()) {
        newApprovals.put(lt.getName(), (short) 0);
    }
    StringBuilder msg = new StringBuilder();
    msg.append("Removed reviewer " + reviewer.getFullName());
    StringBuilder removedVotesMsg = new StringBuilder();
    removedVotesMsg.append(" with the following votes:\n\n");
    List<PatchSetApproval> del = new ArrayList<>();
    boolean votesRemoved = false;
    for (PatchSetApproval a : approvals(ctx, reviewerId)) {
        removeReviewerControl.checkRemoveReviewer(ctx.getNotes(), ctx.getUser(), a);
        del.add(a);
        if (a.getPatchSetId().equals(currPs.getId()) && a.getValue() != 0) {
            oldApprovals.put(a.getLabel(), a.getValue());
            removedVotesMsg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
            votesRemoved = true;
        }
    }
    if (votesRemoved) {
        msg.append(removedVotesMsg);
    } else {
        msg.append(".");
    }
    ctx.getDb().patchSetApprovals().delete(del);
    ChangeUpdate update = ctx.getUpdate(currPs.getId());
    update.removeReviewer(reviewerId);
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_REVIEWER);
    cmUtil.addChangeMessage(ctx.getDb(), update, changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, ResourceNotFoundException, OrmException, PermissionBackendException, IOException, NoSuchProjectException {
    Account.Id reviewerId = reviewer.getId();
    if (!approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).all().contains(reviewerId)) {
        throw new ResourceNotFoundException();
    }
    currChange = ctx.getChange();
    currPs = psUtil.current(ctx.getDb(), ctx.getNotes());
    LabelTypes labelTypes = projectCache.checkedGet(ctx.getProject()).getLabelTypes(ctx.getNotes(), ctx.getUser());
    // removing a reviewer will remove all her votes
    for (LabelType lt : labelTypes.getLabelTypes()) {
        newApprovals.put(lt.getName(), (short) 0);
    }
    StringBuilder msg = new StringBuilder();
    msg.append("Removed reviewer " + reviewer.getFullName());
    StringBuilder removedVotesMsg = new StringBuilder();
    removedVotesMsg.append(" with the following votes:\n\n");
    List<PatchSetApproval> del = new ArrayList<>();
    boolean votesRemoved = false;
    for (PatchSetApproval a : approvals(ctx, reviewerId)) {
        removeReviewerControl.checkRemoveReviewer(ctx.getNotes(), ctx.getUser(), a);
        del.add(a);
        if (a.getPatchSetId().equals(currPs.getId()) && a.getValue() != 0) {
            oldApprovals.put(a.getLabel(), a.getValue());
            removedVotesMsg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
            votesRemoved = true;
        }
    }
    if (votesRemoved) {
        msg.append(removedVotesMsg);
    } else {
        msg.append(".");
    }
    ctx.getDb().patchSetApprovals().delete(del);
    ChangeUpdate update = ctx.getUpdate(currPs.getId());
    update.removeReviewer(reviewerId);
    changeMessage = ChangeMessagesUtil.newMessage(ctx, msg.toString(), ChangeMessagesUtil.TAG_DELETE_REVIEWER);
    cmUtil.addChangeMessage(ctx.getDb(), update, changeMessage);
    return true;
}
#end_block

#method_before
public Change mergeChange(RevisionResource rsrc, IdentifiedUser submitter, SubmitInput input) throws OrmException, RestApiException, IOException, UpdateException, ConfigInvalidException, PermissionBackendException {
    Change change = rsrc.getChange();
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    try (MergeOp op = mergeOpProvider.get()) {
        ReviewDb db = dbProvider.get();
        op.merge(db, change, submitter, true, input, false);
        try {
            change = changeNotesFactory.createChecked(db, change.getProject(), change.getId()).getChange();
        } catch (NoSuchChangeException e) {
            throw new ResourceConflictException("change is deleted");
        }
    }
    switch(change.getStatus()) {
        case MERGED:
            return change;
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
}
#method_after
public Change mergeChange(RevisionResource rsrc, IdentifiedUser submitter, SubmitInput input) throws OrmException, RestApiException, IOException, UpdateException, ConfigInvalidException, PermissionBackendException {
    Change change = rsrc.getChange();
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    try (MergeOp op = mergeOpProvider.get()) {
        ReviewDb db = dbProvider.get();
        op.merge(db, change, submitter, true, input, false);
        try {
            change = changeNotesFactory.createChecked(db, change.getProject(), change.getId()).getChange();
        } catch (NoSuchChangeException e) {
            throw new ResourceConflictException("change is deleted");
        }
    }
    switch(change.getStatus()) {
        case MERGED:
            return change;
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        case ABANDONED:
        default:
            throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    Change change = resource.getChange();
    if (!change.getStatus().isOpen() || !resource.isCurrent() || resource.getPatchSet().isDraft() || !resource.permissions().testOrFalse(ChangePermission.SUBMIT)) {
        // submit not visible
        return null;
    }
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        MergeOp.checkSubmitRule(cd, false);
    } catch (ResourceConflictException e) {
        // submit not visible
        return null;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.get().completeChangeSet(db, cd.change(), resource.getControl().getUser());
    } catch (OrmException | IOException | PermissionBackendException e) {
        throw new OrmRuntimeException("Could not determine complete set of changes to be submitted", e);
    }
    String topic = change.getTopic();
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cd, cs, resource.getUser());
    Boolean enabled;
    try {
        // Recheck mergeability rather than using value stored in the index,
        // which may be stale.
        // TODO(dborowitz): This is ugly; consider providing a way to not read
        // stored fields from the index in the first place.
        // cd.setMergeable(null);
        // That was done in unmergeableChanges which was called by
        // problemsForSubmittingChangeset, so now it is safe to read from
        // the cache, as it yields the same result.
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", change.getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
    ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
    return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    Change change = resource.getChange();
    if (!change.getStatus().isOpen() || !resource.isCurrent() || !resource.permissions().testOrFalse(ChangePermission.SUBMIT)) {
        // submit not visible
        return null;
    }
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getNotes());
    try {
        MergeOp.checkSubmitRule(cd, false);
    } catch (ResourceConflictException e) {
        // submit not visible
        return null;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.get().completeChangeSet(db, cd.change(), resource.getUser());
    } catch (OrmException | IOException | PermissionBackendException e) {
        throw new OrmRuntimeException("Could not determine complete set of changes to be submitted", e);
    }
    String topic = change.getTopic();
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cd, cs, resource.getUser());
    Boolean enabled;
    try {
        // Recheck mergeability rather than using value stored in the index,
        // which may be stale.
        // TODO(dborowitz): This is ugly; consider providing a way to not read
        // stored fields from the index in the first place.
        // cd.setMergeable(null);
        // That was done in unmergeableChanges which was called by
        // problemsForSubmittingChangeset, so now it is safe to read from
        // the cache, as it yields the same result.
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", change.getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
    ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
    return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource rsrc, SubmitInput input) throws RestApiException, RepositoryNotFoundException, IOException, OrmException, PermissionBackendException, UpdateException, ConfigInvalidException {
    PatchSet ps = psUtil.current(dbProvider.get(), rsrc.getNotes());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(ps, dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    Output out = submit.apply(new RevisionResource(rsrc, ps), input);
    return json.noOptions().format(out.change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource rsrc, SubmitInput input) throws RestApiException, RepositoryNotFoundException, IOException, OrmException, PermissionBackendException, UpdateException, ConfigInvalidException {
    PatchSet ps = psUtil.current(dbProvider.get(), rsrc.getNotes());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    }
    Output out = submit.apply(new RevisionResource(rsrc, ps), input);
    return json.noOptions().format(out.change);
}
#end_block

#method_before
@Override
public ChangeUpdate getUpdate(PatchSet.Id psId) {
    ChangeUpdate u = updates.get(psId);
    if (u == null) {
        u = changeUpdateFactory.create(ctl, when);
        if (newChanges.containsKey(ctl.getId())) {
            u.setAllowWriteToNewRef(true);
        }
        u.setPatchSetId(psId);
        updates.put(psId, u);
    }
    return u;
}
#method_after
@Override
public ChangeUpdate getUpdate(PatchSet.Id psId) {
    ChangeUpdate u = updates.get(psId);
    if (u == null) {
        u = changeUpdateFactory.create(notes, user, when);
        if (newChanges.containsKey(notes.getChangeId())) {
            u.setAllowWriteToNewRef(true);
        }
        u.setPatchSetId(psId);
        updates.put(psId, u);
    }
    return u;
}
#end_block

#method_before
private ChangeContextImpl newChangeContext(Change.Id id) throws OrmException {
    logDebug("Opening change {} for update", id);
    Change c = newChanges.get(id);
    boolean isNew = c != null;
    if (!isNew) {
        // Pass a synthetic change into ChangeNotes.Factory, which will take care of checking for
        // existence and populating columns from the parsed notes state.
        // TODO(dborowitz): This dance made more sense when using Reviewdb; consider a nicer way.
        c = ChangeNotes.Factory.newNoteDbOnlyChange(project, id);
    } else {
        logDebug("Change {} is new", id);
    }
    ChangeNotes notes = changeNotesFactory.createForBatchUpdate(c, !isNew);
    ChangeControl ctl = changeControlFactory.controlFor(notes, user);
    return new ChangeContextImpl(ctl);
}
#method_after
private ChangeContextImpl newChangeContext(Change.Id id) throws OrmException {
    logDebug("Opening change {} for update", id);
    Change c = newChanges.get(id);
    boolean isNew = c != null;
    if (!isNew) {
        // Pass a synthetic change into ChangeNotes.Factory, which will take care of checking for
        // existence and populating columns from the parsed notes state.
        // TODO(dborowitz): This dance made more sense when using Reviewdb; consider a nicer way.
        c = ChangeNotes.Factory.newNoteDbOnlyChange(project, id);
    } else {
        logDebug("Change {} is new", id);
    }
    ChangeNotes notes = changeNotesFactory.createForBatchUpdate(c, !isNew);
    return new ChangeContextImpl(notes);
}
#end_block

#method_before
private void logOrmExceptionForAccounts(String header, Account.Id me, Collection<AccountGroupMember> values, OrmException e) {
    List<String> descriptions = new ArrayList<>();
    for (AccountGroupMember m : values) {
        Account.Id accountId = m.getAccountId();
        String userName = accountCache.get(accountId).getUserName();
        AccountGroup.Id groupId = m.getAccountGroupId();
        String groupName = groupCache.get(groupId).getName();
        descriptions.add(MessageFormat.format("account {0}/{1}, group {2}/{3}", accountId, userName, groupId, groupName));
    }
    logOrmException(header, me, descriptions, e);
}
#method_after
private void logOrmExceptionForAccounts(String header, Account.Id me, Collection<AccountGroupMember> values, OrmException e) {
    List<String> descriptions = new ArrayList<>();
    for (AccountGroupMember m : values) {
        Account.Id accountId = m.getAccountId();
        String userName = accountCache.get(accountId).getUserName();
        AccountGroup.Id groupId = m.getAccountGroupId();
        String groupName = getGroupName(groupId);
        descriptions.add(MessageFormat.format("account {0}/{1}, group {2}/{3}", accountId, userName, groupId, groupName));
    }
    logOrmException(header, me, descriptions, e);
}
#end_block

#method_before
private void logOrmExceptionForGroups(String header, Account.Id me, Collection<AccountGroupById> values, OrmException e) {
    List<String> descriptions = new ArrayList<>();
    for (AccountGroupById m : values) {
        AccountGroup.UUID groupUuid = m.getIncludeUUID();
        String groupName = groupBackend.get(groupUuid).getName();
        AccountGroup.Id targetGroupId = m.getGroupId();
        String targetGroupName = groupCache.get(targetGroupId).getName();
        descriptions.add(MessageFormat.format("group {0}/{1}, group {2}/{3}", groupUuid, groupName, targetGroupId, targetGroupName));
    }
    logOrmException(header, me, descriptions, e);
}
#method_after
private void logOrmExceptionForGroups(String header, Account.Id me, Collection<AccountGroupById> values, OrmException e) {
    List<String> descriptions = new ArrayList<>();
    for (AccountGroupById m : values) {
        AccountGroup.UUID groupUuid = m.getIncludeUUID();
        String groupName = groupBackend.get(groupUuid).getName();
        AccountGroup.Id targetGroupId = m.getGroupId();
        String targetGroupName = getGroupName(targetGroupId);
        descriptions.add(MessageFormat.format("group {0}/{1}, group {2}/{3}", groupUuid, groupName, targetGroupId, targetGroupName));
    }
    logOrmException(header, me, descriptions, e);
}
#end_block

#method_before
private void loadLabelSections(Config rc) {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = new LinkedHashMap<>();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = new ArrayList<>();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String functionName = MoreObjects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        if (!values.isEmpty()) {
            short dv = (short) rc.getInt(LABEL, name, KEY_DEFAULT_VALUE, 0);
            if (isInRange(dv, values)) {
                label.setDefaultValue(dv);
            } else {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\"", KEY_DEFAULT_VALUE, dv, name)));
            }
        }
        label.setAllowPostSubmit(rc.getBoolean(LABEL, name, KEY_ALLOW_POST_SUBMIT, LabelType.DEF_ALLOW_POST_SUBMIT));
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, LabelType.DEF_COPY_MIN_SCORE));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, LabelType.DEF_COPY_MAX_SCORE));
        label.setCopyAllScoresOnMergeFirstParentUpdate(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE, LabelType.DEF_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE));
        label.setCopyAllScoresOnTrivialRebase(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, LabelType.DEF_COPY_ALL_SCORES_ON_TRIVIAL_REBASE));
        label.setCopyAllScoresIfNoCodeChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE, LabelType.DEF_COPY_ALL_SCORES_IF_NO_CODE_CHANGE));
        label.setCopyAllScoresIfNoChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, LabelType.DEF_COPY_ALL_SCORES_IF_NO_CHANGE));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, LabelType.DEF_CAN_OVERRIDE));
        label.setRefPatterns(getStringListOrNull(rc, LABEL, name, KEY_BRANCH));
        labelSections.put(name, label);
    }
}
#method_after
private void loadLabelSections(Config rc) {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = new LinkedHashMap<>();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = new ArrayList<>();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String functionName = rc.getString(LABEL, name, KEY_FUNCTION);
        Optional<LabelFunction> function = functionName != null ? LabelFunction.parse(functionName) : Optional.of(LabelFunction.MAX_WITH_BLOCK);
        if (!function.isPresent()) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LabelFunction.ALL.keySet()))));
        }
        label.setFunction(function.orElse(null));
        if (!values.isEmpty()) {
            short dv = (short) rc.getInt(LABEL, name, KEY_DEFAULT_VALUE, 0);
            if (isInRange(dv, values)) {
                label.setDefaultValue(dv);
            } else {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\"", KEY_DEFAULT_VALUE, dv, name)));
            }
        }
        label.setAllowPostSubmit(rc.getBoolean(LABEL, name, KEY_ALLOW_POST_SUBMIT, LabelType.DEF_ALLOW_POST_SUBMIT));
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, LabelType.DEF_COPY_MIN_SCORE));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, LabelType.DEF_COPY_MAX_SCORE));
        label.setCopyAllScoresOnMergeFirstParentUpdate(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE, LabelType.DEF_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE));
        label.setCopyAllScoresOnTrivialRebase(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, LabelType.DEF_COPY_ALL_SCORES_ON_TRIVIAL_REBASE));
        label.setCopyAllScoresIfNoCodeChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE, LabelType.DEF_COPY_ALL_SCORES_IF_NO_CODE_CHANGE));
        label.setCopyAllScoresIfNoChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, LabelType.DEF_COPY_ALL_SCORES_IF_NO_CHANGE));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, LabelType.DEF_CAN_OVERRIDE));
        label.setRefPatterns(getStringListOrNull(rc, LABEL, name, KEY_BRANCH));
        labelSections.put(name, label);
    }
}
#end_block

#method_before
private void saveLabelSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(LABEL));
    if (!Lists.newArrayList(labelSections.keySet()).equals(existing)) {
        // Order of sections changed, remove and rewrite them all.
        for (String name : existing) {
            rc.unsetSection(LABEL, name);
        }
    }
    Set<String> toUnset = Sets.newHashSet(existing);
    for (Map.Entry<String, LabelType> e : labelSections.entrySet()) {
        String name = e.getKey();
        LabelType label = e.getValue();
        toUnset.remove(name);
        rc.setString(LABEL, name, KEY_FUNCTION, label.getFunctionName());
        rc.setInt(LABEL, name, KEY_DEFAULT_VALUE, label.getDefaultValue());
        setBooleanConfigKey(rc, LABEL, name, KEY_ALLOW_POST_SUBMIT, label.allowPostSubmit(), LabelType.DEF_ALLOW_POST_SUBMIT);
        setBooleanConfigKey(rc, LABEL, name, KEY_COPY_MIN_SCORE, label.isCopyMinScore(), LabelType.DEF_COPY_MIN_SCORE);
        setBooleanConfigKey(rc, LABEL, name, KEY_COPY_MAX_SCORE, label.isCopyMaxScore(), LabelType.DEF_COPY_MAX_SCORE);
        setBooleanConfigKey(rc, LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, label.isCopyAllScoresOnTrivialRebase(), LabelType.DEF_COPY_ALL_SCORES_ON_TRIVIAL_REBASE);
        setBooleanConfigKey(rc, LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE, label.isCopyAllScoresIfNoCodeChange(), LabelType.DEF_COPY_ALL_SCORES_IF_NO_CODE_CHANGE);
        setBooleanConfigKey(rc, LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, label.isCopyAllScoresIfNoChange(), LabelType.DEF_COPY_ALL_SCORES_IF_NO_CHANGE);
        setBooleanConfigKey(rc, LABEL, name, KEY_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE, label.isCopyAllScoresOnMergeFirstParentUpdate(), LabelType.DEF_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE);
        setBooleanConfigKey(rc, LABEL, name, KEY_CAN_OVERRIDE, label.canOverride(), LabelType.DEF_CAN_OVERRIDE);
        List<String> values = Lists.newArrayListWithCapacity(label.getValues().size());
        for (LabelValue value : label.getValues()) {
            values.add(value.format());
        }
        rc.setStringList(LABEL, name, KEY_VALUE, values);
    }
    for (String name : toUnset) {
        rc.unsetSection(LABEL, name);
    }
}
#method_after
private void saveLabelSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(LABEL));
    if (!Lists.newArrayList(labelSections.keySet()).equals(existing)) {
        // Order of sections changed, remove and rewrite them all.
        for (String name : existing) {
            rc.unsetSection(LABEL, name);
        }
    }
    Set<String> toUnset = Sets.newHashSet(existing);
    for (Map.Entry<String, LabelType> e : labelSections.entrySet()) {
        String name = e.getKey();
        LabelType label = e.getValue();
        toUnset.remove(name);
        rc.setString(LABEL, name, KEY_FUNCTION, label.getFunction().getFunctionName());
        rc.setInt(LABEL, name, KEY_DEFAULT_VALUE, label.getDefaultValue());
        setBooleanConfigKey(rc, LABEL, name, KEY_ALLOW_POST_SUBMIT, label.allowPostSubmit(), LabelType.DEF_ALLOW_POST_SUBMIT);
        setBooleanConfigKey(rc, LABEL, name, KEY_COPY_MIN_SCORE, label.isCopyMinScore(), LabelType.DEF_COPY_MIN_SCORE);
        setBooleanConfigKey(rc, LABEL, name, KEY_COPY_MAX_SCORE, label.isCopyMaxScore(), LabelType.DEF_COPY_MAX_SCORE);
        setBooleanConfigKey(rc, LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, label.isCopyAllScoresOnTrivialRebase(), LabelType.DEF_COPY_ALL_SCORES_ON_TRIVIAL_REBASE);
        setBooleanConfigKey(rc, LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE, label.isCopyAllScoresIfNoCodeChange(), LabelType.DEF_COPY_ALL_SCORES_IF_NO_CODE_CHANGE);
        setBooleanConfigKey(rc, LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, label.isCopyAllScoresIfNoChange(), LabelType.DEF_COPY_ALL_SCORES_IF_NO_CHANGE);
        setBooleanConfigKey(rc, LABEL, name, KEY_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE, label.isCopyAllScoresOnMergeFirstParentUpdate(), LabelType.DEF_COPY_ALL_SCORES_ON_MERGE_FIRST_PARENT_UPDATE);
        setBooleanConfigKey(rc, LABEL, name, KEY_CAN_OVERRIDE, label.canOverride(), LabelType.DEF_CAN_OVERRIDE);
        List<String> values = Lists.newArrayListWithCapacity(label.getValues().size());
        for (LabelValue value : label.getValues()) {
            values.add(value.format());
        }
        rc.setStringList(LABEL, name, KEY_VALUE, values);
    }
    for (String name : toUnset) {
        rc.unsetSection(LABEL, name);
    }
}
#end_block

#method_before
default Change getChange() {
    return checkNotNull(getControl().getChange());
}
#method_after
default Change getChange() {
    return checkNotNull(getNotes().getChange());
}
#end_block

#method_before
@Override
public GroupIndex create(Schema<AccountGroup> schema) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public GroupIndex create(Schema<InternalGroup> schema) {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
protected void configure() {
    install(new IndexModule(1));
    bind(IndexConfig.class).toInstance(IndexConfig.createDefault());
    bind(Index.class).toInstance(new DummyChangeIndex());
    bind(AccountIndex.Factory.class).toInstance(new DummyAccountIndexFactory());
    bind(ChangeIndex.Factory.class).toInstance(new DummyChangeIndexFactory());
    bind(GroupIndex.Factory.class).toInstance(new DummyGroupIndexFactory());
}
#method_after
@Override
protected void configure() {
    install(new IndexModule(1));
    bind(IndexConfig.class).toInstance(IndexConfig.createDefault());
    bind(Index.class).toInstance(new DummyChangeIndex());
    bind(AccountIndex.Factory.class).toInstance(new DummyAccountIndexFactory());
    bind(ChangeIndex.Factory.class).toInstance(new DummyChangeIndexFactory());
    bind(GroupIndex.Factory.class).toInstance(new DummyGroupIndexFactory());
    bind(ProjectIndex.Factory.class).toInstance(new DummyProjectIndexFactory());
}
#end_block

#method_before
@Test
public void parseMetadataFromHeader() {
    // This tests if the metadata parser is able to parse metadata from the
    // email headers of the message.
    MailMessage.Builder b = MailMessage.builder();
    b.id("");
    b.dateReceived(new DateTime());
    b.subject("");
    b.addAdditionalHeader(toHeaderWithDelimiter(MetadataName.CHANGE_NUMBER) + "123");
    b.addAdditionalHeader(toHeaderWithDelimiter(MetadataName.PATCH_SET) + "1");
    b.addAdditionalHeader(toHeaderWithDelimiter(MetadataName.MESSAGE_TYPE) + "comment");
    b.addAdditionalHeader(toHeaderWithDelimiter(MetadataName.TIMESTAMP) + "Tue, 25 Oct 2016 02:11:35 -0700");
    Address author = new Address("Diffy", "test@gerritcodereview.com");
    b.from(author);
    MailMetadata meta = MetadataParser.parse(b.build());
    assertThat(meta.author).isEqualTo(author.getEmail());
    assertThat(meta.changeNumber).isEqualTo(123);
    assertThat(meta.patchSet).isEqualTo(1);
    assertThat(meta.messageType).isEqualTo("comment");
    assertThat(meta.timestamp.getTime()).isEqualTo(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC).getMillis());
}
#method_after
@Test
public void parseMetadataFromHeader() {
    // This tests if the metadata parser is able to parse metadata from the
    // email headers of the message.
    MailMessage.Builder b = MailMessage.builder();
    b.id("");
    b.dateReceived(Instant.now());
    b.subject("");
    b.addAdditionalHeader(toHeaderWithDelimiter(MetadataName.CHANGE_NUMBER) + "123");
    b.addAdditionalHeader(toHeaderWithDelimiter(MetadataName.PATCH_SET) + "1");
    b.addAdditionalHeader(toHeaderWithDelimiter(MetadataName.MESSAGE_TYPE) + "comment");
    b.addAdditionalHeader(toHeaderWithDelimiter(MetadataName.TIMESTAMP) + "Tue, 25 Oct 2016 02:11:35 -0700");
    Address author = new Address("Diffy", "test@gerritcodereview.com");
    b.from(author);
    MailMetadata meta = MetadataParser.parse(b.build());
    assertThat(meta.author).isEqualTo(author.getEmail());
    assertThat(meta.changeNumber).isEqualTo(123);
    assertThat(meta.patchSet).isEqualTo(1);
    assertThat(meta.messageType).isEqualTo("comment");
    assertThat(meta.timestamp.toInstant()).isEqualTo(LocalDateTime.of(2016, Month.OCTOBER, 25, 9, 11, 35).atOffset(ZoneOffset.UTC).toInstant());
}
#end_block

#method_before
@Test
public void parseMetadataFromText() {
    // This tests if the metadata parser is able to parse metadata from the
    // the text body of the message.
    MailMessage.Builder b = MailMessage.builder();
    b.id("");
    b.dateReceived(new DateTime());
    b.subject("");
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(toFooterWithDelimiter(MetadataName.CHANGE_NUMBER) + "123\r\n");
    stringBuilder.append("> " + toFooterWithDelimiter(MetadataName.PATCH_SET) + "1\n");
    stringBuilder.append(toFooterWithDelimiter(MetadataName.MESSAGE_TYPE) + "comment\n");
    stringBuilder.append(toFooterWithDelimiter(MetadataName.TIMESTAMP) + "Tue, 25 Oct 2016 02:11:35 -0700\r\n");
    b.textContent(stringBuilder.toString());
    Address author = new Address("Diffy", "test@gerritcodereview.com");
    b.from(author);
    MailMetadata meta = MetadataParser.parse(b.build());
    assertThat(meta.author).isEqualTo(author.getEmail());
    assertThat(meta.changeNumber).isEqualTo(123);
    assertThat(meta.patchSet).isEqualTo(1);
    assertThat(meta.messageType).isEqualTo("comment");
    assertThat(meta.timestamp.getTime()).isEqualTo(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC).getMillis());
}
#method_after
@Test
public void parseMetadataFromText() {
    // This tests if the metadata parser is able to parse metadata from the
    // the text body of the message.
    MailMessage.Builder b = MailMessage.builder();
    b.id("");
    b.dateReceived(Instant.now());
    b.subject("");
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(toFooterWithDelimiter(MetadataName.CHANGE_NUMBER) + "123\r\n");
    stringBuilder.append("> " + toFooterWithDelimiter(MetadataName.PATCH_SET) + "1\n");
    stringBuilder.append(toFooterWithDelimiter(MetadataName.MESSAGE_TYPE) + "comment\n");
    stringBuilder.append(toFooterWithDelimiter(MetadataName.TIMESTAMP) + "Tue, 25 Oct 2016 02:11:35 -0700\r\n");
    b.textContent(stringBuilder.toString());
    Address author = new Address("Diffy", "test@gerritcodereview.com");
    b.from(author);
    MailMetadata meta = MetadataParser.parse(b.build());
    assertThat(meta.author).isEqualTo(author.getEmail());
    assertThat(meta.changeNumber).isEqualTo(123);
    assertThat(meta.patchSet).isEqualTo(1);
    assertThat(meta.messageType).isEqualTo("comment");
    assertThat(meta.timestamp.toInstant()).isEqualTo(LocalDateTime.of(2016, Month.OCTOBER, 25, 9, 11, 35).atOffset(ZoneOffset.UTC).toInstant());
}
#end_block

#method_before
@Test
public void parseMetadataFromHTML() {
    // This tests if the metadata parser is able to parse metadata from the
    // the HTML body of the message.
    MailMessage.Builder b = MailMessage.builder();
    b.id("");
    b.dateReceived(new DateTime());
    b.subject("");
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("<div id\"someid\">" + toFooterWithDelimiter(MetadataName.CHANGE_NUMBER) + "123</div>");
    stringBuilder.append("<div>" + toFooterWithDelimiter(MetadataName.PATCH_SET) + "1</div>");
    stringBuilder.append("<div>" + toFooterWithDelimiter(MetadataName.MESSAGE_TYPE) + "comment</div>");
    stringBuilder.append("<div>" + toFooterWithDelimiter(MetadataName.TIMESTAMP) + "Tue, 25 Oct 2016 02:11:35 -0700" + "</div>");
    b.htmlContent(stringBuilder.toString());
    Address author = new Address("Diffy", "test@gerritcodereview.com");
    b.from(author);
    MailMetadata meta = MetadataParser.parse(b.build());
    assertThat(meta.author).isEqualTo(author.getEmail());
    assertThat(meta.changeNumber).isEqualTo(123);
    assertThat(meta.patchSet).isEqualTo(1);
    assertThat(meta.messageType).isEqualTo("comment");
    assertThat(meta.timestamp.getTime()).isEqualTo(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC).getMillis());
}
#method_after
@Test
public void parseMetadataFromHTML() {
    // This tests if the metadata parser is able to parse metadata from the
    // the HTML body of the message.
    MailMessage.Builder b = MailMessage.builder();
    b.id("");
    b.dateReceived(Instant.now());
    b.subject("");
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("<div id\"someid\">" + toFooterWithDelimiter(MetadataName.CHANGE_NUMBER) + "123</div>");
    stringBuilder.append("<div>" + toFooterWithDelimiter(MetadataName.PATCH_SET) + "1</div>");
    stringBuilder.append("<div>" + toFooterWithDelimiter(MetadataName.MESSAGE_TYPE) + "comment</div>");
    stringBuilder.append("<div>" + toFooterWithDelimiter(MetadataName.TIMESTAMP) + "Tue, 25 Oct 2016 02:11:35 -0700" + "</div>");
    b.htmlContent(stringBuilder.toString());
    Address author = new Address("Diffy", "test@gerritcodereview.com");
    b.from(author);
    MailMetadata meta = MetadataParser.parse(b.build());
    assertThat(meta.author).isEqualTo(author.getEmail());
    assertThat(meta.changeNumber).isEqualTo(123);
    assertThat(meta.patchSet).isEqualTo(1);
    assertThat(meta.messageType).isEqualTo("comment");
    assertThat(meta.timestamp.toInstant()).isEqualTo(LocalDateTime.of(2016, Month.OCTOBER, 25, 9, 11, 35).atOffset(ZoneOffset.UTC).toInstant());
}
#end_block

#method_before
@Override
public void publish() throws RestApiException {
    try {
        publishDraftChange.apply(change, null);
    } catch (Exception e) {
        throw asRestApiException("Cannot publish change", e);
    }
}
#method_after
@Deprecated
@Override
public void publish() throws RestApiException {
    throw new UnsupportedOperationException("draft workflow is discontinued");
}
#end_block

#method_before
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot set topic", e);
    }
}
#method_after
@Override
public void topic(String topic) throws RestApiException {
    TopicInput in = new TopicInput();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot set topic", e);
    }
}
#end_block

#method_before
@Override
public void index() throws RestApiException {
    try {
        index.apply(change, new Index.Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot index change", e);
    }
}
#method_after
@Override
public void index() throws RestApiException {
    try {
        index.apply(change, new Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot index change", e);
    }
}
#end_block

#method_before
@Override
public void ignore(boolean ignore) throws RestApiException {
    // StarredChangesUtil.
    if (ignore) {
        this.ignore.apply(change, new Ignore.Input());
    } else {
        unignore.apply(change, new Unignore.Input());
    }
}
#method_after
@Override
public void ignore(boolean ignore) throws RestApiException {
    // StarredChangesUtil.
    try {
        if (ignore) {
            this.ignore.apply(change, new Input());
        } else {
            unignore.apply(change, new Input());
        }
    } catch (OrmException | IllegalLabelException e) {
        throw asRestApiException("Cannot ignore change", e);
    }
}
#end_block

#method_before
@Override
public void index(AccountGroup.UUID uuid) throws IOException {
    for (Index<?, AccountGroup> i : getWriteIndexes()) {
        i.replace(groupCache.get(uuid));
    }
    fireGroupIndexedEvent(uuid.get());
}
#method_after
@Override
public void index(AccountGroup.UUID uuid) throws IOException {
    for (Index<AccountGroup.UUID, InternalGroup> i : getWriteIndexes()) {
        Optional<InternalGroup> internalGroup = groupCache.get(uuid);
        if (internalGroup.isPresent()) {
            i.replace(internalGroup.get());
        } else {
            i.delete(uuid);
        }
    }
    fireGroupIndexedEvent(uuid.get());
}
#end_block

#method_before
public ExternalIdsUpdate create() {
    PersonIdent i = serverIdent.get();
    return new ExternalIdsUpdate(repoManager, accountCache, allUsersName, metricMaker, externalIds, externalIdCache, i, i);
}
#method_after
public ExternalIdsUpdate create() {
    PersonIdent i = serverIdent.get();
    return new ExternalIdsUpdate(repoManager, accountCache, allUsersName, metricMaker, externalIds, externalIdCache, i, i, null, gitRefUpdated);
}
#end_block

#method_before
public ExternalIdsUpdate create() {
    PersonIdent i = serverIdent.get();
    return new ExternalIdsUpdate(repoManager, null, allUsersName, metricMaker, externalIds, externalIdCache, i, i);
}
#method_after
public ExternalIdsUpdate create() {
    PersonIdent i = serverIdent.get();
    return new ExternalIdsUpdate(repoManager, null, allUsersName, metricMaker, externalIds, externalIdCache, i, i, null, gitRefUpdated);
}
#end_block

#method_before
public ExternalIdsUpdate create() {
    PersonIdent i = serverIdent.get();
    return new ExternalIdsUpdate(repoManager, accountCache, allUsersName, metricMaker, externalIds, externalIdCache, createPersonIdent(i, identifiedUser.get()), i);
}
#method_after
public ExternalIdsUpdate create() {
    IdentifiedUser user = identifiedUser.get();
    PersonIdent i = serverIdent.get();
    return new ExternalIdsUpdate(repoManager, accountCache, allUsersName, metricMaker, externalIds, externalIdCache, createPersonIdent(i, user), i, user, gitRefUpdated);
}
#end_block

#method_before
private RefsMetaExternalIdsUpdate commit(Repository repo, RevWalk rw, ObjectInserter ins, ObjectId rev, NoteMap noteMap, UpdatedExternalIds updatedExtIds) throws IOException {
    ObjectId newRev = commit(repo, rw, ins, rev, noteMap, COMMIT_MSG, committerIdent, authorIdent);
    updateCount.increment();
    return RefsMetaExternalIdsUpdate.create(rev, newRev, updatedExtIds);
}
#method_after
private RefsMetaExternalIdsUpdate commit(Repository repo, RevWalk rw, ObjectInserter ins, ObjectId rev, NoteMap noteMap, UpdatedExternalIds updatedExtIds) throws IOException {
    ObjectId newRev = commit(allUsersName, repo, rw, ins, rev, noteMap, COMMIT_MSG, committerIdent, authorIdent, currentUser, gitRefUpdated);
    updateCount.increment();
    return RefsMetaExternalIdsUpdate.create(rev, newRev, updatedExtIds);
}
#end_block

#method_before
public static ObjectId commit(Repository repo, RevWalk rw, ObjectInserter ins, ObjectId rev, NoteMap noteMap, String commitMessage, PersonIdent committerIdent, PersonIdent authorIdent) throws IOException {
    CommitBuilder cb = new CommitBuilder();
    cb.setMessage(commitMessage);
    cb.setTreeId(noteMap.writeTree(ins));
    cb.setAuthor(authorIdent);
    cb.setCommitter(committerIdent);
    if (!rev.equals(ObjectId.zeroId())) {
        cb.setParentId(rev);
    } else {
        // Ref is currently nonexistent, commit has no parents.
        cb.setParentIds();
    }
    if (cb.getTreeId() == null) {
        if (rev.equals(ObjectId.zeroId())) {
            // No parent, assume empty tree.
            cb.setTreeId(emptyTree(ins));
        } else {
            RevCommit p = rw.parseCommit(rev);
            // Copy tree from parent.
            cb.setTreeId(p.getTree());
        }
    }
    ObjectId commitId = ins.insert(cb);
    ins.flush();
    RefUpdate u = repo.updateRef(RefNames.REFS_EXTERNAL_IDS);
    u.setRefLogIdent(committerIdent);
    u.setRefLogMessage("Update external IDs", false);
    u.setExpectedOldObjectId(rev);
    u.setNewObjectId(commitId);
    RefUpdate.Result res = u.update();
    switch(res) {
        case NEW:
        case FAST_FORWARD:
        case NO_CHANGE:
        case RENAMED:
        case FORCED:
            break;
        case LOCK_FAILURE:
            throw new LockFailureException("Updating external IDs failed with " + res);
        case IO_FAILURE:
        case NOT_ATTEMPTED:
        case REJECTED:
        case REJECTED_CURRENT_BRANCH:
        case REJECTED_MISSING_OBJECT:
        case REJECTED_OTHER_REASON:
        default:
            throw new IOException("Updating external IDs failed with " + res);
    }
    return rw.parseCommit(commitId);
}
#method_after
public static ObjectId commit(Project.NameKey project, Repository repo, RevWalk rw, ObjectInserter ins, ObjectId rev, NoteMap noteMap, String commitMessage, PersonIdent committerIdent, PersonIdent authorIdent, @Nullable IdentifiedUser user, GitReferenceUpdated gitRefUpdated) throws IOException {
    CommitBuilder cb = new CommitBuilder();
    cb.setMessage(commitMessage);
    cb.setTreeId(noteMap.writeTree(ins));
    cb.setAuthor(authorIdent);
    cb.setCommitter(committerIdent);
    if (!rev.equals(ObjectId.zeroId())) {
        cb.setParentId(rev);
    } else {
        // Ref is currently nonexistent, commit has no parents.
        cb.setParentIds();
    }
    if (cb.getTreeId() == null) {
        if (rev.equals(ObjectId.zeroId())) {
            // No parent, assume empty tree.
            cb.setTreeId(emptyTree(ins));
        } else {
            RevCommit p = rw.parseCommit(rev);
            // Copy tree from parent.
            cb.setTreeId(p.getTree());
        }
    }
    ObjectId commitId = ins.insert(cb);
    ins.flush();
    RefUpdate u = repo.updateRef(RefNames.REFS_EXTERNAL_IDS);
    u.setRefLogIdent(committerIdent);
    u.setRefLogMessage("Update external IDs", false);
    u.setExpectedOldObjectId(rev);
    u.setNewObjectId(commitId);
    RefUpdate.Result res = u.update();
    switch(res) {
        case NEW:
        case FAST_FORWARD:
        case NO_CHANGE:
        case RENAMED:
        case FORCED:
            break;
        case LOCK_FAILURE:
            throw new LockFailureException("Updating external IDs failed with " + res);
        case IO_FAILURE:
        case NOT_ATTEMPTED:
        case REJECTED:
        case REJECTED_CURRENT_BRANCH:
        case REJECTED_MISSING_OBJECT:
        case REJECTED_OTHER_REASON:
        default:
            throw new IOException("Updating external IDs failed with " + res);
    }
    gitRefUpdated.fire(project, u, user != null ? user.getAccount() : null);
    return rw.parseCommit(commitId);
}
#end_block

#method_before
@Override
protected Response<String> applyImpl(BatchUpdate.Factory updateFactory, RevisionResource rsrc, Input input) throws UpdateException, RestApiException, PermissionBackendException {
    rsrc.permissions().check(ChangePermission.EDIT_DESCRIPTION);
    ChangeControl ctl = rsrc.getControl();
    Op op = new Op(input != null ? input : new Input(), rsrc.getPatchSet().getId());
    try (BatchUpdate u = updateFactory.create(dbProvider.get(), rsrc.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(rsrc.getChange().getId(), op);
        u.execute();
    }
    return Strings.isNullOrEmpty(op.newDescription) ? Response.none() : Response.ok(op.newDescription);
}
#method_after
@Override
protected Response<String> applyImpl(BatchUpdate.Factory updateFactory, RevisionResource rsrc, DescriptionInput input) throws UpdateException, RestApiException, PermissionBackendException {
    rsrc.permissions().check(ChangePermission.EDIT_DESCRIPTION);
    Op op = new Op(input != null ? input : new DescriptionInput(), rsrc.getPatchSet().getId());
    try (BatchUpdate u = updateFactory.create(dbProvider.get(), rsrc.getChange().getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        u.addOp(rsrc.getChange().getId(), op);
        u.execute();
    }
    return Strings.isNullOrEmpty(op.newDescription) ? Response.none() : Response.ok(op.newDescription);
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, String newPassword) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException, ConfigInvalidException {
    if (user.getUserName() == null) {
        throw new ResourceConflictException("username must be set");
    }
    ExternalId extId = externalIds.get(ExternalId.Key.create(SCHEME_USERNAME, user.getUserName()));
    if (extId == null) {
        throw new ResourceNotFoundException();
    }
    ExternalId newExtId = ExternalId.createWithPassword(extId.key(), extId.accountId(), extId.email(), newPassword);
    externalIdsUpdate.create().upsert(newExtId);
    return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword);
}
#method_after
@Override
public Response<String> apply(AccountResource rsrc, HttpPasswordInput input) throws AuthException, ResourceNotFoundException, ResourceConflictException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    if (input == null) {
        input = new HttpPasswordInput();
    }
    input.httpPassword = Strings.emptyToNull(input.httpPassword);
    String newPassword;
    if (input.generate) {
        newPassword = generate();
    } else if (input.httpPassword == null) {
        newPassword = null;
    } else {
        // Only administrators can explicitly set the password.
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
        newPassword = input.httpPassword;
    }
    return apply(rsrc.getUser(), newPassword);
}
#end_block

#method_before
@Override
public BinaryResult apply(FileResource rsrc) throws ResourceNotFoundException, IOException, NoSuchChangeException, OrmException {
    String path = rsrc.getPatchKey().get();
    ProjectState projectState = rsrc.getRevision().getControl().getProjectControl().getProjectState();
    ObjectId revstr = ObjectId.fromString(rsrc.getRevision().getPatchSet().getRevision().get());
    return fileContentUtil.downloadContent(projectState, revstr, path, parent);
}
#method_after
@Override
public BinaryResult apply(FileResource rsrc) throws ResourceNotFoundException, IOException, NoSuchChangeException, OrmException {
    String path = rsrc.getPatchKey().get();
    RevisionResource rev = rsrc.getRevision();
    ObjectId revstr = ObjectId.fromString(rev.getPatchSet().getRevision().get());
    return fileContentUtil.downloadContent(projectCache.checkedGet(rev.getProject()), revstr, path, parent);
}
#end_block

#method_before
public void commit(String commitMessage) throws IOException, OrmException, ConfigInvalidException {
    if (toDelete.isEmpty() && toAdd.isEmpty()) {
        return;
    }
    try (Repository repo = repoManager.openRepository(allUsersName);
        RevWalk rw = new RevWalk(repo);
        ObjectInserter ins = repo.newObjectInserter()) {
        ObjectId rev = ExternalIdReader.readRevision(repo);
        NoteMap noteMap = ExternalIdReader.readNoteMap(rw, rev);
        for (ExternalId extId : toDelete) {
            ExternalIdsUpdate.remove(rw, noteMap, extId);
        }
        for (ExternalId extId : toAdd) {
            ExternalIdsUpdate.insert(rw, ins, noteMap, extId);
        }
        ObjectId newRev = ExternalIdsUpdate.commit(repo, rw, ins, rev, noteMap, commitMessage, serverIdent, serverIdent);
        externalIdCache.onReplace(rev, newRev, toDelete, toAdd);
    }
    toAdd.clear();
    toDelete.clear();
}
#method_after
public void commit(String commitMessage) throws IOException, OrmException, ConfigInvalidException {
    if (toDelete.isEmpty() && toAdd.isEmpty()) {
        return;
    }
    try (Repository repo = repoManager.openRepository(allUsersName);
        RevWalk rw = new RevWalk(repo);
        ObjectInserter ins = repo.newObjectInserter()) {
        ObjectId rev = ExternalIdReader.readRevision(repo);
        NoteMap noteMap = ExternalIdReader.readNoteMap(rw, rev);
        for (ExternalId extId : toDelete) {
            ExternalIdsUpdate.remove(rw, noteMap, extId);
        }
        for (ExternalId extId : toAdd) {
            ExternalIdsUpdate.insert(rw, ins, noteMap, extId);
        }
        ObjectId newRev = ExternalIdsUpdate.commit(allUsersName, repo, rw, ins, rev, noteMap, commitMessage, serverIdent, serverIdent, null, gitRefUpdated);
        externalIdCache.onReplace(rev, newRev, toDelete, toAdd);
    }
    toAdd.clear();
    toDelete.clear();
}
#end_block

#method_before
@Override
public SubmitType apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(accountCache, accounts, emails, changeDataFactory.create(db.get(), rsrc.getControl()));
    SubmitTypeRecord rec = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRuleName(), rec));
    }
    return rec.type;
}
#method_after
@Override
public SubmitType apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = submitRuleEvaluatorFactory.create(rsrc.getUser(), changeDataFactory.create(db.get(), rsrc.getNotes()));
    SubmitTypeRecord rec = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRuleName(), rec));
    }
    return rec.type;
}
#end_block

#method_before
public Set<String> getNames() {
    return names.values().stream().map(r -> r.getName()).collect(toSet());
}
#method_after
public Set<String> getNames() {
    return names;
}
#end_block

#method_before
@Override
public Collection<GroupReference> suggest(String name, ProjectState project) {
    String nameLC = name.toLowerCase(Locale.US);
    SortedMap<String, GroupReference> matches = names.tailMap(nameLC);
    if (matches.isEmpty()) {
        return Collections.emptyList();
    }
    List<GroupReference> r = new ArrayList<>(matches.size());
    for (Map.Entry<String, GroupReference> e : matches.entrySet()) {
        if (e.getKey().startsWith(nameLC)) {
            r.add(e.getValue());
        } else {
            break;
        }
    }
    return r;
}
#method_after
@Override
public Collection<GroupReference> suggest(String name, ProjectState project) {
    String nameLC = name.toLowerCase(Locale.US);
    SortedMap<String, GroupReference> matches = namesToGroups.tailMap(nameLC);
    if (matches.isEmpty()) {
        return Collections.emptyList();
    }
    List<GroupReference> r = new ArrayList<>(matches.size());
    for (Map.Entry<String, GroupReference> e : matches.entrySet()) {
        if (e.getKey().startsWith(nameLC)) {
            r.add(e.getValue());
        } else {
            break;
        }
    }
    return r;
}
#end_block

#method_before
@Override
public void check() throws StartupException {
    Map<AccountGroup.UUID, String> configuredNames = new HashMap<>();
    Map<String, AccountGroup.UUID> byLowerCaseConfiguredName = new HashMap<>();
    for (AccountGroup.UUID uuid : all) {
        String configuredName = cfg.getString("groups", uuid.get(), "name");
        if (configuredName != null) {
            configuredNames.put(uuid, configuredName);
            byLowerCaseConfiguredName.put(configuredName.toLowerCase(Locale.US), uuid);
        }
    }
    if (configuredNames.isEmpty()) {
        return;
    }
    for (AccountGroup g : groupCache.all()) {
        String name = g.getName().toLowerCase(Locale.US);
        if (byLowerCaseConfiguredName.keySet().contains(name)) {
            AccountGroup.UUID uuidSystemGroup = byLowerCaseConfiguredName.get(name);
            throw new StartupException(String.format("The configured name '%s' for system group '%s' is ambiguous" + " with the name '%s' of existing group '%s'." + " Please remove/change the value for groups.%s.name in" + " gerrit.config.", configuredNames.get(uuidSystemGroup), uuidSystemGroup.get(), g.getName(), g.getGroupUUID().get(), uuidSystemGroup.get()));
        }
    }
}
#method_after
@Override
public void check() throws StartupException {
    Map<AccountGroup.UUID, String> configuredNames = new HashMap<>();
    Map<String, AccountGroup.UUID> byLowerCaseConfiguredName = new HashMap<>();
    for (AccountGroup.UUID uuid : all) {
        String configuredName = cfg.getString("groups", uuid.get(), "name");
        if (configuredName != null) {
            configuredNames.put(uuid, configuredName);
            byLowerCaseConfiguredName.put(configuredName.toLowerCase(Locale.US), uuid);
        }
    }
    if (configuredNames.isEmpty()) {
        return;
    }
    Optional<InternalGroup> conflictingGroup;
    try (ReviewDb db = schema.open()) {
        conflictingGroup = groups.getAll(db).filter(group -> hasConfiguredName(byLowerCaseConfiguredName, group)).findAny();
    } catch (OrmException ignored) {
        return;
    }
    if (conflictingGroup.isPresent()) {
        InternalGroup group = conflictingGroup.get();
        String groupName = group.getName();
        AccountGroup.UUID systemGroupUuid = byLowerCaseConfiguredName.get(groupName);
        throw new StartupException(getAmbiguousNameMessage(groupName, group.getGroupUUID(), systemGroupUuid));
    }
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws AuthException, BadRequestException, OrmException, IOException, ConfigInvalidException {
    if (!self.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    return reviewersUtil.suggestReviewers(rsrc.getNotes(), this, rsrc.getControl().getProjectControl().getProjectState(), getVisibility(rsrc), excludeGroups);
}
#method_after
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws AuthException, BadRequestException, OrmException, IOException, ConfigInvalidException {
    if (!self.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    return reviewersUtil.suggestReviewers(rsrc.getNotes(), this, projectCache.checkedGet(rsrc.getProject()), getVisibility(rsrc), excludeGroups);
}
#end_block

#method_before
Account findAccount(String nameOrEmailOrId) throws AuthException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    try {
        return accounts.parse(nameOrEmailOrId).getAccount();
    } catch (UnprocessableEntityException e) {
        // not visible
        switch(authType) {
            case HTTP_LDAP:
            case CLIENT_SSL_CERT_LDAP:
            case LDAP:
                if (accountResolver.find(db.get(), nameOrEmailOrId) == null) {
                    // account does not exist, try to create it
                    Account a = createAccountByLdap(nameOrEmailOrId);
                    if (a != null) {
                        return a;
                    }
                }
                break;
            case CUSTOM_EXTENSION:
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            case HTTP:
            case LDAP_BIND:
            case OAUTH:
            case OPENID:
            case OPENID_SSO:
            default:
        }
        throw e;
    }
}
#method_after
Account findAccount(String nameOrEmailOrId) throws AuthException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    try {
        return accounts.parse(nameOrEmailOrId).getAccount();
    } catch (UnprocessableEntityException e) {
        // not visible
        switch(authType) {
            case HTTP_LDAP:
            case CLIENT_SSL_CERT_LDAP:
            case LDAP:
                if (accountResolver.find(nameOrEmailOrId) == null) {
                    // account does not exist, try to create it
                    Account a = createAccountByLdap(nameOrEmailOrId);
                    if (a != null) {
                        return a;
                    }
                }
                break;
            case CUSTOM_EXTENSION:
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            case HTTP:
            case LDAP_BIND:
            case OAUTH:
            case OPENID:
            case OPENID_SSO:
            default:
        }
        throw e;
    }
}
#end_block

#method_before
@Override
public AccountInfo apply(GroupResource resource, PutMember.Input input) throws AuthException, MethodNotAllowedException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    AddMembers.Input in = new AddMembers.Input();
    in._oneMember = id;
    try {
        List<AccountInfo> list = put.apply(resource, in);
        if (list.size() == 1) {
            return list.get(0);
        }
        throw new IllegalStateException();
    } catch (UnprocessableEntityException e) {
        throw new ResourceNotFoundException(id);
    }
}
#method_after
@Override
public AccountInfo apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    AddMembers.Input in = new AddMembers.Input();
    in._oneMember = id;
    try {
        List<AccountInfo> list = put.apply(resource, in);
        if (list.size() == 1) {
            return list.get(0);
        }
        throw new IllegalStateException();
    } catch (UnprocessableEntityException e) {
        throw new ResourceNotFoundException(id);
    }
}
#end_block

#method_before
@Override
public AccountInfo apply(MemberResource resource, PutMember.Input input) throws OrmException {
    // Do nothing, the user is already a member.
    return get.apply(resource);
}
#method_after
@Override
public AccountInfo apply(MemberResource resource, Input input) throws OrmException {
    // Do nothing, the user is already a member.
    return get.apply(resource);
}
#end_block

#method_before
@Override
protected Response<String> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource resource, CommitMessageInput input) throws IOException, UnchangedCommitMessageException, RestApiException, UpdateException, PermissionBackendException, OrmException, ConfigInvalidException {
    PatchSet ps = psUtil.current(db.get(), resource.getNotes());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!resource.getControl().isPatchVisible(ps, db.get())) {
        throw new AuthException("current revision not accessible");
    }
    if (input == null) {
        throw new BadRequestException("input cannot be null");
    }
    String sanitizedCommitMessage = CommitMessageUtil.checkAndSanitizeCommitMessage(input.message);
    ensureCanEditCommitMessage(resource.getNotes());
    ensureChangeIdIsCorrect(resource.getControl().getProjectControl().getProjectState().isRequireChangeID(), resource.getChange().getKey().get(), sanitizedCommitMessage);
    NotifyHandling notify = input.notify;
    if (notify == null) {
        notify = resource.getChange().isWorkInProgress() ? NotifyHandling.OWNER : NotifyHandling.ALL;
    }
    try (Repository repository = repositoryManager.openRepository(resource.getProject());
        RevWalk revWalk = new RevWalk(repository);
        ObjectInserter objectInserter = repository.newObjectInserter()) {
        RevCommit patchSetCommit = revWalk.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        String currentCommitMessage = patchSetCommit.getFullMessage();
        if (input.message.equals(currentCommitMessage)) {
            throw new ResourceConflictException("new and existing commit message are the same");
        }
        Timestamp ts = TimeUtil.nowTs();
        try (BatchUpdate bu = updateFactory.create(db.get(), resource.getChange().getProject(), currentUserProvider.get(), ts)) {
            // Ensure that BatchUpdate will update the same repo
            bu.setRepository(repository, new RevWalk(objectInserter.newReader()), objectInserter);
            PatchSet.Id psId = ChangeUtil.nextPatchSetId(repository, ps.getId());
            ObjectId newCommit = createCommit(objectInserter, patchSetCommit, sanitizedCommitMessage, ts);
            PatchSetInserter inserter = psInserterFactory.create(resource.getNotes(), psId, newCommit);
            inserter.setMessage(String.format("Patch Set %s: Commit message was updated.", psId.getId()));
            inserter.setDescription("Edit commit message");
            inserter.setNotify(notify);
            inserter.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
            bu.addOp(resource.getChange().getId(), inserter);
            bu.execute();
        }
    }
    return Response.ok("ok");
}
#method_after
@Override
protected Response<String> applyImpl(BatchUpdate.Factory updateFactory, ChangeResource resource, CommitMessageInput input) throws IOException, UnchangedCommitMessageException, RestApiException, UpdateException, PermissionBackendException, OrmException, ConfigInvalidException {
    PatchSet ps = psUtil.current(db.get(), resource.getNotes());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    }
    if (input == null) {
        throw new BadRequestException("input cannot be null");
    }
    String sanitizedCommitMessage = CommitMessageUtil.checkAndSanitizeCommitMessage(input.message);
    ensureCanEditCommitMessage(resource.getNotes());
    ensureChangeIdIsCorrect(projectCache.checkedGet(resource.getProject()).isRequireChangeID(), resource.getChange().getKey().get(), sanitizedCommitMessage);
    NotifyHandling notify = input.notify;
    if (notify == null) {
        notify = resource.getChange().isWorkInProgress() ? NotifyHandling.OWNER : NotifyHandling.ALL;
    }
    try (Repository repository = repositoryManager.openRepository(resource.getProject());
        RevWalk revWalk = new RevWalk(repository);
        ObjectInserter objectInserter = repository.newObjectInserter()) {
        RevCommit patchSetCommit = revWalk.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        String currentCommitMessage = patchSetCommit.getFullMessage();
        if (input.message.equals(currentCommitMessage)) {
            throw new ResourceConflictException("new and existing commit message are the same");
        }
        Timestamp ts = TimeUtil.nowTs();
        try (BatchUpdate bu = updateFactory.create(db.get(), resource.getChange().getProject(), currentUserProvider.get(), ts)) {
            // Ensure that BatchUpdate will update the same repo
            bu.setRepository(repository, new RevWalk(objectInserter.newReader()), objectInserter);
            PatchSet.Id psId = ChangeUtil.nextPatchSetId(repository, ps.getId());
            ObjectId newCommit = createCommit(objectInserter, patchSetCommit, sanitizedCommitMessage, ts);
            PatchSetInserter inserter = psInserterFactory.create(resource.getNotes(), psId, newCommit);
            inserter.setMessage(String.format("Patch Set %s: Commit message was updated.", psId.getId()));
            inserter.setDescription("Edit commit message");
            inserter.setNotify(notify);
            inserter.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
            bu.addOp(resource.getChange().getId(), inserter);
            bu.execute();
        }
    }
    return Response.ok("ok");
}
#end_block

#method_before
public void fire(Change change, PatchSet patchSet, Account uploader, Timestamp when, NotifyHandling notify) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        Event event = new Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(uploader), when, notify);
        for (RevisionCreatedListener l : listeners) {
            try {
                l.onRevisionCreated(event);
            } catch (Exception e) {
                util.logEventListenerError(this, l, e);
            }
        }
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException e) {
        log.error("Couldn't fire event", e);
    }
}
#method_after
public void fire(Change change, PatchSet patchSet, Account uploader, Timestamp when, NotifyHandling notify) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        Event event = new Event(util.changeInfo(change), util.revisionInfo(change.getProject(), patchSet), util.accountInfo(uploader), when, notify);
        for (RevisionCreatedListener l : listeners) {
            try {
                l.onRevisionCreated(event);
            } catch (Exception e) {
                util.logEventListenerError(this, l, e);
            }
        }
    } catch (PatchListObjectTooLargeException e) {
        log.warn("Couldn't fire event: " + e.getMessage());
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException | PermissionBackendException e) {
        log.error("Couldn't fire event", e);
    }
}
#end_block

#method_before
public GroupControl controlFor(AccountGroup.Id groupId) throws NoSuchGroupException {
    final AccountGroup group = groupCache.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return controlFor(GroupDescriptions.forAccountGroup(group));
}
#method_after
public GroupControl controlFor(AccountGroup.Id groupId) throws NoSuchGroupException {
    Optional<InternalGroup> group = groupCache.get(groupId);
    return group.map(InternalGroupDescription::new).map(this::controlFor).orElseThrow(() -> new NoSuchGroupException(groupId));
}
#end_block

#method_before
@Override
public Response<String> apply(AccountResource rsrc, Input input) throws ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    return setInactiveFlag.activate(rsrc.getUser());
}
#method_after
@Override
public Response<String> apply(AccountResource rsrc, Input input) throws ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    return setInactiveFlag.activate(rsrc.getUser().getAccountId());
}
#end_block

#method_before
@Override
public MailMessage expectedMailMessage() {
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114da7ae26e2eb053fe0c29c@google.com>").from(new Address("Jonathan Nieder (Gerrit)", "noreply-gerritcodereview-CtTy0igsBrnvL7dKoWEIEg@google.com")).addTo(new Address("ekempin", "ekempin@google.com")).addCc(new Address("Dave Borowitz", "dborowitz@google.com")).addCc(new Address("Jonathan Nieder", "jrn@google.com")).addCc(new Address("Patrick Hiesel", "hiesel@google.com")).textContent(textContent).subject("Change in gerrit[master]: (Re)enable voting buttons for merged changes").dateReceived(new DateTime(2016, 10, 25, 9, 11, 35, 0, DateTimeZone.UTC)).addAdditionalHeader("Authentication-Results: mx.google.com; dkim=pass header.i=@google.com;").addAdditionalHeader("In-Reply-To: <gerrit.1477487889000.Iba501e00bee" + "77be3bd0ced72f88fd04ba0accaed@gerrit-review.googlesource.com>").addAdditionalHeader("References: <gerrit.1477487889000.Iba501e00bee" + "77be3bd0ced72f88fd04ba0accaed@gerrit-review.googlesource.com>");
    return expect.build();
}
#method_after
@Override
public MailMessage expectedMailMessage() {
    MailMessage.Builder expect = MailMessage.builder();
    expect.id("<001a114da7ae26e2eb053fe0c29c@google.com>").from(new Address("Jonathan Nieder (Gerrit)", "noreply-gerritcodereview-CtTy0igsBrnvL7dKoWEIEg@google.com")).addTo(new Address("ekempin", "ekempin@google.com")).addCc(new Address("Dave Borowitz", "dborowitz@google.com")).addCc(new Address("Jonathan Nieder", "jrn@google.com")).addCc(new Address("Patrick Hiesel", "hiesel@google.com")).textContent(textContent).subject("Change in gerrit[master]: (Re)enable voting buttons for merged changes").dateReceived(LocalDateTime.of(2016, Month.OCTOBER, 25, 9, 11, 35).atOffset(ZoneOffset.UTC).toInstant()).addAdditionalHeader("Authentication-Results: mx.google.com; dkim=pass header.i=@google.com;").addAdditionalHeader("In-Reply-To: <gerrit.1477487889000.Iba501e00bee" + "77be3bd0ced72f88fd04ba0accaed@gerrit-review.googlesource.com>").addAdditionalHeader("References: <gerrit.1477487889000.Iba501e00bee" + "77be3bd0ced72f88fd04ba0accaed@gerrit-review.googlesource.com>");
    return expect.build();
}
#end_block

#method_before
@Override
public ConfigInfo apply(ProjectResource resource) {
    return new ConfigInfoImpl(serverEnableSignedPush, resource.getControl(), config, pluginConfigEntries, cfgFactory, allProjects, uiActions, views);
}
#method_after
@Override
public ConfigInfo apply(ProjectResource resource) {
    return new ConfigInfoImpl(serverEnableSignedPush, resource.getProjectState(), resource.getUser(), config, pluginConfigEntries, cfgFactory, allProjects, uiActions, views);
}
#end_block

#method_before
private static Stream<Account.Id> readUserRefs(Repository repo) throws IOException {
    return repo.getRefDatabase().getRefs(RefNames.REFS_USERS).values().stream().map(r -> Account.Id.fromRef(r.getName())).filter(Objects::nonNull);
}
#method_after
public static Stream<Account.Id> readUserRefs(Repository repo) throws IOException {
    return repo.getRefDatabase().getRefs(RefNames.REFS_USERS).values().stream().map(r -> Account.Id.fromRef(r.getName())).filter(Objects::nonNull);
}
#end_block

#method_before
public static Builder defaults() {
    return builder().fastEvalLabels(false).allowDraft(false).allowClosed(false).skipFilters(false).rule(null);
}
#method_after
public static Builder defaults() {
    return builder().allowClosed(false).skipFilters(false).rule(null);
}
#end_block

#method_before
public Builder toBuilder() {
    return builder().fastEvalLabels(fastEvalLabels()).allowDraft(allowDraft()).allowClosed(allowClosed()).skipFilters(skipFilters()).rule(rule());
}
#method_after
public Builder toBuilder() {
    return builder().allowClosed(allowClosed()).skipFilters(skipFilters()).rule(rule());
}
#end_block

#method_before
@Override
public void onPreMerge(Repository repo, CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch, PatchSet.Id patchSetId, IdentifiedUser caller) throws MergeValidationException {
    Account.Id accountId = Account.Id.fromRef(destBranch.get());
    if (!allUsersName.equals(destProject.getNameKey()) || accountId == null) {
        return;
    }
    ChangeData cd = changeDataFactory.create(dbProvider.get(), destProject.getProject().getNameKey(), patchSetId.getParentKey());
    try {
        if (!cd.currentFilePaths().contains(AccountConfig.ACCOUNT_CONFIG)) {
            return;
        }
    } catch (OrmException e) {
        log.error("Cannot validate account update", e);
        throw new MergeValidationException("account validation unavailable");
    }
    try (RevWalk rw = new RevWalk(repo)) {
        List<String> errorMessages = accountValidator.validate(accountId, rw, null, commit);
        if (!errorMessages.isEmpty()) {
            throw new MergeValidationException("invalid account configuration: " + Joiner.on("; ").join(errorMessages));
        }
    } catch (IOException e) {
        log.error("Cannot validate account update", e);
        throw new MergeValidationException("account validation unavailable");
    }
}
#method_after
@Override
public void onPreMerge(Repository repo, CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch, PatchSet.Id patchSetId, IdentifiedUser caller) throws MergeValidationException {
    Account.Id accountId = Account.Id.fromRef(destBranch.get());
    if (!allUsersName.equals(destProject.getNameKey()) || accountId == null) {
        return;
    }
    ChangeData cd = changeDataFactory.create(dbProvider.get(), destProject.getProject().getNameKey(), patchSetId.getParentKey());
    try {
        if (!cd.currentFilePaths().contains(AccountConfig.ACCOUNT_CONFIG)) {
            return;
        }
    } catch (IOException | OrmException e) {
        log.error("Cannot validate account update", e);
        throw new MergeValidationException("account validation unavailable");
    }
    try (RevWalk rw = new RevWalk(repo)) {
        List<String> errorMessages = accountValidator.validate(accountId, rw, null, commit);
        if (!errorMessages.isEmpty()) {
            throw new MergeValidationException("invalid account configuration: " + Joiner.on("; ").join(errorMessages));
        }
    } catch (IOException e) {
        log.error("Cannot validate account update", e);
        throw new MergeValidationException("account validation unavailable");
    }
}
#end_block

#method_before
private static EnumSet<Change.Status> extractStatus(Predicate<ChangeData> in) {
    if (in instanceof ChangeStatusPredicate) {
        return EnumSet.of(((ChangeStatusPredicate) in).getStatus());
    } else if (in instanceof NotPredicate) {
        EnumSet<Status> s = extractStatus(in.getChild(0));
        return s != null ? EnumSet.complementOf(s) : null;
    } else if (in instanceof OrPredicate) {
        EnumSet<Change.Status> r = null;
        int childrenWithStatus = 0;
        for (int i = 0; i < in.getChildCount(); i++) {
            EnumSet<Status> c = extractStatus(in.getChild(i));
            if (c != null) {
                if (r == null) {
                    r = EnumSet.noneOf(Change.Status.class);
                }
                r.addAll(c);
                childrenWithStatus++;
            }
        }
        if (r != null && childrenWithStatus < in.getChildCount()) {
            // the child was used at the root of a query.
            return EnumSet.allOf(Change.Status.class);
        }
        return r;
    } else if (in instanceof AndPredicate) {
        EnumSet<Change.Status> r = null;
        for (int i = 0; i < in.getChildCount(); i++) {
            EnumSet<Change.Status> c = extractStatus(in.getChild(i));
            if (c != null) {
                if (r == null) {
                    r = EnumSet.allOf(Change.Status.class);
                }
                r.retainAll(c);
            }
        }
        return r;
    }
    return null;
}
#method_after
private static EnumSet<Change.Status> extractStatus(Predicate<ChangeData> in) {
    if (in instanceof ChangeStatusPredicate) {
        Status status = ((ChangeStatusPredicate) in).getStatus();
        return status != null ? EnumSet.of(status) : null;
    } else if (in instanceof NotPredicate) {
        EnumSet<Status> s = extractStatus(in.getChild(0));
        return s != null ? EnumSet.complementOf(s) : null;
    } else if (in instanceof OrPredicate) {
        EnumSet<Change.Status> r = null;
        int childrenWithStatus = 0;
        for (int i = 0; i < in.getChildCount(); i++) {
            EnumSet<Status> c = extractStatus(in.getChild(i));
            if (c != null) {
                if (r == null) {
                    r = EnumSet.noneOf(Change.Status.class);
                }
                r.addAll(c);
                childrenWithStatus++;
            }
        }
        if (r != null && childrenWithStatus < in.getChildCount()) {
            // the child was used at the root of a query.
            return EnumSet.allOf(Change.Status.class);
        }
        return r;
    } else if (in instanceof AndPredicate) {
        EnumSet<Change.Status> r = null;
        for (int i = 0; i < in.getChildCount(); i++) {
            EnumSet<Change.Status> c = extractStatus(in.getChild(i));
            if (c != null) {
                if (r == null) {
                    r = EnumSet.allOf(Change.Status.class);
                }
                r.retainAll(c);
            }
        }
        return r;
    }
    return null;
}
#end_block

#method_before
public List<WebLinkInfo> getFileLinks(String project, String revision, String file) {
    return filterLinks(fileLinks, webLink -> webLink.getFileWebLink(project, revision, file));
}
#method_after
public List<WebLinkInfo> getFileLinks(String project, String revision, String file) {
    return Patch.isMagic(file) ? Collections.emptyList() : filterLinks(fileLinks, webLink -> webLink.getFileWebLink(project, revision, file));
}
#end_block

#method_before
public List<WebLinkInfoCommon> getFileHistoryLinks(String project, String revision, String file) {
    return FluentIterable.from(fileHistoryLinks).transform(webLink -> {
        WebLinkInfo info = webLink.getFileHistoryWebLink(project, revision, file);
        if (info == null) {
            return null;
        }
        WebLinkInfoCommon commonInfo = new WebLinkInfoCommon();
        commonInfo.name = info.name;
        commonInfo.imageUrl = info.imageUrl;
        commonInfo.url = info.url;
        commonInfo.target = info.target;
        return commonInfo;
    }).filter(INVALID_WEBLINK_COMMON).toList();
}
#method_after
public List<WebLinkInfoCommon> getFileHistoryLinks(String project, String revision, String file) {
    if (Patch.isMagic(file)) {
        return Collections.emptyList();
    }
    return FluentIterable.from(fileHistoryLinks).transform(webLink -> {
        WebLinkInfo info = webLink.getFileHistoryWebLink(project, revision, file);
        if (info == null) {
            return null;
        }
        WebLinkInfoCommon commonInfo = new WebLinkInfoCommon();
        commonInfo.name = info.name;
        commonInfo.imageUrl = info.imageUrl;
        commonInfo.url = info.url;
        commonInfo.target = info.target;
        return commonInfo;
    }).filter(INVALID_WEBLINK_COMMON).toList();
}
#end_block

#method_before
public List<DiffWebLinkInfo> getDiffLinks(final String project, final int changeId, final Integer patchSetIdA, final String revisionA, final String fileA, final int patchSetIdB, final String revisionB, final String fileB) {
    return FluentIterable.from(diffLinks).transform(webLink -> webLink.getDiffLink(project, changeId, patchSetIdA, revisionA, fileA, patchSetIdB, revisionB, fileB)).filter(INVALID_WEBLINK).toList();
}
#method_after
public List<DiffWebLinkInfo> getDiffLinks(final String project, final int changeId, final Integer patchSetIdA, final String revisionA, final String fileA, final int patchSetIdB, final String revisionB, final String fileB) {
    if (Patch.isMagic(fileA) || Patch.isMagic(fileB)) {
        return Collections.emptyList();
    }
    return FluentIterable.from(diffLinks).transform(webLink -> webLink.getDiffLink(project, changeId, patchSetIdA, revisionA, fileA, patchSetIdB, revisionB, fileB)).filter(INVALID_WEBLINK).toList();
}
#end_block

#method_before
public static List<MailComment> parse(MailMessage email, Collection<Comment> comments, String changeUrl) {
    // TODO(hiesel) Add support for Gmail Mobile
    // TODO(hiesel) Add tests for other popular email clients
    // This parser goes though all html elements in the email and checks for
    // matching patterns. It keeps track of the last file and comments it
    // encountered to know in which context a parsed comment belongs.
    // It uses the href attributes of <a> tags to identify comments sent out by
    // Gerrit as these are generally more reliable then the text captions.
    List<MailComment> parsedComments = new ArrayList<>();
    Document d = Jsoup.parse(email.htmlContent());
    PeekingIterator<Comment> iter = Iterators.peekingIterator(comments.iterator());
    String lastEncounteredFileName = null;
    Comment lastEncounteredComment = null;
    for (Element e : d.body().getAllElements()) {
        String elementName = e.tagName();
        boolean isInBlockQuote = e.parents().stream().filter(p -> p.tagName().equals("blockquote")).findAny().isPresent();
        if (elementName.equals("a")) {
            String href = e.attr("href");
            // this <a> tag
            if (!iter.hasNext()) {
                continue;
            }
            Comment perspectiveComment = iter.peek();
            if (href.equals(ParserUtil.filePath(changeUrl, perspectiveComment))) {
                if (lastEncounteredFileName == null || !lastEncounteredFileName.equals(perspectiveComment.key.filename)) {
                    // Not a file-level comment, but users could have typed a comment
                    // right after this file annotation to create a new file-level
                    // comment. If this file has a file-level comment, we have already
                    // set lastEncounteredComment to that file-level comment when we
                    // encountered the file link and should not reset it now.
                    lastEncounteredFileName = perspectiveComment.key.filename;
                    lastEncounteredComment = null;
                } else if (perspectiveComment.lineNbr == 0) {
                    // This was originally a file-level comment
                    lastEncounteredComment = perspectiveComment;
                    iter.next();
                }
            } else if (ParserUtil.isCommentUrl(href, changeUrl, perspectiveComment)) {
                // This is a regular inline comment
                lastEncounteredComment = perspectiveComment;
                iter.next();
            }
        } else if (!isInBlockQuote && elementName.equals("div") && !e.className().startsWith("gmail")) {
            // This is a comment typed by the user
            // Replace non-breaking spaces and trim string
            String content = e.ownText().replace('\u00a0', ' ').trim();
            if (!Strings.isNullOrEmpty(content)) {
                if (lastEncounteredComment == null && lastEncounteredFileName == null) {
                    // Remove quotation line, email signature and
                    // "Sent from my xyz device"
                    content = ParserUtil.trimQuotation(content);
                    // TODO(hiesel) Add more sanitizer
                    if (!Strings.isNullOrEmpty(content)) {
                        ParserUtil.appendOrAddNewComment(new MailComment(content, null, null, MailComment.CommentType.CHANGE_MESSAGE), parsedComments);
                    }
                } else if (lastEncounteredComment == null) {
                    ParserUtil.appendOrAddNewComment(new MailComment(content, lastEncounteredFileName, null, MailComment.CommentType.FILE_COMMENT), parsedComments);
                } else {
                    ParserUtil.appendOrAddNewComment(new MailComment(content, null, lastEncounteredComment, MailComment.CommentType.INLINE_COMMENT), parsedComments);
                }
            }
        }
    }
    return parsedComments;
}
#method_after
public static List<MailComment> parse(MailMessage email, Collection<Comment> comments, String changeUrl) {
    // TODO(hiesel) Add support for Gmail Mobile
    // TODO(hiesel) Add tests for other popular email clients
    // This parser goes though all html elements in the email and checks for
    // matching patterns. It keeps track of the last file and comments it
    // encountered to know in which context a parsed comment belongs.
    // It uses the href attributes of <a> tags to identify comments sent out by
    // Gerrit as these are generally more reliable then the text captions.
    List<MailComment> parsedComments = new ArrayList<>();
    Document d = Jsoup.parse(email.htmlContent());
    PeekingIterator<Comment> iter = Iterators.peekingIterator(comments.iterator());
    String lastEncounteredFileName = null;
    Comment lastEncounteredComment = null;
    for (Element e : d.body().getAllElements()) {
        String elementName = e.tagName();
        boolean isInBlockQuote = e.parents().stream().filter(p -> p.tagName().equals("blockquote")).findAny().isPresent();
        if (elementName.equals("a")) {
            String href = e.attr("href");
            // this <a> tag
            if (!iter.hasNext()) {
                continue;
            }
            Comment perspectiveComment = iter.peek();
            if (href.equals(ParserUtil.filePath(changeUrl, perspectiveComment))) {
                if (lastEncounteredFileName == null || !lastEncounteredFileName.equals(perspectiveComment.key.filename)) {
                    // Not a file-level comment, but users could have typed a comment
                    // right after this file annotation to create a new file-level
                    // comment. If this file has a file-level comment, we have already
                    // set lastEncounteredComment to that file-level comment when we
                    // encountered the file link and should not reset it now.
                    lastEncounteredFileName = perspectiveComment.key.filename;
                    lastEncounteredComment = null;
                } else if (perspectiveComment.lineNbr == 0) {
                    // This was originally a file-level comment
                    lastEncounteredComment = perspectiveComment;
                    iter.next();
                }
            } else if (ParserUtil.isCommentUrl(href, changeUrl, perspectiveComment)) {
                // This is a regular inline comment
                lastEncounteredComment = perspectiveComment;
                iter.next();
            }
        } else if (!isInBlockQuote && elementName.equals("div") && !MAIL_PROVIDER_EXTRAS.contains(e.className())) {
            // This is a comment typed by the user
            // Replace non-breaking spaces and trim string
            String content = e.ownText().replace('\u00a0', ' ').trim();
            if (!Strings.isNullOrEmpty(content)) {
                if (lastEncounteredComment == null && lastEncounteredFileName == null) {
                    // Remove quotation line, email signature and
                    // "Sent from my xyz device"
                    content = ParserUtil.trimQuotation(content);
                    // TODO(hiesel) Add more sanitizer
                    if (!Strings.isNullOrEmpty(content)) {
                        ParserUtil.appendOrAddNewComment(new MailComment(content, null, null, MailComment.CommentType.CHANGE_MESSAGE), parsedComments);
                    }
                } else if (lastEncounteredComment == null) {
                    ParserUtil.appendOrAddNewComment(new MailComment(content, lastEncounteredFileName, null, MailComment.CommentType.FILE_COMMENT), parsedComments);
                } else {
                    ParserUtil.appendOrAddNewComment(new MailComment(content, null, lastEncounteredComment, MailComment.CommentType.INLINE_COMMENT), parsedComments);
                }
            }
        }
    }
    return parsedComments;
}
#end_block

#method_before
@Override
public void evict(Project p) {
    if (p != null) {
        byName.invalidate(p.getNameKey().get());
    }
}
#method_after
@Override
public void evict(Project p) throws IOException {
    evict(p.getNameKey());
}
#end_block

#method_before
@Override
public void evict(Project.NameKey p) {
    if (p != null) {
        byName.invalidate(p.get());
    }
}
#method_after
@Override
public void evict(Project.NameKey p) throws IOException {
    if (p != null) {
        byName.invalidate(p.get());
    }
    indexer.get().index(p);
}
#end_block

#method_before
@Override
public void remove(Project p) {
    listLock.lock();
    try {
        SortedSet<Project.NameKey> n = Sets.newTreeSet(list.get(ListKey.ALL));
        n.remove(p.getNameKey());
        list.put(ListKey.ALL, Collections.unmodifiableSortedSet(n));
    } catch (ExecutionException e) {
        log.warn("Cannot list available projects", e);
    } finally {
        listLock.unlock();
    }
    evict(p);
}
#method_after
@Override
public void remove(Project p) throws IOException {
    listLock.lock();
    try {
        SortedSet<Project.NameKey> n = Sets.newTreeSet(list.get(ListKey.ALL));
        n.remove(p.getNameKey());
        list.put(ListKey.ALL, Collections.unmodifiableSortedSet(n));
    } catch (ExecutionException e) {
        log.warn("Cannot list available projects", e);
    } finally {
        listLock.unlock();
    }
    evict(p);
}
#end_block

#method_before
@Override
public void onCreateProject(Project.NameKey newProjectName) {
    listLock.lock();
    try {
        SortedSet<Project.NameKey> n = Sets.newTreeSet(list.get(ListKey.ALL));
        n.add(newProjectName);
        list.put(ListKey.ALL, Collections.unmodifiableSortedSet(n));
    } catch (ExecutionException e) {
        log.warn("Cannot list available projects", e);
    } finally {
        listLock.unlock();
    }
}
#method_after
@Override
public void onCreateProject(Project.NameKey newProjectName) throws IOException {
    listLock.lock();
    try {
        SortedSet<Project.NameKey> n = Sets.newTreeSet(list.get(ListKey.ALL));
        n.add(newProjectName);
        list.put(ListKey.ALL, Collections.unmodifiableSortedSet(n));
    } catch (ExecutionException e) {
        log.warn("Cannot list available projects", e);
    } finally {
        listLock.unlock();
    }
    indexer.get().index(newProjectName);
}
#end_block

#method_before
@Override
public ForProject project(Project.NameKey project) {
    try {
        ProjectState state = projectCache.checkedGet(project);
        if (state != null) {
            return state.controlFor(user).asForProject().database(db);
        }
        return FailedPermissionBackend.project("not found");
    } catch (IOException e) {
        return FailedPermissionBackend.project("unavailable", e);
    }
}
#method_after
@Override
public ForProject project(Project.NameKey project) {
    try {
        ProjectState state = projectCache.checkedGet(project);
        if (state != null) {
            return state.controlFor(user).asForProject().database(db);
        }
        return FailedPermissionBackend.project("not found", new NoSuchProjectException(project));
    } catch (IOException e) {
        return FailedPermissionBackend.project("unavailable", e);
    }
}
#end_block

#method_before
private Boolean computeAdmin() {
    Boolean r = user.get(IS_ADMIN);
    if (r == null) {
        if (user.getRealUser() != user) {
            r = false;
        } else if (user instanceof PeerDaemonUser) {
            r = true;
        } else {
            r = allow(capabilities().administrateServer);
        }
        user.put(IS_ADMIN, r);
    }
    return r;
}
#method_after
private Boolean computeAdmin() {
    Boolean r = user.get(IS_ADMIN);
    if (r == null) {
        if (user.isImpersonating()) {
            r = false;
        } else if (user instanceof PeerDaemonUser) {
            r = true;
        } else {
            r = allow(capabilities().administrateServer);
        }
        user.put(IS_ADMIN, r);
    }
    return r;
}
#end_block

#method_before
@Override
public Response<PluginInfo> apply(TopLevelResource resource, InstallPluginInput input) throws BadRequestException, MethodNotAllowedException, IOException {
    if (!loader.isRemoteAdminEnabled()) {
        throw new MethodNotAllowedException("remote installation is disabled");
    }
    try {
        try (InputStream in = openStream(input)) {
            String pluginName = loader.installPluginFromStream(name, in);
            PluginInfo info = ListPlugins.toPluginInfo(loader.get(pluginName));
            return created ? Response.created(info) : Response.ok(info);
        }
    } catch (PluginInstallException e) {
        StringWriter buf = new StringWriter();
        buf.write(String.format("cannot install %s", name));
        if (e.getCause() instanceof ZipException) {
            buf.write(": ");
            buf.write(e.getCause().getMessage());
        } else {
            buf.write(":\n");
            PrintWriter pw = new PrintWriter(buf);
            e.printStackTrace(pw);
            pw.flush();
        }
        throw new BadRequestException(buf.toString());
    }
}
#method_after
@Override
public Response<PluginInfo> apply(TopLevelResource resource, InstallPluginInput input) throws RestApiException, IOException {
    loader.checkRemoteAdminEnabled();
    try {
        try (InputStream in = openStream(input)) {
            String pluginName = loader.installPluginFromStream(name, in);
            PluginInfo info = ListPlugins.toPluginInfo(loader.get(pluginName));
            return created ? Response.created(info) : Response.ok(info);
        }
    } catch (PluginInstallException e) {
        StringWriter buf = new StringWriter();
        buf.write(String.format("cannot install %s", name));
        if (e.getCause() instanceof ZipException) {
            buf.write(": ");
            buf.write(e.getCause().getMessage());
        } else {
            buf.write(":\n");
            PrintWriter pw = new PrintWriter(buf);
            e.printStackTrace(pw);
            pw.flush();
        }
        throw new BadRequestException(buf.toString());
    }
}
#end_block

#method_before
@Override
public Response<PluginInfo> apply(PluginResource resource, InstallPluginInput input) throws BadRequestException, MethodNotAllowedException, IOException {
    return install.get().setName(resource.getName()).apply(TopLevelResource.INSTANCE, input);
}
#method_after
@Override
public Response<PluginInfo> apply(PluginResource resource, InstallPluginInput input) throws RestApiException, IOException {
    return install.get().setName(resource.getName()).apply(TopLevelResource.INSTANCE, input);
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(ProjectResource rsrc, ProjectAccessInput input) throws PermissionBackendException, PermissionDeniedException, IOException, ConfigInvalidException, OrmException, InvalidNameException, UpdateException, RestApiException {
    MetaDataUpdate.User metaDataUpdateUser = metaDataUpdateFactory.get();
    List<AccessSection> removals = setAccess.getAccessSections(input.remove);
    List<AccessSection> additions = setAccess.getAccessSections(input.add);
    PermissionBackend.ForRef metaRef = permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey()).ref(RefNames.REFS_CONFIG);
    try {
        metaRef.check(RefPermission.READ);
    } catch (AuthException denied) {
        throw new PermissionDeniedException(RefNames.REFS_CONFIG + " not visible");
    }
    if (!rsrc.getControl().isOwner()) {
        try {
            metaRef.check(RefPermission.CREATE_CHANGE);
        } catch (AuthException denied) {
            throw new PermissionDeniedException("cannot create change for " + RefNames.REFS_CONFIG);
        }
    }
    Project.NameKey newParentProjectName = input.parent == null ? null : new Project.NameKey(input.parent);
    try (MetaDataUpdate md = metaDataUpdateUser.create(rsrc.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        setAccess.validateChanges(config, removals, additions);
        setAccess.applyChanges(config, removals, additions);
        try {
            setAccess.setParentName(rsrc.getUser().asIdentifiedUser(), config, rsrc.getNameKey(), newParentProjectName, false);
        } catch (AuthException e) {
            throw new IllegalStateException(e);
        }
        md.setMessage("Review access change");
        md.setInsertChangeId(true);
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
        try (ObjectInserter objInserter = md.getRepository().newObjectInserter();
            ObjectReader objReader = objInserter.newReader();
            RevWalk rw = new RevWalk(objReader);
            BatchUpdate bu = updateFactory.create(db.get(), rsrc.getNameKey(), rsrc.getUser(), TimeUtil.nowTs())) {
            bu.setRepository(md.getRepository(), rw, objInserter);
            ChangeInserter ins = changeInserterFactory.create(changeId, commit, RefNames.REFS_CONFIG);
            ins.setMessage("First patchset").setValidate(false).setUpdateRef(false);
            bu.insertChange(ins);
            bu.execute();
            return Response.created(jsonFactory.noOptions().format(ins.getChange()));
        }
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(ProjectResource rsrc, ProjectAccessInput input) throws PermissionBackendException, PermissionDeniedException, IOException, ConfigInvalidException, OrmException, InvalidNameException, UpdateException, RestApiException {
    PermissionBackend.ForProject forProject = permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey());
    if (!check(forProject, ProjectPermission.READ_CONFIG)) {
        throw new PermissionDeniedException(RefNames.REFS_CONFIG + " not visible");
    }
    if (!check(forProject, ProjectPermission.WRITE_CONFIG)) {
        try {
            forProject.ref(RefNames.REFS_CONFIG).check(RefPermission.CREATE_CHANGE);
        } catch (AuthException denied) {
            throw new PermissionDeniedException("cannot create change for " + RefNames.REFS_CONFIG);
        }
    }
    MetaDataUpdate.User metaDataUpdateUser = metaDataUpdateFactory.get();
    List<AccessSection> removals = setAccess.getAccessSections(input.remove);
    List<AccessSection> additions = setAccess.getAccessSections(input.add);
    Project.NameKey newParentProjectName = input.parent == null ? null : new Project.NameKey(input.parent);
    try (MetaDataUpdate md = metaDataUpdateUser.create(rsrc.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        setAccess.validateChanges(config, removals, additions);
        setAccess.applyChanges(config, removals, additions);
        try {
            setAccess.setParentName(rsrc.getUser().asIdentifiedUser(), config, rsrc.getNameKey(), newParentProjectName, false);
        } catch (AuthException e) {
            throw new IllegalStateException(e);
        }
        md.setMessage("Review access change");
        md.setInsertChangeId(true);
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
        try (ObjectInserter objInserter = md.getRepository().newObjectInserter();
            ObjectReader objReader = objInserter.newReader();
            RevWalk rw = new RevWalk(objReader);
            BatchUpdate bu = updateFactory.create(db.get(), rsrc.getNameKey(), rsrc.getUser(), TimeUtil.nowTs())) {
            bu.setRepository(md.getRepository(), rw, objInserter);
            ChangeInserter ins = newInserter(changeId, commit);
            bu.insertChange(ins);
            bu.execute();
            return Response.created(jsonFactory.noOptions().format(ins.getChange()));
        }
    }
}
#end_block

#method_before
public String getApprovals() {
    try {
        Table<Account.Id, String, PatchSetApproval> pos = HashBasedTable.create();
        Table<Account.Id, String, PatchSetApproval> neg = HashBasedTable.create();
        for (PatchSetApproval ca : args.approvalsUtil.byPatchSet(args.db.get(), changeData.notes(), changeData.changeControl().getUser(), patchSet.getId(), null, null)) {
            LabelType lt = labelTypes.byLabel(ca.getLabelId());
            if (lt == null) {
                continue;
            }
            if (ca.getValue() > 0) {
                pos.put(ca.getAccountId(), lt.getName(), ca);
            } else if (ca.getValue() < 0) {
                neg.put(ca.getAccountId(), lt.getName(), ca);
            }
        }
        return format("Approvals", pos) + format("Objections", neg);
    } catch (OrmException err) {
    // Don't list the approvals
    }
    return "";
}
#method_after
public String getApprovals() {
    try {
        Table<Account.Id, String, PatchSetApproval> pos = HashBasedTable.create();
        Table<Account.Id, String, PatchSetApproval> neg = HashBasedTable.create();
        for (PatchSetApproval ca : args.approvalsUtil.byPatchSet(args.db.get(), changeData.notes(), args.identifiedUserFactory.create(changeData.change().getOwner()), patchSet.getId(), null, null)) {
            LabelType lt = labelTypes.byLabel(ca.getLabelId());
            if (lt == null) {
                continue;
            }
            if (ca.getValue() > 0) {
                pos.put(ca.getAccountId(), lt.getName(), ca);
            } else if (ca.getValue() < 0) {
                neg.put(ca.getAccountId(), lt.getName(), ca);
            }
        }
        return format("Approvals", pos) + format("Objections", neg);
    } catch (OrmException err) {
    // Don't list the approvals
    }
    return "";
}
#end_block

#method_before
public String generate(RevCommit original, RevCommit mergeTip, ChangeControl ctl, String current) {
    checkNotNull(original.getRawBuffer());
    if (mergeTip != null) {
        checkNotNull(mergeTip.getRawBuffer());
    }
    for (ChangeMessageModifier changeMessageModifier : changeMessageModifiers) {
        current = changeMessageModifier.onSubmit(current, original, mergeTip, ctl.getChange().getDest());
        checkNotNull(current, changeMessageModifier.getClass().getName() + ".OnSubmit returned null instead of new commit message");
    }
    return current;
}
#method_after
public String generate(RevCommit original, RevCommit mergeTip, Branch.NameKey dest, String current) {
    checkNotNull(original.getRawBuffer());
    if (mergeTip != null) {
        checkNotNull(mergeTip.getRawBuffer());
    }
    for (ChangeMessageModifier changeMessageModifier : changeMessageModifiers) {
        current = changeMessageModifier.onSubmit(current, original, mergeTip, dest);
        checkNotNull(current, changeMessageModifier.getClass().getName() + ".OnSubmit returned null instead of new commit message");
    }
    return current;
}
#end_block

#method_before
private String createDetailedCommitMessage(RevCommit n, ChangeControl ctl, PatchSet.Id psId) {
    Change c = ctl.getChange();
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, FooterConstants.CHANGE_ID, c.getKey().get())) {
        msgbuf.append(FooterConstants.CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(c.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + c.getId().get();
        if (!contains(footers, FooterConstants.REVIEWED_ON, url)) {
            msgbuf.append(FooterConstants.REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    for (PatchSetApproval a : safeGetApprovals(ctl.getNotes(), ctl.getUser(), psId)) {
        if (a.getValue() <= 0) {
            // Negative votes aren't counted.
            continue;
        }
        if (a.isLegacySubmit()) {
            // 
            if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                submitAudit = a;
            }
            continue;
        }
        final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
        final StringBuilder identbuf = new StringBuilder();
        if (acc.getFullName() != null && acc.getFullName().length() > 0) {
            if (identbuf.length() > 0) {
                identbuf.append(' ');
            }
            identbuf.append(acc.getFullName());
        }
        if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
            if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                continue;
            }
            if (identbuf.length() > 0) {
                identbuf.append(' ');
            }
            identbuf.append('<');
            identbuf.append(acc.getPreferredEmail());
            identbuf.append('>');
        }
        if (identbuf.length() == 0) {
            // Nothing reasonable to describe them by? Ignore them.
            continue;
        }
        final String tag;
        if (isCodeReview(a.getLabelId())) {
            tag = "Reviewed-by";
        } else if (isVerified(a.getLabelId())) {
            tag = "Tested-by";
        } else {
            final LabelType lt = project.getLabelTypes().byLabel(a.getLabelId());
            if (lt == null) {
                continue;
            }
            tag = lt.getName();
        }
        if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
            msgbuf.append(tag);
            msgbuf.append(": ");
            msgbuf.append(identbuf);
            msgbuf.append('\n');
        }
    }
    return msgbuf.toString();
}
#method_after
private String createDetailedCommitMessage(RevCommit n, ChangeNotes notes, CurrentUser user, PatchSet.Id psId) {
    Change c = notes.getChange();
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, FooterConstants.CHANGE_ID, c.getKey().get())) {
        msgbuf.append(FooterConstants.CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(c.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + c.getId().get();
        if (!contains(footers, FooterConstants.REVIEWED_ON, url)) {
            msgbuf.append(FooterConstants.REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    for (PatchSetApproval a : safeGetApprovals(notes, user, psId)) {
        if (a.getValue() <= 0) {
            // Negative votes aren't counted.
            continue;
        }
        if (a.isLegacySubmit()) {
            // 
            if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                submitAudit = a;
            }
            continue;
        }
        final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
        final StringBuilder identbuf = new StringBuilder();
        if (acc.getFullName() != null && acc.getFullName().length() > 0) {
            if (identbuf.length() > 0) {
                identbuf.append(' ');
            }
            identbuf.append(acc.getFullName());
        }
        if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
            if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                continue;
            }
            if (identbuf.length() > 0) {
                identbuf.append(' ');
            }
            identbuf.append('<');
            identbuf.append(acc.getPreferredEmail());
            identbuf.append('>');
        }
        if (identbuf.length() == 0) {
            // Nothing reasonable to describe them by? Ignore them.
            continue;
        }
        final String tag;
        if (isCodeReview(a.getLabelId())) {
            tag = "Reviewed-by";
        } else if (isVerified(a.getLabelId())) {
            tag = "Tested-by";
        } else {
            final LabelType lt = project.getLabelTypes().byLabel(a.getLabelId());
            if (lt == null) {
                continue;
            }
            tag = lt.getName();
        }
        if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
            msgbuf.append(tag);
            msgbuf.append(": ");
            msgbuf.append(identbuf);
            msgbuf.append('\n');
        }
    }
    return msgbuf.toString();
}
#end_block

#method_before
public String createCommitMessageOnSubmit(CodeReviewCommit n, RevCommit mergeTip) {
    return createCommitMessageOnSubmit(n, mergeTip, n.getControl(), n.getPatchsetId());
}
#method_after
public String createCommitMessageOnSubmit(CodeReviewCommit n, RevCommit mergeTip) {
    return createCommitMessageOnSubmit(n, mergeTip, n.notes(), identifiedUserFactory.create(n.notes().getChange().getOwner()), n.getPatchsetId());
}
#end_block

#method_before
public String createCommitMessageOnSubmit(RevCommit n, RevCommit mergeTip, ChangeControl ctl, Id id) {
    return commitMessageGenerator.generate(n, mergeTip, ctl, createDetailedCommitMessage(n, ctl, id));
}
#method_after
public String createCommitMessageOnSubmit(RevCommit n, RevCommit mergeTip, ChangeNotes notes, CurrentUser user, Id id) {
    return commitMessageGenerator.generate(n, mergeTip, notes.getChange().getDest(), createDetailedCommitMessage(n, notes, user, id));
}
#end_block

#method_before
public CodeReviewCommit writeMergeCommit(PersonIdent author, PersonIdent committer, CodeReviewRevWalk rw, ObjectInserter inserter, Branch.NameKey destBranch, CodeReviewCommit mergeTip, ObjectId treeId, CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    CodeReviewCommit crc;
    while ((crc = rw.next()) != null) {
        if (crc.getPatchsetId() != null) {
            merged.add(crc);
        }
    }
    StringBuilder msgbuf = new StringBuilder().append(summarize(rw, merged));
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(treeId);
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(author);
    mergeCommit.setCommitter(committer);
    mergeCommit.setMessage(msgbuf.toString());
    CodeReviewCommit mergeResult = rw.parseCommit(inserter.insert(mergeCommit));
    mergeResult.setControl(n.getControl());
    return mergeResult;
}
#method_after
public CodeReviewCommit writeMergeCommit(PersonIdent author, PersonIdent committer, CodeReviewRevWalk rw, ObjectInserter inserter, Branch.NameKey destBranch, CodeReviewCommit mergeTip, ObjectId treeId, CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<>();
    rw.reset();
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    CodeReviewCommit crc;
    while ((crc = rw.next()) != null) {
        if (crc.getPatchsetId() != null) {
            merged.add(crc);
        }
    }
    StringBuilder msgbuf = new StringBuilder().append(summarize(rw, merged));
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(treeId);
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(author);
    mergeCommit.setCommitter(committer);
    mergeCommit.setMessage(msgbuf.toString());
    CodeReviewCommit mergeResult = rw.parseCommit(inserter.insert(mergeCommit));
    mergeResult.setNotes(n.getNotes());
    return mergeResult;
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), permissionBackend, changeControlGenericFactory, notesFactory, changeDataFactory, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts, notesMigration);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), permissionBackend, notesFactory, changeDataFactory, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts, notesMigration);
}
#end_block

#method_before
IdentifiedUser getIdentifiedUser() throws QueryParseException {
    try {
        CurrentUser u = getUser();
        if (u.isIdentifiedUser()) {
            return u.asIdentifiedUser();
        }
        throw new QueryParseException(NotSignedInException.MESSAGE);
    } catch (ProvisionException e) {
        throw new QueryParseException(NotSignedInException.MESSAGE, e);
    }
}
#method_after
IdentifiedUser getIdentifiedUser() throws QueryRequiresAuthException {
    try {
        CurrentUser u = getUser();
        if (u.isIdentifiedUser()) {
            return u.asIdentifiedUser();
        }
        throw new QueryRequiresAuthException(NotSignedInException.MESSAGE);
    } catch (ProvisionException e) {
        throw new QueryRequiresAuthException(NotSignedInException.MESSAGE, e);
    }
}
#end_block

#method_before
CurrentUser getUser() throws QueryParseException {
    try {
        return self.get();
    } catch (ProvisionException e) {
        throw new QueryParseException(NotSignedInException.MESSAGE, e);
    }
}
#method_after
CurrentUser getUser() throws QueryRequiresAuthException {
    try {
        return self.get();
    } catch (ProvisionException e) {
        throw new QueryRequiresAuthException(NotSignedInException.MESSAGE, e);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> change(String query) throws QueryParseException {
    Optional<ChangeTriplet> triplet = ChangeTriplet.parse(query);
    if (triplet.isPresent()) {
        return Predicate.and(project(triplet.get().project().get()), branch(triplet.get().branch().get()), new ChangeIdPredicate(parseChangeId(triplet.get().id().get())));
    }
    if (PAT_LEGACY_ID.matcher(query).matches()) {
        return new LegacyChangeIdPredicate(Change.Id.parse(query));
    } else if (PAT_CHANGE_ID.matcher(query).matches()) {
        return new ChangeIdPredicate(parseChangeId(query));
    }
    throw new QueryParseException("Invalid change format");
}
#method_after
@Operator
public Predicate<ChangeData> change(String query) throws QueryParseException {
    Optional<ChangeTriplet> triplet = ChangeTriplet.parse(query);
    if (triplet.isPresent()) {
        return Predicate.and(project(triplet.get().project().get()), branch(triplet.get().branch().get()), new ChangeIdPredicate(parseChangeId(triplet.get().id().get())));
    }
    if (PAT_LEGACY_ID.matcher(query).matches()) {
        Integer id = Ints.tryParse(query);
        if (id != null) {
            return new LegacyChangeIdPredicate(new Change.Id(id));
        }
    } else if (PAT_CHANGE_ID.matcher(query).matches()) {
        return new ChangeIdPredicate(parseChangeId(query));
    }
    throw new QueryParseException("Invalid change format");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> status(String statusName) throws QueryParseException {
    if ("reviewed".equalsIgnoreCase(statusName)) {
        return IsReviewedPredicate.create();
    }
    return ChangeStatusPredicate.parse(statusName);
}
#method_after
@Operator
public Predicate<ChangeData> status(String statusName) {
    if ("reviewed".equalsIgnoreCase(statusName)) {
        return IsReviewedPredicate.create();
    }
    return ChangeStatusPredicate.parse(statusName);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP)), ReviewerPredicate.reviewer(args, self()));
        }
        return ReviewerPredicate.reviewer(args, self());
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(args, self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE);
    }
    if ("private".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.PRIVATE)) {
            return new BooleanPredicate(ChangeField.PRIVATE);
        }
        throw new QueryParseException("'is:private' operator is not supported by change index version");
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    if ("ignored".equalsIgnoreCase(value)) {
        return star("ignore");
    }
    if ("started".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.STARTED)) {
            return new BooleanPredicate(ChangeField.STARTED);
        }
        throw new QueryParseException("'is:started' operator is not supported by change index version");
    }
    if ("wip".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return new BooleanPredicate(ChangeField.WIP);
        }
        throw new QueryParseException("'is:wip' operator is not supported by change index version");
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP)), ReviewerPredicate.reviewer(args, self()));
        }
        return ReviewerPredicate.reviewer(args, self());
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE);
    }
    if ("private".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.PRIVATE)) {
            return new BooleanPredicate(ChangeField.PRIVATE);
        }
        throw new QueryParseException("'is:private' operator is not supported by change index version");
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    if ("ignored".equalsIgnoreCase(value)) {
        return star("ignore");
    }
    if ("started".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.STARTED)) {
            return new BooleanPredicate(ChangeField.STARTED);
        }
        throw new QueryParseException("'is:started' operator is not supported by change index version");
    }
    if ("wip".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return new BooleanPredicate(ChangeField.WIP);
        }
        throw new QueryParseException("'is:wip' operator is not supported by change index version");
    }
    return status(value);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    // Special case: votes by owners can be tracked with ",owner":
    // label:Code-Review+2,owner
    // label:Code-Review+2,user=owner
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                if (pair.getValue().equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(pair.getValue());
                }
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                if (value.equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(value);
                }
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found", e);
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = args.listMembers.get().setRecursive(true).apply(group).stream().map(a -> new Account.Id(a._accountId)).collect(toSet());
        int maxLimit = args.indexConfig.maxLimit();
        if (allMembers.size() > maxLimit) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxLimit));
        } else {
            accounts = allMembers;
        }
    }
    // If the vote piece looks like Code-Review=NEED with a valid non-numeric
    // submit record status, interpret as a submit record query.
    int eq = name.indexOf('=');
    if (args.getSchema().hasField(ChangeField.SUBMIT_RECORD) && eq > 0) {
        String statusName = name.substring(eq + 1).toUpperCase();
        if (!isInt(statusName)) {
            SubmitRecord.Label.Status status = Enums.getIfPresent(SubmitRecord.Label.Status.class, statusName).orNull();
            if (status == null) {
                throw error("Invalid label status " + statusName + " in " + name);
            }
            return SubmitRecordPredicate.create(name.substring(0, eq), status, accounts);
        }
    }
    return new LabelPredicate(args, name, accounts, group);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    // Special case: votes by owners can be tracked with ",owner":
    // label:Code-Review+2,owner
    // label:Code-Review+2,user=owner
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                if (pair.getValue().equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(pair.getValue());
                }
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                if (value.equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(value);
                }
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found", e);
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = args.listMembers.get().getTransitiveMembers(group).stream().map(a -> new Account.Id(a._accountId)).collect(toSet());
        int maxLimit = args.indexConfig.maxLimit();
        if (allMembers.size() > maxLimit) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxLimit));
        } else {
            accounts = allMembers;
        }
    }
    // If the vote piece looks like Code-Review=NEED with a valid non-numeric
    // submit record status, interpret as a submit record query.
    int eq = name.indexOf('=');
    if (args.getSchema().hasField(ChangeField.SUBMIT_RECORD) && eq > 0) {
        String statusName = name.substring(eq + 1).toUpperCase();
        if (!isInt(statusName)) {
            SubmitRecord.Label.Status status = Enums.getIfPresent(SubmitRecord.Label.Status.class, statusName).orNull();
            if (status == null) {
                throw error("Invalid label status " + statusName + " in " + name);
            }
            return SubmitRecordPredicate.create(name.substring(0, eq), status, accounts);
        }
    }
    return new LabelPredicate(args, name, accounts, group);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    if (isSelf(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    if (isSelf(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
public Predicate<ChangeData> visibleto(CurrentUser user) {
    return new ChangeIsVisibleToPredicate(args.db, args.notesFactory, args.changeControlGenericFactory, user, args.permissionBackend);
}
#method_after
public Predicate<ChangeData> visibleto(CurrentUser user) {
    return new ChangeIsVisibleToPredicate(args.db, args.notesFactory, user, args.permissionBackend);
}
#end_block

#method_before
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    if (isSelf(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#method_after
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    if (isSelf(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#end_block

#method_before
public Predicate<ChangeData> reviewerByState(String who, ReviewerStateInternal state, boolean forDefaultField) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    Predicate<ChangeData> reviewerByEmailPredicate = null;
    if (args.index.getSchema().hasField(ChangeField.REVIEWER_BY_EMAIL)) {
        Address address = Address.tryParse(who);
        if (address != null) {
            reviewerByEmailPredicate = ReviewerByEmailPredicate.forState(args, address, state);
        }
    }
    Predicate<ChangeData> reviewerPredicate = null;
    try {
        Set<Account.Id> accounts = parseAccount(who);
        if (!forDefaultField || accounts.size() <= MAX_ACCOUNTS_PER_DEFAULT_FIELD) {
            reviewerPredicate = Predicate.or(accounts.stream().map(id -> ReviewerPredicate.forState(args, id, state)).collect(toList()));
        }
    } catch (QueryParseException e) {
        // Propagate this exception only if we can't use 'who' to query by email
        if (reviewerByEmailPredicate == null) {
            throw e;
        }
    }
    if (reviewerPredicate != null && reviewerByEmailPredicate != null) {
        return Predicate.or(reviewerPredicate, reviewerByEmailPredicate);
    } else if (reviewerPredicate != null) {
        return reviewerPredicate;
    } else if (reviewerByEmailPredicate != null) {
        return reviewerByEmailPredicate;
    } else {
        return Predicate.any();
    }
}
#method_after
public Predicate<ChangeData> reviewerByState(String who, ReviewerStateInternal state, boolean forDefaultField) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    Predicate<ChangeData> reviewerByEmailPredicate = null;
    if (args.index.getSchema().hasField(ChangeField.REVIEWER_BY_EMAIL)) {
        Address address = Address.tryParse(who);
        if (address != null) {
            reviewerByEmailPredicate = ReviewerByEmailPredicate.forState(address, state);
        }
    }
    Predicate<ChangeData> reviewerPredicate = null;
    try {
        Set<Account.Id> accounts = parseAccount(who);
        if (!forDefaultField || accounts.size() <= MAX_ACCOUNTS_PER_DEFAULT_FIELD) {
            reviewerPredicate = Predicate.or(accounts.stream().map(id -> ReviewerPredicate.forState(id, state)).collect(toList()));
        }
    } catch (QueryParseException e) {
        // Propagate this exception only if we can't use 'who' to query by email
        if (reviewerByEmailPredicate == null) {
            throw e;
        }
    }
    if (reviewerPredicate != null && reviewerByEmailPredicate != null) {
        return Predicate.or(reviewerPredicate, reviewerByEmailPredicate);
    } else if (reviewerPredicate != null) {
        return reviewerPredicate;
    } else if (reviewerByEmailPredicate != null) {
        return reviewerByEmailPredicate;
    } else {
        return Predicate.any();
    }
}
#end_block

#method_before
@Override
public Response<String> apply(ProjectResource resource, DescriptionInput input) throws AuthException, ResourceConflictException, ResourceNotFoundException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new DescriptionInput();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = ctl.getUser().asIdentifiedUser();
    if (!ctl.isOwner()) {
        throw new AuthException("not project owner");
    }
    try (MetaDataUpdate md = updateFactory.create(resource.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        project.setDescription(Strings.emptyToNull(input.description));
        String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(user);
        md.setMessage(msg);
        config.commit(md);
        cache.evict(ctl.getProject());
        md.getRepository().setGitwebDescription(project.getDescription());
        return Strings.isNullOrEmpty(project.getDescription()) ? Response.<String>none() : Response.ok(project.getDescription());
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#method_after
@Override
public Response<String> apply(ProjectResource resource, DescriptionInput input) throws AuthException, ResourceConflictException, ResourceNotFoundException, IOException, PermissionBackendException {
    if (input == null) {
        // Delete would set description to null.
        input = new DescriptionInput();
    }
    IdentifiedUser user = resource.getUser().asIdentifiedUser();
    permissionBackend.user(user).project(resource.getNameKey()).check(ProjectPermission.WRITE_CONFIG);
    try (MetaDataUpdate md = updateFactory.create(resource.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        project.setDescription(Strings.emptyToNull(input.description));
        String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(user);
        md.setMessage(msg);
        config.commit(md);
        cache.evict(resource.getProjectState().getProject());
        md.getRepository().setGitwebDescription(project.getDescription());
        return Strings.isNullOrEmpty(project.getDescription()) ? Response.<String>none() : Response.ok(project.getDescription());
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    List<AccountGroup> accountGroups = db.accountGroups().all().toList();
    for (AccountGroup accountGroup : accountGroups) {
        ResultSet<AccountGroupMemberAudit> groupMemberAudits = db.accountGroupMembersAudit().byGroup(accountGroup.getId());
        Optional<Timestamp> firstTimeMentioned = Streams.stream(groupMemberAudits).map(AccountGroupMemberAudit::getKey).map(Key::getAddedOn).min(Comparator.naturalOrder());
        Timestamp createdOn = firstTimeMentioned.orElseGet(() -> AccountGroup.auditCreationInstantTs());
        accountGroup.setCreatedOn(createdOn);
    }
    db.accountGroups().update(accountGroups);
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    try (PreparedStatement groupUpdate = prepareStatement(db, "UPDATE account_groups SET created_on = ? WHERE group_id = ?");
        PreparedStatement addedOnRetrieval = prepareStatement(db, "SELECT added_on FROM account_group_members_audit WHERE group_id = ?" + " ORDER BY added_on ASC")) {
        List<AccountGroup.Id> accountGroups = getAllGroupIds(db);
        for (AccountGroup.Id groupId : accountGroups) {
            Optional<Timestamp> firstTimeMentioned = getFirstTimeMentioned(addedOnRetrieval, groupId);
            Timestamp createdOn = firstTimeMentioned.orElseGet(AccountGroup::auditCreationInstantTs);
            groupUpdate.setTimestamp(1, createdOn);
            groupUpdate.setInt(2, groupId.get());
            groupUpdate.executeUpdate();
        }
    }
}
#end_block

#method_before
public SortedMap<String, ProjectInfo> display(@Nullable OutputStream displayOutputStream) throws BadRequestException, PermissionBackendException {
    if (groupUuid != null) {
        try {
            if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                return Collections.emptySortedMap();
            }
        } catch (NoSuchGroupException ex) {
            return Collections.emptySortedMap();
        }
    }
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, UTF_8)));
    }
    if (type == FilterType.PARENT_CANDIDATES) {
        // Historically, PARENT_CANDIDATES implied showDescription.
        showDescription = true;
    }
    int foundIndex = 0;
    int found = 0;
    TreeMap<String, ProjectInfo> output = new TreeMap<>();
    Map<String, String> hiddenNames = new HashMap<>();
    Map<Project.NameKey, Boolean> accessibleParents = new HashMap<>();
    PermissionBackend.WithUser perm = permissionBackend.user(currentUser);
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<>();
    try {
        for (Project.NameKey projectName : filter(perm)) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null || (!all && e.getProject().getState() == HIDDEN)) {
                // If all wasn't selected, and its HIDDEN, pretend its not present.
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (groupUuid != null && !pctl.getLocalGroups().contains(GroupReference.forGroup(groupsCollection.parseId(groupUuid.get())))) {
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (showTree && !format.isJson()) {
                treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), true));
                continue;
            }
            info.name = projectName.get();
            if (showTree && format.isJson()) {
                ProjectState parent = Iterables.getFirst(e.parents(), null);
                if (parent != null) {
                    if (isParentAccessible(accessibleParents, perm, parent)) {
                        info.parent = parent.getName();
                    } else {
                        info.parent = hiddenNames.get(parent.getName());
                        if (info.parent == null) {
                            info.parent = "?-" + (hiddenNames.size() + 1);
                            hiddenNames.put(parent.getName(), info.parent);
                        }
                    }
                }
            }
            if (showDescription) {
                info.description = Strings.emptyToNull(e.getProject().getDescription());
            }
            info.state = e.getProject().getState();
            try {
                if (!showBranch.isEmpty()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                        List<Ref> refs = getBranchRefs(projectName, pctl);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (int i = 0; i < showBranch.size(); i++) {
                            Ref ref = refs.get(i);
                            if (ref != null && ref.getObjectId() != null) {
                                if (info.branches == null) {
                                    info.branches = new LinkedHashMap<>();
                                }
                                info.branches.put(showBranch.get(i), ref.getObjectId().name());
                            }
                        }
                    }
                } else if (!showTree && type.useMatch()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                log.warn("Unexpected error reading " + projectName, err);
                continue;
            }
            if (type != FilterType.PARENT_CANDIDATES) {
                List<WebLinkInfo> links = webLinks.getProjectLinks(projectName.get());
                info.webLinks = links.isEmpty() ? null : links;
            }
            if (foundIndex++ < start) {
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (!showBranch.isEmpty()) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        for (ProjectInfo info : output.values()) {
            info.id = Url.encode(info.name);
            info.name = null;
        }
        if (stdout == null) {
            return output;
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#method_after
public SortedMap<String, ProjectInfo> display(@Nullable OutputStream displayOutputStream) throws BadRequestException, PermissionBackendException {
    if (groupUuid != null) {
        try {
            if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                return Collections.emptySortedMap();
            }
        } catch (NoSuchGroupException ex) {
            return Collections.emptySortedMap();
        }
    }
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, UTF_8)));
    }
    if (type == FilterType.PARENT_CANDIDATES) {
        // Historically, PARENT_CANDIDATES implied showDescription.
        showDescription = true;
    }
    int foundIndex = 0;
    int found = 0;
    TreeMap<String, ProjectInfo> output = new TreeMap<>();
    Map<String, String> hiddenNames = new HashMap<>();
    Map<Project.NameKey, Boolean> accessibleParents = new HashMap<>();
    PermissionBackend.WithUser perm = permissionBackend.user(currentUser);
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<>();
    try {
        for (Project.NameKey projectName : filter(perm)) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null || (!all && e.getProject().getState() == HIDDEN)) {
                // If all wasn't selected, and its HIDDEN, pretend its not present.
                continue;
            }
            if (groupUuid != null && !e.getLocalGroups().contains(GroupReference.forGroup(groupsCollection.parseId(groupUuid.get())))) {
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (showTree && !format.isJson()) {
                treeMap.put(projectName, projectNodeFactory.create(e.getProject(), true));
                continue;
            }
            info.name = projectName.get();
            if (showTree && format.isJson()) {
                ProjectState parent = Iterables.getFirst(e.parents(), null);
                if (parent != null) {
                    if (isParentAccessible(accessibleParents, perm, parent)) {
                        info.parent = parent.getName();
                    } else {
                        info.parent = hiddenNames.get(parent.getName());
                        if (info.parent == null) {
                            info.parent = "?-" + (hiddenNames.size() + 1);
                            hiddenNames.put(parent.getName(), info.parent);
                        }
                    }
                }
            }
            if (showDescription) {
                info.description = Strings.emptyToNull(e.getProject().getDescription());
            }
            info.state = e.getProject().getState();
            try {
                if (!showBranch.isEmpty()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                        boolean canReadAllRefs;
                        try {
                            permissionBackend.user(currentUser).project(e.getNameKey()).check(ProjectPermission.READ);
                            canReadAllRefs = true;
                        } catch (AuthException ae) {
                            canReadAllRefs = false;
                        }
                        List<Ref> refs = getBranchRefs(projectName, canReadAllRefs);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (int i = 0; i < showBranch.size(); i++) {
                            Ref ref = refs.get(i);
                            if (ref != null && ref.getObjectId() != null) {
                                if (info.branches == null) {
                                    info.branches = new LinkedHashMap<>();
                                }
                                info.branches.put(showBranch.get(i), ref.getObjectId().name());
                            }
                        }
                    }
                } else if (!showTree && type.useMatch()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                log.warn("Unexpected error reading " + projectName, err);
                continue;
            }
            if (type != FilterType.PARENT_CANDIDATES) {
                List<WebLinkInfo> links = webLinks.getProjectLinks(projectName.get());
                info.webLinks = links.isEmpty() ? null : links;
            }
            if (foundIndex++ < start) {
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (!showBranch.isEmpty()) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        for (ProjectInfo info : output.values()) {
            info.id = Url.encode(info.name);
            info.name = null;
        }
        if (stdout == null) {
            return output;
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#end_block

#method_before
private List<Ref> getBranchRefs(Project.NameKey projectName, ProjectControl projectControl) {
    Ref[] result = new Ref[showBranch.size()];
    try (Repository git = repoManager.openRepository(projectName)) {
        PermissionBackend.ForProject perm = permissionBackend.user(currentUser).project(projectName);
        for (int i = 0; i < showBranch.size(); i++) {
            Ref ref = git.findRef(showBranch.get(i));
            if (all && projectControl.isOwner()) {
                result[i] = ref;
            } else if (ref != null && ref.getObjectId() != null) {
                try {
                    perm.ref(ref.getLeaf().getName()).check(RefPermission.READ);
                    result[i] = ref;
                } catch (AuthException e) {
                    continue;
                }
            }
        }
    } catch (IOException | PermissionBackendException e) {
    // Fall through and return what is available.
    }
    return Arrays.asList(result);
}
#method_after
private List<Ref> getBranchRefs(Project.NameKey projectName, boolean canReadAllRefs) {
    Ref[] result = new Ref[showBranch.size()];
    try (Repository git = repoManager.openRepository(projectName)) {
        PermissionBackend.ForProject perm = permissionBackend.user(currentUser).project(projectName);
        for (int i = 0; i < showBranch.size(); i++) {
            Ref ref = git.findRef(showBranch.get(i));
            if (all && canReadAllRefs) {
                result[i] = ref;
            } else if (ref != null && ref.getObjectId() != null) {
                try {
                    perm.ref(ref.getLeaf().getName()).check(RefPermission.READ);
                    result[i] = ref;
                } catch (AuthException e) {
                    continue;
                }
            }
        }
    } catch (IOException | PermissionBackendException e) {
    // Fall through and return what is available.
    }
    return Arrays.asList(result);
}
#end_block

#method_before
@Operator
public Predicate<AccountGroup> uuid(String uuid) {
    return GroupPredicates.uuid(new AccountGroup.UUID(uuid));
}
#method_after
@Operator
public Predicate<InternalGroup> uuid(String uuid) {
    return GroupPredicates.uuid(new AccountGroup.UUID(uuid));
}
#end_block

#method_before
@Operator
public Predicate<AccountGroup> description(String description) throws QueryParseException {
    if (Strings.isNullOrEmpty(description)) {
        throw error("description operator requires a value");
    }
    return GroupPredicates.description(description);
}
#method_after
@Operator
public Predicate<InternalGroup> description(String description) throws QueryParseException {
    if (Strings.isNullOrEmpty(description)) {
        throw error("description operator requires a value");
    }
    return GroupPredicates.description(description);
}
#end_block

#method_before
@Operator
public Predicate<AccountGroup> inname(String namePart) {
    if (namePart.isEmpty()) {
        return name(namePart);
    }
    return GroupPredicates.inname(namePart);
}
#method_after
@Operator
public Predicate<InternalGroup> inname(String namePart) {
    if (namePart.isEmpty()) {
        return name(namePart);
    }
    return GroupPredicates.inname(namePart);
}
#end_block

#method_before
@Operator
public Predicate<AccountGroup> name(String name) {
    return GroupPredicates.name(name);
}
#method_after
@Operator
public Predicate<InternalGroup> name(String name) {
    return GroupPredicates.name(name);
}
#end_block

#method_before
@Operator
public Predicate<AccountGroup> owner(String owner) throws QueryParseException {
    AccountGroup group = args.groupCache.get(new AccountGroup.UUID(owner));
    if (group != null) {
        return GroupPredicates.owner(group.getGroupUUID());
    }
    GroupReference g = GroupBackends.findBestSuggestion(args.groupBackend, owner);
    if (g == null) {
        throw error("Group " + owner + " not found");
    }
    return GroupPredicates.owner(g.getUUID());
}
#method_after
@Operator
public Predicate<InternalGroup> owner(String owner) throws QueryParseException {
    AccountGroup.UUID groupUuid = parseGroup(owner);
    return GroupPredicates.owner(groupUuid);
}
#end_block

#method_before
@Operator
public Predicate<AccountGroup> is(String value) throws QueryParseException {
    if ("visibletoall".equalsIgnoreCase(value)) {
        return GroupPredicates.isVisibleToAll();
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<InternalGroup> is(String value) throws QueryParseException {
    if ("visibletoall".equalsIgnoreCase(value)) {
        return GroupPredicates.isVisibleToAll();
    }
    throw error("Invalid query");
}
#end_block

#method_before
@Override
protected Predicate<AccountGroup> defaultField(String query) throws QueryParseException {
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<AccountGroup>> preds = Lists.newArrayListWithCapacity(5);
    preds.add(uuid(query));
    preds.add(name(query));
    preds.add(inname(query));
    if (!Strings.isNullOrEmpty(query)) {
        preds.add(description(query));
    }
    try {
        preds.add(owner(query));
    } catch (QueryParseException e) {
    // Skip.
    }
    return Predicate.or(preds);
}
#method_after
@Override
protected Predicate<InternalGroup> defaultField(String query) throws QueryParseException {
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<InternalGroup>> preds = Lists.newArrayListWithCapacity(5);
    preds.add(uuid(query));
    preds.add(name(query));
    preds.add(inname(query));
    if (!Strings.isNullOrEmpty(query)) {
        preds.add(description(query));
    }
    try {
        preds.add(owner(query));
    } catch (QueryParseException e) {
    // Skip.
    }
    return Predicate.or(preds);
}
#end_block

#method_before
@Operator
public Predicate<AccountGroup> limit(String query) throws QueryParseException {
    Integer limit = Ints.tryParse(query);
    if (limit == null) {
        throw error("Invalid limit: " + query);
    }
    return new LimitPredicate<>(FIELD_LIMIT, limit);
}
#method_after
@Operator
public Predicate<InternalGroup> limit(String query) throws QueryParseException {
    Integer limit = Ints.tryParse(query);
    if (limit == null) {
        throw error("Invalid limit: " + query);
    }
    return new LimitPredicate<>(FIELD_LIMIT, limit);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (!shouldValidateChangeId(receiveEvent)) {
        return Collections.emptyList();
    }
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new ArrayList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(SHA1_LENGTH).name();
    if (idList.isEmpty()) {
        if (projectState.isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    } else {
        String v = idList.get(idList.size() - 1).trim();
        // Egit (I0000000000000000000000000000000000000000).
        if (!CHANGE_ID.matcher(v).matches() || v.matches("^I00*$")) {
            String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (!shouldValidateChangeId(receiveEvent)) {
        return Collections.emptyList();
    }
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new ArrayList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(RevId.ABBREV_LEN).name();
    if (idList.isEmpty()) {
        if (projectState.isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    } else {
        String v = idList.get(idList.size() - 1).trim();
        // Egit (I0000000000000000000000000000000000000000).
        if (!CHANGE_ID.matcher(v).matches() || v.matches("^I00*$")) {
            String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(RequestScopedReviewDbProvider.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ProjectControl.Factory.class).in(SINGLETON);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(RequestScopedReviewDbProvider.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
}
#end_block

#method_before
static Set<String> extractTags(Set<String> input) throws IllegalArgumentException {
    if (input == null) {
        return Collections.emptySet();
    }
    HashSet<String> result = new HashSet<>();
    for (String hashtag : input) {
        if (hashtag.contains(",")) {
            throw new IllegalArgumentException("Hashtags may not contain commas");
        }
        hashtag = cleanupHashtag(hashtag);
        if (!hashtag.isEmpty()) {
            result.add(hashtag);
        }
    }
    return result;
}
#method_after
static Set<String> extractTags(Set<String> input) throws InvalidHashtagException {
    if (input == null) {
        return Collections.emptySet();
    }
    HashSet<String> result = new HashSet<>();
    for (String hashtag : input) {
        if (hashtag.contains(",")) {
            throw InvalidHashtagException.hashtagsMayNotContainCommas();
        }
        hashtag = cleanupHashtag(hashtag);
        if (!hashtag.isEmpty()) {
            result.add(hashtag);
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    for (AccountGroup.Id id : scanSystemGroups(db)) {
        AccountGroup group = db.accountGroups().get(id);
        if (group != null && SystemGroupBackend.isSystemGroup(group.getGroupUUID())) {
            db.accountGroups().delete(Collections.singleton(group));
            db.accountGroupNames().deleteKeys(Collections.singleton(group.getNameKey()));
        }
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    try (PreparedStatement uuidRetrieval = prepareStatement(db, "SELECT group_uuid FROM account_groups WHERE group_id = ?");
        PreparedStatement groupDeletion = prepareStatement(db, "DELETE FROM account_groups WHERE group_id = ?");
        PreparedStatement groupNameDeletion = prepareStatement(db, "DELETE FROM account_group_names WHERE group_id = ?")) {
        for (AccountGroup.Id id : scanSystemGroups(db)) {
            Optional<AccountGroup.UUID> groupUuid = getUuid(uuidRetrieval, id);
            if (groupUuid.filter(SystemGroupBackend::isSystemGroup).isPresent()) {
                groupDeletion.setInt(1, id.get());
                groupDeletion.executeUpdate();
                groupNameDeletion.setInt(1, id.get());
                groupNameDeletion.executeUpdate();
            }
        }
    }
}
#end_block

#method_before
private Set<AccountGroup.Id> scanSystemGroups(ReviewDb db) throws SQLException {
    try (Statement stmt = newStatement(db);
        ResultSet rs = stmt.executeQuery("SELECT group_id FROM account_groups WHERE group_type = 'SYSTEM'")) {
        Set<AccountGroup.Id> ids = new HashSet<>();
        while (rs.next()) {
            ids.add(new AccountGroup.Id(rs.getInt(1)));
        }
        return ids;
    }
}
#method_after
private static Set<AccountGroup.Id> scanSystemGroups(ReviewDb db) throws SQLException {
    try (Statement stmt = newStatement(db);
        ResultSet rs = stmt.executeQuery("SELECT group_id FROM account_groups WHERE group_type = 'SYSTEM'")) {
        Set<AccountGroup.Id> ids = new HashSet<>();
        while (rs.next()) {
            ids.add(new AccountGroup.Id(rs.getInt(1)));
        }
        return ids;
    }
}
#end_block

#method_before
public PermissionBackend.ForChange permissions() {
    return permissionBackend.user(getControl().getUser()).change(getNotes());
}
#method_after
public PermissionBackend.ForChange permissions() {
    return permissionBackend.user(user).change(notes);
}
#end_block

#method_before
public CurrentUser getUser() {
    return getControl().getUser();
}
#method_after
public CurrentUser getUser() {
    return user;
}
#end_block

#method_before
public Change.Id getId() {
    return getControl().getId();
}
#method_after
public Change.Id getId() {
    return notes.getChangeId();
}
#end_block

#method_before
public boolean isUserOwner() {
    CurrentUser user = getControl().getUser();
    Account.Id owner = getChange().getOwner();
    return user.isIdentifiedUser() && user.asIdentifiedUser().getAccountId().equals(owner);
}
#method_after
public boolean isUserOwner() {
    Account.Id owner = getChange().getOwner();
    return user.isIdentifiedUser() && user.asIdentifiedUser().getAccountId().equals(owner);
}
#end_block

#method_before
public Change getChange() {
    return getControl().getChange();
}
#method_after
public Change getChange() {
    return notes.getChange();
}
#end_block

#method_before
public ChangeNotes getNotes() {
    return getControl().getNotes();
}
#method_after
public ChangeNotes getNotes() {
    return notes;
}
#end_block

#method_before
// This includes all information relevant for ETag computation
public void prepareETag(Hasher h, CurrentUser user) {
    h.putInt(JSON_FORMAT_VERSION).putLong(getChange().getLastUpdatedOn().getTime()).putInt(getChange().getRowVersion()).putInt(user.isIdentifiedUser() ? user.getAccountId().get() : 0);
    if (user.isIdentifiedUser()) {
        for (AccountGroup.UUID uuid : user.getEffectiveGroups().getKnownGroups()) {
            h.putBytes(uuid.get().getBytes(UTF_8));
        }
    }
    byte[] buf = new byte[20];
    Set<Account.Id> accounts = new HashSet<>();
    accounts.add(getChange().getOwner());
    if (getChange().getAssignee() != null) {
        accounts.add(getChange().getAssignee());
    }
    try {
        patchSetUtil.byChange(db.get(), getNotes()).stream().map(ps -> ps.getUploader()).forEach(accounts::add);
        // It's intentional to include the states for *all* reviewers into the ETag computation.
        // We need the states of all current reviewers and CCs because they are part of ChangeInfo.
        // Including removed reviewers is a cheap way of making sure that the states of accounts that
        // posted a message on the change are included. Loading all change messages to find the exact
        // set of accounts that posted a message is too expensive. However everyone who posts a
        // message is automatically added as reviewer. Hence if we include removed reviewers we can
        // be sure that we have all accounts that posted messages on the change.
        accounts.addAll(approvalUtil.getReviewers(db.get(), getNotes()).all());
    } catch (OrmException e) {
    // This ETag will be invalidated if it loads next time.
    }
    accounts.stream().forEach(a -> hashAccount(h, accountCache.get(a), buf));
    ObjectId noteId;
    try {
        noteId = getNotes().loadRevision();
    } catch (OrmException e) {
        // This ETag will be invalidated if it loads next time.
        noteId = null;
    }
    hashObjectId(h, noteId, buf);
    for (ProjectState p : control.getProjectControl().getProjectState().tree()) {
        hashObjectId(h, p.getConfig().getRevision(), buf);
    }
}
#method_after
// This includes all information relevant for ETag computation
public void prepareETag(Hasher h, CurrentUser user) {
    h.putInt(JSON_FORMAT_VERSION).putLong(getChange().getLastUpdatedOn().getTime()).putInt(getChange().getRowVersion()).putInt(user.isIdentifiedUser() ? user.getAccountId().get() : 0);
    if (user.isIdentifiedUser()) {
        for (AccountGroup.UUID uuid : user.getEffectiveGroups().getKnownGroups()) {
            h.putBytes(uuid.get().getBytes(UTF_8));
        }
    }
    byte[] buf = new byte[20];
    Set<Account.Id> accounts = new HashSet<>();
    accounts.add(getChange().getOwner());
    if (getChange().getAssignee() != null) {
        accounts.add(getChange().getAssignee());
    }
    try {
        patchSetUtil.byChange(db.get(), notes).stream().map(ps -> ps.getUploader()).forEach(accounts::add);
        // It's intentional to include the states for *all* reviewers into the ETag computation.
        // We need the states of all current reviewers and CCs because they are part of ChangeInfo.
        // Including removed reviewers is a cheap way of making sure that the states of accounts that
        // posted a message on the change are included. Loading all change messages to find the exact
        // set of accounts that posted a message is too expensive. However everyone who posts a
        // message is automatically added as reviewer. Hence if we include removed reviewers we can
        // be sure that we have all accounts that posted messages on the change.
        accounts.addAll(approvalUtil.getReviewers(db.get(), notes).all());
    } catch (OrmException e) {
    // This ETag will be invalidated if it loads next time.
    }
    accounts.stream().forEach(a -> hashAccount(h, accountCache.get(a), buf));
    ObjectId noteId;
    try {
        noteId = notes.loadRevision();
    } catch (OrmException e) {
        // This ETag will be invalidated if it loads next time.
        noteId = null;
    }
    hashObjectId(h, noteId, buf);
    // TODO(dborowitz): Include more NoteDb and other related refs, e.g. drafts
    // and edits.
    Iterable<ProjectState> projectStateTree;
    try {
        projectStateTree = projectCache.checkedGet(getProject()).tree();
    } catch (IOException e) {
        log.error(String.format("could not load project %s while computing etag", getProject()));
        projectStateTree = ImmutableList.of();
    }
    for (ProjectState p : projectStateTree) {
        hashObjectId(h, p.getConfig().getRevision(), buf);
    }
}
#end_block

#method_before
@Override
public String getETag() {
    CurrentUser user = control.getUser();
    Hasher h = Hashing.murmur3_128().newHasher();
    if (user.isIdentifiedUser()) {
        h.putString(starredChangesUtil.getObjectId(user.getAccountId(), getId()).name(), UTF_8);
    }
    prepareETag(h, user);
    return h.hash().toString();
}
#method_after
@Override
public String getETag() {
    Hasher h = Hashing.murmur3_128().newHasher();
    if (user.isIdentifiedUser()) {
        h.putString(starredChangesUtil.getObjectId(user.getAccountId(), getId()).name(), UTF_8);
    }
    prepareETag(h, user);
    return h.hash().toString();
}
#end_block

#method_before
@Override
protected BanResultInfo applyImpl(BatchUpdate.Factory updateFactory, ProjectResource rsrc, Input input) throws RestApiException, UpdateException, IOException {
    BanResultInfo r = new BanResultInfo();
    if (input != null && input.commits != null && !input.commits.isEmpty()) {
        List<ObjectId> commitsToBan = new ArrayList<>(input.commits.size());
        for (String c : input.commits) {
            try {
                commitsToBan.add(ObjectId.fromString(c));
            } catch (IllegalArgumentException e) {
                throw new UnprocessableEntityException(e.getMessage());
            }
        }
        try {
            BanCommitResult result = banCommit.ban(rsrc.getControl(), commitsToBan, input.reason);
            r.newlyBanned = transformCommits(result.getNewlyBannedCommits());
            r.alreadyBanned = transformCommits(result.getAlreadyBannedCommits());
            r.ignored = transformCommits(result.getIgnoredObjectIds());
        } catch (PermissionDeniedException e) {
            throw new AuthException(e.getMessage());
        }
    }
    return r;
}
#method_after
@Override
protected BanResultInfo applyImpl(BatchUpdate.Factory updateFactory, ProjectResource rsrc, BanCommitInput input) throws RestApiException, UpdateException, IOException, PermissionBackendException {
    BanResultInfo r = new BanResultInfo();
    if (input != null && input.commits != null && !input.commits.isEmpty()) {
        List<ObjectId> commitsToBan = new ArrayList<>(input.commits.size());
        for (String c : input.commits) {
            try {
                commitsToBan.add(ObjectId.fromString(c));
            } catch (IllegalArgumentException e) {
                throw new UnprocessableEntityException(e.getMessage());
            }
        }
        BanCommitResult result = banCommit.ban(rsrc.getNameKey(), rsrc.getUser(), commitsToBan, input.reason);
        r.newlyBanned = transformCommits(result.getNewlyBannedCommits());
        r.alreadyBanned = transformCommits(result.getAlreadyBannedCommits());
        r.ignored = transformCommits(result.getIgnoredObjectIds());
    }
    return r;
}
#end_block

#method_before
public String apply(ProjectResource rsrc, Input input, boolean checkIfAdmin) throws AuthException, ResourceConflictException, ResourceNotFoundException, UnprocessableEntityException, IOException, PermissionBackendException {
    IdentifiedUser user = rsrc.getUser().asIdentifiedUser();
    String parentName = MoreObjects.firstNonNull(Strings.emptyToNull(input.parent), allProjects.get());
    validateParentUpdate(rsrc.getProjectState().getNameKey(), user, parentName, checkIfAdmin);
    try (MetaDataUpdate md = updateFactory.create(rsrc.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        project.setParentName(parentName);
        String msg = Strings.emptyToNull(input.commitMessage);
        if (msg == null) {
            msg = String.format("Changed parent to %s.\n", parentName);
        } else if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(user);
        md.setMessage(msg);
        config.commit(md);
        cache.evict(rsrc.getProjectState().getProject());
        Project.NameKey parent = project.getParent(allProjects);
        checkNotNull(parent);
        return parent.get();
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(rsrc.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#method_after
@Override
public String apply(ProjectResource rsrc, ParentInput input) throws AuthException, ResourceConflictException, ResourceNotFoundException, UnprocessableEntityException, IOException, PermissionBackendException {
    return apply(rsrc, input, true);
}
#end_block

#method_before
public void validateParentUpdate(Project.NameKey project, IdentifiedUser user, String newParent, boolean checkIfAdmin) throws AuthException, ResourceConflictException, UnprocessableEntityException, PermissionBackendException {
    if (checkIfAdmin) {
        permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    if (project.equals(allProjects)) {
        throw new ResourceConflictException("cannot set parent of " + allProjects.get());
    }
    newParent = Strings.emptyToNull(newParent);
    if (newParent != null) {
        ProjectState parent = cache.get(new Project.NameKey(newParent));
        if (parent == null) {
            throw new UnprocessableEntityException("parent project " + newParent + " not found");
        }
        if (Iterables.tryFind(parent.tree(), p -> {
            return p.getNameKey().equals(project);
        }).isPresent()) {
            throw new ResourceConflictException("cycle exists between " + project.get() + " and " + parent.getName());
        }
    }
}
#method_after
public void validateParentUpdate(Project.NameKey project, IdentifiedUser user, String newParent, boolean checkIfAdmin) throws AuthException, ResourceConflictException, UnprocessableEntityException, PermissionBackendException {
    if (checkIfAdmin) {
        permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    if (project.equals(allProjects)) {
        throw new ResourceConflictException("cannot set parent of " + allProjects.get());
    }
    newParent = Strings.emptyToNull(newParent);
    if (newParent != null) {
        ProjectState parent = cache.get(new Project.NameKey(newParent));
        if (parent == null) {
            throw new UnprocessableEntityException("parent project " + newParent + " not found");
        }
        if (parent.getName().equals(project.get())) {
            throw new ResourceConflictException("cannot set parent to self");
        }
        if (Iterables.tryFind(parent.tree(), p -> {
            return p.getNameKey().equals(project);
        }).isPresent()) {
            throw new ResourceConflictException("cycle exists between " + project.get() + " and " + parent.getName());
        }
    }
}
#end_block

#method_before
public NoteDbMigrator build() throws MigrationException {
    return new NoteDbMigrator(sitePaths, schemaFactory, repoManager, allProjects, requestContext, userFactory, rebuilder, globalNotesMigration, primaryStorageMigrator, threads > 1 ? MoreExecutors.listeningDecorator(workQueue.createQueue(threads, "RebuildChange")) : MoreExecutors.newDirectExecutorService(), projects, changes, progressOut, stopAtState, trial, forceRebuild, sequenceGap >= 0 ? sequenceGap : Sequences.getChangeSequenceGap(cfg), autoMigrate);
}
#method_after
public NoteDbMigrator build() throws MigrationException {
    return new NoteDbMigrator(sitePaths, schemaFactory, repoManager, allProjects, requestContext, userFactory, rebuilder, globalNotesMigration, primaryStorageMigrator, listeners, threads > 1 ? MoreExecutors.listeningDecorator(workQueue.createQueue(threads, "RebuildChange")) : MoreExecutors.newDirectExecutorService(), projects, changes, progressOut, stopAtState, trial, forceRebuild, sequenceGap >= 0 ? sequenceGap : Sequences.getChangeSequenceGap(cfg), autoMigrate);
}
#end_block

#method_before
public void migrate() throws OrmException, IOException {
    if (!changes.isEmpty() || !projects.isEmpty()) {
        throw new MigrationException("Cannot set changes or projects during full migration; call rebuild() instead");
    }
    Optional<NotesMigrationState> maybeState = loadState();
    if (!maybeState.isPresent()) {
        throw new MigrationException("Could not determine initial migration state");
    }
    NotesMigrationState state = maybeState.get();
    if (trial && state.compareTo(READ_WRITE_NO_SEQUENCE) > 0) {
        throw new MigrationException("Migration has already progressed past the endpoint of the \"trial mode\" state;" + " NoteDb is already the primary storage for some changes");
    }
    if (forceRebuild && state.compareTo(READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY) > 0) {
        throw new MigrationException("Cannot force rebuild changes; NoteDb is already the primary storage for some changes");
    }
    if (autoMigrate) {
        if (trial) {
            throw new MigrationException("Auto-migration cannot be used with trial mode");
        }
        enableAutoMigrate();
    }
    boolean rebuilt = false;
    while (state.compareTo(NOTE_DB) < 0) {
        if (state.equals(stopAtState)) {
            return;
        }
        boolean stillNeedsRebuild = forceRebuild && !rebuilt;
        if (trial && state.compareTo(READ_WRITE_NO_SEQUENCE) >= 0) {
            if (stillNeedsRebuild && state == READ_WRITE_NO_SEQUENCE) {
            // We're at the end state of trial mode, but still need a rebuild due to forceRebuild. Let
            // the loop go one more time.
            } else {
                return;
            }
        }
        switch(state) {
            case REVIEW_DB:
                state = turnOnWrites(state);
                break;
            case WRITE:
                state = rebuildAndEnableReads(state);
                rebuilt = true;
                break;
            case READ_WRITE_NO_SEQUENCE:
                if (stillNeedsRebuild) {
                    state = rebuildAndEnableReads(state);
                    rebuilt = true;
                } else {
                    state = enableSequences(state);
                }
                break;
            case READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY:
                if (stillNeedsRebuild) {
                    state = rebuildAndEnableReads(state);
                    rebuilt = true;
                } else {
                    state = setNoteDbPrimary(state);
                }
                break;
            case READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY:
                // The only way we can get here is if there was a failure on a previous run of
                // setNoteDbPrimary, since that method moves to NOTE_DB if it completes
                // successfully. Assume that not all changes were converted and re-run the step.
                // migrateToNoteDbPrimary is a relatively fast no-op for already-migrated changes, so this
                // isn't actually repeating work.
                state = setNoteDbPrimary(state);
                break;
            case NOTE_DB:
                // Done!
                break;
            default:
                throw new MigrationException("Migration out of the following state is not supported:\n" + state.toText());
        }
    }
}
#method_after
public void migrate() throws OrmException, IOException {
    if (!changes.isEmpty() || !projects.isEmpty()) {
        throw new MigrationException("Cannot set changes or projects during full migration; call rebuild() instead");
    }
    Optional<NotesMigrationState> maybeState = loadState();
    if (!maybeState.isPresent()) {
        throw new MigrationException("Could not determine initial migration state");
    }
    NotesMigrationState state = maybeState.get();
    if (trial && state.compareTo(READ_WRITE_NO_SEQUENCE) > 0) {
        throw new MigrationException("Migration has already progressed past the endpoint of the \"trial mode\" state;" + " NoteDb is already the primary storage for some changes");
    }
    if (forceRebuild && state.compareTo(READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY) > 0) {
        throw new MigrationException("Cannot force rebuild changes; NoteDb is already the primary storage for some changes");
    }
    setControlFlags();
    boolean rebuilt = false;
    while (state.compareTo(NOTE_DB) < 0) {
        if (state.equals(stopAtState)) {
            return;
        }
        boolean stillNeedsRebuild = forceRebuild && !rebuilt;
        if (trial && state.compareTo(READ_WRITE_NO_SEQUENCE) >= 0) {
            if (stillNeedsRebuild && state == READ_WRITE_NO_SEQUENCE) {
            // We're at the end state of trial mode, but still need a rebuild due to forceRebuild. Let
            // the loop go one more time.
            } else {
                return;
            }
        }
        switch(state) {
            case REVIEW_DB:
                state = turnOnWrites(state);
                break;
            case WRITE:
                state = rebuildAndEnableReads(state);
                rebuilt = true;
                break;
            case READ_WRITE_NO_SEQUENCE:
                if (stillNeedsRebuild) {
                    state = rebuildAndEnableReads(state);
                    rebuilt = true;
                } else {
                    state = enableSequences(state);
                }
                break;
            case READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY:
                if (stillNeedsRebuild) {
                    state = rebuildAndEnableReads(state);
                    rebuilt = true;
                } else {
                    state = setNoteDbPrimary(state);
                }
                break;
            case READ_WRITE_WITH_SEQUENCE_NOTE_DB_PRIMARY:
                // The only way we can get here is if there was a failure on a previous run of
                // setNoteDbPrimary, since that method moves to NOTE_DB if it completes
                // successfully. Assume that not all changes were converted and re-run the step.
                // migrateToNoteDbPrimary is a relatively fast no-op for already-migrated changes, so this
                // isn't actually repeating work.
                state = setNoteDbPrimary(state);
                break;
            case NOTE_DB:
                // Done!
                break;
            default:
                throw new MigrationException("Migration out of the following state is not supported:\n" + state.toText());
        }
    }
}
#end_block

#method_before
private NotesMigrationState enableSequences(NotesMigrationState prev) throws OrmException, IOException {
    try (ReviewDb db = schemaFactory.open()) {
        @SuppressWarnings("deprecation")
        RepoSequence seq = new RepoSequence(repoManager, allProjects, Sequences.NAME_CHANGES, // would be a problem, but we just discard it, so this is safe.
        () -> db.nextChangeId() + sequenceGap - 1, 1);
        seq.next();
    }
    return saveState(prev, READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY);
}
#method_after
private NotesMigrationState enableSequences(NotesMigrationState prev) throws OrmException, IOException {
    try (ReviewDb db = schemaFactory.open()) {
        @SuppressWarnings("deprecation")
        RepoSequence seq = new RepoSequence(repoManager, GitReferenceUpdated.DISABLED, allProjects, Sequences.NAME_CHANGES, // would be a problem, but we just discard it, so this is safe.
        () -> db.nextChangeId() + sequenceGap - 1, 1);
        seq.next();
    }
    return saveState(prev, READ_WRITE_WITH_SEQUENCE_REVIEW_DB_PRIMARY);
}
#end_block

#method_before
private NotesMigrationState saveState(NotesMigrationState expectedOldState, NotesMigrationState newState, Consumer<Config> additionalUpdates) throws IOException {
    synchronized (globalNotesMigration) {
        // This read-modify-write is racy. We're counting on the fact that no other Gerrit operation
        // modifies gerrit.config, and hoping that admins don't either.
        Optional<NotesMigrationState> actualOldState = loadState();
        if (!actualOldState.equals(Optional.of(expectedOldState))) {
            throw new MigrationException("Cannot move to new state:\n" + newState.toText() + "\n\n" + "Expected this state in gerrit.config:\n" + expectedOldState.toText() + "\n\n" + (actualOldState.isPresent() ? "But found this state:\n" + actualOldState.get().toText() : "But could not parse the current state"));
        }
        newState.setConfigValues(noteDbConfig);
        additionalUpdates.accept(noteDbConfig);
        noteDbConfig.save();
        // Only set in-memory state once it's been persisted to storage.
        globalNotesMigration.setFrom(newState);
        return newState;
    }
}
#method_after
private NotesMigrationState saveState(NotesMigrationState expectedOldState, NotesMigrationState newState, Consumer<Config> additionalUpdates) throws IOException {
    synchronized (globalNotesMigration) {
        // This read-modify-write is racy. We're counting on the fact that no other Gerrit operation
        // modifies gerrit.config, and hoping that admins don't either.
        Optional<NotesMigrationState> actualOldState = loadState();
        if (!actualOldState.equals(Optional.of(expectedOldState))) {
            throw new MigrationException("Cannot move to new state:\n" + newState.toText() + "\n\n" + "Expected this state in gerrit.config:\n" + expectedOldState.toText() + "\n\n" + (actualOldState.isPresent() ? "But found this state:\n" + actualOldState.get().toText() : "But could not parse the current state"));
        }
        preStateChange(expectedOldState, newState);
        newState.setConfigValues(noteDbConfig);
        additionalUpdates.accept(noteDbConfig);
        noteDbConfig.save();
        // Only set in-memory state once it's been persisted to storage.
        globalNotesMigration.setFrom(newState);
        return newState;
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    try (Repository repo = repoManager.openRepository(allUsersName);
        RevWalk rw = new RevWalk(repo);
        ObjectInserter ins = repo.newObjectInserter()) {
        ObjectId rev = ExternalIdReader.readRevision(repo);
        NoteMap noteMap = ExternalIdReader.readNoteMap(rw, rev);
        boolean dirty = false;
        for (Note note : noteMap) {
            byte[] raw = rw.getObjectReader().open(note.getData(), OBJ_BLOB).getCachedBytes(ExternalIdReader.MAX_NOTE_SZ);
            try {
                ExternalId extId = ExternalId.parse(note.getName(), raw, note.getData());
                if (needsUpdate(extId)) {
                    ExternalIdsUpdate.upsert(rw, ins, noteMap, extId);
                    dirty = true;
                }
            } catch (ConfigInvalidException e) {
                ui.message(String.format("Warning: Ignoring invalid external ID note %s", note.getName()));
            }
        }
        if (dirty) {
            ExternalIdsUpdate.commit(repo, rw, ins, rev, noteMap, COMMIT_MSG, serverUser, serverUser);
        }
    } catch (IOException e) {
        throw new OrmException("Failed to update external IDs", e);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    try (Repository repo = repoManager.openRepository(allUsersName);
        RevWalk rw = new RevWalk(repo);
        ObjectInserter ins = repo.newObjectInserter()) {
        ObjectId rev = ExternalIdReader.readRevision(repo);
        NoteMap noteMap = ExternalIdReader.readNoteMap(rw, rev);
        boolean dirty = false;
        for (Note note : noteMap) {
            byte[] raw = rw.getObjectReader().open(note.getData(), OBJ_BLOB).getCachedBytes(ExternalIdReader.MAX_NOTE_SZ);
            try {
                ExternalId extId = ExternalId.parse(note.getName(), raw, note.getData());
                if (needsUpdate(extId)) {
                    ExternalIdsUpdate.upsert(rw, ins, noteMap, extId);
                    dirty = true;
                }
            } catch (ConfigInvalidException e) {
                ui.message(String.format("Warning: Ignoring invalid external ID note %s", note.getName()));
            }
        }
        if (dirty) {
            ExternalIdsUpdate.commit(allUsersName, repo, rw, ins, rev, noteMap, COMMIT_MSG, serverUser, serverUser, null, GitReferenceUpdated.DISABLED);
        }
    } catch (IOException e) {
        throw new OrmException("Failed to update external IDs", e);
    }
}
#end_block

#method_before
@Override
public final boolean updateChange(ChangeContext ctx) throws Exception {
    logDebug("{}#updateChange for change {}", getClass().getSimpleName(), toMerge.change().getId());
    // Update change and notes from ctx.
    toMerge.setControl(ctx.getControl());
    PatchSet.Id oldPsId = checkNotNull(toMerge.getPatchsetId());
    PatchSet.Id newPsId;
    if (ctx.getChange().getStatus() == Change.Status.MERGED) {
        // repo failed with lock failure.
        if (alreadyMergedCommit == null) {
            logDebug("Change is already merged according to its status, but we were unable to find it" + " merged into the current tip ({})", args.mergeTip.getCurrentTip().name());
        } else {
            logDebug("Change is already merged");
        }
        changeAlreadyMerged = true;
        return false;
    }
    if (alreadyMergedCommit != null) {
        alreadyMergedCommit.setControl(ctx.getControl());
        mergedPatchSet = getOrCreateAlreadyMergedPatchSet(ctx);
        newPsId = mergedPatchSet.getId();
    } else {
        PatchSet newPatchSet = updateChangeImpl(ctx);
        newPsId = checkNotNull(ctx.getChange().currentPatchSetId());
        if (newPatchSet == null) {
            checkState(oldPsId.equals(newPsId), "patch set advanced from %s to %s but updateChangeImpl did not" + " return new patch set instance", oldPsId, newPsId);
            // Ok to use stale notes to get the old patch set, which didn't change
            // during the submit strategy.
            mergedPatchSet = checkNotNull(args.psUtil.get(ctx.getDb(), ctx.getNotes(), oldPsId), "missing old patch set %s", oldPsId);
        } else {
            PatchSet.Id n = newPatchSet.getId();
            checkState(!n.equals(oldPsId) && n.equals(newPsId), "current patch was %s and is now %s, but updateChangeImpl returned" + " new patch set instance at %s", oldPsId, newPsId, n);
            mergedPatchSet = newPatchSet;
        }
    }
    Change c = ctx.getChange();
    Change.Id id = c.getId();
    CodeReviewCommit commit = args.commitStatus.get(id);
    checkNotNull(commit, "missing commit for change " + id);
    CommitMergeStatus s = commit.getStatusCode();
    checkNotNull(s, "status not set for change " + id + " expected to previously fail fast");
    logDebug("Status of change {} ({}) on {}: {}", id, commit.name(), c.getDest(), s);
    setApproval(ctx, args.caller);
    mergeResultRev = alreadyMergedCommit == null ? args.mergeTip.getMergeResults().get(commit) : // ChangeMergedEvent in the fixup case, but we'll just live with that.
    alreadyMergedCommit;
    try {
        setMerged(ctx, message(ctx, commit, s));
    } catch (OrmException err) {
        String msg = "Error updating change status for " + id;
        log.error(msg, err);
        args.commitStatus.logProblem(id, msg);
    // It's possible this happened before updating anything in the db, but
    // it's hard to know for sure, so just return true below to be safe.
    }
    updatedChange = c;
    return true;
}
#method_after
@Override
public final boolean updateChange(ChangeContext ctx) throws Exception {
    logDebug("{}#updateChange for change {}", getClass().getSimpleName(), toMerge.change().getId());
    // Update change and notes from ctx.
    toMerge.setNotes(ctx.getNotes());
    PatchSet.Id oldPsId = checkNotNull(toMerge.getPatchsetId());
    PatchSet.Id newPsId;
    if (ctx.getChange().getStatus() == Change.Status.MERGED) {
        // repo failed with lock failure.
        if (alreadyMergedCommit == null) {
            logDebug("Change is already merged according to its status, but we were unable to find it" + " merged into the current tip ({})", args.mergeTip.getCurrentTip().name());
        } else {
            logDebug("Change is already merged");
        }
        changeAlreadyMerged = true;
        return false;
    }
    if (alreadyMergedCommit != null) {
        alreadyMergedCommit.setNotes(ctx.getNotes());
        mergedPatchSet = getOrCreateAlreadyMergedPatchSet(ctx);
        newPsId = mergedPatchSet.getId();
    } else {
        PatchSet newPatchSet = updateChangeImpl(ctx);
        newPsId = checkNotNull(ctx.getChange().currentPatchSetId());
        if (newPatchSet == null) {
            checkState(oldPsId.equals(newPsId), "patch set advanced from %s to %s but updateChangeImpl did not" + " return new patch set instance", oldPsId, newPsId);
            // Ok to use stale notes to get the old patch set, which didn't change
            // during the submit strategy.
            mergedPatchSet = checkNotNull(args.psUtil.get(ctx.getDb(), ctx.getNotes(), oldPsId), "missing old patch set %s", oldPsId);
        } else {
            PatchSet.Id n = newPatchSet.getId();
            checkState(!n.equals(oldPsId) && n.equals(newPsId), "current patch was %s and is now %s, but updateChangeImpl returned" + " new patch set instance at %s", oldPsId, newPsId, n);
            mergedPatchSet = newPatchSet;
        }
    }
    Change c = ctx.getChange();
    Change.Id id = c.getId();
    CodeReviewCommit commit = args.commitStatus.get(id);
    checkNotNull(commit, "missing commit for change " + id);
    CommitMergeStatus s = commit.getStatusCode();
    checkNotNull(s, "status not set for change " + id + " expected to previously fail fast");
    logDebug("Status of change {} ({}) on {}: {}", id, commit.name(), c.getDest(), s);
    setApproval(ctx, args.caller);
    mergeResultRev = alreadyMergedCommit == null ? args.mergeTip.getMergeResults().get(commit) : // ChangeMergedEvent in the fixup case, but we'll just live with that.
    alreadyMergedCommit;
    try {
        setMerged(ctx, message(ctx, commit, s));
    } catch (OrmException err) {
        String msg = "Error updating change status for " + id;
        log.error(msg, err);
        args.commitStatus.logProblem(id, msg);
    // It's possible this happened before updating anything in the db, but
    // it's hard to know for sure, so just return true below to be safe.
    }
    updatedChange = c;
    return true;
}
#end_block

#method_before
private PatchSet getOrCreateAlreadyMergedPatchSet(ChangeContext ctx) throws IOException, OrmException {
    PatchSet.Id psId = alreadyMergedCommit.getPatchsetId();
    logDebug("Fixing up already-merged patch set {}", psId);
    PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
    ctx.getRevWalk().parseBody(alreadyMergedCommit);
    ctx.getChange().setCurrentPatchSet(psId, alreadyMergedCommit.getShortMessage(), ctx.getChange().getOriginalSubject());
    PatchSet existing = args.psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (existing != null) {
        logDebug("Patch set row exists, only updating change");
        return existing;
    }
    // No patch set for the already merged commit, although we know it came form
    // a patch set ref. Fix up the database. Note that this uses the current
    // user as the uploader, which is as good a guess as any.
    List<String> groups = prevPs != null ? prevPs.getGroups() : GroupCollector.getDefaultGroups(alreadyMergedCommit);
    return args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, alreadyMergedCommit, false, groups, null, null);
}
#method_after
private PatchSet getOrCreateAlreadyMergedPatchSet(ChangeContext ctx) throws IOException, OrmException {
    PatchSet.Id psId = alreadyMergedCommit.getPatchsetId();
    logDebug("Fixing up already-merged patch set {}", psId);
    PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
    ctx.getRevWalk().parseBody(alreadyMergedCommit);
    ctx.getChange().setCurrentPatchSet(psId, alreadyMergedCommit.getShortMessage(), ctx.getChange().getOriginalSubject());
    PatchSet existing = args.psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (existing != null) {
        logDebug("Patch set row exists, only updating change");
        return existing;
    }
    // No patch set for the already merged commit, although we know it came form
    // a patch set ref. Fix up the database. Note that this uses the current
    // user as the uploader, which is as good a guess as any.
    List<String> groups = prevPs != null ? prevPs.getGroups() : GroupCollector.getDefaultGroups(alreadyMergedCommit);
    return args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, alreadyMergedCommit, groups, null, null);
}
#end_block

#method_before
private void setApproval(ChangeContext ctx, IdentifiedUser user) throws OrmException, IOException, PermissionBackendException {
    Change.Id id = ctx.getChange().getId();
    List<SubmitRecord> records = args.commitStatus.getSubmitRecords(id);
    PatchSet.Id oldPsId = toMerge.getPatchsetId();
    PatchSet.Id newPsId = ctx.getChange().currentPatchSetId();
    logDebug("Add approval for " + id);
    ChangeUpdate origPsUpdate = ctx.getUpdate(oldPsId);
    origPsUpdate.putReviewer(user.getAccountId(), REVIEWER);
    LabelNormalizer.Result normalized = approve(ctx, origPsUpdate);
    ChangeUpdate newPsUpdate = ctx.getUpdate(newPsId);
    newPsUpdate.merge(args.submissionId, records);
    // approvals as well.
    if (!newPsId.equals(oldPsId)) {
        saveApprovals(normalized, ctx, newPsUpdate, true);
        submitter = convertPatchSet(newPsId).apply(submitter);
    }
}
#method_after
private void setApproval(ChangeContext ctx, IdentifiedUser user) throws OrmException, IOException {
    Change.Id id = ctx.getChange().getId();
    List<SubmitRecord> records = args.commitStatus.getSubmitRecords(id);
    PatchSet.Id oldPsId = toMerge.getPatchsetId();
    PatchSet.Id newPsId = ctx.getChange().currentPatchSetId();
    logDebug("Add approval for " + id);
    ChangeUpdate origPsUpdate = ctx.getUpdate(oldPsId);
    origPsUpdate.putReviewer(user.getAccountId(), REVIEWER);
    LabelNormalizer.Result normalized = approve(ctx, origPsUpdate);
    ChangeUpdate newPsUpdate = ctx.getUpdate(newPsId);
    newPsUpdate.merge(args.submissionId, records);
    // approvals as well.
    if (!newPsId.equals(oldPsId)) {
        saveApprovals(normalized, ctx, newPsUpdate, true);
        submitter = convertPatchSet(newPsId).apply(submitter);
    }
}
#end_block

#method_before
private LabelNormalizer.Result approve(ChangeContext ctx, ChangeUpdate update) throws OrmException, IOException, PermissionBackendException {
    PatchSet.Id psId = update.getPatchSetId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = new HashMap<>();
    for (PatchSetApproval psa : args.approvalsUtil.byPatchSet(ctx.getDb(), ctx.getNotes(), ctx.getUser(), psId, ctx.getRevWalk(), ctx.getRepoView().getConfig())) {
        byKey.put(psa.getKey(), psa);
    }
    submitter = ApprovalsUtil.newApproval(psId, ctx.getUser(), LabelId.legacySubmit(), 1, ctx.getWhen());
    byKey.put(submitter.getKey(), submitter);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = args.labelNormalizer.normalize(ctx.getNotes(), ctx.getUser(), byKey.values());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    saveApprovals(normalized, ctx, update, false);
    return normalized;
}
#method_after
private LabelNormalizer.Result approve(ChangeContext ctx, ChangeUpdate update) throws OrmException, IOException {
    PatchSet.Id psId = update.getPatchSetId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = new HashMap<>();
    for (PatchSetApproval psa : args.approvalsUtil.byPatchSet(ctx.getDb(), ctx.getNotes(), ctx.getUser(), psId, ctx.getRevWalk(), ctx.getRepoView().getConfig())) {
        byKey.put(psa.getKey(), psa);
    }
    submitter = ApprovalsUtil.newApproval(psId, ctx.getUser(), LabelId.legacySubmit(), 1, ctx.getWhen());
    byKey.put(submitter.getKey(), submitter);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = args.labelNormalizer.normalize(ctx.getNotes(), ctx.getUser(), byKey.values());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    saveApprovals(normalized, ctx, update, false);
    return normalized;
}
#end_block

#method_before
@Override
public List<? extends GroupAuditEventInfo> apply(GroupResource rsrc) throws AuthException, MethodNotAllowedException, OrmException {
    GroupDescription.Internal group = rsrc.asInternalGroup().orElseThrow(MethodNotAllowedException::new);
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    AccountLoader accountLoader = accountLoaderFactory.create(true);
    List<GroupAuditEventInfo> auditEvents = new ArrayList<>();
    for (AccountGroupMemberAudit auditEvent : db.get().accountGroupMembersAudit().byGroup(group.getId()).toList()) {
        AccountInfo member = accountLoader.get(auditEvent.getKey().getParentKey());
        auditEvents.add(GroupAuditEventInfo.createAddUserEvent(accountLoader.get(auditEvent.getAddedBy()), auditEvent.getKey().getAddedOn(), member));
        if (!auditEvent.isActive()) {
            auditEvents.add(GroupAuditEventInfo.createRemoveUserEvent(accountLoader.get(auditEvent.getRemovedBy()), auditEvent.getRemovedOn(), member));
        }
    }
    for (AccountGroupByIdAud auditEvent : db.get().accountGroupByIdAud().byGroup(group.getId()).toList()) {
        AccountGroup.UUID includedGroupUUID = auditEvent.getKey().getIncludeUUID();
        AccountGroup includedGroup = groupCache.get(includedGroupUUID);
        GroupInfo member;
        if (includedGroup != null) {
            member = groupJson.format(GroupDescriptions.forAccountGroup(includedGroup));
        } else {
            GroupDescription.Basic groupDescription = groupBackend.get(includedGroupUUID);
            member = new GroupInfo();
            member.id = Url.encode(includedGroupUUID.get());
            member.name = groupDescription.getName();
        }
        auditEvents.add(GroupAuditEventInfo.createAddGroupEvent(accountLoader.get(auditEvent.getAddedBy()), auditEvent.getKey().getAddedOn(), member));
        if (!auditEvent.isActive()) {
            auditEvents.add(GroupAuditEventInfo.createRemoveGroupEvent(accountLoader.get(auditEvent.getRemovedBy()), auditEvent.getRemovedOn(), member));
        }
    }
    accountLoader.fill();
    // sort by date in reverse order so that the newest audit event comes first
    Collections.sort(auditEvents, new Comparator<GroupAuditEventInfo>() {

        @Override
        public int compare(GroupAuditEventInfo e1, GroupAuditEventInfo e2) {
            return e2.date.compareTo(e1.date);
        }
    });
    return auditEvents;
}
#method_after
@Override
public List<? extends GroupAuditEventInfo> apply(GroupResource rsrc) throws AuthException, MethodNotAllowedException, OrmException {
    GroupDescription.Internal group = rsrc.asInternalGroup().orElseThrow(MethodNotAllowedException::new);
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    AccountLoader accountLoader = accountLoaderFactory.create(true);
    List<GroupAuditEventInfo> auditEvents = new ArrayList<>();
    for (AccountGroupMemberAudit auditEvent : db.get().accountGroupMembersAudit().byGroup(group.getId()).toList()) {
        AccountInfo member = accountLoader.get(auditEvent.getKey().getParentKey());
        auditEvents.add(GroupAuditEventInfo.createAddUserEvent(accountLoader.get(auditEvent.getAddedBy()), auditEvent.getKey().getAddedOn(), member));
        if (!auditEvent.isActive()) {
            auditEvents.add(GroupAuditEventInfo.createRemoveUserEvent(accountLoader.get(auditEvent.getRemovedBy()), auditEvent.getRemovedOn(), member));
        }
    }
    for (AccountGroupByIdAud auditEvent : db.get().accountGroupByIdAud().byGroup(group.getId()).toList()) {
        AccountGroup.UUID includedGroupUUID = auditEvent.getKey().getIncludeUUID();
        Optional<InternalGroup> includedGroup = groupCache.get(includedGroupUUID);
        GroupInfo member;
        if (includedGroup.isPresent()) {
            member = groupJson.format(new InternalGroupDescription(includedGroup.get()));
        } else {
            GroupDescription.Basic groupDescription = groupBackend.get(includedGroupUUID);
            member = new GroupInfo();
            member.id = Url.encode(includedGroupUUID.get());
            member.name = groupDescription.getName();
        }
        auditEvents.add(GroupAuditEventInfo.createAddGroupEvent(accountLoader.get(auditEvent.getAddedBy()), auditEvent.getKey().getAddedOn(), member));
        if (!auditEvent.isActive()) {
            auditEvents.add(GroupAuditEventInfo.createRemoveGroupEvent(accountLoader.get(auditEvent.getRemovedBy()), auditEvent.getRemovedOn(), member));
        }
    }
    accountLoader.fill();
    // sort by date in reverse order so that the newest audit event comes first
    Collections.sort(auditEvents, new Comparator<GroupAuditEventInfo>() {

        @Override
        public int compare(GroupAuditEventInfo e1, GroupAuditEventInfo e2) {
            return e2.date.compareTo(e1.date);
        }
    });
    return auditEvents;
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    @SuppressWarnings("deprecation")
    RepoSequence.Seed accountSeed = () -> db.nextAccountId();
    RepoSequence accountSeq = new RepoSequence(repoManager, allUsersName, Sequences.NAME_ACCOUNTS, accountSeed, 1);
    // consume one account ID to ensure that the account sequence is initialized in NoteDb
    accountSeq.next();
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    @SuppressWarnings("deprecation")
    RepoSequence.Seed accountSeed = () -> db.nextAccountId();
    RepoSequence accountSeq = new RepoSequence(repoManager, GitReferenceUpdated.DISABLED, allUsersName, Sequences.NAME_ACCOUNTS, accountSeed, 1);
    // consume one account ID to ensure that the account sequence is initialized in NoteDb
    accountSeq.next();
}
#end_block

#method_before
public ChangeData create(ReviewDb db, Project.NameKey project, Change.Id id) {
    return assistedFactory.create(db, project, id, null, null, null);
}
#method_after
public ChangeData create(ReviewDb db, Project.NameKey project, Change.Id id) {
    return assistedFactory.create(db, project, id, null, null);
}
#end_block

#method_before
public ChangeData create(ReviewDb db, Change change) {
    return assistedFactory.create(db, change.getProject(), change.getId(), change, null, null);
}
#method_after
public ChangeData create(ReviewDb db, Change change) {
    return assistedFactory.create(db, change.getProject(), change.getId(), change, null);
}
#end_block

#method_before
public ChangeData create(ReviewDb db, ChangeNotes notes) {
    return assistedFactory.create(db, notes.getChange().getProject(), notes.getChangeId(), notes.getChange(), notes, null);
}
#method_after
public ChangeData create(ReviewDb db, ChangeNotes notes) {
    return assistedFactory.create(db, notes.getChange().getProject(), notes.getChangeId(), notes.getChange(), notes);
}
#end_block

#method_before
public static ChangeData createForTest(Project.NameKey project, Change.Id id, int currentPatchSetId) {
    ChangeData cd = new ChangeData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, project, id, null, null, null);
    cd.currentPatchSet = new PatchSet(new PatchSet.Id(id, currentPatchSetId));
    return cd;
}
#method_after
public static ChangeData createForTest(Project.NameKey project, Change.Id id, int currentPatchSetId) {
    ChangeData cd = new ChangeData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, project, id, null, null);
    cd.currentPatchSet = new PatchSet(new PatchSet.Id(id, currentPatchSetId));
    return cd;
}
#end_block

#method_before
public void setCurrentFilePaths(List<String> filePaths) throws OrmException {
    PatchSet ps = currentPatchSet();
    if (ps != null) {
        initFiles().put(ps.getPatchSetId(), ImmutableList.copyOf(filePaths));
    }
}
#method_after
public void setCurrentFilePaths(List<String> filePaths) throws OrmException {
    PatchSet ps = currentPatchSet();
    if (ps != null) {
        currentFiles = ImmutableList.copyOf(filePaths);
    }
}
#end_block

#method_before
public List<String> currentFilePaths() throws OrmException {
    PatchSet ps = currentPatchSet();
    return ps != null ? filePaths(ps) : null;
}
#method_after
public List<String> currentFilePaths() throws IOException, OrmException {
    if (currentFiles == null) {
        if (!lazyLoad) {
            return Collections.emptyList();
        }
        Optional<DiffSummary> p = getDiffSummary();
        currentFiles = p.map(DiffSummary::getPaths).orElse(Collections.emptyList());
    }
    return currentFiles;
}
#end_block

#method_before
private Optional<DiffSummary> getDiffSummary(Change c, PatchSet ps) {
    Integer psId = ps.getId().get();
    if (diffSummaries == null) {
        diffSummaries = new HashMap<>();
    }
    Optional<DiffSummary> r = diffSummaries.get(psId);
    if (r == null) {
        if (!lazyLoad) {
            return Optional.empty();
        }
        try {
            r = Optional.of(patchListCache.getDiffSummary(c, ps));
        } catch (PatchListNotAvailableException e) {
            r = Optional.empty();
        }
        diffSummaries.put(psId, r);
    }
    return r;
}
#method_after
private Optional<DiffSummary> getDiffSummary() throws OrmException, IOException {
    if (diffSummary == null) {
        if (!lazyLoad) {
            return Optional.empty();
        }
        Change c = change();
        PatchSet ps = currentPatchSet();
        if (c == null || ps == null || !loadCommitData()) {
            return Optional.empty();
        }
        ObjectId id = ObjectId.fromString(ps.getRevision().get());
        Whitespace ws = Whitespace.IGNORE_NONE;
        PatchListKey pk = parentCount > 1 ? PatchListKey.againstParentNum(1, id, ws) : PatchListKey.againstDefaultBase(id, ws);
        DiffSummaryKey key = DiffSummaryKey.fromPatchListKey(pk);
        try {
            diffSummary = Optional.of(patchListCache.getDiffSummary(key, c.getProject()));
        } catch (PatchListNotAvailableException e) {
            diffSummary = Optional.empty();
        }
    }
    return diffSummary;
}
#end_block

#method_before
private Optional<ChangedLines> computeChangedLines() throws OrmException {
    Change c = change();
    if (c == null) {
        return Optional.empty();
    }
    PatchSet ps = currentPatchSet();
    if (ps == null) {
        return Optional.empty();
    }
    Optional<DiffSummary> ds = getDiffSummary(c, ps);
    if (ds.isPresent()) {
        return Optional.of(ds.get().getChangedLines());
    }
    return Optional.empty();
}
#method_after
private Optional<ChangedLines> computeChangedLines() throws OrmException, IOException {
    Optional<DiffSummary> ds = getDiffSummary();
    if (ds.isPresent()) {
        return Optional.of(ds.get().getChangedLines());
    }
    return Optional.empty();
}
#end_block

#method_before
public Optional<ChangedLines> changedLines() throws OrmException {
    if (changedLines == null) {
        if (!lazyLoad) {
            return Optional.empty();
        }
        changedLines = computeChangedLines();
    }
    return changedLines;
}
#method_after
public Optional<ChangedLines> changedLines() throws OrmException, IOException {
    if (changedLines == null) {
        if (!lazyLoad) {
            return Optional.empty();
        }
        changedLines = computeChangedLines();
    }
    return changedLines;
}
#end_block

#method_before
void cacheVisibleTo(ChangeControl ctl) {
    visibleTo = ctl.getUser();
    changeControl = ctl;
}
#method_after
void cacheVisibleTo(CurrentUser user) {
    visibleTo = user;
}
#end_block

#method_before
public LabelTypes getLabelTypes() throws OrmException {
    if (labelTypes == null) {
        ProjectState state;
        try {
            state = projectCache.checkedGet(project());
        } catch (IOException e) {
            throw new OrmException("project state not available", e);
        }
        labelTypes = state.getLabelTypes(changeControl().getChange().getDest(), changeControl().getUser());
    }
    return labelTypes;
}
#method_after
public LabelTypes getLabelTypes() throws OrmException {
    if (labelTypes == null) {
        ProjectState state;
        try {
            state = projectCache.checkedGet(project());
        } catch (IOException e) {
            throw new OrmException("project state not available", e);
        }
        labelTypes = state.getLabelTypes(change().getDest(), userFactory.create(change().getOwner()));
    }
    return labelTypes;
}
#end_block

#method_before
public List<PatchSetApproval> currentApprovals() throws OrmException {
    if (currentApprovals == null) {
        if (!lazyLoad) {
            return Collections.emptyList();
        }
        Change c = change();
        if (c == null) {
            currentApprovals = Collections.emptyList();
        } else {
            try {
                currentApprovals = ImmutableList.copyOf(approvalsUtil.byPatchSet(db, notes(), changeControl().getUser(), c.currentPatchSetId(), null, null));
            } catch (OrmException e) {
                if (e.getCause() instanceof NoSuchChangeException) {
                    currentApprovals = Collections.emptyList();
                } else {
                    throw e;
                }
            }
        }
    }
    return currentApprovals;
}
#method_after
public List<PatchSetApproval> currentApprovals() throws OrmException {
    if (currentApprovals == null) {
        if (!lazyLoad) {
            return Collections.emptyList();
        }
        Change c = change();
        if (c == null) {
            currentApprovals = Collections.emptyList();
        } else {
            try {
                currentApprovals = ImmutableList.copyOf(approvalsUtil.byPatchSet(db, notes(), userFactory.create(c.getOwner()), c.currentPatchSetId(), null, null));
            } catch (OrmException e) {
                if (e.getCause() instanceof NoSuchChangeException) {
                    currentApprovals = Collections.emptyList();
                } else {
                    throw e;
                }
            }
        }
    }
    return currentApprovals;
}
#end_block

#method_before
private boolean loadCommitData() throws OrmException, RepositoryNotFoundException, IOException, MissingObjectException, IncorrectObjectTypeException {
    PatchSet ps = currentPatchSet();
    if (ps == null) {
        return false;
    }
    String sha1 = ps.getRevision().get();
    try (Repository repo = repoManager.openRepository(project());
        RevWalk walk = new RevWalk(repo)) {
        RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
        commitMessage = c.getFullMessage();
        commitFooters = c.getFooterLines();
        author = c.getAuthorIdent();
        committer = c.getCommitterIdent();
    }
    return true;
}
#method_after
private boolean loadCommitData() throws OrmException, RepositoryNotFoundException, IOException, MissingObjectException, IncorrectObjectTypeException {
    PatchSet ps = currentPatchSet();
    if (ps == null) {
        return false;
    }
    String sha1 = ps.getRevision().get();
    try (Repository repo = repoManager.openRepository(project());
        RevWalk walk = new RevWalk(repo)) {
        RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
        commitMessage = c.getFullMessage();
        commitFooters = c.getFooterLines();
        author = c.getAuthorIdent();
        committer = c.getCommitterIdent();
        parentCount = c.getParentCount();
    }
    return true;
}
#end_block

#method_before
public List<SubmitRecord> submitRecords(SubmitRuleOptions options) throws OrmException {
    List<SubmitRecord> records = submitRecords.get(options);
    if (records == null) {
        if (!lazyLoad) {
            return Collections.emptyList();
        }
        records = new SubmitRuleEvaluator(accountCache, accounts, emails, this).setOptions(options).evaluate();
        submitRecords.put(options, records);
    }
    return records;
}
#method_after
public List<SubmitRecord> submitRecords(SubmitRuleOptions options) throws OrmException {
    List<SubmitRecord> records = submitRecords.get(options);
    if (records == null) {
        if (!lazyLoad) {
            return Collections.emptyList();
        }
        records = submitRuleEvaluatorFactory.create(userFactory.create(change().getOwner()), this).setOptions(options).evaluate();
        submitRecords.put(options, records);
    }
    return records;
}
#end_block

#method_before
public SubmitTypeRecord submitTypeRecord() throws OrmException {
    if (submitTypeRecord == null) {
        submitTypeRecord = new SubmitRuleEvaluator(accountCache, accounts, emails, this).getSubmitType();
    }
    return submitTypeRecord;
}
#method_after
public SubmitTypeRecord submitTypeRecord() throws OrmException {
    if (submitTypeRecord == null) {
        submitTypeRecord = submitRuleEvaluatorFactory.create(userFactory.create(change().getOwner()), this).getSubmitType();
    }
    return submitTypeRecord;
}
#end_block

#method_before
public Boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else if (c.getStatus() == Change.Status.ABANDONED) {
            return null;
        } else if (c.isWorkInProgress()) {
            return null;
        } else {
            if (!lazyLoad) {
                return null;
            }
            PatchSet ps = currentPatchSet();
            try {
                if (ps == null || !changeControl().isPatchVisible(ps, db)) {
                    return null;
                }
            } catch (OrmException e) {
                if (e.getCause() instanceof NoSuchChangeException) {
                    return null;
                }
                throw e;
            }
            try (Repository repo = repoManager.openRepository(project())) {
                Ref ref = repo.getRefDatabase().exactRef(c.getDest().get());
                SubmitTypeRecord str = submitTypeRecord();
                if (!str.isOk()) {
                    // No need to log, as SubmitRuleEvaluator already did it for us.
                    return false;
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
    }
    return mergeable;
}
#method_after
public Boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else if (c.getStatus() == Change.Status.ABANDONED) {
            return null;
        } else if (c.isWorkInProgress()) {
            return null;
        } else {
            if (!lazyLoad) {
                return null;
            }
            PatchSet ps = currentPatchSet();
            if (ps == null) {
                return null;
            }
            try (Repository repo = repoManager.openRepository(project())) {
                Ref ref = repo.getRefDatabase().exactRef(c.getDest().get());
                SubmitTypeRecord str = submitTypeRecord();
                if (!str.isOk()) {
                    // No need to log, as SubmitRuleEvaluator already did it for us.
                    return false;
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
    }
    return mergeable;
}
#end_block

#method_before
@Override
public Response<String> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, ResourceNotFoundException, OrmException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new Input();
    }
    GroupDescription.Internal internalGroup = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new);
    if (!resource.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    String newDescription = Strings.emptyToNull(input.description);
    if (!Objects.equals(internalGroup.getDescription(), newDescription)) {
        AccountGroup.UUID groupUuid = internalGroup.getGroupUUID();
        try {
            groupsUpdateProvider.get().updateGroup(db.get(), groupUuid, group -> group.setDescription(newDescription));
        } catch (NoSuchGroupException e) {
            throw new ResourceNotFoundException(String.format("Group %s not found", groupUuid));
        }
    }
    return Strings.isNullOrEmpty(input.description) ? Response.<String>none() : Response.ok(input.description);
}
#method_after
@Override
public Response<String> apply(GroupResource resource, DescriptionInput input) throws AuthException, MethodNotAllowedException, ResourceNotFoundException, OrmException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new DescriptionInput();
    }
    GroupDescription.Internal internalGroup = resource.asInternalGroup().orElseThrow(MethodNotAllowedException::new);
    if (!resource.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    String newDescription = Strings.emptyToNull(input.description);
    if (!Objects.equals(internalGroup.getDescription(), newDescription)) {
        AccountGroup.UUID groupUuid = internalGroup.getGroupUUID();
        try {
            groupsUpdateProvider.get().updateGroup(db.get(), groupUuid, group -> group.setDescription(newDescription));
        } catch (NoSuchGroupException e) {
            throw new ResourceNotFoundException(String.format("Group %s not found", groupUuid));
        }
    }
    return Strings.isNullOrEmpty(input.description) ? Response.<String>none() : Response.ok(input.description);
}
#end_block

#method_before
@Override
public GroupDescription.Internal get(AccountGroup.UUID uuid) {
    if (!handles(uuid)) {
        return null;
    }
    AccountGroup g = groupCache.get(uuid);
    if (g == null) {
        return null;
    }
    return GroupDescriptions.forAccountGroup(g);
}
#method_after
@Override
public GroupDescription.Internal get(AccountGroup.UUID uuid) {
    if (!handles(uuid)) {
        return null;
    }
    return groupCache.get(uuid).map(InternalGroupDescription::new).orElse(null);
}
#end_block

#method_before
@Override
public Collection<GroupReference> suggest(String name, ProjectState project) {
    return groupCache.all().stream().filter(group -> group.getName().regionMatches(true, 0, name, 0, name.length()) && groupControlFactory.controlFor(group).isVisible()).map(GroupReference::forGroup).collect(toList());
}
#method_after
@Override
public Collection<GroupReference> suggest(String name, ProjectState project) {
    try (ReviewDb db = schema.open()) {
        return groups.getAll(db).filter(group -> startsWithIgnoreCase(group, name)).map(InternalGroupDescription::new).filter(this::isVisible).map(GroupReference::forGroup).collect(toList());
    } catch (OrmException e) {
        return ImmutableList.of();
    }
}
#end_block

#method_before
private Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeNotes notes, CurrentUser user, PatchSet ps, @Nullable RevWalk rw, @Nullable Config repoConfig, Iterable<PatchSetApproval> dontCopy) throws OrmException {
    checkNotNull(ps, "ps should not be null");
    ChangeData cd = changeDataFactory.create(db, notes);
    try {
        ProjectState project = projectCache.checkedGet(cd.change().getDest().getParentKey());
        ListMultimap<PatchSet.Id, PatchSetApproval> all = cd.approvals();
        checkNotNull(all, "all should not be null");
        Table<String, Account.Id, PatchSetApproval> wontCopy = HashBasedTable.create();
        for (PatchSetApproval psa : dontCopy) {
            wontCopy.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        Table<String, Account.Id, PatchSetApproval> byUser = HashBasedTable.create();
        for (PatchSetApproval psa : all.get(ps.getId())) {
            if (!wontCopy.contains(psa.getLabel(), psa.getAccountId())) {
                byUser.put(psa.getLabel(), psa.getAccountId(), psa);
            }
        }
        TreeMap<Integer, PatchSet> patchSets = getPatchSets(cd);
        // Walk patch sets strictly less than current in descending order.
        Collection<PatchSet> allPrior = patchSets.descendingMap().tailMap(ps.getId().get(), false).values();
        for (PatchSet priorPs : allPrior) {
            List<PatchSetApproval> priorApprovals = all.get(priorPs.getId());
            if (priorApprovals.isEmpty()) {
                continue;
            }
            ChangeKind kind = changeKindCache.getChangeKind(project.getNameKey(), rw, repoConfig, ObjectId.fromString(priorPs.getRevision().get()), ObjectId.fromString(ps.getRevision().get()));
            for (PatchSetApproval psa : priorApprovals) {
                if (wontCopy.contains(psa.getLabel(), psa.getAccountId())) {
                    continue;
                }
                if (byUser.contains(psa.getLabel(), psa.getAccountId())) {
                    continue;
                }
                if (!canCopy(project, psa, ps.getId(), kind)) {
                    wontCopy.put(psa.getLabel(), psa.getAccountId(), psa);
                    continue;
                }
                byUser.put(psa.getLabel(), psa.getAccountId(), copy(psa, ps.getId()));
            }
        }
        return labelNormalizer.normalize(notes, user, byUser.values()).getNormalized();
    } catch (IOException | PermissionBackendException e) {
        throw new OrmException(e);
    }
}
#method_after
private Iterable<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeNotes notes, CurrentUser user, PatchSet ps, @Nullable RevWalk rw, @Nullable Config repoConfig, Iterable<PatchSetApproval> dontCopy) throws OrmException {
    checkNotNull(ps, "ps should not be null");
    ChangeData cd = changeDataFactory.create(db, notes);
    try {
        ProjectState project = projectCache.checkedGet(cd.change().getDest().getParentKey());
        ListMultimap<PatchSet.Id, PatchSetApproval> all = cd.approvals();
        checkNotNull(all, "all should not be null");
        Table<String, Account.Id, PatchSetApproval> wontCopy = HashBasedTable.create();
        for (PatchSetApproval psa : dontCopy) {
            wontCopy.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        Table<String, Account.Id, PatchSetApproval> byUser = HashBasedTable.create();
        for (PatchSetApproval psa : all.get(ps.getId())) {
            if (!wontCopy.contains(psa.getLabel(), psa.getAccountId())) {
                byUser.put(psa.getLabel(), psa.getAccountId(), psa);
            }
        }
        TreeMap<Integer, PatchSet> patchSets = getPatchSets(cd);
        // Walk patch sets strictly less than current in descending order.
        Collection<PatchSet> allPrior = patchSets.descendingMap().tailMap(ps.getId().get(), false).values();
        for (PatchSet priorPs : allPrior) {
            List<PatchSetApproval> priorApprovals = all.get(priorPs.getId());
            if (priorApprovals.isEmpty()) {
                continue;
            }
            ChangeKind kind = changeKindCache.getChangeKind(project.getNameKey(), rw, repoConfig, ObjectId.fromString(priorPs.getRevision().get()), ObjectId.fromString(ps.getRevision().get()));
            for (PatchSetApproval psa : priorApprovals) {
                if (wontCopy.contains(psa.getLabel(), psa.getAccountId())) {
                    continue;
                }
                if (byUser.contains(psa.getLabel(), psa.getAccountId())) {
                    continue;
                }
                if (!canCopy(project, psa, ps.getId(), kind)) {
                    wontCopy.put(psa.getLabel(), psa.getAccountId(), psa);
                    continue;
                }
                byUser.put(psa.getLabel(), psa.getAccountId(), copy(psa, ps.getId()));
            }
        }
        return labelNormalizer.normalize(notes, user, byUser.values()).getNormalized();
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
public ImmutableSortedSet<String> star(Account.Id accountId, Project.NameKey project, Change.Id changeId, Set<String> labelsToAdd, Set<String> labelsToRemove) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(changeId, accountId);
        StarRef old = readLabels(repo, refName);
        Set<String> labels = new HashSet<>(old.labels());
        if (labelsToAdd != null) {
            labels.addAll(labelsToAdd);
        }
        if (labelsToRemove != null) {
            labels.removeAll(labelsToRemove);
        }
        if (labels.isEmpty()) {
            deleteRef(repo, refName, old.objectId());
        } else {
            checkMutuallyExclusiveLabels(labels);
            updateLabels(repo, refName, old.objectId(), labels);
        }
        indexer.index(dbProvider.get(), project, changeId);
        return ImmutableSortedSet.copyOf(labels);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#method_after
public ImmutableSortedSet<String> star(Account.Id accountId, Project.NameKey project, Change.Id changeId, Set<String> labelsToAdd, Set<String> labelsToRemove) throws OrmException, IllegalLabelException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(changeId, accountId);
        StarRef old = readLabels(repo, refName);
        Set<String> labels = new HashSet<>(old.labels());
        if (labelsToAdd != null) {
            labels.addAll(labelsToAdd);
        }
        if (labelsToRemove != null) {
            labels.removeAll(labelsToRemove);
        }
        if (labels.isEmpty()) {
            deleteRef(repo, refName, old.objectId());
        } else {
            checkMutuallyExclusiveLabels(labels);
            updateLabels(repo, refName, old.objectId(), labels);
        }
        indexer.index(dbProvider.get(), project, changeId);
        return ImmutableSortedSet.copyOf(labels);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#end_block

#method_before
public ImmutableListMultimap<Account.Id, String> byChangeFromIndex(Change.Id changeId) throws OrmException {
    Set<String> fields = ImmutableSet.of(ChangeField.ID.getName(), ChangeField.STAR.getName());
    List<ChangeData> changeData = queryProvider.get().setRequestedFields(fields).byLegacyChangeId(changeId);
    if (changeData.size() != 1) {
        throw new NoSuchChangeException(changeId);
    }
    return changeData.get(0).stars();
}
#method_after
public ImmutableListMultimap<Account.Id, String> byChangeFromIndex(Change.Id changeId) throws OrmException {
    List<ChangeData> changeData = queryProvider.get().setRequestedFields(ChangeField.ID, ChangeField.STAR).byLegacyChangeId(changeId);
    if (changeData.size() != 1) {
        throw new NoSuchChangeException(changeId);
    }
    return changeData.get(0).stars();
}
#end_block

#method_before
public void ignore(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException {
    star(accountId, project, changeId, ImmutableSet.of(IGNORE_LABEL), ImmutableSet.of());
}
#method_after
public void ignore(ChangeResource rsrc) throws OrmException, IllegalLabelException {
    star(rsrc.getUser().asIdentifiedUser().getAccountId(), rsrc.getProject(), rsrc.getChange().getId(), ImmutableSet.of(IGNORE_LABEL), ImmutableSet.of());
}
#end_block

#method_before
public void unignore(Account.Id accountId, Project.NameKey project, Change.Id changeId) throws OrmException {
    star(accountId, project, changeId, ImmutableSet.of(), ImmutableSet.of(IGNORE_LABEL));
}
#method_after
public void unignore(ChangeResource rsrc) throws OrmException, IllegalLabelException {
    star(rsrc.getUser().asIdentifiedUser().getAccountId(), rsrc.getProject(), rsrc.getChange().getId(), ImmutableSet.of(), ImmutableSet.of(IGNORE_LABEL));
}
#end_block

#method_before
private static StarRef readLabels(Repository repo, String refName) throws IOException {
    Ref ref = repo.exactRef(refName);
    if (ref == null) {
        return StarRef.MISSING;
    }
    try (ObjectReader reader = repo.newObjectReader()) {
        ObjectLoader obj = reader.open(ref.getObjectId(), Constants.OBJ_BLOB);
        return StarRef.create(ref, Splitter.on(CharMatcher.whitespace()).omitEmptyStrings().split(new String(obj.getCachedBytes(Integer.MAX_VALUE), UTF_8)));
    }
}
#method_after
public static StarRef readLabels(Repository repo, String refName) throws IOException {
    Ref ref = repo.exactRef(refName);
    if (ref == null) {
        return StarRef.MISSING;
    }
    try (ObjectReader reader = repo.newObjectReader()) {
        ObjectLoader obj = reader.open(ref.getObjectId(), Constants.OBJ_BLOB);
        return StarRef.create(ref, Splitter.on(CharMatcher.whitespace()).omitEmptyStrings().split(new String(obj.getCachedBytes(Integer.MAX_VALUE), UTF_8)));
    }
}
#end_block

#method_before
public static ObjectId writeLabels(Repository repo, Collection<String> labels) throws IOException {
    validateLabels(labels);
    try (ObjectInserter oi = repo.newObjectInserter()) {
        ObjectId id = oi.insert(Constants.OBJ_BLOB, labels.stream().sorted().distinct().collect(joining("\n")).getBytes(UTF_8));
        oi.flush();
        return id;
    }
}
#method_after
public static ObjectId writeLabels(Repository repo, Collection<String> labels) throws IOException, InvalidLabelsException {
    validateLabels(labels);
    try (ObjectInserter oi = repo.newObjectInserter()) {
        ObjectId id = oi.insert(Constants.OBJ_BLOB, labels.stream().sorted().distinct().collect(joining("\n")).getBytes(UTF_8));
        oi.flush();
        return id;
    }
}
#end_block

#method_before
private static void checkMutuallyExclusiveLabels(Set<String> labels) {
    if (labels.containsAll(ImmutableSet.of(DEFAULT_LABEL, IGNORE_LABEL))) {
        throw IllegalLabelException.mutuallyExclusiveLabels(DEFAULT_LABEL, IGNORE_LABEL);
    }
}
#method_after
private static void checkMutuallyExclusiveLabels(Set<String> labels) throws MutuallyExclusiveLabelsException {
    if (labels.containsAll(ImmutableSet.of(DEFAULT_LABEL, IGNORE_LABEL))) {
        throw new MutuallyExclusiveLabelsException(DEFAULT_LABEL, IGNORE_LABEL);
    }
    Set<Integer> reviewedPatchSets = getStarredPatchSets(labels, REVIEWED_LABEL);
    Set<Integer> unreviewedPatchSets = getStarredPatchSets(labels, UNREVIEWED_LABEL);
    Optional<Integer> ps = Sets.intersection(reviewedPatchSets, unreviewedPatchSets).stream().findFirst();
    if (ps.isPresent()) {
        throw new MutuallyExclusiveLabelsException(getReviewedLabel(ps.get()), getUnreviewedLabel(ps.get()));
    }
}
#end_block

#method_before
private static void validateLabels(Collection<String> labels) {
    if (labels == null) {
        return;
    }
    SortedSet<String> invalidLabels = new TreeSet<>();
    for (String label : labels) {
        if (CharMatcher.whitespace().matchesAnyOf(label)) {
            invalidLabels.add(label);
        }
    }
    if (!invalidLabels.isEmpty()) {
        throw IllegalLabelException.invalidLabels(invalidLabels);
    }
}
#method_after
private static void validateLabels(Collection<String> labels) throws InvalidLabelsException {
    if (labels == null) {
        return;
    }
    SortedSet<String> invalidLabels = new TreeSet<>();
    for (String label : labels) {
        if (CharMatcher.whitespace().matchesAnyOf(label)) {
            invalidLabels.add(label);
        }
    }
    if (!invalidLabels.isEmpty()) {
        throw new InvalidLabelsException(invalidLabels);
    }
}
#end_block

#method_before
private void updateLabels(Repository repo, String refName, ObjectId oldObjectId, Collection<String> labels) throws IOException, OrmException {
    try (RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(refName);
        u.setExpectedOldObjectId(oldObjectId);
        u.setForceUpdate(true);
        u.setNewObjectId(writeLabels(repo, labels));
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Update star labels", true);
        RefUpdate.Result result = u.update(rw);
        switch(result) {
            case NEW:
            case FORCED:
            case NO_CHANGE:
            case FAST_FORWARD:
                return;
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            case REJECTED_MISSING_OBJECT:
            case REJECTED_OTHER_REASON:
            default:
                throw new OrmException(String.format("Update star labels on ref %s failed: %s", refName, result.name()));
        }
    }
}
#method_after
private void updateLabels(Repository repo, String refName, ObjectId oldObjectId, Collection<String> labels) throws IOException, OrmException, InvalidLabelsException {
    try (RevWalk rw = new RevWalk(repo)) {
        RefUpdate u = repo.updateRef(refName);
        u.setExpectedOldObjectId(oldObjectId);
        u.setForceUpdate(true);
        u.setNewObjectId(writeLabels(repo, labels));
        u.setRefLogIdent(serverIdent);
        u.setRefLogMessage("Update star labels", true);
        RefUpdate.Result result = u.update(rw);
        switch(result) {
            case NEW:
            case FORCED:
            case NO_CHANGE:
            case FAST_FORWARD:
                gitRefUpdated.fire(allUsers, u, null);
                return;
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            case REJECTED_MISSING_OBJECT:
            case REJECTED_OTHER_REASON:
            default:
                throw new OrmException(String.format("Update star labels on ref %s failed: %s", refName, result.name()));
        }
    }
}
#end_block

#method_before
private void deleteRef(Repository repo, String refName, ObjectId oldObjectId) throws IOException, OrmException {
    RefUpdate u = repo.updateRef(refName);
    u.setForceUpdate(true);
    u.setExpectedOldObjectId(oldObjectId);
    u.setRefLogIdent(serverIdent);
    u.setRefLogMessage("Unstar change", true);
    RefUpdate.Result result = u.delete();
    switch(result) {
        case FORCED:
            return;
        case NEW:
        case NO_CHANGE:
        case FAST_FORWARD:
        case IO_FAILURE:
        case LOCK_FAILURE:
        case NOT_ATTEMPTED:
        case REJECTED:
        case REJECTED_CURRENT_BRANCH:
        case RENAMED:
        case REJECTED_MISSING_OBJECT:
        case REJECTED_OTHER_REASON:
        default:
            throw new OrmException(String.format("Delete star ref %s failed: %s", refName, result.name()));
    }
}
#method_after
private void deleteRef(Repository repo, String refName, ObjectId oldObjectId) throws IOException, OrmException {
    RefUpdate u = repo.updateRef(refName);
    u.setForceUpdate(true);
    u.setExpectedOldObjectId(oldObjectId);
    u.setRefLogIdent(serverIdent);
    u.setRefLogMessage("Unstar change", true);
    RefUpdate.Result result = u.delete();
    switch(result) {
        case FORCED:
            gitRefUpdated.fire(allUsers, u, null);
            return;
        case NEW:
        case NO_CHANGE:
        case FAST_FORWARD:
        case IO_FAILURE:
        case LOCK_FAILURE:
        case NOT_ATTEMPTED:
        case REJECTED:
        case REJECTED_CURRENT_BRANCH:
        case RENAMED:
        case REJECTED_MISSING_OBJECT:
        case REJECTED_OTHER_REASON:
        default:
            throw new OrmException(String.format("Delete star ref %s failed: %s", refName, result.name()));
    }
}
#end_block

#method_before
private SiteIndexer.Result reindexGroups(GroupIndex index, List<AccountGroup.UUID> uuids, ProgressMonitor progress) {
    progress.beginTask("Reindexing groups", uuids.size());
    List<ListenableFuture<?>> futures = new ArrayList<>(uuids.size());
    AtomicBoolean ok = new AtomicBoolean(true);
    AtomicInteger done = new AtomicInteger();
    AtomicInteger failed = new AtomicInteger();
    Stopwatch sw = Stopwatch.createStarted();
    for (AccountGroup.UUID uuid : uuids) {
        String desc = "group " + uuid;
        ListenableFuture<?> future = executor.submit(() -> {
            try {
                AccountGroup oldGroup = groupCache.get(uuid);
                if (oldGroup != null) {
                    groupCache.evict(oldGroup);
                }
                index.replace(groupCache.get(uuid));
                verboseWriter.println("Reindexed " + desc);
                done.incrementAndGet();
            } catch (Exception e) {
                failed.incrementAndGet();
                throw e;
            }
            return null;
        });
        addErrorListener(future, desc, progress, ok);
        futures.add(future);
    }
    try {
        Futures.successfulAsList(futures).get();
    } catch (ExecutionException | InterruptedException e) {
        log.error("Error waiting on group futures", e);
        return new SiteIndexer.Result(sw, false, 0, 0);
    }
    progress.endTask();
    return new SiteIndexer.Result(sw, ok.get(), done.get(), failed.get());
}
#method_after
private SiteIndexer.Result reindexGroups(GroupIndex index, List<AccountGroup.UUID> uuids, ProgressMonitor progress) {
    progress.beginTask("Reindexing groups", uuids.size());
    List<ListenableFuture<?>> futures = new ArrayList<>(uuids.size());
    AtomicBoolean ok = new AtomicBoolean(true);
    AtomicInteger done = new AtomicInteger();
    AtomicInteger failed = new AtomicInteger();
    Stopwatch sw = Stopwatch.createStarted();
    for (AccountGroup.UUID uuid : uuids) {
        String desc = "group " + uuid;
        ListenableFuture<?> future = executor.submit(() -> {
            try {
                Optional<InternalGroup> oldGroup = groupCache.get(uuid);
                if (oldGroup.isPresent()) {
                    InternalGroup group = oldGroup.get();
                    groupCache.evict(group.getGroupUUID(), group.getId(), group.getNameKey());
                }
                Optional<InternalGroup> internalGroup = groupCache.get(uuid);
                if (internalGroup.isPresent()) {
                    index.replace(internalGroup.get());
                } else {
                    index.delete(uuid);
                }
                verboseWriter.println("Reindexed " + desc);
                done.incrementAndGet();
            } catch (Exception e) {
                failed.incrementAndGet();
                throw e;
            }
            return null;
        });
        addErrorListener(future, desc, progress, ok);
        futures.add(future);
    }
    try {
        Futures.successfulAsList(futures).get();
    } catch (ExecutionException | InterruptedException e) {
        log.error("Error waiting on group futures", e);
        return new SiteIndexer.Result(sw, false, 0, 0);
    }
    progress.endTask();
    return new SiteIndexer.Result(sw, ok.get(), done.get(), failed.get());
}
#end_block

#method_before
private List<AccountGroup.UUID> collectGroups(ProgressMonitor progress) throws OrmException {
    progress.beginTask("Collecting groups", ProgressMonitor.UNKNOWN);
    try (ReviewDb db = schemaFactory.open()) {
        return groups.getAll(db).map(AccountGroup::getGroupUUID).collect(toImmutableList());
    } finally {
        progress.endTask();
    }
}
#method_after
private List<AccountGroup.UUID> collectGroups(ProgressMonitor progress) throws OrmException {
    progress.beginTask("Collecting groups", ProgressMonitor.UNKNOWN);
    try (ReviewDb db = schemaFactory.open()) {
        return groups.getAllUuids(db).collect(toImmutableList());
    } finally {
        progress.endTask();
    }
}
#end_block

#method_before
@Override
public MergeableInfo apply(RevisionResource resource) throws AuthException, ResourceConflictException, BadRequestException, OrmException, IOException {
    Change change = resource.getChange();
    PatchSet ps = resource.getPatchSet();
    MergeableInfo result = new MergeableInfo();
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    } else if (!ps.getId().equals(change.currentPatchSetId())) {
        // Only the current revision is mergeable. Others always fail.
        return result;
    }
    ChangeData cd = changeDataFactory.create(db.get(), resource.getControl());
    result.submitType = getSubmitType(cd, ps);
    try (Repository git = gitManager.openRepository(change.getProject())) {
        ObjectId commit = toId(ps);
        Ref ref = git.getRefDatabase().exactRef(change.getDest().get());
        ProjectState projectState = projectCache.get(change.getProject());
        String strategy = mergeUtilFactory.create(projectState).mergeStrategyName();
        result.strategy = strategy;
        result.mergeable = isMergable(git, change, commit, ref, result.submitType, strategy);
        if (otherBranches) {
            result.mergeableInto = new ArrayList<>();
            BranchOrderSection branchOrder = projectState.getBranchOrderSection();
            if (branchOrder != null) {
                int prefixLen = Constants.R_HEADS.length();
                String[] names = branchOrder.getMoreStable(ref.getName());
                Map<String, Ref> refs = git.getRefDatabase().exactRef(names);
                for (String n : names) {
                    Ref other = refs.get(n);
                    if (other == null) {
                        continue;
                    }
                    if (cache.get(commit, other, SubmitType.CHERRY_PICK, strategy, change.getDest(), git)) {
                        result.mergeableInto.add(other.getName().substring(prefixLen));
                    }
                }
            }
        }
    }
    return result;
}
#method_after
@Override
public MergeableInfo apply(RevisionResource resource) throws AuthException, ResourceConflictException, BadRequestException, OrmException, IOException {
    Change change = resource.getChange();
    PatchSet ps = resource.getPatchSet();
    MergeableInfo result = new MergeableInfo();
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    } else if (!ps.getId().equals(change.currentPatchSetId())) {
        // Only the current revision is mergeable. Others always fail.
        return result;
    }
    ChangeData cd = changeDataFactory.create(db.get(), resource.getNotes());
    result.submitType = getSubmitType(resource.getUser(), cd, ps);
    try (Repository git = gitManager.openRepository(change.getProject())) {
        ObjectId commit = toId(ps);
        Ref ref = git.getRefDatabase().exactRef(change.getDest().get());
        ProjectState projectState = projectCache.get(change.getProject());
        String strategy = mergeUtilFactory.create(projectState).mergeStrategyName();
        result.strategy = strategy;
        result.mergeable = isMergable(git, change, commit, ref, result.submitType, strategy);
        if (otherBranches) {
            result.mergeableInto = new ArrayList<>();
            BranchOrderSection branchOrder = projectState.getBranchOrderSection();
            if (branchOrder != null) {
                int prefixLen = Constants.R_HEADS.length();
                String[] names = branchOrder.getMoreStable(ref.getName());
                Map<String, Ref> refs = git.getRefDatabase().exactRef(names);
                for (String n : names) {
                    Ref other = refs.get(n);
                    if (other == null) {
                        continue;
                    }
                    if (cache.get(commit, other, SubmitType.CHERRY_PICK, strategy, change.getDest(), git)) {
                        result.mergeableInto.add(other.getName().substring(prefixLen));
                    }
                }
            }
        }
    }
    return result;
}
#end_block

#method_before
private SubmitType getSubmitType(ChangeData cd, PatchSet patchSet) throws OrmException {
    SubmitTypeRecord rec = new SubmitRuleEvaluator(accountCache, accounts, emails, cd).setPatchSet(patchSet).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new OrmException("Submit type rule failed: " + rec);
    }
    return rec.type;
}
#method_after
private SubmitType getSubmitType(CurrentUser user, ChangeData cd, PatchSet patchSet) throws OrmException {
    SubmitTypeRecord rec = submitRuleEvaluatorFactory.create(user, cd).setPatchSet(patchSet).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new OrmException("Submit type rule failed: " + rec);
    }
    return rec.type;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Rebase post(ChangeResource parent) throws RestApiException {
    return rebase;
}
#method_after
@Override
public Rebase post(ChangeResource parent) throws RestApiException {
    return rebase;
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, Rebase.Input in) throws AuthException, ResourceConflictException, IOException, OrmException, PermissionBackendException {
    Project.NameKey project = rsrc.getProject();
    try (Repository repository = repositoryManager.openRepository(project)) {
        editModifier.rebaseEdit(repository, rsrc.getNotes());
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, Input in) throws AuthException, ResourceConflictException, IOException, OrmException, PermissionBackendException {
    Project.NameKey project = rsrc.getProject();
    try (Repository repository = repositoryManager.openRepository(project)) {
        editModifier.rebaseEdit(repository, rsrc.getNotes());
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
protected Response<CommentInfo> applyImpl(BatchUpdate.Factory updateFactory, DraftCommentResource rsrc, Input input) throws RestApiException, UpdateException {
    try (BatchUpdate bu = updateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getControl().getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc.getComment().key);
        bu.addOp(rsrc.getChange().getId(), op);
        bu.execute();
    }
    return Response.none();
}
#method_after
@Override
protected Response<CommentInfo> applyImpl(BatchUpdate.Factory updateFactory, DraftCommentResource rsrc, Input input) throws RestApiException, UpdateException {
    try (BatchUpdate bu = updateFactory.create(db.get(), rsrc.getChange().getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc.getComment().key);
        bu.addOp(rsrc.getChange().getId(), op);
        bu.execute();
    }
    return Response.none();
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    cmd = new ReceiveCommand(ObjectId.zeroId(), commitId, psId.toRefName());
    validate(ctx);
    if (!updateRef) {
        return;
    }
    ctx.addRefUpdate(cmd);
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    cmd = new ReceiveCommand(ObjectId.zeroId(), commitId, psId.toRefName());
    projectState = projectCache.checkedGet(ctx.getProject());
    validate(ctx);
    if (!updateRef) {
        return;
    }
    ctx.addRefUpdate(cmd);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, PermissionBackendException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    update.setPrivate(isPrivate);
    update.setWorkInProgress(workInProgress);
    if (revertOf != null) {
        update.setRevertOf(revertOf.get());
    }
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commitId);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commitId, draft, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    Set<Account.Id> reviewersToAdd = new HashSet<>(reviewers);
    if (migration.readChanges()) {
        approvalsUtil.addCcs(ctx.getNotes(), update, filterOnChangeVisibility(db, ctx.getNotes(), extraCC));
    } else {
        reviewersToAdd.addAll(extraCC);
    }
    LabelTypes labelTypes = ctl.getProjectControl().getProjectState().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewersToAdd), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getUser(), approvals);
    // reviewer which is needed in several other code paths.
    if (!approvals.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.uploadedPatchSetTag(workInProgress));
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, PermissionBackendException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    update.setPrivate(isPrivate);
    update.setWorkInProgress(workInProgress);
    if (revertOf != null) {
        update.setRevertOf(revertOf.get());
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commitId);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commitId, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    Set<Account.Id> reviewersToAdd = new HashSet<>(reviewers);
    if (migration.readChanges()) {
        approvalsUtil.addCcs(ctx.getNotes(), update, filterOnChangeVisibility(db, ctx.getNotes(), extraCC));
    } else {
        reviewersToAdd.addAll(extraCC);
    }
    LabelTypes labelTypes = projectState.getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewersToAdd), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getUser(), approvals);
    // reviewer which is needed in several other code paths.
    if (!approvals.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.uploadedPatchSetTag(workInProgress));
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException, IOException {
    if (sendMail && (notify != NotifyHandling.NONE || !accountsToNotify.isEmpty())) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getProject(), change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.setNotify(notify);
                    cm.setAccountsToNotify(accountsToNotify);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            @SuppressWarnings("unused")
            Future<?> possiblyIgnoredError = sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
        if (approvals != null && !approvals.isEmpty()) {
            List<LabelType> labels = projectCache.checkedGet(ctx.getProject()).getLabelTypes(change.getDest(), ctx.getUser()).getLabelTypes();
            Map<String, Short> allApprovals = new HashMap<>();
            Map<String, Short> oldApprovals = new HashMap<>();
            for (LabelType lt : labels) {
                allApprovals.put(lt.getName(), (short) 0);
                oldApprovals.put(lt.getName(), null);
            }
            for (Map.Entry<String, Short> entry : approvals.entrySet()) {
                if (entry.getValue() != 0) {
                    allApprovals.put(entry.getKey(), entry.getValue());
                    oldApprovals.put(entry.getKey(), (short) 0);
                }
            }
            commentAdded.fire(change, patchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException, IOException {
    if (sendMail && (notify != NotifyHandling.NONE || !accountsToNotify.isEmpty())) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getProject(), change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.setNotify(notify);
                    cm.setAccountsToNotify(accountsToNotify);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            @SuppressWarnings("unused")
            Future<?> possiblyIgnoredError = sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
        if (approvals != null && !approvals.isEmpty()) {
            List<LabelType> labels = projectState.getLabelTypes(change.getDest(), ctx.getUser()).getLabelTypes();
            Map<String, Short> allApprovals = new HashMap<>();
            Map<String, Short> oldApprovals = new HashMap<>();
            for (LabelType lt : labels) {
                allApprovals.put(lt.getName(), (short) 0);
                oldApprovals.put(lt.getName(), null);
            }
            for (Map.Entry<String, Short> entry : approvals.entrySet()) {
                if (entry.getValue() != 0) {
                    allApprovals.put(entry.getKey(), entry.getValue());
                    oldApprovals.put(entry.getKey(), (short) 0);
                }
            }
            commentAdded.fire(change, patchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
        }
    }
}
#end_block

#method_before
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (!validate) {
        return;
    }
    PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).project(ctx.getProject()).ref(refName);
    try {
        try (CommitReceivedEvent event = new CommitReceivedEvent(cmd, projectCache.checkedGet(ctx.getProject()).getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) {
            commitValidatorsFactory.forGerritCommits(perm, new Branch.NameKey(ctx.getProject(), refName), ctx.getIdentifiedUser(), new NoSshInfo(), ctx.getRevWalk()).validate(event);
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (!validate) {
        return;
    }
    PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).project(ctx.getProject()).ref(refName);
    try {
        try (CommitReceivedEvent event = new CommitReceivedEvent(cmd, projectState.getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) {
            commitValidatorsFactory.forGerritCommits(perm, new Branch.NameKey(ctx.getProject(), refName), ctx.getIdentifiedUser(), new NoSshInfo(), ctx.getRevWalk()).validate(event);
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    }
}
#end_block

#method_before
@Override
public Response<?> apply(GroupResource rsrc, Input input) throws IOException, AuthException, UnprocessableEntityException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("not allowed to index group");
    }
    AccountGroup.UUID groupUuid = rsrc.getGroup().getGroupUUID();
    if (!rsrc.isInternalGroup()) {
        throw new UnprocessableEntityException(String.format("External Group Not Allowed: %s", groupUuid.get()));
    }
    AccountGroup accountGroup = groupCache.get(groupUuid);
    // evicting the group from the cache, reindexes the group
    groupCache.evict(accountGroup);
    return Response.none();
}
#method_after
@Override
public Response<?> apply(GroupResource rsrc, Input input) throws IOException, AuthException, UnprocessableEntityException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("not allowed to index group");
    }
    AccountGroup.UUID groupUuid = rsrc.getGroup().getGroupUUID();
    if (!rsrc.isInternalGroup()) {
        throw new UnprocessableEntityException(String.format("External Group Not Allowed: %s", groupUuid.get()));
    }
    Optional<InternalGroup> group = groupCache.get(groupUuid);
    // evicting the group from the cache, reindexes the group
    if (group.isPresent()) {
        groupCache.evict(group.get().getGroupUUID(), group.get().getId(), group.get().getNameKey());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public List<ReflogEntryInfo> apply(BranchResource rsrc) throws RestApiException, IOException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("not project owner");
    }
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        ReflogReader r;
        try {
            r = repo.getReflogReader(rsrc.getRef());
        } catch (UnsupportedOperationException e) {
            String msg = "reflog not supported on repo " + rsrc.getNameKey().get();
            log.error(msg);
            throw new MethodNotAllowedException(msg);
        }
        if (r == null) {
            throw new ResourceNotFoundException(rsrc.getRef());
        }
        List<ReflogEntry> entries;
        if (from == null && to == null) {
            entries = limit > 0 ? r.getReverseEntries(limit) : r.getReverseEntries();
        } else {
            entries = limit > 0 ? new ArrayList<>(limit) : new ArrayList<>();
            for (ReflogEntry e : r.getReverseEntries()) {
                Timestamp timestamp = new Timestamp(e.getWho().getWhen().getTime());
                if ((from == null || from.before(timestamp)) && (to == null || to.after(timestamp))) {
                    entries.add(e);
                }
                if (limit > 0 && entries.size() >= limit) {
                    break;
                }
            }
        }
        return Lists.transform(entries, e -> newReflogEntryInfo(e));
    }
}
#method_after
@Override
public List<ReflogEntryInfo> apply(BranchResource rsrc) throws RestApiException, IOException, PermissionBackendException {
    permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey()).check(ProjectPermission.READ_REFLOG);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        ReflogReader r;
        try {
            r = repo.getReflogReader(rsrc.getRef());
        } catch (UnsupportedOperationException e) {
            String msg = "reflog not supported on repo " + rsrc.getNameKey().get();
            log.error(msg);
            throw new MethodNotAllowedException(msg);
        }
        if (r == null) {
            throw new ResourceNotFoundException(rsrc.getRef());
        }
        List<ReflogEntry> entries;
        if (from == null && to == null) {
            entries = limit > 0 ? r.getReverseEntries(limit) : r.getReverseEntries();
        } else {
            entries = limit > 0 ? new ArrayList<>(limit) : new ArrayList<>();
            for (ReflogEntry e : r.getReverseEntries()) {
                Timestamp timestamp = new Timestamp(e.getWho().getWhen().getTime());
                if ((from == null || from.before(timestamp)) && (to == null || to.after(timestamp))) {
                    entries.add(e);
                }
                if (limit > 0 && entries.size() >= limit) {
                    break;
                }
            }
        }
        return Lists.transform(entries, e -> newReflogEntryInfo(e));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    put(PROJECT_KIND, "access:review").to(CreateAccessChange.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    post(PROJECT_KIND, "index").to(Index.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    get(COMMIT_KIND, "in").to(CommitIncludedIn.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    post(COMMIT_KIND, "cherrypick").to(CherryPickCommit.class);
    factory(DeleteRef.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    DynamicMap.mapOf(binder(), TAG_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "access").to(GetAccess.class);
    post(PROJECT_KIND, "access").to(SetAccess.class);
    put(PROJECT_KIND, "access:review").to(CreateAccessChange.class);
    post(PROJECT_KIND, "check.access").to(CheckAccess.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    put(PROJECT_KIND, "ban").to(BanCommit.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    post(PROJECT_KIND, "index").to(Index.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    post(PROJECT_KIND, "branches:delete").to(DeleteBranches.class);
    factory(CreateBranch.Factory.class);
    get(BRANCH_KIND, "mergeable").to(CheckMergeability.class);
    factory(RefValidationHelper.Factory.class);
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    get(COMMIT_KIND, "in").to(CommitIncludedIn.class);
    child(COMMIT_KIND, "files").to(FilesInCommitCollection.class);
    child(PROJECT_KIND, "tags").to(TagsCollection.class);
    get(TAG_KIND).to(GetTag.class);
    put(TAG_KIND).to(PutTag.class);
    delete(TAG_KIND).to(DeleteTag.class);
    post(PROJECT_KIND, "tags:delete").to(DeleteTags.class);
    factory(CreateTag.Factory.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    factory(CreateProject.Factory.class);
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
    post(COMMIT_KIND, "cherrypick").to(CherryPickCommit.class);
    factory(DeleteRef.Factory.class);
}
#end_block

#method_before
@Override
public TagResource parse(ProjectResource resource, IdString id) throws ResourceNotFoundException, IOException {
    return new TagResource(resource.getControl(), list.get().get(resource, id));
}
#method_after
@Override
public TagResource parse(ProjectResource rsrc, IdString id) throws ResourceNotFoundException, IOException {
    return new TagResource(rsrc.getProjectState(), rsrc.getUser(), list.get().get(rsrc, id));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public CreateTag create(ProjectResource resource, IdString name) {
    return createTagFactory.create(name.get());
}
#method_after
@Override
public CreateTag create(ProjectResource resource, IdString name) {
    return createTagFactory.create(name.get());
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    try {
        deleteChangeEdit.apply(changeResource, new DeleteChangeEdit.Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot delete change edit", e);
    }
}
#method_after
@Override
public void delete() throws RestApiException {
    try {
        deleteChangeEdit.apply(changeResource, new Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot delete change edit", e);
    }
}
#end_block

#method_before
@Nullable
private Addition addWholeGroup(String reviewer, ChangeResource rsrc, ReviewerState state, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify, boolean confirmed, boolean allowGroup, boolean allowByEmail) throws OrmException, IOException, PermissionBackendException {
    if (!allowGroup) {
        return null;
    }
    GroupDescription.Basic group = null;
    try {
        group = groupsCollection.parseInternal(reviewer);
    } catch (UnprocessableEntityException e) {
        if (!allowByEmail) {
            return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerNotFoundUserOrGroup, reviewer));
        }
        return null;
    }
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName()));
    }
    Set<Account.Id> reviewers = new HashSet<>();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(rsrc.getUser()).listAccounts(group.getGroupUUID(), rsrc.getProject());
    } catch (NoSuchGroupException e) {
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerNotFoundUserOrGroup, group.getName()));
    } catch (NoSuchProjectException e) {
        return fail(reviewer, e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName()));
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!confirmed && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        return fail(reviewer, true, MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size()));
    }
    PermissionBackend.ForRef perm = permissionBackend.user(rsrc.getUser()).ref(rsrc.getChange().getDest());
    for (Account member : members) {
        if (isValidReviewer(member, perm)) {
            reviewers.add(member.getId());
        }
    }
    return new Addition(reviewer, rsrc, reviewers, null, state, notify, accountsToNotify);
}
#method_after
@Nullable
private Addition addWholeGroup(String reviewer, ChangeResource rsrc, ReviewerState state, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify, boolean confirmed, boolean allowGroup, boolean allowByEmail) throws OrmException, IOException, PermissionBackendException {
    if (!allowGroup) {
        return null;
    }
    GroupDescription.Basic group = null;
    try {
        group = groupsCollection.parseInternal(reviewer);
    } catch (UnprocessableEntityException e) {
        if (!allowByEmail) {
            return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerNotFoundUserOrGroup, reviewer));
        }
        return null;
    }
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName()));
    }
    Set<Account.Id> reviewers = new HashSet<>();
    Set<Account> members;
    try {
        members = groupMembers.listAccounts(group.getGroupUUID(), rsrc.getProject());
    } catch (NoSuchGroupException e) {
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().reviewerNotFoundUserOrGroup, group.getName()));
    } catch (NoSuchProjectException e) {
        return fail(reviewer, e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        return fail(reviewer, MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName()));
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!confirmed && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        return fail(reviewer, true, MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size()));
    }
    PermissionBackend.ForRef perm = permissionBackend.user(rsrc.getUser()).ref(rsrc.getChange().getDest());
    for (Account member : members) {
        if (isValidReviewer(member, perm)) {
            reviewers.add(member.getId());
        }
    }
    return new Addition(reviewer, rsrc, reviewers, null, state, notify, accountsToNotify);
}
#end_block

#method_before
void gatherResults() throws OrmException, PermissionBackendException {
    if (notes == null || caller == null) {
        // in the contained AddReviewerResult.
        return;
    }
    ChangeData cd = changeDataFactory.create(dbProvider.get(), notes);
    PermissionBackend.ForChange perm = permissionBackend.user(caller).database(dbProvider).change(cd);
    // Generate result details and fill AccountLoader. This occurs outside
    // the Op because the accounts are in a different table.
    PostReviewersOp.Result opResult = op.getResult();
    if (migration.readChanges() && state == CC) {
        result.ccs = Lists.newArrayListWithCapacity(opResult.addedCCs().size());
        for (Account.Id accountId : opResult.addedCCs()) {
            IdentifiedUser u = identifiedUserFactory.create(accountId);
            result.ccs.add(json.format(new ReviewerInfo(accountId.get()), perm.user(u), cd));
        }
        accountLoaderFactory.create(true).fill(result.ccs);
        for (Address a : reviewersByEmail) {
            result.ccs.add(new AccountInfo(a.getName(), a.getEmail()));
        }
    } else {
        result.reviewers = Lists.newArrayListWithCapacity(opResult.addedReviewers().size());
        for (PatchSetApproval psa : opResult.addedReviewers()) {
            // New reviewers have value 0, don't bother normalizing.
            IdentifiedUser u = identifiedUserFactory.create(psa.getAccountId());
            result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId().get()), perm.user(u), cd, ImmutableList.of(psa)));
        }
        accountLoaderFactory.create(true).fill(result.reviewers);
        for (Address a : reviewersByEmail) {
            result.reviewers.add(ReviewerInfo.byEmail(a.getName(), a.getEmail()));
        }
    }
}
#method_after
void gatherResults() throws OrmException, PermissionBackendException {
    if (notes == null || caller == null) {
        // in the contained AddReviewerResult.
        return;
    }
    ChangeData cd = changeDataFactory.create(dbProvider.get(), notes);
    PermissionBackend.ForChange perm = permissionBackend.user(caller).database(dbProvider).change(cd);
    // Generate result details and fill AccountLoader. This occurs outside
    // the Op because the accounts are in a different table.
    PostReviewersOp.Result opResult = op.getResult();
    if (migration.readChanges() && state == CC) {
        result.ccs = Lists.newArrayListWithCapacity(opResult.addedCCs().size());
        for (Account.Id accountId : opResult.addedCCs()) {
            IdentifiedUser u = identifiedUserFactory.create(accountId);
            result.ccs.add(json.format(caller, new ReviewerInfo(accountId.get()), perm.user(u), cd));
        }
        accountLoaderFactory.create(true).fill(result.ccs);
        for (Address a : reviewersByEmail) {
            result.ccs.add(new AccountInfo(a.getName(), a.getEmail()));
        }
    } else {
        result.reviewers = Lists.newArrayListWithCapacity(opResult.addedReviewers().size());
        for (PatchSetApproval psa : opResult.addedReviewers()) {
            // New reviewers have value 0, don't bother normalizing.
            IdentifiedUser u = identifiedUserFactory.create(psa.getAccountId());
            result.reviewers.add(json.format(caller, new ReviewerInfo(psa.getAccountId().get()), perm.user(u), cd, ImmutableList.of(psa)));
        }
        accountLoaderFactory.create(true).fill(result.reviewers);
        for (Address a : reviewersByEmail) {
            result.reviewers.add(ReviewerInfo.byEmail(a.getName(), a.getEmail()));
        }
    }
}
#end_block

#method_before
@Override
public List<Record> apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(accountCache, accounts, emails, changeDataFactory.create(db.get(), rsrc.getControl()));
    List<SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluate();
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountLoader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    if (!out.isEmpty()) {
        out.get(0).prologReductionCount = evaluator.getReductionsConsumed();
    }
    accounts.fill();
    return out;
}
#method_after
@Override
public List<Record> apply(RevisionResource rsrc, TestSubmitRuleInput input) throws AuthException, OrmException {
    if (input == null) {
        input = new TestSubmitRuleInput();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = submitRuleEvaluatorFactory.create(rsrc.getUser(), changeDataFactory.create(db.get(), rsrc.getNotes()));
    List<SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluate();
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountLoader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    if (!out.isEmpty()) {
        out.get(0).prologReductionCount = evaluator.getReductionsConsumed();
    }
    accounts.fill();
    return out;
}
#end_block

#method_before
protected <K, V, I extends Index<K, V>> void initIndex(IndexDefinition<K, V, I> def, GerritIndexStatus cfg) {
    TreeMap<Integer, Version<V>> versions = scanVersions(def, cfg);
    // Search from the most recent ready version.
    // Write to the most recent ready version and the most recent version.
    Version<V> search = null;
    List<Version<V>> write = Lists.newArrayListWithCapacity(2);
    for (Version<V> v : versions.descendingMap().values()) {
        if (v.schema == null) {
            continue;
        }
        if (write.isEmpty() && onlineUpgrade) {
            write.add(v);
        }
        if (v.ready) {
            search = v;
            if (!write.contains(v)) {
                write.add(v);
            }
            break;
        }
    }
    if (search == null) {
        throw new ProvisionException(String.format(runReindexMsg, def.getName()));
    }
    IndexFactory<K, V, I> factory = def.getIndexFactory();
    I searchIndex = factory.create(search.schema);
    IndexCollection<K, V, I> indexes = def.getIndexCollection();
    indexes.setSearchIndex(searchIndex);
    for (Version<V> v : write) {
        if (v.version != search.version) {
            indexes.addWriteIndex(factory.create(v.schema));
        } else {
            indexes.addWriteIndex(searchIndex);
        }
    }
    markNotReady(def.getName(), versions.values(), write);
    synchronized (this) {
        if (!reindexers.containsKey(def.getName())) {
            int latest = write.get(0).version;
            OnlineReindexer<K, V, I> reindexer = new OnlineReindexer<>(def, search.version, latest, listeners);
            reindexers.put(def.getName(), reindexer);
        }
    }
}
#method_after
protected <K, V, I extends Index<K, V>> void initIndex(IndexDefinition<K, V, I> def, GerritIndexStatus cfg) {
    TreeMap<Integer, Version<V>> versions = scanVersions(def, cfg);
    // Search from the most recent ready version.
    // Write to the most recent ready version and the most recent version.
    Version<V> search = null;
    List<Version<V>> write = Lists.newArrayListWithCapacity(2);
    for (Version<V> v : versions.descendingMap().values()) {
        if (v.schema == null) {
            continue;
        }
        if (write.isEmpty() && onlineUpgrade) {
            write.add(v);
        }
        if (v.ready) {
            search = v;
            if (!write.contains(v)) {
                write.add(v);
            }
            break;
        }
    }
    if (search == null) {
        throw new ProvisionException(String.format(runReindexMsg, def.getName(), def.getName()));
    }
    IndexFactory<K, V, I> factory = def.getIndexFactory();
    I searchIndex = factory.create(search.schema);
    IndexCollection<K, V, I> indexes = def.getIndexCollection();
    indexes.setSearchIndex(searchIndex);
    for (Version<V> v : write) {
        if (v.version != search.version) {
            indexes.addWriteIndex(factory.create(v.schema));
        } else {
            indexes.addWriteIndex(searchIndex);
        }
    }
    markNotReady(def.getName(), versions.values(), write);
    synchronized (this) {
        if (!reindexers.containsKey(def.getName())) {
            int latest = write.get(0).version;
            OnlineReindexer<K, V, I> reindexer = new OnlineReindexer<>(def, search.version, latest, listeners);
            reindexers.put(def.getName(), reindexer);
        }
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setStatus(change.getStatus());
    message = newMessage(ctx);
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setStatus(change.getStatus());
    message = newMessage(ctx);
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#end_block

#method_before
public List<SubmitRecord> evaluate() {
    initOptions();
    Change c = control.getChange();
    if (!opts.allowClosed() && c.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!opts.allowDraft()) {
        try {
            initPatchSet();
        } catch (OrmException e) {
            return ruleError("Error looking up patch set " + control.getChange().currentPatchSetId(), e);
        }
        if (c.getStatus() == Change.Status.DRAFT || patchSet.isDraft()) {
            return cannotSubmitDraft();
        }
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", control.getUser());
    } catch (RuleEvalException e) {
        return ruleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // whether or not that is actually possible given the permissions.
        return ruleError(String.format("Submit rule '%s' for change %s of %s has no solution.", getSubmitRuleName(), cd.getId(), getProjectName()));
    }
    return resultsToSubmitRecord(getSubmitRule(), results);
}
#method_after
public List<SubmitRecord> evaluate() {
    initOptions();
    try {
        init();
    } catch (OrmException e) {
        return ruleError("Error looking up change " + cd.getId(), e);
    }
    if (!opts.allowClosed() && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", user);
    } catch (RuleEvalException e) {
        return ruleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // whether or not that is actually possible given the permissions.
        return ruleError(String.format("Submit rule '%s' for change %s of %s has no solution.", getSubmitRuleName(), cd.getId(), getProjectName()));
    }
    return resultsToSubmitRecord(getSubmitRule(), results);
}
#end_block

#method_before
public SubmitTypeRecord getSubmitType() {
    initOptions();
    try {
        initPatchSet();
    } catch (OrmException e) {
        return typeError("Error looking up patch set " + control.getChange().currentPatchSetId(), e);
    }
    try {
        if (control.getChange().getStatus() == Change.Status.DRAFT && !control.isDraftVisible(cd.db(), cd)) {
            return SubmitTypeRecord.error("Patch set " + patchSet.getId() + " not found");
        }
        if (patchSet.isDraft() && !control.isDraftVisible(cd.db(), cd)) {
            return SubmitTypeRecord.error("Patch set " + patchSet.getId() + " not found");
        }
    } catch (OrmException err) {
        String msg = "Cannot read patch set " + patchSet.getId();
        log.error(msg, err);
        return SubmitTypeRecord.error(msg);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results", // have a consistent view of the submit type.
        null);
    } catch (RuleEvalException e) {
        return typeError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " has no solution.");
    }
    Term typeTerm = results.get(0);
    if (!(typeTerm instanceof SymbolTerm)) {
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " did not return a symbol.");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return typeError("Submit type rule " + getSubmitRule() + " for change " + cd.getId() + " of " + getProjectName() + " output invalid result: " + typeName);
    }
}
#method_after
public SubmitTypeRecord getSubmitType() {
    initOptions();
    try {
        init();
    } catch (OrmException e) {
        return typeError("Error looking up change " + cd.getId(), e);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results", // have a consistent view of the submit type.
        null);
    } catch (RuleEvalException e) {
        return typeError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " has no solution.");
    }
    Term typeTerm = results.get(0);
    if (!(typeTerm instanceof SymbolTerm)) {
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " did not return a symbol.");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return typeError("Submit type rule " + getSubmitRule() + " for change " + cd.getId() + " of " + getProjectName() + " output invalid result: " + typeName);
    }
}
#end_block

#method_before
private List<Term> evaluateImpl(String userRuleLocatorName, String userRuleWrapperName, String filterRuleLocatorName, String filterRuleWrapperName, CurrentUser user) throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment(user);
    try {
        Term sr = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        if (opts.fastEvalLabels()) {
            env.once("gerrit", "assume_range_from_label");
        }
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, sr, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), getProjectName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", sr, cd.getId().get(), getProjectName()), err);
        } finally {
            reductionsConsumed = env.getReductions();
        }
        Term resultsTerm = toListTerm(results);
        if (!opts.skipFilters()) {
            resultsTerm = runSubmitFilters(resultsTerm, env, filterRuleLocatorName, filterRuleWrapperName);
        }
        List<Term> r;
        if (resultsTerm instanceof ListTerm) {
            r = new ArrayList<>();
            for (Term t = resultsTerm; t instanceof ListTerm; ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
        } else {
            r = Collections.emptyList();
        }
        submitRule = sr;
        return r;
    } finally {
        env.close();
    }
}
#method_after
private List<Term> evaluateImpl(String userRuleLocatorName, String userRuleWrapperName, String filterRuleLocatorName, String filterRuleWrapperName, CurrentUser user) throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment(user);
    try {
        Term sr = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, sr, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), getProjectName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", sr, cd.getId().get(), getProjectName()), err);
        } finally {
            reductionsConsumed = env.getReductions();
        }
        Term resultsTerm = toListTerm(results);
        if (!opts.skipFilters()) {
            resultsTerm = runSubmitFilters(resultsTerm, env, filterRuleLocatorName, filterRuleWrapperName);
        }
        List<Term> r;
        if (resultsTerm instanceof ListTerm) {
            r = new ArrayList<>();
            for (Term t = resultsTerm; t instanceof ListTerm; ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
        } else {
            r = Collections.emptyList();
        }
        submitRule = sr;
        return r;
    } finally {
        env.close();
    }
}
#end_block

#method_before
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (opts.rule() == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new StringReader(opts.rule()));
        }
    } catch (CompileException err) {
        String msg;
        if (opts.rule() == null && control.getProjectControl().isOwner()) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else if (opts.rule() != null) {
            msg = err.getMessage();
        } else {
            msg = String.format("Cannot load rules.pl for %s", getProjectName());
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.ACCOUNTS, accounts);
    env.set(StoredValues.ACCOUNT_CACHE, accountCache);
    env.set(StoredValues.EMAILS, emails);
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.CHANGE_CONTROL, control);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    return env;
}
#method_after
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    PrologEnvironment env;
    try {
        if (opts.rule() == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new StringReader(opts.rule()));
        }
    } catch (CompileException err) {
        String msg;
        if (opts.rule() == null) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else {
            msg = err.getMessage();
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.ACCOUNTS, accounts);
    env.set(StoredValues.ACCOUNT_CACHE, accountCache);
    env.set(StoredValues.EMAILS, emails);
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    env.set(StoredValues.PROJECT_STATE, projectState);
    return env;
}
#end_block

#method_before
private Term runSubmitFilters(Term results, PrologEnvironment env, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment childEnv = env;
    for (ProjectState parentState : projectState.parents()) {
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            throw new RuleEvalException("Cannot consult rules.pl for " + parentState.getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", filterRuleLocatorName, new VariableTerm());
        try {
            if (opts.fastEvalLabels()) {
                env.once("gerrit", "assume_range_from_label");
            }
            Term[] template = parentEnv.once("gerrit", filterRuleWrapperName, filterRule, results, new VariableTerm());
            results = template[2];
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), parentState.getName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", filterRule, cd.getId().get(), parentState.getName()), err);
        } finally {
            reductionsConsumed += env.getReductions();
        }
        childEnv = parentEnv;
    }
    return results;
}
#method_after
private Term runSubmitFilters(Term results, PrologEnvironment env, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    PrologEnvironment childEnv = env;
    for (ProjectState parentState : projectState.parents()) {
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            throw new RuleEvalException("Cannot consult rules.pl for " + parentState.getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", filterRuleLocatorName, new VariableTerm());
        try {
            Term[] template = parentEnv.once("gerrit", filterRuleWrapperName, filterRule, results, new VariableTerm());
            results = template[2];
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), parentState.getName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", filterRule, cd.getId().get(), parentState.getName()), err);
        } finally {
            reductionsConsumed += env.getReductions();
        }
        childEnv = parentEnv;
    }
    return results;
}
#end_block

#method_before
private String getProjectName() {
    return control.getProjectControl().getProjectState().getName();
}
#method_after
private String getProjectName() {
    return projectState.getName();
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource rsrc, List<ProjectWatchInfo> input) throws AuthException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    if (input == null) {
        return Response.none();
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    watchConfig.deleteProjectWatches(accountId, input.stream().map(w -> ProjectWatchKey.create(new Project.NameKey(w.project), w.filter)).collect(toList()));
    accountCache.evict(accountId);
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource rsrc, List<ProjectWatchInfo> input) throws AuthException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException, PermissionBackendException {
    if (self.get() != rsrc.getUser()) {
        permissionBackend.user(self).check(GlobalPermission.ADMINISTRATE_SERVER);
    }
    if (input == null) {
        return Response.none();
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    watchConfig.deleteProjectWatches(accountId, input.stream().filter(Objects::nonNull).map(w -> ProjectWatchKey.create(new Project.NameKey(w.project), w.filter)).collect(toList()));
    accountCache.evict(accountId);
    return Response.none();
}
#end_block

#method_before
@Override
public void enable() throws RestApiException {
    enable.apply(resource, new EnablePlugin.Input());
}
#method_after
@Override
public void enable() throws RestApiException {
    enable.apply(resource, new Input());
}
#end_block

#method_before
@Override
public void disable() throws RestApiException {
    disable.apply(resource, new DisablePlugin.Input());
}
#method_after
@Override
public void disable() throws RestApiException {
    disable.apply(resource, new Input());
}
#end_block

#method_before
@Override
public void reload() throws RestApiException {
    reload.apply(resource, new ReloadPlugin.Input());
}
#method_after
@Override
public void reload() throws RestApiException {
    reload.apply(resource, new Input());
}
#end_block

#method_before
public BatchMetaDataUpdate openUpdate(MetaDataUpdate update) throws IOException {
    final Repository db = update.getRepository();
    reader = db.newObjectReader();
    inserter = db.newObjectInserter();
    final RevWalk rw = new RevWalk(reader);
    final RevTree tree = revision != null ? rw.parseTree(revision) : null;
    newTree = readTree(tree);
    return new BatchMetaDataUpdate() {

        AnyObjectId src = revision;

        AnyObjectId srcTree = tree;

        @Override
        public void write(CommitBuilder commit) throws IOException {
            write(VersionedMetaData.this, commit);
        }

        private boolean doSave(VersionedMetaData config, CommitBuilder commit) throws IOException {
            DirCache nt = config.newTree;
            ObjectReader r = config.reader;
            ObjectInserter i = config.inserter;
            try {
                config.newTree = newTree;
                config.reader = reader;
                config.inserter = inserter;
                return config.onSave(commit);
            } catch (ConfigInvalidException e) {
                throw new IOException("Cannot update " + getRefName() + " in " + db.getDirectory() + ": " + e.getMessage(), e);
            } finally {
                config.newTree = nt;
                config.reader = r;
                config.inserter = i;
            }
        }

        @Override
        public void write(VersionedMetaData config, CommitBuilder commit) throws IOException {
            if (!doSave(config, commit)) {
                return;
            }
            ObjectId res = newTree.writeTree(inserter);
            if (res.equals(srcTree) && !update.allowEmpty() && (commit.getTreeId() == null)) {
                // If there are no changes to the content, don't create the commit.
                return;
            }
            // the tree for the updated DirCache.
            if (commit.getTreeId() == null) {
                commit.setTreeId(res);
            } else {
                // In this case, the caller populated the tree without using DirCache.
                res = commit.getTreeId();
            }
            if (src != null) {
                commit.addParentId(src);
            }
            if (update.insertChangeId()) {
                ObjectId id = ChangeIdUtil.computeChangeId(res, getRevision(), commit.getAuthor(), commit.getCommitter(), commit.getMessage());
                commit.setMessage(ChangeIdUtil.insertId(commit.getMessage(), id));
            }
            src = inserter.insert(commit);
            srcTree = res;
        }

        @Override
        public RevCommit createRef(String refName) throws IOException {
            if (Objects.equals(src, revision)) {
                return revision;
            }
            return updateRef(ObjectId.zeroId(), src, refName);
        }

        @Override
        public void removeRef(String refName) throws IOException {
            RefUpdate ru = db.updateRef(refName);
            ru.setForceUpdate(true);
            if (revision != null) {
                ru.setExpectedOldObjectId(revision);
            }
            RefUpdate.Result result = ru.delete();
            switch(result) {
                case FORCED:
                    update.fireGitRefUpdatedEvent(ru);
                    return;
                case LOCK_FAILURE:
                    throw new LockFailureException("Cannot delete " + ru.getName() + " in " + db.getDirectory() + ": " + ru.getResult());
                case FAST_FORWARD:
                case IO_FAILURE:
                case NEW:
                case NOT_ATTEMPTED:
                case NO_CHANGE:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                case REJECTED_MISSING_OBJECT:
                case REJECTED_OTHER_REASON:
                default:
                    throw new IOException("Cannot delete " + ru.getName() + " in " + db.getDirectory() + ": " + ru.getResult());
            }
        }

        @Override
        public RevCommit commit() throws IOException {
            return commitAt(revision);
        }

        @Override
        public RevCommit commitAt(ObjectId expected) throws IOException {
            if (Objects.equals(src, expected)) {
                return revision;
            }
            return updateRef(MoreObjects.firstNonNull(expected, ObjectId.zeroId()), src, getRefName());
        }

        @Override
        public void close() {
            newTree = null;
            rw.close();
            if (inserter != null) {
                inserter.close();
                inserter = null;
            }
            if (reader != null) {
                reader.close();
                reader = null;
            }
        }

        private RevCommit updateRef(AnyObjectId oldId, AnyObjectId newId, String refName) throws IOException {
            BatchRefUpdate bru = update.getBatch();
            if (bru != null) {
                bru.addCommand(new ReceiveCommand(oldId.toObjectId(), newId.toObjectId(), refName));
                inserter.flush();
                revision = rw.parseCommit(newId);
                return revision;
            }
            RefUpdate ru = db.updateRef(refName);
            ru.setExpectedOldObjectId(oldId);
            ru.setNewObjectId(src);
            ru.setRefLogIdent(update.getCommitBuilder().getAuthor());
            String message = update.getCommitBuilder().getMessage();
            if (message == null) {
                message = "meta data update";
            }
            try (BufferedReader reader = new BufferedReader(new StringReader(message))) {
                // read the subject line and use it as reflog message
                ru.setRefLogMessage("commit: " + reader.readLine(), true);
            }
            inserter.flush();
            RefUpdate.Result result = ru.update();
            switch(result) {
                case NEW:
                case FAST_FORWARD:
                    revision = rw.parseCommit(ru.getNewObjectId());
                    update.fireGitRefUpdatedEvent(ru);
                    return revision;
                case LOCK_FAILURE:
                    throw new LockFailureException("Cannot update " + ru.getName() + " in " + db.getDirectory() + ": " + ru.getResult());
                case FORCED:
                case IO_FAILURE:
                case NOT_ATTEMPTED:
                case NO_CHANGE:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                case REJECTED_MISSING_OBJECT:
                case REJECTED_OTHER_REASON:
                default:
                    throw new IOException("Cannot update " + ru.getName() + " in " + db.getDirectory() + ": " + ru.getResult());
            }
        }
    };
}
#method_after
public BatchMetaDataUpdate openUpdate(MetaDataUpdate update) throws IOException {
    final Repository db = update.getRepository();
    reader = db.newObjectReader();
    inserter = db.newObjectInserter();
    final RevWalk rw = new RevWalk(reader);
    final RevTree tree = revision != null ? rw.parseTree(revision) : null;
    newTree = readTree(tree);
    return new BatchMetaDataUpdate() {

        AnyObjectId src = revision;

        AnyObjectId srcTree = tree;

        @Override
        public void write(CommitBuilder commit) throws IOException {
            write(VersionedMetaData.this, commit);
        }

        private boolean doSave(VersionedMetaData config, CommitBuilder commit) throws IOException {
            DirCache nt = config.newTree;
            ObjectReader r = config.reader;
            ObjectInserter i = config.inserter;
            try {
                config.newTree = newTree;
                config.reader = reader;
                config.inserter = inserter;
                return config.onSave(commit);
            } catch (ConfigInvalidException e) {
                throw new IOException("Cannot update " + getRefName() + " in " + db.getDirectory() + ": " + e.getMessage(), e);
            } finally {
                config.newTree = nt;
                config.reader = r;
                config.inserter = i;
            }
        }

        @Override
        public void write(VersionedMetaData config, CommitBuilder commit) throws IOException {
            if (!doSave(config, commit)) {
                return;
            }
            ObjectId res = newTree.writeTree(inserter);
            if (res.equals(srcTree) && !update.allowEmpty() && (commit.getTreeId() == null)) {
                // If there are no changes to the content, don't create the commit.
                return;
            }
            // the tree for the updated DirCache.
            if (commit.getTreeId() == null) {
                commit.setTreeId(res);
            } else {
                // In this case, the caller populated the tree without using DirCache.
                res = commit.getTreeId();
            }
            if (src != null) {
                commit.addParentId(src);
            }
            if (update.insertChangeId()) {
                ObjectId id = ChangeIdUtil.computeChangeId(res, getRevision(), commit.getAuthor(), commit.getCommitter(), commit.getMessage());
                commit.setMessage(ChangeIdUtil.insertId(commit.getMessage(), id));
            }
            src = inserter.insert(commit);
            srcTree = res;
        }

        @Override
        public RevCommit createRef(String refName) throws IOException {
            if (Objects.equals(src, revision)) {
                return revision;
            }
            return updateRef(ObjectId.zeroId(), src, refName);
        }

        @Override
        public RevCommit commit() throws IOException {
            return commitAt(revision);
        }

        @Override
        public RevCommit commitAt(ObjectId expected) throws IOException {
            if (Objects.equals(src, expected)) {
                return revision;
            }
            return updateRef(MoreObjects.firstNonNull(expected, ObjectId.zeroId()), src, getRefName());
        }

        @Override
        public void close() {
            newTree = null;
            rw.close();
            if (inserter != null) {
                inserter.close();
                inserter = null;
            }
            if (reader != null) {
                reader.close();
                reader = null;
            }
        }

        private RevCommit updateRef(AnyObjectId oldId, AnyObjectId newId, String refName) throws IOException {
            BatchRefUpdate bru = update.getBatch();
            if (bru != null) {
                bru.addCommand(new ReceiveCommand(oldId.toObjectId(), newId.toObjectId(), refName));
                inserter.flush();
                revision = rw.parseCommit(newId);
                return revision;
            }
            RefUpdate ru = db.updateRef(refName);
            ru.setExpectedOldObjectId(oldId);
            ru.setNewObjectId(newId);
            ru.setRefLogIdent(update.getCommitBuilder().getAuthor());
            String message = update.getCommitBuilder().getMessage();
            if (message == null) {
                message = "meta data update";
            }
            try (BufferedReader reader = new BufferedReader(new StringReader(message))) {
                // read the subject line and use it as reflog message
                ru.setRefLogMessage("commit: " + reader.readLine(), true);
            }
            inserter.flush();
            RefUpdate.Result result = ru.update();
            switch(result) {
                case NEW:
                case FAST_FORWARD:
                    revision = rw.parseCommit(ru.getNewObjectId());
                    update.fireGitRefUpdatedEvent(ru);
                    return revision;
                case LOCK_FAILURE:
                    throw new LockFailureException("Cannot update " + ru.getName() + " in " + db.getDirectory() + ": " + ru.getResult());
                case FORCED:
                case IO_FAILURE:
                case NOT_ATTEMPTED:
                case NO_CHANGE:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                case REJECTED_MISSING_OBJECT:
                case REJECTED_OTHER_REASON:
                default:
                    throw new IOException("Cannot update " + ru.getName() + " in " + db.getDirectory() + ": " + ru.getResult());
            }
        }
    };
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, BadRequestException, MethodNotAllowedException, OrmException, IOException {
    if (!notesMigration.readChanges()) {
        throw new MethodNotAllowedException("Cannot add hashtags; NoteDb is disabled");
    }
    if (input == null || (input.add == null && input.remove == null)) {
        updatedHashtags = ImmutableSortedSet.of();
        return false;
    }
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    ChangeNotes notes = update.getNotes().load();
    Set<String> existingHashtags = notes.getHashtags();
    Set<String> updated = new HashSet<>();
    toAdd = new HashSet<>(extractTags(input.add));
    toRemove = new HashSet<>(extractTags(input.remove));
    try {
        for (HashtagValidationListener validator : validationListeners) {
            validator.validateHashtags(update.getChange(), toAdd, toRemove);
        }
    } catch (ValidationException e) {
        throw new BadRequestException(e.getMessage());
    }
    updated.addAll(existingHashtags);
    toAdd.removeAll(existingHashtags);
    toRemove.retainAll(existingHashtags);
    if (updated()) {
        updated.addAll(toAdd);
        updated.removeAll(toRemove);
        update.setHashtags(updated);
        addMessage(ctx, update);
    }
    updatedHashtags = ImmutableSortedSet.copyOf(updated);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, BadRequestException, MethodNotAllowedException, OrmException, IOException {
    if (!notesMigration.readChanges()) {
        throw new MethodNotAllowedException("Cannot add hashtags; NoteDb is disabled");
    }
    if (input == null || (input.add == null && input.remove == null)) {
        updatedHashtags = ImmutableSortedSet.of();
        return false;
    }
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    ChangeNotes notes = update.getNotes().load();
    try {
        Set<String> existingHashtags = notes.getHashtags();
        Set<String> updated = new HashSet<>();
        toAdd = new HashSet<>(extractTags(input.add));
        toRemove = new HashSet<>(extractTags(input.remove));
        for (HashtagValidationListener validator : validationListeners) {
            validator.validateHashtags(update.getChange(), toAdd, toRemove);
        }
        updated.addAll(existingHashtags);
        toAdd.removeAll(existingHashtags);
        toRemove.retainAll(existingHashtags);
        if (updated()) {
            updated.addAll(toAdd);
            updated.removeAll(toRemove);
            update.setHashtags(updated);
            addMessage(ctx, update);
        }
        updatedHashtags = ImmutableSortedSet.copyOf(updated);
        return true;
    } catch (ValidationException | InvalidHashtagException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountIndexRewriter.class);
    bind(AccountIndexCollection.class);
    listener().to(AccountIndexCollection.class);
    factory(AccountIndexerImpl.Factory.class);
    bind(ChangeIndexRewriter.class);
    bind(ChangeIndexCollection.class);
    listener().to(ChangeIndexCollection.class);
    factory(ChangeIndexer.Factory.class);
    bind(GroupIndexRewriter.class);
    bind(GroupIndexCollection.class);
    listener().to(GroupIndexCollection.class);
    factory(GroupIndexerImpl.Factory.class);
    DynamicSet.setOf(binder(), OnlineUpgradeListener.class);
}
#method_after
@Override
protected void configure() {
    bind(AccountIndexRewriter.class);
    bind(AccountIndexCollection.class);
    listener().to(AccountIndexCollection.class);
    factory(AccountIndexerImpl.Factory.class);
    bind(ChangeIndexRewriter.class);
    bind(ChangeIndexCollection.class);
    listener().to(ChangeIndexCollection.class);
    factory(ChangeIndexer.Factory.class);
    bind(GroupIndexRewriter.class);
    bind(GroupIndexCollection.class);
    listener().to(GroupIndexCollection.class);
    factory(GroupIndexerImpl.Factory.class);
    bind(ProjectIndexRewriter.class);
    bind(ProjectIndexCollection.class);
    listener().to(ProjectIndexCollection.class);
    factory(ProjectIndexerImpl.Factory.class);
    DynamicSet.setOf(binder(), OnlineUpgradeListener.class);
}
#end_block

#method_before
@Provides
Collection<IndexDefinition<?, ?, ?>> getIndexDefinitions(AccountIndexDefinition accounts, ChangeIndexDefinition changes, GroupIndexDefinition groups) {
    Collection<IndexDefinition<?, ?, ?>> result = ImmutableList.<IndexDefinition<?, ?, ?>>of(accounts, groups, changes);
    Set<String> expected = FluentIterable.from(ALL_SCHEMA_DEFS).transform(SchemaDefinitions::getName).toSet();
    Set<String> actual = FluentIterable.from(result).transform(IndexDefinition::getName).toSet();
    if (!expected.equals(actual)) {
        throw new ProvisionException("need index definitions for all schemas: " + expected + " != " + actual);
    }
    return result;
}
#method_after
@Provides
Collection<IndexDefinition<?, ?, ?>> getIndexDefinitions(AccountIndexDefinition accounts, ChangeIndexDefinition changes, GroupIndexDefinition groups, ProjectIndexDefinition projects) {
    Collection<IndexDefinition<?, ?, ?>> result = ImmutableList.<IndexDefinition<?, ?, ?>>of(accounts, groups, changes, projects);
    Set<String> expected = FluentIterable.from(ALL_SCHEMA_DEFS).transform(SchemaDefinitions::getName).toSet();
    Set<String> actual = FluentIterable.from(result).transform(IndexDefinition::getName).toSet();
    if (!expected.equals(actual)) {
        throw new ProvisionException("need index definitions for all schemas: " + expected + " != " + actual);
    }
    return result;
}
#end_block

#method_before
@Test
public void byStatus() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    ChangeInserter ins2 = newChangeWithStatus(repo, Change.Status.MERGED);
    Change change2 = insert(repo, ins2);
    assertQuery("status:new", change1);
    assertQuery("status:NEW", change1);
    assertQuery("is:new", change1);
    assertQuery("status:merged", change2);
    assertQuery("is:merged", change2);
}
#method_after
@Test
public void byStatus() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    ChangeInserter ins2 = newChangeWithStatus(repo, Change.Status.MERGED);
    Change change2 = insert(repo, ins2);
    assertQuery("status:new", change1);
    assertQuery("status:NEW", change1);
    assertQuery("is:new", change1);
    assertQuery("status:merged", change2);
    assertQuery("is:merged", change2);
    assertQuery("status:draft");
    assertQuery("is:draft");
}
#end_block

#method_before
@Test
public void byStatusOpen() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    ChangeInserter ins2 = newChangeWithStatus(repo, Change.Status.DRAFT);
    Change change2 = insert(repo, ins2);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change[] expected = new Change[] { change2, change1 };
    assertQuery("status:open", expected);
    assertQuery("status:OPEN", expected);
    assertQuery("status:o", expected);
    assertQuery("status:op", expected);
    assertQuery("status:ope", expected);
    assertQuery("status:pending", expected);
    assertQuery("status:PENDING", expected);
    assertQuery("status:p", expected);
    assertQuery("status:pe", expected);
    assertQuery("status:pen", expected);
    assertQuery("is:open", expected);
}
#method_after
@Test
public void byStatusOpen() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change[] expected = new Change[] { change1 };
    assertQuery("status:open", expected);
    assertQuery("status:OPEN", expected);
    assertQuery("status:o", expected);
    assertQuery("status:op", expected);
    assertQuery("status:ope", expected);
    assertQuery("status:pending", expected);
    assertQuery("status:PENDING", expected);
    assertQuery("status:p", expected);
    assertQuery("status:pe", expected);
    assertQuery("status:pen", expected);
    assertQuery("is:open", expected);
}
#end_block

#method_before
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    assertQuery("status:n", change1);
    assertQuery("status:ne", change1);
    assertQuery("status:new", change1);
    assertQuery("status:N", change1);
    assertQuery("status:nE", change1);
    assertQuery("status:neW", change1);
    assertThatQueryException("status:nx").hasMessageThat().isEqualTo("invalid change status: nx");
    assertThatQueryException("status:newx").hasMessageThat().isEqualTo("invalid change status: newx");
}
#method_after
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    assertQuery("status:n", change1);
    assertQuery("status:ne", change1);
    assertQuery("status:new", change1);
    assertQuery("status:N", change1);
    assertQuery("status:nE", change1);
    assertQuery("status:neW", change1);
    assertQuery("status:nx");
    assertQuery("status:newx");
}
#end_block

#method_before
@Test
public void byAge() throws Exception {
    long thirtyHoursInMs = MILLISECONDS.convert(30, HOURS);
    resetTimeWithClockStep(thirtyHoursInMs, MILLISECONDS);
    TestRepository<Repo> repo = createProject("repo");
    long startMs = TestTimeUtil.START.getMillis();
    Change change1 = insert(repo, newChange(repo), null, new Timestamp(startMs));
    Change change2 = insert(repo, newChange(repo), null, new Timestamp(startMs + thirtyHoursInMs));
    // Stop time so age queries use the same endpoint.
    TestTimeUtil.setClockStep(0, MILLISECONDS);
    TestTimeUtil.setClock(new Timestamp(startMs + 2 * thirtyHoursInMs));
    long nowMs = TimeUtil.nowMs();
    assertThat(lastUpdatedMs(change2) - lastUpdatedMs(change1)).isEqualTo(thirtyHoursInMs);
    assertThat(nowMs - lastUpdatedMs(change2)).isEqualTo(thirtyHoursInMs);
    assertThat(TimeUtil.nowMs()).isEqualTo(nowMs);
    assertQuery("-age:1d");
    assertQuery("-age:" + (30 * 60 - 1) + "m");
    assertQuery("-age:2d", change2);
    assertQuery("-age:3d", change2, change1);
    assertQuery("age:3d");
    assertQuery("age:2d", change1);
    assertQuery("age:1d", change2, change1);
}
#method_after
@Test
public void byAge() throws Exception {
    long thirtyHoursInMs = MILLISECONDS.convert(30, HOURS);
    resetTimeWithClockStep(thirtyHoursInMs, MILLISECONDS);
    TestRepository<Repo> repo = createProject("repo");
    long startMs = TestTimeUtil.START.toEpochMilli();
    Change change1 = insert(repo, newChange(repo), null, new Timestamp(startMs));
    Change change2 = insert(repo, newChange(repo), null, new Timestamp(startMs + thirtyHoursInMs));
    // Stop time so age queries use the same endpoint.
    TestTimeUtil.setClockStep(0, MILLISECONDS);
    TestTimeUtil.setClock(new Timestamp(startMs + 2 * thirtyHoursInMs));
    long nowMs = TimeUtil.nowMs();
    assertThat(lastUpdatedMs(change2) - lastUpdatedMs(change1)).isEqualTo(thirtyHoursInMs);
    assertThat(nowMs - lastUpdatedMs(change2)).isEqualTo(thirtyHoursInMs);
    assertThat(TimeUtil.nowMs()).isEqualTo(nowMs);
    assertQuery("-age:1d");
    assertQuery("-age:" + (30 * 60 - 1) + "m");
    assertQuery("-age:2d", change2);
    assertQuery("-age:3d", change2, change1);
    assertQuery("age:3d");
    assertQuery("age:2d", change1);
    assertQuery("age:1d", change2, change1);
}
#end_block

#method_before
@Test
public void byBefore() throws Exception {
    long thirtyHoursInMs = MILLISECONDS.convert(30, HOURS);
    resetTimeWithClockStep(thirtyHoursInMs, MILLISECONDS);
    TestRepository<Repo> repo = createProject("repo");
    long startMs = TestTimeUtil.START.getMillis();
    Change change1 = insert(repo, newChange(repo), null, new Timestamp(startMs));
    Change change2 = insert(repo, newChange(repo), null, new Timestamp(startMs + thirtyHoursInMs));
    TestTimeUtil.setClockStep(0, MILLISECONDS);
    assertQuery("before:2009-09-29");
    assertQuery("before:2009-09-30");
    assertQuery("before:\"2009-09-30 16:59:00 -0400\"");
    assertQuery("before:\"2009-09-30 20:59:00 -0000\"");
    assertQuery("before:\"2009-09-30 20:59:00\"");
    assertQuery("before:\"2009-09-30 17:02:00 -0400\"", change1);
    assertQuery("before:\"2009-10-01 21:02:00 -0000\"", change1);
    assertQuery("before:\"2009-10-01 21:02:00\"", change1);
    assertQuery("before:2009-10-01", change1);
    assertQuery("before:2009-10-03", change2, change1);
}
#method_after
@Test
public void byBefore() throws Exception {
    long thirtyHoursInMs = MILLISECONDS.convert(30, HOURS);
    resetTimeWithClockStep(thirtyHoursInMs, MILLISECONDS);
    TestRepository<Repo> repo = createProject("repo");
    long startMs = TestTimeUtil.START.toEpochMilli();
    Change change1 = insert(repo, newChange(repo), null, new Timestamp(startMs));
    Change change2 = insert(repo, newChange(repo), null, new Timestamp(startMs + thirtyHoursInMs));
    TestTimeUtil.setClockStep(0, MILLISECONDS);
    assertQuery("before:2009-09-29");
    assertQuery("before:2009-09-30");
    assertQuery("before:\"2009-09-30 16:59:00 -0400\"");
    assertQuery("before:\"2009-09-30 20:59:00 -0000\"");
    assertQuery("before:\"2009-09-30 20:59:00\"");
    assertQuery("before:\"2009-09-30 17:02:00 -0400\"", change1);
    assertQuery("before:\"2009-10-01 21:02:00 -0000\"", change1);
    assertQuery("before:\"2009-10-01 21:02:00\"", change1);
    assertQuery("before:2009-10-01", change1);
    assertQuery("before:2009-10-03", change2, change1);
}
#end_block

#method_before
@Test
public void byAfter() throws Exception {
    long thirtyHoursInMs = MILLISECONDS.convert(30, HOURS);
    resetTimeWithClockStep(thirtyHoursInMs, MILLISECONDS);
    TestRepository<Repo> repo = createProject("repo");
    long startMs = TestTimeUtil.START.getMillis();
    Change change1 = insert(repo, newChange(repo), null, new Timestamp(startMs));
    Change change2 = insert(repo, newChange(repo), null, new Timestamp(startMs + thirtyHoursInMs));
    TestTimeUtil.setClockStep(0, MILLISECONDS);
    assertQuery("after:2009-10-03");
    assertQuery("after:\"2009-10-01 20:59:59 -0400\"", change2);
    assertQuery("after:\"2009-10-01 20:59:59 -0000\"", change2);
    assertQuery("after:2009-10-01", change2);
    assertQuery("after:2009-09-30", change2, change1);
}
#method_after
@Test
public void byAfter() throws Exception {
    long thirtyHoursInMs = MILLISECONDS.convert(30, HOURS);
    resetTimeWithClockStep(thirtyHoursInMs, MILLISECONDS);
    TestRepository<Repo> repo = createProject("repo");
    long startMs = TestTimeUtil.START.toEpochMilli();
    Change change1 = insert(repo, newChange(repo), null, new Timestamp(startMs));
    Change change2 = insert(repo, newChange(repo), null, new Timestamp(startMs + thirtyHoursInMs));
    TestTimeUtil.setClockStep(0, MILLISECONDS);
    assertQuery("after:2009-10-03");
    assertQuery("after:\"2009-10-01 20:59:59 -0400\"", change2);
    assertQuery("after:\"2009-10-01 20:59:59 -0000\"", change2);
    assertQuery("after:2009-10-01", change2);
    assertQuery("after:2009-09-30", change2, change1);
}
#end_block

#method_before
protected Change newPatchSet(TestRepository<Repo> repo, Change c) throws Exception {
    // Add a new file so the patch set is not a trivial rebase, to avoid default
    // Code-Review label copying.
    int n = c.currentPatchSetId().get() + 1;
    RevCommit commit = repo.parseBody(repo.commit().message("message").add("file" + n, "contents " + n).create());
    ChangeControl ctl = changeControlFactory.controlFor(db, c, user);
    PatchSetInserter inserter = patchSetFactory.create(ctl.getNotes(), new PatchSet.Id(c.getId(), n), commit).setNotify(NotifyHandling.NONE).setFireRevisionCreated(false).setValidate(false);
    try (BatchUpdate bu = updateFactory.create(db, c.getProject(), user, TimeUtil.nowTs());
        ObjectInserter oi = repo.getRepository().newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo.getRepository(), rw, oi);
        bu.addOp(c.getId(), inserter);
        bu.execute();
    }
    return inserter.getChange();
}
#method_after
protected Change newPatchSet(TestRepository<Repo> repo, Change c) throws Exception {
    // Add a new file so the patch set is not a trivial rebase, to avoid default
    // Code-Review label copying.
    int n = c.currentPatchSetId().get() + 1;
    RevCommit commit = repo.parseBody(repo.commit().message("message").add("file" + n, "contents " + n).create());
    PatchSetInserter inserter = patchSetFactory.create(changeNotesFactory.createChecked(db, c), new PatchSet.Id(c.getId(), n), commit).setNotify(NotifyHandling.NONE).setFireRevisionCreated(false).setValidate(false);
    try (BatchUpdate bu = updateFactory.create(db, c.getProject(), user, TimeUtil.nowTs());
        ObjectInserter oi = repo.getRepository().newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo.getRepository(), rw, oi);
        bu.addOp(c.getId(), inserter);
        bu.execute();
    }
    return inserter.getChange();
}
#end_block

#method_before
@Override
public void postRun() throws Exception {
    Config cfg = allProjectsConfig.load().getConfig();
    if (installVerified) {
        cfg.setString(KEY_LABEL, LABEL_VERIFIED, KEY_FUNCTION, "MaxWithBlock");
        cfg.setStringList(KEY_LABEL, LABEL_VERIFIED, KEY_VALUE, Arrays.asList(new String[] { "-1 Fails", " 0 No score", "+1 Verified" }));
        cfg.setBoolean(KEY_LABEL, LABEL_VERIFIED, KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE, true);
        allProjectsConfig.save("Configure 'Verified' label");
    }
}
#method_after
@Override
public void postRun() throws Exception {
    Config cfg = allProjectsConfig.load().getConfig();
    if (installVerified) {
        cfg.setString(KEY_LABEL, LABEL_VERIFIED, KEY_FUNCTION, MAX_WITH_BLOCK.getFunctionName());
        cfg.setStringList(KEY_LABEL, LABEL_VERIFIED, KEY_VALUE, Arrays.asList(new String[] { "-1 Fails", " 0 No score", "+1 Verified" }));
        cfg.setBoolean(KEY_LABEL, LABEL_VERIFIED, KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE, true);
        allProjectsConfig.save("Configure 'Verified' label");
    }
}
#end_block

#method_before
@Override
public void run() {
    ui.header("SQL Database");
    Set<String> allowedValues = Sets.newTreeSet();
    Injector i = Guice.createInjector(PRODUCTION, new DatabaseConfigModule(site));
    List<Binding<DatabaseConfigInitializer>> dbConfigBindings = i.findBindingsByType(new TypeLiteral<DatabaseConfigInitializer>() {
    });
    for (Binding<DatabaseConfigInitializer> binding : dbConfigBindings) {
        Annotation annotation = binding.getKey().getAnnotation();
        if (annotation instanceof Named) {
            allowedValues.add(((Named) annotation).value());
        }
    }
    if (!Strings.isNullOrEmpty(database.get("url")) && Strings.isNullOrEmpty(database.get("type"))) {
        database.set("type", "jdbc");
    }
    String dbType = database.select("Database server type", "type", "h2", allowedValues);
    DatabaseConfigInitializer dci = i.getInstance(Key.get(DatabaseConfigInitializer.class, Names.named(dbType.toLowerCase())));
    if (dci instanceof MySqlInitializer) {
        libraries.mysqlDriver.downloadRequired();
    } else if (dci instanceof MariaDbInitializer) {
        libraries.mariadbDriver.downloadRequired();
    } else if (dci instanceof OracleInitializer) {
        libraries.oracleDriver.downloadRequired();
    } else if (dci instanceof DB2Initializer) {
        libraries.db2Driver.downloadRequired();
    } else if (dci instanceof HANAInitializer) {
        libraries.hanaDriver.downloadRequired();
    }
    dci.initConfig(database);
    // Initialize UUID for NoteDb on first init.
    String id = idSection.get(GerritServerIdProvider.KEY);
    if (Strings.isNullOrEmpty(id)) {
        idSection.set(GerritServerIdProvider.KEY, GerritServerIdProvider.generate());
    }
}
#method_after
@Override
public void run() {
    initSqlDb();
    if (flags.isNew) {
        initNoteDb();
    }
}
#end_block

#method_before
public synchronized void insert(String commitMessage, Collection<ExternalId> extIds) throws OrmException, IOException, ConfigInvalidException {
    File path = getPath();
    if (path != null) {
        try (Repository repo = new FileRepository(path);
            RevWalk rw = new RevWalk(repo);
            ObjectInserter ins = repo.newObjectInserter()) {
            ObjectId rev = ExternalIdReader.readRevision(repo);
            NoteMap noteMap = ExternalIdReader.readNoteMap(rw, rev);
            for (ExternalId extId : extIds) {
                ExternalIdsUpdate.insert(rw, ins, noteMap, extId);
            }
            PersonIdent serverIdent = new GerritPersonIdentProvider(flags.cfg).get();
            ExternalIdsUpdate.commit(repo, rw, ins, rev, noteMap, commitMessage, serverIdent, serverIdent);
        }
    }
}
#method_after
public synchronized void insert(String commitMessage, Collection<ExternalId> extIds) throws OrmException, IOException, ConfigInvalidException {
    File path = getPath();
    if (path != null) {
        try (Repository repo = new FileRepository(path);
            RevWalk rw = new RevWalk(repo);
            ObjectInserter ins = repo.newObjectInserter()) {
            ObjectId rev = ExternalIdReader.readRevision(repo);
            NoteMap noteMap = ExternalIdReader.readNoteMap(rw, rev);
            for (ExternalId extId : extIds) {
                ExternalIdsUpdate.insert(rw, ins, noteMap, extId);
            }
            PersonIdent serverIdent = new GerritPersonIdentProvider(flags.cfg).get();
            ExternalIdsUpdate.commit(new Project.NameKey(allUsers), repo, rw, ins, rev, noteMap, commitMessage, serverIdent, serverIdent, null, GitReferenceUpdated.DISABLED);
        }
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    Map<String, Integer> versions = new HashMap<>();
    if (changesVersion != null) {
        versions.put(ChangeSchemaDefinitions.INSTANCE.getName(), changesVersion);
    }
    List<Module> modules = new ArrayList<>();
    Module indexModule;
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            indexModule = LuceneIndexModule.singleVersionWithExplicitVersions(versions, threads);
            break;
        case ELASTICSEARCH:
            indexModule = ElasticIndexModule.singleVersionWithExplicitVersions(versions, threads);
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(indexModule);
    modules.add(dbInjector.getInstance(BatchProgramModule.class));
    modules.add(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ChangeResource.Factory.class);
        }
    });
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    Map<String, Integer> versions = new HashMap<>();
    if (changesVersion != null) {
        versions.put(ChangeSchemaDefinitions.INSTANCE.getName(), changesVersion);
    }
    List<Module> modules = new ArrayList<>();
    Module indexModule;
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            indexModule = LuceneIndexModule.singleVersionWithExplicitVersions(versions, threads);
            break;
        case ELASTICSEARCH:
            indexModule = ElasticIndexModule.singleVersionWithExplicitVersions(versions, threads);
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(indexModule);
    modules.add(dbInjector.getInstance(BatchProgramModule.class));
    modules.add(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ChangeResource.Factory.class);
            bind(GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED);
        }
    });
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
@Inject(optional = true)
void set(AccountIndexCollection indexCollection) {
    this.indexCollection = indexCollection;
}
#method_after
@Inject
void set(AccountIndexCollection accountIndexCollection) {
    this.accountIndexCollection = accountIndexCollection;
}
#end_block

#method_before
@Inject(optional = true)
void set(AccountIndexCollection indexCollection) {
    this.indexCollection = indexCollection;
}
#method_after
@Inject
void set(GroupIndexCollection groupIndexCollection) {
    this.groupIndexCollection = groupIndexCollection;
}
#end_block

#method_before
@Override
public void postRun() throws Exception {
    AuthType authType = flags.cfg.getEnum(AuthType.values(), "auth", null, "type", null);
    if (authType != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        return;
    }
    try (ReviewDb db = dbFactory.open()) {
        if (!accounts.hasAnyAccount()) {
            ui.header("Gerrit Administrator");
            if (ui.yesno(true, "Create administrator user")) {
                Account.Id id = new Account.Id(sequencesOnInit.nextAccountId(db));
                String username = ui.readString("admin", "username");
                String name = ui.readString("Administrator", "name");
                String httpPassword = ui.readString("secret", "HTTP password");
                AccountSshKey sshKey = readSshKey(id);
                String email = readEmail(sshKey);
                List<ExternalId> extIds = new ArrayList<>(2);
                extIds.add(ExternalId.createUsername(username, id, httpPassword));
                if (email != null) {
                    extIds.add(ExternalId.createEmail(id, email));
                }
                externalIds.insert("Add external IDs for initial admin user", extIds);
                Account a = new Account(id, TimeUtil.nowTs());
                a.setFullName(name);
                a.setPreferredEmail(email);
                accounts.insert(a);
                AccountGroup adminGroup = groupsOnInit.getExistingGroup(db, new AccountGroup.NameKey("Administrators"));
                groupsOnInit.addGroupMember(db, adminGroup.getGroupUUID(), id);
                if (sshKey != null) {
                    VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
                    authorizedKeys.addKey(sshKey.getSshPublicKey());
                    authorizedKeys.save("Add SSH key for initial admin user\n");
                }
                AccountState as = new AccountState(new AllUsersName(allUsers.get()), a, Collections.singleton(adminGroup.getGroupUUID()), extIds, new HashMap<>());
                for (AccountIndex accountIndex : indexCollection.getWriteIndexes()) {
                    accountIndex.replace(as);
                }
            }
        }
    }
}
#method_after
@Override
public void postRun() throws Exception {
    AuthType authType = flags.cfg.getEnum(AuthType.values(), "auth", null, "type", null);
    if (authType != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        return;
    }
    try (ReviewDb db = dbFactory.open()) {
        if (!accounts.hasAnyAccount()) {
            ui.header("Gerrit Administrator");
            if (ui.yesno(true, "Create administrator user")) {
                Account.Id id = new Account.Id(sequencesOnInit.nextAccountId(db));
                String username = ui.readString("admin", "username");
                String name = ui.readString("Administrator", "name");
                String httpPassword = ui.readString("secret", "HTTP password");
                AccountSshKey sshKey = readSshKey(id);
                String email = readEmail(sshKey);
                List<ExternalId> extIds = new ArrayList<>(2);
                extIds.add(ExternalId.createUsername(username, id, httpPassword));
                if (email != null) {
                    extIds.add(ExternalId.createEmail(id, email));
                }
                externalIds.insert("Add external IDs for initial admin user", extIds);
                Account a = new Account(id, TimeUtil.nowTs());
                a.setFullName(name);
                a.setPreferredEmail(email);
                accounts.insert(a);
                AccountGroup adminGroup = groupsOnInit.getExistingGroup(db, new AccountGroup.NameKey("Administrators"));
                groupsOnInit.addGroupMember(db, adminGroup.getGroupUUID(), id);
                if (sshKey != null) {
                    VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
                    authorizedKeys.addKey(sshKey.getSshPublicKey());
                    authorizedKeys.save("Add SSH key for initial admin user\n");
                }
                AccountState as = new AccountState(new AllUsersName(allUsers.get()), a, extIds, new HashMap<>());
                for (AccountIndex accountIndex : accountIndexCollection.getWriteIndexes()) {
                    accountIndex.replace(as);
                }
                InternalGroup adminInternalGroup = InternalGroup.create(adminGroup, ImmutableSet.of(id), ImmutableSet.of());
                for (GroupIndex groupIndex : groupIndexCollection.getWriteIndexes()) {
                    groupIndex.replace(adminInternalGroup);
                }
            }
        }
    }
}
#end_block

#method_before
public int nextAccountId(ReviewDb db) throws OrmException {
    @SuppressWarnings("deprecation")
    RepoSequence.Seed accountSeed = () -> db.nextAccountId();
    RepoSequence accountSeq = new RepoSequence(repoManager, new Project.NameKey(allUsersName.get()), Sequences.NAME_ACCOUNTS, accountSeed, 1);
    return accountSeq.next();
}
#method_after
public int nextAccountId(ReviewDb db) throws OrmException {
    @SuppressWarnings("deprecation")
    RepoSequence.Seed accountSeed = () -> db.nextAccountId();
    RepoSequence accountSeq = new RepoSequence(repoManager, GitReferenceUpdated.DISABLED, new Project.NameKey(allUsersName.get()), Sequences.NAME_ACCOUNTS, accountSeed, 1);
    return accountSeq.next();
}
#end_block

#method_before
private void guessDriver(Section database) {
    String url = Strings.emptyToNull(database.get("url"));
    if (url != null && Strings.isNullOrEmpty(database.get("driver"))) {
        if (url.startsWith("jdbc:derby:")) {
            database.set("driver", "org.apache.derby.jdbc.EmbeddedDriver");
        } else if (url.startsWith("jdbc:h2:")) {
            database.set("driver", "org.h2.Driver");
        } else if (url.startsWith("jdbc:mariadb:")) {
            database.set("driver", "org.mariadb.jdbc.Driver");
        } else if (url.startsWith("jdbc:mysql:")) {
            database.set("driver", "com.mysql.cj.jdbc.Driver");
        } else if (url.startsWith("jdbc:postgresql:")) {
            database.set("driver", "org.postgresql.Driver");
        }
    }
}
#method_after
private void guessDriver(Section database) {
    String url = Strings.emptyToNull(database.get("url"));
    if (url != null && Strings.isNullOrEmpty(database.get("driver"))) {
        if (url.startsWith("jdbc:derby:")) {
            database.set("driver", "org.apache.derby.jdbc.EmbeddedDriver");
        } else if (url.startsWith("jdbc:h2:")) {
            database.set("driver", "org.h2.Driver");
        } else if (url.startsWith("jdbc:mariadb:")) {
            database.set("driver", "org.mariadb.jdbc.Driver");
        } else if (url.startsWith("jdbc:mysql:")) {
            database.set("driver", "com.mysql.jdbc.Driver");
        } else if (url.startsWith("jdbc:postgresql:")) {
            database.set("driver", "org.postgresql.Driver");
        }
    }
}
#end_block

#method_before
@Override
public void start() {
    // compress log once and then schedule compression every day at 11:00pm
    queue.getDefaultQueue().execute(compressor);
    ZoneId zone = ZoneId.systemDefault();
    LocalDate now = LocalDate.now(zone);
    long milliSecondsUntil11pm = now.atStartOfDay(zone).plusHours(23).toInstant().toEpochMilli();
    @SuppressWarnings("unused")
    Future<?> possiblyIgnoredError = queue.getDefaultQueue().scheduleAtFixedRate(compressor, milliSecondsUntil11pm, HOURS.toMillis(24), MILLISECONDS);
}
#method_after
@Override
public void start() {
    // compress log once and then schedule compression every day at 11:00pm
    queue.getDefaultQueue().execute(compressor);
    ZoneId zone = ZoneId.systemDefault();
    LocalDateTime now = LocalDateTime.now(zone);
    long milliSecondsUntil11pm = now.until(now.withHour(23).withMinute(0).withSecond(0).withNano(0), ChronoUnit.MILLIS);
    @SuppressWarnings("unused")
    Future<?> possiblyIgnoredError = queue.getDefaultQueue().scheduleAtFixedRate(compressor, milliSecondsUntil11pm, HOURS.toMillis(24), MILLISECONDS);
}
#end_block

#method_before
@Override
public void run() {
    if (!Files.isDirectory(logs_dir)) {
        return;
    }
    try (DirectoryStream<Path> list = Files.newDirectoryStream(logs_dir)) {
        for (Path entry : list) {
            if (!isLive(entry) && !isCompressed(entry) && isLogFile(entry)) {
                compress(entry);
            }
        }
    } catch (IOException e) {
        log.error("Error listing logs to compress in " + logs_dir, e);
    }
}
#method_after
@Override
public void run() {
    try {
        if (!Files.isDirectory(logs_dir)) {
            return;
        }
        try (DirectoryStream<Path> list = Files.newDirectoryStream(logs_dir)) {
            for (Path entry : list) {
                if (!isLive(entry) && !isCompressed(entry) && isLogFile(entry)) {
                    compress(entry);
                }
            }
        } catch (IOException e) {
            log.error("Error listing logs to compress in " + logs_dir, e);
        }
    } catch (Exception e) {
        log.error("Failed to compress log files: " + e.getMessage(), e);
    }
}
#end_block

#method_before
private void doGetByHttp() throws IOException {
    System.err.print("Downloading " + jarUrl + " ...");
    System.err.flush();
    try (InputStream in = openHttpStream(jarUrl);
        OutputStream out = Files.newOutputStream(dst)) {
        ByteStreams.copy(in, out);
        System.err.println(" OK");
        System.err.flush();
    } catch (IOException err) {
        deleteDst();
        System.err.println(" !! FAIL !!");
        System.err.flush();
        throw err;
    }
}
#method_after
private void doGetByHttp() throws IOException {
    System.err.print("Downloading " + jarUrl + " ...");
    System.err.flush();
    try (InputStream in = openHttpStream(jarUrl);
        OutputStream out = Files.newOutputStream(dst)) {
        ByteStreams.copy(in, out);
        System.err.println(" OK");
        System.err.flush();
    } catch (IOException err) {
        deleteDst();
        System.err.println(" !! FAIL !!");
        System.err.println(err);
        System.err.flush();
        throw err;
    }
}
#end_block

#method_before
private void verifyFileChecksum() {
    if (sha1 == null) {
        System.err.println();
        System.err.flush();
        return;
    }
    Hasher h = Hashing.murmur3_128().newHasher();
    try (InputStream in = Files.newInputStream(dst);
        OutputStream out = Funnels.asOutputStream(h)) {
        ByteStreams.copy(in, out);
    } catch (IOException e) {
        deleteDst();
        throw new Die("cannot checksum " + dst, e);
    }
    if (sha1.equals(h.hash().toString())) {
        System.err.println("Checksum " + dst.getFileName() + " OK");
        System.err.flush();
    } else if (ui.isBatch()) {
        deleteDst();
        throw new Die(dst + " SHA-1 checksum does not match");
    } else if (!ui.yesno(null, // 
    "error: SHA-1 checksum does not match\nUse %s anyway", dst.getFileName())) {
        deleteDst();
        throw new Die("aborted by user");
    }
}
#method_after
// Use Hashing.sha1 for compatibility.
@SuppressWarnings("deprecation")
private void verifyFileChecksum() {
    if (sha1 == null) {
        System.err.println();
        System.err.flush();
        return;
    }
    Hasher h = Hashing.sha1().newHasher();
    try (InputStream in = Files.newInputStream(dst);
        OutputStream out = Funnels.asOutputStream(h)) {
        ByteStreams.copy(in, out);
    } catch (IOException e) {
        deleteDst();
        throw new Die("cannot checksum " + dst, e);
    }
    if (sha1.equals(h.hash().toString())) {
        System.err.println("Checksum " + dst.getFileName() + " OK");
        System.err.flush();
    } else if (ui.isBatch()) {
        deleteDst();
        throw new Die(dst + " SHA-1 checksum does not match");
    } else if (!ui.yesno(null, // 
    "error: SHA-1 checksum does not match\nUse %s anyway", dst.getFileName())) {
        deleteDst();
        throw new Die("aborted by user");
    }
}
#end_block

#method_before
@Override
public void run() {
    ui.header("Experimental features");
    if (!ui.yesno(false, "Enable any experimental features")) {
        return;
    }
    if (flags.isNew) {
        initNoteDb();
    }
    initUis();
}
#method_after
@Override
public void run() {
    ui.header("Experimental features");
    if (!ui.yesno(false, "Enable any experimental features")) {
        return;
    }
    initUis();
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Plugin module needs to be inserted *before* the index module.
    // There is the concept of LifecycleModule, in Gerrit's own extension
    // to Guice, which has these:
    // listener().to(SomeClassImplementingLifecycleListener.class);
    // and the start() methods of each such listener are executed in the
    // order they are declared.
    // Makes sure that PluginLoader.start() is executed before the
    // LuceneIndexModule.start() so that plugins get loaded and the respective
    // Guice modules installed so that the on-line reindexing will happen
    // with the proper classes (e.g. group backends, custom Prolog
    // predicates) and the associated rules ready to be evaluated.
    modules.add(new PluginModule());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(inMemoryTest ? new InMemoryAccountPatchReviewStore.Module() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (inMemoryTest) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new ChangeCleanupRunner.Module());
    }
    modules.addAll(LibModuleLoader.loadModules(cfgInjector));
    if (migrateToNoteDb()) {
        modules.add(new OnlineNoteDbMigrator.Module());
    }
    if (testSysModule != null) {
        modules.add(testSysModule);
    }
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Plugin module needs to be inserted *before* the index module.
    // There is the concept of LifecycleModule, in Gerrit's own extension
    // to Guice, which has these:
    // listener().to(SomeClassImplementingLifecycleListener.class);
    // and the start() methods of each such listener are executed in the
    // order they are declared.
    // Makes sure that PluginLoader.start() is executed before the
    // LuceneIndexModule.start() so that plugins get loaded and the respective
    // Guice modules installed so that the on-line reindexing will happen
    // with the proper classes (e.g. group backends, custom Prolog
    // predicates) and the associated rules ready to be evaluated.
    modules.add(new PluginModule());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(inMemoryTest ? new InMemoryAccountPatchReviewStore.Module() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (inMemoryTest) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new AccountDeactivator.Module());
        modules.add(new ChangeCleanupRunner.Module());
    }
    modules.addAll(LibModuleLoader.loadModules(cfgInjector));
    if (migrateToNoteDb()) {
        modules.add(new OnlineNoteDbMigrator.Module(trial));
    }
    if (testSysModule != null) {
        modules.add(testSysModule);
    }
    modules.add(new LocalMergeSuperSetComputation.Module());
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
protected void configure() {
    install(new FactoryModuleBuilder().implement(AccountIndex.class, LuceneAccountIndex.class).build(AccountIndex.Factory.class));
    install(new FactoryModuleBuilder().implement(ChangeIndex.class, LuceneChangeIndex.class).build(ChangeIndex.Factory.class));
    install(new FactoryModuleBuilder().implement(GroupIndex.class, LuceneGroupIndex.class).build(GroupIndex.Factory.class));
    install(new IndexModule(threads));
    if (singleVersions == null) {
        install(new MultiVersionModule());
    } else {
        install(new SingleVersionModule(singleVersions));
    }
}
#method_after
@Override
protected void configure() {
    install(new FactoryModuleBuilder().implement(AccountIndex.class, LuceneAccountIndex.class).build(AccountIndex.Factory.class));
    install(new FactoryModuleBuilder().implement(ChangeIndex.class, LuceneChangeIndex.class).build(ChangeIndex.Factory.class));
    install(new FactoryModuleBuilder().implement(GroupIndex.class, LuceneGroupIndex.class).build(GroupIndex.Factory.class));
    install(new FactoryModuleBuilder().implement(ProjectIndex.class, LuceneProjectIndex.class).build(ProjectIndex.Factory.class));
    install(new IndexModule(threads));
    if (singleVersions == null) {
        install(new MultiVersionModule());
    } else {
        install(new SingleVersionModule(singleVersions));
    }
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    ChangeControl control = StoredValues.CHANGE_CONTROL.get(engine);
    SubmitType submitType = control.getProject().getSubmitType();
    if (!a1.unify(term[submitType.ordinal()], engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    ProjectState projectState = StoredValues.PROJECT_STATE.get(engine);
    SubmitType submitType = projectState.getProject().getSubmitType();
    if (!a1.unify(term[submitType.ordinal()], engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
static Term export(LabelType type) {
    LabelValue min = type.getMin();
    LabelValue max = type.getMax();
    return new StructureTerm(symLabelType, SymbolTerm.intern(type.getName()), SymbolTerm.intern(type.getFunctionName()), min != null ? new IntegerTerm(min.getValue()) : NONE, max != null ? new IntegerTerm(max.getValue()) : NONE);
}
#method_after
static Term export(LabelType type) {
    LabelValue min = type.getMin();
    LabelValue max = type.getMax();
    return new StructureTerm(symLabelType, SymbolTerm.intern(type.getName()), SymbolTerm.intern(type.getFunction().getFunctionName()), min != null ? new IntegerTerm(min.getValue()) : NONE, max != null ? new IntegerTerm(max.getValue()) : NONE);
}
#end_block

#method_before
public static String changeMetaRef(Change.Id id) {
    StringBuilder r = new StringBuilder();
    r.append(REFS_CHANGES);
    r.append(shard(id.get()));
    r.append(META_SUFFIX);
    return r.toString();
}
#method_after
public static String changeMetaRef(Change.Id id) {
    StringBuilder r = newStringBuilder().append(REFS_CHANGES);
    return shard(id.get(), r).append(META_SUFFIX).toString();
}
#end_block

#method_before
public static String robotCommentsRef(Change.Id id) {
    StringBuilder r = new StringBuilder();
    r.append(REFS_CHANGES);
    r.append(shard(id.get()));
    r.append(ROBOT_COMMENTS_SUFFIX);
    return r.toString();
}
#method_after
public static String robotCommentsRef(Change.Id id) {
    StringBuilder r = newStringBuilder().append(REFS_CHANGES);
    return shard(id.get(), r).append(ROBOT_COMMENTS_SUFFIX).toString();
}
#end_block

#method_before
public static String refsUsers(Account.Id accountId) {
    StringBuilder r = new StringBuilder();
    r.append(REFS_USERS);
    r.append(shard(accountId.get()));
    return r.toString();
}
#method_after
public static String refsUsers(Account.Id accountId) {
    StringBuilder r = newStringBuilder().append(REFS_USERS);
    return shard(accountId.get(), r).toString();
}
#end_block

#method_before
public static String refsDraftComments(Change.Id changeId, Account.Id accountId) {
    StringBuilder r = buildRefsPrefix(REFS_DRAFT_COMMENTS, changeId.get());
    r.append(accountId.get());
    return r.toString();
}
#method_after
public static String refsDraftComments(Change.Id changeId, Account.Id accountId) {
    return buildRefsPrefix(REFS_DRAFT_COMMENTS, changeId.get()).append(accountId.get()).toString();
}
#end_block

#method_before
public static String refsStarredChanges(Change.Id changeId, Account.Id accountId) {
    StringBuilder r = buildRefsPrefix(REFS_STARRED_CHANGES, changeId.get());
    r.append(accountId.get());
    return r.toString();
}
#method_after
public static String refsStarredChanges(Change.Id changeId, Account.Id accountId) {
    return buildRefsPrefix(REFS_STARRED_CHANGES, changeId.get()).append(accountId.get()).toString();
}
#end_block

#method_before
private static StringBuilder buildRefsPrefix(String prefix, int id) {
    StringBuilder r = new StringBuilder();
    r.append(prefix);
    r.append(shard(id));
    r.append('/');
    return r;
}
#method_after
private static StringBuilder buildRefsPrefix(String prefix, int id) {
    StringBuilder r = newStringBuilder().append(prefix);
    return shard(id, r).append('/');
}
#end_block

#method_before
public static String shard(int id) {
    if (id < 0) {
        return null;
    }
    StringBuilder r = new StringBuilder();
    int n = id % 100;
    if (n < 10) {
        r.append('0');
    }
    r.append(n);
    r.append('/');
    r.append(id);
    return r.toString();
}
#method_after
public static String shard(int id) {
    if (id < 0) {
        return null;
    }
    return shard(id, newStringBuilder()).toString();
}
#end_block

#method_before
public static String shard(int id) {
    if (id < 0) {
        return null;
    }
    StringBuilder r = new StringBuilder();
    int n = id % 100;
    if (n < 10) {
        r.append('0');
    }
    r.append(n);
    r.append('/');
    r.append(id);
    return r.toString();
}
#method_after
private static StringBuilder shard(int id, StringBuilder sb) {
    int n = id % 100;
    if (n < 10) {
        sb.append('0');
    }
    sb.append(n);
    sb.append('/');
    sb.append(id);
    return sb;
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Deprecated
@Override
public void delete() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void publish() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Deprecated
@Override
public void publish() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void rebase() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Deprecated
@Override
public void rebase() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
private String shortenSubject(String subject) {
    if (subject.length() < 73) {
        return subject;
    } else {
        return subject.substring(0, 69) + "...";
    }
}
#method_after
private static String shortenSubject(String subject) {
    if (subject.length() < 73) {
        return subject;
    } else {
        return subject.substring(0, 69) + "...";
    }
}
#end_block

#method_before
private void addNewGroupMembers(ReviewDb db, AccountGroup group, Set<Account.Id> newMemberIds) throws OrmException, IOException {
    Set<AccountGroupMember> newMembers = newMemberIds.stream().map(accountId -> new AccountGroupMember.Key(accountId, group.getId())).map(AccountGroupMember::new).collect(toImmutableSet());
    if (currentUser != null) {
        auditService.dispatchAddAccountsToGroup(currentUser.getAccountId(), newMembers);
    }
    db.accountGroupMembers().insert(newMembers);
    groupCache.evict(group.getGroupUUID(), group.getId(), group.getNameKey());
    for (AccountGroupMember newMember : newMembers) {
        accountCache.evict(newMember.getAccountId());
    }
}
#method_after
private void addNewGroupMembers(ReviewDb db, AccountGroup group, Set<Account.Id> newMemberIds) throws OrmException, IOException {
    Set<AccountGroupMember> newMembers = newMemberIds.stream().map(accountId -> new AccountGroupMember.Key(accountId, group.getId())).map(AccountGroupMember::new).collect(toImmutableSet());
    if (currentUser != null) {
        auditService.dispatchAddAccountsToGroup(currentUser.getAccountId(), newMembers);
    }
    db.accountGroupMembers().insert(newMembers);
    groupCache.evict(group.getGroupUUID(), group.getId(), group.getNameKey());
    for (AccountGroupMember newMember : newMembers) {
        groupIncludeCache.evictGroupsWithMember(newMember.getAccountId());
    }
}
#end_block

#method_before
public void removeGroupMembers(ReviewDb db, AccountGroup.UUID groupUuid, Set<Account.Id> accountIds) throws OrmException, IOException, NoSuchGroupException {
    AccountGroup group = getExistingGroupFromReviewDb(db, groupUuid);
    AccountGroup.Id groupId = group.getId();
    Set<AccountGroupMember> membersToRemove = new HashSet<>();
    for (Account.Id accountId : accountIds) {
        boolean isMember = groups.isMember(db, groupUuid, accountId);
        if (isMember) {
            AccountGroupMember.Key key = new AccountGroupMember.Key(accountId, groupId);
            membersToRemove.add(new AccountGroupMember(key));
        }
    }
    if (membersToRemove.isEmpty()) {
        return;
    }
    if (currentUser != null) {
        auditService.dispatchDeleteAccountsFromGroup(currentUser.getAccountId(), membersToRemove);
    }
    db.accountGroupMembers().delete(membersToRemove);
    groupCache.evict(group.getGroupUUID(), group.getId(), group.getNameKey());
    for (AccountGroupMember member : membersToRemove) {
        accountCache.evict(member.getAccountId());
    }
}
#method_after
public void removeGroupMembers(ReviewDb db, AccountGroup.UUID groupUuid, Set<Account.Id> accountIds) throws OrmException, IOException, NoSuchGroupException {
    AccountGroup group = getExistingGroupFromReviewDb(db, groupUuid);
    AccountGroup.Id groupId = group.getId();
    Set<AccountGroupMember> membersToRemove = new HashSet<>();
    for (Account.Id accountId : accountIds) {
        boolean isMember = groups.isMember(db, groupUuid, accountId);
        if (isMember) {
            AccountGroupMember.Key key = new AccountGroupMember.Key(accountId, groupId);
            membersToRemove.add(new AccountGroupMember(key));
        }
    }
    if (membersToRemove.isEmpty()) {
        return;
    }
    if (currentUser != null) {
        auditService.dispatchDeleteAccountsFromGroup(currentUser.getAccountId(), membersToRemove);
    }
    db.accountGroupMembers().delete(membersToRemove);
    groupCache.evict(group.getGroupUUID(), group.getId(), group.getNameKey());
    for (AccountGroupMember member : membersToRemove) {
        groupIncludeCache.evictGroupsWithMember(member.getAccountId());
    }
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(PARENT_GROUPS_NAME, AccountGroup.UUID.class, new TypeLiteral<ImmutableList<AccountGroup.UUID>>() {
            }).loader(ParentGroupsLoader.class);
            cache(EXTERNAL_NAME, String.class, new TypeLiteral<ImmutableList<AccountGroup.UUID>>() {
            }).loader(AllExternalLoader.class);
            bind(GroupIncludeCacheImpl.class);
            bind(GroupIncludeCache.class).to(GroupIncludeCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(GROUPS_WITH_MEMBER_NAME, Account.Id.class, new TypeLiteral<ImmutableSet<AccountGroup.UUID>>() {
            }).loader(GroupsWithMemberLoader.class);
            cache(PARENT_GROUPS_NAME, AccountGroup.UUID.class, new TypeLiteral<ImmutableList<AccountGroup.UUID>>() {
            }).loader(ParentGroupsLoader.class);
            cache(EXTERNAL_NAME, String.class, new TypeLiteral<ImmutableList<AccountGroup.UUID>>() {
            }).loader(AllExternalLoader.class);
            bind(GroupIncludeCacheImpl.class);
            bind(GroupIncludeCache.class).to(GroupIncludeCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Override
public ImmutableList<AccountGroup.UUID> load(AccountGroup.UUID key) throws OrmException {
    Stream<InternalGroup> internalGroupStream;
    if (groupIndexProvider.get().getSchema().hasField(GroupField.SUBGROUP)) {
        internalGroupStream = groupQueryProvider.get().bySubgroup(key).stream();
    } else {
        try (ReviewDb db = schema.open()) {
            internalGroupStream = Groups.getParentGroupsFromReviewDb(db, key).map(groupCache::get).flatMap(Streams::stream);
        }
    }
    return internalGroupStream.map(InternalGroup::getGroupUUID).collect(toImmutableList());
}
#method_after
@Override
public ImmutableList<AccountGroup.UUID> load(AccountGroup.UUID key) throws OrmException {
    if (groupIndexProvider.get().getSchema().hasField(GroupField.SUBGROUP)) {
        return groupQueryProvider.get().bySubgroup(key).stream().map(InternalGroup::getGroupUUID).collect(toImmutableList());
    }
    try (ReviewDb db = schema.open()) {
        return Groups.getParentGroupsFromReviewDb(db, key).map(groupCache::get).flatMap(Streams::stream).map(InternalGroup::getGroupUUID).collect(toImmutableList());
    }
}
#end_block

#method_before
private List<AccountInfo> getTransitiveMembers(GroupDescription.Internal group, GroupControl groupControl) throws OrmException {
    Set<Account.Id> members = getTransitiveMemberIds(group, groupControl, new HashSet<>(ImmutableSet.of(group.getGroupUUID())));
    return toAccountInfos(members);
}
#method_after
private List<AccountInfo> getTransitiveMembers(GroupDescription.Internal group, GroupControl groupControl) throws OrmException {
    checkSameGroup(group, groupControl);
    Set<Account.Id> members = getTransitiveMemberIds(group, groupControl, new HashSet<>(ImmutableSet.of(group.getGroupUUID())));
    return toAccountInfos(members);
}
#end_block

#method_before
public List<AccountInfo> getDirectMembers(GroupDescription.Internal group, GroupControl groupControl) throws OrmException {
    Set<Account.Id> directMembers = getDirectMemberIds(group, groupControl);
    return toAccountInfos(directMembers);
}
#method_after
public List<AccountInfo> getDirectMembers(GroupDescription.Internal group, GroupControl groupControl) throws OrmException {
    checkSameGroup(group, groupControl);
    Set<Account.Id> directMembers = getDirectMemberIds(group, groupControl);
    return toAccountInfos(directMembers);
}
#end_block

#method_before
@Override
protected void configure() {
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), CONFIG_KIND);
    DynamicMap.mapOf(binder(), TASK_KIND);
    DynamicMap.mapOf(binder(), TOP_MENU_KIND);
    child(CONFIG_KIND, "capabilities").to(CapabilitiesCollection.class);
    child(CONFIG_KIND, "tasks").to(TasksCollection.class);
    get(TASK_KIND).to(GetTask.class);
    delete(TASK_KIND).to(DeleteTask.class);
    child(CONFIG_KIND, "top-menus").to(TopMenuCollection.class);
    get(CONFIG_KIND, "version").to(GetVersion.class);
    get(CONFIG_KIND, "info").to(GetServerInfo.class);
    get(CONFIG_KIND, "preferences").to(GetPreferences.class);
    put(CONFIG_KIND, "preferences").to(SetPreferences.class);
    put(CONFIG_KIND, "email.validate").to(ValidateEmail.class);
}
#method_after
@Override
protected void configure() {
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), CONFIG_KIND);
    DynamicMap.mapOf(binder(), TASK_KIND);
    DynamicMap.mapOf(binder(), TOP_MENU_KIND);
    child(CONFIG_KIND, "capabilities").to(CapabilitiesCollection.class);
    child(CONFIG_KIND, "tasks").to(TasksCollection.class);
    get(TASK_KIND).to(GetTask.class);
    delete(TASK_KIND).to(DeleteTask.class);
    child(CONFIG_KIND, "top-menus").to(TopMenuCollection.class);
    get(CONFIG_KIND, "version").to(GetVersion.class);
    get(CONFIG_KIND, "info").to(GetServerInfo.class);
    get(CONFIG_KIND, "preferences").to(GetPreferences.class);
    put(CONFIG_KIND, "preferences").to(SetPreferences.class);
    put(CONFIG_KIND, "email.confirm").to(ConfirmEmail.class);
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    ConfigServerApi.validateEmail(magicToken, new ScreenLoadCallback<VoidResult>(this) {

        @Override
        protected void preDisplay(final VoidResult result) {
        }

        @Override
        protected void postDisplay() {
            Gerrit.display(PageLinks.SETTINGS_CONTACT);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    ConfigServerApi.confirmEmail(magicToken, new ScreenLoadCallback<VoidResult>(this) {

        @Override
        protected void preDisplay(final VoidResult result) {
        }

        @Override
        protected void postDisplay() {
            Gerrit.display(PageLinks.SETTINGS_CONTACT);
        }
    });
}
#end_block

#method_before
HttpResult post(String endpoint, Map<String, String> headers, String content) throws IOException {
    HttpPost post = new HttpPost(endpoint);
    post.addHeader("Content-Type", MediaType.JSON_UTF_8.toString());
    headers.entrySet().stream().forEach(e -> {
        post.addHeader(e.getKey(), e.getValue());
    });
    post.setEntity(new StringEntity(content, StandardCharsets.UTF_8));
    return httpClient.execute(post, new HttpResponseHandler());
}
#method_after
HttpResult post(String endpoint, EventProcessor.Request request) throws IOException {
    HttpPost post = new HttpPost(endpoint);
    post.addHeader("Content-Type", MediaType.JSON_UTF_8.toString());
    request.headers.entrySet().stream().forEach(e -> {
        post.addHeader(e.getKey(), e.getValue());
    });
    post.setEntity(new StringEntity(request.body, StandardCharsets.UTF_8));
    return httpClient.execute(post, new HttpResponseHandler());
}
#end_block

#method_before
@Before
public void setup() {
    when(cfg.getRetryInterval()).thenReturn(RETRY_INTERVAL);
    when(cfg.getMaxTries()).thenReturn(MAX_TRIES);
    when(processor.process()).thenReturn(CONTENT);
    task = new PostTask(executor, session, cfg, WEBHOOK_URL, processor);
}
#method_after
@Before
public void setup() {
    when(cfg.getRetryInterval()).thenReturn(RETRY_INTERVAL);
    when(cfg.getMaxTries()).thenReturn(MAX_TRIES);
    when(remote.getUrl()).thenReturn(WEBHOOK_URL);
    when(processor.process(eq(projectCreated), eq(remote))).thenReturn(Optional.of(content));
    task = new PostTask(executor, session, cfg, processor, projectCreated, remote);
}
#end_block

#method_before
@Test
public void noRescheduleOnSuccess() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, BODY)).thenReturn(OK_RESULT);
    task.run();
    verifyZeroInteractions(executor);
}
#method_after
@Test
public void noRescheduleOnSuccess() throws IOException {
    when(session.post(eq(WEBHOOK_URL), eq(content))).thenReturn(OK_RESULT);
    task.run();
    verifyZeroInteractions(executor);
}
#end_block

#method_before
@Test
public void noRescheduleOnNonRecoverableException() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, BODY)).thenThrow(SSLException.class);
    task.run();
    verifyZeroInteractions(executor);
}
#method_after
@Test
public void noRescheduleOnNonRecoverableException() throws IOException {
    when(session.post(eq(WEBHOOK_URL), eq(content))).thenThrow(SSLException.class);
    task.run();
    verifyZeroInteractions(executor);
}
#end_block

#method_before
@Test
public void rescheduleOnError() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, BODY)).thenReturn(ERR_RESULT);
    task.run();
    verify(executor, times(1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#method_after
@Test
public void rescheduleOnError() throws IOException {
    when(session.post(eq(WEBHOOK_URL), eq(content))).thenReturn(ERR_RESULT);
    task.run();
    verify(executor, times(1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Test
public void rescheduleOnRecoverableException() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, BODY)).thenThrow(IOException.class);
    task.run();
    verify(executor, times(1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#method_after
@Test
public void rescheduleOnRecoverableException() throws IOException {
    when(session.post(eq(WEBHOOK_URL), eq(content))).thenThrow(IOException.class);
    task.run();
    verify(executor, times(1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Test
public void keepReschedulingMaxTriesTimes() throws IOException {
    when(session.post(WEBHOOK_URL, HEADERS, BODY)).thenThrow(IOException.class);
    when(executor.schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS)).then(new Answer<Void>() {

        @Override
        public Void answer(InvocationOnMock invocation) throws Throwable {
            task.run();
            return null;
        }
    });
    task.run();
    verify(executor, times(MAX_TRIES - 1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#method_after
@Test
public void keepReschedulingMaxTriesTimes() throws IOException {
    when(session.post(eq(WEBHOOK_URL), eq(content))).thenThrow(IOException.class);
    when(executor.schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS)).then(new Answer<Void>() {

        @Override
        public Void answer(InvocationOnMock invocation) throws Throwable {
            task.run();
            return null;
        }
    });
    task.run();
    verify(executor, times(MAX_TRIES - 1)).schedule(task, RETRY_INTERVAL, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Override
public void run() {
    try {
        Optional<EventProcessor.Output> content = processor.get();
        if (!content.isPresent()) {
            log.debug("No content. Webhook [{}] skipped.", url);
            return;
        }
        execCnt++;
        HttpResult result = session.post(url, content.get().headers, content.get().body);
        if (!result.successful && execCnt < cfg.getMaxTries()) {
            logRetry(result.message);
            reschedule();
        }
    } catch (IOException e) {
        if (isRecoverable(e) && execCnt < cfg.getMaxTries()) {
            logRetry(e);
            reschedule();
        } else {
            log.error("Failed to post: {}", toString(), e);
        }
    }
}
#method_after
@Override
public void run() {
    try {
        Optional<EventProcessor.Request> content = processor.get();
        if (!content.isPresent()) {
            log.debug("No content. Webhook [{}] skipped.", url);
            return;
        }
        execCnt++;
        HttpResult result = session.post(url, content.get());
        if (!result.successful && execCnt < cfg.getMaxTries()) {
            logRetry(result.message);
            reschedule();
        }
    } catch (IOException e) {
        if (isRecoverable(e) && execCnt < cfg.getMaxTries()) {
            logRetry(e);
            reschedule();
        } else {
            log.error("Failed to post: {}", toString(), e);
        }
    }
}
#end_block

#method_before
@Override
public String toString() {
    Optional<EventProcessor.Output> content = processor.get();
    return content.isPresent() ? content.get().toString() : "no content";
}
#method_after
@Override
public String toString() {
    Optional<EventProcessor.Request> content = processor.get();
    return content.isPresent() ? content.get().toString() : "no content";
}
#end_block

#method_before
public Map<String, Set<String>> getIssueIds(String projectName, String commitId, PatchSet.Id patchSetId) {
    Map<String, Set<String>> current = getIssueIds(projectName, commitId);
    if (patchSetId != null) {
        Map<String, Set<String>> previous = Maps.newHashMap();
        if (patchSetId.get() != 1) {
            try {
                String previousRevision = getPreviousRevision(patchSetId);
                if (previousRevision != null) {
                    previous = getIssueIds(projectName, previousRevision);
                }
            } catch (RestApiException e) {
            // previous is still empty to indicate that there was no previous
            // accessible patch set. We treat every occurrence as added.
            }
        }
        for (String issue : current.keySet()) {
            Set<String> currentOccurrences = current.get(issue);
            Set<String> previousOccurrences = previous.get(issue);
            Set<String> newOccurrences;
            if (previousOccurrences == null || previousOccurrences.isEmpty()) {
                newOccurrences = Sets.newHashSet(currentOccurrences);
            } else {
                newOccurrences = Sets.newHashSet(currentOccurrences);
                newOccurrences.removeAll(previousOccurrences);
            }
            for (String occurrence : newOccurrences) {
                currentOccurrences.add("added@" + occurrence);
            }
        }
    }
    return current;
}
#method_after
public Map<String, Set<String>> getIssueIds(String projectName, String commitId, PatchSet.Id patchSetId) {
    Map<String, Set<String>> current = getIssueIds(projectName, commitId);
    if (patchSetId != null) {
        Map<String, Set<String>> previous = Maps.newHashMap();
        if (patchSetId.get() != 1) {
            PatchSet.Id previousPatchSetId = new PatchSet.Id(patchSetId.getParentKey(), patchSetId.get() - 1);
            String previousPatchSet = db.getRevision(previousPatchSetId);
            if (previousPatchSet != null) {
                previous = getIssueIds(projectName, previousPatchSet);
            }
        }
        for (String issue : current.keySet()) {
            Set<String> currentOccurrences = current.get(issue);
            Set<String> previousOccurrences = previous.get(issue);
            Set<String> newOccurrences;
            if (previousOccurrences == null || previousOccurrences.isEmpty()) {
                newOccurrences = Sets.newHashSet(currentOccurrences);
            } else {
                newOccurrences = Sets.newHashSet(currentOccurrences);
                newOccurrences.removeAll(previousOccurrences);
            }
            for (String occurrence : newOccurrences) {
                currentOccurrences.add("added@" + occurrence);
            }
        }
    }
    return current;
}
#end_block

#method_before
@Test
public void pushForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(1);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES);
    cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId(), MESSAGES);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3.");
}
#method_after
@Test
public void pushForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(1);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId(), MESSAGES);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3.");
}
#end_block

#method_before
@Test
public void pushNewPatchSetForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ChangeInfo ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the new patch set was added as a reviewer since they added
    // a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
}
#method_after
@Test
public void pushNewPatchSetForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ChangeInfo ci = get(r.getChangeId(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the new patch set was added as a reviewer since they added
    // a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
}
#end_block

#method_before
@Test
public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws Exception {
    // Create a commit with "User" as author and committer
    RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    // Push this commit as "Administrator" (requires Forge Committer Identity)
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false);
    // Expected Code-Review votes:
    // 1. 0 from User (committer):
    // When the committer is forged, the committer is automatically added as
    // reviewer, hence we expect a dummy 0 vote for the committer.
    // 2. +1 from Administrator (uploader):
    // On push Code-Review+1 was specified, hence we expect a +1 vote from
    // the uploader.
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get(), DETAILED_LABELS, MESSAGES);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(2);
    int indexAdmin = admin.fullName.equals(cr.all.get(0).name) ? 0 : 1;
    int indexUser = indexAdmin == 0 ? 1 : 0;
    assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName);
    assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1);
    assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName);
    assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#method_after
@Test
public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws Exception {
    // Create a commit with "User" as author and committer
    RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    // Push this commit as "Administrator" (requires Forge Committer Identity)
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false);
    // Expected Code-Review votes:
    // 1. 0 from User (committer):
    // When the committer is forged, the committer is automatically added as
    // reviewer, hence we expect a dummy 0 vote for the committer.
    // 2. +1 from Administrator (uploader):
    // On push Code-Review+1 was specified, hence we expect a +1 vote from
    // the uploader.
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get(), DETAILED_LABELS, MESSAGES, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(2);
    int indexAdmin = admin.fullName.equals(cr.all.get(0).name) ? 0 : 1;
    int indexUser = indexAdmin == 0 ? 1 : 0;
    assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName);
    assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1);
    assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName);
    assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#end_block

#method_before
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get(), DETAILED_LABELS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#method_after
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get(), DETAILED_LABELS, DETAILED_ACCOUNTS);
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#end_block

#method_before
public Set<Property> extractFrom(ChangeAttribute changeAttribute) {
    Set<Property> properties = Sets.newHashSet();
    properties.add(propertyFactory.create("project", changeAttribute.project));
    properties.add(propertyFactory.create("branch", changeAttribute.branch));
    properties.add(propertyFactory.create("topic", changeAttribute.topic));
    properties.add(propertyFactory.create("subject", changeAttribute.subject));
    properties.add(propertyFactory.create("commit-message", changeAttribute.commitMessage));
    properties.add(propertyFactory.create("change-id", changeAttribute.id));
    properties.add(propertyFactory.create("change-number", Integer.toString(changeAttribute.number)));
    properties.add(propertyFactory.create("change-url", changeAttribute.url));
    String status = null;
    if (changeAttribute.status != null) {
        status = changeAttribute.status.toString();
    }
    properties.add(propertyFactory.create("status", status));
    properties.addAll(extractFrom(changeAttribute.owner, "owner"));
    return properties;
}
#method_after
public Set<Property> extractFrom(ChangeAttribute changeAttribute) {
    Set<Property> properties = Sets.newHashSet();
    properties.add(propertyFactory.create("project", changeAttribute.project));
    properties.add(propertyFactory.create("branch", changeAttribute.branch));
    properties.add(propertyFactory.create("topic", changeAttribute.topic));
    properties.add(propertyFactory.create("subject", changeAttribute.subject));
    properties.add(propertyFactory.create("commit-message", changeAttribute.commitMessage));
    properties.add(propertyFactory.create("change-id", changeAttribute.id));
    properties.add(propertyFactory.create("change-number", String.valueOf(changeAttribute.number)));
    properties.add(propertyFactory.create("change-url", changeAttribute.url));
    String status = null;
    if (changeAttribute.status != null) {
        status = changeAttribute.status.toString();
    }
    properties.add(propertyFactory.create("status", status));
    properties.addAll(extractFrom(changeAttribute.owner, "owner"));
    return properties;
}
#end_block

#method_before
public Set<Property> extractFrom(PatchSetAttribute patchSetAttribute) {
    Set<Property> properties = Sets.newHashSet();
    properties.add(propertyFactory.create("revision", patchSetAttribute.revision));
    properties.add(propertyFactory.create("patch-set-number", Integer.toString(patchSetAttribute.number)));
    properties.add(propertyFactory.create("ref", patchSetAttribute.ref));
    properties.add(propertyFactory.create("created-on", patchSetAttribute.createdOn.toString()));
    properties.add(propertyFactory.create("parents", patchSetAttribute.parents.toString()));
    properties.add(propertyFactory.create("deletions", Integer.toString(patchSetAttribute.sizeDeletions)));
    properties.add(propertyFactory.create("insertions", Integer.toString(patchSetAttribute.sizeInsertions)));
    properties.add(propertyFactory.create("is-draft", Boolean.toString(patchSetAttribute.isDraft)));
    properties.addAll(extractFrom(patchSetAttribute.uploader, "uploader"));
    properties.addAll(extractFrom(patchSetAttribute.author, "author"));
    return properties;
}
#method_after
public Set<Property> extractFrom(PatchSetAttribute patchSetAttribute) {
    Set<Property> properties = Sets.newHashSet();
    properties.add(propertyFactory.create("revision", patchSetAttribute.revision));
    properties.add(propertyFactory.create("patch-set-number", String.valueOf(patchSetAttribute.number)));
    properties.add(propertyFactory.create("ref", patchSetAttribute.ref));
    properties.add(propertyFactory.create("created-on", patchSetAttribute.createdOn.toString()));
    properties.add(propertyFactory.create("parents", patchSetAttribute.parents.toString()));
    properties.add(propertyFactory.create("deletions", Integer.toString(patchSetAttribute.sizeDeletions)));
    properties.add(propertyFactory.create("insertions", Integer.toString(patchSetAttribute.sizeInsertions)));
    properties.add(propertyFactory.create("is-draft", Boolean.toString(patchSetAttribute.isDraft)));
    properties.addAll(extractFrom(patchSetAttribute.uploader, "uploader"));
    properties.addAll(extractFrom(patchSetAttribute.author, "author"));
    return properties;
}
#end_block

#method_before
@Override
public void run() throws Failure {
    try {
        DeleteProject.Input input = new DeleteProject.Input();
        input.force = force;
        input.preserve = preserveGitRepository;
        ProjectResource rsrc = new ProjectResource(projectState);
        deleteProject.assertDeletePermission(rsrc);
        deleteProject.assertCanDelete(rsrc, input);
        if (!yesReallyDelete) {
            StringBuilder msgBuilder = new StringBuilder();
            msgBuilder.append("Really delete ");
            msgBuilder.append(rsrc.getName());
            msgBuilder.append("?\n");
            msgBuilder.append("This is an operation which permanently deletes ");
            msgBuilder.append("data. This cannot be undone!\n");
            msgBuilder.append("If you are sure you wish to delete this project, ");
            msgBuilder.append("re-run\n");
            msgBuilder.append("with the --yes-really-delete flag.\n");
            throw new UnloggedFailure(msgBuilder.toString());
        }
        if (!force) {
            Collection<String> warnings = deleteProject.getWarnings(rsrc);
            if (warnings != null && !warnings.isEmpty()) {
                StringBuilder msgBuilder = new StringBuilder();
                msgBuilder.append("There are warnings against deleting ");
                msgBuilder.append(rsrc.getName());
                msgBuilder.append(":\n");
                for (String warning : warnings) {
                    msgBuilder.append(" * ");
                    msgBuilder.append(warning);
                    msgBuilder.append("\n");
                }
                msgBuilder.append("To really delete ");
                msgBuilder.append(rsrc.getName());
                msgBuilder.append(", re-run with the --force flag.");
                throw new UnloggedFailure(msgBuilder.toString());
            }
        }
        deleteProject.doDelete(rsrc, input);
    } catch (AuthException | ResourceNotFoundException | ResourceConflictException | OrmException | IOException e) {
        die(e);
    }
}
#method_after
@Override
public void run() throws Failure {
    try {
        DeleteProject.Input input = new DeleteProject.Input();
        input.force = force;
        input.preserve = preserveGitRepository;
        ProjectResource rsrc = new ProjectResource(projectState, user);
        deleteProject.assertDeletePermission(rsrc);
        deleteProject.assertCanDelete(rsrc, input);
        if (!yesReallyDelete) {
            StringBuilder msgBuilder = new StringBuilder();
            msgBuilder.append("Really delete ");
            msgBuilder.append(rsrc.getName());
            msgBuilder.append("?\n");
            msgBuilder.append("This is an operation which permanently deletes ");
            msgBuilder.append("data. This cannot be undone!\n");
            msgBuilder.append("If you are sure you wish to delete this project, ");
            msgBuilder.append("re-run\n");
            msgBuilder.append("with the --yes-really-delete flag.\n");
            throw new UnloggedFailure(msgBuilder.toString());
        }
        if (!force) {
            Collection<String> warnings = deleteProject.getWarnings(rsrc);
            if (warnings != null && !warnings.isEmpty()) {
                StringBuilder msgBuilder = new StringBuilder();
                msgBuilder.append("There are warnings against deleting ");
                msgBuilder.append(rsrc.getName());
                msgBuilder.append(":\n");
                for (String warning : warnings) {
                    msgBuilder.append(" * ");
                    msgBuilder.append(warning);
                    msgBuilder.append("\n");
                }
                msgBuilder.append("To really delete ");
                msgBuilder.append(rsrc.getName());
                msgBuilder.append(", re-run with the --force flag.");
                throw new UnloggedFailure(msgBuilder.toString());
            }
        }
        deleteProject.doDelete(rsrc, input);
    } catch (AuthException | ResourceNotFoundException | ResourceConflictException | OrmException | IOException e) {
        die(e);
    }
}
#end_block

#method_before
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Created a revert of this change as %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
}
#method_after
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Created a revert of this change as %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
    assertThat(revertChange.revertOf).isEqualTo(gApi.changes().id(r.getChangeId()).get()._number);
}
#end_block

#method_before
private void testRebase(Rebase rebase) throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    // Add an approval whose score should be copied on trivial rebase
    gApi.changes().id(r2.getChangeId()).current().review(ReviewInput.recommend());
    String changeId = r2.getChangeId();
    // Rebase the second change
    rebase.call(changeId);
    // Second change should have 2 patch sets and an approval
    ChangeInfo c2 = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.DETAILED_LABELS));
    assertThat(c2.revisions.get(c2.currentRevision)._number).isEqualTo(2);
    // ...and the committer and description should be correct
    ChangeInfo info = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT));
    GitPerson committer = info.revisions.get(info.currentRevision).commit.committer;
    assertThat(committer.name).isEqualTo(admin.fullName);
    assertThat(committer.email).isEqualTo(admin.email);
    String description = info.revisions.get(info.currentRevision).description;
    assertThat(description).isEqualTo("Rebase");
    // ...and the approval was copied
    LabelInfo cr = c2.labels.get("Code-Review");
    assertThat(cr).isNotNull();
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).value).isEqualTo(1);
    if (notesMigration.changePrimaryStorage() == PrimaryStorage.REVIEW_DB) {
        // Ensure record was actually copied under ReviewDb
        List<PatchSetApproval> psas = unwrapDb(db).patchSetApprovals().byPatchSet(new PatchSet.Id(new Change.Id(c2._number), 2)).toList();
        assertThat(psas).hasSize(1);
        assertThat(psas.get(0).getValue()).isEqualTo((short) 1);
    }
    // Rebasing the second change again should fail
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Change is already up to date");
    gApi.changes().id(changeId).current().rebase();
}
#method_after
private void testRebase(Rebase rebase) throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    // Add an approval whose score should be copied on trivial rebase
    gApi.changes().id(r2.getChangeId()).current().review(ReviewInput.recommend());
    String changeId = r2.getChangeId();
    // Rebase the second change
    rebase.call(changeId);
    // Second change should have 2 patch sets and an approval
    ChangeInfo c2 = gApi.changes().id(changeId).get(CURRENT_REVISION, DETAILED_LABELS);
    assertThat(c2.revisions.get(c2.currentRevision)._number).isEqualTo(2);
    // ...and the committer and description should be correct
    ChangeInfo info = gApi.changes().id(changeId).get(CURRENT_REVISION, CURRENT_COMMIT);
    GitPerson committer = info.revisions.get(info.currentRevision).commit.committer;
    assertThat(committer.name).isEqualTo(admin.fullName);
    assertThat(committer.email).isEqualTo(admin.email);
    String description = info.revisions.get(info.currentRevision).description;
    assertThat(description).isEqualTo("Rebase");
    // ...and the approval was copied
    LabelInfo cr = c2.labels.get("Code-Review");
    assertThat(cr).isNotNull();
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).value).isEqualTo(1);
    if (notesMigration.changePrimaryStorage() == PrimaryStorage.REVIEW_DB) {
        // Ensure record was actually copied under ReviewDb
        List<PatchSetApproval> psas = unwrapDb(db).patchSetApprovals().byPatchSet(new PatchSet.Id(new Change.Id(c2._number), 2)).toList();
        assertThat(psas).hasSize(1);
        assertThat(psas.get(0).getValue()).isEqualTo((short) 1);
    }
    // Rebasing the second change again should fail
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Change is already up to date");
    gApi.changes().id(changeId).current().rebase();
}
#end_block

#method_before
@Test
public void pushCommitOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit of user
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, user.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that the author/committer was NOT added as reviewer (he can't see
    // the change)
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#method_after
@Test
public void pushCommitOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit of user
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, user.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that the author/committer was NOT added as reviewer (he can't see
    // the change)
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
@Test
public void pushCommitWithFooterOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit that references 'user' in a footer
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that 'user' was NOT added as cc ('user' can't see the change)
    setApiUser(admin);
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#method_after
@Test
public void pushCommitWithFooterOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit that references 'user' in a footer
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that 'user' was NOT added as cc ('user' can't see the change)
    setApiUser(admin);
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
@Test
public void addReviewerThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // create change
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // try to add user as reviewer
    setApiUser(admin);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(user.email);
    assertThat(r.error).contains("does not have permission to see this change");
    assertThat(r.reviewers).isNull();
}
#method_after
@Test
public void addReviewerThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // create change
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // try to add user as reviewer
    setApiUser(admin);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(user.email);
    assertThat(r.error).contains("does not have permission to see this change");
    assertThat(r.reviewers).isNull();
}
#end_block

#method_before
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#method_after
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
    // Change status of reviewer and ensure ETag is updated.
    oldETag = rsrc.getETag();
    gApi.accounts().id(user.id.get()).setStatus("new status");
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
}
#end_block

#method_before
@Test
public void implicitlyCcOnNonVotingReviewGwtStyle() throws Exception {
    PushOneCommit.Result r = createChange();
    setApiUser(user);
    assertThat(getReviewerState(r.getChangeId(), user.id)).isEmpty();
    // Exact request format made by GWT UI at ddc6b7160fe416fed9e7e3180489d44c82fd64f8.
    ReviewInput in = new ReviewInput();
    in.labels = ImmutableMap.of("Code-Review", (short) 0);
    in.strictLabels = true;
    in.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    in.message = "comment";
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(in);
    // If we're not reading from NoteDb, then the CCed user will be returned in the REVIEWER state.
    assertThat(getReviewerState(r.getChangeId(), user.id)).hasValue(notesMigration.readChanges() ? CC : REVIEWER);
}
#method_after
@Test
public void implicitlyCcOnNonVotingReviewGwtStyle() throws Exception {
    PushOneCommit.Result r = createChange();
    setApiUser(user);
    assertThat(getReviewerState(r.getChangeId(), user.id)).isEmpty();
    // Exact request format made by GWT UI at ddc6b7160fe416fed9e7e3180489d44c82fd64f8.
    ReviewInput in = new ReviewInput();
    in.labels = ImmutableMap.of("Code-Review", (short) 0);
    in.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    in.message = "comment";
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(in);
    // If we're not reading from NoteDb, then the CCed user will be returned in the REVIEWER state.
    assertThat(getReviewerState(r.getChangeId(), user.id)).hasValue(notesMigration.readChanges() ? CC : REVIEWER);
}
#end_block

#method_before
@Test
public void removeReviewerNotPermitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("delete reviewer not permitted");
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).remove();
}
#method_after
@Test
public void removeReviewerNotPermitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("remove reviewer not permitted");
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).remove();
}
#end_block

#method_before
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).get());
    assertThat(result.labels).isNull();
    assertThat(result.messages).isNull();
    assertThat(result.actions).isNull();
    assertThat(result.revisions).isNull();
    EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CHANGE_ACTIONS, ListChangesOption.CURRENT_ACTIONS, ListChangesOption.DETAILED_LABELS, ListChangesOption.MESSAGES);
    result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(options).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.created).isNotNull();
    assertThat(rev.uploader._accountId).isEqualTo(admin.getId().get());
    assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName());
    assertThat(rev.actions).isNotEmpty();
}
#method_after
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).get());
    assertThat(result.labels).isNull();
    assertThat(result.messages).isNull();
    assertThat(result.actions).isNull();
    assertThat(result.revisions).isNull();
    result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(ALL_REVISIONS, CHANGE_ACTIONS, CURRENT_ACTIONS, DETAILED_LABELS, MESSAGES).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.created).isNotNull();
    assertThat(rev.uploader._accountId).isEqualTo(admin.getId().get());
    assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName());
    assertThat(rev.actions).isNotEmpty();
}
#end_block

#method_before
@Test
public void submitted() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    assertThat(gApi.changes().id(r.getChangeId()).info().submitted).isNull();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    assertThat(gApi.changes().id(r.getChangeId()).info().submitted).isNotNull();
}
#method_after
@Test
public void submitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String id = r.getChangeId();
    ChangeInfo c = gApi.changes().id(r.getChangeId()).info();
    assertThat(c.submitted).isNull();
    assertThat(c.submitter).isNull();
    gApi.changes().id(id).current().review(ReviewInput.approve());
    gApi.changes().id(id).current().submit();
    c = gApi.changes().id(r.getChangeId()).info();
    assertThat(c.submitted).isNotNull();
    assertThat(c.submitter).isNotNull();
    assertThat(c.submitter._accountId).isEqualTo(atrScope.get().getUser().getAccountId().get());
}
#end_block

#method_before
@Test
public void check() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(gApi.changes().id(r.getChangeId()).get().problems).isNull();
    assertThat(gApi.changes().id(r.getChangeId()).get(EnumSet.of(ListChangesOption.CHECK)).problems).isEmpty();
}
#method_after
@Test
public void check() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(gApi.changes().id(r.getChangeId()).get().problems).isNull();
    assertThat(gApi.changes().id(r.getChangeId()).get(CHECK).problems).isEmpty();
}
#end_block

#method_before
@Test
public void commitFooters() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    LabelType custom1 = category("Custom1", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    LabelType custom2 = category("Custom2", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    cfg.getLabelSections().put(custom1.getName(), custom1);
    cfg.getLabelSections().put(custom2.getName(), custom2);
    String heads = "refs/heads/*";
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel("Verified"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom1"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom2"), -1, 1, anon, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r1 = createChange();
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    r2.assertOkStatus();
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.label("Verified", 1);
    in.label("Custom1", -1);
    in.label("Custom2", 1);
    gApi.changes().id(r2.getChangeId()).current().review(in);
    EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
    ChangeInfo actual = gApi.changes().id(r2.getChangeId()).get(options);
    assertThat(actual.revisions).hasSize(2);
    // No footers except on latest patch set.
    assertThat(actual.revisions.get(r1.getCommit().getName()).commitWithFooters).isNull();
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(r2.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + r2.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + r2.getChange().getId(), "Reviewed-by: Administrator <admin@example.com>", "Custom2: Administrator <admin@example.com>", "Tested-by: Administrator <admin@example.com>");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#method_after
@Test
public void commitFooters() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    LabelType custom1 = category("Custom1", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    LabelType custom2 = category("Custom2", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    cfg.getLabelSections().put(custom1.getName(), custom1);
    cfg.getLabelSections().put(custom2.getName(), custom2);
    String heads = "refs/heads/*";
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel("Verified"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom1"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom2"), -1, 1, anon, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r1 = createChange();
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    r2.assertOkStatus();
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.label("Verified", 1);
    in.label("Custom1", -1);
    in.label("Custom2", 1);
    gApi.changes().id(r2.getChangeId()).current().review(in);
    ChangeInfo actual = gApi.changes().id(r2.getChangeId()).get(ALL_REVISIONS, COMMIT_FOOTERS);
    assertThat(actual.revisions).hasSize(2);
    // No footers except on latest patch set.
    assertThat(actual.revisions.get(r1.getCommit().getName()).commitWithFooters).isNull();
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(r2.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + r2.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + r2.getChange().getId(), "Reviewed-by: Administrator <admin@example.com>", "Custom2: Administrator <admin@example.com>", "Tested-by: Administrator <admin@example.com>");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#end_block

#method_before
@Test
public void customCommitFooters() throws Exception {
    PushOneCommit.Result change = createChange();
    RegistrationHandle handle = changeMessageModifiers.add(new ChangeMessageModifier() {

        @Override
        public String onSubmit(String newCommitMessage, RevCommit original, RevCommit mergeTip, Branch.NameKey destination) {
            assertThat(original.getName()).isNotEqualTo(mergeTip.getName());
            return newCommitMessage + "Custom: " + destination.get();
        }
    });
    ChangeInfo actual;
    try {
        EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
        actual = gApi.changes().id(change.getChangeId()).get(options);
    } finally {
        handle.remove();
    }
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(change.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + change.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + change.getChange().getId(), "Custom: refs/heads/master");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#method_after
@Test
public void customCommitFooters() throws Exception {
    PushOneCommit.Result change = createChange();
    RegistrationHandle handle = changeMessageModifiers.add(new ChangeMessageModifier() {

        @Override
        public String onSubmit(String newCommitMessage, RevCommit original, RevCommit mergeTip, Branch.NameKey destination) {
            assertThat(original.getName()).isNotEqualTo(mergeTip.getName());
            return newCommitMessage + "Custom: " + destination.get();
        }
    });
    ChangeInfo actual;
    try {
        actual = gApi.changes().id(change.getChangeId()).get(ALL_REVISIONS, COMMIT_FOOTERS);
    } finally {
        handle.remove();
    }
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(change.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + change.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + change.getChange().getId(), "Custom: refs/heads/master");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#end_block

#method_before
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    setApiUser(admin);
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    createDraftChange();
    setApiUser(user);
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try {
        assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(ListChangesOption.LABELS).withOption(ListChangesOption.DETAILED_ACCOUNTS).withOption(ListChangesOption.REVIEWED).get()).hasSize(2);
    } finally {
        enableDb(ctx);
    }
}
#method_after
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    setApiUser(admin);
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    setApiUser(user);
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try {
        assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(LABELS).withOption(DETAILED_ACCOUNTS).withOption(REVIEWED).get()).hasSize(2);
    } finally {
        enableDb(ctx);
    }
}
#end_block

#method_before
@Test
public void votable() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isEqualTo(0);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.blockLabel(cfg, "Code-Review", REGISTERED_USERS, "refs/heads/*");
    saveProjectConfig(project, cfg);
    c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isNull();
}
#method_after
@Test
public void votable() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isEqualTo(0);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.blockLabel(cfg, "Code-Review", REGISTERED_USERS, "refs/heads/*");
    saveProjectConfig(project, cfg);
    c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isNull();
}
#end_block

#method_before
@Test
@GerritConfig(name = "gerrit.editGpgKeys", value = "true")
@GerritConfig(name = "receive.enableSignedPush", value = "true")
public void pushCertificates() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = amendChange(r1.getChangeId());
    ChangeInfo info = gApi.changes().id(r1.getChangeId()).get(EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.PUSH_CERTIFICATES));
    RevisionInfo rev1 = info.revisions.get(r1.getCommit().name());
    assertThat(rev1).isNotNull();
    assertThat(rev1.pushCertificate).isNotNull();
    assertThat(rev1.pushCertificate.certificate).isNull();
    assertThat(rev1.pushCertificate.key).isNull();
    RevisionInfo rev2 = info.revisions.get(r2.getCommit().name());
    assertThat(rev2).isNotNull();
    assertThat(rev2.pushCertificate).isNotNull();
    assertThat(rev2.pushCertificate.certificate).isNull();
    assertThat(rev2.pushCertificate.key).isNull();
}
#method_after
@Test
@GerritConfig(name = "gerrit.editGpgKeys", value = "true")
@GerritConfig(name = "receive.enableSignedPush", value = "true")
public void pushCertificates() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = amendChange(r1.getChangeId());
    ChangeInfo info = gApi.changes().id(r1.getChangeId()).get(ALL_REVISIONS, PUSH_CERTIFICATES);
    RevisionInfo rev1 = info.revisions.get(r1.getCommit().name());
    assertThat(rev1).isNotNull();
    assertThat(rev1.pushCertificate).isNotNull();
    assertThat(rev1.pushCertificate.certificate).isNull();
    assertThat(rev1.pushCertificate.key).isNull();
    RevisionInfo rev2 = info.revisions.get(r2.getCommit().name());
    assertThat(rev2).isNotNull();
    assertThat(rev2.pushCertificate).isNotNull();
    assertThat(rev2.pushCertificate.certificate).isNull();
    assertThat(rev2.pushCertificate.key).isNull();
}
#end_block

#method_before
@Test
public void createMergePatchSet() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    String parent = currentMaster.getCommit().getName();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2";
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION));
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
}
#method_after
@Test
public void createMergePatchSet() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    String parent = currentMaster.getCommit().getName();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2";
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(ALL_REVISIONS, CURRENT_COMMIT, CURRENT_REVISION);
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
}
#end_block

#method_before
@Test
public void createMergePatchSetInheritParent() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    String parent = r.getCommit().getParent(0).getName();
    // advance master branch
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2 inherit parent of ps1";
    in.inheritParent = true;
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION));
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isNotEqualTo(currentMaster.getCommit().getName());
}
#method_after
@Test
public void createMergePatchSetInheritParent() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    String parent = r.getCommit().getParent(0).getName();
    // advance master branch
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2 inherit parent of ps1";
    in.inheritParent = true;
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(ALL_REVISIONS, CURRENT_COMMIT, CURRENT_REVISION);
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isNotEqualTo(currentMaster.getCommit().getName());
}
#end_block

#method_before
@Test
public void maxPermittedValueAllowed() throws Exception {
    final int minPermittedValue = -2;
    final int maxPermittedValue = +2;
    String heads = "refs/heads/*";
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    // default values
    assertThat(approval.permittedVotingRange.min).isEqualTo(-1);
    assertThat(approval.permittedVotingRange.max).isEqualTo(1);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.allow(cfg, Permission.forLabel("Code-Review"), minPermittedValue, maxPermittedValue, REGISTERED_USERS, heads);
    saveProjectConfig(project, cfg);
    c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    assertThat(approval.permittedVotingRange.min).isEqualTo(minPermittedValue);
    assertThat(approval.permittedVotingRange.max).isEqualTo(maxPermittedValue);
}
#method_after
@Test
public void maxPermittedValueAllowed() throws Exception {
    final int minPermittedValue = -2;
    final int maxPermittedValue = +2;
    String heads = "refs/heads/*";
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    // default values
    assertThat(approval.permittedVotingRange.min).isEqualTo(-1);
    assertThat(approval.permittedVotingRange.max).isEqualTo(1);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.allow(cfg, Permission.forLabel("Code-Review"), minPermittedValue, maxPermittedValue, REGISTERED_USERS, heads);
    saveProjectConfig(project, cfg);
    c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    assertThat(approval.permittedVotingRange.min).isEqualTo(minPermittedValue);
    assertThat(approval.permittedVotingRange.max).isEqualTo(maxPermittedValue);
}
#end_block

#method_before
@Test
public void maxPermittedValueBlocked() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.blockLabel(cfg, "Code-Review", REGISTERED_USERS, "refs/heads/*");
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNull();
}
#method_after
@Test
public void maxPermittedValueBlocked() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.blockLabel(cfg, "Code-Review", REGISTERED_USERS, "refs/heads/*");
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNull();
}
#end_block

#method_before
@Sandboxed
@Test
public void unresolvedCommentsBlocked() throws Exception {
    RevCommit oldHead = getRemoteHead();
    GitUtil.fetch(testRepo, RefNames.REFS_CONFIG + ":config");
    testRepo.reset("config");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "Configure", "rules.pl", "submit_rule(submit(R)) :- \n" + "gerrit:unresolved_comments_count(0), \n" + "!," + "gerrit:commit_author(A), \n" + "R = label('All-Comments-Resolved', ok(A)).\n" + "submit_rule(submit(R)) :- \n" + "gerrit:unresolved_comments_count(U), \n" + "U > 0," + "R = label('All-Comments-Resolved', need(_)). \n\n");
    push.to(RefNames.REFS_CONFIG);
    testRepo.reset(oldHead);
    oldHead = getRemoteHead();
    PushOneCommit.Result result1 = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    testRepo.reset(oldHead);
    PushOneCommit.Result result2 = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    addComment(result1, "comment 1", true, false, null);
    addComment(result2, "comment 2", true, true, null);
    gApi.changes().id(result1.getChangeId()).current().submit();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Failed to submit 1 change due to the following problems:\n" + "Change 2: needs All-Comments-Resolved");
    gApi.changes().id(result2.getChangeId()).current().submit();
}
#method_after
@Test
public void unresolvedCommentsBlocked() throws Exception {
    modifySubmitRules("submit_rule(submit(R)) :- \n" + "gerrit:unresolved_comments_count(0), \n" + "!," + "gerrit:commit_author(A), \n" + "R = label('All-Comments-Resolved', ok(A)).\n" + "submit_rule(submit(R)) :- \n" + "gerrit:unresolved_comments_count(U), \n" + "U > 0," + "R = label('All-Comments-Resolved', need(_)). \n\n");
    String oldHead = getRemoteHead().name();
    PushOneCommit.Result result1 = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    testRepo.reset(oldHead);
    PushOneCommit.Result result2 = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    addComment(result1, "comment 1", true, false, null);
    addComment(result2, "comment 2", true, true, null);
    gApi.changes().id(result1.getChangeId()).current().submit();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Failed to submit 1 change due to the following problems");
    exception.expectMessage("needs All-Comments-Resolved");
    gApi.changes().id(result2.getChangeId()).current().submit();
}
#end_block

#method_before
public void submittableAfterLosingPermissions(String label) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID registered = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(label), -1, +1, registered, "refs/heads/*");
    Util.allow(cfg, Permission.forLabel("Code-Review"), -2, +2, registered, "refs/heads/*");
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    assertThat(gApi.changes().id(changeId).get().submittable).isFalse();
    setApiUser(user);
    ReviewInput input = new ReviewInput();
    input.label("Code-Review", 2);
    input.label(label, 1);
    gApi.changes().id(changeId).current().review(input);
    assertThat(gApi.changes().id(changeId).get().submittable).isTrue();
    // Remove user's permission for 'Label'.
    Util.remove(cfg, Permission.forLabel(label), registered, "refs/heads/*");
    // Update user's permitted range for 'Code-Review' to be -1...+1.
    Util.remove(cfg, Permission.forLabel("Code-Review"), registered, "refs/heads/*");
    Util.allow(cfg, Permission.forLabel("Code-Review"), -1, +1, registered, "refs/heads/*");
    saveProjectConfig(project, cfg);
    assertThat(gApi.changes().id(changeId).get().submittable).isTrue();
    setApiUser(admin);
    gApi.changes().id(changeId).current().submit();
}
#method_after
public void submittableAfterLosingPermissions(String label) throws Exception {
    String codeReviewLabel = "Code-Review";
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID registered = SystemGroupBackend.REGISTERED_USERS;
    Util.allow(cfg, Permission.forLabel(label), -1, +1, registered, "refs/heads/*");
    Util.allow(cfg, Permission.forLabel(codeReviewLabel), -2, +2, registered, "refs/heads/*");
    saveProjectConfig(cfg);
    setApiUser(user);
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    // Verify user's permitted range.
    ChangeInfo change = gApi.changes().id(changeId).get();
    assertPermitted(change, label, -1, 0, 1);
    assertPermitted(change, codeReviewLabel, -2, -1, 0, 1, 2);
    ReviewInput input = new ReviewInput();
    input.label(codeReviewLabel, 2);
    input.label(label, 1);
    gApi.changes().id(changeId).current().review(input);
    assertThat(gApi.changes().id(changeId).current().reviewer(user.email).votes().keySet()).containsExactly(codeReviewLabel, label);
    assertThat(gApi.changes().id(changeId).current().reviewer(user.email).votes().values()).containsExactly((short) 2, (short) 1);
    assertThat(gApi.changes().id(changeId).get().submittable).isTrue();
    setApiUser(admin);
    // Remove user's permission for 'Label'.
    Util.remove(cfg, Permission.forLabel(label), registered, "refs/heads/*");
    // Update user's permitted range for 'Code-Review' to be -1...+1.
    Util.remove(cfg, Permission.forLabel(codeReviewLabel), registered, "refs/heads/*");
    Util.allow(cfg, Permission.forLabel(codeReviewLabel), -1, +1, registered, "refs/heads/*");
    saveProjectConfig(cfg);
    // Verify user's new permitted range.
    setApiUser(user);
    change = gApi.changes().id(changeId).get();
    assertPermitted(change, label);
    assertPermitted(change, codeReviewLabel, -1, 0, 1);
    assertThat(gApi.changes().id(changeId).current().reviewer(user.email).votes().values()).containsExactly((short) 2, (short) 1);
    assertThat(gApi.changes().id(changeId).get().submittable).isTrue();
    setApiUser(admin);
    gApi.changes().id(changeId).current().submit();
}
#end_block

#method_before
private ChangeResource parseResource(PushOneCommit.Result r) throws Exception {
    List<ChangeControl> ctls = changeFinder.find(r.getChangeId(), atrScope.get().getUser());
    assertThat(ctls).hasSize(1);
    return changeResourceFactory.create(ctls.get(0));
}
#method_after
private ChangeResource parseResource(PushOneCommit.Result r) throws Exception {
    return parseChangeResource(r.getChangeId());
}
#end_block

#method_before
private Optional<ReviewerState> getReviewerState(String changeId, Account.Id accountId) throws Exception {
    ChangeInfo c = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    Set<ReviewerState> states = c.reviewers.entrySet().stream().filter(e -> e.getValue().stream().anyMatch(a -> a._accountId == accountId.get())).map(e -> e.getKey()).collect(toSet());
    assertThat(states.size()).named(states.toString()).isAtMost(1);
    return states.stream().findFirst();
}
#method_after
private Optional<ReviewerState> getReviewerState(String changeId, Account.Id accountId) throws Exception {
    ChangeInfo c = gApi.changes().id(changeId).get(DETAILED_LABELS);
    Set<ReviewerState> states = c.reviewers.entrySet().stream().filter(e -> e.getValue().stream().anyMatch(a -> a._accountId == accountId.get())).map(e -> e.getKey()).collect(toSet());
    assertThat(states.size()).named(states.toString()).isAtMost(1);
    return states.stream().findFirst();
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (testRequiresSsh && SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
        // Create Ssh sessions
        initSsh(admin);
        Context ctx = newRequestContext(user);
        atrScope.set(ctx);
        userSshSession = ctx.getSession();
        userSshSession.open();
        ctx = newRequestContext(admin);
        atrScope.set(ctx);
        adminSshSession = ctx.getSession();
        adminSshSession.open();
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    db = reviewDbProvider.open();
    // All groups which were added during the server start (e.g. in SchemaCreator) aren't contained
    // in the instance of the group index which is available here and in tests. There are two
    // reasons:
    // 1) No group index is available in SchemaCreator when using an in-memory database. (This could
    // be fixed by using the IndexManagerOnInit in InMemoryDatabase similar as BaseInit uses it.)
    // 2) During the on-init part of the server start, we use another instance of the index than
    // later on. As test indexes are non-permanent, closing an instance and opening another one
    // removes all indexed data.
    // As a workaround, we simply reindex all available groups here.
    Iterable<AccountGroup> allGroups = groups.getAll(db)::iterator;
    for (AccountGroup group : allGroups) {
        groupCache.evict(group.getGroupUUID(), group.getId(), group.getNameKey());
    }
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (testRequiresSsh && SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
        // Create Ssh sessions
        initSsh(admin);
        Context ctx = newRequestContext(user);
        atrScope.set(ctx);
        userSshSession = ctx.getSession();
        userSshSession.open();
        ctx = newRequestContext(admin);
        atrScope.set(ctx);
        adminSshSession = ctx.getSession();
        adminSshSession.open();
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
protected ChangeInfo get(String id, ListChangesOption... options) throws RestApiException {
    return gApi.changes().id(id).get(Sets.newEnumSet(Arrays.asList(options), ListChangesOption.class));
}
#method_after
protected ChangeInfo get(String id, ListChangesOption... options) throws RestApiException {
    return gApi.changes().id(id).get(options);
}
#end_block

#method_before
protected void grant(Project.NameKey project, String ref, String permission, boolean force) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
    grant(project, ref, permission, force, adminGroup.getGroupUUID());
}
#method_after
protected void grant(Project.NameKey project, String ref, String permission, boolean force) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    InternalGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null);
    grant(project, ref, permission, force, adminGroup.getGroupUUID());
}
#end_block

#method_before
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether();
    SubmittedTogetherInfo info = gApi.changes().id(chId).submittedTogether(EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.nonVisibleChanges).isEqualTo(0);
    assertThat(actual).hasSize(expected.length);
    assertThat(changeIds(actual)).containsExactly((Object[]) expected).inOrder();
    assertThat(changeIds(info.changes)).containsExactly((Object[]) expected).inOrder();
}
#method_after
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether();
    SubmittedTogetherInfo info = gApi.changes().id(chId).submittedTogether(EnumSet.of(NON_VISIBLE_CHANGES));
    assertThat(info.nonVisibleChanges).isEqualTo(0);
    assertThat(changeIds(actual)).containsExactly((Object[]) expected).inOrder();
    assertThat(changeIds(info.changes)).containsExactly((Object[]) expected).inOrder();
}
#end_block

#method_before
protected ChangeResource parseChangeResource(String changeId) throws Exception {
    List<ChangeControl> ctls = changeFinder.find(changeId, atrScope.get().getUser());
    assertThat(ctls).hasSize(1);
    return changeResourceFactory.create(ctls.get(0));
}
#method_after
protected ChangeResource parseChangeResource(String changeId) throws Exception {
    List<ChangeNotes> notes = changeFinder.find(changeId);
    assertThat(notes).hasSize(1);
    return changeResourceFactory.create(notes.get(0), atrScope.get().getUser());
}
#end_block

#method_before
protected ContributorAgreement configureContributorAgreement(boolean autoVerify) throws Exception {
    ContributorAgreement ca;
    if (autoVerify) {
        String g = createGroup("cla-test-group");
        GroupApi groupApi = gApi.groups().id(g);
        groupApi.description("CLA test group");
        AccountGroup caGroup = groupCache.get(new AccountGroup.UUID(groupApi.detail().id));
        GroupReference groupRef = GroupReference.forGroup(caGroup);
        PermissionRule rule = new PermissionRule(groupRef);
        rule.setAction(PermissionRule.Action.ALLOW);
        ca = new ContributorAgreement("cla-test");
        ca.setAutoVerify(groupRef);
        ca.setAccepted(ImmutableList.of(rule));
    } else {
        ca = new ContributorAgreement("cla-test-no-auto-verify");
    }
    ca.setDescription("description");
    ca.setAgreementUrl("agreement-url");
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    cfg.replace(ca);
    saveProjectConfig(allProjects, cfg);
    return ca;
}
#method_after
protected ContributorAgreement configureContributorAgreement(boolean autoVerify) throws Exception {
    ContributorAgreement ca;
    if (autoVerify) {
        String g = createGroup("cla-test-group");
        GroupApi groupApi = gApi.groups().id(g);
        groupApi.description("CLA test group");
        InternalGroup caGroup = groupCache.get(new AccountGroup.UUID(groupApi.detail().id)).orElse(null);
        GroupReference groupRef = new GroupReference(caGroup.getGroupUUID(), caGroup.getName());
        PermissionRule rule = new PermissionRule(groupRef);
        rule.setAction(PermissionRule.Action.ALLOW);
        ca = new ContributorAgreement("cla-test");
        ca.setAutoVerify(groupRef);
        ca.setAccepted(ImmutableList.of(rule));
    } else {
        ca = new ContributorAgreement("cla-test-no-auto-verify");
    }
    ca.setDescription("description");
    ca.setAgreementUrl("agreement-url");
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    cfg.replace(ca);
    saveProjectConfig(allProjects, cfg);
    return ca;
}
#end_block

#method_before
@Override
protected ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, MoveInput input) throws RestApiException, OrmException, UpdateException, PermissionBackendException {
    Change change = rsrc.getChange();
    Project.NameKey project = rsrc.getProject();
    IdentifiedUser caller = rsrc.getUser();
    input.destinationBranch = RefNames.fullName(input.destinationBranch);
    if (change.getStatus().isClosed()) {
        throw new ResourceConflictException("Change is " + ChangeUtil.status(change));
    }
    Branch.NameKey newDest = new Branch.NameKey(project, input.destinationBranch);
    if (change.getDest().equals(newDest)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    // Move requires abandoning this change, and creating a new change.
    try {
        rsrc.permissions().database(dbProvider).check(ChangePermission.ABANDON);
        permissionBackend.user(caller).database(dbProvider).ref(newDest).check(RefPermission.CREATE_CHANGE);
    } catch (AuthException denied) {
        throw new AuthException("move not permitted", denied);
    }
    try (BatchUpdate u = updateFactory.create(dbProvider.get(), project, caller, TimeUtil.nowTs())) {
        u.addOp(change.getId(), new Op(input));
        u.execute();
    }
    return json.noOptions().format(project, rsrc.getId());
}
#method_after
@Override
protected ChangeInfo applyImpl(BatchUpdate.Factory updateFactory, ChangeResource rsrc, MoveInput input) throws RestApiException, OrmException, UpdateException, PermissionBackendException {
    Change change = rsrc.getChange();
    Project.NameKey project = rsrc.getProject();
    IdentifiedUser caller = rsrc.getUser().asIdentifiedUser();
    input.destinationBranch = RefNames.fullName(input.destinationBranch);
    if (change.getStatus().isClosed()) {
        throw new ResourceConflictException("Change is " + ChangeUtil.status(change));
    }
    Branch.NameKey newDest = new Branch.NameKey(project, input.destinationBranch);
    if (change.getDest().equals(newDest)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    // Move requires abandoning this change, and creating a new change.
    try {
        rsrc.permissions().database(dbProvider).check(ABANDON);
        permissionBackend.user(caller).database(dbProvider).ref(newDest).check(CREATE_CHANGE);
    } catch (AuthException denied) {
        throw new AuthException("move not permitted", denied);
    }
    try (BatchUpdate u = updateFactory.create(dbProvider.get(), project, caller, TimeUtil.nowTs())) {
        u.addOp(change.getId(), new Op(input));
        u.execute();
    }
    return json.noOptions().format(project, rsrc.getId());
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, RepositoryNotFoundException, IOException {
    change = ctx.getChange();
    if (change.getStatus() != Status.NEW && change.getStatus() != Status.DRAFT) {
        throw new ResourceConflictException("Change is " + ChangeUtil.status(change));
    }
    Project.NameKey projectKey = change.getProject();
    newDestKey = new Branch.NameKey(projectKey, input.destinationBranch);
    Branch.NameKey changePrevDest = change.getDest();
    if (changePrevDest.equals(newDestKey)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    try (Repository repo = repoManager.openRepository(projectKey);
        RevWalk revWalk = new RevWalk(repo)) {
        RevCommit currPatchsetRevCommit = revWalk.parseCommit(ObjectId.fromString(psUtil.current(ctx.getDb(), ctx.getNotes()).getRevision().get()));
        if (currPatchsetRevCommit.getParentCount() > 1) {
            throw new ResourceConflictException("Merge commit cannot be moved");
        }
        ObjectId refId = repo.resolve(input.destinationBranch);
        // Check if destination ref exists in project repo
        if (refId == null) {
            throw new ResourceConflictException("Destination " + input.destinationBranch + " not found in the project");
        }
        RevCommit refCommit = revWalk.parseCommit(refId);
        if (revWalk.isMergedInto(currPatchsetRevCommit, refCommit)) {
            throw new ResourceConflictException("Current patchset revision is reachable from tip of " + input.destinationBranch);
        }
    }
    Change.Key changeKey = change.getKey();
    if (!asChanges(queryProvider.get().byBranchKey(newDestKey, changeKey)).isEmpty()) {
        throw new ResourceConflictException("Destination " + newDestKey.getShortName() + " has a different change with same change key " + changeKey);
    }
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new ResourceConflictException("Patch set is not current");
    }
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    update.setBranch(newDestKey.get());
    change.setDest(newDestKey);
    List<PatchSetApproval> approvals = new ArrayList<>();
    for (Map.Entry<PatchSet.Id, PatchSetApproval> entry : approvalsUtil.byChange(ctx.getDb(), ctx.getNotes()).entries()) {
        // remove votes from NoteDb.
        update.removeApprovalFor(entry.getValue().getAccountId(), entry.getValue().getLabel());
        approvals.add(new PatchSetApproval(new PatchSetApproval.Key(entry.getKey(), entry.getValue().getAccountId(), new LabelId(entry.getValue().getLabel())), (short) 0, ctx.getWhen()));
    }
    // Remove all votes from reviewDb.
    ctx.getDb().patchSetApprovals().upsert(approvals);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change destination moved from ");
    msgBuf.append(changePrevDest.getShortName());
    msgBuf.append(" to ");
    msgBuf.append(newDestKey.getShortName());
    if (!Strings.isNullOrEmpty(input.message)) {
        msgBuf.append("\n\n");
        msgBuf.append(input.message);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msgBuf.toString(), ChangeMessagesUtil.TAG_MOVE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, IOException {
    change = ctx.getChange();
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("Change is " + ChangeUtil.status(change));
    }
    Project.NameKey projectKey = change.getProject();
    newDestKey = new Branch.NameKey(projectKey, input.destinationBranch);
    Branch.NameKey changePrevDest = change.getDest();
    if (changePrevDest.equals(newDestKey)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    try (Repository repo = repoManager.openRepository(projectKey);
        RevWalk revWalk = new RevWalk(repo)) {
        RevCommit currPatchsetRevCommit = revWalk.parseCommit(ObjectId.fromString(psUtil.current(ctx.getDb(), ctx.getNotes()).getRevision().get()));
        if (currPatchsetRevCommit.getParentCount() > 1) {
            throw new ResourceConflictException("Merge commit cannot be moved");
        }
        ObjectId refId = repo.resolve(input.destinationBranch);
        // Check if destination ref exists in project repo
        if (refId == null) {
            throw new ResourceConflictException("Destination " + input.destinationBranch + " not found in the project");
        }
        RevCommit refCommit = revWalk.parseCommit(refId);
        if (revWalk.isMergedInto(currPatchsetRevCommit, refCommit)) {
            throw new ResourceConflictException("Current patchset revision is reachable from tip of " + input.destinationBranch);
        }
    }
    Change.Key changeKey = change.getKey();
    if (!asChanges(queryProvider.get().byBranchKey(newDestKey, changeKey)).isEmpty()) {
        throw new ResourceConflictException("Destination " + newDestKey.getShortName() + " has a different change with same change key " + changeKey);
    }
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new ResourceConflictException("Patch set is not current");
    }
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setBranch(newDestKey.get());
    change.setDest(newDestKey);
    updateApprovals(ctx, update, psId, projectKey);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change destination moved from ");
    msgBuf.append(changePrevDest.getShortName());
    msgBuf.append(" to ");
    msgBuf.append(newDestKey.getShortName());
    if (!Strings.isNullOrEmpty(input.message)) {
        msgBuf.append("\n\n");
        msgBuf.append(input.message);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msgBuf.toString(), ChangeMessagesUtil.TAG_MOVE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#end_block

#method_before
@Override
public Optional<InternalGroup> load(AccountGroup.Id key) throws Exception {
    if (groupIndexProvider.get() != null) {
        return groupQueryProvider.get().byId(key);
    }
    try (ReviewDb db = schema.open()) {
        return groups.getGroup(db, key);
    }
}
#method_after
@Override
public Optional<InternalGroup> load(AccountGroup.Id key) throws Exception {
    if (hasGroupIndex) {
        return groupQueryProvider.get().byId(key);
    }
    try (ReviewDb db = schema.open()) {
        return groups.getGroup(db, key);
    }
}
#end_block

#method_before
@Override
public void onEvent(Event event) {
    if (!(event instanceof ProjectEvent)) {
        return;
    }
    ProjectEvent projectEvent = (ProjectEvent) event;
    Config cfg;
    try {
        cfg = configFactory.getProjectPluginConfigWithInheritance(projectEvent.getProjectNameKey(), pluginName);
    } catch (NoSuchProjectException e) {
        log.warn("Ignoring event for a non-existing project {}, {}", projectEvent.getProjectNameKey().get(), projectEvent);
        return;
    }
    for (String name : cfg.getSubsections(SECTION)) {
        String url = cfg.getString(SECTION, name, "url");
        if (Strings.isNullOrEmpty(url)) {
            log.warn("remote.{}.url not defined, skipping this remote", name);
            continue;
        }
        Optional<EventProcessor.Factory> factory = provider.getFactory(cfg, name);
        if (!factory.isPresent()) {
            log.warn("remote.{}.type not recognized, skipping this remote", name);
            continue;
        }
        EventProcessor processor = factory.get().create(projectEvent);
        if (processor.shouldPost(cfg.getStringList(SECTION, name, "event"))) {
            post(url, processor);
        }
    }
}
#method_after
@Override
public void onEvent(Event event) {
    if (!(event instanceof ProjectEvent)) {
        return;
    }
    ProjectEvent projectEvent = (ProjectEvent) event;
    Config cfg;
    try {
        cfg = configFactory.getProjectPluginConfigWithInheritance(projectEvent.getProjectNameKey(), pluginName);
    } catch (NoSuchProjectException e) {
        log.warn("Ignoring event for a non-existing project {}, {}", projectEvent.getProjectNameKey().get(), projectEvent);
        return;
    }
    for (String name : cfg.getSubsections(REMOTE)) {
        RemoteConfig remote = remoteFactory.create(cfg, name);
        if (Strings.isNullOrEmpty(remote.getUrl())) {
            log.warn("remote.{}.url not defined, skipping this remote", name);
            continue;
        }
        taskFactory.create(projectEvent, remote).schedule();
    }
}
#end_block

#method_before
@Before
public void setup() throws NoSuchProjectException {
    when(configFactory.getProjectPluginConfigWithInheritance(PROJECT_NAME, PLUGIN)).thenReturn(config);
    when(provider.getFactory(eq(config), eq(FOO))).thenReturn(Optional.of(factory));
    when(factory.create(any(ProjectEvent.class))).thenReturn(processor);
    when(taskFactory.create(anyString(), eq(processor))).thenReturn(postTask);
    eventHandler = new EventHandler(configFactory, PLUGIN, taskFactory, provider);
}
#method_after
@Before
public void setup() throws NoSuchProjectException {
    when(projectCreated.getProjectNameKey()).thenReturn(PROJECT_NAME);
    when(configFactory.getProjectPluginConfigWithInheritance(PROJECT_NAME, PLUGIN)).thenReturn(config);
    when(remoteFactory.create(eq(config), eq(FOO))).thenReturn(remote);
    when(taskFactory.create(eq(projectCreated), eq(remote))).thenReturn(postTask);
    eventHandler = new EventHandler(configFactory, PLUGIN, remoteFactory, taskFactory);
}
#end_block

#method_before
@Before
public void setup() {
    when(cfg.getRetryInterval()).thenReturn(RETRY_INTERVAL);
    when(cfg.getMaxTries()).thenReturn(MAX_TRIES);
    when(processor.process()).thenReturn(BODY);
    task = new PostTask(executor, session, cfg, WEBHOOK_URL, processor);
}
#method_after
@Before
public void setup() {
    when(cfg.getRetryInterval()).thenReturn(RETRY_INTERVAL);
    when(cfg.getMaxTries()).thenReturn(MAX_TRIES);
    when(remote.getUrl()).thenReturn(WEBHOOK_URL);
    when(processor.process(eq(projectCreated), eq(remote))).thenReturn(BODY);
    task = new PostTask(executor, session, cfg, processor, projectCreated, remote);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ScheduledExecutorService.class).annotatedWith(WebHooksExecutor.class).toProvider(ExecutorProvider.class);
    bind(Configuration.class).in(Scopes.SINGLETON);
    bind(CloseableHttpClient.class).toProvider(HttpClientProvider.class).in(Scopes.SINGLETON);
    factory(PostTask.Factory.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventHandler.class);
    DynamicSet.setOf(binder(), EventProcessor.Factory.class);
    DynamicSet.bind(binder(), EventProcessor.Factory.class).to(JenkinsEventProcessor.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ScheduledExecutorService.class).annotatedWith(WebHooksExecutor.class).toProvider(ExecutorProvider.class);
    bind(CloseableHttpClient.class).toProvider(HttpClientProvider.class).in(Scopes.SINGLETON);
    factory(PostTask.Factory.class);
    factory(RemoteConfig.Factory.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventHandler.class);
    install(processors);
}
#end_block

#method_before
@Inject()
void set(AccountIndexCollection accountIndexCollection) {
    this.accountIndexCollection = accountIndexCollection;
}
#method_after
@Inject
void set(AccountIndexCollection accountIndexCollection) {
    this.accountIndexCollection = accountIndexCollection;
}
#end_block

#method_before
@Inject()
void set(GroupIndexCollection groupIndexCollection) {
    this.groupIndexCollection = groupIndexCollection;
}
#method_after
@Inject
void set(GroupIndexCollection groupIndexCollection) {
    this.groupIndexCollection = groupIndexCollection;
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    Connection connection = ((JdbcSchema) db).getConnection();
    try (PreparedStatement uuidRetrieval = connection.prepareStatement("SELECT group_uuid FROM account_groups WHERE group_id = ?");
        PreparedStatement groupDeletion = connection.prepareStatement("DELETE account_groups WHERE group_id = ?");
        PreparedStatement groupNameDeletion = connection.prepareStatement("DELETE account_group_names WHERE group_id = ?")) {
        for (AccountGroup.Id id : scanSystemGroups(db)) {
            Optional<AccountGroup.UUID> groupUuid = getUuid(uuidRetrieval, id);
            if (groupUuid.filter(SystemGroupBackend::isSystemGroup).isPresent()) {
                groupDeletion.setInt(1, id.get());
                groupDeletion.executeUpdate();
                groupNameDeletion.setInt(1, id.get());
                groupNameDeletion.executeUpdate();
            }
        }
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    try (PreparedStatement uuidRetrieval = prepareStatement(db, "SELECT group_uuid FROM account_groups WHERE group_id = ?");
        PreparedStatement groupDeletion = prepareStatement(db, "DELETE FROM account_groups WHERE group_id = ?");
        PreparedStatement groupNameDeletion = prepareStatement(db, "DELETE FROM account_group_names WHERE group_id = ?")) {
        for (AccountGroup.Id id : scanSystemGroups(db)) {
            Optional<AccountGroup.UUID> groupUuid = getUuid(uuidRetrieval, id);
            if (groupUuid.filter(SystemGroupBackend::isSystemGroup).isPresent()) {
                groupDeletion.setInt(1, id.get());
                groupDeletion.executeUpdate();
                groupNameDeletion.setInt(1, id.get());
                groupNameDeletion.executeUpdate();
            }
        }
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    Connection connection = ((JdbcSchema) db).getConnection();
    try (PreparedStatement groupUpdate = connection.prepareStatement("UPDATE account_groups SET created_on = ? WHERE group_id = ?");
        PreparedStatement addedOnRetrieval = connection.prepareStatement("SELECT added_on FROM account_group_members_audit WHERE group_id = ?" + " ORDER BY added_on ASC")) {
        List<AccountGroup.Id> accountGroups = getAllGroupIds(db);
        for (AccountGroup.Id groupId : accountGroups) {
            Optional<Timestamp> firstTimeMentioned = getFirstTimeMentioned(addedOnRetrieval, groupId);
            Timestamp createdOn = firstTimeMentioned.orElseGet(AccountGroup::auditCreationInstantTs);
            groupUpdate.setTimestamp(1, createdOn);
            groupUpdate.setInt(2, groupId.get());
            groupUpdate.executeUpdate();
        }
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    try (PreparedStatement groupUpdate = prepareStatement(db, "UPDATE account_groups SET created_on = ? WHERE group_id = ?");
        PreparedStatement addedOnRetrieval = prepareStatement(db, "SELECT added_on FROM account_group_members_audit WHERE group_id = ?" + " ORDER BY added_on ASC")) {
        List<AccountGroup.Id> accountGroups = getAllGroupIds(db);
        for (AccountGroup.Id groupId : accountGroups) {
            Optional<Timestamp> firstTimeMentioned = getFirstTimeMentioned(addedOnRetrieval, groupId);
            Timestamp createdOn = firstTimeMentioned.orElseGet(AccountGroup::auditCreationInstantTs);
            groupUpdate.setTimestamp(1, createdOn);
            groupUpdate.setInt(2, groupId.get());
            groupUpdate.executeUpdate();
        }
    }
}
#end_block

#method_before
private static ObjectId getBranchId(Repository repo, String branch, ChangeData changeData) {
    try {
        ObjectId id = repo.resolve(branch);
        if (id == null && changeData != null && !Checker.isExemptFromOwnerApproval(changeData)) {
            log.error("cannot find branch " + branch);
        }
        return id;
    } catch (Exception e) {
        log.error("cannot find branch " + branch, e);
    }
    return null;
}
#method_after
private static ObjectId getBranchId(Repository repo, String branch, ChangeData changeData) {
    try {
        ObjectId id = repo.resolve(branch);
        if (id == null && changeData != null && !Checker.isExemptFromOwnerApproval(changeData)) {
            log.error("cannot find branch " + branch + " for " + Config.getChangeId(changeData));
        }
        return id;
    } catch (Exception e) {
        log.error("cannot find branch " + branch + " for " + Config.getChangeId(changeData), e);
    }
    return null;
}
#end_block

#method_before
static String getOwnersFileName(Project.NameKey project, Change.Id id) {
    if (config != null && project != null) {
        try {
            String name = config.getFromProjectConfigWithInheritance(project, PLUGIN_NAME).getString(OWNERS_FILE_NAME, OWNERS);
            if (name.trim().equals("")) {
                log.error("Project " + project.get() + " has wrong " + OWNERS_FILE_NAME + ": \"" + name + "\"");
                return OWNERS;
            }
            return name;
        } catch (NoSuchProjectException e) {
            log.error(String.format("Cannot find project %s for change %s", project, id.get()), e);
        }
    }
    return OWNERS;
}
#method_after
static String getOwnersFileName(Project.NameKey project, ChangeData c) {
    if (config != null && project != null) {
        try {
            String name = config.getFromProjectConfigWithInheritance(project, PLUGIN_NAME).getString(OWNERS_FILE_NAME, OWNERS);
            if (name.trim().equals("")) {
                log.error("Project " + project + " has wrong " + OWNERS_FILE_NAME + ": \"" + name + "\" for " + getChangeId(c));
                return OWNERS;
            }
            return name;
        } catch (NoSuchProjectException e) {
            log.error("Cannot find project " + project + " for " + getChangeId(c), e);
        }
    }
    return OWNERS;
}
#end_block

#method_before
static int getMinOwnerVoteLevel(ChangeData changeData) throws OrmException {
    Project.NameKey project = changeData.change().getProject();
    try {
        return (config == null || project == null) ? minOwnerVoteLevel : config.getFromProjectConfigWithInheritance(project, PLUGIN_NAME).getInt(MIN_OWNER_VOTE_LEVEL, minOwnerVoteLevel);
    } catch (NoSuchProjectException e) {
        log.error("Cannot find project: " + project, e);
        return minOwnerVoteLevel;
    }
}
#method_after
static int getMinOwnerVoteLevel(ChangeData changeData) throws OrmException {
    Project.NameKey project = changeData.change().getProject();
    try {
        return (config == null || project == null) ? minOwnerVoteLevel : config.getFromProjectConfigWithInheritance(project, PLUGIN_NAME).getInt(MIN_OWNER_VOTE_LEVEL, minOwnerVoteLevel);
    } catch (NoSuchProjectException e) {
        log.error("Cannot find project " + project + " for " + getChangeId(changeData), e);
        return minOwnerVoteLevel;
    }
}
#end_block

#method_before
private void updateSubmodules(Repository repo, String targetRef, URI targetURI, JiriProjects projects, GerritRemoteReader reader) throws IOException, GitAPIException {
    DirCache index = DirCache.newInCore();
    DirCacheBuilder builder = index.builder();
    ObjectInserter inserter = repo.newObjectInserter();
    try (RevWalk rw = new RevWalk(repo)) {
        Config cfg = new Config();
        projects.sortByPath();
        String parent = null;
        for (JiriProjects.Project proj : projects.getProjects()) {
            String path = proj.getPath();
            String nameUri = proj.getRemote();
            if (parent != null) {
                String p1 = StringUtil.stripAndAddCharsAtEnd(path, "/");
                String p2 = StringUtil.stripAndAddCharsAtEnd(parent, "/");
                if (p1.startsWith(p2)) {
                    warn("Skipping project %s(%s) as git doesn't support nested submodules", proj.getName(), path);
                    continue;
                }
            }
            ObjectId objectId;
            String ref = proj.getRef();
            if (ObjectId.isId(ref)) {
                objectId = ObjectId.fromString(ref);
            } else {
                objectId = reader.sha1(nameUri, ref);
                if (objectId == null) {
                    warn("failed to get ref '%s' for '%s', skipping", ref, nameUri);
                    continue;
                }
            }
            // can be branch or tag
            cfg.setString("submodule", path, "branch", ref);
            if (proj.getHistorydepth() > 0) {
                cfg.setBoolean("submodule", path, "shallow", true);
                if (proj.getHistorydepth() != 1) {
                    warn("Project %s(%s) has historydepth other than 1. Submodule only support shallow of depth 1.", proj.getName(), proj.getPath());
                }
            }
            URI submodUrl = URI.create(nameUri);
            // check if repo exists locally then relativize its URL
            try {
                String repoName = submodUrl.getPath();
                while (repoName.startsWith("/")) {
                    repoName = repoName.substring(1);
                }
                reader.openRepository(repoName);
                submodUrl = relativize(targetURI, URI.create(submodUrl.getPath()));
            } catch (RepositoryNotFoundException e) {
            }
            cfg.setString("submodule", path, "path", path);
            cfg.setString("submodule", path, "url", submodUrl.toString());
            // create gitlink
            DirCacheEntry dcEntry = new DirCacheEntry(path);
            dcEntry.setObjectId(objectId);
            dcEntry.setFileMode(FileMode.GITLINK);
            builder.add(dcEntry);
            parent = path;
        }
        String content = cfg.toText();
        // create a new DirCacheEntry for .gitmodules file.
        final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);
        ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));
        dcEntry.setObjectId(objectId);
        dcEntry.setFileMode(FileMode.REGULAR_FILE);
        builder.add(dcEntry);
        builder.finish();
        ObjectId treeId = index.writeTree(inserter);
        // Create a Commit object, populate it and write it
        ObjectId headId = repo.resolve(targetRef + "^{commit}");
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(treeId);
        if (headId != null)
            commit.setParentIds(headId);
        commit.setAuthor(serverIdent);
        commit.setCommitter(serverIdent);
        commit.setMessage(RepoText.get().repoCommitMessage);
        ObjectId commitId = inserter.insert(commit);
        inserter.flush();
        RefUpdate ru = repo.updateRef(targetRef);
        ru.setNewObjectId(commitId);
        ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());
        Result rc = ru.update(rw);
        switch(rc) {
            case NEW:
            case FORCED:
            case FAST_FORWARD:
                // Successful. Do nothing.
                break;
            case REJECTED:
            case LOCK_FAILURE:
                throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetRef), ru.getRef(), rc);
            default:
                throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetRef, commitId.name(), rc));
        }
    }
}
#method_after
private void updateSubmodules(Repository repo, String targetRef, URI targetURI, JiriProjects projects, GerritRemoteReader reader) throws IOException, GitAPIException {
    DirCache index = DirCache.newInCore();
    DirCacheBuilder builder = index.builder();
    ObjectInserter inserter = repo.newObjectInserter();
    try (RevWalk rw = new RevWalk(repo)) {
        Config cfg = new Config();
        projects.sortByPath();
        String parent = null;
        for (JiriProjects.Project proj : projects.getProjects()) {
            String path = proj.getPath();
            String nameUri = proj.getRemote();
            if (parent != null) {
                String p1 = StringUtil.stripAndAddCharsAtEnd(path, "/");
                String p2 = StringUtil.stripAndAddCharsAtEnd(parent, "/");
                if (p1.startsWith(p2)) {
                    warn("Skipping project %s(%s) as git doesn't support nested submodules", proj.getName(), path);
                    continue;
                }
            }
            ObjectId objectId;
            String ref = proj.getRef();
            if (ObjectId.isId(ref)) {
                objectId = ObjectId.fromString(ref);
            } else {
                objectId = reader.sha1(nameUri, ref);
                if (objectId == null) {
                    warn("failed to get ref '%s' for '%s', skipping", ref, nameUri);
                    continue;
                }
            }
            // can be branch or tag
            cfg.setString("submodule", path, "branch", ref);
            if (proj.getHistorydepth() > 0) {
                cfg.setBoolean("submodule", path, "shallow", true);
                if (proj.getHistorydepth() != 1) {
                    warn("Project %s(%s) has historydepth other than 1. Submodule only support shallow of depth 1.", proj.getName(), proj.getPath());
                }
            }
            URI submodUrl = URI.create(nameUri);
            // check if repo exists locally then relativize its URL
            try {
                String repoName = submodUrl.getPath();
                while (repoName.startsWith("/")) {
                    repoName = repoName.substring(1);
                }
                reader.openRepository(repoName);
                submodUrl = relativize(targetURI, URI.create(repoName));
            } catch (RepositoryNotFoundException e) {
            }
            cfg.setString("submodule", path, "path", path);
            cfg.setString("submodule", path, "url", submodUrl.toString());
            // create gitlink
            DirCacheEntry dcEntry = new DirCacheEntry(path);
            dcEntry.setObjectId(objectId);
            dcEntry.setFileMode(FileMode.GITLINK);
            builder.add(dcEntry);
            parent = path;
        }
        String content = cfg.toText();
        // create a new DirCacheEntry for .gitmodules file.
        final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);
        ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));
        dcEntry.setObjectId(objectId);
        dcEntry.setFileMode(FileMode.REGULAR_FILE);
        builder.add(dcEntry);
        builder.finish();
        ObjectId treeId = index.writeTree(inserter);
        // Create a Commit object, populate it and write it
        ObjectId headId = repo.resolve(targetRef + "^{commit}");
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(treeId);
        if (headId != null)
            commit.setParentIds(headId);
        commit.setAuthor(serverIdent);
        commit.setCommitter(serverIdent);
        commit.setMessage(RepoText.get().repoCommitMessage);
        ObjectId commitId = inserter.insert(commit);
        inserter.flush();
        RefUpdate ru = repo.updateRef(targetRef);
        ru.setNewObjectId(commitId);
        ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());
        Result rc = ru.update(rw);
        switch(rc) {
            case NEW:
            case FORCED:
            case FAST_FORWARD:
                // Successful. Do nothing.
                break;
            case REJECTED:
            case LOCK_FAILURE:
                throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetRef), ru.getRef(), rc);
            default:
                throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetRef, commitId.name(), rc));
        }
    }
}
#end_block

#method_before
static URI relativize(URI current, URI target) {
    // We only handle bare paths for now.
    if (!target.toString().equals(target.getPath())) {
        return target;
    }
    if (!current.toString().equals(current.getPath())) {
        return target;
    }
    String cur = current.normalize().getPath();
    String dest = target.normalize().getPath();
    while (cur.startsWith(SLASH)) {
        cur = cur.substring(1);
    }
    while (dest.startsWith(SLASH)) {
        dest = dest.substring(1);
    }
    if (cur.indexOf('/') == -1 || dest.indexOf('/') == -1) {
        // Avoid having to special-casing in the next two ifs.
        String prefix = "prefix/";
        cur = prefix + cur;
        dest = prefix + dest;
    }
    if (!cur.endsWith(SLASH)) {
        // The current file doesn't matter.
        int lastSlash = cur.lastIndexOf('/');
        cur = cur.substring(0, lastSlash);
    }
    String destFile = "";
    if (!dest.endsWith(SLASH)) {
        // We always have to provide the destination file.
        int lastSlash = dest.lastIndexOf('/');
        destFile = dest.substring(lastSlash + 1, dest.length());
        dest = dest.substring(0, dest.lastIndexOf('/'));
    }
    String[] cs = cur.split(SLASH);
    String[] ds = dest.split(SLASH);
    int common = 0;
    while (common < cs.length && common < ds.length && cs[common].equals(ds[common])) {
        common++;
    }
    StringJoiner j = new StringJoiner(SLASH);
    for (int i = common; i < cs.length; i++) {
        j.add("..");
    }
    for (int i = common; i < ds.length; i++) {
        j.add(ds[i]);
    }
    j.add(destFile);
    return URI.create(j.toString());
}
#method_after
static URI relativize(URI current, URI target) {
    // We only handle bare paths for now.
    if (!target.toString().equals(target.getPath())) {
        return target;
    }
    if (!current.toString().equals(current.getPath())) {
        return target;
    }
    String cur = current.normalize().getPath();
    String dest = target.normalize().getPath();
    if (cur.startsWith(SLASH) != dest.startsWith(SLASH)) {
        return target;
    }
    while (cur.startsWith(SLASH)) {
        cur = cur.substring(1);
    }
    while (dest.startsWith(SLASH)) {
        dest = dest.substring(1);
    }
    if (cur.indexOf('/') == -1 || dest.indexOf('/') == -1) {
        // Avoid having to special-casing in the next two ifs.
        String prefix = "prefix/";
        cur = prefix + cur;
        dest = prefix + dest;
    }
    if (!cur.endsWith(SLASH)) {
        // The current file doesn't matter.
        int lastSlash = cur.lastIndexOf('/');
        cur = cur.substring(0, lastSlash);
    }
    String destFile = "";
    if (!dest.endsWith(SLASH)) {
        // We always have to provide the destination file.
        int lastSlash = dest.lastIndexOf('/');
        destFile = dest.substring(lastSlash + 1, dest.length());
        dest = dest.substring(0, dest.lastIndexOf('/'));
    }
    String[] cs = cur.split(SLASH);
    String[] ds = dest.split(SLASH);
    int common = 0;
    while (common < cs.length && common < ds.length && cs[common].equals(ds[common])) {
        common++;
    }
    StringJoiner j = new StringJoiner(SLASH);
    for (int i = common; i < cs.length; i++) {
        j.add("..");
    }
    for (int i = common; i < ds.length; i++) {
        j.add(ds[i]);
    }
    j.add(destFile);
    return URI.create(j.toString());
}
#end_block

#method_before
@Test
public void relativeFetch() throws Exception {
    // Test the setup that Android uses, where the "fetch" field is relative to the location of the
    // manifest repo.
    setupTestRepos("platform/project");
    String realPrefix = testRepoKeys[0].get().split("/")[0];
    Project.NameKey manifestKey = createProject(realPrefix + "/manifest");
    TestRepository<InMemoryRepository> manifestRepo = cloneProject(manifestKey, admin);
    Project.NameKey superKey = createProject("superproject");
    pushConfig("[superproject \"" + superKey.get() + ":refs/heads/destbranch\"]\n" + "  srcRepo = " + manifestKey.get() + "\n" + "  srcRef = refs/heads/srcbranch\n" + "  srcPath = default\n" + "  toolType = jiri\n");
    String url = canonicalWebUrl.get();
    // XML change will trigger commit to superproject.
    String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<manifest>\n<projects>\n" + "<project name=\"" + testRepoKeys[0].get() + "\" remote=\"" + canonicalWebUrl.get() + testRepoKeys[0].get() + "\" path=\"project1\" />\n" + "<project name=\"external\"" + " remote=\"https://external/repo\"" + " revision=\"c438d02cdf08a08fe29550cb11cb6ae8190919f1\"" + " path=\"project2\" />\n" + "</projects>\n</manifest>\n";
    pushFactory.create(db, admin.getIdent(), manifestRepo, "Subject", "default", xml).to("refs/heads/srcbranch").assertOkStatus();
    BranchApi branch = gApi.projects().name(superKey.get()).branch("refs/heads/destbranch");
    assertThat(branch.file("project1").getContentType()).isEqualTo("x-git/gitlink; charset=UTF-8");
    assertThat(branch.file("project2").getContentType()).isEqualTo("x-git/gitlink; charset=UTF-8");
    Config base = new Config();
    BlobBasedConfig cfg = new BlobBasedConfig(base, branch.file(".gitmodules").asString().getBytes(UTF_8));
    String subUrl = cfg.getString("submodule", "project1", "url");
    // URL is valid.
    URI.create(subUrl);
    // The suburl must be interpreted as relative to the parent project as a directory, i.e.
    // to go from superproject/ to platform/project0, you have to do ../platform/project0
    // URL is clean.
    assertThat(subUrl).isEqualTo("../" + realPrefix + "/project0");
    subUrl = cfg.getString("submodule", "project2", "url");
    // URL is valid.
    URI.create(subUrl);
    // The suburl must be absolute as this is external repo
    assertThat(subUrl).isEqualTo("https://external/repo");
}
#method_after
@Test
public void relativeFetch() throws Exception {
    // Test that first party gerrit repos are represented by relative URLs in supermanifest and
    // external repos by their absolute URLs.
    setupTestRepos("platform/project");
    String realPrefix = testRepoKeys[0].get().split("/")[0];
    Project.NameKey manifestKey = createProject(realPrefix + "/manifest");
    TestRepository<InMemoryRepository> manifestRepo = cloneProject(manifestKey, admin);
    Project.NameKey superKey = createProject("superproject");
    pushConfig("[superproject \"" + superKey.get() + ":refs/heads/destbranch\"]\n" + "  srcRepo = " + manifestKey.get() + "\n" + "  srcRef = refs/heads/srcbranch\n" + "  srcPath = default\n" + "  toolType = jiri\n");
    // XML change will trigger commit to superproject.
    String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<manifest>\n<projects>\n" + "<project name=\"" + testRepoKeys[0].get() + "\" remote=\"" + canonicalWebUrl.get() + testRepoKeys[0].get() + "\" path=\"project1\" />\n" + "<project name=\"external\"" + " remote=\"https://external/repo\"" + " revision=\"c438d02cdf08a08fe29550cb11cb6ae8190919f1\"" + " path=\"project2\" />\n" + "</projects>\n</manifest>\n";
    pushFactory.create(db, admin.getIdent(), manifestRepo, "Subject", "default", xml).to("refs/heads/srcbranch").assertOkStatus();
    BranchApi branch = gApi.projects().name(superKey.get()).branch("refs/heads/destbranch");
    assertThat(branch.file("project1").getContentType()).isEqualTo("x-git/gitlink; charset=UTF-8");
    assertThat(branch.file("project2").getContentType()).isEqualTo("x-git/gitlink; charset=UTF-8");
    Config base = new Config();
    BlobBasedConfig cfg = new BlobBasedConfig(base, branch.file(".gitmodules").asString().getBytes(UTF_8));
    String subUrl = cfg.getString("submodule", "project1", "url");
    // URL is valid.
    URI.create(subUrl);
    // The suburl must be interpreted as relative to the parent project as a directory, i.e.
    // to go from superproject/ to platform/project0, you have to do ../platform/project0
    // URL is clean.
    assertThat(subUrl).isEqualTo("../" + realPrefix + "/project0");
    subUrl = cfg.getString("submodule", "project2", "url");
    // URL is valid.
    URI.create(subUrl);
    // The suburl must be absolute as this is external repo
    assertThat(subUrl).isEqualTo("https://external/repo");
}
#end_block

#method_before
@Test
public void listAllGroups() throws Exception {
    List<String> expectedGroups = groupCache.all().stream().map(a -> a.getName()).sorted().collect(toList());
    assertThat(expectedGroups.size()).isAtLeast(2);
    assertThat(gApi.groups().list().getAsMap().keySet()).containsExactlyElementsIn(expectedGroups).inOrder();
}
#method_after
@Test
public void listAllGroups() throws Exception {
    List<String> expectedGroups = groups.getAll(db).map(a -> a.getName()).sorted().collect(toList());
    assertThat(expectedGroups.size()).isAtLeast(2);
    assertThat(gApi.groups().list().getAsMap().keySet()).containsExactlyElementsIn(expectedGroups).inOrder();
}
#end_block

#method_before
@Test
public void getGroupsByOwner() throws Exception {
    String parent = createGroup("test-parent");
    List<String> children = Arrays.asList(createGroup("test-child1", parent), createGroup("test-child2", parent));
    for (String c : children) {
        assertThat(groupCache.get(new AccountGroup.NameKey(c)).isPresent()).isTrue();
        assertThat(gApi.groups().id(c).owner().name).isEqualTo(parent);
    }
    List<GroupInfo> owned = gApi.groups().list().withOwnedBy(getFromCache(parent).getGroupUUID()).get();
    assertThat(owned).hasSize(2);
    assertThat(owned.stream().map(g -> g.name).collect(toList())).containsExactlyElementsIn(children);
}
#method_after
@Test
public void getGroupsByOwner() throws Exception {
    String parent = createGroup("test-parent");
    List<String> children = Arrays.asList(createGroup("test-child1", parent), createGroup("test-child2", parent));
    // By UUID
    List<GroupInfo> owned = gApi.groups().list().withOwnedBy(getFromCache(parent).getGroupUUID().get()).get();
    assertThat(owned.stream().map(g -> g.name).collect(toList())).containsExactlyElementsIn(children);
    // By name
    owned = gApi.groups().list().withOwnedBy(parent).get();
    assertThat(owned.stream().map(g -> g.name).collect(toList())).containsExactlyElementsIn(children);
    // By group that does not own any others
    owned = gApi.groups().list().withOwnedBy(owned.get(0).id).get();
    assertThat(owned).isEmpty();
    // By non-existing group
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage("Group Not Found: does-not-exist");
    gApi.groups().list().withOwnedBy("does-not-exist").get();
}
#end_block

#method_before
private void assertBadRequest(Groups.ListRequest req) throws Exception {
    try {
        req.get();
        fail("Expected BadRequestException");
    } catch (BadRequestException e) {
    // Expected
    }
}
#method_after
private void assertBadRequest(ListRequest req) throws Exception {
    try {
        req.get();
        fail("Expected BadRequestException");
    } catch (BadRequestException e) {
    // Expected
    }
}
#end_block

#method_before
private SortedMap<String, GroupInfo> list(ListRequest req) throws RestApiException {
    TopLevelResource tlr = TopLevelResource.INSTANCE;
    ListGroups list = listGroups.get();
    list.setOptions(req.getOptions());
    for (String project : req.getProjects()) {
        try {
            list.addProject(projects.parse(tlr, IdString.fromDecoded(project)).getControl());
        } catch (Exception e) {
            throw asRestApiException("Error looking up project " + project, e);
        }
    }
    for (String group : req.getGroups()) {
        list.addGroup(groups.parse(group).getGroupUUID());
    }
    list.setVisibleToAll(req.getVisibleToAll());
    if (req.getOwnedBy() != null) {
        list.setOwnedBy(req.getOwnedBy());
    }
    if (req.getUser() != null) {
        try {
            list.setUser(accounts.parse(req.getUser()).getAccountId());
        } catch (Exception e) {
            throw asRestApiException("Error looking up user " + req.getUser(), e);
        }
    }
    list.setOwned(req.getOwned());
    list.setLimit(req.getLimit());
    list.setStart(req.getStart());
    list.setMatchSubstring(req.getSubstring());
    list.setMatchRegex(req.getRegex());
    list.setSuggest(req.getSuggest());
    try {
        return list.apply(tlr);
    } catch (Exception e) {
        throw asRestApiException("Cannot list groups", e);
    }
}
#method_after
private SortedMap<String, GroupInfo> list(ListRequest req) throws RestApiException {
    TopLevelResource tlr = TopLevelResource.INSTANCE;
    ListGroups list = listGroups.get();
    list.setOptions(req.getOptions());
    for (String project : req.getProjects()) {
        try {
            ProjectResource rsrc = projects.parse(tlr, IdString.fromDecoded(project));
            list.addProject(rsrc.getProjectState());
        } catch (Exception e) {
            throw asRestApiException("Error looking up project " + project, e);
        }
    }
    for (String group : req.getGroups()) {
        list.addGroup(groups.parse(group).getGroupUUID());
    }
    list.setVisibleToAll(req.getVisibleToAll());
    if (req.getOwnedBy() != null) {
        list.setOwnedBy(req.getOwnedBy());
    }
    if (req.getUser() != null) {
        try {
            list.setUser(accounts.parse(req.getUser()).getAccountId());
        } catch (Exception e) {
            throw asRestApiException("Error looking up user " + req.getUser(), e);
        }
    }
    list.setOwned(req.getOwned());
    list.setLimit(req.getLimit());
    list.setStart(req.getStart());
    list.setMatchSubstring(req.getSubstring());
    list.setMatchRegex(req.getRegex());
    list.setSuggest(req.getSuggest());
    try {
        return list.apply(tlr);
    } catch (Exception e) {
        throw asRestApiException("Cannot list groups", e);
    }
}
#end_block

#method_before
@Option(name = "--project", aliases = { "-p" }, usage = "projects for which the groups should be listed")
public void addProject(ProjectControl project) {
    projects.add(project);
}
#method_after
@Option(name = "--project", aliases = { "-p" }, usage = "projects for which the groups should be listed")
public void addProject(ProjectState project) {
    projects.add(project);
}
#end_block

#method_before
@Option(name = "--owned-by", usage = "list groups owned by the given group")
public void setOwnedBy(AccountGroup.UUID ownedBy) {
    this.ownedBy = ownedBy;
}
#method_after
@Option(name = "--owned-by", usage = "list groups owned by the given group uuid")
public void setOwnedBy(String ownedBy) {
    this.ownedBy = ownedBy;
}
#end_block

#method_before
public List<ProjectControl> getProjects() {
    return projects;
}
#method_after
public List<ProjectState> getProjects() {
    return projects;
}
#end_block

#method_before
@Override
public SortedMap<String, GroupInfo> apply(TopLevelResource resource) throws OrmException, BadRequestException {
    SortedMap<String, GroupInfo> output = new TreeMap<>();
    for (GroupInfo info : get()) {
        output.put(MoreObjects.firstNonNull(info.name, "Group " + Url.decode(info.id)), info);
        info.name = null;
    }
    return output;
}
#method_after
@Override
public SortedMap<String, GroupInfo> apply(TopLevelResource resource) throws OrmException, RestApiException {
    SortedMap<String, GroupInfo> output = new TreeMap<>();
    for (GroupInfo info : get()) {
        output.put(MoreObjects.firstNonNull(info.name, "Group " + Url.decode(info.id)), info);
        info.name = null;
    }
    return output;
}
#end_block

#method_before
public List<GroupInfo> get() throws OrmException, BadRequestException {
    if (!Strings.isNullOrEmpty(suggest)) {
        return suggestGroups();
    }
    if (!Strings.isNullOrEmpty(matchSubstring) && !Strings.isNullOrEmpty(matchRegex)) {
        throw new BadRequestException("Specify one of m/r");
    }
    if (ownedBy != null) {
        return getGroupsOwnedBy(ownedBy);
    }
    if (owned) {
        return getGroupsOwnedBy(user != null ? userFactory.create(user) : identifiedUser.get());
    }
    if (user != null) {
        return accountGetGroups.apply(new AccountResource(userFactory.create(user)));
    }
    return getAllGroups();
}
#method_after
public List<GroupInfo> get() throws OrmException, RestApiException {
    if (!Strings.isNullOrEmpty(suggest)) {
        return suggestGroups();
    }
    if (!Strings.isNullOrEmpty(matchSubstring) && !Strings.isNullOrEmpty(matchRegex)) {
        throw new BadRequestException("Specify one of m/r");
    }
    if (ownedBy != null) {
        return getGroupsOwnedBy(ownedBy);
    }
    if (owned) {
        return getGroupsOwnedBy(user != null ? userFactory.create(user) : identifiedUser.get());
    }
    if (user != null) {
        return accountGetGroups.apply(new AccountResource(userFactory.create(user)));
    }
    return getAllGroups();
}
#end_block

#method_before
private List<GroupInfo> getAllGroups() throws OrmException {
    List<GroupInfo> groupInfos;
    List<GroupDescription.Internal> groupList;
    if (!projects.isEmpty()) {
        Map<AccountGroup.UUID, GroupDescription.Internal> groups = new HashMap<>();
        for (ProjectControl projectControl : projects) {
            final Set<GroupReference> groupsRefs = projectControl.getAllGroups();
            for (GroupReference groupRef : groupsRefs) {
                Optional<InternalGroup> internalGroup = groupCache.get(groupRef.getUUID());
                internalGroup.ifPresent(group -> groups.put(group.getGroupUUID(), new InternalGroupDescription(group)));
            }
        }
        groupList = filterGroups(groups.values());
    } else {
        groupList = filterGroups(getAllExistingInternalGroups());
    }
    groupInfos = Lists.newArrayListWithCapacity(groupList.size());
    int found = 0;
    int foundIndex = 0;
    for (GroupDescription.Internal group : groupList) {
        if (foundIndex++ < start) {
            continue;
        }
        if (limit > 0 && ++found > limit) {
            break;
        }
        groupInfos.add(json.addOptions(options).format(group));
    }
    return groupInfos;
}
#method_after
private List<GroupInfo> getAllGroups() throws OrmException {
    Pattern pattern = getRegexPattern();
    Stream<GroupDescription.Internal> existingGroups = getAllExistingGroups().filter(group -> !isNotRelevant(pattern, group)).sorted(GROUP_COMPARATOR).skip(start);
    if (limit > 0) {
        existingGroups = existingGroups.limit(limit);
    }
    List<GroupDescription.Internal> relevantGroups = existingGroups.collect(toImmutableList());
    List<GroupInfo> groupInfos = Lists.newArrayListWithCapacity(relevantGroups.size());
    for (GroupDescription.Internal group : relevantGroups) {
        groupInfos.add(json.addOptions(options).format(group));
    }
    return groupInfos;
}
#end_block

#method_before
private List<GroupInfo> suggestGroups() throws OrmException, BadRequestException {
    if (conflictingSuggestParameters()) {
        throw new BadRequestException("You should only have no more than one --project and -n with --suggest");
    }
    List<GroupReference> groupRefs = Lists.newArrayList(Iterables.limit(groupBackend.suggest(suggest, projects.stream().findFirst().map(pc -> pc.getProjectState()).orElse(null)), limit <= 0 ? 10 : Math.min(limit, 10)));
    List<GroupInfo> groupInfos = Lists.newArrayListWithCapacity(groupRefs.size());
    for (GroupReference ref : groupRefs) {
        GroupDescription.Basic desc = groupBackend.get(ref.getUUID());
        if (desc != null) {
            groupInfos.add(json.addOptions(options).format(desc));
        }
    }
    return groupInfos;
}
#method_after
private List<GroupInfo> suggestGroups() throws OrmException, BadRequestException {
    if (conflictingSuggestParameters()) {
        throw new BadRequestException("You should only have no more than one --project and -n with --suggest");
    }
    List<GroupReference> groupRefs = Lists.newArrayList(Iterables.limit(groupBackend.suggest(suggest, projects.stream().findFirst().orElse(null)), limit <= 0 ? 10 : Math.min(limit, 10)));
    List<GroupInfo> groupInfos = Lists.newArrayListWithCapacity(groupRefs.size());
    for (GroupReference ref : groupRefs) {
        GroupDescription.Basic desc = groupBackend.get(ref.getUUID());
        if (desc != null) {
            groupInfos.add(json.addOptions(options).format(desc));
        }
    }
    return groupInfos;
}
#end_block

#method_before
private boolean conflictingSuggestParameters() {
    if (Strings.isNullOrEmpty(suggest)) {
        return false;
    }
    if (projects.size() > 1) {
        return true;
    }
    if (visibleToAll) {
        return true;
    }
    if (user != null) {
        return true;
    }
    if (owned) {
        return true;
    }
    if (start != 0) {
        return true;
    }
    if (!groupsToInspect.isEmpty()) {
        return true;
    }
    if (!Strings.isNullOrEmpty(matchSubstring)) {
        return true;
    }
    if (!Strings.isNullOrEmpty(matchRegex)) {
        return true;
    }
    return false;
}
#method_after
private boolean conflictingSuggestParameters() {
    if (Strings.isNullOrEmpty(suggest)) {
        return false;
    }
    if (projects.size() > 1) {
        return true;
    }
    if (visibleToAll) {
        return true;
    }
    if (user != null) {
        return true;
    }
    if (owned) {
        return true;
    }
    if (ownedBy != null) {
        return true;
    }
    if (start != 0) {
        return true;
    }
    if (!groupsToInspect.isEmpty()) {
        return true;
    }
    if (!Strings.isNullOrEmpty(matchSubstring)) {
        return true;
    }
    if (!Strings.isNullOrEmpty(matchRegex)) {
        return true;
    }
    return false;
}
#end_block

#method_before
private List<GroupInfo> getGroupsOwnedBy(IdentifiedUser user) throws OrmException {
    List<GroupInfo> groups = new ArrayList<>();
    int found = 0;
    int foundIndex = 0;
    for (GroupDescription.Internal g : filterGroups(getAllExistingInternalGroups())) {
        GroupControl ctl = groupControlFactory.controlFor(g);
        try {
            if (genericGroupControlFactory.controlFor(user, g.getGroupUUID()).isOwner()) {
                if (foundIndex++ < start) {
                    continue;
                }
                if (limit > 0 && ++found > limit) {
                    break;
                }
                groups.add(json.addOptions(options).format(ctl.getGroup()));
            }
        } catch (NoSuchGroupException e) {
            continue;
        }
    }
    return groups;
}
#method_after
private List<GroupInfo> getGroupsOwnedBy(String id) throws OrmException, RestApiException {
    String uuid = groupsCollection.parse(id).getGroupUUID().get();
    return filterGroupsOwnedBy(group -> group.getOwnerGroupUUID().get().equals(uuid));
}
#end_block

#method_before
private List<GroupInfo> getGroupsOwnedBy(IdentifiedUser user) throws OrmException {
    List<GroupInfo> groups = new ArrayList<>();
    int found = 0;
    int foundIndex = 0;
    for (GroupDescription.Internal g : filterGroups(getAllExistingInternalGroups())) {
        GroupControl ctl = groupControlFactory.controlFor(g);
        try {
            if (genericGroupControlFactory.controlFor(user, g.getGroupUUID()).isOwner()) {
                if (foundIndex++ < start) {
                    continue;
                }
                if (limit > 0 && ++found > limit) {
                    break;
                }
                groups.add(json.addOptions(options).format(ctl.getGroup()));
            }
        } catch (NoSuchGroupException e) {
            continue;
        }
    }
    return groups;
}
#method_after
private List<GroupInfo> getGroupsOwnedBy(IdentifiedUser user) throws OrmException {
    return filterGroupsOwnedBy(group -> isOwner(user, group));
}
#end_block

#method_before
public ListRequest withOwnedBy(AccountGroup.UUID ownedBy) {
    this.ownedBy = ownedBy;
    return this;
}
#method_after
public ListRequest withOwnedBy(String ownedBy) {
    this.ownedBy = ownedBy;
    return this;
}
#end_block

#method_before
public AccountGroup.UUID getOwnedBy() {
    return ownedBy;
}
#method_after
public String getOwnedBy() {
    return ownedBy;
}
#end_block

#method_before
@Test
public void outgoingMailHasListHeaders() throws Exception {
    String changeId = createChangeWithReview(user);
    // Check that the mail has the expected headers
    assertThat(sender.getMessages()).hasSize(1);
    Map<String, EmailHeader> headers = sender.getMessages().iterator().next().headers();
    String hostname = URI.create(canonicalWebUrl.get()).getHost();
    String listId = "<gerrit-" + project.get() + "." + hostname + ">";
    String unsubscribeLink = "<" + canonicalWebUrl.get() + "settings>";
    String threadId = "<gerrit." + gApi.changes().id(changeId).get().created.getTime() + "." + changeId + "@" + hostname + ">";
    assertThat(headerString(headers, "List-Id")).isEqualTo(listId);
    assertThat(headerString(headers, "List-Unsubscribe")).isEqualTo(unsubscribeLink);
    assertThat(headerString(headers, "In-Reply-To")).isEqualTo(threadId);
}
#method_after
@Test
public void outgoingMailHasListHeaders() throws Exception {
    String changeId = createChangeWithReview(user);
    // Check that the mail has the expected headers
    assertThat(sender.getMessages()).hasSize(1);
    Map<String, EmailHeader> headers = sender.getMessages().iterator().next().headers();
    String hostname = URI.create(canonicalWebUrl.get()).getHost();
    String listId = String.format("<gerrit-%s.%s>", project.get(), hostname);
    String unsubscribeLink = String.format("<%ssettings>", canonicalWebUrl.get());
    String threadId = String.format("<gerrit.%s.%s@%s>", gApi.changes().id(changeId).get().created.getTime(), changeId, hostname);
    assertThat(headerString(headers, "List-Id")).isEqualTo(listId);
    assertThat(headerString(headers, "List-Unsubscribe")).isEqualTo(unsubscribeLink);
    assertThat(headerString(headers, "In-Reply-To")).isEqualTo(threadId);
}
#end_block

#method_before
private Set<Account> toAccounts(Set<String> in, Project.NameKey p) {
    Set<Account> reviewers = Sets.newHashSetWithExpectedSize(in.size());
    for (String r : in) {
        try {
            Account account = accountResolver.find(r);
            if (account != null) {
                reviewers.add(account);
                continue;
            }
        } catch (OrmException | IOException | ConfigInvalidException e) {
            // If the account doesn't exist, find() will return null.  We only
            // get here if something went wrong accessing the database
            log.error("Failed to resolve account " + r, e);
            continue;
        }
        if (groupMembers == null) {
            try {
                reviewers.addAll(groupMembers.listAccounts(groupsCollection.get().parse(r).getGroupUUID(), p));
            } catch (UnprocessableEntityException | NoSuchGroupException e) {
                log.warn(String.format("Reviewer %s is neither an account nor a group", r));
            } catch (NoSuchProjectException e) {
                log.warn(String.format("Failed to list accounts for group %s and project %s", r, p));
            } catch (IOException | OrmException e) {
                log.warn(String.format("Failed to list accounts for group %s", r), e);
            }
        }
    }
    return reviewers;
}
#method_after
private Set<Account> toAccounts(Set<String> in, Project.NameKey p) {
    Set<Account> reviewers = Sets.newHashSetWithExpectedSize(in.size());
    for (String r : in) {
        try {
            Account account = accountResolver.find(r);
            if (account != null) {
                reviewers.add(account);
                continue;
            }
        } catch (OrmException | IOException | ConfigInvalidException e) {
            // If the account doesn't exist, find() will return null.  We only
            // get here if something went wrong accessing the database
            log.error("Failed to resolve account " + r, e);
            continue;
        }
        try {
            reviewers.addAll(groupMembers.listAccounts(groupsCollection.get().parse(r).getGroupUUID(), p));
        } catch (UnprocessableEntityException | NoSuchGroupException e) {
            log.warn(String.format("Reviewer %s is neither an account nor a group", r));
        } catch (NoSuchProjectException e) {
            log.warn(String.format("Failed to list accounts for group %s and project %s", r, p));
        } catch (IOException | OrmException e) {
            log.warn(String.format("Failed to list accounts for group %s", r), e);
        }
    }
    return reviewers;
}
#end_block

#method_before
static void createAllIndexes(ElasticNodeInfo nodeInfo) {
    Schema<ChangeData> changeSchema = ChangeSchemaDefinitions.INSTANCE.getLatest();
    ChangeMapping openChangesMapping = new ChangeMapping(changeSchema);
    ChangeMapping closedChangesMapping = new ChangeMapping(changeSchema);
    openChangesMapping.closedChanges = null;
    closedChangesMapping.openChanges = null;
    nodeInfo.node.client().admin().indices().prepareCreate(String.format("%s%04d", CHANGES_PREFIX, changeSchema.getVersion())).addMapping(OPEN_CHANGES, gson.toJson(openChangesMapping)).addMapping(CLOSED_CHANGES, gson.toJson(closedChangesMapping)).execute().actionGet();
    Schema<AccountState> accountSchema = AccountSchemaDefinitions.INSTANCE.getLatest();
    AccountMapping accountMapping = new AccountMapping(accountSchema);
    nodeInfo.node.client().admin().indices().prepareCreate(String.format("%s%04d", ACCOUNTS_PREFIX, accountSchema.getVersion())).addMapping(ElasticAccountIndex.ACCOUNTS, gson.toJson(accountMapping)).execute().actionGet();
    Schema<AccountGroup> groupSchema = GroupSchemaDefinitions.INSTANCE.getLatest();
    GroupMapping groupMapping = new GroupMapping(groupSchema);
    nodeInfo.node.client().admin().indices().prepareCreate(String.format("%s%04d", GROUPS_PREFIX, groupSchema.getVersion())).addMapping(ElasticGroupIndex.GROUPS, gson.toJson(groupMapping)).execute().actionGet();
    Schema<ProjectData> projectSchema = ProjectSchemaDefinitions.INSTANCE.getLatest();
    ProjectMapping projectMapping = new ProjectMapping(projectSchema);
    nodeInfo.node.client().admin().indices().prepareCreate(String.format("%s%04d", PROJECTS_PREFIX, projectSchema.getVersion())).addMapping(ElasticProjectIndex.PROJECTS, gson.toJson(projectMapping)).execute().actionGet();
}
#method_after
static void createAllIndexes(ElasticNodeInfo nodeInfo) {
    Schema<ChangeData> changeSchema = ChangeSchemaDefinitions.INSTANCE.getLatest();
    ChangeMapping openChangesMapping = new ChangeMapping(changeSchema);
    ChangeMapping closedChangesMapping = new ChangeMapping(changeSchema);
    openChangesMapping.closedChanges = null;
    closedChangesMapping.openChanges = null;
    nodeInfo.node.client().admin().indices().prepareCreate(String.format("%s%04d", CHANGES_PREFIX, changeSchema.getVersion())).addMapping(OPEN_CHANGES, gson.toJson(openChangesMapping)).addMapping(CLOSED_CHANGES, gson.toJson(closedChangesMapping)).execute().actionGet();
    Schema<AccountState> accountSchema = AccountSchemaDefinitions.INSTANCE.getLatest();
    AccountMapping accountMapping = new AccountMapping(accountSchema);
    nodeInfo.node.client().admin().indices().prepareCreate(String.format("%s%04d", ACCOUNTS_PREFIX, accountSchema.getVersion())).addMapping(ElasticAccountIndex.ACCOUNTS, gson.toJson(accountMapping)).execute().actionGet();
    Schema<InternalGroup> groupSchema = GroupSchemaDefinitions.INSTANCE.getLatest();
    GroupMapping groupMapping = new GroupMapping(groupSchema);
    nodeInfo.node.client().admin().indices().prepareCreate(String.format("%s%04d", GROUPS_PREFIX, groupSchema.getVersion())).addMapping(ElasticGroupIndex.GROUPS, gson.toJson(groupMapping)).execute().actionGet();
    Schema<ProjectData> projectSchema = ProjectSchemaDefinitions.INSTANCE.getLatest();
    ProjectMapping projectMapping = new ProjectMapping(projectSchema);
    nodeInfo.node.client().admin().indices().prepareCreate(String.format("%s%04d", PROJECTS_PREFIX, projectSchema.getVersion())).addMapping(ElasticProjectIndex.PROJECTS, gson.toJson(projectMapping)).execute().actionGet();
}
#end_block

#method_before
@Override
public void replace(ProjectData projectState) throws IOException {
    try {
        // No parts of FillArgs are currently required, just use null.
        replace(idTerm(projectState), toDocument(projectState, null)).get();
    } catch (ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#method_after
@Override
public void replace(ProjectData projectState) throws IOException {
    try {
        replace(idTerm(projectState), toDocument(projectState)).get();
    } catch (ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public GroupIndex create(Schema<AccountGroup> schema) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public GroupIndex create(Schema<InternalGroup> schema) {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
@Override
public List<ProjectInfo> apply(TopLevelResource resource) throws BadRequestException, MethodNotAllowedException, OrmException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    ProjectIndex searchIndex = indexes.getSearchIndex();
    if (searchIndex == null) {
        throw new MethodNotAllowedException("no project index");
    }
    if (start != 0) {
        queryProcessor.setStart(start);
    }
    if (limit != 0) {
        queryProcessor.setLimit(limit);
    }
    try {
        QueryResult<ProjectData> result = queryProcessor.query(queryBuilder.parse(query));
        List<ProjectData> pds = result.entities();
        ArrayList<ProjectInfo> projectInfos = Lists.newArrayListWithCapacity(pds.size());
        for (ProjectData pd : pds) {
            projectInfos.add(json.format(pd.getProject()));
        }
        return projectInfos;
    } catch (QueryParseException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
public List<ProjectInfo> apply(TopLevelResource resource) throws BadRequestException, MethodNotAllowedException, OrmException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    ProjectIndex searchIndex = indexes.getSearchIndex();
    if (searchIndex == null) {
        throw new MethodNotAllowedException("no project index");
    }
    if (start != 0) {
        queryProcessor.setStart(start);
    }
    if (limit != 0) {
        queryProcessor.setUserProvidedLimit(limit);
    }
    try {
        QueryResult<ProjectData> result = queryProcessor.query(queryBuilder.parse(query));
        List<ProjectData> pds = result.entities();
        ArrayList<ProjectInfo> projectInfos = Lists.newArrayListWithCapacity(pds.size());
        for (ProjectData pd : pds) {
            projectInfos.add(json.format(pd.getProject()));
        }
        return projectInfos;
    } catch (QueryParseException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
private boolean isRevisionOutOfDate() {
    try (Repository git = gitMgr.openRepository(getProject().getNameKey())) {
        Ref ref = git.getRefDatabase().exactRef(RefNames.REFS_CONFIG);
        if (ref == null || ref.getObjectId() == null) {
            return true;
        }
        return !ref.getObjectId().equals(config.getRevision());
    } catch (IOException gone) {
        return true;
    }
}
#method_after
private boolean isRevisionOutOfDate() {
    try (Repository git = gitMgr.openRepository(getNameKey())) {
        Ref ref = git.getRefDatabase().exactRef(RefNames.REFS_CONFIG);
        if (ref == null || ref.getObjectId() == null) {
            return true;
        }
        return !ref.getObjectId().equals(config.getRevision());
    } catch (IOException gone) {
        return true;
    }
}
#end_block

#method_before
public PrologEnvironment newPrologEnvironment() throws CompileException {
    PrologMachineCopy pmc = rulesMachine;
    if (pmc == null) {
        pmc = rulesCache.loadMachine(getProject().getNameKey(), config.getRulesId());
        rulesMachine = pmc;
    }
    return envFactory.create(pmc);
}
#method_after
public PrologEnvironment newPrologEnvironment() throws CompileException {
    PrologMachineCopy pmc = rulesMachine;
    if (pmc == null) {
        pmc = rulesCache.loadMachine(getNameKey(), config.getRulesId());
        rulesMachine = pmc;
    }
    return envFactory.create(pmc);
}
#end_block

#method_before
public ProjectLevelConfig getConfig(String fileName) {
    if (configs.containsKey(fileName)) {
        return configs.get(fileName);
    }
    ProjectLevelConfig cfg = new ProjectLevelConfig(fileName, this);
    try (Repository git = gitMgr.openRepository(getProject().getNameKey())) {
        cfg.load(git);
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Failed to load " + fileName + " for " + getProject().getName(), e);
    }
    configs.put(fileName, cfg);
    return cfg;
}
#method_after
public ProjectLevelConfig getConfig(String fileName) {
    if (configs.containsKey(fileName)) {
        return configs.get(fileName);
    }
    ProjectLevelConfig cfg = new ProjectLevelConfig(fileName, this);
    try (Repository git = gitMgr.openRepository(getNameKey())) {
        cfg.load(git);
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Failed to load " + fileName + " for " + getName(), e);
    }
    configs.put(fileName, cfg);
    return cfg;
}
#end_block

#method_before
List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(getProject().getNameKey(), section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#method_after
List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(getNameKey(), section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#end_block

#method_before
public LabelTypes getLabelTypes() {
    Map<String, LabelType> types = new LinkedHashMap<>();
    for (ProjectState s : treeInOrder()) {
        for (LabelType type : s.getConfig().getLabelSections().values()) {
            String lower = type.getName().toLowerCase();
            LabelType old = types.get(lower);
            if (old == null || old.canOverride()) {
                types.put(lower, type);
            }
        }
    }
    List<LabelType> all = Lists.newArrayListWithCapacity(types.size());
    for (LabelType type : types.values()) {
        if (!type.getValues().isEmpty()) {
            all.add(type);
        }
    }
    return new LabelTypes(Collections.unmodifiableList(all));
}
#method_after
public LabelTypes getLabelTypes() {
    if (labelTypes == null) {
        labelTypes = loadLabelTypes();
    }
    return labelTypes;
}
#end_block

#method_before
public LabelTypes getLabelTypes() {
    Map<String, LabelType> types = new LinkedHashMap<>();
    for (ProjectState s : treeInOrder()) {
        for (LabelType type : s.getConfig().getLabelSections().values()) {
            String lower = type.getName().toLowerCase();
            LabelType old = types.get(lower);
            if (old == null || old.canOverride()) {
                types.put(lower, type);
            }
        }
    }
    List<LabelType> all = Lists.newArrayListWithCapacity(types.size());
    for (LabelType type : types.values()) {
        if (!type.getValues().isEmpty()) {
            all.add(type);
        }
    }
    return new LabelTypes(Collections.unmodifiableList(all));
}
#method_after
public LabelTypes getLabelTypes(ChangeNotes notes, CurrentUser user) {
    return getLabelTypes(notes.getChange().getDest(), user);
}
#end_block

#method_before
FilteredRepository create(Project.NameKey name) throws NoSuchProjectException, IOException {
    ProjectControl ctl = projectControlFactory.controlFor(name, userProvider.get());
    if (ctl.getProject().getState().equals(HIDDEN)) {
        throw new NoSuchProjectException(name);
    }
    return new FilteredRepository(ctl, repoManager.openRepository(name), visibleRefFilterFactory, userProvider, permissionBackend, projectState);
}
#method_after
FilteredRepository create(Project.NameKey name) throws NoSuchProjectException, IOException, PermissionBackendException {
    ProjectControl ctl = projectControlFactory.controlFor(name, userProvider.get());
    if (ctl.getProject().getState().equals(ProjectState.HIDDEN)) {
        throw new NoSuchProjectException(name);
    }
    return new FilteredRepository(ctl, repoManager.openRepository(name), visibleRefFilterFactory, permissionBackend);
}
#end_block

#method_before
private boolean can(ProjectPermission perm) throws PermissionBackendException {
    switch(perm) {
        case ACCESS:
            return (!isHidden() && (user.isInternalUser() || canPerformOnAnyRef(Permission.READ))) || isOwner();
        case READ:
            return !isHidden() && allRefsAreVisible(Collections.emptySet());
        case READ_NO_CONFIG:
            return !isHidden() && allRefsAreVisible(ImmutableSet.of(RefNames.REFS_CONFIG));
        case CREATE_REF:
            return canAddRefs();
        case CREATE_CHANGE:
            return canCreateChanges();
        case RUN_RECEIVE_PACK:
            return canRunReceivePack();
        case RUN_UPLOAD_PACK:
            return canRunUploadPack();
        case BAN_COMMIT:
        case READ_REF_LOG:
        case SET_DEFAULT_DASHBOARD:
        case READ_ACCESS:
        case WRITE_ACCESS:
            return isOwner();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
private boolean can(ProjectPermission perm) throws PermissionBackendException {
    switch(perm) {
        case ACCESS:
            return (!isHidden() && (user.isInternalUser() || canPerformOnAnyRef(Permission.READ))) || isOwner();
        case READ:
            return !isHidden() && allRefsAreVisible(Collections.emptySet());
        case READ_NO_CONFIG:
            return !isHidden() && allRefsAreVisible(ImmutableSet.of(RefNames.REFS_CONFIG));
        case CREATE_REF:
            return canAddRefs();
        case CREATE_CHANGE:
            return canCreateChanges();
        case RUN_RECEIVE_PACK:
            return canRunReceivePack();
        case RUN_UPLOAD_PACK:
            return canRunUploadPack();
        case BAN_COMMIT:
        case READ_REFLOG:
        case READ_CONFIG:
        case WRITE_CONFIG:
            return isOwner();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
@Test
public void nonOwnerCannotSetConfig() throws Exception {
    ConfigInput input = createTestConfigInput();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("write access not permitted");
    gApi.projects().name(project.get()).config(input);
}
#method_after
@Test
public void nonOwnerCannotSetConfig() throws Exception {
    ConfigInput input = createTestConfigInput();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("write config not permitted");
    gApi.projects().name(project.get()).config(input);
}
#end_block

#method_before
@Override
public final T call() throws NoSuchProjectException, IOException, ConfigInvalidException, InvalidNameException, NoSuchGroupException, OrmException, UpdateParentFailedException, PermissionDeniedException, PermissionBackendException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    this.user = projectControl.getUser();
    try {
        contributorAgreements.check(projectName, projectControl.getUser());
    } catch (AuthException e) {
        throw new PermissionDeniedException(e.getMessage());
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        ProjectConfig config = ProjectConfig.read(md, base);
        Set<String> toDelete = scanSectionNames(config);
        for (AccessSection section : mergeSections(sectionList)) {
            String name = section.getName();
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (checkIfOwner && !canWriteConfig()) {
                    continue;
                }
                replace(config, toDelete, section);
            } else if (AccessSection.isValid(name)) {
                if (checkIfOwner && !projectControl.controlForRef(name).isOwner()) {
                    continue;
                }
                RefPattern.validate(name);
                replace(config, toDelete, section);
            }
        }
        for (String name : toDelete) {
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (!checkIfOwner || canWriteConfig()) {
                    config.remove(config.getAccessSection(name));
                }
            } else if (!checkIfOwner || projectControl.controlForRef(name).isOwner()) {
                config.remove(config.getAccessSection(name));
            }
        }
        boolean parentProjectUpdate = false;
        if (!config.getProject().getNameKey().equals(allProjects) && !config.getProject().getParent(allProjects).equals(parentProjectName)) {
            parentProjectUpdate = true;
            try {
                setParent.get().validateParentUpdate(projectControl.getProject().getNameKey(), projectControl.getUser().asIdentifiedUser(), MoreObjects.firstNonNull(parentProjectName, allProjects).get(), checkIfOwner);
            } catch (AuthException e) {
                throw new UpdateParentFailedException("You are not allowed to change the parent project since you are " + "not an administrator. You may save the modifications for review " + "so that an administrator can approve them.", e);
            } catch (ResourceConflictException | UnprocessableEntityException e) {
                throw new UpdateParentFailedException(e.getMessage(), e);
            }
            config.getProject().setParentName(parentProjectName);
        }
        if (message != null && !message.isEmpty()) {
            if (!message.endsWith("\n")) {
                message += "\n";
            }
            md.setMessage(message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        return updateProjectConfig(projectControl, config, md, parentProjectUpdate);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
}
#method_after
@Override
public final T call() throws NoSuchProjectException, IOException, ConfigInvalidException, InvalidNameException, NoSuchGroupException, OrmException, UpdateParentFailedException, PermissionDeniedException, PermissionBackendException {
    final ProjectControl projectControl = projectControlFactory.controlFor(projectName);
    this.user = projectControl.getUser();
    try {
        contributorAgreements.check(projectName, projectControl.getUser());
    } catch (AuthException e) {
        throw new PermissionDeniedException(e.getMessage());
    }
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        ProjectConfig config = ProjectConfig.read(md, base);
        Set<String> toDelete = scanSectionNames(config);
        PermissionBackend.ForProject forProject = permissionBackend.user(user).project(projectName);
        for (AccessSection section : mergeSections(sectionList)) {
            String name = section.getName();
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (checkIfOwner && !canWriteConfig()) {
                    continue;
                }
                replace(config, toDelete, section);
            } else if (AccessSection.isValid(name)) {
                if (checkIfOwner && !forProject.ref(name).test(RefPermission.WRITE_CONFIG)) {
                    continue;
                }
                RefPattern.validate(name);
                replace(config, toDelete, section);
            }
        }
        for (String name : toDelete) {
            if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
                if (!checkIfOwner || canWriteConfig()) {
                    config.remove(config.getAccessSection(name));
                }
            } else if (!checkIfOwner || forProject.ref(name).test(RefPermission.WRITE_CONFIG)) {
                config.remove(config.getAccessSection(name));
            }
        }
        boolean parentProjectUpdate = false;
        if (!config.getProject().getNameKey().equals(allProjects) && !config.getProject().getParent(allProjects).equals(parentProjectName)) {
            parentProjectUpdate = true;
            try {
                setParent.get().validateParentUpdate(projectControl.getProject().getNameKey(), projectControl.getUser().asIdentifiedUser(), MoreObjects.firstNonNull(parentProjectName, allProjects).get(), checkIfOwner);
            } catch (AuthException e) {
                throw new UpdateParentFailedException("You are not allowed to change the parent project since you are " + "not an administrator. You may save the modifications for review " + "so that an administrator can approve them.", e);
            } catch (ResourceConflictException | UnprocessableEntityException e) {
                throw new UpdateParentFailedException(e.getMessage(), e);
            }
            config.getProject().setParentName(parentProjectName);
        }
        if (message != null && !message.isEmpty()) {
            if (!message.endsWith("\n")) {
                message += "\n";
            }
            md.setMessage(message);
        } else {
            md.setMessage("Modify access rules\n");
        }
        return updateProjectConfig(projectControl, config, md, parentProjectUpdate);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(projectName);
    }
}
#end_block

#method_before
private boolean canWriteConfig() throws PermissionBackendException {
    checkNotNull(user);
    if (canWriteConfig != null) {
        return canWriteConfig;
    }
    try {
        permissionBackend.user(user).project(projectName).check(ProjectPermission.WRITE_ACCESS);
        canWriteConfig = true;
    } catch (AuthException e) {
        canWriteConfig = false;
    }
    return canWriteConfig;
}
#method_after
private boolean canWriteConfig() throws PermissionBackendException {
    checkNotNull(user);
    if (canWriteConfig != null) {
        return canWriteConfig;
    }
    try {
        permissionBackend.user(user).project(projectName).check(ProjectPermission.WRITE_CONFIG);
        canWriteConfig = true;
    } catch (AuthException e) {
        canWriteConfig = false;
    }
    return canWriteConfig;
}
#end_block

#method_before
@Override
protected BanResultInfo applyImpl(BatchUpdate.Factory updateFactory, ProjectResource rsrc, Input input) throws RestApiException, UpdateException, IOException, PermissionBackendException {
    BanResultInfo r = new BanResultInfo();
    if (input != null && input.commits != null && !input.commits.isEmpty()) {
        List<ObjectId> commitsToBan = new ArrayList<>(input.commits.size());
        for (String c : input.commits) {
            try {
                commitsToBan.add(ObjectId.fromString(c));
            } catch (IllegalArgumentException e) {
                throw new UnprocessableEntityException(e.getMessage());
            }
        }
        try {
            BanCommitResult result = banCommit.ban(rsrc.getControl(), commitsToBan, input.reason);
            r.newlyBanned = transformCommits(result.getNewlyBannedCommits());
            r.alreadyBanned = transformCommits(result.getAlreadyBannedCommits());
            r.ignored = transformCommits(result.getIgnoredObjectIds());
        } catch (PermissionDeniedException e) {
            throw new AuthException(e.getMessage());
        }
    }
    return r;
}
#method_after
@Override
protected BanResultInfo applyImpl(BatchUpdate.Factory updateFactory, ProjectResource rsrc, Input input) throws RestApiException, UpdateException, IOException, PermissionBackendException {
    BanResultInfo r = new BanResultInfo();
    if (input != null && input.commits != null && !input.commits.isEmpty()) {
        List<ObjectId> commitsToBan = new ArrayList<>(input.commits.size());
        for (String c : input.commits) {
            try {
                commitsToBan.add(ObjectId.fromString(c));
            } catch (IllegalArgumentException e) {
                throw new UnprocessableEntityException(e.getMessage());
            }
        }
        BanCommitResult result = banCommit.ban(rsrc.getControl(), commitsToBan, input.reason);
        r.newlyBanned = transformCommits(result.getNewlyBannedCommits());
        r.alreadyBanned = transformCommits(result.getAlreadyBannedCommits());
        r.ignored = transformCommits(result.getIgnoredObjectIds());
    }
    return r;
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException, PermissionBackendException {
    ProjectControl pc = checkProjectControl();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            pc = checkProjectControl();
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = checkProjectControl();
        }
    }
    List<AccessSection> local = new ArrayList<>();
    Set<String> ownerOf = new HashSet<>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<>();
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(projectName);
    boolean checkReadConfig = check(perm, RefNames.REFS_CONFIG, READ);
    boolean canWriteProjectConfig = true;
    try {
        perm.check(ProjectPermission.WRITE_ACCESS);
    } catch (AuthException e) {
        canWriteProjectConfig = false;
    }
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (canWriteProjectConfig) {
                local.add(section);
                ownerOf.add(name);
            } else if (checkReadConfig) {
                local.add(section);
            }
        } else if (RefConfigSection.isValid(name)) {
            if (pc.controlForRef(name).isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (checkReadConfig) {
                local.add(section);
            } else if (check(perm, name, READ)) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && isAdmin()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Fall back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName) && permissionBackend.user(user).testOrFalse(ADMINISTRATE_SERVER)) {
        ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setCanUpload(canWriteProjectConfig || (checkReadConfig && perm.ref(RefNames.REFS_CONFIG).testOrFalse(CREATE_CHANGE)));
    detail.setConfigVisible(canWriteProjectConfig || checkReadConfig);
    detail.setGroupInfo(buildGroupInfo(local));
    detail.setLabelTypes(pc.getProjectState().getLabelTypes());
    detail.setFileHistoryLinks(getConfigFileLogLinks(projectName.get()));
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException, PermissionBackendException {
    ProjectControl pc = checkProjectControl();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            pc = checkProjectControl();
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = checkProjectControl();
        }
    }
    List<AccessSection> local = new ArrayList<>();
    Set<String> ownerOf = new HashSet<>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<>();
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(projectName);
    boolean checkReadConfig = check(perm, RefNames.REFS_CONFIG, READ);
    boolean canWriteProjectConfig = true;
    try {
        perm.check(ProjectPermission.WRITE_CONFIG);
    } catch (AuthException e) {
        canWriteProjectConfig = false;
    }
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (canWriteProjectConfig) {
                local.add(section);
                ownerOf.add(name);
            } else if (checkReadConfig) {
                local.add(section);
            }
        } else if (RefConfigSection.isValid(name)) {
            if (check(perm, name, WRITE_CONFIG)) {
                local.add(section);
                ownerOf.add(name);
            } else if (checkReadConfig) {
                local.add(section);
            } else if (check(perm, name, READ)) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && isAdmin()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Fall back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName) && permissionBackend.user(user).testOrFalse(ADMINISTRATE_SERVER)) {
        ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setCanUpload(canWriteProjectConfig || (checkReadConfig && perm.ref(RefNames.REFS_CONFIG).testOrFalse(CREATE_CHANGE)));
    detail.setConfigVisible(canWriteProjectConfig || checkReadConfig);
    detail.setGroupInfo(buildGroupInfo(local));
    detail.setLabelTypes(pc.getProjectState().getLabelTypes());
    detail.setFileHistoryLinks(getConfigFileLogLinks(projectName.get()));
    return detail;
}
#end_block

#method_before
public void checkRemoveReviewer(ChangeNotes notes, CurrentUser currentUser, PatchSetApproval approval) throws PermissionBackendException, AuthException, NoSuchChangeException, OrmException {
    if (canRemoveReviewerWithoutPermissionCheck(notes.getChange(), currentUser, approval.getAccountId(), approval.getValue())) {
        return;
    }
    permissionBackend.user(currentUser).change(notes).database(dbProvider).check(ChangePermission.REMOVE_REVIEWER);
}
#method_after
public void checkRemoveReviewer(ChangeNotes notes, CurrentUser currentUser, PatchSetApproval approval) throws PermissionBackendException, AuthException, NoSuchProjectException, IOException {
    if (canRemoveReviewerWithoutPermissionCheck(notes.getChange(), currentUser, approval.getAccountId(), approval.getValue())) {
        return;
    }
    permissionBackend.user(currentUser).change(notes).database(dbProvider).check(ChangePermission.REMOVE_REVIEWER);
}
#end_block

#method_before
public boolean testRemoveReviewer(ChangeData cd, CurrentUser currentUser, Account.Id reviewer, int value) throws PermissionBackendException, NoSuchChangeException, OrmException {
    if (canRemoveReviewerWithoutPermissionCheck(cd.change(), currentUser, reviewer, value)) {
        return true;
    }
    return permissionBackend.user(currentUser).change(cd).database(dbProvider).test(ChangePermission.REMOVE_REVIEWER);
}
#method_after
public boolean testRemoveReviewer(ChangeData cd, CurrentUser currentUser, Account.Id reviewer, int value) throws PermissionBackendException, NoSuchProjectException, OrmException, IOException {
    if (canRemoveReviewerWithoutPermissionCheck(cd.change(), currentUser, reviewer, value)) {
        return true;
    }
    return permissionBackend.user(currentUser).change(cd).database(dbProvider).test(ChangePermission.REMOVE_REVIEWER);
}
#end_block

#method_before
private boolean canRemoveReviewerWithoutPermissionCheck(Change change, CurrentUser currentUser, Account.Id reviewer, int value) throws NoSuchChangeException, OrmException {
    if (!change.getStatus().isOpen()) {
        return false;
    }
    if (currentUser.isIdentifiedUser()) {
        Account.Id aId = currentUser.getAccountId();
        if (aId.equals(reviewer)) {
            // A user can always remove themselves.
            return true;
        } else if (aId.equals(change.getOwner()) && 0 <= value) {
            // The change owner may remove any zero or positive score.
            return true;
        }
    }
    // Users with the remove reviewer permission, the branch owner, project
    // owner and site admin can remove anyone
    // TODO(hiesel): Remove all Control usage
    ChangeControl changeControl = changeControlFactory.controlFor(dbProvider.get(), change, currentUser);
    if (// branch owner
    changeControl.getRefControl().isOwner() || // project owner
    changeControl.getProjectControl().isOwner() || changeControl.getProjectControl().isAdmin()) {
        // project admin
        return true;
    }
    return false;
}
#method_after
private boolean canRemoveReviewerWithoutPermissionCheck(Change change, CurrentUser currentUser, Account.Id reviewer, int value) throws NoSuchProjectException, IOException {
    if (!change.getStatus().isOpen()) {
        return false;
    }
    if (currentUser.isIdentifiedUser()) {
        Account.Id aId = currentUser.getAccountId();
        if (aId.equals(reviewer)) {
            // A user can always remove themselves.
            return true;
        } else if (aId.equals(change.getOwner()) && 0 <= value) {
            // The change owner may remove any zero or positive score.
            return true;
        }
    }
    // Users with the remove reviewer permission, the branch owner, project
    // owner and site admin can remove anyone
    // TODO(hiesel): Remove all Control usage
    ProjectControl ctl = projectControlFactory.controlFor(change.getProject(), currentUser);
    if (// branch owner
    ctl.controlForRef(change.getDest()).isOwner() || // project owner
    ctl.isOwner() || ctl.isAdmin()) {
        // project admin
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(ChangeResource rsrc, FixInput input) throws RestApiException, OrmException, PermissionBackendException, NoSuchProjectException, IOException {
    PermissionBackend.WithUser perm = permissionBackend.user(user);
    if (!rsrc.isUserOwner()) {
        perm.project(rsrc.getProject()).check(ProjectPermission.READ_ACCESS);
    }
    return Response.withMustRevalidate(newChangeJson().fix(input).format(rsrc));
}
#method_after
@Override
public Response<ChangeInfo> apply(ChangeResource rsrc, FixInput input) throws RestApiException, OrmException, PermissionBackendException, NoSuchProjectException, IOException {
    PermissionBackend.WithUser perm = permissionBackend.user(user);
    if (!rsrc.isUserOwner()) {
        perm.project(rsrc.getProject()).check(ProjectPermission.READ_CONFIG);
    }
    return Response.withMustRevalidate(newChangeJson().fix(input).format(rsrc));
}
#end_block

#method_before
@Override
public Response<DashboardInfo> apply(DashboardResource resource, SetDashboardInput input) throws RestApiException, IOException, PermissionBackendException {
    if (input == null) {
        // Delete would set input to null.
        input = new SetDashboardInput();
    }
    input.id = Strings.emptyToNull(input.id);
    ProjectControl ctl = resource.getControl();
    permissionBackend.user(ctl.getUser()).project(ctl.getProject().getNameKey()).check(ProjectPermission.SET_DEFAULT_DASHBOARD);
    DashboardResource target = null;
    if (input.id != null) {
        try {
            target = dashboards.parse(new ProjectResource(ctl), IdString.fromUrl(input.id));
        } catch (ResourceNotFoundException e) {
            throw new BadRequestException("dashboard " + input.id + " not found");
        } catch (ConfigInvalidException e) {
            throw new ResourceConflictException(e.getMessage());
        }
    }
    try (MetaDataUpdate md = updateFactory.create(ctl.getProject().getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        if (inherited) {
            project.setDefaultDashboard(input.id);
        } else {
            project.setLocalDefaultDashboard(input.id);
        }
        String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), input.id == null ? "Removed default dashboard.\n" : String.format("Changed default dashboard to %s.\n", input.id));
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(ctl.getUser().asIdentifiedUser());
        md.setMessage(msg);
        config.commit(md);
        cache.evict(ctl.getProject());
        if (target != null) {
            DashboardInfo info = get.get().apply(target);
            info.isDefault = true;
            return Response.ok(info);
        }
        return Response.none();
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(ctl.getProject().getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#method_after
@Override
public Response<DashboardInfo> apply(DashboardResource resource, SetDashboardInput input) throws RestApiException, IOException, PermissionBackendException {
    if (input == null) {
        // Delete would set input to null.
        input = new SetDashboardInput();
    }
    input.id = Strings.emptyToNull(input.id);
    ProjectControl ctl = resource.getControl();
    permissionBackend.user(ctl.getUser()).project(ctl.getProject().getNameKey()).check(ProjectPermission.WRITE_CONFIG);
    DashboardResource target = null;
    if (input.id != null) {
        try {
            target = dashboards.parse(new ProjectResource(ctl), IdString.fromUrl(input.id));
        } catch (ResourceNotFoundException e) {
            throw new BadRequestException("dashboard " + input.id + " not found");
        } catch (ConfigInvalidException e) {
            throw new ResourceConflictException(e.getMessage());
        }
    }
    try (MetaDataUpdate md = updateFactory.create(ctl.getProject().getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        if (inherited) {
            project.setDefaultDashboard(input.id);
        } else {
            project.setLocalDefaultDashboard(input.id);
        }
        String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), input.id == null ? "Removed default dashboard.\n" : String.format("Changed default dashboard to %s.\n", input.id));
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(ctl.getUser().asIdentifiedUser());
        md.setMessage(msg);
        config.commit(md);
        cache.evict(ctl.getProject());
        if (target != null) {
            DashboardInfo info = get.get().apply(target);
            info.isDefault = true;
            return Response.ok(info);
        }
        return Response.none();
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(ctl.getProject().getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#end_block

#method_before
@Override
public ProjectAccessInfo apply(ProjectResource rsrc) throws ResourceNotFoundException, ResourceConflictException, IOException, PermissionBackendException, OrmException {
    // Load the current configuration from the repository, ensuring it's the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    Project.NameKey projectName = rsrc.getNameKey();
    ProjectAccessInfo info = new ProjectAccessInfo();
    ProjectControl pc = createProjectControl(projectName);
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(projectName);
    ProjectConfig config;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            pc = createProjectControl(projectName);
            perm = permissionBackend.user(user).project(projectName);
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = createProjectControl(projectName);
            perm = permissionBackend.user(user).project(projectName);
        }
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
    info.local = new HashMap<>();
    info.ownerOf = new HashSet<>();
    Map<AccountGroup.UUID, GroupInfo> visibleGroups = new HashMap<>();
    boolean canReadConfig = check(perm, ProjectPermission.READ_ACCESS);
    boolean canWriteConfig = check(perm, ProjectPermission.WRITE_ACCESS);
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (canWriteConfig) {
                info.local.put(name, createAccessSection(visibleGroups, section));
                info.ownerOf.add(name);
            } else if (canReadConfig) {
                info.local.put(section.getName(), createAccessSection(visibleGroups, section));
            }
        } else if (RefConfigSection.isValid(name)) {
            if (pc.controlForRef(name).isOwner()) {
                info.local.put(name, createAccessSection(visibleGroups, section));
                info.ownerOf.add(name);
            } else if (canReadConfig) {
                info.local.put(name, createAccessSection(visibleGroups, section));
            } else if (check(perm, name, READ)) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID groupId = srcRule.getGroup().getUUID();
                        if (groupId == null) {
                            continue;
                        }
                        GroupInfo group = loadGroup(visibleGroups, groupId);
                        if (group != INVISIBLE_SENTINEL) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    info.local.put(name, createAccessSection(visibleGroups, dst));
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && permissionBackend.user(user).test(GlobalPermission.ADMINISTRATE_SERVER)) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Fall back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(pc.getProjectState().parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (projectName.equals(allProjectsName) && permissionBackend.user(user).testOrFalse(ADMINISTRATE_SERVER)) {
        info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
    }
    info.isOwner = toBoolean(canWriteConfig);
    info.canUpload = toBoolean(canWriteConfig || (canReadConfig && perm.ref(RefNames.REFS_CONFIG).testOrFalse(CREATE_CHANGE)));
    info.canAdd = toBoolean(perm.testOrFalse(CREATE_REF));
    info.configVisible = canReadConfig || canWriteConfig;
    info.groups = visibleGroups.entrySet().stream().filter(e -> e.getValue() != INVISIBLE_SENTINEL).collect(toMap(e -> e.getKey().get(), e -> e.getValue()));
    return info;
}
#method_after
@Override
public ProjectAccessInfo apply(ProjectResource rsrc) throws ResourceNotFoundException, ResourceConflictException, IOException, PermissionBackendException, OrmException {
    // Load the current configuration from the repository, ensuring it's the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    Project.NameKey projectName = rsrc.getNameKey();
    ProjectAccessInfo info = new ProjectAccessInfo();
    ProjectControl pc = createProjectControl(projectName);
    PermissionBackend.ForProject perm = permissionBackend.user(user).project(projectName);
    ProjectConfig config;
    try (MetaDataUpdate md = metaDataUpdateFactory.create(projectName)) {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            pc = createProjectControl(projectName);
            perm = permissionBackend.user(user).project(projectName);
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = createProjectControl(projectName);
            perm = permissionBackend.user(user).project(projectName);
        }
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
    info.local = new HashMap<>();
    info.ownerOf = new HashSet<>();
    Map<AccountGroup.UUID, GroupInfo> visibleGroups = new HashMap<>();
    boolean canReadConfig = check(perm, ProjectPermission.READ_CONFIG);
    boolean canWriteConfig = check(perm, ProjectPermission.WRITE_CONFIG);
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (canWriteConfig) {
                info.local.put(name, createAccessSection(visibleGroups, section));
                info.ownerOf.add(name);
            } else if (canReadConfig) {
                info.local.put(section.getName(), createAccessSection(visibleGroups, section));
            }
        } else if (RefConfigSection.isValid(name)) {
            if (pc.controlForRef(name).isOwner()) {
                info.local.put(name, createAccessSection(visibleGroups, section));
                info.ownerOf.add(name);
            } else if (canReadConfig) {
                info.local.put(name, createAccessSection(visibleGroups, section));
            } else if (check(perm, name, READ)) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID groupId = srcRule.getGroup().getUUID();
                        if (groupId == null) {
                            continue;
                        }
                        GroupInfo group = loadGroup(visibleGroups, groupId);
                        if (group != INVISIBLE_SENTINEL) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    info.local.put(name, createAccessSection(visibleGroups, dst));
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (info.ownerOf.isEmpty() && permissionBackend.user(user).test(GlobalPermission.ADMINISTRATE_SERVER)) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Fall back to site administrators.
        info.ownerOf.add(AccessSection.ALL);
    }
    if (config.getRevision() != null) {
        info.revision = config.getRevision().name();
    }
    ProjectState parent = Iterables.getFirst(pc.getProjectState().parents(), null);
    if (parent != null) {
        info.inheritsFrom = projectJson.format(parent.getProject());
    }
    if (projectName.equals(allProjectsName) && permissionBackend.user(user).testOrFalse(ADMINISTRATE_SERVER)) {
        info.ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
    }
    info.isOwner = toBoolean(canWriteConfig);
    info.canUpload = toBoolean(canWriteConfig || (canReadConfig && perm.ref(RefNames.REFS_CONFIG).testOrFalse(CREATE_CHANGE)));
    info.canAdd = toBoolean(perm.testOrFalse(CREATE_REF));
    info.configVisible = canReadConfig || canWriteConfig;
    info.groups = visibleGroups.entrySet().stream().filter(e -> e.getValue() != INVISIBLE_SENTINEL).collect(toMap(e -> e.getKey().get(), e -> e.getValue()));
    return info;
}
#end_block

#method_before
// TODO(dborowitz): Hack MetaDataUpdate so it can be created within a BatchUpdate and we can avoid
@SuppressWarnings("deprecation")
@Override
protected Change.Id updateProjectConfig(ProjectControl projectControl, ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, OrmException, PermissionDeniedException, PermissionBackendException {
    PermissionBackend.ForProject perm = permissionBackend.user(projectControl.getUser()).project(projectControl.getProject().getNameKey());
    if (!check(perm, ProjectPermission.READ_ACCESS)) {
        throw new PermissionDeniedException(RefNames.REFS_CONFIG + " not visible");
    }
    if (!check(perm, ProjectPermission.WRITE_ACCESS) && !check(perm.ref(RefNames.REFS_CONFIG), RefPermission.CREATE_CHANGE)) {
        throw new PermissionDeniedException("cannot create change for " + RefNames.REFS_CONFIG);
    }
    md.setInsertChangeId(true);
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
    if (commit.getId().equals(base)) {
        return null;
    }
    try (ObjectInserter objInserter = md.getRepository().newObjectInserter();
        ObjectReader objReader = objInserter.newReader();
        RevWalk rw = new RevWalk(objReader);
        BatchUpdate bu = updateFactory.create(db, config.getProject().getNameKey(), projectControl.getUser(), TimeUtil.nowTs())) {
        bu.setRepository(md.getRepository(), rw, objInserter);
        bu.insertChange(changeInserterFactory.create(changeId, commit, RefNames.REFS_CONFIG).setValidate(false).setUpdateRef(// Created by commitToNewRef.
        false));
        bu.execute();
    } catch (UpdateException | RestApiException e) {
        throw new IOException(e);
    }
    ChangeResource rsrc;
    try {
        rsrc = changes.parse(changeId);
    } catch (ResourceNotFoundException e) {
        throw new IOException(e);
    }
    addProjectOwnersAsReviewers(rsrc);
    if (parentProjectUpdate) {
        addAdministratorsAsReviewers(rsrc);
    }
    return changeId;
}
#method_after
// TODO(dborowitz): Hack MetaDataUpdate so it can be created within a BatchUpdate and we can avoid
@SuppressWarnings("deprecation")
@Override
protected Change.Id updateProjectConfig(ProjectControl projectControl, ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, OrmException, PermissionDeniedException, PermissionBackendException {
    PermissionBackend.ForProject perm = permissionBackend.user(projectControl.getUser()).project(projectControl.getProject().getNameKey());
    if (!check(perm, ProjectPermission.READ_CONFIG)) {
        throw new PermissionDeniedException(RefNames.REFS_CONFIG + " not visible");
    }
    if (!check(perm, ProjectPermission.WRITE_CONFIG) && !check(perm.ref(RefNames.REFS_CONFIG), RefPermission.CREATE_CHANGE)) {
        throw new PermissionDeniedException("cannot create change for " + RefNames.REFS_CONFIG);
    }
    md.setInsertChangeId(true);
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
    if (commit.getId().equals(base)) {
        return null;
    }
    try (ObjectInserter objInserter = md.getRepository().newObjectInserter();
        ObjectReader objReader = objInserter.newReader();
        RevWalk rw = new RevWalk(objReader);
        BatchUpdate bu = updateFactory.create(db, config.getProject().getNameKey(), projectControl.getUser(), TimeUtil.nowTs())) {
        bu.setRepository(md.getRepository(), rw, objInserter);
        bu.insertChange(changeInserterFactory.create(changeId, commit, RefNames.REFS_CONFIG).setValidate(false).setUpdateRef(// Created by commitToNewRef.
        false));
        bu.execute();
    } catch (UpdateException | RestApiException e) {
        throw new IOException(e);
    }
    ChangeResource rsrc;
    try {
        rsrc = changes.parse(changeId);
    } catch (ResourceNotFoundException e) {
        throw new IOException(e);
    }
    addProjectOwnersAsReviewers(rsrc);
    if (parentProjectUpdate) {
        addAdministratorsAsReviewers(rsrc);
    }
    return changeId;
}
#end_block

#method_before
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(changeFormatter.newChange(ChangeReportFormatter.Input.builder().setChange(c.change).build()));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && (magicBranch.edit || magicBranch.draft);
        Boolean isPrivate = null;
        Boolean wip = null;
        if (magicBranch != null) {
            if (magicBranch.isPrivate) {
                isPrivate = true;
            } else if (magicBranch.removePrivate) {
                isPrivate = false;
            }
            if (magicBranch.workInProgress) {
                wip = true;
            } else if (magicBranch.ready) {
                wip = false;
            }
        }
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            if (isPrivate == null) {
                isPrivate = u.notes.getChange().isPrivate();
            }
            if (wip == null) {
                wip = u.notes.getChange().isWorkInProgress();
            }
            ChangeReportFormatter.Input input = ChangeReportFormatter.Input.builder().setChange(u.notes.getChange()).setSubject(subject).setIsEdit(edit).setIsPrivate(isPrivate).setIsWorkInProgress(wip).build();
            addMessage(changeFormatter.changeUpdated(input));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(changeFormatter.newChange(ChangeReportFormatter.Input.builder().setChange(c.change).build()));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && (magicBranch.edit || magicBranch.draft);
        Boolean isPrivate = null;
        Boolean wip = null;
        if (magicBranch != null) {
            if (magicBranch.isPrivate) {
                isPrivate = true;
            } else if (magicBranch.removePrivate) {
                isPrivate = false;
            }
            if (magicBranch.workInProgress) {
                wip = true;
            } else if (magicBranch.ready) {
                wip = false;
            }
        }
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            if (isPrivate == null) {
                isPrivate = u.notes.getChange().isPrivate();
            }
            if (wip == null) {
                wip = u.notes.getChange().isWorkInProgress();
            }
            ChangeReportFormatter.Input input = ChangeReportFormatter.Input.builder().setChange(u.notes.getChange()).setSubject(subject).setIsEdit(edit).setIsPrivate(isPrivate).setIsWorkInProgress(wip).build();
            addMessage(changeFormatter.changeUpdated(input));
        }
        addMessage("");
    }
    // TODO(xchangcheng): remove after migrating tools which are using this magic branch.
    if (magicBranch != null && magicBranch.publish) {
        addMessage("Pushing to refs/publish/* is deprecated, use refs/for/* instead.");
    }
}
#end_block

#method_before
private void parseCommands(Collection<ReceiveCommand> commands) throws PermissionBackendException, NoSuchProjectException, IOException {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET_PATTERN.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd, "prohibited by Gerrit: unknown command type " + cmd.getType());
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            try {
                permissions.check(ProjectPermission.WRITE_ACCESS);
            } catch (AuthException e) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent)) {
                                try {
                                    permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER);
                                } catch (AuthException e) {
                                    reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                    continue;
                                }
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                oldValue = Arrays.stream(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName())).collect(joining("\n"));
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd, "prohibited by Gerrit: don't know how to handle config update of type " + cmd.getType());
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) throws PermissionBackendException, NoSuchProjectException, IOException {
    List<String> optionList = rp.getPushOptions();
    if (optionList != null) {
        for (String option : optionList) {
            int e = option.indexOf('=');
            if (e > 0) {
                pushOptions.put(option.substring(0, e), option.substring(e + 1));
            } else {
                pushOptions.put(option, "");
            }
        }
    }
    logDebug("Parsing {} commands", commands.size());
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // Already rejected by the core receive process.
            logDebug("Already processed by core: {} {}", cmd.getResult(), cmd);
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            String newName = RefNames.refsUsers(user.getAccountId());
            logDebug("Swapping out command for {} to {}", RefNames.REFS_USERS_SELF, newName);
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), newName, cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET_PATTERN.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd, "prohibited by Gerrit: unknown command type " + cmd.getType());
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            logDebug("Processing {} command", cmd.getRefName());
            try {
                permissions.check(ProjectPermission.WRITE_CONFIG);
            } catch (AuthException e) {
                reject(cmd, String.format("must be either project owner or have %s permission", ProjectPermission.WRITE_CONFIG.describeForException()));
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent)) {
                                try {
                                    permissionBackend.user(user).check(GlobalPermission.ADMINISTRATE_SERVER);
                                } catch (AuthException e) {
                                    reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                    continue;
                                }
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                oldValue = Arrays.stream(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName())).collect(joining("\n"));
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        logError("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd, "prohibited by Gerrit: don't know how to handle config update of type " + cmd.getType());
                    continue;
            }
        }
    }
}
#end_block

#method_before
@Override
public Response<String> apply(ProjectResource resource, DescriptionInput input) throws AuthException, ResourceConflictException, ResourceNotFoundException, IOException, PermissionBackendException {
    if (input == null) {
        // Delete would set description to null.
        input = new DescriptionInput();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = ctl.getUser().asIdentifiedUser();
    permissionBackend.user(user).project(resource.getNameKey()).check(ProjectPermission.WRITE_ACCESS);
    try (MetaDataUpdate md = updateFactory.create(resource.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        project.setDescription(Strings.emptyToNull(input.description));
        String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(user);
        md.setMessage(msg);
        config.commit(md);
        cache.evict(ctl.getProject());
        md.getRepository().setGitwebDescription(project.getDescription());
        return Strings.isNullOrEmpty(project.getDescription()) ? Response.<String>none() : Response.ok(project.getDescription());
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#method_after
@Override
public Response<String> apply(ProjectResource resource, DescriptionInput input) throws AuthException, ResourceConflictException, ResourceNotFoundException, IOException, PermissionBackendException {
    if (input == null) {
        // Delete would set description to null.
        input = new DescriptionInput();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = ctl.getUser().asIdentifiedUser();
    permissionBackend.user(user).project(resource.getNameKey()).check(ProjectPermission.WRITE_CONFIG);
    try (MetaDataUpdate md = updateFactory.create(resource.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        project.setDescription(Strings.emptyToNull(input.description));
        String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(user);
        md.setMessage(msg);
        config.commit(md);
        cache.evict(ctl.getProject());
        md.getRepository().setGitwebDescription(project.getDescription());
        return Strings.isNullOrEmpty(project.getDescription()) ? Response.<String>none() : Response.ok(project.getDescription());
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#end_block

#method_before
public BanCommitResult ban(ProjectControl projectControl, List<ObjectId> commitsToBan, String reason) throws PermissionDeniedException, LockFailureException, IOException, PermissionBackendException {
    try {
        permissionBackend.user(projectControl.getUser()).project(projectControl.getProject().getNameKey()).check(ProjectPermission.BAN_COMMIT);
    } catch (AuthException e) {
        throw new PermissionDeniedException("Not project owner: not permitted to ban commits");
    }
    final BanCommitResult result = new BanCommitResult();
    NoteMap banCommitNotes = NoteMap.newEmptyMap();
    // Add a note for each banned commit to notes.
    final Project.NameKey project = projectControl.getProject().getNameKey();
    try (Repository repo = repoManager.openRepository(project);
        RevWalk revWalk = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter()) {
        ObjectId noteId = null;
        for (ObjectId commitToBan : commitsToBan) {
            try {
                revWalk.parseCommit(commitToBan);
            } catch (MissingObjectException e) {
            // Ignore exception, non-existing commits can be banned.
            } catch (IncorrectObjectTypeException e) {
                result.notACommit(commitToBan);
                continue;
            }
            if (noteId == null) {
                noteId = createNoteContent(reason, inserter);
            }
            banCommitNotes.set(commitToBan, noteId);
        }
        NotesBranchUtil notesBranchUtil = notesBranchUtilFactory.create(project, repo, inserter);
        NoteMap newlyCreated = notesBranchUtil.commitNewNotes(banCommitNotes, REFS_REJECT_COMMITS, createPersonIdent(), buildCommitMessage(commitsToBan, reason));
        for (Note n : banCommitNotes) {
            if (newlyCreated.contains(n)) {
                result.commitBanned(n);
            } else {
                result.commitAlreadyBanned(n);
            }
        }
        return result;
    }
}
#method_after
public BanCommitResult ban(ProjectControl projectControl, List<ObjectId> commitsToBan, String reason) throws AuthException, LockFailureException, IOException, PermissionBackendException {
    permissionBackend.user(projectControl.getUser()).project(projectControl.getProject().getNameKey()).check(ProjectPermission.BAN_COMMIT);
    final BanCommitResult result = new BanCommitResult();
    NoteMap banCommitNotes = NoteMap.newEmptyMap();
    // Add a note for each banned commit to notes.
    final Project.NameKey project = projectControl.getProject().getNameKey();
    try (Repository repo = repoManager.openRepository(project);
        RevWalk revWalk = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter()) {
        ObjectId noteId = null;
        for (ObjectId commitToBan : commitsToBan) {
            try {
                revWalk.parseCommit(commitToBan);
            } catch (MissingObjectException e) {
            // Ignore exception, non-existing commits can be banned.
            } catch (IncorrectObjectTypeException e) {
                result.notACommit(commitToBan);
                continue;
            }
            if (noteId == null) {
                noteId = createNoteContent(reason, inserter);
            }
            banCommitNotes.set(commitToBan, noteId);
        }
        NotesBranchUtil notesBranchUtil = notesBranchUtilFactory.create(project, repo, inserter);
        NoteMap newlyCreated = notesBranchUtil.commitNewNotes(banCommitNotes, REFS_REJECT_COMMITS, createPersonIdent(), buildCommitMessage(commitsToBan, reason));
        for (Note n : banCommitNotes) {
            if (newlyCreated.contains(n)) {
                result.commitBanned(n);
            } else {
                result.commitAlreadyBanned(n);
            }
        }
        return result;
    }
}
#end_block

#method_before
public String getRefName() {
    return refName;
}
#method_after
String getRefName() {
    return refName;
}
#end_block

#method_before
public ProjectControl getProjectControl() {
    return projectControl;
}
#method_after
ProjectControl getProjectControl() {
    return projectControl;
}
#end_block

#method_before
public CurrentUser getUser() {
    return projectControl.getUser();
}
#method_after
CurrentUser getUser() {
    return projectControl.getUser();
}
#end_block

#method_before
public RefControl forUser(CurrentUser who) {
    ProjectControl newCtl = projectControl.forUser(who);
    if (relevant.isUserSpecific()) {
        return newCtl.controlForRef(getRefName());
    }
    return new RefControl(newCtl, getRefName(), relevant);
}
#method_after
RefControl forUser(CurrentUser who) {
    ProjectControl newCtl = projectControl.forUser(who);
    if (relevant.isUserSpecific()) {
        return newCtl.controlForRef(getRefName());
    }
    return new RefControl(newCtl, getRefName(), relevant);
}
#end_block

#method_before
public boolean isOwner() {
    if (owner == null) {
        if (canPerform(Permission.OWNER)) {
            owner = true;
        } else {
            owner = projectControl.isOwner();
        }
    }
    return owner;
}
#method_after
boolean isOwner() {
    if (owner == null) {
        if (canPerform(Permission.OWNER)) {
            owner = true;
        } else {
            owner = projectControl.isOwner();
        }
    }
    return owner;
}
#end_block

#method_before
public boolean isBlocked(String permissionName) {
    return !doCanPerform(permissionName, false, true);
}
#method_after
boolean isBlocked(String permissionName) {
    return !doCanPerform(permissionName, false, true);
}
#end_block

#method_before
private boolean can(RefPermission perm) throws PermissionBackendException {
    switch(perm) {
        case READ:
            return isVisible();
        case CREATE:
            // TODO This isn't an accurate test.
            return canPerform(perm.permissionName().get());
        case DELETE:
            return canDelete();
        case UPDATE:
            return canUpdate();
        case FORCE_UPDATE:
            return canForceUpdate();
        case SET_HEAD:
            return projectControl.isOwner();
        case FORGE_AUTHOR:
            return canForgeAuthor();
        case FORGE_COMMITTER:
            return canForgeCommitter();
        case FORGE_SERVER:
            return canForgeGerritServerIdentity();
        case MERGE:
            return canUploadMerges();
        case CREATE_CHANGE:
            return canUpload();
        case UPDATE_BY_SUBMIT:
            return projectControl.controlForRef("refs/for/" + getRefName()).canSubmit(true);
        case SKIP_VALIDATION:
            return canForgeAuthor() && canForgeCommitter() && canForgeGerritServerIdentity() && canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#method_after
private boolean can(RefPermission perm) throws PermissionBackendException {
    switch(perm) {
        case READ:
            return isVisible();
        case CREATE:
            // TODO This isn't an accurate test.
            return canPerform(perm.permissionName().get());
        case DELETE:
            return canDelete();
        case UPDATE:
            return canUpdate();
        case FORCE_UPDATE:
            return canForceUpdate();
        case SET_HEAD:
            return projectControl.isOwner();
        case FORGE_AUTHOR:
            return canForgeAuthor();
        case FORGE_COMMITTER:
            return canForgeCommitter();
        case FORGE_SERVER:
            return canForgeGerritServerIdentity();
        case MERGE:
            return canUploadMerges();
        case CREATE_CHANGE:
            return canUpload();
        case UPDATE_BY_SUBMIT:
            return projectControl.controlForRef("refs/for/" + getRefName()).canSubmit(true);
        case READ_PRIVATE_CHANGES:
            return canViewPrivateChanges();
        case READ_CONFIG:
            return projectControl.controlForRef(RefNames.REFS_CONFIG).canPerform(RefPermission.READ.name());
        case WRITE_CONFIG:
            return isOwner();
        case SKIP_VALIDATION:
            return canForgeAuthor() && canForgeCommitter() && canForgeGerritServerIdentity() && canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy();
    }
    throw new PermissionBackendException(perm + " unsupported");
}
#end_block

#method_before
@Override
public String apply(ProjectResource rsrc) throws AuthException, ResourceNotFoundException, IOException, PermissionBackendException {
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        Ref head = repo.getRefDatabase().exactRef(Constants.HEAD);
        if (head == null) {
            throw new ResourceNotFoundException(Constants.HEAD);
        } else if (head.isSymbolic()) {
            String n = head.getTarget().getName();
            permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey()).ref(n).check(RefPermission.READ);
            return n;
        } else if (head.getObjectId() != null) {
            try (RevWalk rw = new RevWalk(repo)) {
                RevCommit commit = rw.parseCommit(head.getObjectId());
                if (commits.canRead(rsrc.getProjectState(), repo, commit)) {
                    return head.getObjectId().name();
                }
                throw new AuthException("not allowed to see HEAD");
            } catch (MissingObjectException | IncorrectObjectTypeException e) {
                throw new AuthException("not allowed to see HEAD");
            }
        }
        throw new ResourceNotFoundException(Constants.HEAD);
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
}
#method_after
@Override
public String apply(ProjectResource rsrc) throws AuthException, ResourceNotFoundException, IOException, PermissionBackendException {
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        Ref head = repo.getRefDatabase().exactRef(Constants.HEAD);
        if (head == null) {
            throw new ResourceNotFoundException(Constants.HEAD);
        } else if (head.isSymbolic()) {
            String n = head.getTarget().getName();
            permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey()).ref(n).check(RefPermission.READ);
            return n;
        } else if (head.getObjectId() != null) {
            try (RevWalk rw = new RevWalk(repo)) {
                RevCommit commit = rw.parseCommit(head.getObjectId());
                if (commits.canRead(rsrc.getProjectState(), repo, commit)) {
                    return head.getObjectId().name();
                }
                throw new AuthException("not allowed to see HEAD");
            } catch (MissingObjectException | IncorrectObjectTypeException e) {
                try {
                    permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey()).check(ProjectPermission.WRITE_CONFIG);
                } catch (AuthException ae) {
                    throw new AuthException("not allowed to see HEAD");
                }
            }
        }
        throw new ResourceNotFoundException(Constants.HEAD);
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
}
#end_block

#method_before
@Override
public ConfigInfo apply(ProjectResource rsrc, ConfigInput input) throws RestApiException, PermissionBackendException {
    permissionBackend.user(user).project(rsrc.getNameKey()).check(ProjectPermission.WRITE_ACCESS);
    return apply(rsrc.getProjectState(), input);
}
#method_after
@Override
public ConfigInfo apply(ProjectResource rsrc, ConfigInput input) throws RestApiException, PermissionBackendException {
    permissionBackend.user(user).project(rsrc.getNameKey()).check(ProjectPermission.WRITE_CONFIG);
    return apply(rsrc.getProjectState(), input);
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(ProjectResource rsrc, ProjectAccessInput input) throws PermissionBackendException, PermissionDeniedException, IOException, ConfigInvalidException, OrmException, InvalidNameException, UpdateException, RestApiException {
    PermissionBackend.ForProject forProject = permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey());
    if (!check(forProject, ProjectPermission.READ_ACCESS)) {
        throw new PermissionDeniedException(RefNames.REFS_CONFIG + " not visible");
    }
    if (!check(forProject, ProjectPermission.WRITE_ACCESS)) {
        try {
            forProject.ref(RefNames.REFS_CONFIG).check(RefPermission.CREATE_CHANGE);
        } catch (AuthException denied) {
            throw new PermissionDeniedException("cannot create change for " + RefNames.REFS_CONFIG);
        }
    }
    MetaDataUpdate.User metaDataUpdateUser = metaDataUpdateFactory.get();
    List<AccessSection> removals = setAccess.getAccessSections(input.remove);
    List<AccessSection> additions = setAccess.getAccessSections(input.add);
    Project.NameKey newParentProjectName = input.parent == null ? null : new Project.NameKey(input.parent);
    try (MetaDataUpdate md = metaDataUpdateUser.create(rsrc.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        setAccess.validateChanges(config, removals, additions);
        setAccess.applyChanges(config, removals, additions);
        try {
            setAccess.setParentName(rsrc.getUser().asIdentifiedUser(), config, rsrc.getNameKey(), newParentProjectName, false);
        } catch (AuthException e) {
            throw new IllegalStateException(e);
        }
        md.setMessage("Review access change");
        md.setInsertChangeId(true);
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
        try (ObjectInserter objInserter = md.getRepository().newObjectInserter();
            ObjectReader objReader = objInserter.newReader();
            RevWalk rw = new RevWalk(objReader);
            BatchUpdate bu = updateFactory.create(db.get(), rsrc.getNameKey(), rsrc.getUser(), TimeUtil.nowTs())) {
            bu.setRepository(md.getRepository(), rw, objInserter);
            ChangeInserter ins = newInserter(changeId, commit);
            bu.insertChange(ins);
            bu.execute();
            return Response.created(jsonFactory.noOptions().format(ins.getChange()));
        }
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(ProjectResource rsrc, ProjectAccessInput input) throws PermissionBackendException, PermissionDeniedException, IOException, ConfigInvalidException, OrmException, InvalidNameException, UpdateException, RestApiException {
    PermissionBackend.ForProject forProject = permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey());
    if (!check(forProject, ProjectPermission.READ_CONFIG)) {
        throw new PermissionDeniedException(RefNames.REFS_CONFIG + " not visible");
    }
    if (!check(forProject, ProjectPermission.WRITE_CONFIG)) {
        try {
            forProject.ref(RefNames.REFS_CONFIG).check(RefPermission.CREATE_CHANGE);
        } catch (AuthException denied) {
            throw new PermissionDeniedException("cannot create change for " + RefNames.REFS_CONFIG);
        }
    }
    MetaDataUpdate.User metaDataUpdateUser = metaDataUpdateFactory.get();
    List<AccessSection> removals = setAccess.getAccessSections(input.remove);
    List<AccessSection> additions = setAccess.getAccessSections(input.add);
    Project.NameKey newParentProjectName = input.parent == null ? null : new Project.NameKey(input.parent);
    try (MetaDataUpdate md = metaDataUpdateUser.create(rsrc.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        setAccess.validateChanges(config, removals, additions);
        setAccess.applyChanges(config, removals, additions);
        try {
            setAccess.setParentName(rsrc.getUser().asIdentifiedUser(), config, rsrc.getNameKey(), newParentProjectName, false);
        } catch (AuthException e) {
            throw new IllegalStateException(e);
        }
        md.setMessage("Review access change");
        md.setInsertChangeId(true);
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
        try (ObjectInserter objInserter = md.getRepository().newObjectInserter();
            ObjectReader objReader = objInserter.newReader();
            RevWalk rw = new RevWalk(objReader);
            BatchUpdate bu = updateFactory.create(db.get(), rsrc.getNameKey(), rsrc.getUser(), TimeUtil.nowTs())) {
            bu.setRepository(md.getRepository(), rw, objInserter);
            ChangeInserter ins = newInserter(changeId, commit);
            bu.insertChange(ins);
            bu.execute();
            return Response.created(jsonFactory.noOptions().format(ins.getChange()));
        }
    }
}
#end_block

#method_before
@Override
public List<ReflogEntryInfo> apply(BranchResource rsrc) throws RestApiException, IOException, PermissionBackendException {
    permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey()).check(ProjectPermission.READ_REF_LOG);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        ReflogReader r;
        try {
            r = repo.getReflogReader(rsrc.getRef());
        } catch (UnsupportedOperationException e) {
            String msg = "reflog not supported on repo " + rsrc.getNameKey().get();
            log.error(msg);
            throw new MethodNotAllowedException(msg);
        }
        if (r == null) {
            throw new ResourceNotFoundException(rsrc.getRef());
        }
        List<ReflogEntry> entries;
        if (from == null && to == null) {
            entries = limit > 0 ? r.getReverseEntries(limit) : r.getReverseEntries();
        } else {
            entries = limit > 0 ? new ArrayList<>(limit) : new ArrayList<>();
            for (ReflogEntry e : r.getReverseEntries()) {
                Timestamp timestamp = new Timestamp(e.getWho().getWhen().getTime());
                if ((from == null || from.before(timestamp)) && (to == null || to.after(timestamp))) {
                    entries.add(e);
                }
                if (limit > 0 && entries.size() >= limit) {
                    break;
                }
            }
        }
        return Lists.transform(entries, e -> newReflogEntryInfo(e));
    }
}
#method_after
@Override
public List<ReflogEntryInfo> apply(BranchResource rsrc) throws RestApiException, IOException, PermissionBackendException {
    permissionBackend.user(rsrc.getUser()).project(rsrc.getNameKey()).check(ProjectPermission.READ_REFLOG);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        ReflogReader r;
        try {
            r = repo.getReflogReader(rsrc.getRef());
        } catch (UnsupportedOperationException e) {
            String msg = "reflog not supported on repo " + rsrc.getNameKey().get();
            log.error(msg);
            throw new MethodNotAllowedException(msg);
        }
        if (r == null) {
            throw new ResourceNotFoundException(rsrc.getRef());
        }
        List<ReflogEntry> entries;
        if (from == null && to == null) {
            entries = limit > 0 ? r.getReverseEntries(limit) : r.getReverseEntries();
        } else {
            entries = limit > 0 ? new ArrayList<>(limit) : new ArrayList<>();
            for (ReflogEntry e : r.getReverseEntries()) {
                Timestamp timestamp = new Timestamp(e.getWho().getWhen().getTime());
                if ((from == null || from.before(timestamp)) && (to == null || to.after(timestamp))) {
                    entries.add(e);
                }
                if (limit > 0 && entries.size() >= limit) {
                    break;
                }
            }
        }
        return Lists.transform(entries, e -> newReflogEntryInfo(e));
    }
}
#end_block

#method_before
private Optional<ChangedLines> computeChangedLines() throws OrmException {
    Change c = change();
    if (c == null) {
        return Optional.empty();
    }
    PatchSet ps = currentPatchSet();
    if (ps == null) {
        return Optional.empty();
    }
    return getPatchList(c, ps).map(p -> new ChangedLines(p.getInsertions(), p.getDeletions()));
}
#method_after
private Optional<ChangedLines> computeChangedLines() throws OrmException {
    Change c = change();
    if (c == null) {
        return Optional.empty();
    }
    PatchSet ps = currentPatchSet();
    if (ps == null) {
        return Optional.empty();
    }
    Optional<DiffSummary> ds = getDiffSummary(c, ps);
    if (ds.isPresent()) {
        return Optional.of(ds.get().getChangedLines());
    }
    return Optional.empty();
}
#end_block

#method_before
public ImmutableListMultimap<Account.Id, String> stars() throws OrmException {
    if (stars == null) {
        if (!lazyLoad) {
            return ImmutableListMultimap.of();
        }
        ImmutableListMultimap.Builder<Account.Id, String> b = ImmutableListMultimap.builder();
        for (Map.Entry<Account.Id, StarRef> e : starRefs().entrySet()) {
            b.putAll(e.getKey(), e.getValue().labels());
        }
        return b.build();
    }
    return stars;
}
#method_after
public Set<String> stars(Account.Id accountId) throws OrmException {
    if (starsOf != null) {
        if (!starsOf.accountId().equals(accountId)) {
            starsOf = null;
        }
    }
    if (starsOf == null) {
        if (stars != null) {
            starsOf = StarsOf.create(accountId, stars.get(accountId));
        } else {
            if (!lazyLoad) {
                return ImmutableSet.of();
            }
            starsOf = StarsOf.create(accountId, starredChangesUtil.getLabels(accountId, legacyId));
        }
    }
    return starsOf.stars();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> has(String value) throws QueryParseException {
    if ("star".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("stars".equalsIgnoreCase(value)) {
        return new HasStarsPredicate(self());
    }
    if ("draft".equalsIgnoreCase(value)) {
        return draftby(self());
    }
    if ("edit".equalsIgnoreCase(value)) {
        return new EditByPredicate(self());
    }
    // for plugins the value will be operandName_pluginName
    String[] names = value.split("_");
    if (names.length == 2) {
        ChangeHasOperandFactory op = args.hasOperands.get(names[1], names[0]);
        if (op != null) {
            return op.create(this);
        }
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> has(String value) throws QueryParseException {
    if ("star".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("stars".equalsIgnoreCase(value)) {
        return new HasStarsPredicate(self());
    }
    if ("draft".equalsIgnoreCase(value)) {
        return draftby(self());
    }
    if ("edit".equalsIgnoreCase(value)) {
        return new EditByPredicate(self());
    }
    if ("unresolved".equalsIgnoreCase(value)) {
        return new IsUnresolvedPredicate();
    }
    // for plugins the value will be operandName_pluginName
    String[] names = value.split("_");
    if (names.length == 2) {
        ChangeHasOperandFactory op = args.hasOperands.get(names[1], names[0]);
        if (op != null) {
            return op.create(this);
        }
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
private ChangeData toChangeData(ListMultimap<String, IndexableField> doc, Set<String> fields, String idFieldName) {
    ChangeData cd;
    // Either change or the ID field was guaranteed to be included in the call
    // to fields() above.
    IndexableField cb = Iterables.getFirst(doc.get(CHANGE_FIELD), null);
    if (cb != null) {
        BytesRef proto = cb.binaryValue();
        cd = changeDataFactory.create(db.get(), ChangeProtoField.CODEC.decode(proto.bytes, proto.offset, proto.length));
    } else {
        IndexableField f = Iterables.getFirst(doc.get(idFieldName), null);
        Change.Id id = new Change.Id(f.numericValue().intValue());
        IndexableField project = Iterables.getFirst(doc.get(PROJECT.getName()), null);
        if (project == null) {
            // Old schema without project field: we can safely assume NoteDb is
            // disabled.
            cd = changeDataFactory.createOnlyWhenNoteDbDisabled(db.get(), id);
        } else {
            cd = changeDataFactory.create(db.get(), new Project.NameKey(project.stringValue()), id);
        }
    }
    if (fields.contains(PATCH_SET_FIELD)) {
        decodePatchSets(doc, cd);
    }
    if (fields.contains(APPROVAL_FIELD)) {
        decodeApprovals(doc, cd);
    }
    if (fields.contains(ADDED_FIELD) && fields.contains(DELETED_FIELD)) {
        decodeChangedLines(doc, cd);
    }
    if (fields.contains(MERGEABLE_FIELD)) {
        decodeMergeable(doc, cd);
    }
    if (fields.contains(REVIEWEDBY_FIELD)) {
        decodeReviewedBy(doc, cd);
    }
    if (fields.contains(HASHTAG_FIELD)) {
        decodeHashtags(doc, cd);
    }
    if (fields.contains(STAR_FIELD)) {
        decodeStar(doc, cd);
    }
    if (fields.contains(REVIEWER_FIELD)) {
        decodeReviewers(doc, cd);
    }
    decodeSubmitRecords(doc, SUBMIT_RECORD_STRICT_FIELD, ChangeField.SUBMIT_RULE_OPTIONS_STRICT, cd);
    decodeSubmitRecords(doc, SUBMIT_RECORD_LENIENT_FIELD, ChangeField.SUBMIT_RULE_OPTIONS_LENIENT, cd);
    if (fields.contains(REF_STATE_FIELD)) {
        decodeRefStates(doc, cd);
    }
    if (fields.contains(REF_STATE_PATTERN_FIELD)) {
        decodeRefStatePatterns(doc, cd);
    }
    if (fields.contains(UNRESOLVED_COMMENTS_NUM_FIELD)) {
        decodeUnresolvedCommentsNum(doc, cd);
    }
    return cd;
}
#method_after
private ChangeData toChangeData(ListMultimap<String, IndexableField> doc, Set<String> fields, String idFieldName) {
    ChangeData cd;
    // Either change or the ID field was guaranteed to be included in the call
    // to fields() above.
    IndexableField cb = Iterables.getFirst(doc.get(CHANGE_FIELD), null);
    if (cb != null) {
        BytesRef proto = cb.binaryValue();
        cd = changeDataFactory.create(db.get(), ChangeProtoField.CODEC.decode(proto.bytes, proto.offset, proto.length));
    } else {
        IndexableField f = Iterables.getFirst(doc.get(idFieldName), null);
        Change.Id id = new Change.Id(f.numericValue().intValue());
        IndexableField project = Iterables.getFirst(doc.get(PROJECT.getName()), null);
        if (project == null) {
            // Old schema without project field: we can safely assume NoteDb is
            // disabled.
            cd = changeDataFactory.createOnlyWhenNoteDbDisabled(db.get(), id);
        } else {
            cd = changeDataFactory.create(db.get(), new Project.NameKey(project.stringValue()), id);
        }
    }
    if (fields.contains(PATCH_SET_FIELD)) {
        decodePatchSets(doc, cd);
    }
    if (fields.contains(APPROVAL_FIELD)) {
        decodeApprovals(doc, cd);
    }
    if (fields.contains(ADDED_FIELD) && fields.contains(DELETED_FIELD)) {
        decodeChangedLines(doc, cd);
    }
    if (fields.contains(MERGEABLE_FIELD)) {
        decodeMergeable(doc, cd);
    }
    if (fields.contains(REVIEWEDBY_FIELD)) {
        decodeReviewedBy(doc, cd);
    }
    if (fields.contains(HASHTAG_FIELD)) {
        decodeHashtags(doc, cd);
    }
    if (fields.contains(STAR_FIELD)) {
        decodeStar(doc, cd);
    }
    if (fields.contains(REVIEWER_FIELD)) {
        decodeReviewers(doc, cd);
    }
    decodeSubmitRecords(doc, SUBMIT_RECORD_STRICT_FIELD, ChangeField.SUBMIT_RULE_OPTIONS_STRICT, cd);
    decodeSubmitRecords(doc, SUBMIT_RECORD_LENIENT_FIELD, ChangeField.SUBMIT_RULE_OPTIONS_LENIENT, cd);
    if (fields.contains(REF_STATE_FIELD)) {
        decodeRefStates(doc, cd);
    }
    if (fields.contains(REF_STATE_PATTERN_FIELD)) {
        decodeRefStatePatterns(doc, cd);
    }
    decodeUnresolvedCommentCount(doc, cd);
    return cd;
}
#end_block

#method_before
@Override
public Repository createRepository(Project.NameKey name) throws RepositoryNotFoundException, RepositoryCaseMismatchException, IOException {
    Path path = getBasePath(name);
    if (isUnreasonableName(name)) {
        throw new RepositoryNotFoundException("Invalid name: " + name);
    }
    File dir = FileKey.resolve(path.resolve(name.get()).toFile(), FS.DETECTED);
    FileKey loc;
    if (dir != null) {
        // Already exists on disk, use the repository we found.
        // 
        Project.NameKey onDiskName = getProjectName(path, dir.getCanonicalFile().toPath());
        if (!onDiskName.equals(name)) {
            throw new RepositoryCaseMismatchException(name);
        }
        throw new IllegalStateException("Repository already exists: " + name);
    }
    // It doesn't exist under any of the standard permutations
    // of the repository name, so prefer the standard bare name.
    // 
    String n = name.get() + Constants.DOT_GIT_EXT;
    loc = FileKey.exact(path.resolve(n).toFile(), FS.DETECTED);
    try {
        Repository db = RepositoryCache.open(loc, false);
        db.create(true);
        StoredConfig config = db.getConfig();
        config.setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_LOGALLREFUPDATES, true);
        config.save();
        // JGit only writes to the reflog for refs/meta/config if the log file
        // already exists.
        // 
        File metaConfigLog = new File(db.getDirectory(), "logs/" + RefNames.REFS_CONFIG);
        if (!metaConfigLog.getParentFile().mkdirs() || !metaConfigLog.createNewFile()) {
            log.error(String.format("Failed to create ref log for %s in repository %s", RefNames.REFS_CONFIG, name));
        }
        return db;
    } catch (IOException e1) {
        final RepositoryNotFoundException e2;
        e2 = new RepositoryNotFoundException("Cannot create repository " + name);
        e2.initCause(e1);
        throw e2;
    }
}
#method_after
@Override
public Repository createRepository(Project.NameKey name) throws RepositoryNotFoundException, RepositoryCaseMismatchException, IOException {
    Path path = getBasePath(name);
    if (isUnreasonableName(name)) {
        throw new RepositoryNotFoundException("Invalid name: " + name);
    }
    File dir = FileKey.resolve(path.resolve(name.get()).toFile(), FS.DETECTED);
    if (dir != null) {
        // Already exists on disk, use the repository we found.
        // 
        Project.NameKey onDiskName = getProjectName(path, dir.getCanonicalFile().toPath());
        if (!onDiskName.equals(name)) {
            throw new RepositoryCaseMismatchException(name);
        }
        throw new IllegalStateException("Repository already exists: " + name);
    }
    // It doesn't exist under any of the standard permutations
    // of the repository name, so prefer the standard bare name.
    // 
    String n = name.get() + Constants.DOT_GIT_EXT;
    FileKey loc = FileKey.exact(path.resolve(n).toFile(), FS.DETECTED);
    try {
        Repository db = RepositoryCache.open(loc, false);
        db.create(true);
        StoredConfig config = db.getConfig();
        config.setBoolean(ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_LOGALLREFUPDATES, true);
        config.save();
        // JGit only writes to the reflog for refs/meta/config if the log file
        // already exists.
        // 
        File metaConfigLog = new File(db.getDirectory(), "logs/" + RefNames.REFS_CONFIG);
        if (!metaConfigLog.getParentFile().mkdirs() || !metaConfigLog.createNewFile()) {
            log.error(String.format("Failed to create ref log for %s in repository %s", RefNames.REFS_CONFIG, name));
        }
        return db;
    } catch (IOException e1) {
        final RepositoryNotFoundException e2;
        e2 = new RepositoryNotFoundException("Cannot create repository " + name);
        e2.initCause(e1);
        throw e2;
    }
}
#end_block

#method_before
void cacheVisibleTo(ChangeControl ctl) {
    visibleTo = ctl.getUser();
}
#method_after
void cacheVisibleTo(ChangeControl ctl) {
    visibleTo = ctl.getUser();
    changeControl = ctl;
}
#end_block

#method_before
public Boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else if (c.getStatus() == Change.Status.ABANDONED) {
            return null;
        } else if (c.isWorkInProgress()) {
            return null;
        } else {
            if (!lazyLoad) {
                return null;
            }
            PatchSet ps = currentPatchSet();
            try {
                if (ps == null || !changeControlFactory.controlFor(db, change(), userFactory.create(c.getOwner())).isPatchVisible(ps, db)) {
                    return null;
                }
            } catch (OrmException e) {
                if (e.getCause() instanceof NoSuchChangeException) {
                    return null;
                }
                throw e;
            }
            try (Repository repo = repoManager.openRepository(project())) {
                Ref ref = repo.getRefDatabase().exactRef(c.getDest().get());
                SubmitTypeRecord str = submitTypeRecord();
                if (!str.isOk()) {
                    // No need to log, as SubmitRuleEvaluator already did it for us.
                    return false;
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
    }
    return mergeable;
}
#method_after
public Boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else if (c.getStatus() == Change.Status.ABANDONED) {
            return null;
        } else if (c.isWorkInProgress()) {
            return null;
        } else {
            if (!lazyLoad) {
                return null;
            }
            PatchSet ps = currentPatchSet();
            try {
                if (ps == null || !changeControl().isPatchVisible(ps, db)) {
                    return null;
                }
            } catch (OrmException e) {
                if (e.getCause() instanceof NoSuchChangeException) {
                    return null;
                }
                throw e;
            }
            try (Repository repo = repoManager.openRepository(project())) {
                Ref ref = repo.getRefDatabase().exactRef(c.getDest().get());
                SubmitTypeRecord str = submitTypeRecord();
                if (!str.isOk()) {
                    // No need to log, as SubmitRuleEvaluator already did it for us.
                    return false;
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
    }
    return mergeable;
}
#end_block

#method_before
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes, CurrentUser user) throws IOException, OrmException, PermissionBackendException {
    Collection<ChangeData> visibleChanges = new ArrayList<>();
    Collection<ChangeData> nonVisibleChanges = new ArrayList<>();
    // For each target branch we run a separate rev walk to find open changes
    // reachable from changes already in the merge super set.
    ImmutableListMultimap<Branch.NameKey, ChangeData> bc = byBranch(Iterables.concat(changes.changes(), changes.nonVisibleChanges()));
    for (Branch.NameKey b : bc.keySet()) {
        OpenRepo or = getRepo(b.getParentKey());
        List<RevCommit> visibleCommits = new ArrayList<>();
        List<RevCommit> nonVisibleCommits = new ArrayList<>();
        for (ChangeData cd : bc.get(b)) {
            boolean visible = changes.ids().contains(cd.getId());
            if (visible && !canRead(db, user, cd)) {
                // We thought the change was visible, but it isn't.
                // This can happen if the ACL changes during the
                // completeChangeSet computation, for example.
                visible = false;
            }
            Collection<RevCommit> toWalk = visible ? visibleCommits : nonVisibleCommits;
            // Pick a revision to use for traversal.  If any of the patch sets
            // is visible, we use the most recent one.  Otherwise, use the current
            // patch set.
            PatchSet ps = cd.currentPatchSet();
            boolean visiblePatchSet = visible;
            ChangeControl ctl = changeControlFactory.controlFor(cd.notes(), user);
            if (!ctl.isPatchVisible(ps, cd)) {
                Iterable<PatchSet> visiblePatchSets = ctl.getVisiblePatchSets(cd.patchSets(), db);
                if (Iterables.isEmpty(visiblePatchSets)) {
                    visiblePatchSet = false;
                } else {
                    ps = Iterables.getLast(visiblePatchSets);
                }
            }
            if (submitType(user, cd, ps, visiblePatchSet) == SubmitType.CHERRY_PICK) {
                if (visible) {
                    visibleChanges.add(cd);
                } else {
                    nonVisibleChanges.add(cd);
                }
                continue;
            }
            // Get the underlying git commit object
            String objIdStr = ps.getRevision().get();
            RevCommit commit = or.rw.parseCommit(ObjectId.fromString(objIdStr));
            // Always include the input, even if merged. This allows
            // SubmitStrategyOp to correct the situation later, assuming it gets
            // returned by byCommitsOnBranchNotMerged below.
            toWalk.add(commit);
        }
        Set<String> emptySet = Collections.emptySet();
        Set<String> visibleHashes = walkChangesByHashes(visibleCommits, emptySet, or, b);
        List<ChangeData> cds = byCommitsOnBranchNotMerged(or, db, b, visibleHashes);
        for (ChangeData chd : cds) {
            visibleChanges.add(chd);
        }
        Set<String> nonVisibleHashes = walkChangesByHashes(nonVisibleCommits, visibleHashes, or, b);
        Iterables.addAll(nonVisibleChanges, byCommitsOnBranchNotMerged(or, db, b, nonVisibleHashes));
    }
    return new ChangeSet(visibleChanges, nonVisibleChanges);
}
#method_after
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes, CurrentUser user) throws IOException, OrmException, PermissionBackendException {
    Collection<ChangeData> visibleChanges = new ArrayList<>();
    Collection<ChangeData> nonVisibleChanges = new ArrayList<>();
    // For each target branch we run a separate rev walk to find open changes
    // reachable from changes already in the merge super set.
    ImmutableListMultimap<Branch.NameKey, ChangeData> bc = byBranch(Iterables.concat(changes.changes(), changes.nonVisibleChanges()));
    for (Branch.NameKey b : bc.keySet()) {
        OpenRepo or = getRepo(b.getParentKey());
        List<RevCommit> visibleCommits = new ArrayList<>();
        List<RevCommit> nonVisibleCommits = new ArrayList<>();
        for (ChangeData cd : bc.get(b)) {
            boolean visible = changes.ids().contains(cd.getId());
            if (visible && !canRead(db, user, cd)) {
                // We thought the change was visible, but it isn't.
                // This can happen if the ACL changes during the
                // completeChangeSet computation, for example.
                visible = false;
            }
            // Pick a revision to use for traversal.  If any of the patch sets
            // is visible, we use the most recent one.  Otherwise, use the current
            // patch set.
            PatchSet ps = cd.currentPatchSet();
            boolean visiblePatchSet = visible;
            ChangeControl ctl = changeControlFactory.controlFor(cd.notes(), user);
            if (!ctl.isPatchVisible(ps, cd)) {
                Iterable<PatchSet> visiblePatchSets = ctl.getVisiblePatchSets(cd.patchSets(), db);
                if (Iterables.isEmpty(visiblePatchSets)) {
                    visiblePatchSet = false;
                } else {
                    ps = Iterables.getLast(visiblePatchSets);
                }
            }
            if (submitType(user, cd, ps, visiblePatchSet) == SubmitType.CHERRY_PICK) {
                if (visible) {
                    visibleChanges.add(cd);
                } else {
                    nonVisibleChanges.add(cd);
                }
                continue;
            }
            // Get the underlying git commit object
            String objIdStr = ps.getRevision().get();
            RevCommit commit = or.rw.parseCommit(ObjectId.fromString(objIdStr));
            // returned by byCommitsOnBranchNotMerged below.
            if (visible) {
                visibleCommits.add(commit);
            } else {
                nonVisibleCommits.add(commit);
            }
        }
        Set<String> visibleHashes = walkChangesByHashes(visibleCommits, Collections.emptySet(), or, b);
        Iterables.addAll(visibleChanges, byCommitsOnBranchNotMerged(or, db, b, visibleHashes));
        Set<String> nonVisibleHashes = walkChangesByHashes(nonVisibleCommits, visibleHashes, or, b);
        Iterables.addAll(nonVisibleChanges, byCommitsOnBranchNotMerged(or, db, b, nonVisibleHashes));
    }
    return new ChangeSet(visibleChanges, nonVisibleChanges);
}
#end_block

#method_before
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | PermissionBackendException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#method_after
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | PermissionBackendException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else if (e instanceof NoSuchChangeException) {
                    log.info("NoSuchChangeException: Omitting corrupt change " + cd.getId() + " from results. Seems to be stale in the index.");
                    continue;
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.WithUser withUser = permissionBackend.user(user).database(db);
    PermissionBackend.ForChange perm = lazyLoad ? withUser.change(cd) : withUser.indexedChange(cd, notesFactory.createFromIndexedChange(cd.change()));
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
        }
    }
    out.labels = labelsFor(perm, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.WithUser withUser = permissionBackend.user(user).database(db);
    PermissionBackend.ForChange perm = lazyLoad ? withUser.change(cd) : withUser.indexedChange(cd, notesFactory.createFromIndexedChange(cd.change()));
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
        }
    }
    out.labels = labelsFor(perm, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    ChangeControl ctl = null;
    if (needMessages || needRevisions) {
        ctl = changeControlFactory.controlFor(db.get(), cd.change(), userProvider.get());
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#end_block

#method_before
private Map<String, Short> currentLabels(PermissionBackend.ForChange perm, ChangeData cd) throws OrmException {
    IdentifiedUser user = perm.user().asIdentifiedUser();
    Map<String, Short> result = new HashMap<>();
    for (PatchSetApproval psa : approvalsUtil.byPatchSetUser(db.get(), cd.notes(), user, cd.change().currentPatchSetId(), user.getAccountId(), null, null)) {
        result.put(psa.getLabel(), psa.getValue());
    }
    return result;
}
#method_after
private Map<String, Short> currentLabels(PermissionBackend.ForChange perm, ChangeData cd) throws OrmException {
    IdentifiedUser user = perm.user().asIdentifiedUser();
    Map<String, Short> result = new HashMap<>();
    for (PatchSetApproval psa : approvalsUtil.byPatchSetUser(db.get(), lazyLoad ? cd.notes() : notesFactory.createFromIndexedChange(cd.change()), user, cd.change().currentPatchSetId(), user.getAccountId(), null, null)) {
        result.put(psa.getLabel(), psa.getValue());
    }
    return result;
}
#end_block

#method_before
private Collection<ChangeMessageInfo> messages(ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    ChangeControl ctl = changeControlFactory.controlFor(db.get(), cd.change(), userProvider.get());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            Account.Id realAuthor = message.getRealAuthor();
            if (realAuthor != null) {
                cmi.realAuthor = accountLoader.get(realAuthor);
            }
            result.add(cmi);
        }
    }
    return result;
}
#method_after
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            Account.Id realAuthor = message.getRealAuthor();
            if (realAuthor != null) {
                cmi.realAuthor = accountLoader.get(realAuthor);
            }
            result.add(cmi);
        }
    }
    return result;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeData cd, Map<PatchSet.Id, PatchSet> map, Optional<PatchSet.Id> limitToPsId, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    ChangeControl ctl = changeControlFactory.controlFor(db.get(), cd.change(), userProvider.get());
    try (Repository repo = openRepoIfNecessary(cd.project());
        RevWalk rw = newRevWalk(repo)) {
        for (PatchSet in : map.values()) {
            PatchSet.Id id = in.getId();
            boolean want = false;
            if (has(ALL_REVISIONS)) {
                want = true;
            } else if (limitToPsId.isPresent()) {
                want = id.equals(limitToPsId.get());
            } else {
                want = id.equals(cd.change().currentPatchSetId());
            }
            if (want && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(cd, in, repo, rw, false, changeInfo));
            }
        }
        return res;
    }
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, Optional<PatchSet.Id> limitToPsId, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(cd.project());
        RevWalk rw = newRevWalk(repo)) {
        for (PatchSet in : map.values()) {
            PatchSet.Id id = in.getId();
            boolean want = false;
            if (has(ALL_REVISIONS)) {
                want = true;
            } else if (limitToPsId.isPresent()) {
                want = id.equals(limitToPsId.get());
            } else {
                want = id.equals(cd.change().currentPatchSetId());
            }
            if (want && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(cd, in, repo, rw, false, changeInfo));
            }
        }
        return res;
    }
}
#end_block

#method_before
@Test
public void pushToPublishMagicBranchIsAllowed() throws Exception {
    // Push to "refs/publish/*" will be a synonym of "refs/for/*".
    createChange("refs/publish/master");
    PushOneCommit.Result result = pushTo("refs/publish/master");
    result.assertOkStatus();
    assertThat(result.getMessage()).endsWith("Pushing to refs/publish/* will be deprecated, use refs/for/* instead.\n");
}
#method_after
@Test
public void pushToPublishMagicBranchIsAllowed() throws Exception {
    // Push to "refs/publish/*" will be a synonym of "refs/for/*".
    createChange("refs/publish/master");
    PushOneCommit.Result result = pushTo("refs/publish/master");
    result.assertOkStatus();
    assertThat(result.getMessage()).endsWith("Pushing to refs/publish/* is deprecated, use refs/for/* instead.\n");
}
#end_block

#method_before
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(changeFormatter.newChange(ChangeReportFormatter.Input.builder().setChange(c.change).build()));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && (magicBranch.edit || magicBranch.draft);
        Boolean isPrivate = null;
        Boolean wip = null;
        if (magicBranch != null) {
            if (magicBranch.isPrivate) {
                isPrivate = true;
            } else if (magicBranch.removePrivate) {
                isPrivate = false;
            }
            if (magicBranch.workInProgress) {
                wip = true;
            } else if (magicBranch.ready) {
                wip = false;
            }
        }
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            if (isPrivate == null) {
                isPrivate = u.notes.getChange().isPrivate();
            }
            if (wip == null) {
                wip = u.notes.getChange().isWorkInProgress();
            }
            ChangeReportFormatter.Input input = ChangeReportFormatter.Input.builder().setChange(u.notes.getChange()).setSubject(subject).setIsEdit(edit).setIsPrivate(isPrivate).setIsWorkInProgress(wip).build();
            addMessage(changeFormatter.changeUpdated(input));
        }
        addMessage("");
    }
    // TODO: remove after migrating tools which are using this magic branch.
    if (magicBranch.publish) {
        addMessage("Pushing to refs/publish/* will be deprecated, use refs/for/* instead.");
    }
}
#method_after
private void reportMessages() {
    List<CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(toList());
    if (!created.isEmpty()) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(changeFormatter.newChange(ChangeReportFormatter.Input.builder().setChange(c.change).build()));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> !r.skip && r.inputCommand.getResult() == OK).sorted(comparingInt(r -> r.notes.getChangeId().get())).collect(toList());
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && (magicBranch.edit || magicBranch.draft);
        Boolean isPrivate = null;
        Boolean wip = null;
        if (magicBranch != null) {
            if (magicBranch.isPrivate) {
                isPrivate = true;
            } else if (magicBranch.removePrivate) {
                isPrivate = false;
            }
            if (magicBranch.workInProgress) {
                wip = true;
            } else if (magicBranch.ready) {
                wip = false;
            }
        }
        for (ReplaceRequest u : updated) {
            String subject;
            if (edit) {
                try {
                    subject = rp.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
                } catch (IOException e) {
                    // Log and fall back to original change subject
                    logWarn("failed to get subject for edit patch set", e);
                    subject = u.notes.getChange().getSubject();
                }
            } else {
                subject = u.info.getSubject();
            }
            if (isPrivate == null) {
                isPrivate = u.notes.getChange().isPrivate();
            }
            if (wip == null) {
                wip = u.notes.getChange().isWorkInProgress();
            }
            ChangeReportFormatter.Input input = ChangeReportFormatter.Input.builder().setChange(u.notes.getChange()).setSubject(subject).setIsEdit(edit).setIsPrivate(isPrivate).setIsWorkInProgress(wip).build();
            addMessage(changeFormatter.changeUpdated(input));
        }
        addMessage("");
    }
    // TODO(xchangcheng): remove after migrating tools which are using this magic branch.
    if (magicBranch != null && magicBranch.publish) {
        addMessage("Pushing to refs/publish/* is deprecated, use refs/for/* instead.");
    }
}
#end_block

#method_before
@Override
public void evict(Project p) throws IOException {
    if (p != null) {
        byName.invalidate(p.getNameKey().get());
    }
    indexer.get().index(p.getNameKey());
}
#method_after
@Override
public void evict(Project p) throws IOException {
    evict(p.getNameKey());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountIndexRewriter.class);
    bind(AccountIndexCollection.class);
    listener().to(AccountIndexCollection.class);
    factory(AccountIndexerImpl.Factory.class);
    bind(ChangeIndexRewriter.class);
    bind(ChangeIndexCollection.class);
    listener().to(ChangeIndexCollection.class);
    factory(ChangeIndexer.Factory.class);
    bind(GroupIndexRewriter.class);
    bind(GroupIndexCollection.class);
    listener().to(GroupIndexCollection.class);
    factory(GroupIndexerImpl.Factory.class);
    bind(ProjectIndexCollection.class);
    listener().to(ProjectIndexCollection.class);
    factory(ProjectIndexerImpl.Factory.class);
    DynamicSet.setOf(binder(), OnlineUpgradeListener.class);
}
#method_after
@Override
protected void configure() {
    bind(AccountIndexRewriter.class);
    bind(AccountIndexCollection.class);
    listener().to(AccountIndexCollection.class);
    factory(AccountIndexerImpl.Factory.class);
    bind(ChangeIndexRewriter.class);
    bind(ChangeIndexCollection.class);
    listener().to(ChangeIndexCollection.class);
    factory(ChangeIndexer.Factory.class);
    bind(GroupIndexRewriter.class);
    bind(GroupIndexCollection.class);
    listener().to(GroupIndexCollection.class);
    factory(GroupIndexerImpl.Factory.class);
    bind(ProjectIndexRewriter.class);
    bind(ProjectIndexCollection.class);
    listener().to(ProjectIndexCollection.class);
    factory(ProjectIndexerImpl.Factory.class);
    DynamicSet.setOf(binder(), OnlineUpgradeListener.class);
}
#end_block

#method_before
@Override
protected void run() throws Failure {
    if (oldParent == null && children.isEmpty()) {
        throw die("child projects have to be specified as " + "arguments or the --children-of option has to be set");
    }
    if (oldParent == null && !excludedChildren.isEmpty()) {
        throw die("--exclude can only be used together with --children-of");
    }
    final StringBuilder err = new StringBuilder();
    final Set<Project.NameKey> grandParents = new HashSet<>();
    grandParents.add(allProjectsName);
    if (newParent != null) {
        newParentKey = newParent.getProject().getNameKey();
        // Catalog all grandparents of the "parent", we want to
        // catch a cycle in the parent pointers before it occurs.
        // 
        Project.NameKey gp = newParent.getProject().getParent();
        while (gp != null && grandParents.add(gp)) {
            final ProjectState s = projectCache.get(gp);
            if (s != null) {
                gp = s.getProject().getParent();
            } else {
                break;
            }
        }
    }
    final List<Project.NameKey> childProjects = new ArrayList<>();
    for (ProjectControl pc : children) {
        childProjects.add(pc.getProject().getNameKey());
    }
    if (oldParent != null) {
        try {
            childProjects.addAll(getChildrenForReparenting(oldParent));
        } catch (PermissionBackendException e) {
            throw new Failure(1, "permissions unavailable", e);
        }
    }
    for (Project.NameKey nameKey : childProjects) {
        final String name = nameKey.get();
        if (allProjectsName.equals(nameKey)) {
            // Don't allow the wild card project to have a parent.
            // 
            err.append("error: Cannot set parent of '").append(name).append("'\n");
            continue;
        }
        if (grandParents.contains(nameKey) || nameKey.equals(newParentKey)) {
            // Try to avoid creating a cycle in the parent pointers.
            // 
            err.append("error: Cycle exists between '").append(name).append("' and '").append(newParentKey != null ? newParentKey.get() : allProjectsName.get()).append("'\n");
            continue;
        }
        try (MetaDataUpdate md = metaDataUpdateFactory.create(nameKey)) {
            ProjectConfig config = ProjectConfig.read(md);
            config.getProject().setParentName(newParentKey);
            md.setMessage("Inherit access from " + (newParentKey != null ? newParentKey.get() : allProjectsName.get()) + "\n");
            config.commit(md);
        } catch (RepositoryNotFoundException notFound) {
            err.append("error: Project ").append(name).append(" not found\n");
        } catch (IOException | ConfigInvalidException e) {
            final String msg = "Cannot update project " + name;
            log.error(msg, e);
            err.append("error: ").append(msg).append("\n");
        }
        try {
            projectCache.evict(nameKey);
        } catch (IOException e) {
            final String msg = "Cannot evict from project cache, name key: " + nameKey.get();
            log.error(msg, e);
            err.append("error: ").append(msg).append("\n");
        }
    }
    if (err.length() > 0) {
        while (err.charAt(err.length() - 1) == '\n') {
            err.setLength(err.length() - 1);
        }
        throw die(err.toString());
    }
}
#method_after
@Override
protected void run() throws Failure {
    if (oldParent == null && children.isEmpty()) {
        throw die("child projects have to be specified as " + "arguments or the --children-of option has to be set");
    }
    if (oldParent == null && !excludedChildren.isEmpty()) {
        throw die("--exclude can only be used together with --children-of");
    }
    final StringBuilder err = new StringBuilder();
    final Set<Project.NameKey> grandParents = new HashSet<>();
    grandParents.add(allProjectsName);
    if (newParent != null) {
        newParentKey = newParent.getProject().getNameKey();
        // Catalog all grandparents of the "parent", we want to
        // catch a cycle in the parent pointers before it occurs.
        // 
        Project.NameKey gp = newParent.getProject().getParent();
        while (gp != null && grandParents.add(gp)) {
            final ProjectState s = projectCache.get(gp);
            if (s != null) {
                gp = s.getProject().getParent();
            } else {
                break;
            }
        }
    }
    final List<Project.NameKey> childProjects = new ArrayList<>();
    for (ProjectControl pc : children) {
        childProjects.add(pc.getProject().getNameKey());
    }
    if (oldParent != null) {
        try {
            childProjects.addAll(getChildrenForReparenting(oldParent));
        } catch (PermissionBackendException e) {
            throw new Failure(1, "permissions unavailable", e);
        }
    }
    for (Project.NameKey nameKey : childProjects) {
        final String name = nameKey.get();
        if (allProjectsName.equals(nameKey)) {
            // Don't allow the wild card project to have a parent.
            // 
            err.append("error: Cannot set parent of '").append(name).append("'\n");
            continue;
        }
        if (grandParents.contains(nameKey) || nameKey.equals(newParentKey)) {
            // Try to avoid creating a cycle in the parent pointers.
            // 
            err.append("error: Cycle exists between '").append(name).append("' and '").append(newParentKey != null ? newParentKey.get() : allProjectsName.get()).append("'\n");
            continue;
        }
        try (MetaDataUpdate md = metaDataUpdateFactory.create(nameKey)) {
            ProjectConfig config = ProjectConfig.read(md);
            config.getProject().setParentName(newParentKey);
            md.setMessage("Inherit access from " + (newParentKey != null ? newParentKey.get() : allProjectsName.get()) + "\n");
            config.commit(md);
        } catch (RepositoryNotFoundException notFound) {
            err.append("error: Project ").append(name).append(" not found\n");
        } catch (IOException | ConfigInvalidException e) {
            final String msg = "Cannot update project " + name;
            log.error(msg, e);
            err.append("error: ").append(msg).append("\n");
        }
        try {
            projectCache.evict(nameKey);
        } catch (IOException e) {
            final String msg = "Cannot reindex project: " + name;
            log.error(msg, e);
            err.append("error: ").append(msg).append("\n");
        }
    }
    if (err.length() > 0) {
        while (err.charAt(err.length() - 1) == '\n') {
            err.setLength(err.length() - 1);
        }
        throw die(err.toString());
    }
}
#end_block

#method_before
private Set<Project.NameKey> getAllParents(Project.NameKey projectName) {
    ProjectState ps = projectCache.get(projectName);
    if (ps == null) {
        return Collections.emptySet();
    }
    return ps.parents().transform(s -> s.getProject().getNameKey()).toSet();
}
#method_after
private Set<Project.NameKey> getAllParents(Project.NameKey projectName) {
    ProjectState ps = projectCache.get(projectName);
    if (ps == null) {
        return Collections.emptySet();
    }
    return ps.parents().transform(s -> s.getNameKey()).toSet();
}
#end_block

#method_before
public static Predicate<ProjectState> name(Project.NameKey nameKey) {
    return new ProjectPredicate(ProjectField.NAME, ProjectQueryBuilder.FIELD_NAME, nameKey.get());
}
#method_after
public static Predicate<ProjectState> name(Project.NameKey nameKey) {
    return new ProjectPredicate(ProjectField.NAME, nameKey.get());
}
#end_block

#method_before
@Override
public SiteIndexer.Result indexAll(final ProjectIndex index) {
    ProgressMonitor progress = new TextProgressMonitor(new PrintWriter(progressOut));
    progress.start(2);
    Stopwatch sw = Stopwatch.createStarted();
    List<Project.NameKey> names;
    try {
        names = collectProjects(progress);
    } catch (OrmException e) {
        log.error("Error collecting accounts", e);
        return new SiteIndexer.Result(sw, false, 0, 0);
    }
    return reindexProjects(index, names, progress);
}
#method_after
@Override
public SiteIndexer.Result indexAll(final ProjectIndex index) {
    ProgressMonitor progress = new TextProgressMonitor(new PrintWriter(progressOut));
    progress.start(2);
    Stopwatch sw = Stopwatch.createStarted();
    List<Project.NameKey> names;
    try {
        names = collectProjects(progress);
    } catch (OrmException e) {
        log.error("Error collecting projects", e);
        return new SiteIndexer.Result(sw, false, 0, 0);
    }
    return reindexProjects(index, names, progress);
}
#end_block

#method_before
private SiteIndexer.Result reindexProjects(ProjectIndex index, List<Project.NameKey> names, ProgressMonitor progress) {
    progress.beginTask("Reindexing projects", names.size());
    List<ListenableFuture<?>> futures = new ArrayList<>(names.size());
    AtomicBoolean ok = new AtomicBoolean(true);
    AtomicInteger done = new AtomicInteger();
    AtomicInteger failed = new AtomicInteger();
    Stopwatch sw = Stopwatch.createStarted();
    for (Project.NameKey name : names) {
        String desc = "project " + name;
        ListenableFuture<?> future = executor.submit(() -> {
            try {
                projectCache.evict(name);
                index.replace(projectCache.get(name));
                verboseWriter.println("Reindexed " + desc);
                done.incrementAndGet();
            } catch (Exception e) {
                failed.incrementAndGet();
                throw e;
            }
            return null;
        });
        addErrorListener(future, desc, progress, ok);
        futures.add(future);
    }
    try {
        Futures.successfulAsList(futures).get();
    } catch (ExecutionException | InterruptedException e) {
        log.error("Error waiting on account futures", e);
        return new SiteIndexer.Result(sw, false, 0, 0);
    }
    progress.endTask();
    return new SiteIndexer.Result(sw, ok.get(), done.get(), failed.get());
}
#method_after
private SiteIndexer.Result reindexProjects(ProjectIndex index, List<Project.NameKey> names, ProgressMonitor progress) {
    progress.beginTask("Reindexing projects", names.size());
    List<ListenableFuture<?>> futures = new ArrayList<>(names.size());
    AtomicBoolean ok = new AtomicBoolean(true);
    AtomicInteger done = new AtomicInteger();
    AtomicInteger failed = new AtomicInteger();
    Stopwatch sw = Stopwatch.createStarted();
    for (Project.NameKey name : names) {
        String desc = "project " + name;
        ListenableFuture<?> future = executor.submit(() -> {
            try {
                projectCache.evict(name);
                index.replace(projectCache.get(name));
                verboseWriter.println("Reindexed " + desc);
                done.incrementAndGet();
            } catch (Exception e) {
                failed.incrementAndGet();
                throw e;
            }
            return null;
        });
        addErrorListener(future, desc, progress, ok);
        futures.add(future);
    }
    try {
        Futures.successfulAsList(futures).get();
    } catch (ExecutionException | InterruptedException e) {
        log.error("Error waiting on project futures", e);
        return new SiteIndexer.Result(sw, false, 0, 0);
    }
    progress.endTask();
    return new SiteIndexer.Result(sw, ok.get(), done.get(), failed.get());
}
#end_block

#method_before
private List<Project.NameKey> collectProjects(ProgressMonitor progress) throws OrmException {
    progress.beginTask("Collecting projects", ProgressMonitor.UNKNOWN);
    List<Project.NameKey> names = new ArrayList<>();
    // there. Is getting all the name keys from projectcache the right approach?
    for (Project.NameKey nameKey : projectCache.all()) {
        names.add(nameKey);
    }
    progress.endTask();
    return names;
}
#method_after
private List<Project.NameKey> collectProjects(ProgressMonitor progress) throws OrmException {
    progress.beginTask("Collecting projects", ProgressMonitor.UNKNOWN);
    List<Project.NameKey> names = new ArrayList<>();
    for (Project.NameKey nameKey : projectCache.all()) {
        names.add(nameKey);
    }
    progress.endTask();
    return names;
}
#end_block

#method_before
@Override
public Response<DiffInfo> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    DiffPreferencesInfo prefs = new DiffPreferencesInfo();
    if (whitespace != null) {
        prefs.ignoreWhitespace = whitespace;
    } else if (ignoreWhitespace != null) {
        prefs.ignoreWhitespace = ignoreWhitespace.whitespace;
    } else {
        prefs.ignoreWhitespace = Whitespace.IGNORE_LEADING_AND_TRAILING;
    }
    prefs.context = context;
    prefs.intralineDifference = intraline;
    PatchScriptFactory psf;
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
        psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet.getId(), resource.getPatchKey().getParentKey(), prefs);
    } else if (parentNum > 0) {
        psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), parentNum - 1, resource.getPatchKey().getParentKey(), prefs);
    } else {
        psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), null, resource.getPatchKey().getParentKey(), prefs);
    }
    try {
        psf.setLoadHistory(false);
        psf.setLoadComments(context != DiffPreferencesInfo.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %s; want %s", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %s; want %s", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        DiffInfo result = new DiffInfo();
        // TODO referring to the parent commit by refs/changes/12/60012/1^1
        // will likely not work for inline edits
        String revA = basePatchSet != null ? basePatchSet.getRefName() : content.commitIdA;
        String revB = resource.getRevision().getEdit().isPresent() ? resource.getRevision().getEdit().get().getRefName() : resource.getRevision().getPatchSet().getRefName();
        List<DiffWebLinkInfo> links = webLinks.getDiffLinks(state.getProject().getName(), resource.getPatchKey().getParentKey().getParentKey().get(), basePatchSet != null ? basePatchSet.getId().get() : null, revA, MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName()), resource.getPatchKey().getParentKey().get(), revB, ps.getNewName());
        result.webLinks = links.isEmpty() ? null : links;
        if (!webLinksOnly) {
            if (ps.isBinary()) {
                result.binary = true;
            }
            if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
                result.metaA = new FileMeta();
                result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
                result.metaA.contentType = FileContentUtil.resolveContentType(state, result.metaA.name, ps.getFileModeA(), ps.getMimeTypeA());
                result.metaA.lines = ps.getA().size();
                result.metaA.webLinks = getFileWebLinks(state.getProject(), revA, result.metaA.name);
                result.metaA.commitId = content.commitIdA;
            }
            if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
                result.metaB = new FileMeta();
                result.metaB.name = ps.getNewName();
                result.metaB.contentType = FileContentUtil.resolveContentType(state, result.metaB.name, ps.getFileModeB(), ps.getMimeTypeB());
                result.metaB.lines = ps.getB().size();
                result.metaB.webLinks = getFileWebLinks(state.getProject(), revB, result.metaB.name);
                result.metaB.commitId = content.commitIdB;
            }
            if (intraline) {
                if (ps.hasIntralineTimeout()) {
                    result.intralineStatus = IntraLineStatus.TIMEOUT;
                } else if (ps.hasIntralineFailure()) {
                    result.intralineStatus = IntraLineStatus.FAILURE;
                } else {
                    result.intralineStatus = IntraLineStatus.OK;
                }
            }
            result.changeType = CHANGE_TYPE.get(ps.getChangeType());
            if (result.changeType == null) {
                throw new IllegalStateException("unknown change type: " + ps.getChangeType());
            }
            if (ps.getPatchHeader().size() > 0) {
                result.diffHeader = ps.getPatchHeader();
            }
            result.content = content.lines;
        }
        Response<DiffInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage(), e);
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    }
}
#method_after
@Override
public Response<DiffInfo> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    DiffPreferencesInfo prefs = new DiffPreferencesInfo();
    if (whitespace != null) {
        prefs.ignoreWhitespace = whitespace;
    } else if (ignoreWhitespace != null) {
        prefs.ignoreWhitespace = ignoreWhitespace.whitespace;
    } else {
        prefs.ignoreWhitespace = Whitespace.IGNORE_LEADING_AND_TRAILING;
    }
    prefs.context = context;
    prefs.intralineDifference = intraline;
    PatchScriptFactory psf;
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
        psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet.getId(), resource.getPatchKey().getParentKey(), prefs);
    } else if (parentNum > 0) {
        psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), parentNum - 1, resource.getPatchKey().getParentKey(), prefs);
    } else {
        psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), null, resource.getPatchKey().getParentKey(), prefs);
    }
    try {
        psf.setLoadHistory(false);
        psf.setLoadComments(context != DiffPreferencesInfo.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %s; want %s", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %s; want %s", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        DiffInfo result = new DiffInfo();
        String revA = basePatchSet != null ? basePatchSet.getRefName() : content.commitIdA;
        String revB = resource.getRevision().getEdit().isPresent() ? resource.getRevision().getEdit().get().getRefName() : resource.getRevision().getPatchSet().getRefName();
        List<DiffWebLinkInfo> links = webLinks.getDiffLinks(state.getProject().getName(), resource.getPatchKey().getParentKey().getParentKey().get(), basePatchSet != null ? basePatchSet.getId().get() : null, revA, MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName()), resource.getPatchKey().getParentKey().get(), revB, ps.getNewName());
        result.webLinks = links.isEmpty() ? null : links;
        if (!webLinksOnly) {
            if (ps.isBinary()) {
                result.binary = true;
            }
            if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
                result.metaA = new FileMeta();
                result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
                result.metaA.contentType = FileContentUtil.resolveContentType(state, result.metaA.name, ps.getFileModeA(), ps.getMimeTypeA());
                result.metaA.lines = ps.getA().size();
                result.metaA.webLinks = getFileWebLinks(state.getProject(), revA, result.metaA.name);
                result.metaA.commitId = content.commitIdA;
            }
            if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
                result.metaB = new FileMeta();
                result.metaB.name = ps.getNewName();
                result.metaB.contentType = FileContentUtil.resolveContentType(state, result.metaB.name, ps.getFileModeB(), ps.getMimeTypeB());
                result.metaB.lines = ps.getB().size();
                result.metaB.webLinks = getFileWebLinks(state.getProject(), revB, result.metaB.name);
                result.metaB.commitId = content.commitIdB;
            }
            if (intraline) {
                if (ps.hasIntralineTimeout()) {
                    result.intralineStatus = IntraLineStatus.TIMEOUT;
                } else if (ps.hasIntralineFailure()) {
                    result.intralineStatus = IntraLineStatus.FAILURE;
                } else {
                    result.intralineStatus = IntraLineStatus.OK;
                }
            }
            result.changeType = CHANGE_TYPE.get(ps.getChangeType());
            if (result.changeType == null) {
                throw new IllegalStateException("unknown change type: " + ps.getChangeType());
            }
            if (ps.getPatchHeader().size() > 0) {
                result.diffHeader = ps.getPatchHeader();
            }
            result.content = content.lines;
        }
        Response<DiffInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage(), e);
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    }
}
#end_block

#method_before
@Test
public void listDashboards() throws Exception {
    assertThat(dashboards()).isEmpty();
    DashboardInfo info1 = createDashboard(DashboardsCollection.DEFAULT_DASHBOARD_NAME, "test1");
    DashboardInfo info2 = createDashboard(DashboardsCollection.DEFAULT_DASHBOARD_NAME, "test2");
    List<String> expected = ImmutableList.of(info1.id, info2.id);
    assertThat(dashboards().stream().map(d -> d.id).collect(toList())).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void listDashboards() throws Exception {
    assertThat(dashboards()).isEmpty();
    DashboardInfo info1 = createDashboard(DashboardsCollection.DEFAULT_DASHBOARD_NAME, "test1");
    DashboardInfo info2 = createDashboard(DashboardsCollection.DEFAULT_DASHBOARD_NAME, "test2");
    assertThat(dashboards().stream().map(d -> d.id).collect(toList())).containsExactly(info1.id, info2.id);
}
#end_block

#method_before
@Override
public Description getDescription(ChangeResource rsrc) {
    return new UiAction.Description().setLabel("Mark as Unreviewed").setTitle("Mark the change as unreviewed to highlight it in the dashboard").setVisible(isReviewed(rsrc));
}
#method_after
@Override
public Description getDescription(ChangeResource rsrc) {
    return new UiAction.Description().setLabel("Mark Unreviewed").setTitle("Mark the change as unreviewed to highlight it in the dashboard").setVisible(isReviewed(rsrc));
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Fixes.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FIX_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    get(CHANGE_KIND, "pure_revert").to(GetPureRevert.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "private").to(PostPrivate.class);
    post(CHANGE_KIND, "private.delete").to(DeletePrivateByPost.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    put(CHANGE_KIND, "ignore").to(Ignore.class);
    put(CHANGE_KIND, "unignore").to(Unignore.class);
    put(CHANGE_KIND, "reviewed").to(MarkAsReviewed.class);
    put(CHANGE_KIND, "unreviewed").to(MarkAsUnreviewed.class);
    post(CHANGE_KIND, "wip").to(SetWorkInProgress.class);
    post(CHANGE_KIND, "ready").to(SetReadyForReview.class);
    put(CHANGE_KIND, "message").to(PutMessage.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    delete(COMMENT_KIND).to(DeleteComment.class);
    post(COMMENT_KIND, "delete").to(DeleteComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "fixes").to(Fixes.class);
    post(FIX_KIND, "apply").to(ApplyFix.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(ChangeResource.Factory.class);
    factory(DeleteReviewerByEmailOp.Factory.class);
    factory(DeleteReviewerOp.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(PostReviewersOp.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(WorkInProgressOp.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Fixes.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FIX_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    get(CHANGE_KIND, "pure_revert").to(GetPureRevert.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "private").to(PostPrivate.class);
    post(CHANGE_KIND, "private.delete").to(DeletePrivateByPost.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    put(CHANGE_KIND, "ignore").to(Ignore.class);
    put(CHANGE_KIND, "unignore").to(Unignore.class);
    put(CHANGE_KIND, "mute").to(Mute.class);
    put(CHANGE_KIND, "unmute").to(Unmute.class);
    put(CHANGE_KIND, "reviewed").to(MarkAsReviewed.class);
    put(CHANGE_KIND, "unreviewed").to(MarkAsUnreviewed.class);
    post(CHANGE_KIND, "wip").to(SetWorkInProgress.class);
    post(CHANGE_KIND, "ready").to(SetReadyForReview.class);
    put(CHANGE_KIND, "message").to(PutMessage.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    delete(COMMENT_KIND).to(DeleteComment.class);
    post(COMMENT_KIND, "delete").to(DeleteComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "fixes").to(Fixes.class);
    post(FIX_KIND, "apply").to(ApplyFix.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(ChangeResource.Factory.class);
    factory(DeleteReviewerByEmailOp.Factory.class);
    factory(DeleteReviewerOp.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(PostReviewersOp.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(WorkInProgressOp.Factory.class);
}
#end_block

#method_before
@Override
public void rebase() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Deprecated
@Override
public void rebase() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.WithUser withUser = permissionBackend.user(user).database(db);
    PermissionBackend.ForChange perm = lazyLoad ? withUser.change(cd) : withUser.indexedChange(cd, notesFactory.createFromIndexedChange(cd.change()));
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        out.reviewed = cd.isReviewedBy(user.getAccountId()) ? true : null;
    }
    out.labels = labelsFor(perm, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    ChangeControl ctl = null;
    if (needMessages || needRevisions) {
        ctl = changeControlFactory.controlFor(db.get(), cd.change(), userProvider.get());
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.WithUser withUser = permissionBackend.user(user).database(db);
    PermissionBackend.ForChange perm = lazyLoad ? withUser.change(cd) : withUser.indexedChange(cd, notesFactory.createFromIndexedChange(cd.change()));
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.isReviewedBy(user.getAccountId()) ? true : null;
        }
    }
    out.labels = labelsFor(perm, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    ChangeControl ctl = null;
    if (needMessages || needRevisions) {
        ctl = changeControlFactory.controlFor(db.get(), cd.change(), userProvider.get());
    }
    if (needMessages) {
        out.messages = messages(ctl, cd);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#end_block

#method_before
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            Account.Id realAuthor = message.getRealAuthor();
            if (realAuthor != null) {
                cmi.realAuthor = accountLoader.get(realAuthor);
            }
            result.add(cmi);
        }
    }
    return result;
}
#method_after
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        if (patchNum == null || ctl.isVisible(db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            Account.Id realAuthor = message.getRealAuthor();
            if (realAuthor != null) {
                cmi.realAuthor = accountLoader.get(realAuthor);
            }
            result.add(cmi);
        }
    }
    return result;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, Optional<PatchSet.Id> limitToPsId, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(cd.project());
        RevWalk rw = newRevWalk(repo)) {
        for (PatchSet in : map.values()) {
            PatchSet.Id id = in.getId();
            boolean want = false;
            if (has(ALL_REVISIONS)) {
                want = true;
            } else if (limitToPsId.isPresent()) {
                want = id.equals(limitToPsId.get());
            } else {
                want = id.equals(cd.change().currentPatchSetId());
            }
            if (want && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(cd, in, repo, rw, false, changeInfo));
            }
        }
        return res;
    }
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, Optional<PatchSet.Id> limitToPsId, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(cd.project());
        RevWalk rw = newRevWalk(repo)) {
        for (PatchSet in : map.values()) {
            PatchSet.Id id = in.getId();
            boolean want = false;
            if (has(ALL_REVISIONS)) {
                want = true;
            } else if (limitToPsId.isPresent()) {
                want = id.equals(limitToPsId.get());
            } else {
                want = id.equals(cd.change().currentPatchSetId());
            }
            if (want && ctl.isVisible(db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(cd, in, repo, rw, false, changeInfo));
            }
        }
        return res;
    }
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in, @Nullable Repository repo, @Nullable RevWalk rw, boolean fillCommit, @Nullable ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = cd.change();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(cd, in);
    out.kind = changeKindCache.getChangeKind(rw, repo != null ? repo.getConfig() : null, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        checkState(rw != null);
        checkState(repo != null);
        Project.NameKey project = c.getProject();
        String rev = in.getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        if (setCommit) {
            out.commit = toCommit(project, rw, commit, has(WEB_LINKS), fillCommit);
        }
        if (addFooters) {
            Ref ref = repo.exactRef(cd.change().getDest().get());
            RevCommit mergeTip = null;
            if (ref != null) {
                mergeTip = rw.parseCommit(ref.getObjectId());
                rw.parseBody(mergeTip);
            }
            out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, cd.notes(), userProvider.get(), in.getId());
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(cd.notes(), userProvider.get()), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in, @Nullable Repository repo, @Nullable RevWalk rw, boolean fillCommit, @Nullable ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = cd.change();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.fetch = makeFetchMap(cd, in);
    out.kind = changeKindCache.getChangeKind(rw, repo != null ? repo.getConfig() : null, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        checkState(rw != null);
        checkState(repo != null);
        Project.NameKey project = c.getProject();
        String rev = in.getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        if (setCommit) {
            out.commit = toCommit(project, rw, commit, has(WEB_LINKS), fillCommit);
        }
        if (addFooters) {
            Ref ref = repo.exactRef(cd.change().getDest().get());
            RevCommit mergeTip = null;
            if (ref != null) {
                mergeTip = rw.parseCommit(ref.getObjectId());
                rw.parseBody(mergeTip);
            }
            out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, cd.notes(), userProvider.get(), in.getId());
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if (out.isCurrent && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(cd.notes(), userProvider.get()), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#end_block

#method_before
private Map<String, FetchInfo> makeFetchMap(ChangeData cd, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = new LinkedHashMap<>();
    ChangeControl ctl = changeControlFactory.controlFor(db.get(), cd.change(), anonymous);
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.isPatchVisible(in, db.get())) {
            continue;
        }
        String projectName = cd.project().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#method_after
private Map<String, FetchInfo> makeFetchMap(ChangeData cd, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = new LinkedHashMap<>();
    ChangeControl ctl = changeControlFactory.controlFor(db.get(), cd.change(), anonymous);
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.isVisible(db.get())) {
            continue;
        }
        String projectName = cd.project().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#end_block

#method_before
public Boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else if (c.getStatus() == Change.Status.ABANDONED) {
            return null;
        } else if (c.isWorkInProgress()) {
            return null;
        } else {
            if (!lazyLoad) {
                return null;
            }
            PatchSet ps = currentPatchSet();
            try {
                if (ps == null || !changeControl().isPatchVisible(ps, db)) {
                    return null;
                }
            } catch (OrmException e) {
                if (e.getCause() instanceof NoSuchChangeException) {
                    return null;
                }
                throw e;
            }
            try (Repository repo = repoManager.openRepository(project())) {
                Ref ref = repo.getRefDatabase().exactRef(c.getDest().get());
                SubmitTypeRecord str = submitTypeRecord();
                if (!str.isOk()) {
                    // No need to log, as SubmitRuleEvaluator already did it for us.
                    return false;
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
    }
    return mergeable;
}
#method_after
public Boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else if (c.getStatus() == Change.Status.ABANDONED) {
            return null;
        } else if (c.isWorkInProgress()) {
            return null;
        } else {
            if (!lazyLoad) {
                return null;
            }
            PatchSet ps = currentPatchSet();
            try {
                if (ps == null || !changeControl().isVisible(db)) {
                    return null;
                }
            } catch (OrmException e) {
                if (e.getCause() instanceof NoSuchChangeException) {
                    return null;
                }
                throw e;
            }
            try (Repository repo = repoManager.openRepository(project())) {
                Ref ref = repo.getRefDatabase().exactRef(c.getDest().get());
                SubmitTypeRecord str = submitTypeRecord();
                if (!str.isOk()) {
                    // No need to log, as SubmitRuleEvaluator already did it for us.
                    return false;
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(project())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, str.type, mergeStrategy, c.getDest(), repo);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
    }
    return mergeable;
}
#end_block

#method_before
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    setApiUser(admin);
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    createDraftChange();
    setApiUser(user);
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try {
        assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(LABELS).withOption(DETAILED_ACCOUNTS).withOption(REVIEWED).get()).hasSize(2);
    } finally {
        enableDb(ctx);
    }
}
#method_after
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    setApiUser(admin);
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    setApiUser(user);
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try {
        assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(LABELS).withOption(DETAILED_ACCOUNTS).withOption(REVIEWED).get()).hasSize(2);
    } finally {
        enableDb(ctx);
    }
}
#end_block

#method_before
private static String getReviewedLabel(Change change) {
    return REVIEWED_LABEL + "/" + change.currentPatchSetId().get();
}
#method_after
private static String getReviewedLabel(Change change) {
    return getReviewedLabel(change.currentPatchSetId().get());
}
#end_block

#method_before
private static String getReviewedLabel(Change change) {
    return REVIEWED_LABEL + "/" + change.currentPatchSetId().get();
}
#method_after
private static String getReviewedLabel(int ps) {
    return REVIEWED_LABEL + "/" + ps;
}
#end_block

#method_before
private static String getUnreviewedLabel(Change change) {
    return UNREVIEWED_LABEL + "/" + change.currentPatchSetId().get();
}
#method_after
private static String getUnreviewedLabel(Change change) {
    return getUnreviewedLabel(change.currentPatchSetId().get());
}
#end_block

#method_before
private static String getUnreviewedLabel(Change change) {
    return UNREVIEWED_LABEL + "/" + change.currentPatchSetId().get();
}
#method_after
private static String getUnreviewedLabel(int ps) {
    return UNREVIEWED_LABEL + "/" + ps;
}
#end_block

#method_before
public static StarRef readLabels(Repository repo, String refName) throws IOException {
    Ref ref = repo.exactRef(refName);
    if (ref == null) {
        return StarRef.MISSING;
    }
    try (ObjectReader reader = repo.newObjectReader()) {
        ObjectLoader obj = reader.open(ref.getObjectId(), Constants.OBJ_BLOB);
        return StarRef.create(ref, Splitter.on(CharMatcher.whitespace()).omitEmptyStrings().split(new String(obj.getCachedBytes(Integer.MAX_VALUE), UTF_8)));
    }
}
#method_after
private static StarRef readLabels(Repository repo, String refName) throws IOException {
    Ref ref = repo.exactRef(refName);
    if (ref == null) {
        return StarRef.MISSING;
    }
    try (ObjectReader reader = repo.newObjectReader()) {
        ObjectLoader obj = reader.open(ref.getObjectId(), Constants.OBJ_BLOB);
        return StarRef.create(ref, Splitter.on(CharMatcher.whitespace()).omitEmptyStrings().split(new String(obj.getCachedBytes(Integer.MAX_VALUE), UTF_8)));
    }
}
#end_block

#method_before
private static void checkMutuallyExclusiveLabels(Set<String> labels) throws MutuallyExclusiveLabelsException {
    if (labels.containsAll(ImmutableSet.of(DEFAULT_LABEL, IGNORE_LABEL))) {
        throw new MutuallyExclusiveLabelsException(DEFAULT_LABEL, IGNORE_LABEL);
    }
    if (labels.stream().filter(l -> l.startsWith(REVIEWED_LABEL)).findAny().isPresent() && labels.stream().filter(l -> l.startsWith(UNREVIEWED_LABEL)).findAny().isPresent()) {
        throw new MutuallyExclusiveLabelsException(REVIEWED_LABEL, UNREVIEWED_LABEL);
    }
}
#method_after
private static void checkMutuallyExclusiveLabels(Set<String> labels) throws MutuallyExclusiveLabelsException {
    if (labels.containsAll(ImmutableSet.of(DEFAULT_LABEL, IGNORE_LABEL))) {
        throw new MutuallyExclusiveLabelsException(DEFAULT_LABEL, IGNORE_LABEL);
    }
    Set<Integer> reviewedPatchSets = labels.stream().filter(l -> l.startsWith(REVIEWED_LABEL)).map(l -> Integer.valueOf(l.substring(REVIEWED_LABEL.length() + 1))).collect(toSet());
    Set<Integer> unreviewedPatchSets = labels.stream().filter(l -> l.startsWith(UNREVIEWED_LABEL)).map(l -> Integer.valueOf(l.substring(UNREVIEWED_LABEL.length() + 1))).collect(toSet());
    Optional<Integer> ps = Sets.intersection(reviewedPatchSets, unreviewedPatchSets).stream().findFirst();
    if (ps.isPresent()) {
        throw new MutuallyExclusiveLabelsException(getReviewedLabel(ps.get()), getUnreviewedLabel(ps.get()));
    }
}
#end_block

#method_before
@Override
public void publish() throws RestApiException {
    try {
        publishDraftChange.apply(change, null);
    } catch (Exception e) {
        throw asRestApiException("Cannot publish change", e);
    }
}
#method_after
@Deprecated
@Override
public void publish() throws RestApiException {
    throw new UnsupportedOperationException("draft workflow is discontinued");
}
#end_block

#method_before
@Override
public void markAsReviewed(boolean reviewed) throws RestApiException {
    // StarredChangesUtil.
    try {
        if (reviewed) {
            this.markAsReviewed.apply(change, new MarkAsReviewed.Input());
        } else {
            markAsUnreviewed.apply(change, new MarkAsUnreviewed.Input());
        }
    } catch (OrmException | IllegalLabelException e) {
        throw asRestApiException("Cannot mark change as " + (reviewed ? "reviewed" : "unreviewed"), e);
    }
}
#method_after
@Override
public void markAsReviewed(boolean reviewed) throws RestApiException {
    // StarredChangesUtil.
    try {
        if (reviewed) {
            markAsReviewed.apply(change, new MarkAsReviewed.Input());
        } else {
            markAsUnreviewed.apply(change, new MarkAsUnreviewed.Input());
        }
    } catch (OrmException | IllegalLabelException e) {
        throw asRestApiException("Cannot mark change as " + (reviewed ? "reviewed" : "unreviewed"), e);
    }
}
#end_block

#method_before
@Override
public Description getDescription(ChangeResource rsrc) {
    return new UiAction.Description().setLabel("Mark as Reviewed").setTitle("Mark the change as reviewed to unhighlight it in the dashboard").setVisible(!isReviewed(rsrc));
}
#method_after
@Override
public Description getDescription(ChangeResource rsrc) {
    return new UiAction.Description().setLabel("Mark Reviewed").setTitle("Mark the change as reviewed to unhighlight it in the dashboard").setVisible(!isReviewed(rsrc));
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Plugin module needs to be inserted *before* the index module.
    // There is the concept of LifecycleModule, in Gerrit's own extension
    // to Guice, which has these:
    // listener().to(SomeClassImplementingLifecycleListener.class);
    // and the start() methods of each such listener are executed in the
    // order they are declared.
    // Makes sure that PluginLoader.start() is executed before the
    // LuceneIndexModule.start() so that plugins get loaded and the respective
    // Guice modules installed so that the on-line reindexing will happen
    // with the proper classes (e.g. group backends, custom Prolog
    // predicates) and the associated rules ready to be evaluated.
    modules.add(new PluginModule());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(inMemoryTest ? new H2AccountPatchReviewStore.InMemoryModule() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (inMemoryTest) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new AccountDeactivator.Module());
    if (!slave) {
        modules.add(new ChangeCleanupRunner.Module());
    }
    modules.addAll(LibModuleLoader.loadModules(cfgInjector));
    if (migrateToNoteDb()) {
        modules.add(new OnlineNoteDbMigrator.Module());
    }
    if (testSysModule != null) {
        modules.add(testSysModule);
    }
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Plugin module needs to be inserted *before* the index module.
    // There is the concept of LifecycleModule, in Gerrit's own extension
    // to Guice, which has these:
    // listener().to(SomeClassImplementingLifecycleListener.class);
    // and the start() methods of each such listener are executed in the
    // order they are declared.
    // Makes sure that PluginLoader.start() is executed before the
    // LuceneIndexModule.start() so that plugins get loaded and the respective
    // Guice modules installed so that the on-line reindexing will happen
    // with the proper classes (e.g. group backends, custom Prolog
    // predicates) and the associated rules ready to be evaluated.
    modules.add(new PluginModule());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(inMemoryTest ? new InMemoryAccountPatchReviewStore.Module() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (inMemoryTest) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new AccountDeactivator.Module());
        modules.add(new ChangeCleanupRunner.Module());
    }
    modules.addAll(LibModuleLoader.loadModules(cfgInjector));
    if (migrateToNoteDb()) {
        modules.add(new OnlineNoteDbMigrator.Module(trial));
    }
    if (testSysModule != null) {
        modules.add(testSysModule);
    }
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(BatchUpdate.module());
    install(ChangeKindCacheImpl.module());
    install(ChangeFinder.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new ExternalIdModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.AssistedFactory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(AccountDeactivatorConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    bind(UiActions.class);
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), DraftPublishedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), AccountIndexedListener.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), GroupIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterRefUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicSet.setOf(binder(), TagWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    bind(MailFilter.class).annotatedWith(Exports.named("ListMailFilter")).to(ListMailFilter.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryProcessor.ChangeAttributeFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(AccountValidator.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountCacheImpl.module());
    install(BatchUpdate.module());
    install(ChangeKindCacheImpl.module());
    install(ChangeFinder.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(OAuthTokenCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new ExternalIdModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule(cfg));
    install(new PrologModule());
    install(new ReceiveCommitsModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityCollection.Factory.class);
    factory(ChangeData.AssistedFactory.class);
    factory(ChangeJson.AssistedFactory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(SetAssigneeSender.Factory.class);
    factory(VisibleRefFilter.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    factory(SubmitRuleEvaluator.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(AccountDeactivator.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class);
    bind(SoyTofu.class).annotatedWith(MailTemplates.class).toProvider(MailSoyTofuProvider.class);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    bind(UiActions.class);
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), AssigneeChangedListener.class);
    DynamicSet.setOf(binder(), ChangeAbandonedListener.class);
    DynamicSet.setOf(binder(), CommentAddedListener.class);
    DynamicSet.setOf(binder(), HashtagsEditedListener.class);
    DynamicSet.setOf(binder(), ChangeMergedListener.class);
    DynamicSet.setOf(binder(), ChangeRestoredListener.class);
    DynamicSet.setOf(binder(), ChangeRevertedListener.class);
    DynamicSet.setOf(binder(), ReviewerAddedListener.class);
    DynamicSet.setOf(binder(), ReviewerDeletedListener.class);
    DynamicSet.setOf(binder(), VoteDeletedListener.class);
    DynamicSet.setOf(binder(), RevisionCreatedListener.class);
    DynamicSet.setOf(binder(), TopicEditedListener.class);
    DynamicSet.setOf(binder(), AgreementSignupListener.class);
    DynamicSet.setOf(binder(), PluginEventListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), PostUploadHook.class);
    DynamicSet.setOf(binder(), AccountIndexedListener.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), GroupIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterRefUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), ChangeMessageModifier.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), OnSubmitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ReviewerSuggestion.class);
    DynamicSet.setOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ParentWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicSet.setOf(binder(), TagWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicItem.itemOf(binder(), OAuthTokenEncrypter.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    DynamicItem.itemOf(binder(), AccountPatchReviewStore.class);
    DynamicSet.setOf(binder(), AssigneeValidationListener.class);
    DynamicSet.setOf(binder(), ActionVisitor.class);
    DynamicMap.mapOf(binder(), MailFilter.class);
    bind(MailFilter.class).annotatedWith(Exports.named("ListMailFilter")).to(ListMailFilter.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeHasOperandFactory.class);
    DynamicMap.mapOf(binder(), ChangeQueryProcessor.ChangeAttributeFactory.class);
    install(new GitwebConfig.LegacyModule(cfg));
    bind(AnonymousUser.class);
    factory(AbandonOp.Factory.class);
    factory(AccountMergeValidator.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(OnSubmitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(MergedByPushOp.Factory.class);
    factory(GitModules.Factory.class);
    factory(VersionedAuthorizedKeys.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public void start() {
    if (!supportAutomaticAccountActivityUpdate) {
        return;
    }
    ScheduleConfig scheduleConfig = cfg.getScheduleConfig();
    long interval = scheduleConfig.getInterval();
    long delay = scheduleConfig.getInitialDelay();
    if (delay == MISSING_CONFIG && interval == MISSING_CONFIG) {
        log.info("Ignoring missing accountDeactivator schedule configuration");
    } else if (delay < 0 || interval <= 0) {
        log.warn(String.format("Ignoring invalid accountDeactivator schedule configuration: %s", scheduleConfig));
    } else {
        @SuppressWarnings("unused")
        Future<?> possiblyIgnoredError = queue.getDefaultQueue().scheduleAtFixedRate(deactivator, delay, interval, TimeUnit.MILLISECONDS);
    }
}
#method_after
@Override
public void start() {
    if (!supportAutomaticAccountActivityUpdate) {
        return;
    }
    long interval = scheduleConfig.getInterval();
    long delay = scheduleConfig.getInitialDelay();
    if (delay == MISSING_CONFIG && interval == MISSING_CONFIG) {
        log.info("Ignoring missing accountDeactivator schedule configuration");
    } else if (delay < 0 || interval <= 0) {
        log.warn(String.format("Ignoring invalid accountDeactivator schedule configuration: %s", scheduleConfig));
    } else {
        queue.getDefaultQueue().scheduleAtFixedRate(deactivator, delay, interval, TimeUnit.MILLISECONDS);
    }
}
#end_block

#method_before
@Override
public void run() {
    log.info("Running account deactivations.");
    try (ManualRequestContext ctx = oneOffRequestContext.open()) {
        deactivationUtil.deactivateInactiveAccounts();
    } catch (Exception e) {
        log.error("Failed to deactivate inactive accounts.", e);
    }
}
#method_after
@Override
public void run() {
    log.debug("Running account deactivations");
    try {
        int numberOfAccountsDeactivated = 0;
        for (AccountState acc : accountQueryProvider.get().query(AccountPredicates.isActive())) {
            log.debug("processing account " + acc.getUserName());
            if (acc.getUserName() != null && !realm.isActive(acc.getUserName())) {
                sif.deactivate(acc.getAccount().getId());
                log.debug("deactivated accout " + acc.getUserName());
                numberOfAccountsDeactivated++;
            }
        }
        log.info("Deactivations complete, {} account(s) were deactivated", numberOfAccountsDeactivated);
    } catch (Exception e) {
        log.error("Failed to deactivate inactive accounts " + e.getMessage(), e);
    }
}
#end_block

#method_before
default Boolean isActive(String username) throws LoginException, NamingException, AccountException {
    return true;
}
#method_after
default boolean isActive(@SuppressWarnings("unused") String username) throws LoginException, NamingException, AccountException {
    return true;
}
#end_block

#method_before
@Override
public AuthRequest authenticate(AuthRequest who) throws AccountException {
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        who.setLocalUser(who.getLocalUser().toLowerCase(Locale.US));
    }
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, who.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username, fetchMemberOfEagerly);
            helper.updateRequestActiveStatus(schema, ctx, username, who);
            if (authConfig.getAuthType() == AuthType.LDAP && !who.isSkipAuthentication()) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), who.getPassword()).close();
            }
            who.setDisplayName(apply(schema.accountFullName, m));
            who.setUserName(apply(schema.accountSshUserName, m));
            if (schema.accountEmailAddress != null) {
                who.setEmailAddress(apply(schema.accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // 
            if (fetchMemberOfEagerly || mandatoryGroup != null) {
                Set<AccountGroup.UUID> groups = helper.queryForGroups(ctx, username, m);
                if (mandatoryGroup != null) {
                    GroupReference mandatoryGroupRef = GroupBackends.findExactSuggestion(groupBackend, mandatoryGroup);
                    if (mandatoryGroupRef == null) {
                        throw new AccountException("Could not identify mandatory group: " + mandatoryGroup);
                    }
                    if (!groups.contains(mandatoryGroupRef.getUUID())) {
                        throw new AccountException("Not member of mandatory LDAP group: " + mandatoryGroupRef.getName());
                    }
                }
                // Regardless if we enabled fetchMemberOfEagerly, we already have the
                // groups and it would be a waste not to cache them.
                membershipCache.put(username, groups);
            }
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    }
}
#method_after
@Override
public AuthRequest authenticate(AuthRequest who) throws AccountException {
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        who.setLocalUser(who.getLocalUser().toLowerCase(Locale.US));
    }
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, who.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            LdapQuery.Result m;
            who.setAuthProvidesAccountActiveStatus(true);
            try {
                m = helper.findAccount(schema, ctx, username, fetchMemberOfEagerly);
                who.setActive(true);
            } catch (NoSuchUserException e) {
                who.setActive(false);
                return who;
            }
            if (authConfig.getAuthType() == AuthType.LDAP && !who.isSkipAuthentication()) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), who.getPassword()).close();
            }
            who.setDisplayName(apply(schema.accountFullName, m));
            who.setUserName(apply(schema.accountSshUserName, m));
            if (schema.accountEmailAddress != null) {
                who.setEmailAddress(apply(schema.accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // 
            if (fetchMemberOfEagerly || mandatoryGroup != null) {
                Set<AccountGroup.UUID> groups = helper.queryForGroups(ctx, username, m);
                if (mandatoryGroup != null) {
                    GroupReference mandatoryGroupRef = GroupBackends.findExactSuggestion(groupBackend, mandatoryGroup);
                    if (mandatoryGroupRef == null) {
                        throw new AccountException("Could not identify mandatory group: " + mandatoryGroup);
                    }
                    if (!groups.contains(mandatoryGroupRef.getUUID())) {
                        throw new AccountException("Not member of mandatory LDAP group: " + mandatoryGroupRef.getName());
                    }
                }
                // Regardless if we enabled fetchMemberOfEagerly, we already have the
                // groups and it would be a waste not to cache them.
                membershipCache.put(username, groups);
            }
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
@Override
public Boolean isActive(String username) throws NamingException, AccountException, LoginException {
    try {
        final DirContext ctx = helper.open();
        final Helper.LdapSchema schema = helper.getSchema(ctx);
        helper.findAccount(schema, ctx, username, false);
    } catch (NoSuchUserException e) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean isActive(String username) throws LoginException, NamingException, AccountException {
    try {
        DirContext ctx = helper.open();
        Helper.LdapSchema schema = helper.getSchema(ctx);
        helper.findAccount(schema, ctx, username, false);
    } catch (NoSuchUserException e) {
        return false;
    }
    return true;
}
#end_block

#method_before
public AuthResult authenticate(AuthRequest who) throws AccountException, IOException {
    IdentifiedUser user;
    who = realm.authenticate(who);
    try {
        try (ReviewDb db = schema.open()) {
            ExternalId id = externalIds.get(who.getExternalIdKey());
            if (id == null) {
                // 
                return create(db, who);
            }
            // Account exists
            Account act = byIdCache.get(id.accountId()).getAccount();
            if (supportAutomaticAccountActivityUpdate.get()) {
                user = genericUserFactory.create(act.getId());
                if (who.isActive() && !act.isActive()) {
                    try {
                        setInactiveFlag.activate(user);
                    } catch (ResourceNotFoundException e) {
                        throw new AccountException("Unable to activate account.", e);
                    }
                } else if (!who.isActive() && act.isActive()) {
                    try {
                        setInactiveFlag.deactivate(user);
                    } catch (RestApiException e) {
                        throw new AccountException("Unable to deactivate account.", e);
                    }
                }
            }
            act = byIdCache.get(id.accountId()).getAccount();
            if (!act.isActive()) {
                throw new AccountException("Authentication error, account inactive");
            }
            // return the identity to the caller.
            update(db, who, id);
            return new AuthResult(id.accountId(), who.getExternalIdKey(), false);
        }
    } catch (OrmException | ConfigInvalidException e) {
        throw new AccountException("Authentication error", e);
    }
}
#method_after
public AuthResult authenticate(AuthRequest who) throws AccountException, IOException {
    who = realm.authenticate(who);
    try {
        try (ReviewDb db = schema.open()) {
            ExternalId id = externalIds.get(who.getExternalIdKey());
            if (id == null) {
                // 
                return create(db, who);
            }
            // Account exists
            Account act = byIdCache.get(id.accountId()).getAccount();
            if (autoUpdateAccountActiveStatus && who.authProvidesAccountActiveStatus()) {
                if (who.isActive() && !act.isActive()) {
                    try {
                        setInactiveFlag.activate(act.getId());
                        act = byIdCache.get(id.accountId()).getAccount();
                    } catch (ResourceNotFoundException e) {
                        throw new AccountException("Unable to activate account " + act.getId(), e);
                    }
                } else if (!who.isActive() && act.isActive()) {
                    try {
                        setInactiveFlag.deactivate(act.getId());
                        act = byIdCache.get(id.accountId()).getAccount();
                    } catch (RestApiException e) {
                        throw new AccountException("Unable to deactivate account " + act.getId(), e);
                    }
                }
            }
            if (!act.isActive()) {
                throw new AccountException("Authentication error, account inactive");
            }
            // return the identity to the caller.
            update(who, id);
            return new AuthResult(id.accountId(), who.getExternalIdKey(), false);
        }
    } catch (OrmException | ConfigInvalidException e) {
        throw new AccountException("Authentication error", e);
    }
}
#end_block

#method_before
private void update(ReviewDb db, AuthRequest who, ExternalId extId) throws OrmException, IOException, ConfigInvalidException {
    IdentifiedUser user = userFactory.create(extId.accountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.email();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        externalIdsUpdateFactory.create().replace(extId, ExternalId.create(extId.key(), extId.accountId(), newEmail, extId.password()));
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME) && !Strings.isNullOrEmpty(who.getDisplayName()) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME) && who.getUserName() != null && !eq(user.getUserName(), who.getUserName())) {
        log.warn(String.format("Not changing already set username %s to %s", user.getUserName(), who.getUserName()));
    }
    if (toUpdate != null) {
        accountsUpdateFactory.create().update(db, toUpdate);
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
}
#method_after
private void update(AuthRequest who, ExternalId extId) throws OrmException, IOException, ConfigInvalidException {
    IdentifiedUser user = userFactory.create(extId.accountId());
    List<Consumer<Account>> accountUpdates = new ArrayList<>();
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.email();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            accountUpdates.add(a -> a.setPreferredEmail(newEmail));
        }
        externalIdsUpdateFactory.create().replace(extId, ExternalId.create(extId.key(), extId.accountId(), newEmail, extId.password()));
    }
    if (!realm.allowsEdit(AccountFieldName.FULL_NAME) && !Strings.isNullOrEmpty(who.getDisplayName()) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        accountUpdates.add(a -> a.setFullName(who.getDisplayName()));
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME) && who.getUserName() != null && !eq(user.getUserName(), who.getUserName())) {
        log.warn(String.format("Not changing already set username %s to %s", user.getUserName(), who.getUserName()));
    }
    if (!accountUpdates.isEmpty()) {
        Account account = accountsUpdateFactory.create().update(user.getAccountId(), accountUpdates);
        if (account == null) {
            throw new OrmException("Account " + user.getAccountId() + " has been deleted");
        }
    }
}
#end_block

#method_before
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException, IOException, ConfigInvalidException {
    Account.Id newId = new Account.Id(db.nextAccountId());
    Account account = new Account(newId, TimeUtil.nowTs());
    ExternalId extId = ExternalId.createWithEmail(who.getExternalIdKey(), newId, who.getEmailAddress());
    account.setFullName(who.getDisplayName());
    account.setPreferredEmail(extId.email());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && !accounts.hasAnyAccount();
    try {
        AccountsUpdate accountsUpdate = accountsUpdateFactory.create();
        accountsUpdate.upsert(db, account);
        ExternalId existingExtId = externalIds.get(extId.key());
        if (existingExtId != null && !existingExtId.accountId().equals(extId.accountId())) {
            // external ID is assigned to another account, do not overwrite
            accountsUpdate.delete(db, account);
            throw new AccountException("Cannot assign external ID \"" + extId.key().get() + "\" to account " + newId + "; external ID already in use.");
        }
        externalIdsUpdateFactory.create().upsert(extId);
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        AccountGroup g = db.accountGroups().byUUID(uuid).iterator().next();
        AccountGroup.Id adminId = g.getId();
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(newId, adminId));
        auditService.dispatchAddAccountsToGroup(newId, Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (who.getUserName() != null) {
        // Only set if the name hasn't been used yet, but was given to us.
        // 
        IdentifiedUser user = userFactory.create(newId);
        try {
            changeUserNameFactory.create(user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(db, account, extId, message, e, true);
        }
    }
    byEmailCache.evict(account.getPreferredEmail());
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.key(), true);
}
#method_after
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException, IOException, ConfigInvalidException {
    Account.Id newId = new Account.Id(sequences.nextAccountId());
    ExternalId extId = ExternalId.createWithEmail(who.getExternalIdKey(), newId, who.getEmailAddress());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && !accounts.hasAnyAccount();
    Account account;
    try {
        AccountsUpdate accountsUpdate = accountsUpdateFactory.create();
        account = accountsUpdate.insert(newId, a -> {
            a.setFullName(who.getDisplayName());
            a.setPreferredEmail(extId.email());
        });
        ExternalId existingExtId = externalIds.get(extId.key());
        if (existingExtId != null && !existingExtId.accountId().equals(extId.accountId())) {
            // external ID is assigned to another account, do not overwrite
            accountsUpdate.delete(account);
            throw new AccountException("Cannot assign external ID \"" + extId.key().get() + "\" to account " + newId + "; external ID already in use.");
        }
        externalIdsUpdateFactory.create().upsert(extId);
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    IdentifiedUser user = userFactory.create(newId);
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        // The user initiated this request by logging in. -> Attribute all modifications to that user.
        GroupsUpdate groupsUpdate = groupsUpdateFactory.create(user);
        try {
            groupsUpdate.addGroupMember(db, uuid, newId);
        } catch (NoSuchGroupException e) {
            throw new AccountException(String.format("Group %s not found", uuid));
        }
    }
    if (who.getUserName() != null) {
        // 
        try {
            changeUserNameFactory.create(user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(account, extId, message, e, true);
        }
    }
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.key(), true);
}
#end_block

#method_before
private void handleSettingUserNameFailure(ReviewDb db, Account account, ExternalId extId, String errorMessage, Exception e, boolean logException) throws AccountUserNameException, OrmException, IOException, ConfigInvalidException {
    if (logException) {
        log.error(errorMessage, e);
    } else {
        log.error(errorMessage);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        // setting the given user name has failed, but the realm does not
        // allow the user to manually set a user name,
        // this means we would end with an account without user name
        // (without 'username:<USERNAME>' entry in
        // account_external_ids table),
        // such an account cannot be used for uploading changes,
        // this is why the best we can do here is to fail early and cleanup
        // the database
        accountsUpdateFactory.create().delete(db, account);
        externalIdsUpdateFactory.create().delete(extId);
        throw new AccountUserNameException(errorMessage, e);
    }
}
#method_after
private void handleSettingUserNameFailure(Account account, ExternalId extId, String errorMessage, Exception e, boolean logException) throws AccountUserNameException, OrmException, IOException, ConfigInvalidException {
    if (logException) {
        log.error(errorMessage, e);
    } else {
        log.error(errorMessage);
    }
    if (!realm.allowsEdit(AccountFieldName.USER_NAME)) {
        // setting the given user name has failed, but the realm does not
        // allow the user to manually set a user name,
        // this means we would end with an account without user name
        // (without 'username:<USERNAME>' external ID),
        // such an account cannot be used for uploading changes,
        // this is why the best we can do here is to fail early and cleanup
        // the database
        accountsUpdateFactory.create().delete(account);
        externalIdsUpdateFactory.create().delete(extId);
        throw new AccountUserNameException(errorMessage, e);
    }
}
#end_block

#method_before
public AuthResult link(Account.Id to, AuthRequest who) throws AccountException, OrmException, IOException, ConfigInvalidException {
    try (ReviewDb db = schema.open()) {
        ExternalId extId = externalIds.get(who.getExternalIdKey());
        if (extId != null) {
            if (!extId.accountId().equals(to)) {
                throw new AccountException("Identity in use by another account");
            }
            update(db, who, extId);
        } else {
            externalIdsUpdateFactory.create().insert(ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress()));
            if (who.getEmailAddress() != null) {
                Account a = accounts.get(db, to);
                if (a.getPreferredEmail() == null) {
                    a.setPreferredEmail(who.getEmailAddress());
                    accountsUpdateFactory.create().update(db, a);
                }
                byEmailCache.evict(who.getEmailAddress());
            }
        }
        return new AuthResult(to, who.getExternalIdKey(), false);
    }
}
#method_after
public AuthResult link(Account.Id to, AuthRequest who) throws AccountException, OrmException, IOException, ConfigInvalidException {
    ExternalId extId = externalIds.get(who.getExternalIdKey());
    if (extId != null) {
        if (!extId.accountId().equals(to)) {
            throw new AccountException("Identity '" + extId.key().get() + "' in use by another account");
        }
        update(who, extId);
    } else {
        externalIdsUpdateFactory.create().insert(ExternalId.createWithEmail(who.getExternalIdKey(), to, who.getEmailAddress()));
        if (who.getEmailAddress() != null) {
            accountsUpdateFactory.create().update(to, a -> {
                if (a.getPreferredEmail() == null) {
                    a.setPreferredEmail(who.getEmailAddress());
                }
            });
        }
    }
    return new AuthResult(to, who.getExternalIdKey(), false);
}
#end_block

#method_before
public AuthResult unlink(Account.Id from, AuthRequest who) throws AccountException, OrmException, IOException, ConfigInvalidException {
    try (ReviewDb db = schema.open()) {
        ExternalId extId = externalIds.get(who.getExternalIdKey());
        if (extId != null) {
            if (!extId.accountId().equals(from)) {
                throw new AccountException("Identity '" + who.getExternalIdKey().get() + "' in use by another account");
            }
            externalIdsUpdateFactory.create().delete(extId);
            if (who.getEmailAddress() != null) {
                Account a = accounts.get(db, from);
                if (a.getPreferredEmail() != null && a.getPreferredEmail().equals(who.getEmailAddress())) {
                    a.setPreferredEmail(null);
                    accountsUpdateFactory.create().update(db, a);
                }
                byEmailCache.evict(who.getEmailAddress());
            }
        } else {
            throw new AccountException("Identity '" + who.getExternalIdKey().get() + "' not found");
        }
        return new AuthResult(from, who.getExternalIdKey(), false);
    }
}
#method_after
public void unlink(Account.Id from, ExternalId.Key extIdKey) throws AccountException, OrmException, IOException, ConfigInvalidException {
    unlink(from, ImmutableList.of(extIdKey));
}
#end_block

#method_before
public Boolean isActive() {
    return active;
}
#method_after
public boolean isActive() {
    return active;
}
#end_block

#method_before
@Override
public AuthRequest authenticate(AuthRequest who) throws AccountException {
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        who.setLocalUser(who.getLocalUser().toLowerCase(Locale.US));
    }
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, who.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username, fetchMemberOfEagerly);
            helper.updateAccountActiveStatus(schema, ctx, username, who);
            if (authConfig.getAuthType() == AuthType.LDAP && !who.isSkipAuthentication()) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), who.getPassword()).close();
            }
            who.setDisplayName(apply(schema.accountFullName, m));
            who.setUserName(apply(schema.accountSshUserName, m));
            if (schema.accountEmailAddress != null) {
                who.setEmailAddress(apply(schema.accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // 
            if (fetchMemberOfEagerly || mandatoryGroup != null) {
                Set<AccountGroup.UUID> groups = helper.queryForGroups(ctx, username, m);
                if (mandatoryGroup != null) {
                    GroupReference mandatoryGroupRef = GroupBackends.findExactSuggestion(groupBackend, mandatoryGroup);
                    if (mandatoryGroupRef == null) {
                        throw new AccountException("Could not identify mandatory group: " + mandatoryGroup);
                    }
                    if (!groups.contains(mandatoryGroupRef.getUUID())) {
                        throw new AccountException("Not member of mandatory LDAP group: " + mandatoryGroupRef.getName());
                    }
                }
                // Regardless if we enabled fetchMemberOfEagerly, we already have the
                // groups and it would be a waste not to cache them.
                membershipCache.put(username, groups);
            }
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    }
}
#method_after
@Override
public AuthRequest authenticate(AuthRequest who) throws AccountException {
    if (config.getBoolean("ldap", "localUsernameToLowerCase", false)) {
        who.setLocalUser(who.getLocalUser().toLowerCase(Locale.US));
    }
    final String username = who.getLocalUser();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, who.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            LdapQuery.Result m;
            who.setAuthProvidesAccountActiveStatus(true);
            try {
                m = helper.findAccount(schema, ctx, username, fetchMemberOfEagerly);
                who.setActive(true);
            } catch (NoSuchUserException e) {
                who.setActive(false);
                return who;
            }
            if (authConfig.getAuthType() == AuthType.LDAP && !who.isSkipAuthentication()) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), who.getPassword()).close();
            }
            who.setDisplayName(apply(schema.accountFullName, m));
            who.setUserName(apply(schema.accountSshUserName, m));
            if (schema.accountEmailAddress != null) {
                who.setEmailAddress(apply(schema.accountEmailAddress, m));
            } else if (emailExpander.canExpand(username)) {
                // If LDAP cannot give us a valid email address for this user
                // try expanding it through the older email expander code which
                // assumes a user name within a domain.
                // 
                who.setEmailAddress(emailExpander.expand(username));
            }
            // 
            if (fetchMemberOfEagerly || mandatoryGroup != null) {
                Set<AccountGroup.UUID> groups = helper.queryForGroups(ctx, username, m);
                if (mandatoryGroup != null) {
                    GroupReference mandatoryGroupRef = GroupBackends.findExactSuggestion(groupBackend, mandatoryGroup);
                    if (mandatoryGroupRef == null) {
                        throw new AccountException("Could not identify mandatory group: " + mandatoryGroup);
                    }
                    if (!groups.contains(mandatoryGroupRef.getUUID())) {
                        throw new AccountException("Not member of mandatory LDAP group: " + mandatoryGroupRef.getName());
                    }
                }
                // Regardless if we enabled fetchMemberOfEagerly, we already have the
                // groups and it would be a waste not to cache them.
                membershipCache.put(username, groups);
            }
            return who;
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthenticationUnavailableException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
public static void tryRecursiveDelete(Path dir) {
    try {
        Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                tryDelete(file);
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {
                tryDelete(dir);
                return FileVisitResult.CONTINUE;
            }
        });
    } catch (IOException e) {
    }
}
#method_after
public static void tryRecursiveDelete(Path dir) {
    try {
        Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                tryDelete(file);
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {
                tryDelete(dir);
                return FileVisitResult.CONTINUE;
            }
        });
    } catch (IOException e) {
    // Intent of 'try' function is to ignore these.
    }
}
#end_block

#method_before
public static void tryDelete(Path path) {
    try {
        Files.delete(path);
    } catch (IOException e) {
    }
}
#method_after
public static void tryDelete(Path path) {
    try {
        Files.delete(path);
    } catch (IOException e) {
    // Intent of 'try' function is to ignore these.
    }
}
#end_block

#method_before
public static void unsafeRecursiveRmdir(File dir) {
    try {
        while (unsafeRmdir(dir)) {
            dir = dir.getParentFile();
        }
    } catch (IOException e) {
    }
}
#method_after
public static void unsafeRecursiveRmdir(File dir) {
    try {
        while (unsafeRmdir(dir)) {
            dir = dir.getParentFile();
        }
    } catch (IOException e) {
    // Intent of 'try' function is to ignore these.
    }
}
#end_block

#method_before
public static void throwIfNotStaleFileHandle(IOException e) throws IOException {
    if (!isStaleFileHandle(e)) {
        throw e;
    }
}
#method_after
public static <T extends Throwable> void throwIfNotStaleFileHandle(T e) throws T {
    if (!isStaleFileHandleInCausalChain(e)) {
        throw e;
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try {
        try (Repository repo = repoManager.openRepository(allUsersName)) {
            ProgressMonitor pm = new TextProgressMonitor();
            pm.beginTask("Removing \"My Drafts\" menu items", ProgressMonitor.UNKNOWN);
            for (Account.Id id : Accounts.allIds(repo)) {
                if (removeMyDrafts(repo, id)) {
                    pm.update(1);
                }
            }
            pm.endTask();
        }
    } catch (IOException | ConfigInvalidException e) {
        throw new OrmException("Removing \"My Drafts\" menu items failed", e);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try {
        try (Repository repo = repoManager.openRepository(allUsersName)) {
            ProgressMonitor pm = new TextProgressMonitor();
            pm.beginTask("Removing \"My Drafts\" menu items", ProgressMonitor.UNKNOWN);
            for (Account.Id id : (Iterable<Account.Id>) Accounts.readUserRefs(repo)::iterator) {
                if (removeMyDrafts(repo, id)) {
                    pm.update(1);
                }
            }
            pm.endTask();
        }
    } catch (IOException | ConfigInvalidException e) {
        throw new OrmException("Removing \"My Drafts\" menu items failed", e);
    }
}
#end_block

#method_before
private static Stream<Account.Id> readUserRefs(Repository repo) throws IOException {
    return repo.getRefDatabase().getRefs(RefNames.REFS_USERS).values().stream().map(r -> Account.Id.fromRef(r.getName())).filter(Objects::nonNull);
}
#method_after
public static Stream<Account.Id> readUserRefs(Repository repo) throws IOException {
    return repo.getRefDatabase().getRefs(RefNames.REFS_USERS).values().stream().map(r -> Account.Id.fromRef(r.getName())).filter(Objects::nonNull);
}
#end_block

#method_before
public static void tryRecursiveDelete(Path dir) {
    try {
        Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                tryDelete(file);
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {
                tryDelete(dir);
                return FileVisitResult.CONTINUE;
            }
        });
    } catch (IOException e) {
    }
}
#method_after
public static void tryRecursiveDelete(Path dir) {
    try {
        Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                tryDelete(file);
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {
                tryDelete(dir);
                return FileVisitResult.CONTINUE;
            }
        });
    } catch (IOException e) {
    // Intent of 'try' function is to ignore these.
    }
}
#end_block

#method_before
public static void tryDelete(Path path) {
    try {
        Files.delete(path);
    } catch (IOException e) {
    }
}
#method_after
public static void tryDelete(Path path) {
    try {
        Files.delete(path);
    } catch (IOException e) {
    // Intent of 'try' function is to ignore these.
    }
}
#end_block

#method_before
public static void unsafeRecursiveRmdir(File dir) {
    try {
        while (unsafeRmdir(dir)) {
            dir = dir.getParentFile();
        }
    } catch (IOException e) {
    }
}
#method_after
public static void unsafeRecursiveRmdir(File dir) {
    try {
        while (unsafeRmdir(dir)) {
            dir = dir.getParentFile();
        }
    } catch (IOException e) {
    // Intent of 'try' function is to ignore these.
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    index = new FakeChangeIndex(FakeChangeIndex.V2);
    indexes = new ChangeIndexCollection();
    indexes.setSearchIndex(index);
    queryBuilder = new FakeQueryBuilder(indexes);
    rewrite = new ChangeIndexRewriter(indexes, IndexConfig.create(0, 0, 3));
}
#method_after
@Before
public void setUp() throws Exception {
    index = new FakeChangeIndex(FakeChangeIndex.V2);
    indexes = new ChangeIndexCollection();
    indexes.setSearchIndex(index);
    queryBuilder = new FakeQueryBuilder(indexes);
    rewrite = new ChangeIndexRewriter(indexes, IndexConfig.builder().maxTerms(3).build());
}
#end_block

#method_before
@Test
public void unsupportedIndexOperator() throws Exception {
    Predicate<ChangeData> in = parse("status:merged file:a");
    assertThat(rewrite(in)).isEqualTo(query(in));
    indexes.setSearchIndex(new FakeChangeIndex(FakeChangeIndex.V1));
    Predicate<ChangeData> out = rewrite(in);
    assertThat(out).isInstanceOf(AndPredicate.class);
    assertThat(out.getChildren()).containsExactly(query(in.getChild(0)), in.getChild(1)).inOrder();
}
#method_after
@Test
public void unsupportedIndexOperator() throws Exception {
    Predicate<ChangeData> in = parse("status:merged file:a");
    assertThat(rewrite(in)).isEqualTo(query(in));
    indexes.setSearchIndex(new FakeChangeIndex(FakeChangeIndex.V1));
    exception.expect(QueryParseException.class);
    exception.expectMessage("Unsupported index predicate: file:a");
    rewrite(in);
}
#end_block

#method_before
@Override
public void review(ReviewInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public ReviewResult review(ReviewInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void submit() {
    throw new NotImplementedException();
}
#method_after
@Override
public void submit() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void submit(SubmitInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public void submit(SubmitInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeApi cherryPick(CherryPickInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi cherryPick(CherryPickInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeApi rebase() {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi rebase() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeApi rebase(RebaseInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi rebase(RebaseInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public boolean canRebase() {
    throw new NotImplementedException();
}
#method_after
@Override
public boolean canRebase() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public RevisionReviewerApi reviewer(String id) {
    throw new NotImplementedException();
}
#method_after
@Override
public RevisionReviewerApi reviewer(String id) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void setReviewed(String path, boolean reviewed) {
    throw new NotImplementedException();
}
#method_after
@Override
public void setReviewed(String path, boolean reviewed) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Set<String> reviewed() {
    throw new NotImplementedException();
}
#method_after
@Override
public Set<String> reviewed() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public MergeableInfo mergeable() {
    throw new NotImplementedException();
}
#method_after
@Override
public MergeableInfo mergeable() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public MergeableInfo mergeableOtherBranches() {
    throw new NotImplementedException();
}
#method_after
@Override
public MergeableInfo mergeableOtherBranches() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, FileInfo> files(String base) {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, FileInfo> files(String base) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, FileInfo> files(int parentNum) {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, FileInfo> files(int parentNum) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, FileInfo> files() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, FileInfo> files() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> comments() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, List<RobotCommentInfo>> robotComments() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<CommentInfo> commentsAsList() {
    throw new NotImplementedException();
}
#method_after
@Override
public List<CommentInfo> commentsAsList() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<CommentInfo> draftsAsList() {
    throw new NotImplementedException();
}
#method_after
@Override
public List<CommentInfo> draftsAsList() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<RobotCommentInfo> robotCommentsAsList() {
    throw new NotImplementedException();
}
#method_after
@Override
public List<RobotCommentInfo> robotCommentsAsList() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> drafts() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public DraftApi createDraft(DraftInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public DraftApi createDraft(DraftInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public DraftApi draft(String id) {
    throw new NotImplementedException();
}
#method_after
@Override
public DraftApi draft(String id) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public CommentApi comment(String id) {
    throw new NotImplementedException();
}
#method_after
@Override
public CommentApi comment(String id) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public RobotCommentApi robotComment(String id) {
    throw new NotImplementedException();
}
#method_after
@Override
public RobotCommentApi robotComment(String id) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public BinaryResult patch() {
    throw new NotImplementedException();
}
#method_after
@Override
public BinaryResult patch() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public BinaryResult patch(String path) {
    throw new NotImplementedException();
}
#method_after
@Override
public BinaryResult patch(String path) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, ActionInfo> actions() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, ActionInfo> actions() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SubmitType submitType() {
    throw new NotImplementedException();
}
#method_after
@Override
public SubmitType submitType() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public BinaryResult submitPreview() {
    throw new NotImplementedException();
}
#method_after
@Override
public BinaryResult submitPreview() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public BinaryResult submitPreview(String format) {
    throw new NotImplementedException();
}
#method_after
@Override
public BinaryResult submitPreview(String format) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SubmitType testSubmitType(TestSubmitRuleInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public SubmitType testSubmitType(TestSubmitRuleInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public MergeListRequest getMergeList() {
    throw new NotImplementedException();
}
#method_after
@Override
public MergeListRequest getMergeList() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void description(String description) {
    throw new NotImplementedException();
}
#method_after
@Override
public void description(String description) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public String description() {
    throw new NotImplementedException();
}
#method_after
@Override
public String description() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public String etag() {
    throw new NotImplementedException();
}
#method_after
@Override
public String etag() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Test
public void submitChangesAcrossRepos() throws Exception {
    Project.NameKey p1 = createProject("project-where-we-submit");
    Project.NameKey p2 = createProject("project-impacted-via-topic");
    Project.NameKey p3 = createProject("project-impacted-indirectly-via-topic");
    RevCommit initialHead2 = getRemoteHead(p2, "master");
    RevCommit initialHead3 = getRemoteHead(p3, "master");
    TestRepository<?> repo1 = cloneProject(p1);
    TestRepository<?> repo2 = cloneProject(p2);
    TestRepository<?> repo3 = cloneProject(p3);
    PushOneCommit.Result change1a = createChange(repo1, "master", "An ancestor of the change we want to submit", "a.txt", "1", "dependent-topic");
    PushOneCommit.Result change1b = createChange(repo1, "master", "We're interested in submitting this change", "a.txt", "2", "topic-to-submit");
    PushOneCommit.Result change2a = createChange(repo2, "master", "indirection level 1", "a.txt", "1", "topic-indirect");
    PushOneCommit.Result change2b = createChange(repo2, "master", "should go in with first change", "a.txt", "2", "dependent-topic");
    PushOneCommit.Result change3 = createChange(repo3, "master", "indirection level 2", "a.txt", "1", "topic-indirect");
    approve(change1a.getChangeId());
    approve(change2a.getChangeId());
    approve(change2b.getChangeId());
    approve(change3.getChangeId());
    // get a preview before submitting:
    BinaryResult request = submitPreview(change1b.getChangeId());
    Map<Branch.NameKey, RevTree> preview = fetchFromBundles(request);
    submit(change1b.getChangeId());
    RevCommit tip1 = getRemoteLog(p1, "master").get(0);
    RevCommit tip2 = getRemoteLog(p2, "master").get(0);
    RevCommit tip3 = getRemoteLog(p3, "master").get(0);
    assertThat(tip1.getShortMessage()).isEqualTo(change1b.getCommit().getShortMessage());
    if (isSubmitWholeTopicEnabled()) {
        assertThat(tip2.getShortMessage()).isEqualTo(change2b.getCommit().getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3.getCommit().getShortMessage());
        // check that the preview matched what happened:
        assertThat(preview).hasSize(3);
        assertThat(preview).containsKey(new Branch.NameKey(p1, "refs/heads/master"));
        assertRevTrees(p1, preview);
        assertThat(preview).containsKey(new Branch.NameKey(p2, "refs/heads/master"));
        assertRevTrees(p2, preview);
        assertThat(preview).containsKey(new Branch.NameKey(p3, "refs/heads/master"));
        assertRevTrees(p3, preview);
    } else {
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(initialHead3.getShortMessage());
        assertThat(preview).hasSize(1);
        assertThat(preview.get(new Branch.NameKey(p1, "refs/heads/master"))).isNotNull();
    }
}
#method_after
@Test
public void submitChangesAcrossRepos() throws Exception {
    Project.NameKey p1 = createProject("project-where-we-submit");
    Project.NameKey p2 = createProject("project-impacted-via-topic");
    Project.NameKey p3 = createProject("project-impacted-indirectly-via-topic");
    RevCommit initialHead2 = getRemoteHead(p2, "master");
    RevCommit initialHead3 = getRemoteHead(p3, "master");
    TestRepository<?> repo1 = cloneProject(p1);
    TestRepository<?> repo2 = cloneProject(p2);
    TestRepository<?> repo3 = cloneProject(p3);
    PushOneCommit.Result change1a = createChange(repo1, "master", "An ancestor of the change we want to submit", "a.txt", "1", "dependent-topic");
    PushOneCommit.Result change1b = createChange(repo1, "master", "We're interested in submitting this change", "a.txt", "2", "topic-to-submit");
    PushOneCommit.Result change2a = createChange(repo2, "master", "indirection level 1", "a.txt", "1", "topic-indirect");
    PushOneCommit.Result change2b = createChange(repo2, "master", "should go in with first change", "a.txt", "2", "dependent-topic");
    PushOneCommit.Result change3 = createChange(repo3, "master", "indirection level 2", "a.txt", "1", "topic-indirect");
    approve(change1a.getChangeId());
    approve(change2a.getChangeId());
    approve(change2b.getChangeId());
    approve(change3.getChangeId());
    // get a preview before submitting:
    Map<Branch.NameKey, ObjectId> preview = fetchFromSubmitPreview(change1b.getChangeId());
    submit(change1b.getChangeId());
    RevCommit tip1 = getRemoteLog(p1, "master").get(0);
    RevCommit tip2 = getRemoteLog(p2, "master").get(0);
    RevCommit tip3 = getRemoteLog(p3, "master").get(0);
    assertThat(tip1.getShortMessage()).isEqualTo(change1b.getCommit().getShortMessage());
    if (isSubmitWholeTopicEnabled()) {
        assertThat(tip2.getShortMessage()).isEqualTo(change2b.getCommit().getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3.getCommit().getShortMessage());
        // check that the preview matched what happened:
        assertThat(preview).hasSize(3);
        assertThat(preview).containsKey(new Branch.NameKey(p1, "refs/heads/master"));
        assertTrees(p1, preview);
        assertThat(preview).containsKey(new Branch.NameKey(p2, "refs/heads/master"));
        assertTrees(p2, preview);
        assertThat(preview).containsKey(new Branch.NameKey(p3, "refs/heads/master"));
        assertTrees(p3, preview);
    } else {
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(initialHead3.getShortMessage());
        assertThat(preview).hasSize(1);
        assertThat(preview.get(new Branch.NameKey(p1, "refs/heads/master"))).isNotNull();
    }
}
#end_block

#method_before
@Test
public void submitChangesAcrossReposBlocked() throws Exception {
    Project.NameKey p1 = createProject("project-where-we-submit");
    Project.NameKey p2 = createProject("project-impacted-via-topic");
    Project.NameKey p3 = createProject("project-impacted-indirectly-via-topic");
    TestRepository<?> repo1 = cloneProject(p1);
    TestRepository<?> repo2 = cloneProject(p2);
    TestRepository<?> repo3 = cloneProject(p3);
    RevCommit initialHead1 = getRemoteHead(p1, "master");
    RevCommit initialHead2 = getRemoteHead(p2, "master");
    RevCommit initialHead3 = getRemoteHead(p3, "master");
    PushOneCommit.Result change1a = createChange(repo1, "master", "An ancestor of the change we want to submit", "a.txt", "1", "dependent-topic");
    PushOneCommit.Result change1b = createChange(repo1, "master", "we're interested to submit this change", "a.txt", "2", "topic-to-submit");
    PushOneCommit.Result change2a = createChange(repo2, "master", "indirection level 2a", "a.txt", "1", "topic-indirect");
    PushOneCommit.Result change2b = createChange(repo2, "master", "should go in with first change", "a.txt", "2", "dependent-topic");
    PushOneCommit.Result change3 = createChange(repo3, "master", "indirection level 2b", "a.txt", "1", "topic-indirect");
    // Create a merge conflict for change3 which is only indirectly related
    // via topics.
    repo3.reset(initialHead3);
    PushOneCommit.Result change3Conflict = createChange(repo3, "master", "conflicting change", "a.txt", "2\n2", "conflicting-topic");
    submit(change3Conflict.getChangeId());
    RevCommit tipConflict = getRemoteLog(p3, "master").get(0);
    assertThat(tipConflict.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
    approve(change1a.getChangeId());
    approve(change2a.getChangeId());
    approve(change2b.getChangeId());
    approve(change3.getChangeId());
    if (isSubmitWholeTopicEnabled()) {
        String msg = "Failed to submit 5 changes due to the following problems:\n" + "Change " + change3.getChange().getId() + ": Change could not be " + "merged due to a path conflict. Please rebase the change locally " + "and upload the rebased commit for review.";
        // Get a preview before submitting:
        try {
            // We cannot just use the ExpectedException infrastructure as provided
            // by AbstractDaemonTest, as then we'd stop early and not test the
            // actual submit.
            submitPreview(change1b.getChangeId());
            fail("expected failure");
        } catch (RestApiException e) {
            assertThat(e.getMessage()).isEqualTo(msg);
        }
        submitWithConflict(change1b.getChangeId(), msg);
    } else {
        submit(change1b.getChangeId());
    }
    RevCommit tip1 = getRemoteLog(p1, "master").get(0);
    RevCommit tip2 = getRemoteLog(p2, "master").get(0);
    RevCommit tip3 = getRemoteLog(p3, "master").get(0);
    if (isSubmitWholeTopicEnabled()) {
        assertThat(tip1.getShortMessage()).isEqualTo(initialHead1.getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
        assertNoSubmitter(change1a.getChangeId(), 1);
        assertNoSubmitter(change2a.getChangeId(), 1);
        assertNoSubmitter(change2b.getChangeId(), 1);
        assertNoSubmitter(change3.getChangeId(), 1);
    } else {
        assertThat(tip1.getShortMessage()).isEqualTo(change1b.getCommit().getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
        assertNoSubmitter(change2a.getChangeId(), 1);
        assertNoSubmitter(change2b.getChangeId(), 1);
        assertNoSubmitter(change3.getChangeId(), 1);
    }
}
#method_after
@Test
public void submitChangesAcrossReposBlocked() throws Exception {
    Project.NameKey p1 = createProject("project-where-we-submit");
    Project.NameKey p2 = createProject("project-impacted-via-topic");
    Project.NameKey p3 = createProject("project-impacted-indirectly-via-topic");
    TestRepository<?> repo1 = cloneProject(p1);
    TestRepository<?> repo2 = cloneProject(p2);
    TestRepository<?> repo3 = cloneProject(p3);
    RevCommit initialHead1 = getRemoteHead(p1, "master");
    RevCommit initialHead2 = getRemoteHead(p2, "master");
    RevCommit initialHead3 = getRemoteHead(p3, "master");
    PushOneCommit.Result change1a = createChange(repo1, "master", "An ancestor of the change we want to submit", "a.txt", "1", "dependent-topic");
    PushOneCommit.Result change1b = createChange(repo1, "master", "we're interested to submit this change", "a.txt", "2", "topic-to-submit");
    PushOneCommit.Result change2a = createChange(repo2, "master", "indirection level 2a", "a.txt", "1", "topic-indirect");
    PushOneCommit.Result change2b = createChange(repo2, "master", "should go in with first change", "a.txt", "2", "dependent-topic");
    PushOneCommit.Result change3 = createChange(repo3, "master", "indirection level 2b", "a.txt", "1", "topic-indirect");
    // Create a merge conflict for change3 which is only indirectly related
    // via topics.
    repo3.reset(initialHead3);
    PushOneCommit.Result change3Conflict = createChange(repo3, "master", "conflicting change", "a.txt", "2\n2", "conflicting-topic");
    submit(change3Conflict.getChangeId());
    RevCommit tipConflict = getRemoteLog(p3, "master").get(0);
    assertThat(tipConflict.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
    approve(change1a.getChangeId());
    approve(change2a.getChangeId());
    approve(change2b.getChangeId());
    approve(change3.getChangeId());
    if (isSubmitWholeTopicEnabled()) {
        String msg = "Failed to submit 5 changes due to the following problems:\n" + "Change " + change3.getChange().getId() + ": Change could not be " + "merged due to a path conflict. Please rebase the change locally " + "and upload the rebased commit for review.";
        // Get a preview before submitting:
        try (BinaryResult r = submitPreview(change1b.getChangeId())) {
            // We cannot just use the ExpectedException infrastructure as provided
            // by AbstractDaemonTest, as then we'd stop early and not test the
            // actual submit.
            fail("expected failure");
        } catch (RestApiException e) {
            assertThat(e.getMessage()).isEqualTo(msg);
        }
        submitWithConflict(change1b.getChangeId(), msg);
    } else {
        submit(change1b.getChangeId());
    }
    RevCommit tip1 = getRemoteLog(p1, "master").get(0);
    RevCommit tip2 = getRemoteLog(p2, "master").get(0);
    RevCommit tip3 = getRemoteLog(p3, "master").get(0);
    if (isSubmitWholeTopicEnabled()) {
        assertThat(tip1.getShortMessage()).isEqualTo(initialHead1.getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
        assertNoSubmitter(change1a.getChangeId(), 1);
        assertNoSubmitter(change2a.getChangeId(), 1);
        assertNoSubmitter(change2b.getChangeId(), 1);
        assertNoSubmitter(change3.getChangeId(), 1);
    } else {
        assertThat(tip1.getShortMessage()).isEqualTo(change1b.getCommit().getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
        assertNoSubmitter(change2a.getChangeId(), 1);
        assertNoSubmitter(change2b.getChangeId(), 1);
        assertNoSubmitter(change3.getChangeId(), 1);
    }
}
#end_block

#method_before
@Test
public void submitWithOpenAncestorsOnOtherBranch() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change1 = createChange(testRepo, "master", "base commit", "a.txt", "1", "");
    submit(change1.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    gApi.projects().name(project.get()).branch("branch").create(new BranchInput());
    PushOneCommit.Result change2 = createChange(testRepo, "master", "We want to commit this to master first", "a.txt", "2", "");
    approve(change2.getChangeId());
    RevCommit tip1 = getRemoteLog(project, "master").get(0);
    assertThat(tip1.getShortMessage()).isEqualTo(change1.getCommit().getShortMessage());
    RevCommit tip2 = getRemoteLog(project, "branch").get(0);
    assertThat(tip2.getShortMessage()).isEqualTo(change1.getCommit().getShortMessage());
    PushOneCommit.Result change3a = createChange(testRepo, "branch", "This commit is based on change2 pending for master, " + "but is targeted itself at branch, which doesn't include it.", "a.txt", "3", "a-topic-here");
    Project.NameKey p3 = createProject("project-related-to-change3");
    TestRepository<?> repo3 = cloneProject(p3);
    RevCommit repo3Head = getRemoteHead(p3, "master");
    PushOneCommit.Result change3b = createChange(repo3, "master", "some accompanying changes for change3a in another repo " + "tied together via topic", "a.txt", "1", "a-topic-here");
    approve(change3b.getChangeId());
    String cnt = isSubmitWholeTopicEnabled() ? "2 changes" : "1 change";
    submitWithConflict(change3a.getChangeId(), "Failed to submit " + cnt + " due to the following problems:\n" + "Change " + change3a.getChange().getId() + ": depends on change that" + " was not submitted");
    RevCommit tipbranch = getRemoteLog(project, "branch").get(0);
    assertThat(tipbranch.getShortMessage()).isEqualTo(change1.getCommit().getShortMessage());
    RevCommit tipmaster = getRemoteLog(p3, "master").get(0);
    assertThat(tipmaster.getShortMessage()).isEqualTo(repo3Head.getShortMessage());
    assertRefUpdatedEvents(initialHead, headAfterFirstSubmit);
    assertChangeMergedEvents(change1.getChangeId(), headAfterFirstSubmit.name());
}
#method_after
@Test
public void submitWithOpenAncestorsOnOtherBranch() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change1 = createChange(testRepo, "master", "base commit", "a.txt", "1", "");
    submit(change1.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    gApi.projects().name(project.get()).branch("branch").create(new BranchInput());
    PushOneCommit.Result change2 = createChange(testRepo, "master", "We want to commit this to master first", "a.txt", "2", "");
    approve(change2.getChangeId());
    RevCommit tip1 = getRemoteLog(project, "master").get(0);
    assertThat(tip1.getShortMessage()).isEqualTo(change1.getCommit().getShortMessage());
    RevCommit tip2 = getRemoteLog(project, "branch").get(0);
    assertThat(tip2.getShortMessage()).isEqualTo(change1.getCommit().getShortMessage());
    PushOneCommit.Result change3a = createChange(testRepo, "branch", "This commit is based on change2 pending for master, " + "but is targeted itself at branch, which doesn't include it.", "a.txt", "3", "a-topic-here");
    Project.NameKey p3 = createProject("project-related-to-change3");
    TestRepository<?> repo3 = cloneProject(p3);
    RevCommit repo3Head = getRemoteHead(p3, "master");
    PushOneCommit.Result change3b = createChange(repo3, "master", "some accompanying changes for change3a in another repo tied together via topic", "a.txt", "1", "a-topic-here");
    approve(change3b.getChangeId());
    String cnt = isSubmitWholeTopicEnabled() ? "2 changes" : "1 change";
    submitWithConflict(change3a.getChangeId(), "Failed to submit " + cnt + " due to the following problems:\n" + "Change " + change3a.getChange().getId() + ": depends on change that" + " was not submitted");
    RevCommit tipbranch = getRemoteLog(project, "branch").get(0);
    assertThat(tipbranch.getShortMessage()).isEqualTo(change1.getCommit().getShortMessage());
    RevCommit tipmaster = getRemoteLog(p3, "master").get(0);
    assertThat(tipmaster.getShortMessage()).isEqualTo(repo3Head.getShortMessage());
    assertRefUpdatedEvents(initialHead, headAfterFirstSubmit);
    assertChangeMergedEvents(change1.getChangeId(), headAfterFirstSubmit.name());
}
#end_block

#method_before
@Test
public void testPreviewSubmitTgz() throws Exception {
    Project.NameKey p1 = createProject("project-name");
    TestRepository<?> repo1 = cloneProject(p1);
    PushOneCommit.Result change1 = createChange(repo1, "master", "test", "a.txt", "1", "topic");
    approve(change1.getChangeId());
    // get a preview before submitting:
    BinaryResult request = submitPreview(change1.getChangeId(), "tgz");
    assertThat(request.getContentType()).isEqualTo("application/x-gzip");
    File tempfile = File.createTempFile("test", null);
    request.writeTo(new FileOutputStream(tempfile));
    InputStream is = new GZIPInputStream(new FileInputStream(tempfile));
    List<String> untarredFiles = new ArrayList<>();
    try (TarArchiveInputStream tarInputStream = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream("tar", is)) {
        TarArchiveEntry entry = null;
        while ((entry = (TarArchiveEntry) tarInputStream.getNextEntry()) != null) {
            untarredFiles.add(entry.getName());
        }
    }
    assertThat(untarredFiles).containsExactly(name("project-name") + ".git");
}
#method_after
@Test
public void testPreviewSubmitTgz() throws Exception {
    Project.NameKey p1 = createProject("project-name");
    TestRepository<?> repo1 = cloneProject(p1);
    PushOneCommit.Result change1 = createChange(repo1, "master", "test", "a.txt", "1", "topic");
    approve(change1.getChangeId());
    // get a preview before submitting:
    File tempfile;
    try (BinaryResult request = submitPreview(change1.getChangeId(), "tgz")) {
        assertThat(request.getContentType()).isEqualTo("application/x-gzip");
        tempfile = File.createTempFile("test", null);
        request.writeTo(Files.newOutputStream(tempfile.toPath()));
    }
    InputStream is = new GZIPInputStream(Files.newInputStream(tempfile.toPath()));
    List<String> untarredFiles = new ArrayList<>();
    try (TarArchiveInputStream tarInputStream = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream("tar", is)) {
        TarArchiveEntry entry = null;
        while ((entry = (TarArchiveEntry) tarInputStream.getNextEntry()) != null) {
            untarredFiles.add(entry.getName());
        }
    }
    assertThat(untarredFiles).containsExactly(name("project-name") + ".git");
}
#end_block

#method_before
public PatchSetInserter setNotify(NotifyHandling notify) {
    this.notify = notify;
    return this;
}
#method_after
public PatchSetInserter setNotify(NotifyHandling notify) {
    this.notify = Preconditions.checkNotNull(notify);
    return this;
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws AuthException, ResourceConflictException, IOException, OrmException {
    validate(ctx);
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, getPatchSetId().toRefName(), ReceiveCommand.Type.CREATE));
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws AuthException, ResourceConflictException, IOException, OrmException, PermissionBackendException {
    validate(ctx);
    ctx.addRefUpdate(ObjectId.zeroId(), commitId, getPatchSetId().toRefName());
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new ResourceConflictException(String.format("Cannot create new patch set of change %s because it is %s", change.getId(), change.getStatus().name().toLowerCase()));
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        PatchSet prevPs = psUtil.current(db, ctx.getNotes());
        if (prevPs != null) {
            newGroups = prevPs.getGroups();
        }
    }
    patchSet = psUtil.insert(db, ctx.getRevWalk(), ctx.getUpdate(psId), psId, commit, newGroups, null, description);
    if (notify != NotifyHandling.NONE) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), ctx.getWhen(), message, ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (!allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = ctx.getDb();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new ResourceConflictException(String.format("Cannot create new patch set of change %s because it is %s", change.getId(), ChangeUtil.status(change)));
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        PatchSet prevPs = psUtil.current(db, ctx.getNotes());
        if (prevPs != null) {
            newGroups = prevPs.getGroups();
        }
    }
    patchSet = psUtil.insert(db, ctx.getRevWalk(), ctx.getUpdate(psId), psId, commitId, newGroups, null, description);
    if (notify != NotifyHandling.NONE) {
        oldReviewers = approvalsUtil.getReviewers(db, ctx.getNotes());
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), ctx.getWhen(), message, ChangeMessagesUtil.uploadedPatchSetTag(change.isWorkInProgress()));
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    if (!allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    if (copyApprovals) {
        approvalCopier.copyInReviewDb(db, ctx.getNotes(), ctx.getUser(), patchSet, ctx.getRevWalk(), ctx.getRepoView().getConfig());
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
private void validate(RepoContext ctx) throws AuthException, ResourceConflictException, IOException, OrmException {
    if (checkAddPatchSetPermission && !origCtl.canAddPatchSet(ctx.getDb())) {
        throw new AuthException("cannot add patch set");
    }
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    String refName = getPatchSetId().toRefName();
    CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName.substring(0, refName.lastIndexOf('/') + 1) + "new"), origCtl.getProjectControl().getProject(), origCtl.getRefControl().getRefName(), commit, ctx.getIdentifiedUser());
    try {
        commitValidatorsFactory.create(validatePolicy, origCtl.getRefControl(), new NoSshInfo(), ctx.getRepository()).validate(event);
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws AuthException, ResourceConflictException, IOException, PermissionBackendException {
    if (checkAddPatchSetPermission) {
        permissionBackend.user(ctx.getUser()).database(ctx.getDb()).change(origNotes).check(ChangePermission.ADD_PATCH_SET);
    }
    if (!validate) {
        return;
    }
    PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).ref(origNotes.getChange().getDest());
    String refName = getPatchSetId().toRefName();
    try (CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commitId, refName.substring(0, refName.lastIndexOf('/') + 1) + "new"), projectCache.checkedGet(origNotes.getProjectName()).getProject(), origNotes.getChange().getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) {
        commitValidatorsFactory.forGerritCommits(perm, origNotes.getChange().getDest(), ctx.getIdentifiedUser(), new NoSshInfo(), ctx.getRevWalk()).validate(event);
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    }
}
#end_block

#method_before
public ChangeInfo format(ChangeResource rsrc) throws OrmException {
    return format(changeDataFactory.create(db.get(), rsrc.getControl()));
}
#method_after
public ChangeInfo format(ChangeResource rsrc) throws OrmException {
    return format(changeDataFactory.create(db.get(), rsrc.getNotes()));
}
#end_block

#method_before
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.throwIfInstanceOf(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#method_after
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | PermissionBackendException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.throwIfInstanceOf(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#end_block

#method_before
public ChangeInfo format(RevisionResource rsrc) throws OrmException {
    ChangeData cd = changeDataFactory.create(db.get(), rsrc.getControl());
    return format(cd, Optional.of(rsrc.getPatchSet().getId()), true);
}
#method_after
public ChangeInfo format(RevisionResource rsrc) throws OrmException {
    ChangeData cd = changeDataFactory.create(db.get(), rsrc.getNotes());
    return format(cd, Optional.of(rsrc.getPatchSet().getId()), true);
}
#end_block

#method_before
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#method_after
private List<ChangeInfo> toChangeInfo(Map<Change.Id, ChangeInfo> out, List<ChangeData> changes) {
    List<ChangeInfo> info = Lists.newArrayListWithCapacity(changes.size());
    for (ChangeData cd : changes) {
        ChangeInfo i = out.get(cd.getId());
        if (i == null) {
            try {
                i = toChangeInfo(cd, Optional.empty());
            } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | PermissionBackendException | RuntimeException e) {
                if (has(CHECK)) {
                    i = checkOnly(cd);
                } else if (e instanceof NoSuchChangeException) {
                    log.info("NoSuchChangeException: Omitting corrupt change " + cd.getId() + " from results. Seems to be stale in the index.");
                    continue;
                } else {
                    log.warn("Omitting corrupt change " + cd.getId() + " from results", e);
                    continue;
                }
            }
            out.put(cd.getId(), i);
        }
        info.add(i);
    }
    return info;
}
#end_block

#method_before
private ChangeInfo checkOnly(ChangeData cd) {
    ChangeControl ctl;
    try {
        ctl = cd.changeControl().forUser(userProvider.get());
    } catch (OrmException e) {
        String msg = "Error loading change";
        log.warn(msg + " " + cd.getId(), e);
        ChangeInfo info = new ChangeInfo();
        info._number = cd.getId().get();
        ProblemInfo p = new ProblemInfo();
        p.message = msg;
        info.problems = Lists.newArrayList(p);
        return info;
    }
    ConsistencyChecker.Result result = checkerProvider.get().check(ctl, fix);
    ChangeInfo info;
    Change c = result.change();
    if (c != null) {
        info = new ChangeInfo();
        info.project = c.getProject().get();
        info.branch = c.getDest().getShortName();
        info.topic = c.getTopic();
        info.changeId = c.getKey().get();
        info.subject = c.getSubject();
        info.status = c.getStatus().asChangeStatus();
        info.owner = new AccountInfo(c.getOwner().get());
        info.created = c.getCreatedOn();
        info.updated = c.getLastUpdatedOn();
        info._number = c.getId().get();
        info.problems = result.problems();
        finish(info);
    } else {
        info = new ChangeInfo();
        info._number = result.id().get();
        info.problems = result.problems();
    }
    return info;
}
#method_after
private ChangeInfo checkOnly(ChangeData cd) {
    ChangeNotes notes;
    try {
        notes = cd.notes();
    } catch (OrmException e) {
        String msg = "Error loading change";
        log.warn(msg + " " + cd.getId(), e);
        ChangeInfo info = new ChangeInfo();
        info._number = cd.getId().get();
        ProblemInfo p = new ProblemInfo();
        p.message = msg;
        info.problems = Lists.newArrayList(p);
        return info;
    }
    ConsistencyChecker.Result result = checkerProvider.get().check(notes, fix);
    ChangeInfo info;
    Change c = result.change();
    if (c != null) {
        info = new ChangeInfo();
        info.project = c.getProject().get();
        info.branch = c.getDest().getShortName();
        info.topic = c.getTopic();
        info.changeId = c.getKey().get();
        info.subject = c.getSubject();
        info.status = c.getStatus().asChangeStatus();
        info.owner = new AccountInfo(c.getOwner().get());
        info.created = c.getCreatedOn();
        info.updated = c.getLastUpdatedOn();
        info._number = c.getId().get();
        info.problems = result.problems();
        info.isPrivate = c.isPrivate() ? true : null;
        info.workInProgress = c.isWorkInProgress() ? true : null;
        info.hasReviewStarted = c.hasReviewStarted();
        finish(info);
    } else {
        info = new ChangeInfo();
        info._number = result.id().get();
        info.problems = result.problems();
    }
    return info;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(ctl, cd) : ImmutableMap.of();
        }
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
        out.removableReviewers = removableReviewers(ctl, out);
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException, PermissionBackendException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    PermissionBackend.WithUser withUser = permissionBackend.user(user).database(db);
    PermissionBackend.ForChange perm = lazyLoad ? withUser.change(cd) : withUser.indexedChange(cd, notesFactory.createFromIndexedChange(cd.change()));
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    if (indexes.getSearchIndex().getSchema().hasField(ChangeField.ASSIGNEE)) {
        if (in.getAssignee() != null) {
            out.assignee = accountLoader.get(in.getAssignee());
        }
    }
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        out.muted = stars.contains(StarredChangesUtil.MUTE_LABEL + "/" + cd.currentPatchSet().getPatchSetId()) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        if (out.muted != null) {
            out.reviewed = true;
        } else {
            out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
        }
    }
    out.labels = labelsFor(perm, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? permittedLabels(perm, cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    out.plugins = pluginDefinedAttributesFactory != null ? pluginDefinedAttributesFactory.create(cd) : null;
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    ChangeControl ctl = null;
    if (needMessages || needRevisions) {
        ctl = changeControlFactory.controlFor(db.get(), cd.change(), userProvider.get());
    }
    if (needMessages) {
        out.messages = messages(ctl, cd);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeControl ctl, ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus().isOpen() ? labelsForOpenChange(ctl, cd, labelTypes, standard, detailed) : labelsForClosedChange(ctl, cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#method_after
private Map<String, LabelInfo> labelsFor(PermissionBackend.ForChange perm, ChangeData cd, boolean standard, boolean detailed) throws OrmException, PermissionBackendException {
    if (!standard && !detailed) {
        return null;
    }
    LabelTypes labelTypes = cd.getLabelTypes();
    Map<String, LabelWithStatus> withStatus = cd.change().getStatus() == Change.Status.MERGED ? labelsForSubmittedChange(perm, cd, labelTypes, standard, detailed) : labelsForUnsubmittedChange(perm, cd, labelTypes, standard, detailed);
    return ImmutableMap.copyOf(Maps.transformValues(withStatus, LabelWithStatus::label));
}
#end_block

#method_before
private Map<String, LabelWithStatus> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelWithStatus p = labels.get(r.label);
            if (p == null || p.status().compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        case IMPOSSIBLE:
                        case MAY:
                        case NEED:
                        default:
                            break;
                    }
                }
                n.optional = r.status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, LabelWithStatus.create(n, r.status));
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelWithStatus p = labels.get(r.label);
            if (p == null || p.status().compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        case IMPOSSIBLE:
                        case MAY:
                        case NEED:
                        default:
                            break;
                    }
                }
                n.optional = r.status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, LabelWithStatus.create(n, r.status));
            }
        }
    }
    return labels;
}
#end_block

#method_before
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    Change.Status status = cd.change().getStatus();
    checkState(status.isOpen(), "should not call setAllApprovals on %s change", status);
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        Map<String, VotingRangeInfo> pvr = getPermittedVotingRanges(permittedLabels(ctl, cd));
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            VotingRangeInfo permittedVotingRange = pvr.getOrDefault(lt.getName(), null);
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
                if (psa.isPostSubmit()) {
                    log.warn("unexpected post-submit approval on open change: {}", psa);
                }
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, permittedVotingRange, tag, date));
        }
    }
}
#method_after
private void setAllApprovals(PermissionBackend.ForChange basePerm, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException, PermissionBackendException {
    Change.Status status = cd.change().getStatus();
    checkState(status != Change.Status.MERGED, "should not call setAllApprovals on %s change", status);
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().byState(ReviewerStateInternal.REVIEWER));
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), cd.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    LabelTypes labelTypes = cd.getLabelTypes();
    for (Account.Id accountId : allUsers) {
        PermissionBackend.ForChange perm = basePerm.user(userFactory.create(accountId));
        Map<String, VotingRangeInfo> pvr = getPermittedVotingRanges(permittedLabels(perm, cd));
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = labelTypes.byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            VotingRangeInfo permittedVotingRange = pvr.getOrDefault(lt.getName(), null);
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = perm.test(new LabelPermission(lt)) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
                if (psa.isPostSubmit()) {
                    log.warn("unexpected post-submit approval on open change: {}", psa);
                }
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = perm.test(new LabelPermission(lt)) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, permittedVotingRange, tag, date));
        }
    }
}
#end_block

#method_before
private Map<String, Collection<String>> permittedLabels(ChangeControl ctl, ChangeData cd) throws OrmException {
    if (ctl == null || !ctl.getUser().isIdentifiedUser()) {
        return null;
    }
    Map<String, Short> labels = null;
    boolean isMerged = ctl.getChange().getStatus() == Change.Status.MERGED;
    LabelTypes labelTypes = ctl.getLabelTypes();
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null || (isMerged && !type.allowPostSubmit())) {
                continue;
            }
            PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
            for (LabelValue v : type.getValues()) {
                boolean ok = range.contains(v.getValue());
                if (isMerged) {
                    if (labels == null) {
                        labels = currentLabels(ctl);
                    }
                    short prev = labels.getOrDefault(type.getName(), (short) 0);
                    ok &= v.getValue() >= prev;
                }
                if (ok) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#method_after
private Map<String, Collection<String>> permittedLabels(PermissionBackend.ForChange perm, ChangeData cd) throws OrmException, PermissionBackendException {
    boolean isMerged = cd.change().getStatus() == Change.Status.MERGED;
    LabelTypes labelTypes = cd.getLabelTypes();
    Map<String, LabelType> toCheck = new HashMap<>();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels != null) {
            for (SubmitRecord.Label r : rec.labels) {
                LabelType type = labelTypes.byLabel(r.label);
                if (type != null && (!isMerged || type.allowPostSubmit())) {
                    toCheck.put(type.getName(), type);
                }
            }
        }
    }
    Map<String, Short> labels = null;
    Set<LabelPermission.WithValue> can = perm.testLabels(toCheck.values());
    SetMultimap<String, String> permitted = LinkedHashMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null || (isMerged && !type.allowPostSubmit())) {
                continue;
            }
            for (LabelValue v : type.getValues()) {
                boolean ok = can.contains(new LabelPermission.WithValue(type, v));
                if (isMerged) {
                    if (labels == null) {
                        labels = currentLabels(perm, cd);
                    }
                    short prev = labels.getOrDefault(type.getName(), (short) 0);
                    ok &= v.getValue() >= prev;
                }
                if (ok) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#end_block

#method_before
private Map<String, Short> currentLabels(ChangeControl ctl) throws OrmException {
    Map<String, Short> result = new HashMap<>();
    for (PatchSetApproval psa : approvalsUtil.byPatchSetUser(db.get(), ctl, ctl.getChange().currentPatchSetId(), ctl.getUser().getAccountId())) {
        result.put(psa.getLabel(), psa.getValue());
    }
    return result;
}
#method_after
private Map<String, Short> currentLabels(PermissionBackend.ForChange perm, ChangeData cd) throws OrmException {
    IdentifiedUser user = perm.user().asIdentifiedUser();
    Map<String, Short> result = new HashMap<>();
    for (PatchSetApproval psa : approvalsUtil.byPatchSetUser(db.get(), lazyLoad ? cd.notes() : notesFactory.createFromIndexedChange(cd.change()), user, cd.change().currentPatchSetId(), user.getAccountId(), null, null)) {
        result.put(psa.getLabel(), psa.getValue());
    }
    return result;
}
#end_block

#method_before
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            result.add(cmi);
        }
    }
    return result;
}
#method_after
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        if (patchNum == null || ctl.isVisible(db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            Account.Id realAuthor = message.getRealAuthor();
            if (realAuthor != null) {
                cmi.realAuthor = accountLoader.get(realAuthor);
            }
            result.add(cmi);
        }
    }
    return result;
}
#end_block

#method_before
private Collection<AccountInfo> removableReviewers(ChangeControl ctl, ChangeInfo out) {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            Account.Id id = new Account.Id(ai._accountId);
            if (ctl.canRemoveReviewer(id, 0)) {
                removable.add(id);
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#method_after
private Collection<AccountInfo> removableReviewers(ChangeData cd, ChangeInfo out) throws PermissionBackendException, NoSuchChangeException, OrmException {
    // Although this is called removableReviewers, this method also determines
    // which CCs are removable.
    // 
    // For reviewers, we need to look at each approval, because the reviewer
    // should only be considered removable if *all* of their approvals can be
    // removed. First, add all reviewers with *any* removable approval to the
    // "removable" set. Along the way, if we encounter a non-removable approval,
    // add the reviewer to the "fixed" set. Before we return, remove all members
    // of "fixed" from "removable", because not all of their approvals can be
    // removed.
    Collection<LabelInfo> labels = out.labels.values();
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            Account.Id id = new Account.Id(ai._accountId);
            if (removeReviewerControl.testRemoveReviewer(cd, userProvider.get(), id, MoreObjects.firstNonNull(ai.value, 0))) {
                removable.add(id);
            } else {
                fixed.add(id);
            }
        }
    }
    // CCs are simpler than reviewers. They are removable if the ChangeControl
    // would permit a non-negative approval by that account to be removed, in
    // which case add them to removable. We don't need to add unremovable CCs to
    // "fixed" because we only visit each CC once here.
    Collection<AccountInfo> ccs = out.reviewers.get(ReviewerState.CC);
    if (ccs != null) {
        for (AccountInfo ai : ccs) {
            if (ai._accountId != null) {
                Account.Id id = new Account.Id(ai._accountId);
                if (removeReviewerControl.testRemoveReviewer(cd, userProvider.get(), id, 0)) {
                    removable.add(id);
                }
            }
        }
    }
    // Subtract any reviewers with non-removable approvals from the "removable"
    // set. This also subtracts any CCs that for some reason also hold
    // unremovable approvals.
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    // Reviewers added by email are always removable
    for (Collection<AccountInfo> infos : out.reviewers.values()) {
        for (AccountInfo info : infos) {
            if (info._accountId == null) {
                result.add(info);
            }
        }
    }
    return result;
}
#end_block

#method_before
@Nullable
private Repository openRepoIfNecessary(ChangeControl ctl) throws IOException {
    if (has(ALL_COMMITS) || has(CURRENT_COMMIT) || has(COMMIT_FOOTERS)) {
        return repoManager.openRepository(ctl.getProject().getNameKey());
    }
    return null;
}
#method_after
@Nullable
private Repository openRepoIfNecessary(Project.NameKey project) throws IOException {
    if (has(ALL_COMMITS) || has(CURRENT_COMMIT) || has(COMMIT_FOOTERS)) {
        return repoManager.openRepository(project);
    }
    return null;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(ctl)) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo, false, changeInfo));
            }
        }
        return res;
    }
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map, Optional<PatchSet.Id> limitToPsId, ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = openRepoIfNecessary(cd.project());
        RevWalk rw = newRevWalk(repo)) {
        for (PatchSet in : map.values()) {
            PatchSet.Id id = in.getId();
            boolean want = false;
            if (has(ALL_REVISIONS)) {
                want = true;
            } else if (limitToPsId.isPresent()) {
                want = id.equals(limitToPsId.get());
            } else {
                want = id.equals(cd.change().currentPatchSetId());
            }
            if (want && ctl.isVisible(db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(cd, in, repo, rw, false, changeInfo));
            }
        }
        return res;
    }
}
#end_block

#method_before
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(ctl)) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo, true, null);
        accountLoader.fill();
        return rev;
    }
}
#method_after
public RevisionInfo getRevisionInfo(ChangeData cd, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = openRepoIfNecessary(cd.project());
        RevWalk rw = newRevWalk(repo)) {
        RevisionInfo rev = toRevisionInfo(cd, in, repo, rw, true, null);
        accountLoader.fill();
        return rev;
    }
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, @Nullable Repository repo, boolean fillCommit, @Nullable ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(repo, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS), fillCommit);
            }
            if (addFooters) {
                Ref ref = repo.exactRef(ctl.getChange().getDest().get());
                RevCommit mergeTip = null;
                if (ref != null) {
                    mergeTip = rw.parseCommit(ref.getObjectId());
                    rw.parseBody(mergeTip);
                }
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if ((out.isCurrent) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in, @Nullable Repository repo, @Nullable RevWalk rw, boolean fillCommit, @Nullable ChangeInfo changeInfo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = cd.change();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.fetch = makeFetchMap(cd, in);
    out.kind = changeKindCache.getChangeKind(rw, repo != null ? repo.getConfig() : null, cd, in);
    out.description = in.getDescription();
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        checkState(rw != null);
        checkState(repo != null);
        Project.NameKey project = c.getProject();
        String rev = in.getRevision().get();
        RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
        rw.parseBody(commit);
        if (setCommit) {
            out.commit = toCommit(project, rw, commit, has(WEB_LINKS), fillCommit);
        }
        if (addFooters) {
            Ref ref = repo.exactRef(cd.change().getDest().get());
            RevCommit mergeTip = null;
            if (ref != null) {
                mergeTip = rw.parseCommit(ref.getObjectId());
                rw.parseBody(mergeTip);
            }
            out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCommitMessageOnSubmit(commit, mergeTip, cd.notes(), userProvider.get(), in.getId());
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
        out.files.remove(Patch.MERGE_LIST);
    }
    if (out.isCurrent && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(changeInfo, out, new RevisionResource(changeResourceFactory.create(cd.notes(), userProvider.get()), in));
    }
    if (gpgApi.isEnabled() && has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        List<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links;
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            List<WebLinkInfo> parentLinks = webLinks.getParentLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks;
        }
        info.parents.add(i);
    }
    return info;
}
#method_after
CommitInfo toCommit(Project.NameKey project, RevWalk rw, RevCommit commit, boolean addLinks, boolean fillCommit) throws IOException {
    CommitInfo info = new CommitInfo();
    if (fillCommit) {
        info.commit = commit.name();
    }
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        List<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links;
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            List<WebLinkInfo> parentLinks = webLinks.getParentLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks;
        }
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
private Map<String, FetchInfo> makeFetchMap(ChangeControl ctl, PatchSet in) {
    Map<String, FetchInfo> r = new LinkedHashMap<>();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.forUser(anonymous).isPatchVisible(in, db.get())) {
            continue;
        }
        String projectName = ctl.getProject().getNameKey().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#method_after
private Map<String, FetchInfo> makeFetchMap(ChangeData cd, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = new LinkedHashMap<>();
    ChangeControl ctl = changeControlFactory.controlFor(db.get(), cd.change(), anonymous);
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.isVisible(db.get())) {
            continue;
        }
        String projectName = cd.project().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#end_block

#method_before
private List<ChangeAttribute> executeSuccessfulQuery(String params, SshSession session) throws Exception {
    String rawResponse = session.exec("gerrit query --format=JSON " + params);
    assert_().withFailureMessage(session.getError()).that(session.hasError()).isFalse();
    return getChanges(rawResponse);
}
#method_after
private List<ChangeAttribute> executeSuccessfulQuery(String params, SshSession session) throws Exception {
    String rawResponse = session.exec("gerrit query --format=JSON " + params);
    assertWithMessage(session.getError()).that(session.hasError()).isFalse();
    return getChanges(rawResponse);
}
#end_block

#method_before
public ImmutableCollection<PatchSet> byChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChanges()) {
        return ChangeUtil.PS_ID_ORDER.immutableSortedCopy(db.patchSets().byChange(notes.getChangeId()));
    }
    return notes.load().getPatchSets().values();
}
#method_after
public ImmutableCollection<PatchSet> byChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChanges()) {
        return PS_ID_ORDER.immutableSortedCopy(db.patchSets().byChange(notes.getChangeId()));
    }
    return notes.load().getPatchSets().values();
}
#end_block

#method_before
public ImmutableMap<PatchSet.Id, PatchSet> byChangeAsMap(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChanges()) {
        ImmutableMap.Builder<PatchSet.Id, PatchSet> result = ImmutableMap.builder();
        for (PatchSet ps : ChangeUtil.PS_ID_ORDER.sortedCopy(db.patchSets().byChange(notes.getChangeId()))) {
            result.put(ps.getId(), ps);
        }
        return result.build();
    }
    return notes.load().getPatchSets();
}
#method_after
public ImmutableMap<PatchSet.Id, PatchSet> byChangeAsMap(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChanges()) {
        ImmutableMap.Builder<PatchSet.Id, PatchSet> result = ImmutableMap.builder();
        for (PatchSet ps : PS_ID_ORDER.sortedCopy(db.patchSets().byChange(notes.getChangeId()))) {
            result.put(ps.getId(), ps);
        }
        return result.build();
    }
    return notes.load().getPatchSets();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(RevisionReviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Fixes.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FIX_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(ChangeIncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "robotcomments").to(ListChangeRobotComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    get(CHANGE_KIND, "pure_revert").to(GetPureRevert.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "private").to(PostPrivate.class);
    post(CHANGE_KIND, "private.delete").to(DeletePrivateByPost.class);
    delete(CHANGE_KIND, "private").to(DeletePrivate.class);
    put(CHANGE_KIND, "ignore").to(Ignore.class);
    put(CHANGE_KIND, "unignore").to(Unignore.class);
    put(CHANGE_KIND, "mute").to(Mute.class);
    put(CHANGE_KIND, "unmute").to(Unmute.class);
    post(CHANGE_KIND, "wip").to(SetWorkInProgress.class);
    post(CHANGE_KIND, "ready").to(SetReadyForReview.class);
    put(CHANGE_KIND, "message").to(PutMessage.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "reviewers").to(RevisionReviewers.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    delete(COMMENT_KIND).to(DeleteComment.class);
    post(COMMENT_KIND, "delete").to(DeleteComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "fixes").to(Fixes.class);
    post(FIX_KIND, "apply").to(ApplyFix.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(ChangeResource.Factory.class);
    factory(DeleteReviewerByEmailOp.Factory.class);
    factory(DeleteReviewerOp.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(PostReviewersOp.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(WorkInProgressOp.Factory.class);
}
#end_block

#method_before
@Argument(index = 0, required = true, multiValued = true, metaVar = "{COMMIT | CHANGE,PATCHSET}", usage = "list of commits or patch sets to review")
void addPatchSetId(final String token) {
    try {
        PatchSet ps = psParser.parsePatchSet(token, projectControl, branch);
        patchSets.add(ps);
    } catch (UnloggedFailure e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    } catch (OrmException e) {
        throw new IllegalArgumentException("database error", e);
    }
}
#method_after
@Argument(index = 0, required = true, multiValued = true, metaVar = "{COMMIT | CHANGE,PATCHSET}", usage = "list of commits or patch sets to review")
void addPatchSetId(String token) {
    try {
        PatchSet ps = psParser.parsePatchSet(token, projectControl, branch);
        patchSets.add(ps);
    } catch (UnloggedFailure e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    } catch (OrmException e) {
        throw new IllegalArgumentException("database error", e);
    }
}
#end_block

#method_before
@Option(name = "--label", aliases = "-l", usage = "custom label(s) to assign", metaVar = "LABEL=VALUE")
void addLabel(final String token) {
    LabelVote v = LabelVote.parseWithEquals(token);
    // Disallow SUBM.
    LabelType.checkName(v.label());
    customLabels.put(v.label(), v.value());
}
#method_after
@Option(name = "--label", aliases = "-l", usage = "custom label(s) to assign", metaVar = "LABEL=VALUE")
void addLabel(String token) {
    LabelVote v = LabelVote.parseWithEquals(token);
    // Disallow SUBM.
    LabelType.checkName(v.label());
    customLabels.put(v.label(), v.value());
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw die("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("abandon and submit actions are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("abandon and rebase actions are mutually exclusive");
        }
        if (moveToBranch != null) {
            throw die("abandon and move actions are mutually exclusive");
        }
    }
    if (json) {
        if (restoreChange) {
            throw die("json and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("json and submit actions are mutually exclusive");
        }
        if (abandonChange) {
            throw die("json and abandon actions are mutually exclusive");
        }
        if (changeComment != null) {
            throw die("json and message are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("json and rebase actions are mutually exclusive");
        }
        if (moveToBranch != null) {
            throw die("json and move actions are mutually exclusive");
        }
        if (changeTag != null) {
            throw die("json and tag actions are mutually exclusive");
        }
    }
    if (rebaseChange) {
        if (submitChange) {
            throw die("rebase and submit actions are mutually exclusive");
        }
    }
    boolean ok = true;
    ReviewInput input = null;
    if (json) {
        input = reviewFromJson();
    }
    for (final PatchSet patchSet : patchSets) {
        try {
            if (input != null) {
                applyReview(patchSet, input);
            } else {
                reviewPatchSet(patchSet);
            }
        } catch (RestApiException | UnloggedFailure e) {
            ok = false;
            writeError("error", e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("error", "no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal", "internal server error while reviewing " + patchSet.getId() + "\n");
            log.error("internal error while reviewing " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw die("one or more reviews failed; review output above");
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw die("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("abandon and submit actions are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("abandon and rebase actions are mutually exclusive");
        }
        if (moveToBranch != null) {
            throw die("abandon and move actions are mutually exclusive");
        }
    }
    if (json) {
        if (restoreChange) {
            throw die("json and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw die("json and submit actions are mutually exclusive");
        }
        if (abandonChange) {
            throw die("json and abandon actions are mutually exclusive");
        }
        if (changeComment != null) {
            throw die("json and message are mutually exclusive");
        }
        if (rebaseChange) {
            throw die("json and rebase actions are mutually exclusive");
        }
        if (moveToBranch != null) {
            throw die("json and move actions are mutually exclusive");
        }
        if (changeTag != null) {
            throw die("json and tag actions are mutually exclusive");
        }
    }
    if (rebaseChange) {
        if (submitChange) {
            throw die("rebase and submit actions are mutually exclusive");
        }
    }
    boolean ok = true;
    ReviewInput input = null;
    if (json) {
        input = reviewFromJson();
    }
    for (PatchSet patchSet : patchSets) {
        try {
            if (input != null) {
                applyReview(patchSet, input);
            } else {
                reviewPatchSet(patchSet);
            }
        } catch (RestApiException | UnloggedFailure e) {
            ok = false;
            writeError("error", e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("error", "no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal", "internal server error while reviewing " + patchSet.getId() + "\n");
            log.error("internal error while reviewing " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw die("one or more reviews failed; review output above");
    }
}
#end_block

#method_before
private void applyReview(PatchSet patchSet, final ReviewInput review) throws RestApiException {
    gApi.changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).review(review);
}
#method_after
private void applyReview(PatchSet patchSet, ReviewInput review) throws RestApiException {
    gApi.changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).review(review);
}
#end_block

#method_before
private void reviewPatchSet(final PatchSet patchSet) throws Exception {
    if (notify == null) {
        notify = NotifyHandling.ALL;
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.tag = Strings.emptyToNull(changeTag);
    review.notify = notify;
    review.labels = new TreeMap<>();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = strictLabels;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // We don't need to add the review comment when abandoning/restoring.
    if (abandonChange || restoreChange || moveToBranch != null) {
        review.message = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = Strings.emptyToNull(changeComment);
            applyReview(patchSet, review);
            changeApi(patchSet).abandon(input);
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = Strings.emptyToNull(changeComment);
            changeApi(patchSet).restore(input);
            applyReview(patchSet, review);
        } else {
            applyReview(patchSet, review);
        }
        if (moveToBranch != null) {
            MoveInput moveInput = new MoveInput();
            moveInput.destinationBranch = moveToBranch;
            moveInput.message = Strings.emptyToNull(changeComment);
            changeApi(patchSet).move(moveInput);
        }
        if (rebaseChange) {
            revisionApi(patchSet).rebase();
        }
        if (submitChange) {
            revisionApi(patchSet).submit();
        }
    } catch (IllegalStateException | RestApiException e) {
        throw die(e);
    }
}
#method_after
private void reviewPatchSet(PatchSet patchSet) throws Exception {
    if (notify == null) {
        notify = NotifyHandling.ALL;
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.tag = Strings.emptyToNull(changeTag);
    review.notify = notify;
    review.labels = new TreeMap<>();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = strictLabels;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // We don't need to add the review comment when abandoning/restoring.
    if (abandonChange || restoreChange || moveToBranch != null) {
        review.message = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = Strings.emptyToNull(changeComment);
            applyReview(patchSet, review);
            changeApi(patchSet).abandon(input);
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = Strings.emptyToNull(changeComment);
            changeApi(patchSet).restore(input);
            applyReview(patchSet, review);
        } else {
            applyReview(patchSet, review);
        }
        if (moveToBranch != null) {
            MoveInput moveInput = new MoveInput();
            moveInput.destinationBranch = moveToBranch;
            moveInput.message = Strings.emptyToNull(changeComment);
            changeApi(patchSet).move(moveInput);
        }
        if (rebaseChange) {
            revisionApi(patchSet).rebase();
        }
        if (submitChange) {
            revisionApi(patchSet).submit();
        }
    } catch (IllegalStateException | RestApiException e) {
        throw die(e);
    }
}
#end_block

#method_before
@Override
protected void parseCommandLine() throws UnloggedFailure {
    optionList = new ArrayList<>();
    customLabels = new HashMap<>();
    ProjectControl allProjectsControl;
    try {
        allProjectsControl = projectControlFactory.controlFor(allProjects);
    } catch (NoSuchProjectException e) {
        throw die("missing " + allProjects.get());
    }
    for (LabelType type : allProjectsControl.getLabelTypes().getLabelTypes()) {
        StringBuilder usage = new StringBuilder("score for ").append(type.getName()).append("\n");
        for (LabelValue v : type.getValues()) {
            usage.append(v.format()).append("\n");
        }
        final String name = "--" + type.getName().toLowerCase();
        optionList.add(new ApproveOption(name, usage.toString(), type));
    }
    super.parseCommandLine();
}
#method_after
@Override
protected void parseCommandLine() throws UnloggedFailure {
    optionList = new ArrayList<>();
    customLabels = new HashMap<>();
    ProjectState allProjectsState;
    try {
        allProjectsState = projectCache.checkedGet(allProjects);
    } catch (IOException e) {
        throw die("missing " + allProjects.get());
    }
    for (LabelType type : allProjectsState.getLabelTypes().getLabelTypes()) {
        StringBuilder usage = new StringBuilder("score for ").append(type.getName()).append("\n");
        for (LabelValue v : type.getValues()) {
            usage.append(v.format()).append("\n");
        }
        final String name = "--" + type.getName().toLowerCase();
        optionList.add(new ApproveOption(name, usage.toString(), type));
    }
    super.parseCommandLine();
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    }
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setStatus(change.getStatus());
    message = newMessage(ctx);
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + ChangeUtil.status(change));
    }
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setStatus(change.getStatus());
    message = newMessage(ctx);
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#end_block

#method_before
@Override
protected void onLoad() {
    if (!loaded) {
        RestApi call = ChangeApi.detail(changeId.get());
        ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_COMMITS, ListChangesOption.ALL_REVISIONS));
        call.get(new AsyncCallback<ChangeInfo>() {

            @Override
            public void onSuccess(ChangeInfo result) {
                if (edit != null) {
                    edit.setName(edit.commit().commit());
                    result.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
                }
                render(result.revisions());
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#method_after
@Override
protected void onLoad() {
    if (!loaded) {
        RestApi call = ChangeApi.detail(project.get(), changeId.get());
        ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_COMMITS, ListChangesOption.ALL_REVISIONS));
        call.get(new AsyncCallback<ChangeInfo>() {

            @Override
            public void onSuccess(ChangeInfo result) {
                if (edit != null) {
                    edit.setName(edit.commit().commit());
                    result.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
                }
                render(result.revisions());
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#end_block

#method_before
private String url(RevisionInfo r) {
    return PageLinks.toChange(changeId, r.id());
}
#method_after
private String url(RevisionInfo r) {
    return PageLinks.toChange(project, changeId, r.id());
}
#end_block

#method_before
@Test
@TestProjectInput(createEmptyCommit = false)
public void submitToEmptyRepo() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    BinaryResult request = submitPreview(change.getChangeId());
    RevCommit headAfterSubmitPreview = getRemoteHead();
    assertThat(headAfterSubmitPreview).isEqualTo(initialHead);
    Map<Branch.NameKey, RevTree> actual = fetchFromBundles(request);
    assertThat(actual).hasSize(1);
    submit(change.getChangeId());
    assertThat(getRemoteHead().getId()).isEqualTo(change.getCommit());
    assertRevTrees(project, actual);
}
#method_after
@Test
@TestProjectInput(createEmptyCommit = false)
public void submitToEmptyRepo() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    Map<Branch.NameKey, ObjectId> actual = fetchFromSubmitPreview(change.getChangeId());
    RevCommit headAfterSubmitPreview = getRemoteHead();
    assertThat(headAfterSubmitPreview).isEqualTo(initialHead);
    assertThat(actual).hasSize(1);
    submit(change.getChangeId());
    assertThat(getRemoteHead().getId()).isEqualTo(change.getCommit());
    assertTrees(project, actual);
}
#end_block

#method_before
@Test
public void submitSingleChange() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    BinaryResult request = submitPreview(change.getChangeId());
    RevCommit headAfterSubmit = getRemoteHead();
    assertThat(headAfterSubmit).isEqualTo(initialHead);
    assertRefUpdatedEvents();
    assertChangeMergedEvents();
    Map<Branch.NameKey, RevTree> actual = fetchFromBundles(request);
    if ((getSubmitType() == SubmitType.CHERRY_PICK) || (getSubmitType() == SubmitType.REBASE_ALWAYS)) {
        // The change is updated as well:
        assertThat(actual).hasSize(2);
    } else {
        assertThat(actual).hasSize(1);
    }
    submit(change.getChangeId());
    assertRevTrees(project, actual);
}
#method_after
@Test
public void submitSingleChange() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    Map<Branch.NameKey, ObjectId> actual = fetchFromSubmitPreview(change.getChangeId());
    RevCommit headAfterSubmit = getRemoteHead();
    assertThat(headAfterSubmit).isEqualTo(initialHead);
    assertRefUpdatedEvents();
    assertChangeMergedEvents();
    if ((getSubmitType() == SubmitType.CHERRY_PICK) || (getSubmitType() == SubmitType.REBASE_ALWAYS)) {
        // The change is updated as well:
        assertThat(actual).hasSize(2);
    } else {
        assertThat(actual).hasSize(1);
    }
    submit(change.getChangeId());
    assertTrees(project, actual);
}
#end_block

#method_before
@Test
public void submitMultipleChangesOtherMergeConflictPreview() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "other content");
    PushOneCommit.Result change3 = createChange("Change 3", "d", "d");
    PushOneCommit.Result change4 = createChange("Change 4", "e", "e");
    // change 2 is not approved, but we ignore labels
    approve(change3.getChangeId());
    BinaryResult request = null;
    String msg = null;
    try {
        request = submitPreview(change4.getChangeId());
    } catch (Exception e) {
        msg = e.getMessage();
    }
    if (getSubmitType() == SubmitType.CHERRY_PICK) {
        Map<Branch.NameKey, RevTree> s = fetchFromBundles(request);
        submit(change4.getChangeId());
        assertRevTrees(project, s);
    } else if (getSubmitType() == SubmitType.FAST_FORWARD_ONLY) {
        assertThat(msg).isEqualTo("Failed to submit 3 changes due to the following problems:\n" + "Change " + change2.getChange().getId() + ": internal error: " + "change not processed by merge strategy\n" + "Change " + change3.getChange().getId() + ": internal error: " + "change not processed by merge strategy\n" + "Change " + change4.getChange().getId() + ": Project policy " + "requires all submissions to be a fast-forward. Please " + "rebase the change locally and upload again for review.");
        RevCommit headAfterSubmit = getRemoteHead();
        assertThat(headAfterSubmit).isEqualTo(headAfterFirstSubmit);
        assertRefUpdatedEvents(initialHead, headAfterFirstSubmit);
        assertChangeMergedEvents(change.getChangeId(), headAfterFirstSubmit.name());
    } else if ((getSubmitType() == SubmitType.REBASE_IF_NECESSARY) || (getSubmitType() == SubmitType.REBASE_ALWAYS)) {
        String change2hash = change2.getChange().currentPatchSet().getRevision().get();
        assertThat(msg).isEqualTo("Cannot rebase " + change2hash + ": The change could " + "not be rebased due to a conflict during merge.");
        RevCommit headAfterSubmit = getRemoteHead();
        assertThat(headAfterSubmit).isEqualTo(headAfterFirstSubmit);
        assertRefUpdatedEvents(initialHead, headAfterFirstSubmit);
        assertChangeMergedEvents(change.getChangeId(), headAfterFirstSubmit.name());
    } else {
        assertThat(msg).isEqualTo("Failed to submit 3 changes due to the following problems:\n" + "Change " + change2.getChange().getId() + ": Change could not be " + "merged due to a path conflict. Please rebase the change " + "locally and upload the rebased commit for review.\n" + "Change " + change3.getChange().getId() + ": Change could not be " + "merged due to a path conflict. Please rebase the change " + "locally and upload the rebased commit for review.\n" + "Change " + change4.getChange().getId() + ": Change could not be " + "merged due to a path conflict. Please rebase the change " + "locally and upload the rebased commit for review.");
        RevCommit headAfterSubmit = getRemoteHead();
        assertThat(headAfterSubmit).isEqualTo(headAfterFirstSubmit);
        assertRefUpdatedEvents(initialHead, headAfterFirstSubmit);
        assertChangeMergedEvents(change.getChangeId(), headAfterFirstSubmit.name());
    }
}
#method_after
@Test
public void submitMultipleChangesOtherMergeConflictPreview() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "other content");
    PushOneCommit.Result change3 = createChange("Change 3", "d", "d");
    PushOneCommit.Result change4 = createChange("Change 4", "e", "e");
    // change 2 is not approved, but we ignore labels
    approve(change3.getChangeId());
    try (BinaryResult request = submitPreview(change4.getChangeId())) {
        assertThat(getSubmitType()).isEqualTo(SubmitType.CHERRY_PICK);
        submit(change4.getChangeId());
    } catch (RestApiException e) {
        switch(getSubmitType()) {
            case FAST_FORWARD_ONLY:
                assertThat(e.getMessage()).isEqualTo("Failed to submit 3 changes due to the following problems:\n" + "Change " + change2.getChange().getId() + ": internal error: " + "change not processed by merge strategy\n" + "Change " + change3.getChange().getId() + ": internal error: " + "change not processed by merge strategy\n" + "Change " + change4.getChange().getId() + ": Project policy " + "requires all submissions to be a fast-forward. Please " + "rebase the change locally and upload again for review.");
                break;
            case REBASE_IF_NECESSARY:
            case REBASE_ALWAYS:
                String change2hash = change2.getChange().currentPatchSet().getRevision().get();
                assertThat(e.getMessage()).isEqualTo("Cannot rebase " + change2hash + ": The change could " + "not be rebased due to a conflict during merge.");
                break;
            case MERGE_ALWAYS:
            case MERGE_IF_NECESSARY:
                assertThat(e.getMessage()).isEqualTo("Failed to submit 3 changes due to the following problems:\n" + "Change " + change2.getChange().getId() + ": Change could not be " + "merged due to a path conflict. Please rebase the change " + "locally and upload the rebased commit for review.\n" + "Change " + change3.getChange().getId() + ": Change could not be " + "merged due to a path conflict. Please rebase the change " + "locally and upload the rebased commit for review.\n" + "Change " + change4.getChange().getId() + ": Change could not be " + "merged due to a path conflict. Please rebase the change " + "locally and upload the rebased commit for review.");
                break;
            case CHERRY_PICK:
            default:
                fail("Should not reach here.");
                break;
        }
        RevCommit headAfterSubmit = getRemoteHead();
        assertThat(headAfterSubmit).isEqualTo(headAfterFirstSubmit);
        assertRefUpdatedEvents(initialHead, headAfterFirstSubmit);
        assertChangeMergedEvents(change.getChangeId(), headAfterFirstSubmit.name());
    }
}
#end_block

#method_before
@Test
public void submitMultipleChangesPreview() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "other content");
    PushOneCommit.Result change3 = createChange("Change 3", "d", "d");
    PushOneCommit.Result change4 = createChange("Change 4", "e", "e");
    // change 2 is not approved, but we ignore labels
    approve(change3.getChangeId());
    BinaryResult request = submitPreview(change4.getChangeId());
    Map<String, Map<String, Integer>> expected = new HashMap<>();
    expected.put(project.get(), new HashMap<String, Integer>());
    expected.get(project.get()).put("refs/heads/master", 3);
    Map<Branch.NameKey, RevTree> actual = fetchFromBundles(request);
    assertThat(actual).containsKey(new Branch.NameKey(project, "refs/heads/master"));
    if (getSubmitType() == SubmitType.CHERRY_PICK) {
        // CherryPick ignores dependencies, thus only change and destination
        // branch refs are modified.
        assertThat(actual).hasSize(2);
    } else if (getSubmitType() == SubmitType.REBASE_ALWAYS) {
        // RebaseAlways takes care of dependencies, therefore Change{2,3,4} and
        // destination branch will be modified.
        assertThat(actual).hasSize(4);
    } else {
        assertThat(actual).hasSize(1);
    }
    // check that the submit preview did not actually submit
    RevCommit headAfterSubmit = getRemoteHead();
    assertThat(headAfterSubmit).isEqualTo(initialHead);
    assertRefUpdatedEvents();
    assertChangeMergedEvents();
    // now check we actually have the same content:
    approve(change2.getChangeId());
    submit(change4.getChangeId());
    assertRevTrees(project, actual);
}
#method_after
@Test
public void submitMultipleChangesPreview() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "other content");
    PushOneCommit.Result change3 = createChange("Change 3", "d", "d");
    PushOneCommit.Result change4 = createChange("Change 4", "e", "e");
    // change 2 is not approved, but we ignore labels
    approve(change3.getChangeId());
    Map<Branch.NameKey, ObjectId> actual = fetchFromSubmitPreview(change4.getChangeId());
    Map<String, Map<String, Integer>> expected = new HashMap<>();
    expected.put(project.get(), new HashMap<>());
    expected.get(project.get()).put("refs/heads/master", 3);
    assertThat(actual).containsKey(new Branch.NameKey(project, "refs/heads/master"));
    if (getSubmitType() == SubmitType.CHERRY_PICK) {
        // CherryPick ignores dependencies, thus only change and destination
        // branch refs are modified.
        assertThat(actual).hasSize(2);
    } else if (getSubmitType() == SubmitType.REBASE_ALWAYS) {
        // RebaseAlways takes care of dependencies, therefore Change{2,3,4} and
        // destination branch will be modified.
        assertThat(actual).hasSize(4);
    } else {
        assertThat(actual).hasSize(1);
    }
    // check that the submit preview did not actually submit
    RevCommit headAfterSubmit = getRemoteHead();
    assertThat(headAfterSubmit).isEqualTo(initialHead);
    assertRefUpdatedEvents();
    assertChangeMergedEvents();
    // now check we actually have the same content:
    approve(change2.getChangeId());
    submit(change4.getChangeId());
    assertTrees(project, actual);
}
#end_block

#method_before
@Test
public void submitNoPermission() throws Exception {
    // create project where submit is blocked
    Project.NameKey p = createProject("p");
    block(Permission.SUBMIT, REGISTERED_USERS, "refs/*", p);
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    submit(result.getChangeId(), new SubmitInput(), AuthException.class, "submit not permitted");
}
#method_after
@Test
public void submitNoPermission() throws Exception {
    // create project where submit is blocked
    Project.NameKey p = createProject("p");
    block(p, "refs/*", Permission.SUBMIT, REGISTERED_USERS);
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    submit(result.getChangeId(), new SubmitInput(), AuthException.class, "submit not permitted");
}
#end_block

#method_before
@Test
public void submitWholeTopic() throws Exception {
    assume().that(isSubmitWholeTopicEnabled()).isTrue();
    String topic = "test-topic";
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content", topic);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "content", topic);
    PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "content", topic);
    approve(change1.getChangeId());
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change3.getChangeId());
    String expectedTopic = name(topic);
    change1.assertChange(Change.Status.MERGED, expectedTopic, admin);
    change2.assertChange(Change.Status.MERGED, expectedTopic, admin);
    change3.assertChange(Change.Status.MERGED, expectedTopic, admin);
    // Check for the exact change to have the correct submitter.
    assertSubmitter(change3);
    // Also check submitters for changes submitted via the topic relationship.
    assertSubmitter(change1);
    assertSubmitter(change2);
    // Check that the repo has the expected commits
    List<RevCommit> log = getRemoteLog();
    List<String> commitsInRepo = log.stream().map(c -> c.getShortMessage()).collect(Collectors.toList());
    int expectedCommitCount = getSubmitType() == SubmitType.MERGE_ALWAYS ? // initial commit + 3 commits + merge commit
    5 : // initial commit + 3 commits
    4;
    assertThat(log).hasSize(expectedCommitCount);
    assertThat(commitsInRepo).containsAllOf("Initial empty repository", "Change 1", "Change 2", "Change 3");
    if (getSubmitType() == SubmitType.MERGE_ALWAYS) {
        assertThat(commitsInRepo).contains("Merge changes from topic '" + expectedTopic + "'");
    }
}
#method_after
@Test
public void submitWholeTopic() throws Exception {
    assume().that(isSubmitWholeTopicEnabled()).isTrue();
    String topic = "test-topic";
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content", topic);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "content", topic);
    PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "content", topic);
    approve(change1.getChangeId());
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change3.getChangeId());
    String expectedTopic = name(topic);
    change1.assertChange(Change.Status.MERGED, expectedTopic, admin);
    change2.assertChange(Change.Status.MERGED, expectedTopic, admin);
    change3.assertChange(Change.Status.MERGED, expectedTopic, admin);
    // Check for the exact change to have the correct submitter.
    assertSubmitter(change3);
    // Also check submitters for changes submitted via the topic relationship.
    assertSubmitter(change1);
    assertSubmitter(change2);
    // Check that the repo has the expected commits
    List<RevCommit> log = getRemoteLog();
    List<String> commitsInRepo = log.stream().map(c -> c.getShortMessage()).collect(toList());
    int expectedCommitCount = getSubmitType() == SubmitType.MERGE_ALWAYS ? // initial commit + 3 commits + merge commit
    5 : // initial commit + 3 commits
    4;
    assertThat(log).hasSize(expectedCommitCount);
    assertThat(commitsInRepo).containsAllOf("Initial empty repository", "Change 1", "Change 2", "Change 3");
    if (getSubmitType() == SubmitType.MERGE_ALWAYS) {
        assertThat(commitsInRepo).contains("Merge changes from topic \"" + expectedTopic + "\"");
    }
}
#end_block

#method_before
@Test
public void submitWithValidationMultiRepo() throws Exception {
    assume().that(isSubmitWholeTopicEnabled()).isTrue();
    String topic = "test-topic";
    // Create test projects
    TestRepository<?> repoA = createProjectWithPush("project-a", null, getSubmitType());
    TestRepository<?> repoB = createProjectWithPush("project-b", null, getSubmitType());
    // Create changes on project-a
    PushOneCommit.Result change1 = createChange(repoA, "master", "Change 1", "a.txt", "content", topic);
    PushOneCommit.Result change2 = createChange(repoA, "master", "Change 2", "b.txt", "content", topic);
    // Create changes on project-b
    PushOneCommit.Result change3 = createChange(repoB, "master", "Change 3", "a.txt", "content", topic);
    PushOneCommit.Result change4 = createChange(repoB, "master", "Change 4", "b.txt", "content", topic);
    List<PushOneCommit.Result> changes = Lists.newArrayList(change1, change2, change3, change4);
    for (PushOneCommit.Result change : changes) {
        approve(change.getChangeId());
    }
    // Construct validator which will throw on a second call.
    // Since there are 2 repos, first submit attempt will fail, the second will
    // succeed.
    List<String> projectsCalled = new ArrayList<>(4);
    this.addOnSubmitValidationListener(new OnSubmitValidationListener() {

        @Override
        public void preBranchUpdate(Arguments args) throws ValidationException {
            assertThat(args.getCommands().keySet()).contains("refs/heads/master");
            try (RevWalk rw = args.newRevWalk()) {
                rw.parseBody(rw.parseCommit(args.getCommands().get("refs/heads/master").getNewId()));
            } catch (IOException e) {
                assertThat(e).isNull();
            }
            projectsCalled.add(args.getProject().get());
            if (projectsCalled.size() == 2) {
                throw new ValidationException("time to fail");
            }
        }
    });
    submitWithConflict(change4.getChangeId(), "time to fail");
    assertThat(projectsCalled).containsExactly(name("project-a"), name("project-b"));
    for (PushOneCommit.Result change : changes) {
        change.assertChange(Change.Status.NEW, name(topic), admin);
    }
    submit(change4.getChangeId());
    assertThat(projectsCalled).containsExactly(name("project-a"), name("project-b"), name("project-a"), name("project-b"));
    for (PushOneCommit.Result change : changes) {
        change.assertChange(Change.Status.MERGED, name(topic), admin);
    }
}
#method_after
@Test
public void submitWithValidationMultiRepo() throws Exception {
    assume().that(isSubmitWholeTopicEnabled()).isTrue();
    String topic = "test-topic";
    // Create test projects
    TestRepository<?> repoA = createProjectWithPush("project-a", null, getSubmitType());
    TestRepository<?> repoB = createProjectWithPush("project-b", null, getSubmitType());
    // Create changes on project-a
    PushOneCommit.Result change1 = createChange(repoA, "master", "Change 1", "a.txt", "content", topic);
    PushOneCommit.Result change2 = createChange(repoA, "master", "Change 2", "b.txt", "content", topic);
    // Create changes on project-b
    PushOneCommit.Result change3 = createChange(repoB, "master", "Change 3", "a.txt", "content", topic);
    PushOneCommit.Result change4 = createChange(repoB, "master", "Change 4", "b.txt", "content", topic);
    List<PushOneCommit.Result> changes = Lists.newArrayList(change1, change2, change3, change4);
    for (PushOneCommit.Result change : changes) {
        approve(change.getChangeId());
    }
    // Construct validator which will throw on a second call.
    // Since there are 2 repos, first submit attempt will fail, the second will
    // succeed.
    List<String> projectsCalled = new ArrayList<>(4);
    this.addOnSubmitValidationListener(new OnSubmitValidationListener() {

        @Override
        public void preBranchUpdate(Arguments args) throws ValidationException {
            String master = "refs/heads/master";
            assertThat(args.getCommands()).containsKey(master);
            ReceiveCommand cmd = args.getCommands().get(master);
            ObjectId newMasterId = cmd.getNewId();
            try (Repository repo = repoManager.openRepository(args.getProject())) {
                assertThat(repo.exactRef(master).getObjectId()).isEqualTo(cmd.getOldId());
                assertThat(args.getRef(master)).hasValue(newMasterId);
                args.getRevWalk().parseBody(args.getRevWalk().parseCommit(newMasterId));
            } catch (IOException e) {
                throw new AssertionError("failed checking new ref value", e);
            }
            projectsCalled.add(args.getProject().get());
            if (projectsCalled.size() == 2) {
                throw new ValidationException("time to fail");
            }
        }
    });
    submitWithConflict(change4.getChangeId(), "time to fail");
    assertThat(projectsCalled).containsExactly(name("project-a"), name("project-b"));
    for (PushOneCommit.Result change : changes) {
        change.assertChange(Change.Status.NEW, name(topic), admin);
    }
    submit(change4.getChangeId());
    assertThat(projectsCalled).containsExactly(name("project-a"), name("project-b"), name("project-a"), name("project-b"));
    for (PushOneCommit.Result change : changes) {
        change.assertChange(Change.Status.MERGED, name(topic), admin);
    }
}
#end_block

#method_before
private void setChangeStatusToNew(PushOneCommit.Result... changes) throws Exception {
    for (PushOneCommit.Result change : changes) {
        try (BatchUpdate bu = updateFactory.create(db, project, userFactory.create(admin.id), TimeUtil.nowTs())) {
            bu.addOp(change.getChange().getId(), new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) throws OrmException {
                    ctx.getChange().setStatus(Change.Status.NEW);
                    ctx.getUpdate(ctx.getChange().currentPatchSetId()).setStatus(Change.Status.NEW);
                    return true;
                }
            });
            bu.execute();
        }
    }
}
#method_after
private void setChangeStatusToNew(PushOneCommit.Result... changes) throws Exception {
    for (PushOneCommit.Result change : changes) {
        try (BatchUpdate bu = batchUpdateFactory.create(db, project, userFactory.create(admin.id), TimeUtil.nowTs())) {
            bu.addOp(change.getChange().getId(), new BatchUpdateOp() {

                @Override
                public boolean updateChange(ChangeContext ctx) throws OrmException {
                    ctx.getChange().setStatus(Change.Status.NEW);
                    ctx.getUpdate(ctx.getChange().currentPatchSetId()).setStatus(Change.Status.NEW);
                    return true;
                }
            });
            bu.execute();
        }
    }
}
#end_block

#method_before
protected void assertRebase(TestRepository<?> testRepo, boolean contentMerge) throws Exception {
    Repository repo = testRepo.getRepository();
    RevCommit localHead = getHead(repo);
    RevCommit remoteHead = getRemoteHead();
    assert_().withFailureMessage(String.format("%s not equal %s", localHead.name(), remoteHead.name())).that(localHead.getId()).isNotEqualTo(remoteHead.getId());
    assertThat(remoteHead.getParentCount()).isEqualTo(1);
    if (!contentMerge) {
        assertThat(getLatestRemoteDiff()).isEqualTo(getLatestDiff(repo));
    }
    assertThat(remoteHead.getShortMessage()).isEqualTo(localHead.getShortMessage());
}
#method_after
protected void assertRebase(TestRepository<?> testRepo, boolean contentMerge) throws Exception {
    Repository repo = testRepo.getRepository();
    RevCommit localHead = getHead(repo);
    RevCommit remoteHead = getRemoteHead();
    assertThat(localHead.getId()).isNotEqualTo(remoteHead.getId());
    assertThat(remoteHead.getParentCount()).isEqualTo(1);
    if (!contentMerge) {
        assertThat(getLatestRemoteDiff()).isEqualTo(getLatestDiff(repo));
    }
    assertThat(remoteHead.getShortMessage()).isEqualTo(localHead.getShortMessage());
}
#end_block

#method_before
ChangeNotesState parseAll() throws ConfigInvalidException, IOException {
    // Don't include initial parse in timer, as this might do more I/O to page
    // in the block containing most commits. Later reads are not guaranteed to
    // avoid I/O, but often should.
    walk.reset();
    walk.markStart(walk.parseCommit(tip));
    try (Timer1.Context timer = metrics.parseLatency.start(CHANGES)) {
        ChangeNotesCommit commit;
        while ((commit = walk.next()) != null) {
            parse(commit);
        }
        parseNotes();
        allPastReviewers.addAll(reviewers.rowKeySet());
        pruneReviewers();
        updatePatchSetStates();
        checkMandatoryFooters();
    }
    return buildState();
}
#method_after
ChangeNotesState parseAll() throws ConfigInvalidException, IOException {
    // Don't include initial parse in timer, as this might do more I/O to page
    // in the block containing most commits. Later reads are not guaranteed to
    // avoid I/O, but often should.
    walk.reset();
    walk.markStart(walk.parseCommit(tip));
    try (Timer1.Context timer = metrics.parseLatency.start(CHANGES)) {
        ChangeNotesCommit commit;
        while ((commit = walk.next()) != null) {
            parse(commit);
        }
        if (hasReviewStarted == null) {
            if (previousWorkInProgressFooter == null) {
                hasReviewStarted = true;
            } else {
                hasReviewStarted = !previousWorkInProgressFooter;
            }
        }
        parseNotes();
        allPastReviewers.addAll(reviewers.rowKeySet());
        pruneReviewers();
        pruneReviewersByEmail();
        updatePatchSetStates();
        checkMandatoryFooters();
    }
    return buildState();
}
#end_block

#method_before
private ChangeNotesState buildState() {
    return ChangeNotesState.create(tip.copy(), id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, assignee != null ? assignee.orElse(null) : null, status, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments);
}
#method_after
private ChangeNotesState buildState() {
    return ChangeNotesState.create(tip.copy(), id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, buildCurrentPatchSetId(), subject, topic, originalSubject, submissionId, assignee != null ? assignee.orElse(null) : null, status, Sets.newLinkedHashSet(Lists.reverse(pastAssignees)), hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), ReviewerByEmailSet.fromTable(Tables.transpose(reviewersByEmail)), pendingReviewers, pendingReviewersByEmail, allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments, readOnlyUntil, isPrivate, workInProgress, hasReviewStarted, revertOf);
}
#end_block

#method_before
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null) {
        if (!patchSetStates.containsKey(psId)) {
            patchSetStates.put(psId, psState);
        }
        if (psState == PatchSetState.DELETED) {
            deletedPatchSets.add(psId);
        }
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    Account.Id realAccountId = parseRealAccountId(commit, accountId);
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, realAccountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    parseAssignee(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    parseCurrentPatchSet(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    // "Status: merged" as non-post-submit.
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, realAccountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(ts, state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
    parseDescription(psId, commit);
}
#method_after
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null) {
        if (!patchSetStates.containsKey(psId)) {
            patchSetStates.put(psId, psState);
        }
        if (psState == PatchSetState.DELETED) {
            deletedPatchSets.add(psId);
        }
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    Account.Id realAccountId = parseRealAccountId(commit, accountId);
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, realAccountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    parseAssignee(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    parseCurrentPatchSet(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    // "Status: merged" as non-post-submit.
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, realAccountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(ts, state, line);
        }
        for (String line : commit.getFooterLineValues(state.getByEmailFooterKey())) {
            parseReviewerByEmail(ts, state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (readOnlyUntil == null) {
        parseReadOnlyUntil(commit);
    }
    if (isPrivate == null) {
        parseIsPrivate(commit);
    }
    if (revertOf == null) {
        revertOf = parseRevertOf(commit);
    }
    previousWorkInProgressFooter = null;
    parseWorkInProgress(commit);
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
    parseDescription(psId, commit);
}
#end_block

#method_before
@Test
public void hashtagCommit() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    LinkedHashSet<String> hashtags = new LinkedHashSet<>();
    hashtags.add("tag1");
    hashtags.add("tag2");
    update.setHashtags(hashtags);
    update.commit();
    try (RevWalk walk = new RevWalk(repo)) {
        RevCommit commit = walk.parseCommit(update.getResult());
        walk.parseBody(commit);
        assertThat(commit.getFullMessage()).endsWith("Hashtags: tag1,tag2\n");
    }
}
#method_after
@Test
public void hashtagCommit() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    LinkedHashSet<String> hashtags = new LinkedHashSet<>();
    hashtags.add("tag1");
    hashtags.add("tag2");
    update.setHashtags(hashtags);
    update.commit();
    try (RevWalk walk = new RevWalk(repo)) {
        RevCommit commit = walk.parseCommit(update.getResult());
        walk.parseBody(commit);
        assertThat(commit.getFullMessage()).contains("Hashtags: tag1,tag2\n");
    }
}
#end_block

#method_before
@Test
public void changeMessageWithTrailingDoubleNewline() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing trailing double newline\n" + "\n");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessagesByPatchSet();
    assertThat(changeMessages).hasSize(1);
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertThat(cm1.getMessage()).isEqualTo("Testing trailing double newline\n" + "\n");
    assertThat(cm1.getAuthor()).isEqualTo(changeOwner.getAccount().getId());
}
#method_after
@Test
public void changeMessageWithTrailingDoubleNewline() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing trailing double newline\n\n");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessagesByPatchSet();
    assertThat(changeMessages).hasSize(1);
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertThat(cm1.getMessage()).isEqualTo("Testing trailing double newline\n\n");
    assertThat(cm1.getAuthor()).isEqualTo(changeOwner.getAccount().getId());
}
#end_block

#method_before
@Test
public void changeMessageWithMultipleParagraphs() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessagesByPatchSet();
    assertThat(changeMessages).hasSize(1);
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertThat(cm1.getMessage()).isEqualTo("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3");
    assertThat(cm1.getAuthor()).isEqualTo(changeOwner.getAccount().getId());
}
#method_after
@Test
public void changeMessageWithMultipleParagraphs() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing paragraph 1\n\nTesting paragraph 2\n\nTesting paragraph 3");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessagesByPatchSet();
    assertThat(changeMessages).hasSize(1);
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertThat(cm1.getMessage()).isEqualTo("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3");
    assertThat(cm1.getAuthor()).isEqualTo(changeOwner.getAccount().getId());
}
#end_block

#method_before
public static void abandon(int id, String msg, AsyncCallback<ChangeInfo> cb) {
    MessageInput input = MessageInput.create();
    input.message(emptyToNull(msg));
    call(id, "abandon").post(input, cb);
}
#method_after
public static void abandon(@Nullable String project, int id, String msg, AsyncCallback<ChangeInfo> cb) {
    MessageInput input = MessageInput.create();
    input.message(emptyToNull(msg));
    call(project, id, "abandon").post(input, cb);
}
#end_block

#method_before
public static void createChange(String project, String branch, String topic, String subject, String base, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.topic(emptyToNull(topic));
    input.subject(emptyToNull(subject));
    input.baseChange(emptyToNull(base));
    new RestApi("/changes/").post(input, cb);
}
#method_after
public static void createChange(String project, String branch, String topic, String subject, String base, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.topic(emptyToNull(topic));
    input.subject(emptyToNull(subject));
    input.baseChange(emptyToNull(base));
    input.workInProgress(true);
    new RestApi("/changes/").post(input, cb);
}
#end_block

#method_before
public static void restore(int id, String msg, AsyncCallback<ChangeInfo> cb) {
    MessageInput input = MessageInput.create();
    input.message(emptyToNull(msg));
}
#method_after
public static void restore(@Nullable String project, int id, String msg, AsyncCallback<ChangeInfo> cb) {
    MessageInput input = MessageInput.create();
    input.message(emptyToNull(msg));
    call(project, id, "restore").post(input, cb);
}
#end_block

#method_before
public static void revert(int id, String msg, AsyncCallback<ChangeInfo> cb) {
    MessageInput input = MessageInput.create();
    input.message(emptyToNull(msg));
    call(id, "revert").post(input, cb);
}
#method_after
public static void revert(@Nullable String project, int id, String msg, AsyncCallback<ChangeInfo> cb) {
    MessageInput input = MessageInput.create();
    input.message(emptyToNull(msg));
    call(project, id, "revert").post(input, cb);
}
#end_block

#method_before
public static void topic(int id, String topic, AsyncCallback<String> cb) {
    RestApi call = call(id, "topic");
    topic = emptyToNull(topic);
    if (topic != null) {
        TopicInput input = TopicInput.create();
        input.topic(topic);
        call.put(input, NativeString.unwrap(cb));
    } else {
        call.delete(NativeString.unwrap(cb));
    }
}
#method_after
public static void topic(@Nullable String project, int id, String topic, AsyncCallback<String> cb) {
    RestApi call = call(project, id, "topic");
    topic = emptyToNull(topic);
    if (topic != null) {
        TopicInput input = TopicInput.create();
        input.topic(topic);
        call.put(input, NativeString.unwrap(cb));
    } else {
        call.delete(NativeString.unwrap(cb));
    }
}
#end_block

#method_before
public static RestApi detail(int id) {
    return call(id, "detail");
}
#method_after
public static void detail(@Nullable String project, int id, AsyncCallback<ChangeInfo> cb) {
    detail(project, id).get(cb);
}
#end_block

#method_before
public static RestApi blame(PatchSet.Id id, String path, boolean base) {
    return revision(id).view("files").id(path).view("blame").addParameter("base", base);
}
#method_after
public static RestApi blame(@Nullable String project, PatchSet.Id id, String path, boolean base) {
    return revision(project, id).view("files").id(path).view("blame").addParameter("base", base);
}
#end_block

#method_before
public static RestApi actions(int id, String revision) {
    if (revision == null || revision.equals("")) {
        revision = "current";
    }
    return call(id, revision, "actions");
}
#method_after
public static RestApi actions(@Nullable String project, int id, String revision) {
    if (revision == null || revision.equals("")) {
        revision = "current";
    }
    return call(project, id, revision, "actions");
}
#end_block

#method_before
public static void deleteAssignee(int id, AsyncCallback<AccountInfo> cb) {
    change(id).view("assignee").delete(cb);
}
#method_after
public static void deleteAssignee(@Nullable String project, int id, AsyncCallback<AccountInfo> cb) {
    change(project, id).view("assignee").delete(cb);
}
#end_block

#method_before
public static void setAssignee(int id, String user, AsyncCallback<AccountInfo> cb) {
    AssigneeInput input = AssigneeInput.create();
    input.assignee(user);
    change(id).view("assignee").put(input, cb);
}
#method_after
public static void setAssignee(@Nullable String project, int id, String user, AsyncCallback<AccountInfo> cb) {
    AssigneeInput input = AssigneeInput.create();
    input.assignee(user);
    change(project, id).view("assignee").put(input, cb);
}
#end_block

#method_before
public static RestApi comments(int id) {
    return call(id, "comments");
}
#method_after
public static RestApi comments(@Nullable String project, int id) {
    return call(project, id, "comments");
}
#end_block

#method_before
public static RestApi drafts(int id) {
    return call(id, "drafts");
}
#method_after
public static RestApi drafts(@Nullable String project, int id) {
    return call(project, id, "drafts");
}
#end_block

#method_before
public static RestApi edit(int id) {
    return change(id).view("edit");
}
#method_after
public static void edit(@Nullable String project, int id, AsyncCallback<EditInfo> cb) {
    edit(project, id).get(cb);
}
#end_block

#method_before
public static void editWithFiles(int id, AsyncCallback<EditInfo> cb) {
    edit(id).addParameterTrue("list").get(cb);
}
#method_after
public static void editWithFiles(@Nullable String project, int id, AsyncCallback<EditInfo> cb) {
    edit(project, id).addParameterTrue("list").get(cb);
}
#end_block

#method_before
public static RestApi editWithCommands(int id) {
    return edit(id).addParameterTrue("download-commands");
}
#method_after
public static RestApi editWithCommands(@Nullable String project, int id) {
    return edit(project, id).addParameterTrue("download-commands");
}
#end_block

#method_before
public static void includedIn(int id, AsyncCallback<IncludedInInfo> cb) {
    call(id, "in").get(cb);
}
#method_after
public static void includedIn(@Nullable String project, int id, AsyncCallback<IncludedInInfo> cb) {
    call(project, id, "in").get(cb);
}
#end_block

#method_before
public static RestApi revision(PatchSet.Id id) {
    int cn = id.getParentKey().get();
    String revision = RevisionInfoCache.get(id);
    if (revision != null) {
        return revision(cn, revision);
    }
    return change(cn).view("revisions").id(id.get());
}
#method_after
public static RestApi revision(@Nullable String project, int id, String revision) {
    return change(project, id).view("revisions").id(revision);
}
#end_block

#method_before
public static RestApi reviewers(int id) {
    return change(id).view("reviewers");
}
#method_after
public static RestApi reviewers(@Nullable String project, int id) {
    return change(project, id).view("reviewers");
}
#end_block

#method_before
public static RestApi suggestReviewers(int id, String q, int n, boolean e) {
    RestApi api = change(id).view("suggest_reviewers").addParameter("n", n).addParameter("e", e);
    if (q != null) {
        api.addParameter("q", q);
    }
    return api;
}
#method_after
public static RestApi suggestReviewers(@Nullable String project, int id, String q, int n, boolean e) {
    RestApi api = change(project, id).view("suggest_reviewers").addParameter("n", n).addParameter("e", e);
    if (q != null) {
        api.addParameter("q", q);
    }
    return api;
}
#end_block

#method_before
public static RestApi vote(int id, int reviewer, String vote) {
    return reviewer(id, reviewer).view("votes").id(vote);
}
#method_after
public static RestApi vote(@Nullable String project, int id, int reviewer, String vote) {
    return reviewer(project, id, reviewer).view("votes").id(vote);
}
#end_block

#method_before
public static RestApi reviewer(int id, String reviewer) {
    return change(id).view("reviewers").id(reviewer);
}
#method_after
public static RestApi reviewer(@Nullable String project, int id, int reviewer) {
    return change(project, id).view("reviewers").id(reviewer);
}
#end_block

#method_before
public static RestApi hashtags(int changeId) {
    return change(changeId).view("hashtags");
}
#method_after
public static RestApi hashtags(@Nullable String project, int changeId) {
    return change(project, changeId).view("hashtags");
}
#end_block

#method_before
public static RestApi hashtag(int changeId, String hashtag) {
    return change(changeId).view("hashtags").id(hashtag);
}
#method_after
public static RestApi hashtag(@Nullable String project, int changeId, String hashtag) {
    return change(project, changeId).view("hashtags").id(hashtag);
}
#end_block

#method_before
public static void cherrypick(int id, String commit, String destination, String message, AsyncCallback<ChangeInfo> cb) {
    CherryPickInput cherryPickInput = CherryPickInput.create();
    cherryPickInput.setMessage(message);
    cherryPickInput.setDestination(destination);
    call(id, commit, "cherrypick").post(cherryPickInput, cb);
}
#method_after
public static void cherrypick(String project, int id, String commit, String destination, String message, AsyncCallback<ChangeInfo> cb) {
    CherryPickInput cherryPickInput = CherryPickInput.create();
    cherryPickInput.setMessage(message);
    cherryPickInput.setDestination(destination);
    call(project, id, commit, "cherrypick").post(cherryPickInput, cb);
}
#end_block

#method_before
public static void message(int id, String commit, String message, AsyncCallback<JavaScriptObject> cb) {
    CherryPickInput input = CherryPickInput.create();
    input.setMessage(message);
    call(id, commit, "message").post(input, cb);
}
#method_after
public static void message(@Nullable String project, int id, String commit, String message, AsyncCallback<JavaScriptObject> cb) {
    CherryPickInput input = CherryPickInput.create();
    input.setMessage(message);
    call(project, id, commit, "message").post(input, cb);
}
#end_block

#method_before
public static void submit(int id, String commit, AsyncCallback<SubmitInfo> cb) {
    JavaScriptObject in = JavaScriptObject.createObject();
    call(id, commit, "submit").post(in, cb);
}
#method_after
public static void submit(@Nullable String project, int id, String commit, AsyncCallback<SubmitInfo> cb) {
    JavaScriptObject in = JavaScriptObject.createObject();
    call(project, id, commit, "submit").post(in, cb);
}
#end_block

#method_before
public static void deleteEdit(int id, AsyncCallback<JavaScriptObject> cb) {
    edit(id).delete(cb);
}
#method_after
public static void deleteEdit(@Nullable String project, int id, AsyncCallback<JavaScriptObject> cb) {
    edit(project, id).delete(cb);
}
#end_block

#method_before
public static void publishEdit(int id, AsyncCallback<JavaScriptObject> cb) {
    JavaScriptObject in = JavaScriptObject.createObject();
    change(id).view("edit:publish").post(in, cb);
}
#method_after
public static void publishEdit(@Nullable String project, int id, AsyncCallback<JavaScriptObject> cb) {
    JavaScriptObject in = JavaScriptObject.createObject();
    change(project, id).view("edit:publish").post(in, cb);
}
#end_block

#method_before
public static void rebaseEdit(int id, AsyncCallback<JavaScriptObject> cb) {
    JavaScriptObject in = JavaScriptObject.createObject();
    change(id).view("edit:rebase").post(in, cb);
}
#method_after
public static void rebaseEdit(@Nullable String project, int id, AsyncCallback<JavaScriptObject> cb) {
    JavaScriptObject in = JavaScriptObject.createObject();
    change(project, id).view("edit:rebase").post(in, cb);
}
#end_block

#method_before
public static void rebase(int id, String commit, String base, AsyncCallback<ChangeInfo> cb) {
    RebaseInput rebaseInput = RebaseInput.create();
    rebaseInput.setBase(base);
    call(id, commit, "rebase").post(rebaseInput, cb);
}
#method_after
public static void rebase(@Nullable String project, int id, String commit, String base, AsyncCallback<ChangeInfo> cb) {
    RebaseInput rebaseInput = RebaseInput.create();
    rebaseInput.setBase(base);
    call(project, id, commit, "rebase").post(rebaseInput, cb);
}
#end_block

#method_before
private static RestApi call(int id, String commit, String action) {
    return change(id).view("revisions").id(commit).view(action);
}
#method_after
private static RestApi call(@Nullable String project, int id, String action) {
    return change(project, id).view(action);
}
#end_block

#method_before
public static RestApi change(int id) {
    // TODO Switch to triplet project~branch~id format in URI.
    return new RestApi("/changes/").id(String.valueOf(id));
}
#method_after
public static RestApi change(@Nullable String project, int id) {
    if (project == null) {
        return new RestApi("/changes/").id(String.valueOf(id));
    }
    return new RestApi("/changes/").id(project, id);
}
#end_block

#method_before
public static void commitWithLinks(int changeId, String revision, Callback<CommitInfo> callback) {
    revision(changeId, revision).view("commit").addParameterTrue("links").get(callback);
}
#method_after
public static void commitWithLinks(@Nullable String project, int changeId, String revision, Callback<CommitInfo> callback) {
    revision(project, changeId, revision).view("commit").addParameterTrue("links").get(callback);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    checkState(ctx.getOrder() == BatchUpdate.Order.DB_BEFORE_REPO, "must use DeleteChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteChangeOp");
    id = ctx.getChange().getId();
    Collection<PatchSet> patchSets = psUtil.byChange(ctx.getDb(), ctx.getNotes());
    ensureDeletable(ctx, id, patchSets);
    // Cleaning up is only possible as long as the change and its elements are
    // still part of the database.
    cleanUpReferences(ctx, id, patchSets);
    deleteChangeElementsFromDb(ctx, id);
    ctx.deleteChange();
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    checkState(ctx.getOrder() == Order.DB_BEFORE_REPO, "must use DeleteChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteChangeOp");
    id = ctx.getChange().getId();
    Collection<PatchSet> patchSets = psUtil.byChange(ctx.getDb(), ctx.getNotes());
    ensureDeletable(ctx, id, patchSets);
    // Cleaning up is only possible as long as the change and its elements are
    // still part of the database.
    cleanUpReferences(ctx, id, patchSets);
    deleteChangeElementsFromDb(ctx, id);
    ctx.deleteChange();
    return true;
}
#end_block

#method_before
private void ensureDeletable(ChangeContext ctx, Change.Id id, Collection<PatchSet> patchSets) throws ResourceConflictException, MethodNotAllowedException, AuthException, IOException {
    Change.Status status = ctx.getChange().getStatus();
    if (status == Change.Status.MERGED) {
        throw new MethodNotAllowedException("Deleting merged change " + id + " is not allowed");
    }
    for (PatchSet patchSet : patchSets) {
        if (isPatchSetMerged(ctx, patchSet)) {
            throw new ResourceConflictException(String.format("Cannot delete change %s: patch set %s is already merged", id, patchSet.getPatchSetId()));
        }
    }
    if (!ctx.getControl().canDelete(ctx.getDb(), status)) {
        throw new AuthException("Deleting change " + id + " is not permitted");
    }
}
#method_after
private void ensureDeletable(ChangeContext ctx, Change.Id id, Collection<PatchSet> patchSets) throws ResourceConflictException, MethodNotAllowedException, IOException {
    Change.Status status = ctx.getChange().getStatus();
    if (status == Change.Status.MERGED) {
        throw new MethodNotAllowedException("Deleting merged change " + id + " is not allowed");
    }
    for (PatchSet patchSet : patchSets) {
        if (isPatchSetMerged(ctx, patchSet)) {
            throw new ResourceConflictException(String.format("Cannot delete change %s: patch set %s is already merged", id, patchSet.getPatchSetId()));
        }
    }
}
#end_block

#method_before
private boolean isPatchSetMerged(ChangeContext ctx, PatchSet patchSet) throws IOException {
    Repository repository = ctx.getRepository();
    Ref destinationRef = repository.exactRef(ctx.getChange().getDest().get());
    if (destinationRef == null) {
        return false;
    }
    RevWalk revWalk = ctx.getRevWalk();
    ObjectId objectId = ObjectId.fromString(patchSet.getRevision().get());
    RevCommit revCommit = revWalk.parseCommit(objectId);
    return IncludedInResolver.includedInOne(repository, revWalk, revCommit, Collections.singletonList(destinationRef));
}
#method_after
private boolean isPatchSetMerged(ChangeContext ctx, PatchSet patchSet) throws IOException {
    Optional<ObjectId> destId = ctx.getRepoView().getRef(ctx.getChange().getDest().get());
    if (!destId.isPresent()) {
        return false;
    }
    RevWalk revWalk = ctx.getRevWalk();
    ObjectId objectId = ObjectId.fromString(patchSet.getRevision().get());
    return revWalk.isMergedInto(revWalk.parseCommit(objectId), revWalk.parseCommit(destId.get()));
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws IOException {
    String prefix = new PatchSet.Id(id, 1).toRefName();
    prefix = prefix.substring(0, prefix.length() - 1);
    for (Ref ref : ctx.getRepository().getRefDatabase().getRefs(prefix).values()) {
        ctx.addRefUpdate(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), ref.getName()));
    }
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws IOException {
    String prefix = new PatchSet.Id(id, 1).toRefName();
    prefix = prefix.substring(0, prefix.length() - 1);
    for (Map.Entry<String, ObjectId> e : ctx.getRepoView().getRefs(prefix).entrySet()) {
        ctx.addRefUpdate(e.getValue(), ObjectId.zeroId(), prefix + e.getKey());
    }
}
#end_block

#method_before
void set(ChangeInfo info, String commit, ReplyAction action) {
    if (!info.hasPermittedLabels() || !info.status().isOpen()) {
        // Quick approve needs at least one label on an open change.
        setVisible(false);
        return;
    }
    if (info.revision(commit).isEdit()) {
        setVisible(false);
        return;
    }
    String qName = null;
    String qValueStr = null;
    short qValue = 0;
    int index = info.getMissingLabelIndex();
    if (index != -1) {
        LabelInfo label = Natives.asList(info.allLabels().values()).get(index);
        JsArrayString values = info.permittedValues(label.name());
        String s = values.get(values.length() - 1);
        short v = LabelInfo.parseValue(s);
        if (v > 0 && s.equals(label.maxValue())) {
            qName = label.name();
            qValueStr = s;
            qValue = v;
        }
    }
    if (qName != null) {
        changeId = info.legacyId();
        revision = commit;
        input = ReviewInput.create();
        input.drafts(DraftHandling.PUBLISH_ALL_REVISIONS);
        input.label(qName, qValue);
        replyAction = action;
        setText(qName + qValueStr);
        setVisible(true);
    } else {
        setVisible(false);
    }
}
#method_after
void set(ChangeInfo info, String commit, ReplyAction action) {
    if (!info.hasPermittedLabels() || !info.status().isOpen()) {
        // Quick approve needs at least one label on an open change.
        setVisible(false);
        return;
    }
    if (info.revision(commit).isEdit()) {
        setVisible(false);
        return;
    }
    String qName = null;
    String qValueStr = null;
    short qValue = 0;
    int index = info.getMissingLabelIndex();
    if (index != -1) {
        LabelInfo label = Natives.asList(info.allLabels().values()).get(index);
        JsArrayString values = info.permittedValues(label.name());
        String s = values.get(values.length() - 1);
        short v = LabelInfo.parseValue(s);
        if (v > 0 && s.equals(label.maxValue())) {
            qName = label.name();
            qValueStr = s;
            qValue = v;
        }
    }
    if (qName != null) {
        changeId = info.legacyId();
        project = info.projectNameKey();
        revision = commit;
        input = ReviewInput.create();
        input.drafts(DraftHandling.PUBLISH_ALL_REVISIONS);
        input.label(qName, qValue);
        replyAction = action;
        setText(qName + qValueStr);
        setVisible(true);
    } else {
        setVisible(false);
    }
}
#end_block

#method_before
@Override
public void onClick(ClickEvent event) {
    if (replyAction != null && replyAction.isVisible()) {
        replyAction.quickApprove(input);
    } else {
        ChangeApi.revision(changeId.get(), revision).view("review").post(input, new GerritCallback<ReviewInput>() {

            @Override
            public void onSuccess(ReviewInput result) {
                Gerrit.display(PageLinks.toChange(changeId));
            }
        });
    }
}
#method_after
@Override
public void onClick(ClickEvent event) {
    if (replyAction != null && replyAction.isVisible()) {
        replyAction.quickApprove(input);
    } else {
        ChangeApi.revision(project.get(), changeId.get(), revision).view("review").post(input, new GerritCallback<ReviewInput>() {

            @Override
            public void onSuccess(ReviewInput result) {
                Gerrit.display(PageLinks.toChange(project, changeId));
            }
        });
    }
}
#end_block

#method_before
public Optional<ChangeEdit> byChange(ChangeControl ctl) throws AuthException, IOException {
    if (!ctl.getUser().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser u = ctl.getUser().asIdentifiedUser();
    Change change = ctl.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject())) {
        int n = change.currentPatchSetId().get();
        String[] refNames = new String[n];
        for (int i = n; i > 0; i--) {
            refNames[i - 1] = RefNames.refsEdit(u.getAccountId(), change.getId(), new PatchSet.Id(change.getId(), i));
        }
        Ref ref = repo.getRefDatabase().firstExactRef(refNames);
        if (ref == null) {
            return Optional.empty();
        }
        try (RevWalk rw = new RevWalk(repo)) {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(ctl, ref);
            return Optional.of(new ChangeEdit(u, change, ref, commit, basePs));
        }
    }
}
#method_after
public Optional<ChangeEdit> byChange(ChangeNotes notes) throws AuthException, IOException {
    return byChange(notes, userProvider.get());
}
#end_block

#method_before
public void publish(final ChangeEdit edit, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws IOException, OrmException, RestApiException, UpdateException {
    Change change = edit.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject());
        RevWalk rw = new RevWalk(repo);
        ObjectInserter oi = repo.newObjectInserter()) {
        PatchSet basePatchSet = edit.getBasePatchSet();
        if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
            throw new ResourceConflictException("only edit for current patch set can be published");
        }
        RevCommit squashed = squashEdit(rw, oi, edit.getEditCommit(), basePatchSet);
        ChangeControl ctl = changeControlFactory.controlFor(db.get(), change, edit.getUser());
        PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(ctl, psId, squashed).setNotify(notify).setAccountsToNotify(accountsToNotify);
        StringBuilder message = new StringBuilder("Patch Set ").append(inserter.getPatchSetId().get()).append(": ");
        // Previously checked that the base patch set is the current patch set.
        ObjectId prior = ObjectId.fromString(basePatchSet.getRevision().get());
        ChangeKind kind = changeKindCache.getChangeKind(change.getProject(), repo, prior, squashed);
        if (kind == ChangeKind.NO_CODE_CHANGE) {
            message.append("Commit message was updated.");
            inserter.setDescription("Edit commit message");
        } else {
            message.append("Published edit on patch set ").append(basePatchSet.getPatchSetId()).append(".");
        }
        try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), ctl.getUser(), TimeUtil.nowTs())) {
            bu.setRepository(repo, rw, oi);
            bu.addOp(change.getId(), inserter.setMessage(message.toString()));
            bu.addOp(change.getId(), new BatchUpdate.Op() {

                @Override
                public void updateRepo(RepoContext ctx) throws Exception {
                    deleteRef(ctx.getRepository(), edit);
                }
            });
            bu.execute();
        } catch (UpdateException e) {
            if (e.getCause() instanceof IOException && e.getMessage().equals(String.format("%s: Failed to delete ref %s: %s", IOException.class.getName(), edit.getRefName(), RefUpdate.Result.LOCK_FAILURE.name()))) {
                throw new ResourceConflictException("edit ref was updated");
            }
        }
        indexer.index(db.get(), inserter.getChange());
    }
}
#method_after
public void publish(BatchUpdate.Factory updateFactory, ChangeNotes notes, CurrentUser user, final ChangeEdit edit, NotifyHandling notify, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws IOException, OrmException, RestApiException, UpdateException {
    Change change = edit.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject());
        ObjectInserter oi = repo.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        PatchSet basePatchSet = edit.getBasePatchSet();
        if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
            throw new ResourceConflictException("only edit for current patch set can be published");
        }
        RevCommit squashed = squashEdit(rw, oi, edit.getEditCommit(), basePatchSet);
        PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(notes, psId, squashed).setNotify(notify).setAccountsToNotify(accountsToNotify);
        StringBuilder message = new StringBuilder("Patch Set ").append(inserter.getPatchSetId().get()).append(": ");
        // Previously checked that the base patch set is the current patch set.
        ObjectId prior = ObjectId.fromString(basePatchSet.getRevision().get());
        ChangeKind kind = changeKindCache.getChangeKind(change.getProject(), rw, repo.getConfig(), prior, squashed);
        if (kind == ChangeKind.NO_CODE_CHANGE) {
            message.append("Commit message was updated.");
            inserter.setDescription("Edit commit message");
        } else {
            message.append("Published edit on patch set ").append(basePatchSet.getPatchSetId()).append(".");
        }
        try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), user, TimeUtil.nowTs())) {
            bu.setRepository(repo, rw, oi);
            bu.addOp(change.getId(), inserter.setMessage(message.toString()));
            bu.addOp(change.getId(), new BatchUpdateOp() {

                @Override
                public void updateRepo(RepoContext ctx) throws Exception {
                    ctx.addRefUpdate(edit.getEditCommit().copy(), ObjectId.zeroId(), edit.getRefName());
                }
            });
            bu.execute();
        }
    }
}
#end_block

#method_before
private PatchSet getBasePatchSet(ChangeControl ctl, Ref ref) throws IOException {
    try {
        int pos = ref.getName().lastIndexOf("/");
        checkArgument(pos > 0, "invalid edit ref: %s", ref.getName());
        String psId = ref.getName().substring(pos + 1);
        return psUtil.get(db.get(), ctl.getNotes(), new PatchSet.Id(ctl.getId(), Integer.parseInt(psId)));
    } catch (OrmException | NumberFormatException e) {
        throw new IOException(e);
    }
}
#method_after
private PatchSet getBasePatchSet(ChangeNotes notes, Ref ref) throws IOException {
    try {
        int pos = ref.getName().lastIndexOf("/");
        checkArgument(pos > 0, "invalid edit ref: %s", ref.getName());
        String psId = ref.getName().substring(pos + 1);
        return psUtil.get(db.get(), notes, new PatchSet.Id(notes.getChange().getId(), Integer.parseInt(psId)));
    } catch (OrmException | NumberFormatException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private static void deleteRef(Repository repo, ChangeEdit edit) throws IOException {
    String refName = edit.getRefName();
    RefUpdate ru = repo.updateRef(refName, true);
    ru.setExpectedOldObjectId(edit.getRef().getObjectId());
    ru.setForceUpdate(true);
    RefUpdate.Result result = ru.delete();
    switch(result) {
        case FORCED:
        case NEW:
        case NO_CHANGE:
            break;
        case FAST_FORWARD:
        case IO_FAILURE:
        case LOCK_FAILURE:
        case NOT_ATTEMPTED:
        case REJECTED:
        case REJECTED_CURRENT_BRANCH:
        case RENAMED:
        default:
            throw new IOException(String.format("Failed to delete ref %s: %s", refName, result));
    }
}
#method_after
private static void deleteRef(Repository repo, ChangeEdit edit) throws IOException {
    String refName = edit.getRefName();
    RefUpdate ru = repo.updateRef(refName, true);
    ru.setExpectedOldObjectId(edit.getEditCommit());
    ru.setForceUpdate(true);
    RefUpdate.Result result = ru.delete();
    switch(result) {
        case FORCED:
        case NEW:
        case NO_CHANGE:
            break;
        case FAST_FORWARD:
        case IO_FAILURE:
        case LOCK_FAILURE:
        case NOT_ATTEMPTED:
        case REJECTED:
        case REJECTED_CURRENT_BRANCH:
        case RENAMED:
        case REJECTED_MISSING_OBJECT:
        case REJECTED_OTHER_REASON:
        default:
            throw new IOException(String.format("Failed to delete ref %s: %s", refName, result));
    }
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws MergeConflictException, InvalidChangeOperationException, RestApiException, IOException, OrmException, NoSuchChangeException {
    // Ok that originalPatchSet was not read in a transaction, since we just
    // need its revision.
    RevId oldRev = originalPatchSet.getRevision();
    RevWalk rw = ctx.getRevWalk();
    RevCommit original = rw.parseCommit(ObjectId.fromString(oldRev.get()));
    rw.parseBody(original);
    RevCommit baseCommit;
    if (baseCommitish != null) {
        baseCommit = rw.parseCommit(ctx.getRepository().resolve(baseCommitish));
    } else {
        baseCommit = rw.parseCommit(rebaseUtil.findBaseRevision(originalPatchSet, ctl.getChange().getDest(), ctx.getRepository(), ctx.getRevWalk()));
    }
    String newCommitMessage;
    if (detailedCommitMessage) {
        rw.parseBody(baseCommit);
        newCommitMessage = newMergeUtil().createCommitMessageOnSubmit(original, baseCommit, ctl, originalPatchSet.getId());
    } else {
        newCommitMessage = original.getFullMessage();
    }
    rebasedCommit = rebaseCommit(ctx, original, baseCommit, newCommitMessage);
    RevId baseRevId = new RevId((baseCommitish != null) ? baseCommitish : ObjectId.toString(baseCommit.getId()));
    Base base = rebaseUtil.parseBase(new RevisionResource(changeResourceFactory.create(ctl), originalPatchSet), baseRevId.get());
    rebasedPatchSetId = ChangeUtil.nextPatchSetId(ctx.getRepository(), ctl.getChange().currentPatchSetId());
    patchSetInserter = patchSetInserterFactory.create(ctl, rebasedPatchSetId, rebasedCommit).setDescription("Rebase").setNotify(NotifyHandling.NONE).setFireRevisionCreated(fireRevisionCreated).setCopyApprovals(copyApprovals).setCheckAddPatchSetPermission(checkAddPatchSetPermission);
    if (postMessage) {
        patchSetInserter.setMessage("Patch Set " + rebasedPatchSetId.get() + ": Patch Set " + originalPatchSet.getId().get() + " was rebased");
    }
    if (base != null) {
        patchSetInserter.setGroups(base.patchSet().getGroups());
    }
    if (validate != null) {
        patchSetInserter.setValidatePolicy(validate);
    }
    patchSetInserter.updateRepo(ctx);
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws MergeConflictException, InvalidChangeOperationException, RestApiException, IOException, OrmException, NoSuchChangeException, PermissionBackendException {
    // Ok that originalPatchSet was not read in a transaction, since we just
    // need its revision.
    RevId oldRev = originalPatchSet.getRevision();
    RevWalk rw = ctx.getRevWalk();
    RevCommit original = rw.parseCommit(ObjectId.fromString(oldRev.get()));
    rw.parseBody(original);
    RevCommit baseCommit = rw.parseCommit(baseCommitId);
    CurrentUser changeOwner = identifiedUserFactory.create(notes.getChange().getOwner());
    String newCommitMessage;
    if (detailedCommitMessage) {
        rw.parseBody(baseCommit);
        newCommitMessage = newMergeUtil().createCommitMessageOnSubmit(original, baseCommit, notes, changeOwner, originalPatchSet.getId());
    } else {
        newCommitMessage = original.getFullMessage();
    }
    rebasedCommit = rebaseCommit(ctx, original, baseCommit, newCommitMessage);
    Base base = rebaseUtil.parseBase(new RevisionResource(changeResourceFactory.create(notes, changeOwner), originalPatchSet), baseCommitId.name());
    rebasedPatchSetId = ChangeUtil.nextPatchSetIdFromChangeRefsMap(ctx.getRepoView().getRefs(originalPatchSet.getId().getParentKey().toRefPrefix()), notes.getChange().currentPatchSetId());
    patchSetInserter = patchSetInserterFactory.create(notes, rebasedPatchSetId, rebasedCommit).setDescription("Rebase").setNotify(NotifyHandling.NONE).setFireRevisionCreated(fireRevisionCreated).setCopyApprovals(copyApprovals).setCheckAddPatchSetPermission(checkAddPatchSetPermission).setValidate(validate);
    if (postMessage) {
        patchSetInserter.setMessage("Patch Set " + rebasedPatchSetId.get() + ": Patch Set " + originalPatchSet.getId().get() + " was rebased");
    }
    if (base != null) {
        patchSetInserter.setGroups(base.patchSet().getGroups());
    }
    patchSetInserter.updateRepo(ctx);
}
#end_block

#method_before
private MergeUtil newMergeUtil() {
    ProjectState project = ctl.getProjectControl().getProjectState();
    return forceContentMerge ? mergeUtilFactory.create(project, true) : mergeUtilFactory.create(project);
}
#method_after
private MergeUtil newMergeUtil() throws IOException {
    ProjectState project = projectCache.checkedGet(notes.getProjectName());
    return forceContentMerge ? mergeUtilFactory.create(project, true) : mergeUtilFactory.create(project);
}
#end_block

#method_before
private RevCommit rebaseCommit(RepoContext ctx, RevCommit original, ObjectId base, String commitMessage) throws ResourceConflictException, IOException {
    RevCommit parentCommit = original.getParent(0);
    if (base.equals(parentCommit)) {
        throw new ResourceConflictException("Change is already up to date.");
    }
    ThreeWayMerger merger = newMergeUtil().newThreeWayMerger(ctx.getRepository(), ctx.getInserter());
    merger.setBase(parentCommit);
    merger.merge(original, base);
    if (merger.getResultTreeId() == null) {
        throw new MergeConflictException("The change could not be rebased due to a conflict during merge.");
    }
    CommitBuilder cb = new CommitBuilder();
    cb.setTreeId(merger.getResultTreeId());
    cb.setParentId(base);
    cb.setAuthor(original.getAuthorIdent());
    cb.setMessage(commitMessage);
    if (committerIdent != null) {
        cb.setCommitter(committerIdent);
    } else {
        cb.setCommitter(ctx.getIdentifiedUser().newCommitterIdent(ctx.getWhen(), ctx.getTimeZone()));
    }
    ObjectId objectId = ctx.getInserter().insert(cb);
    ctx.getInserter().flush();
    return ctx.getRevWalk().parseCommit(objectId);
}
#method_after
private RevCommit rebaseCommit(RepoContext ctx, RevCommit original, ObjectId base, String commitMessage) throws ResourceConflictException, IOException {
    RevCommit parentCommit = original.getParent(0);
    if (base.equals(parentCommit)) {
        throw new ResourceConflictException("Change is already up to date.");
    }
    ThreeWayMerger merger = newMergeUtil().newThreeWayMerger(ctx.getInserter(), ctx.getRepoView().getConfig());
    merger.setBase(parentCommit);
    merger.merge(original, base);
    if (merger.getResultTreeId() == null) {
        throw new MergeConflictException("The change could not be rebased due to a conflict during merge.");
    }
    CommitBuilder cb = new CommitBuilder();
    cb.setTreeId(merger.getResultTreeId());
    cb.setParentId(base);
    cb.setAuthor(original.getAuthorIdent());
    cb.setMessage(commitMessage);
    if (committerIdent != null) {
        cb.setCommitter(committerIdent);
    } else {
        cb.setCommitter(ctx.getIdentifiedUser().newCommitterIdent(ctx.getWhen(), ctx.getTimeZone()));
    }
    if (matchAuthorToCommitterDate) {
        cb.setAuthor(new PersonIdent(cb.getAuthor(), cb.getCommitter().getWhen(), cb.getCommitter().getTimeZone()));
    }
    ObjectId objectId = ctx.getInserter().insert(cb);
    ctx.getInserter().flush();
    return ctx.getRevWalk().parseCommit(objectId);
}
#end_block

#method_before
private ChangeJson changeJson() {
    return changeJsonFactory.create(EnumSet.noneOf(ListChangesOption.class));
}
#method_after
private ChangeJson changeJson() {
    return changeJsonFactory.noOptions();
}
#end_block

#method_before
public ChangeInfo addChangeActions(ChangeInfo to, ChangeControl ctl) {
    List<ActionVisitor> visitors = visitors();
    to.actions = toActionMap(ctl, visitors, copy(visitors, to));
    return to;
}
#method_after
public ChangeInfo addChangeActions(ChangeInfo to, ChangeNotes notes) {
    List<ActionVisitor> visitors = visitors();
    to.actions = toActionMap(notes, visitors, copy(visitors, to));
    return to;
}
#end_block

#method_before
private ChangeInfo copy(List<ActionVisitor> visitors, ChangeInfo changeInfo) {
    if (visitors.isEmpty()) {
        return null;
    }
    // Include all fields from ChangeJson#toChangeInfo that are not protected by
    // any ListChangesOptions.
    ChangeInfo copy = new ChangeInfo();
    copy.project = changeInfo.project;
    copy.branch = changeInfo.branch;
    copy.topic = changeInfo.topic;
    copy.assignee = changeInfo.assignee;
    copy.hashtags = changeInfo.hashtags;
    copy.changeId = changeInfo.changeId;
    copy.submitType = changeInfo.submitType;
    copy.mergeable = changeInfo.mergeable;
    copy.insertions = changeInfo.insertions;
    copy.deletions = changeInfo.deletions;
    copy.subject = changeInfo.subject;
    copy.status = changeInfo.status;
    copy.owner = changeInfo.owner;
    copy.created = changeInfo.created;
    copy.updated = changeInfo.updated;
    copy._number = changeInfo._number;
    copy.starred = changeInfo.starred;
    copy.stars = changeInfo.stars;
    copy.submitted = changeInfo.submitted;
    copy.id = changeInfo.id;
    return copy;
}
#method_after
private ChangeInfo copy(List<ActionVisitor> visitors, ChangeInfo changeInfo) {
    if (visitors.isEmpty()) {
        return null;
    }
    // Include all fields from ChangeJson#toChangeInfo that are not protected by
    // any ListChangesOptions.
    ChangeInfo copy = new ChangeInfo();
    copy.project = changeInfo.project;
    copy.branch = changeInfo.branch;
    copy.topic = changeInfo.topic;
    copy.assignee = changeInfo.assignee;
    copy.hashtags = changeInfo.hashtags;
    copy.changeId = changeInfo.changeId;
    copy.submitType = changeInfo.submitType;
    copy.mergeable = changeInfo.mergeable;
    copy.insertions = changeInfo.insertions;
    copy.deletions = changeInfo.deletions;
    copy.isPrivate = changeInfo.isPrivate;
    copy.subject = changeInfo.subject;
    copy.status = changeInfo.status;
    copy.owner = changeInfo.owner;
    copy.created = changeInfo.created;
    copy.updated = changeInfo.updated;
    copy._number = changeInfo._number;
    copy.starred = changeInfo.starred;
    copy.stars = changeInfo.stars;
    copy.submitted = changeInfo.submitted;
    copy.submitter = changeInfo.submitter;
    copy.id = changeInfo.id;
    return copy;
}
#end_block

#method_before
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc, List<ActionVisitor> visitors, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
    if (!rsrc.getControl().getUser().isIdentifiedUser()) {
        return ImmutableMap.of();
    }
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    Provider<CurrentUser> userProvider = Providers.of(rsrc.getControl().getUser());
    ACTION: for (UiAction.Description d : UiActions.from(revisions, rsrc, userProvider)) {
        ActionInfo actionInfo = new ActionInfo(d);
        for (ActionVisitor visitor : visitors) {
            if (!visitor.visit(d.getId(), actionInfo, changeInfo, revisionInfo)) {
                continue ACTION;
            }
        }
        out.put(d.getId(), actionInfo);
    }
    return out;
}
#method_after
private Map<String, ActionInfo> toActionMap(ChangeNotes notes, List<ActionVisitor> visitors, ChangeInfo changeInfo) {
    CurrentUser user = userProvider.get();
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (!user.isIdentifiedUser()) {
        return out;
    }
    Iterable<UiAction.Description> descs = uiActions.from(changeViews, changeResourceFactory.create(notes, user));
    // The followup action is a client-side only operation that does not
    // have a server side handler. It must be manually registered into the
    // resulting action map.
    Status status = notes.getChange().getStatus();
    if (status.isOpen() || status.equals(Status.MERGED)) {
        UiAction.Description descr = new UiAction.Description();
        PrivateInternals_UiActionDescription.setId(descr, "followup");
        PrivateInternals_UiActionDescription.setMethod(descr, "POST");
        descr.setTitle("Create follow-up change");
        descr.setLabel("Follow-Up");
        descs = Iterables.concat(descs, Collections.singleton(descr));
    }
    ACTION: for (UiAction.Description d : descs) {
        ActionInfo actionInfo = new ActionInfo(d);
        for (ActionVisitor visitor : visitors) {
            if (!visitor.visit(d.getId(), actionInfo, changeInfo)) {
                continue ACTION;
            }
        }
        out.put(d.getId(), actionInfo);
    }
    return out;
}
#end_block

#method_before
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc, List<ActionVisitor> visitors, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
    if (!rsrc.getControl().getUser().isIdentifiedUser()) {
        return ImmutableMap.of();
    }
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    Provider<CurrentUser> userProvider = Providers.of(rsrc.getControl().getUser());
    ACTION: for (UiAction.Description d : UiActions.from(revisions, rsrc, userProvider)) {
        ActionInfo actionInfo = new ActionInfo(d);
        for (ActionVisitor visitor : visitors) {
            if (!visitor.visit(d.getId(), actionInfo, changeInfo, revisionInfo)) {
                continue ACTION;
            }
        }
        out.put(d.getId(), actionInfo);
    }
    return out;
}
#method_after
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc, List<ActionVisitor> visitors, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
    if (!rsrc.getUser().isIdentifiedUser()) {
        return ImmutableMap.of();
    }
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    ACTION: for (UiAction.Description d : uiActions.from(revisions, rsrc)) {
        ActionInfo actionInfo = new ActionInfo(d);
        for (ActionVisitor visitor : visitors) {
            if (!visitor.visit(d.getId(), actionInfo, changeInfo, revisionInfo)) {
                continue ACTION;
            }
        }
        out.put(d.getId(), actionInfo);
    }
    return out;
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(ChangeResource rsrc) {
    Change.Status status = rsrc.getChange().getStatus();
    ChangeControl changeControl = rsrc.getControl();
    boolean visible = isActionAllowed(changeControl) && changeControl.canDelete(db.get(), status);
    return new UiAction.Description().setLabel("Delete").setTitle("Delete change " + rsrc.getId()).setVisible(visible);
}
#method_after
@Override
public UiAction.Description getDescription(ChangeResource rsrc) {
    Change.Status status = rsrc.getChange().getStatus();
    PermissionBackend.ForChange perm = rsrc.permissions().database(db);
    return new UiAction.Description().setLabel("Delete").setTitle("Delete change " + rsrc.getId()).setVisible(and(couldDeleteWhenIn(status), perm.testCond(ChangePermission.DELETE)));
}
#end_block

#method_before
@Override
public RevisionApi revision(String id) throws RestApiException {
    try {
        return revisionApi.create(revisions.parse(change, IdString.fromDecoded(id)));
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot parse revision", e);
    }
}
#method_after
@Override
public RevisionApi revision(String id) throws RestApiException {
    try {
        return revisionApi.create(revisions.parse(change, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot parse revision", e);
    }
}
#end_block

#method_before
@Override
public ReviewerApi reviewer(String id) throws RestApiException {
    try {
        return reviewerApi.create(reviewers.parse(change, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot parse reviewer", e);
    }
}
#method_after
@Override
public ReviewerApi reviewer(String id) throws RestApiException {
    try {
        return reviewerApi.create(reviewers.parse(change, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot parse reviewer", e);
    }
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot abandon change", e);
    }
}
#method_after
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot abandon change", e);
    }
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot restore change", e);
    }
}
#method_after
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot restore change", e);
    }
}
#end_block

#method_before
@Override
public void move(MoveInput in) throws RestApiException {
    try {
        move.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot move change", e);
    }
}
#method_after
@Override
public void move(MoveInput in) throws RestApiException {
    try {
        move.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot move change", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot revert change", e);
    }
}
#method_after
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (Exception e) {
        throw asRestApiException("Cannot revert change", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo createMergePatchSet(MergePatchSetInput in) throws RestApiException {
    try {
        return updateByMerge.apply(change, in).value();
    } catch (IOException | UpdateException | InvalidChangeOperationException | OrmException e) {
        throw new RestApiException("Cannot update change by merge", e);
    }
}
#method_after
@Override
public ChangeInfo createMergePatchSet(MergePatchSetInput in) throws RestApiException {
    try {
        return updateByMerge.apply(change, in).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot update change by merge", e);
    }
}
#end_block

#method_before
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<ListChangesOption> listOptions, EnumSet<SubmittedTogetherOption> submitOptions) throws RestApiException {
    try {
        return submittedTogether.get().addListChangesOption(listOptions).addSubmittedTogetherOption(submitOptions).applyInfo(change);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot query submittedTogether", e);
    }
}
#method_after
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<ListChangesOption> listOptions, EnumSet<SubmittedTogetherOption> submitOptions) throws RestApiException {
    try {
        return submittedTogether.get().addListChangesOption(listOptions).addSubmittedTogetherOption(submitOptions).applyInfo(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot query submittedTogether", e);
    }
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    try {
        deleteChange.apply(change, null);
    } catch (UpdateException e) {
        throw new RestApiException("Cannot delete change", e);
    }
}
#method_after
@Override
public void delete() throws RestApiException {
    try {
        deleteChange.apply(change, null);
    } catch (Exception e) {
        throw asRestApiException("Cannot delete change", e);
    }
}
#end_block

#method_before
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (UpdateException e) {
        throw new RestApiException("Cannot set topic", e);
    }
}
#method_after
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot set topic", e);
    }
}
#end_block

#method_before
@Override
public IncludedInInfo includedIn() throws RestApiException {
    try {
        return includedIn.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Could not extract IncludedIn data", e);
    }
}
#method_after
@Override
public IncludedInInfo includedIn() throws RestApiException {
    try {
        return includedIn.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Could not extract IncludedIn data", e);
    }
}
#end_block

#method_before
@Override
public void addReviewer(String reviewer) throws RestApiException {
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = reviewer;
    addReviewer(in);
}
#method_after
@Override
public AddReviewerResult addReviewer(String reviewer) throws RestApiException {
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = reviewer;
    return addReviewer(in);
}
#end_block

#method_before
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.apply(change, in);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#method_after
@Override
public AddReviewerResult addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        return postReviewers.apply(change, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot add change reviewer", e);
    }
}
#end_block

#method_before
private List<SuggestedReviewerInfo> suggestReviewers(SuggestedReviewersRequest r) throws RestApiException {
    try {
        suggestReviewers.setQuery(r.getQuery());
        suggestReviewers.setLimit(r.getLimit());
        return suggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#method_after
private List<SuggestedReviewerInfo> suggestReviewers(SuggestedReviewersRequest r) throws RestApiException {
    try {
        suggestReviewers.setQuery(r.getQuery());
        suggestReviewers.setLimit(r.getLimit());
        return suggestReviewers.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return changeJson.create(s).format(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return changeJson.create(s).format(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve change", e);
    }
}
#end_block

#method_before
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (RestApiException | UpdateException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#method_after
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (Exception e) {
        throw asRestApiException("Cannot post hashtags", e);
    }
}
#end_block

#method_before
@Override
public Set<String> getHashtags() throws RestApiException {
    try {
        return getHashtags.apply(change).value();
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot get hashtags", e);
    }
}
#method_after
@Override
public Set<String> getHashtags() throws RestApiException {
    try {
        return getHashtags.apply(change).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot get hashtags", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input).value();
    } catch (UpdateException | IOException | OrmException e) {
        throw new RestApiException("Cannot set assignee", e);
    }
}
#method_after
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    try {
        return putAssignee.apply(change, input);
    } catch (Exception e) {
        throw asRestApiException("Cannot set assignee", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo getAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = getAssignee.apply(change);
        return r.isNone() ? null : r.value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get assignee", e);
    }
}
#method_after
@Override
public AccountInfo getAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = getAssignee.apply(change);
        return r.isNone() ? null : r.value();
    } catch (Exception e) {
        throw asRestApiException("Cannot get assignee", e);
    }
}
#end_block

#method_before
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw new RestApiException("Cannot get past assignees", e);
    }
}
#method_after
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    try {
        return getPastAssignees.apply(change).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot get past assignees", e);
    }
}
#end_block

#method_before
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = deleteAssignee.apply(change, null);
        return r.isNone() ? null : r.value();
    } catch (UpdateException | OrmException e) {
        throw new RestApiException("Cannot delete assignee", e);
    }
}
#method_after
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    try {
        Response<AccountInfo> r = deleteAssignee.apply(change, null);
        return r.isNone() ? null : r.value();
    } catch (Exception e) {
        throw asRestApiException("Cannot delete assignee", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    try {
        return listComments.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get comments", e);
    }
}
#method_after
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    try {
        return listComments.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot get comments", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listChangeRobotComments.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get robot comments", e);
    }
}
#method_after
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listChangeRobotComments.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot get robot comments", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    try {
        return listDrafts.apply(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get drafts", e);
    }
}
#method_after
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    try {
        return listDrafts.apply(change);
    } catch (Exception e) {
        throw asRestApiException("Cannot get drafts", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo check() throws RestApiException {
    try {
        return check.apply(change).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot check change", e);
    }
}
#method_after
@Override
public ChangeInfo check() throws RestApiException {
    try {
        return check.apply(change).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot check change", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo check(FixInput fix) throws RestApiException {
    try {
        return check.apply(change, fix).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot check change", e);
    }
}
#method_after
@Override
public ChangeInfo check(FixInput fix) throws RestApiException {
    try {
        // ConsistencyChecker.
        return check.apply(change, fix).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot check change", e);
    }
}
#end_block

#method_before
@Override
public void index() throws RestApiException {
    try {
        index.apply(change, new Index.Input());
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot index change", e);
    }
}
#method_after
@Override
public void index() throws RestApiException {
    try {
        index.apply(change, new Index.Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot index change", e);
    }
}
#end_block

#method_before
@Override
protected void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    // If there is only one parent, a cherry-pick can be done by taking the
    // delta relative to that one parent and redoing that on the current merge
    // tip.
    args.rw.parseBody(toMerge);
    psId = ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId());
    RevCommit mergeTip = args.mergeTip.getCurrentTip();
    args.rw.parseBody(mergeTip);
    String cherryPickCmtMsg = args.mergeUtil.createCommitMessageOnSubmit(toMerge, mergeTip);
    PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
    try {
        newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, false);
    } catch (MergeConflictException mce) {
        // Keep going in the case of a single merge failure; the goal is to
        // cherry-pick as many commits as possible.
        toMerge.setStatusCode(CommitMergeStatus.PATH_CONFLICT);
        return;
    } catch (MergeIdenticalTreeException mie) {
        toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
        return;
    }
    // Initial copy doesn't have new patch set ID since change hasn't been
    // updated yet.
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(psId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_PICK);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commitStatus.put(newCommit);
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), newCommit, psId.toRefName()));
    patchSetInfo = args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, psId);
}
#method_after
@Override
protected void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException, OrmException {
    // If there is only one parent, a cherry-pick can be done by taking the
    // delta relative to that one parent and redoing that on the current merge
    // tip.
    args.rw.parseBody(toMerge);
    psId = ChangeUtil.nextPatchSetIdFromChangeRefsMap(ctx.getRepoView().getRefs(getId().toRefPrefix()), toMerge.change().currentPatchSetId());
    RevCommit mergeTip = args.mergeTip.getCurrentTip();
    args.rw.parseBody(mergeTip);
    String cherryPickCmtMsg = args.mergeUtil.createCommitMessageOnSubmit(toMerge, mergeTip);
    PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
    try {
        newCommit = args.mergeUtil.createCherryPickFromCommit(ctx.getInserter(), ctx.getRepoView().getConfig(), args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, false);
    } catch (MergeConflictException mce) {
        // Keep going in the case of a single merge failure; the goal is to
        // cherry-pick as many commits as possible.
        toMerge.setStatusCode(CommitMergeStatus.PATH_CONFLICT);
        return;
    } catch (MergeIdenticalTreeException mie) {
        toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
        return;
    }
    // Initial copy doesn't have new patch set ID since change hasn't been
    // updated yet.
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(psId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_PICK);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commitStatus.put(newCommit);
    ctx.addRefUpdate(ObjectId.zeroId(), newCommit, psId.toRefName());
    patchSetInfo = args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, psId);
}
#end_block

#method_before
@Override
public PatchSet updateChangeImpl(ChangeContext ctx) throws OrmException, NoSuchChangeException, IOException {
    if (newCommit == null && toMerge.getStatusCode() == SKIPPED_IDENTICAL_TREE) {
        return null;
    }
    checkNotNull(newCommit, "no new commit produced by CherryPick of %s, expected to fail fast", toMerge.change().getId());
    PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
    PatchSet newPs = args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, newCommit, prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of(), null, null);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    // Don't copy approvals, as this is already taken care of by
    // SubmitStrategyOp.
    newCommit.setControl(ctx.getControl());
    return newPs;
}
#method_after
@Override
public PatchSet updateChangeImpl(ChangeContext ctx) throws OrmException, NoSuchChangeException, IOException {
    if (newCommit == null && toMerge.getStatusCode() == SKIPPED_IDENTICAL_TREE) {
        return null;
    }
    checkNotNull(newCommit, "no new commit produced by CherryPick of %s, expected to fail fast", toMerge.change().getId());
    PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
    PatchSet newPs = args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, newCommit, prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of(), null, null);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    // Don't copy approvals, as this is already taken care of by
    // SubmitStrategyOp.
    newCommit.setNotes(ctx.getNotes());
    return newPs;
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    if (args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge)) {
        // on the commit so we have nothing further to perform at this time.
        return;
    }
    // There are multiple parents, so this is a merge commit. We don't want
    // to cherry-pick the merge as clients can't easily rebase their history
    // with that merge present and replaced by an equivalent merge with a
    // different first parent. So instead behave as though MERGE_IF_NECESSARY
    // was configured.
    MergeTip mergeTip = args.mergeTip;
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge) && !args.submoduleOp.hasSubscription(args.destBranch)) {
        mergeTip.moveTipTo(toMerge, toMerge);
    } else {
        PersonIdent myIdent = new PersonIdent(args.serverIdent, ctx.getWhen());
        CodeReviewCommit result = args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.repo, args.rw, args.inserter, args.destBranch, mergeTip.getCurrentTip(), toMerge);
        result = amendGitlink(result);
        mergeTip.moveTipTo(result, toMerge);
        args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    }
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    if (args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge)) {
        // on the commit so we have nothing further to perform at this time.
        return;
    }
    // There are multiple parents, so this is a merge commit. We don't want
    // to cherry-pick the merge as clients can't easily rebase their history
    // with that merge present and replaced by an equivalent merge with a
    // different first parent. So instead behave as though MERGE_IF_NECESSARY
    // was configured.
    MergeTip mergeTip = args.mergeTip;
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge) && !args.submoduleOp.hasSubscription(args.destBranch)) {
        mergeTip.moveTipTo(toMerge, toMerge);
    } else {
        PersonIdent myIdent = new PersonIdent(args.serverIdent, ctx.getWhen());
        CodeReviewCommit result = args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.rw, ctx.getInserter(), ctx.getRepoView().getConfig(), args.destBranch, mergeTip.getCurrentTip(), toMerge);
        result = amendGitlink(result);
        mergeTip.moveTipTo(result, toMerge);
        args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    }
}
#end_block

#method_before
@Test
public void parseAuthor() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Subject: This is a test change\n");
    assertParseFails(writeCommit("Update change\n" + "\n" + "Patch-set: 1\n", new PersonIdent("Change Owner", "owner@example.com", serverIdent.getWhen(), serverIdent.getTimeZone())));
    assertParseFails(writeCommit("Update change\n" + "\n" + "Patch-set: 1\n", new PersonIdent("Change Owner", "x@gerrit", serverIdent.getWhen(), serverIdent.getTimeZone())));
    assertParseFails(writeCommit("Update change\n" + "\n" + "Patch-set: 1\n", new PersonIdent("Change\n\u1234<Owner>", "\n\nx<@>\u0002gerrit", serverIdent.getWhen(), serverIdent.getTimeZone())));
}
#method_after
@Test
public void parseAuthor() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Subject: This is a test change\n");
    assertParseFails(writeCommit("Update change\n\nPatch-set: 1\n", new PersonIdent("Change Owner", "owner@example.com", serverIdent.getWhen(), serverIdent.getTimeZone())));
    assertParseFails(writeCommit("Update change\n\nPatch-set: 1\n", new PersonIdent("Change Owner", "x@gerrit", serverIdent.getWhen(), serverIdent.getTimeZone())));
    assertParseFails(writeCommit("Update change\n\nPatch-set: 1\n", new PersonIdent("Change\n\u1234<Owner>", "\n\nx<@>\u0002gerrit", serverIdent.getWhen(), serverIdent.getTimeZone())));
}
#end_block

#method_before
@Test
public void parseStatus() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Status: NEW\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Status: new\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Status: OOPS\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Status: NEW\n" + "Status: NEW\n");
}
#method_after
@Test
public void parseStatus() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Status: NEW\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Status: new\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n\nPatch-set: 1\nStatus: OOPS\n");
    assertParseFails("Update change\n\nPatch-set: 1\nStatus: NEW\nStatus: NEW\n");
}
#end_block

#method_before
@Test
public void parsePatchSetId() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Patch-set: 1\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: x\n");
}
#method_after
@Test
public void parsePatchSetId() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n\n");
    assertParseFails("Update change\n\nPatch-set: 1\nPatch-set: 1\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n\nPatch-set: x\n");
}
#end_block

#method_before
@Test
public void parseApproval() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Label: Label1=+1\n" + "Label: Label2=1\n" + "Label: Label3=0\n" + "Label: Label4=-1\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Label: -Label1\n" + "Label: -Label1 Other Account <2@gerrit>\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Label: Label1=X\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Label: Label1 = 1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Label: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Label: Label1 Other Account <2@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Label: -Label!1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Label: -Label!1 Other Account <2@gerrit>\n");
}
#method_after
@Test
public void parseApproval() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Label: Label1=+1\n" + "Label: Label2=1\n" + "Label: Label3=0\n" + "Label: Label4=-1\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Label: -Label1\n" + "Label: -Label1 Other Account <2@gerrit>\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n\nPatch-set: 1\nLabel: Label1=X\n");
    assertParseFails("Update change\n\nPatch-set: 1\nLabel: Label1 = 1\n");
    assertParseFails("Update change\n\nPatch-set: 1\nLabel: X+Y\n");
    assertParseFails("Update change\n\nPatch-set: 1\nLabel: Label1 Other Account <2@gerrit>\n");
    assertParseFails("Update change\n\nPatch-set: 1\nLabel: -Label!1\n");
    assertParseFails("Update change\n\nPatch-set: 1\nLabel: -Label!1 Other Account <2@gerrit>\n");
}
#end_block

#method_before
@Test
public void parseSubmitRecords() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Subject: This is a test change\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Code-Review\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Alternative-Code-Review\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Submitted-with: OOPS\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Submitted-with: NEED: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Submitted-with: OK: X+Y: Change Owner <1@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Submitted-with: OK: Code-Review: 1@gerrit\n");
}
#method_after
@Test
public void parseSubmitRecords() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Subject: This is a test change\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Code-Review\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Alternative-Code-Review\n");
    assertParseFails("Update change\n\nPatch-set: 1\nSubmitted-with: OOPS\n");
    assertParseFails("Update change\n\nPatch-set: 1\nSubmitted-with: NEED: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Submitted-with: OK: X+Y: Change Owner <1@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Submitted-with: OK: Code-Review: 1@gerrit\n");
}
#end_block

#method_before
@Test
public void parseReviewer() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n" + "CC: Other Account <2@gerrit>\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Reviewer: 1@gerrit\n");
}
#method_after
@Test
public void parseReviewer() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n" + "CC: Other Account <2@gerrit>\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n\nPatch-set: 1\nReviewer: 1@gerrit\n");
}
#end_block

#method_before
@Test
public void parseTopic() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Topic: Some Topic\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Topic:\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Topic: Some Topic\n" + "Topic: Other Topic");
}
#method_after
@Test
public void parseTopic() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Topic: Some Topic\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Patch-set: 1\n" + "Topic:\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n\nPatch-set: 1\nTopic: Some Topic\nTopic: Other Topic");
}
#end_block

#method_before
@Test
public void parsePatchSetState() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1 (PUBLISHED)\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Subject: Some subject of a change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1 (DELETED)\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Subject: Some subject of a change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1 (NOT A STATUS)\n" + "Branch: refs/heads/master\n" + "Subject: Some subject of a change\n");
}
#method_after
@Test
public void parsePatchSetState() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1 (PUBLISHED)\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Subject: Some subject of a change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1 (DRAFT)\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Subject: Some subject of a change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1 (DELETED)\n" + "Branch: refs/heads/master\n" + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" + "Subject: Some subject of a change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1 (NOT A STATUS)\n" + "Branch: refs/heads/master\n" + "Subject: Some subject of a change\n");
}
#end_block

#method_before
@Test
public void currentPatchSet() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1\n" + "Current: true");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1\n" + "Current: tRUe");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Current: false");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Current: blah");
}
#method_after
@Test
public void currentPatchSet() throws Exception {
    assertParseSucceeds("Update change\n\nPatch-set: 1\nCurrent: true");
    assertParseSucceeds("Update change\n\nPatch-set: 1\nCurrent: tRUe");
    assertParseFails("Update change\n\nPatch-set: 1\nCurrent: false");
    assertParseFails("Update change\n\nPatch-set: 1\nCurrent: blah");
}
#end_block

#method_before
private RevCommit writeCommit(String body) throws Exception {
    ChangeNoteUtil noteUtil = injector.getInstance(ChangeNoteUtil.class);
    return writeCommit(body, noteUtil.newIdent(changeOwner.getAccount(), TimeUtil.nowTs(), serverIdent, "Anonymous Coward"));
}
#method_after
private RevCommit writeCommit(String body) throws Exception {
    ChangeNoteUtil noteUtil = injector.getInstance(ChangeNoteUtil.class);
    return writeCommit(body, noteUtil.newIdent(changeOwner.getAccount(), TimeUtil.nowTs(), serverIdent, "Anonymous Coward"), false);
}
#end_block

#method_before
private RevCommit writeCommit(String body, PersonIdent author) throws Exception {
    Change change = newChange();
    ChangeNotes notes = newNotes(change).load();
    try (ObjectInserter ins = testRepo.getRepository().newObjectInserter()) {
        CommitBuilder cb = new CommitBuilder();
        cb.setParentId(notes.getRevision());
        cb.setAuthor(author);
        cb.setCommitter(new PersonIdent(serverIdent, author.getWhen()));
        cb.setTreeId(testRepo.tree());
        cb.setMessage(body);
        ObjectId id = ins.insert(cb);
        ins.flush();
        RevCommit commit = walk.parseCommit(id);
        walk.parseBody(commit);
        return commit;
    }
}
#method_after
private RevCommit writeCommit(String body, PersonIdent author) throws Exception {
    return writeCommit(body, author, false);
}
#end_block

#method_before
private RevCommit writeCommit(String body, PersonIdent author) throws Exception {
    Change change = newChange();
    ChangeNotes notes = newNotes(change).load();
    try (ObjectInserter ins = testRepo.getRepository().newObjectInserter()) {
        CommitBuilder cb = new CommitBuilder();
        cb.setParentId(notes.getRevision());
        cb.setAuthor(author);
        cb.setCommitter(new PersonIdent(serverIdent, author.getWhen()));
        cb.setTreeId(testRepo.tree());
        cb.setMessage(body);
        ObjectId id = ins.insert(cb);
        ins.flush();
        RevCommit commit = walk.parseCommit(id);
        walk.parseBody(commit);
        return commit;
    }
}
#method_after
private RevCommit writeCommit(String body, boolean initWorkInProgress) throws Exception {
    ChangeNoteUtil noteUtil = injector.getInstance(ChangeNoteUtil.class);
    return writeCommit(body, noteUtil.newIdent(changeOwner.getAccount(), TimeUtil.nowTs(), serverIdent, "Anonymous Coward"), initWorkInProgress);
}
#end_block

#method_before
private void assertParseSucceeds(String body) throws Exception {
    assertParseSucceeds(writeCommit(body));
}
#method_after
private ChangeNotesState assertParseSucceeds(String body) throws Exception {
    return assertParseSucceeds(writeCommit(body));
}
#end_block

#method_before
private void assertParseSucceeds(RevCommit commit) throws Exception {
    newParser(commit).parseAll();
}
#method_after
private ChangeNotesState assertParseSucceeds(RevCommit commit) throws Exception {
    return newParser(commit).parseAll();
}
#end_block

#method_before
public static Id parse(final String str) {
    final Id r = new Id();
    r.fromString(str);
    return r;
}
#method_after
public static Id parse(String str) {
    final Id r = new Id();
    r.fromString(str);
    return r;
}
#end_block

#method_before
public static Key parse(final String str) {
    final Key r = new Key();
    r.fromString(str);
    return r;
}
#method_after
public static Key parse(String str) {
    final Key r = new Key();
    r.fromString(str);
    return r;
}
#end_block

#method_before
public void setKey(final Change.Key k) {
    changeKey = k;
}
#method_after
public void setKey(Change.Key k) {
    changeKey = k;
}
#end_block

#method_before
public void setCurrentPatchSet(final PatchSetInfo ps) {
    if (originalSubject == null && subject != null) {
        // Change was created before schema upgrade. Use the last subject
        // associated with this change, as the most recent discussion will
        // be under that thread in an email client such as GMail.
        originalSubject = subject;
    }
    currentPatchSetId = ps.getKey().get();
    subject = ps.getSubject();
    if (originalSubject == null) {
        // Newly created changes remember the first commit's subject.
        originalSubject = subject;
    }
}
#method_after
public void setCurrentPatchSet(PatchSetInfo ps) {
    if (originalSubject == null && subject != null) {
        // Change was created before schema upgrade. Use the last subject
        // associated with this change, as the most recent discussion will
        // be under that thread in an email client such as GMail.
        originalSubject = subject;
    }
    currentPatchSetId = ps.getKey().get();
    subject = ps.getSubject();
    if (originalSubject == null) {
        // Newly created changes remember the first commit's subject.
        originalSubject = subject;
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeList.query("change:" + changeId.get() + " has:draft", Collections.<ListChangesOption>emptySet(), group.add(new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                hasDraftComments = result.length() > 0;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(final ChangeInfo info) {
            info.init();
            addExtensionPoints(info, initCurrentRevision(info));
            final RevisionInfo rev = info.revision(revision);
            CallbackGroup group = new CallbackGroup();
            loadCommit(rev, group);
            group.addListener(new GerritCallback<Void>() {

                @Override
                public void onSuccess(Void result) {
                    if (base.isBase() && rev.isMerge()) {
                        base = DiffObject.parse(info.legacyId(), Gerrit.getUserPreferences().defaultBaseForMerges().getBase());
                    }
                    loadConfigInfo(info, base);
                    JsArray<MessageInfo> mAr = info.messages();
                    for (int i = 0; i < mAr.length(); i++) {
                        if (mAr.get(i).tag() != null) {
                            hideTaggedComments.setVisible(true);
                            break;
                        }
                    }
                }
            });
            group.done();
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeList.query("change:" + changeId.get() + " has:draft", Collections.<ListChangesOption>emptySet(), group.add(new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                hasDraftComments = result.length() > 0;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
        ChangeApi.editWithFiles(Project.NameKey.asStringOrNull(project), changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            if (project == null) {
                // Update Project when the first API call succeeded if it wasn't already present.
                // This is the case when the user used a URL that doesn't include the project.
                // Setting it here will rewrite the URL token to include the project (visible to
                // the user) and all future API calls made from the change screen will use
                // project/+/changeId to identify the change.
                project = info.projectNameKey();
            }
            initCurrentRevision(info);
            final RevisionInfo rev = info.revision(revision);
            CallbackGroup group = new CallbackGroup();
            loadCommit(rev, group);
            group.addListener(new GerritCallback<Void>() {

                @Override
                public void onSuccess(Void result) {
                    if (base.isBase() && rev.isMerge()) {
                        base = DiffObject.parse(info.legacyId(), Gerrit.getUserPreferences().defaultBaseForMerges().getBase());
                    }
                    loadConfigInfo(info, base);
                    JsArray<MessageInfo> mAr = info.messages();
                    for (int i = 0; i < mAr.length(); i++) {
                        if (mAr.get(i).tag() != null) {
                            hideTaggedComments.setVisible(true);
                            break;
                        }
                    }
                }
            });
            group.done();
        }
    }));
}
#end_block

#method_before
private void addExtensionPoints(ChangeInfo change, RevisionInfo rev) {
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER, headerExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_BUTTONS, headerExtensionMiddle, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, headerExtensionRight, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, changeExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_RELATED_INFO_BLOCK, relatedExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_COMMIT_INFO_BLOCK, commitExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HISTORY_RIGHT_OF_BUTTONS, historyExtensionRight, change, rev);
}
#method_after
private void addExtensionPoints(ChangeInfo change, RevisionInfo rev, Entry result) {
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER, headerExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_BUTTONS, headerExtensionMiddle, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS, headerExtensionRight, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK, changeExtension, change, rev, result.getExtensionPanelNames(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK.toString()));
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_RELATED_INFO_BLOCK, relatedExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_COMMIT_INFO_BLOCK, commitExtension, change, rev);
    addExtensionPoint(GerritUiExtensionPoint.CHANGE_SCREEN_HISTORY_RIGHT_OF_BUTTONS, historyExtensionRight, change, rev);
}
#end_block

#method_before
private void addExtensionPoint(GerritUiExtensionPoint extensionPoint, Panel p, ChangeInfo change, RevisionInfo rev) {
    ExtensionPanel extensionPanel = new ExtensionPanel(extensionPoint);
    extensionPanel.putObject(GerritUiExtensionPoint.Key.CHANGE_INFO, change);
    extensionPanel.putObject(GerritUiExtensionPoint.Key.REVISION_INFO, rev);
    p.add(extensionPanel);
}
#method_after
private void addExtensionPoint(GerritUiExtensionPoint extensionPoint, Panel p, ChangeInfo change, RevisionInfo rev, List<String> panelNames) {
    ExtensionPanel extensionPanel = new ExtensionPanel(extensionPoint, panelNames);
    extensionPanel.putObject(GerritUiExtensionPoint.Key.CHANGE_INFO, change);
    extensionPanel.putObject(GerritUiExtensionPoint.Key.REVISION_INFO, rev);
    p.add(extensionPanel);
}
#end_block

#method_before
private void addExtensionPoint(GerritUiExtensionPoint extensionPoint, Panel p, ChangeInfo change, RevisionInfo rev) {
    ExtensionPanel extensionPanel = new ExtensionPanel(extensionPoint);
    extensionPanel.putObject(GerritUiExtensionPoint.Key.CHANGE_INFO, change);
    extensionPanel.putObject(GerritUiExtensionPoint.Key.REVISION_INFO, rev);
    p.add(extensionPanel);
}
#method_after
private void addExtensionPoint(GerritUiExtensionPoint extensionPoint, Panel p, ChangeInfo change, RevisionInfo rev) {
    addExtensionPoint(extensionPoint, p, change, rev, Collections.emptyList());
}
#end_block

#method_before
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    EnumSet<ListChangesOption> opts = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CHANGE_ACTIONS);
    if (enableSignedPush()) {
        opts.add(ListChangesOption.PUSH_CERTIFICATES);
    }
    ChangeList.addOptions(call, opts);
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#method_after
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(Project.NameKey.asStringOrNull(project), changeId.get());
    EnumSet<ListChangesOption> opts = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CHANGE_ACTIONS);
    if (enableSignedPush()) {
        opts.add(ListChangesOption.PUSH_CERTIFICATES);
    }
    ChangeList.addOptions(call, opts);
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#end_block

#method_before
void loadRevisionInfo() {
    RestApi call = ChangeApi.actions(changeId.get(), revision);
    call.background();
    call.get(new GerritCallback<NativeMap<ActionInfo>>() {

        @Override
        public void onSuccess(NativeMap<ActionInfo> actionMap) {
            actionMap.copyKeysIntoChildren("id");
            renderRevisionInfo(changeInfo, actionMap);
        }
    });
}
#method_after
void loadRevisionInfo() {
    RestApi call = ChangeApi.actions(getProject().get(), changeId.get(), revision);
    call.background();
    call.get(new GerritCallback<NativeMap<ActionInfo>>() {

        @Override
        public void onSuccess(NativeMap<ActionInfo> actionMap) {
            actionMap.copyKeysIntoChildren("id");
            renderRevisionInfo(changeInfo, actionMap);
        }
    });
}
#end_block

#method_before
private void gotoSibling(int offset) {
    if (offset > 0 && changeInfo.currentRevision() != null && changeInfo.currentRevision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacyId(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#method_after
private void gotoSibling(int offset) {
    if (offset > 0 && changeInfo.currentRevision() != null && changeInfo.currentRevision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(project, new PatchSet.Id(changeInfo.legacyId(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#end_block

#method_before
private void initIncludedInAction(ChangeInfo info) {
    if (info.status() == Status.MERGED) {
        includedInAction = new IncludedInAction(info.legacyId(), style, headerLine, includedIn);
        includedIn.setVisible(true);
    }
}
#method_after
private void initIncludedInAction(ChangeInfo info) {
    if (info.status() == Status.MERGED) {
        includedInAction = new IncludedInAction(info.projectNameKey(), info.legacyId(), style, headerLine, includedIn);
        includedIn.setVisible(true);
    }
}
#end_block

#method_before
private void initRevisionsAction(ChangeInfo info, String revision) {
    int currentPatchSet;
    if (info.currentRevision() != null && info.revisions().containsKey(info.currentRevision())) {
        currentPatchSet = info.revision(info.currentRevision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    boolean isPatchSetCurrent = true;
    String revisionId = info.revision(revision).id();
    if (revisionId.equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = revisionId;
        if (!currentlyViewedPatchSet.equals(Integer.toString(currentPatchSet))) {
            isPatchSetCurrent = false;
        }
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    updatePatchSetsTextStyle(isPatchSetCurrent);
    patchSetsAction = new PatchSetsAction(info.legacyId(), revision, edit, style, headerLine, patchSets);
}
#method_after
private void initRevisionsAction(ChangeInfo info, String revision) {
    int currentPatchSet;
    if (info.currentRevision() != null && info.revisions().containsKey(info.currentRevision())) {
        currentPatchSet = info.revision(info.currentRevision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    boolean isPatchSetCurrent = true;
    String revisionId = info.revision(revision).id();
    if (revisionId.equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = revisionId;
        if (!currentlyViewedPatchSet.equals(Integer.toString(currentPatchSet))) {
            isPatchSetCurrent = false;
        }
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    updatePatchSetsTextStyle(isPatchSetCurrent);
    patchSetsAction = new PatchSetsAction(info.projectNameKey(), info.legacyId(), revision, edit, style, headerLine, patchSets);
}
#end_block

#method_before
private void initProjectLinks(final ChangeInfo info) {
    projectSettingsLink.setHref("#" + PageLinks.toProject(info.projectNameKey()));
    projectSettings.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (Hyperlink.impl.handleAsClick((Event) event.getNativeEvent())) {
                event.stopPropagation();
                event.preventDefault();
                Gerrit.display(PageLinks.toProject(info.projectNameKey()));
            }
        }
    }, ClickEvent.getType());
    projectDashboard.setText(info.project());
    projectDashboard.setTargetHistoryToken(PageLinks.toProjectDefaultDashboard(info.projectNameKey()));
}
#method_after
private void initProjectLinks(ChangeInfo info) {
    projectSettingsLink.setHref("#" + PageLinks.toProject(info.projectNameKey()));
    projectSettings.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (Hyperlink.impl.handleAsClick((Event) event.getNativeEvent())) {
                event.stopPropagation();
                event.preventDefault();
                Gerrit.display(PageLinks.toProject(info.projectNameKey()));
            }
        }
    }, ClickEvent.getType());
    projectDashboard.setText(info.project());
    projectDashboard.setTargetHistoryToken(PageLinks.toProjectDefaultDashboard(info.projectNameKey()));
}
#end_block

#method_before
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn()) {
        RevisionInfo rev = info.revision(revision);
        if (info.status().isOpen()) {
            if (isEditModeEnabled(info, rev)) {
                editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
                addFile.setVisible(!editMode.isVisible());
                deleteFile.setVisible(!editMode.isVisible());
                renameFile.setVisible(!editMode.isVisible());
                reviewMode.setVisible(!editMode.isVisible());
                addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile, files);
                deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
                renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
            } else {
                editMode.setVisible(false);
                addFile.setVisible(false);
                reviewMode.setVisible(false);
            }
            if (rev.isEdit()) {
                if (info.hasEditBasedOnCurrentPatchSet()) {
                    publishEdit.setVisible(true);
                } else {
                    rebaseEdit.setVisible(true);
                }
                deleteEdit.setVisible(true);
            }
        } else if (rev.isEdit()) {
            deleteEdit.setStyleName(style.highlight());
            deleteEdit.setVisible(true);
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn()) {
        RevisionInfo rev = info.revision(revision);
        if (info.status().isOpen()) {
            if (isEditModeEnabled(info, rev)) {
                editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
                addFile.setVisible(!editMode.isVisible());
                deleteFile.setVisible(!editMode.isVisible());
                renameFile.setVisible(!editMode.isVisible());
                reviewMode.setVisible(!editMode.isVisible());
                addFileAction = new AddFileAction(info.projectNameKey(), changeId, info.revision(revision), style, addFile, files);
                deleteFileAction = new DeleteFileAction(info.projectNameKey(), changeId, info.revision(revision), style, addFile);
                renameFileAction = new RenameFileAction(info.projectNameKey(), changeId, info.revision(revision), style, addFile);
            } else {
                editMode.setVisible(false);
                addFile.setVisible(false);
                reviewMode.setVisible(false);
            }
            if (rev.isEdit()) {
                if (info.hasEditBasedOnCurrentPatchSet()) {
                    publishEdit.setVisible(true);
                } else {
                    rebaseEdit.setVisible(true);
                }
                deleteEdit.setVisible(true);
            }
        } else if (rev.isEdit()) {
            deleteEdit.setStyleName(style.highlight());
            deleteEdit.setVisible(true);
        }
    }
}
#end_block

#method_before
@UiHandler("publishEdit")
void onPublishEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.publishEdit(changeId, publishEdit, rebaseEdit, deleteEdit);
}
#method_after
@UiHandler("publishEdit")
void onPublishEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.publishEdit(getProject(), changeId, publishEdit, rebaseEdit, deleteEdit);
}
#end_block

#method_before
@UiHandler("rebaseEdit")
void onRebaseEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.rebaseEdit(changeId, publishEdit, rebaseEdit, deleteEdit);
}
#method_after
@UiHandler("rebaseEdit")
void onRebaseEdit(@SuppressWarnings("unused") ClickEvent e) {
    EditActions.rebaseEdit(getProject(), changeId, publishEdit, rebaseEdit, deleteEdit);
}
#end_block

#method_before
@UiHandler("deleteEdit")
void onDeleteEdit(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteChangeEdit())) {
        EditActions.deleteEdit(changeId, publishEdit, rebaseEdit, deleteEdit);
    }
}
#method_after
@UiHandler("deleteEdit")
void onDeleteEdit(@SuppressWarnings("unused") ClickEvent e) {
    if (Window.confirm(Resources.C.deleteChangeEdit())) {
        EditActions.deleteEdit(getProject(), changeId, publishEdit, rebaseEdit, deleteEdit);
    }
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    KeyCommandSet keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    handlers.add(GlobalKey.add(this, keysNavigation));
    KeyCommandSet keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                star.setValue(!star.getValue(), true);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                reviewers.onOpenForm();
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                // differentiate F5 from 't' by checking the charCode(F5=0, t=116).
                if (event.getNativeEvent().getCharCode() == 0) {
                    Window.Location.reload();
                    return;
                }
                if (topic.canEdit()) {
                    topic.onEdit();
                }
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    handlers.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    KeyCommandSet keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(project, changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    handlers.add(GlobalKey.add(this, keysNavigation));
    KeyCommandSet keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                star.setValue(!star.getValue(), true);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                reviewers.onOpenForm();
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                // differentiate F5 from 't' by checking the charCode(F5=0, t=116).
                if (event.getNativeEvent().getCharCode() == 0) {
                    Window.Location.reload();
                    return;
                }
                if (topic.canEdit()) {
                    topic.onEdit();
                }
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    handlers.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#end_block

#method_before
private void scrollToPath(String token) {
    int s = token.indexOf('/');
    try {
        String c = token.substring(0, s);
        int editIndex = c.indexOf(",edit");
        if (editIndex > 0) {
            c = c.substring(0, editIndex);
        }
        if (s < 0 || !changeId.equals(Change.Id.parse(c))) {
            // Unrelated URL, do not scroll.
            return;
        }
    } catch (IllegalArgumentException e) {
        return;
    }
    s = token.indexOf('/', s + 1);
    if (s < 0) {
        // URL does not name a file.
        return;
    }
    int c = token.lastIndexOf(',');
    if (0 <= c) {
        token = token.substring(s + 1, c);
    } else {
        token = token.substring(s + 1);
    }
    if (!token.isEmpty()) {
        files.scrollToPath(KeyUtil.decode(token));
    }
}
#method_after
private void scrollToPath(String token) {
    ProjectChangeId cId;
    try {
        cId = ProjectChangeId.create(token);
    } catch (IllegalArgumentException e) {
        // Scrolling is best-effort.
        return;
    }
    if (!changeId.equals(cId.getChangeId())) {
        // Unrelated URL, do not scroll.
        return;
    }
    // Extract the start of a file path. The patch set is always contained in the URL and separated
    // by from the changeId by a forward slash. Example: /c/project/+/123/1/folder/file.txt
    int s = token.indexOf('/', cId.identifierLength() + 1);
    if (s < 0) {
        // URL does not name a file.
        return;
    }
    int c = token.lastIndexOf(',');
    if (0 <= c) {
        token = token.substring(s + 1, c);
    } else {
        token = token.substring(s + 1);
    }
    if (!token.isEmpty()) {
        files.scrollToPath(KeyUtil.decode(token));
    }
}
#end_block

#method_before
@UiHandler("permalink")
void onReload(ClickEvent e) {
    e.preventDefault();
    Gerrit.display(PageLinks.toChange(changeId));
}
#method_after
@UiHandler("permalink")
void onReload(ClickEvent e) {
    e.preventDefault();
    Gerrit.display(PageLinks.toChange(project, changeId));
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, DiffObject base) {
    final RevisionInfo rev = info.revision(revision);
    if (base.isAutoMerge() && !initCurrentRevision(info).isMerge()) {
        Gerrit.display(getToken(), new NotFoundScreen());
    }
    updateToken(info, base, rev);
    RevisionInfo baseRev = resolveRevisionOrPatchSetId(info, base.asString(), null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        // Comments are filtered for the current revision. Use parent
        // patch set for edits, as edits themself can never have comments.
        RevisionInfo p = RevisionInfo.findEditParentRevision(info.revisions().values());
        List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(p, group);
        loadFileList(base, baseRev, rev, lastReply, group, comments, null);
    } else {
        loadDiff(base, baseRev, rev, lastReply, group);
    }
    group.addListener(new AsyncCallback<Void>() {

        @Override
        public void onSuccess(Void result) {
            loadConfigInfo(info, rev);
        }

        @Override
        public void onFailure(Throwable caught) {
            logger.log(Level.SEVERE, "Loading file list and inline comments failed: " + caught.getMessage());
            loadConfigInfo(info, rev);
        }
    });
    group.done();
}
#method_after
private void loadConfigInfo(ChangeInfo info, DiffObject base) {
    final RevisionInfo rev = info.revision(revision);
    if (base.isAutoMerge() && !initCurrentRevision(info).isMerge()) {
        Gerrit.display(getToken(), new NotFoundScreen());
    }
    updateToken(info, base, rev);
    RevisionInfo baseRev = resolveRevisionOrPatchSetId(info, base.asString(), null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        // Comments are filtered for the current revision. Use parent
        // patch set for edits, as edits themself can never have comments.
        RevisionInfo p = RevisionInfo.findEditParentRevision(info.revisions().values());
        List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(p, group);
        loadFileList(base, baseRev, rev, lastReply, group, comments, null);
    } else {
        loadDiff(base, baseRev, rev, lastReply, group);
    }
    group.addListener(new AsyncCallback<Void>() {

        @Override
        public void onSuccess(Void result) {
            loadConfigInfo(info, rev);
        }

        @Override
        public void onFailure(Throwable caught) {
            logger.log(Level.SEVERE, "Loading file list and inline comments failed: " + caught.getMessage());
            loadConfigInfo(info, rev);
        }
    });
    group.done();
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, RevisionInfo rev) {
    if (loaded) {
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.projectNameKey(), new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    });
}
#method_after
private void loadConfigInfo(ChangeInfo info, RevisionInfo rev) {
    if (loaded) {
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.projectNameKey(), new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    });
    ConfigInfoCache.get(info.projectNameKey(), new GerritCallback<Entry>() {

        @Override
        public void onSuccess(Entry entry) {
            addExtensionPoints(info, rev, entry);
        }
    });
}
#end_block

#method_before
private void updateToken(ChangeInfo info, DiffObject base, RevisionInfo rev) {
    StringBuilder token = new StringBuilder("/c/").append(info._number()).append("/");
    if (base.asString() != null) {
        token.append(base.asString()).append("..");
    }
    if (base.asString() != null || !rev.name().equals(info.currentRevision())) {
        token.append(rev._number());
    }
    setToken(token.toString());
}
#method_after
private void updateToken(ChangeInfo info, DiffObject base, RevisionInfo rev) {
    StringBuilder token = new StringBuilder("/c/").append(PageLinks.toChangeId(info.projectNameKey(), info.legacyId())).append("/");
    if (base.asString() != null) {
        token.append(base.asString()).append("..");
    }
    if (base.asString() != null || !rev.name().equals(info.currentRevision())) {
        token.append(rev._number());
    }
    setToken(token.toString());
}
#end_block

#method_before
private void loadDiff(DiffObject base, RevisionInfo baseRev, RevisionInfo rev, Timestamp myLastReply, CallbackGroup group) {
    List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    loadFileList(base, baseRev, rev, myLastReply, group, comments, drafts);
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#method_after
private void loadDiff(DiffObject base, RevisionInfo baseRev, RevisionInfo rev, Timestamp myLastReply, CallbackGroup group) {
    List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    loadFileList(base, baseRev, rev, myLastReply, group, comments, drafts);
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(getProject().get(), changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void loadFileList(final DiffObject base, final RevisionInfo baseRev, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group, final List<NativeMap<JsArray<CommentInfo>>> comments, final List<NativeMap<JsArray<CommentInfo>>> drafts) {
    DiffApi.list(changeId.get(), rev.name(), baseRev, group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments != null ? comments.get(0) : null, drafts != null ? drafts.get(0) : null);
        }

        @Override
        public void onFailure(Throwable caught) {
            files.showError(caught);
        }
    }));
}
#method_after
private void loadFileList(final DiffObject base, final RevisionInfo baseRev, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group, final List<NativeMap<JsArray<CommentInfo>>> comments, final List<NativeMap<JsArray<CommentInfo>>> drafts) {
    DiffApi.list(getProject().get(), changeId.get(), rev.name(), baseRev, group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base, new PatchSet.Id(changeId, rev._number()), getProject(), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments != null ? comments.get(0) : null, drafts != null ? drafts.get(0) : null);
        }

        @Override
        public void onFailure(Throwable caught) {
            files.showError(caught);
        }
    }));
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadComments(final RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    // TODO(dborowitz): Could eliminate this call by adding an option to include
    // inline comments in the change detail.
    ChangeApi.comments(changeId.get()).get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            // Return value is used for populating the file table, so only count
            // comments for the current revision. Still include all comments in
            // the history table.
            r.add(filterForRevision(result, rev._number()));
            history.addComments(result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadComments(final RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    // TODO(dborowitz): Could eliminate this call by adding an option to include
    // inline comments in the change detail.
    ChangeApi.comments(getProject().get(), changeId.get()).get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            // Return value is used for populating the file table, so only count
            // comments for the current revision. Still include all comments in
            // the history table.
            r.add(filterForRevision(result, rev._number()));
            history.addComments(result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadDrafts(RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(changeId.get(), rev.name()).view("drafts").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                r.add(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    } else {
        r.add(NativeMap.<JsArray<CommentInfo>>create());
    }
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadDrafts(RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(getProject().get(), changeId.get(), rev.name()).view("drafts").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                r.add(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    } else {
        r.add(NativeMap.<JsArray<CommentInfo>>create());
    }
    return r;
}
#end_block

#method_before
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.isEdit() || rev.commit() != null) {
        return;
    }
    ChangeApi.commitWithLinks(changeId.get(), rev.name(), group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.setCommit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadCommit(RevisionInfo rev, CallbackGroup group) {
    if (rev.isEdit() || rev.commit() != null) {
        return;
    }
    ChangeApi.commitWithLinks(getProject().get(), changeId.get(), rev.name(), group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.setCommit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    RevisionInfo revisionInfo = info.revision(revision);
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderUploader(info, revisionInfo);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacyId()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.info().change().showAssignee()) {
        assignee.set(info);
    } else {
        setVisible(assigneeRow, false);
    }
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info, revision);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.idAbbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    // render it faster.
    if (!info.status().isOpen() || !revision.equals(info.currentRevision()) || revisionInfo.isEdit()) {
        setVisible(strategy, false);
    }
    // Properly render revision actions initially while waiting for
    // the callback to populate them correctly.
    NativeMap<ActionInfo> emptyMap = NativeMap.<ActionInfo>create();
    initRevisionsAction(info, revision);
    quickApprove.setVisible(false);
    actions.reloadRevisionActions(emptyMap);
    boolean current = revision.equals(info.currentRevision()) && !revisionInfo.isEdit();
    if (revisionInfo.isEdit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, hasDraftComments, style, commentLinkProcessor, reply, quickApprove);
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current && info.status().isOpen()) {
        quickApprove.set(info, revision, replyAction);
        renderSubmitType(info.status(), isSubmittable(info), info.submitType());
    } else {
        quickApprove.setVisible(false);
    }
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    RevisionInfo revisionInfo = info.revision(revision);
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderUploader(info, revisionInfo);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacyId()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    assignee.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info, revision);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.idAbbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    // render it faster.
    if (!info.status().isOpen() || !revision.equals(info.currentRevision()) || revisionInfo.isEdit()) {
        setVisible(strategy, false);
    }
    // Properly render revision actions initially while waiting for
    // the callback to populate them correctly.
    NativeMap<ActionInfo> emptyMap = NativeMap.<ActionInfo>create();
    initRevisionsAction(info, revision);
    quickApprove.setVisible(false);
    actions.reloadRevisionActions(emptyMap);
    boolean current = revision.equals(info.currentRevision()) && !revisionInfo.isEdit();
    if (revisionInfo.isEdit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    if (info.isPrivate()) {
        privateText.setInnerText(Util.C.isPrivate());
    }
    if (info.isWorkInProgress()) {
        wipText.setInnerText(Util.C.isWorkInProgress());
    }
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, hasDraftComments, style, commentLinkProcessor, reply, quickApprove);
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current && info.status().isOpen()) {
        quickApprove.set(info, revision, replyAction);
        renderSubmitType(info.status(), isSubmittable(info), info.submitType());
    } else {
        quickApprove.setVisible(false);
    }
}
#end_block

#method_before
void showUpdates(ChangeInfo newInfo) {
    if (!isAttached() || newInfo.updated().equals(lastDisplayedUpdate)) {
        return;
    }
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (updateAvailable == null) {
        updateAvailable = new UpdateAvailableBar() {

            @Override
            void onShow() {
                Gerrit.display(PageLinks.toChange(changeId));
            }

            @Override
            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
    }
    updateAvailable.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!updateAvailable.isAttached()) {
        add(updateAvailable);
    }
}
#method_after
void showUpdates(ChangeInfo newInfo) {
    if (!isAttached() || newInfo.updated().equals(lastDisplayedUpdate)) {
        return;
    }
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (om.length() == nm.length()) {
        return;
    }
    if (updateAvailable == null) {
        updateAvailable = new UpdateAvailableBar() {

            @Override
            void onShow() {
                Gerrit.display(PageLinks.toChange(project, changeId));
            }

            @Override
            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
    }
    updateAvailable.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!updateAvailable.isAttached()) {
        add(updateAvailable);
    }
}
#end_block

#method_before
public ChangeControl validateFor(ReviewDb db, ChangeNotes notes, CurrentUser user) throws OrmException {
    return controlFor(notes, user);
}
#method_after
public ChangeControl validateFor(Change.Id changeId, CurrentUser user) throws OrmException {
    return validateFor(notesFactory.createChecked(changeId), user);
}
#end_block

#method_before
public ChangeControl forUser(final CurrentUser who) {
    if (getUser().equals(who)) {
        return this;
    }
    return new ChangeControl(changeDataFactory, approvalsUtil, getRefControl().forUser(who), notes, patchSetUtil);
}
#method_after
public ChangeControl forUser(CurrentUser who) {
    if (getUser().equals(who)) {
        return this;
    }
    return new ChangeControl(changeDataFactory, approvalsUtil, getRefControl().forUser(who), notes, patchSetUtil);
}
#end_block

#method_before
public boolean isVisible(ReviewDb db) {
    return isVisible(db, null);
}
#method_after
public boolean isVisible(ReviewDb db) throws OrmException {
    return isVisible(db, null);
}
#end_block

#method_before
public boolean isVisible(ReviewDb db, @Nullable ChangeData cd) {
    return isRefVisible();
}
#method_after
private boolean isVisible(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getChange().isPrivate() && !isPrivateVisible(db, cd)) {
        return false;
    }
    return isRefVisible();
}
#end_block

#method_before
public boolean isPatchVisible(PatchSet ps, ChangeData cd) {
    checkArgument(cd.getId().equals(ps.getId().getParentKey()), "%s not for change %s", ps, cd.getId());
    return isVisible(cd.db());
}
#method_after
public boolean isPatchVisible(PatchSet ps, ChangeData cd) throws OrmException {
    // TODO(hiesel) These don't need to be migrated, just remove after support for drafts is removed
    checkArgument(cd.getId().equals(ps.getId().getParentKey()), "%s not for change %s", ps, cd.getId());
    return isVisible(cd.db());
}
#end_block

#method_before
public boolean canAbandon(ReviewDb db) throws OrmException {
    return (// owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getUser().getCapabilities().canAdministrateServer() || // user can abandon a specific ref
    getRefControl().canAbandon()) && !isPatchSetLocked(db);
}
#method_after
private boolean canAbandon(ReviewDb db) throws OrmException {
    return (// owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // user can abandon a specific ref
    getRefControl().canAbandon() || getProjectControl().isAdmin()) && !isPatchSetLocked(db);
}
#end_block

#method_before
public boolean canDelete(ReviewDb db, Change.Status status) {
    switch(status) {
        case NEW:
        case ABANDONED:
            return isAdmin();
        case MERGED:
        default:
            return false;
    }
}
#method_after
public boolean canDelete(Change.Status status) {
    switch(status) {
        case NEW:
        case ABANDONED:
            return (isOwner() && getRefControl().canDeleteOwnChanges()) || getProjectControl().isAdmin();
        case MERGED:
        default:
            return false;
    }
}
#end_block

#method_before
public boolean canRebase(ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canSubmit(isOwner()) || getRefControl().canRebase()) && !isPatchSetLocked(db);
}
#method_after
private boolean canRebase(ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canSubmit(isOwner()) || getRefControl().canRebase()) && refControl.asForRef().testOrFalse(RefPermission.CREATE_CHANGE) && !isPatchSetLocked(db);
}
#end_block

#method_before
public boolean canRestore(ReviewDb db) throws OrmException {
    return // Anyone who can abandon the change can restore it back
    canAbandon(db) && // as long as you can upload too
    getRefControl().canUpload();
}
#method_after
private boolean canRestore(ReviewDb db) throws OrmException {
    // Anyone who can abandon the change can restore it, as long as they can create changes.
    return canAbandon(db) && refControl.asForRef().testOrFalse(RefPermission.CREATE_CHANGE);
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    return getRefControl().getRange(permission, isOwner());
}
#method_after
private PermissionRange getRange(String permission) {
    return getRefControl().getRange(permission, isOwner());
}
#end_block

#method_before
public boolean canAddPatchSet(ReviewDb db) throws OrmException {
    if (!getRefControl().canUpload() || isPatchSetLocked(db)) {
        return false;
    }
    if (isOwner()) {
        return true;
    }
    return getRefControl().canAddPatchSet();
}
#method_after
private boolean canAddPatchSet(ReviewDb db) throws OrmException {
    if (!refControl.asForRef().testOrFalse(RefPermission.CREATE_CHANGE) || isPatchSetLocked(db)) {
        return false;
    }
    if (isOwner()) {
        return true;
    }
    return getRefControl().canAddPatchSet();
}
#end_block

#method_before
public boolean isPatchSetLocked(ReviewDb db) throws OrmException {
    if (getChange().getStatus() == Change.Status.MERGED) {
        return false;
    }
    for (PatchSetApproval ap : approvalsUtil.byPatchSet(db, this, getChange().currentPatchSetId())) {
        LabelType type = getLabelTypes().byLabel(ap.getLabel());
        if (type != null && ap.getValue() == 1 && type.getFunctionName().equalsIgnoreCase("PatchSetLock")) {
            return true;
        }
    }
    return false;
}
#method_after
boolean isPatchSetLocked(ReviewDb db) throws OrmException {
    if (getChange().getStatus() == Change.Status.MERGED) {
        return false;
    }
    for (PatchSetApproval ap : approvalsUtil.byPatchSet(db, getNotes(), getUser(), getChange().currentPatchSetId(), null, null)) {
        LabelType type = getProjectControl().getProjectState().getLabelTypes(getNotes(), getUser()).byLabel(ap.getLabel());
        if (type != null && ap.getValue() == 1 && type.getFunctionName().equalsIgnoreCase("PatchSetLock")) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public boolean isOwner() {
    if (getUser().isIdentifiedUser()) {
        Account.Id id = getUser().asIdentifiedUser().getAccountId();
        return id.equals(getChange().getOwner());
    }
    return false;
}
#method_after
private boolean isOwner() {
    if (getUser().isIdentifiedUser()) {
        Account.Id id = getUser().asIdentifiedUser().getAccountId();
        return id.equals(getChange().getOwner());
    }
    return false;
}
#end_block

#method_before
public boolean isAssignee() {
    Account.Id currentAssignee = notes.getChange().getAssignee();
    if (currentAssignee != null && getUser().isIdentifiedUser()) {
        Account.Id id = getUser().getAccountId();
        return id.equals(currentAssignee);
    }
    return false;
}
#method_after
private boolean isAssignee() {
    Account.Id currentAssignee = notes.getChange().getAssignee();
    if (currentAssignee != null && getUser().isIdentifiedUser()) {
        Account.Id id = getUser().getAccountId();
        return id.equals(currentAssignee);
    }
    return false;
}
#end_block

#method_before
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getUser().isIdentifiedUser()) {
        Collection<Account.Id> results = changeData(db, cd).reviewers().all();
        return results.contains(getUser().getAccountId());
    }
    return false;
}
#method_after
private boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getUser().isIdentifiedUser()) {
        Collection<Account.Id> results = changeData(db, cd).reviewers().all();
        return results.contains(getUser().getAccountId());
    }
    return false;
}
#end_block

#method_before
public boolean canEditTopicName() {
    if (getChange().getStatus().isOpen()) {
        return // owner (aka creator) of the change can edit topic
        isOwner() || // branch owner can edit topic
        getRefControl().isOwner() || // project owner can edit topic
        getProjectControl().isOwner() || // site administers are god
        getUser().getCapabilities().canAdministrateServer() || // user can edit topic on a specific ref
        getRefControl().canEditTopicName();
    }
    return getRefControl().canForceEditTopicName();
}
#method_after
private boolean canEditTopicName() {
    if (getChange().getStatus().isOpen()) {
        return // owner (aka creator) of the change can edit topic
        isOwner() || // branch owner can edit topic
        getRefControl().isOwner() || // project owner can edit topic
        getProjectControl().isOwner() || // user can edit topic on a specific ref
        getRefControl().canEditTopicName() || getProjectControl().isAdmin();
    }
    return getRefControl().canForceEditTopicName();
}
#end_block

#method_before
public boolean canEditDescription() {
    if (getChange().getStatus().isOpen()) {
        return // owner (aka creator) of the change can edit desc
        isOwner() || // branch owner can edit desc
        getRefControl().isOwner() || // project owner can edit desc
        getProjectControl().isOwner() || // site administers are god
        getUser().getCapabilities().canAdministrateServer();
    }
    return false;
}
#method_after
private boolean canEditDescription() {
    if (getChange().getStatus().isOpen()) {
        return // owner (aka creator) of the change can edit desc
        isOwner() || // branch owner can edit desc
        getRefControl().isOwner() || // project owner can edit desc
        getProjectControl().isOwner() || getProjectControl().isAdmin();
    }
    return false;
}
#end_block

#method_before
public boolean canEditAssignee() {
    return isOwner() || getProjectControl().isOwner() || getRefControl().canEditAssignee() || isAssignee();
}
#method_after
private boolean canEditAssignee() {
    return isOwner() || getProjectControl().isOwner() || getRefControl().canEditAssignee() || isAssignee();
}
#end_block

#method_before
public boolean canEditHashtags() {
    return // owner (aka creator) of the change can edit hashtags
    isOwner() || // branch owner can edit hashtags
    getRefControl().isOwner() || // project owner can edit hashtags
    getProjectControl().isOwner() || // site administers are god
    getUser().getCapabilities().canAdministrateServer() || // user can edit hashtag on a specific ref
    getRefControl().canEditHashtags();
}
#method_after
private boolean canEditHashtags() {
    return // owner (aka creator) of the change can edit hashtags
    isOwner() || // branch owner can edit hashtags
    getRefControl().isOwner() || // project owner can edit hashtags
    getProjectControl().isOwner() || // user can edit hashtag on a specific ref
    getRefControl().canEditHashtags() || getProjectControl().isAdmin();
}
#end_block

#method_before
private ChangeData changeData(ReviewDb db, @Nullable ChangeData cd) {
    return cd != null ? cd : changeDataFactory.create(db, this);
}
#method_after
private ChangeData changeData(ReviewDb db, @Nullable ChangeData cd) {
    return cd != null ? cd : changeDataFactory.create(db, getNotes());
}
#end_block

#method_before
public Change abandon(ChangeControl control, String msgTxt, NotifyHandling notifyHandling, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws RestApiException, UpdateException {
    CurrentUser user = control.getUser();
    Account account = user.isIdentifiedUser() ? user.asIdentifiedUser().getAccount() : null;
    AbandonOp op = abandonOpFactory.create(account, msgTxt, notifyHandling, accountsToNotify);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return op.getChange();
}
#method_after
public Change abandon(BatchUpdate.Factory updateFactory, ChangeNotes notes, CurrentUser user) throws RestApiException, UpdateException {
    return abandon(updateFactory, notes, user, "", defaultNotify(notes.getChange()), ImmutableListMultimap.of());
}
#end_block

#method_before
public void batchAbandon(Project.NameKey project, CurrentUser user, Collection<ChangeControl> controls) throws RestApiException, UpdateException {
    batchAbandon(project, user, controls, "", NotifyHandling.ALL, ImmutableListMultimap.of());
}
#method_after
public void batchAbandon(BatchUpdate.Factory updateFactory, Project.NameKey project, CurrentUser user, Collection<ChangeData> changes, String msgTxt, NotifyHandling notifyHandling, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws RestApiException, UpdateException {
    if (changes.isEmpty()) {
        return;
    }
    Account account = user.isIdentifiedUser() ? user.asIdentifiedUser().getAccount() : null;
    try (BatchUpdate u = updateFactory.create(dbProvider.get(), project, user, TimeUtil.nowTs())) {
        for (ChangeData change : changes) {
            if (!project.equals(change.project())) {
                throw new ResourceConflictException(String.format("Project name \"%s\" doesn't match \"%s\"", change.project().get(), project.get()));
            }
            u.addOp(change.getId(), abandonOpFactory.create(account, msgTxt, notifyHandling, accountsToNotify));
        }
        u.execute();
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(ChangeResource resource) {
    boolean canAbandon = false;
    try {
        canAbandon = resource.getControl().canAbandon(dbProvider.get());
    } catch (OrmException e) {
        log.error("Cannot check canAbandon status. Assuming false.", e);
    }
    return new UiAction.Description().setLabel("Abandon").setTitle("Abandon the change").setVisible(resource.getChange().getStatus().isOpen() && canAbandon);
}
#method_after
@Override
public UiAction.Description getDescription(ChangeResource rsrc) {
    Change change = rsrc.getChange();
    return new UiAction.Description().setLabel("Abandon").setTitle("Abandon the change").setVisible(and(change.getStatus().isOpen(), rsrc.permissions().database(dbProvider).testCond(ChangePermission.ABANDON)));
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, RepositoryNotFoundException, IOException {
    change = ctx.getChange();
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("Change is " + status(change));
    }
    Project.NameKey projectKey = change.getProject();
    newDestKey = new Branch.NameKey(projectKey, input.destinationBranch);
    Branch.NameKey changePrevDest = change.getDest();
    if (changePrevDest.equals(newDestKey)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    try (Repository repo = repoManager.openRepository(projectKey);
        RevWalk revWalk = new RevWalk(repo)) {
        RevCommit currPatchsetRevCommit = revWalk.parseCommit(ObjectId.fromString(psUtil.current(ctx.getDb(), ctx.getNotes()).getRevision().get()));
        if (currPatchsetRevCommit.getParentCount() > 1) {
            throw new ResourceConflictException("Merge commit cannot be moved");
        }
        ObjectId refId = repo.resolve(input.destinationBranch);
        // Check if destination ref exists in project repo
        if (refId == null) {
            throw new ResourceConflictException("Destination " + input.destinationBranch + " not found in the project");
        }
        RevCommit refCommit = revWalk.parseCommit(refId);
        if (revWalk.isMergedInto(currPatchsetRevCommit, refCommit)) {
            throw new ResourceConflictException("Current patchset revision is reachable from tip of " + input.destinationBranch);
        }
    }
    Change.Key changeKey = change.getKey();
    if (!asChanges(queryProvider.get().byBranchKey(newDestKey, changeKey)).isEmpty()) {
        throw new ResourceConflictException("Destination " + newDestKey.getShortName() + " has a different change with same change key " + changeKey);
    }
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new ResourceConflictException("Patch set is not current");
    }
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    update.setBranch(newDestKey.get());
    change.setDest(newDestKey);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change destination moved from ");
    msgBuf.append(changePrevDest.getShortName());
    msgBuf.append(" to ");
    msgBuf.append(newDestKey.getShortName());
    if (!Strings.isNullOrEmpty(input.message)) {
        msgBuf.append("\n\n");
        msgBuf.append(input.message);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msgBuf.toString(), ChangeMessagesUtil.TAG_MOVE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, RepositoryNotFoundException, IOException {
    change = ctx.getChange();
    if (change.getStatus() != Status.NEW) {
        throw new ResourceConflictException("Change is " + ChangeUtil.status(change));
    }
    Project.NameKey projectKey = change.getProject();
    newDestKey = new Branch.NameKey(projectKey, input.destinationBranch);
    Branch.NameKey changePrevDest = change.getDest();
    if (changePrevDest.equals(newDestKey)) {
        throw new ResourceConflictException("Change is already destined for the specified branch");
    }
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    try (Repository repo = repoManager.openRepository(projectKey);
        RevWalk revWalk = new RevWalk(repo)) {
        RevCommit currPatchsetRevCommit = revWalk.parseCommit(ObjectId.fromString(psUtil.current(ctx.getDb(), ctx.getNotes()).getRevision().get()));
        if (currPatchsetRevCommit.getParentCount() > 1) {
            throw new ResourceConflictException("Merge commit cannot be moved");
        }
        ObjectId refId = repo.resolve(input.destinationBranch);
        // Check if destination ref exists in project repo
        if (refId == null) {
            throw new ResourceConflictException("Destination " + input.destinationBranch + " not found in the project");
        }
        RevCommit refCommit = revWalk.parseCommit(refId);
        if (revWalk.isMergedInto(currPatchsetRevCommit, refCommit)) {
            throw new ResourceConflictException("Current patchset revision is reachable from tip of " + input.destinationBranch);
        }
    }
    Change.Key changeKey = change.getKey();
    if (!asChanges(queryProvider.get().byBranchKey(newDestKey, changeKey)).isEmpty()) {
        throw new ResourceConflictException("Destination " + newDestKey.getShortName() + " has a different change with same change key " + changeKey);
    }
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new ResourceConflictException("Patch set is not current");
    }
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    update.setBranch(newDestKey.get());
    change.setDest(newDestKey);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change destination moved from ");
    msgBuf.append(changePrevDest.getShortName());
    msgBuf.append(" to ");
    msgBuf.append(newDestKey.getShortName());
    if (!Strings.isNullOrEmpty(input.message)) {
        msgBuf.append("\n\n");
        msgBuf.append(input.message);
    }
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx, msgBuf.toString(), ChangeMessagesUtil.TAG_MOVE);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#end_block

#method_before
@Before
public void assumeSshIfRequired() {
    if (useSsh) {
        // If the test uses ssh, we use assume() to make sure ssh is enabled on
        // the test suite. JUnit will skip tests annotated with @UseSsh if we
        // disable them using the command line flag.
        assume().that(SshMode.useSsh()).isTrue();
    }
}
#method_after
@Before
public void assumeSshIfRequired() {
    if (testRequiresSsh) {
        // If the test uses ssh, we use assume() to make sure ssh is enabled on
        // the test suite. JUnit will skip tests annotated with @UseSsh if we
        // disable them using the command line flag.
        assume().that(SshMode.useSsh()).isTrue();
    }
}
#end_block

#method_before
@AfterClass
public static void stopCommonServer() throws Exception {
    if (commonServer != null) {
        try {
            commonServer.stop();
        } finally {
            commonServer = null;
        }
    }
    TempFileUtil.cleanup();
}
#method_after
@AfterClass
public static void stopCommonServer() throws Exception {
    if (commonServer != null) {
        try {
            commonServer.close();
        } catch (Throwable t) {
            throw new AssertionError("Error stopping common server in " + (firstTest != null ? firstTest.getTestClass().getName() : "unknown test class"), t);
        } finally {
            commonServer = null;
        }
    }
    TempFileUtil.cleanup();
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    notesMigration.setFromEnv();
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    db = reviewDbProvider.open();
    if (classDesc.useSsh() || methodDesc.useSsh()) {
        useSsh = true;
        if (SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
            // Create Ssh sessions
            initSsh(admin);
            Context ctx = newRequestContext(user);
            atrScope.set(ctx);
            userSshSession = ctx.getSession();
            userSshSession.open();
            ctx = newRequestContext(admin);
            atrScope.set(ctx);
            adminSshSession = ctx.getSession();
            adminSshSession.open();
        }
    } else {
        useSsh = false;
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    this.description = description;
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setInt("receive", null, "changeUpdateThreads", 4);
    if (classDesc.equals(methodDesc) && !classDesc.sandboxed() && !methodDesc.sandboxed()) {
        if (commonServer == null) {
            commonServer = GerritServer.initAndStart(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.initAndStart(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    db = reviewDbProvider.open();
    // As a workaround, we simply reindex all available groups here.
    for (AccountGroup group : groups.getAll(db).collect(toList())) {
        groupCache.evict(group.getGroupUUID(), group.getId(), group.getNameKey());
    }
    admin = accountCreator.admin();
    user = accountCreator.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminRestSession = new RestSession(server, admin);
    userRestSession = new RestSession(server, user);
    testRequiresSsh = classDesc.useSshAnnotation() || methodDesc.useSshAnnotation();
    if (testRequiresSsh && SshMode.useSsh() && (adminSshSession == null || userSshSession == null)) {
        // Create Ssh sessions
        initSsh(admin);
        Context ctx = newRequestContext(user);
        atrScope.set(ctx);
        userSshSession = ctx.getSession();
        userSshSession.open();
        ctx = newRequestContext(admin);
        atrScope.set(ctx);
        adminSshSession = ctx.getSession();
        adminSshSession.open();
    }
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
private TestAccount getCloneAsAccount(Description description) {
    TestProjectInput ann = description.getAnnotation(TestProjectInput.class);
    return accounts.get(ann != null ? ann.cloneAs() : "admin");
}
#method_after
private TestAccount getCloneAsAccount(Description description) {
    TestProjectInput ann = description.getAnnotation(TestProjectInput.class);
    return accountCreator.get(ann != null ? ann.cloneAs() : "admin");
}
#end_block

#method_before
protected TestRepository<InMemoryRepository> cloneProject(Project.NameKey p, TestAccount testAccount) throws Exception {
    InProcessProtocol.Context ctx = new InProcessProtocol.Context(reviewDbProvider, identifiedUserFactory, testAccount.getId(), p);
    Repository repo = repoManager.openRepository(p);
    toClose.add(repo);
    return GitUtil.cloneProject(p, inProcessProtocol.register(ctx, repo).toString());
}
#method_after
protected TestRepository<InMemoryRepository> cloneProject(Project.NameKey p, TestAccount testAccount) throws Exception {
    return GitUtil.cloneProject(p, registerRepoConnection(p, testAccount));
}
#end_block

#method_before
private void afterTest() throws Exception {
    Transport.unregister(inProcessProtocol);
    for (Repository repo : toClose) {
        repo.close();
    }
    db.close();
    if (adminSshSession != null) {
        adminSshSession.close();
    }
    if (userSshSession != null) {
        userSshSession.close();
    }
    if (server != commonServer) {
        server.stop();
    }
}
#method_after
protected void afterTest() throws Exception {
    Transport.unregister(inProcessProtocol);
    for (Repository repo : toClose) {
        repo.close();
    }
    db.close();
    if (adminSshSession != null) {
        adminSshSession.close();
    }
    if (userSshSession != null) {
        userSshSession.close();
    }
    if (server != commonServer) {
        server.close();
        server = null;
    }
    NoteDbMode.resetFromEnv(notesMigration);
}
#end_block

#method_before
protected PushOneCommit.Result amendChange(String changeId, String ref, TestAccount testAccount, TestRepository<?> repo) throws Exception {
    Collections.shuffle(RANDOM);
    PushOneCommit push = pushFactory.create(db, testAccount.getIdent(), repo, PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, new String(Chars.toArray(RANDOM)), changeId);
    return push.to(ref);
}
#method_after
protected PushOneCommit.Result amendChange(String changeId, String ref, TestAccount testAccount, TestRepository<?> repo) throws Exception {
    Collections.shuffle(RANDOM);
    return amendChange(changeId, ref, testAccount, repo, PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, new String(Chars.toArray(RANDOM)));
}
#end_block

#method_before
protected PushOneCommit.Result amendChange(String changeId, String ref, TestAccount testAccount, TestRepository<?> repo) throws Exception {
    Collections.shuffle(RANDOM);
    PushOneCommit push = pushFactory.create(db, testAccount.getIdent(), repo, PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, new String(Chars.toArray(RANDOM)), changeId);
    return push.to(ref);
}
#method_after
protected PushOneCommit.Result amendChange(String changeId, String subject, String fileName, String content) throws Exception {
    return amendChange(changeId, "refs/for/master", admin, testRepo, subject, fileName, content);
}
#end_block

#method_before
protected ChangeInfo get(String id, ListChangesOption... options) throws RestApiException {
    return gApi.changes().id(id).get(Sets.newEnumSet(Arrays.asList(options), ListChangesOption.class));
}
#method_after
protected ChangeInfo get(String id, ListChangesOption... options) throws RestApiException {
    return gApi.changes().id(id).get(options);
}
#end_block

#method_before
protected Context disableDb() {
    notesMigration.setFailOnLoad(true);
    return atrScope.disableDb();
}
#method_after
protected Context disableDb() {
    notesMigration.setFailOnLoadForTest(true);
    return atrScope.disableDb();
}
#end_block

#method_before
protected void enableDb(Context preDisableContext) {
    notesMigration.setFailOnLoad(false);
    atrScope.set(preDisableContext);
}
#method_after
protected void enableDb(Context preDisableContext) {
    notesMigration.setFailOnLoadForTest(false);
    atrScope.set(preDisableContext);
}
#end_block

#method_before
protected void allow(String permission, AccountGroup.UUID id, String ref) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.allow(cfg, permission, id, ref);
    saveProjectConfig(project, cfg);
}
#method_after
protected void allow(String ref, String permission, AccountGroup.UUID id) throws Exception {
    allow(project, ref, permission, id);
}
#end_block

#method_before
protected void deny(Project.NameKey p, String permission, AccountGroup.UUID id, String ref) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.deny(cfg, permission, id, ref);
    saveProjectConfig(p, cfg);
}
#method_after
protected void deny(String ref, String permission, AccountGroup.UUID id) throws Exception {
    deny(project, ref, permission, id);
}
#end_block

#method_before
protected PermissionRule block(String permission, AccountGroup.UUID id, String ref, Project.NameKey project) throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    PermissionRule rule = Util.block(cfg, permission, id, ref);
    saveProjectConfig(project, cfg);
    return rule;
}
#method_after
protected PermissionRule block(String ref, String permission, AccountGroup.UUID id) throws Exception {
    return block(project, ref, permission, id);
}
#end_block

#method_before
protected void grant(String permission, Project.NameKey project, String ref, boolean force, AccountGroup.UUID groupUUID) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        md.setMessage(String.format("Grant %s on %s", permission, ref));
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection s = config.getAccessSection(ref, true);
        Permission p = s.getPermission(permission, true);
        PermissionRule rule = Util.newRule(config, groupUUID);
        rule.setForce(force);
        p.add(rule);
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#method_after
protected void grant(Project.NameKey project, String ref, String permission) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    grant(project, ref, permission, false);
}
#end_block

#method_before
protected void removePermission(String permission, Project.NameKey project, String ref) throws IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        md.setMessage(String.format("Remove %s on %s", permission, ref));
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection s = config.getAccessSection(ref, true);
        Permission p = s.getPermission(permission, true);
        p.getRules().clear();
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#method_after
protected void removePermission(Project.NameKey project, String ref, String permission) throws IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        md.setMessage(String.format("Remove %s on %s", permission, ref));
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection s = config.getAccessSection(ref, true);
        Permission p = s.getPermission(permission, true);
        p.getRules().clear();
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#end_block

#method_before
protected void blockRead(String ref) throws Exception {
    block(Permission.READ, REGISTERED_USERS, ref);
}
#method_after
protected void blockRead(String ref) throws Exception {
    block(ref, Permission.READ, REGISTERED_USERS);
}
#end_block

#method_before
protected ChangeResource parseChangeResource(String changeId) throws Exception {
    List<ChangeControl> ctls = changeFinder.find(changeId, atrScope.get().getUser());
    assertThat(ctls).hasSize(1);
    return changeResourceFactory.create(ctls.get(0));
}
#method_after
protected ChangeResource parseChangeResource(String changeId) throws Exception {
    List<ChangeNotes> notes = changeFinder.find(changeId);
    assertThat(notes).hasSize(1);
    return changeResourceFactory.create(notes.get(0), atrScope.get().getUser());
}
#end_block

#method_before
protected void grantTagPermissions() throws Exception {
    grant(Permission.CREATE, project, R_TAGS + "*");
    grant(Permission.CREATE_TAG, project, R_TAGS + "*");
    grant(Permission.CREATE_SIGNED_TAG, project, R_TAGS + "*");
}
#method_after
protected void grantTagPermissions() throws Exception {
    grant(project, R_TAGS + "*", Permission.CREATE);
    grant(project, R_TAGS + "", Permission.DELETE);
    grant(project, R_TAGS + "*", Permission.CREATE_TAG);
    grant(project, R_TAGS + "*", Permission.CREATE_SIGNED_TAG);
}
#end_block

#method_before
protected ContributorAgreement configureContributorAgreement(boolean autoVerify) throws Exception {
    ContributorAgreement ca;
    if (autoVerify) {
        String g = createGroup("cla-test-group");
        GroupApi groupApi = gApi.groups().id(g);
        groupApi.description("CLA test group");
        AccountGroup caGroup = groupCache.get(new AccountGroup.UUID(groupApi.detail().id));
        GroupReference groupRef = GroupReference.forGroup(caGroup);
        PermissionRule rule = new PermissionRule(groupRef);
        rule.setAction(PermissionRule.Action.ALLOW);
        ca = new ContributorAgreement("cla-test");
        ca.setAutoVerify(groupRef);
        ca.setAccepted(ImmutableList.of(rule));
    } else {
        ca = new ContributorAgreement("cla-test-no-auto-verify");
    }
    ca.setDescription("description");
    ca.setAgreementUrl("agreement-url");
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    cfg.replace(ca);
    saveProjectConfig(allProjects, cfg);
    return ca;
}
#method_after
protected ContributorAgreement configureContributorAgreement(boolean autoVerify) throws Exception {
    ContributorAgreement ca;
    if (autoVerify) {
        String g = createGroup("cla-test-group");
        GroupApi groupApi = gApi.groups().id(g);
        groupApi.description("CLA test group");
        InternalGroup caGroup = groupCache.get(new AccountGroup.UUID(groupApi.detail().id)).orElse(null);
        GroupReference groupRef = new GroupReference(caGroup.getGroupUUID(), caGroup.getName());
        PermissionRule rule = new PermissionRule(groupRef);
        rule.setAction(PermissionRule.Action.ALLOW);
        ca = new ContributorAgreement("cla-test");
        ca.setAutoVerify(groupRef);
        ca.setAccepted(ImmutableList.of(rule));
    } else {
        ca = new ContributorAgreement("cla-test-no-auto-verify");
    }
    ca.setDescription("description");
    ca.setAgreementUrl("agreement-url");
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    cfg.replace(ca);
    saveProjectConfig(allProjects, cfg);
    return ca;
}
#end_block

#method_before
protected Map<Branch.NameKey, RevTree> fetchFromBundles(BinaryResult bundles) throws Exception {
    assertThat(bundles.getContentType()).isEqualTo("application/x-zip");
    File tempfile = File.createTempFile("test", null);
    bundles.writeTo(new FileOutputStream(tempfile));
    Map<Branch.NameKey, RevTree> ret = new HashMap<>();
    try (ZipFile readback = new ZipFile(tempfile)) {
        for (ZipEntry entry : ImmutableList.copyOf(Iterators.forEnumeration(readback.entries()))) {
            String bundleName = entry.getName();
            InputStream bundleStream = readback.getInputStream(entry);
            int len = bundleName.length();
            assertThat(bundleName).endsWith(".git");
            String repoName = bundleName.substring(0, len - 4);
            Project.NameKey proj = new Project.NameKey(repoName);
            TestRepository<?> localRepo = cloneProject(proj);
            try (TransportBundleStream tbs = new TransportBundleStream(localRepo.getRepository(), new URIish(bundleName), bundleStream)) {
                FetchResult fr = tbs.fetch(NullProgressMonitor.INSTANCE, Arrays.asList(new RefSpec("refs/*:refs/preview/*")));
                for (Ref r : fr.getAdvertisedRefs()) {
                    String branchName = r.getName();
                    Branch.NameKey n = new Branch.NameKey(proj, branchName);
                    RevCommit c = localRepo.getRevWalk().parseCommit(r.getObjectId());
                    ret.put(n, c.getTree());
                }
            }
        }
    }
    return ret;
}
#method_after
protected Map<Branch.NameKey, ObjectId> fetchFromBundles(BinaryResult bundles) throws Exception {
    assertThat(bundles.getContentType()).isEqualTo("application/x-zip");
    FileSystem fs = Jimfs.newFileSystem();
    Path previewPath = fs.getPath("preview.zip");
    try (OutputStream out = Files.newOutputStream(previewPath)) {
        bundles.writeTo(out);
    }
    Map<Branch.NameKey, ObjectId> ret = new HashMap<>();
    try (FileSystem zipFs = FileSystems.newFileSystem(previewPath, null);
        DirectoryStream<Path> dirStream = Files.newDirectoryStream(Iterables.getOnlyElement(zipFs.getRootDirectories()))) {
        for (Path p : dirStream) {
            if (!Files.isRegularFile(p)) {
                continue;
            }
            String bundleName = p.getFileName().toString();
            int len = bundleName.length();
            assertThat(bundleName).endsWith(".git");
            String repoName = bundleName.substring(0, len - 4);
            Project.NameKey proj = new Project.NameKey(repoName);
            TestRepository<?> localRepo = cloneProject(proj);
            try (InputStream bundleStream = Files.newInputStream(p);
                TransportBundleStream tbs = new TransportBundleStream(localRepo.getRepository(), new URIish(bundleName), bundleStream)) {
                FetchResult fr = tbs.fetch(NullProgressMonitor.INSTANCE, Arrays.asList(new RefSpec("refs/*:refs/preview/*")));
                for (Ref r : fr.getAdvertisedRefs()) {
                    String refName = r.getName();
                    if (RefNames.isNoteDbMetaRef(refName)) {
                        continue;
                    }
                    RevCommit c = localRepo.getRevWalk().parseCommit(r.getObjectId());
                    ret.put(new Branch.NameKey(proj, refName), c.getTree().copy());
                }
            }
        }
    }
    assertThat(ret).isNotEmpty();
    return ret;
}
#end_block

#method_before
protected TestRepository<?> createProjectWithPush(String name, @Nullable Project.NameKey parent, SubmitType submitType) throws Exception {
    Project.NameKey project = createProject(name, parent, true, submitType);
    grant(Permission.PUSH, project, "refs/heads/*");
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/*");
    return cloneProject(project);
}
#method_after
protected TestRepository<?> createProjectWithPush(String name, @Nullable Project.NameKey parent, SubmitType submitType) throws Exception {
    Project.NameKey project = createProject(name, parent, true, submitType);
    grant(project, "refs/heads/*", Permission.PUSH);
    grant(project, "refs/for/refs/heads/*", Permission.SUBMIT);
    return cloneProject(project);
}
#end_block

#method_before
protected void assertNotifyTo(TestAccount expected) {
    assertThat(sender.getMessages()).hasSize(1);
    Message m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(expected.emailAddress);
    assertThat(((EmailHeader.AddressList) m.headers().get("To")).getAddressList()).containsExactly(expected.emailAddress);
    assertThat(m.headers().get("CC").isEmpty()).isTrue();
}
#method_after
protected void assertNotifyTo(TestAccount expected) {
    assertNotifyTo(expected.emailAddress);
}
#end_block

#method_before
protected void assertNotifyTo(TestAccount expected) {
    assertThat(sender.getMessages()).hasSize(1);
    Message m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(expected.emailAddress);
    assertThat(((EmailHeader.AddressList) m.headers().get("To")).getAddressList()).containsExactly(expected.emailAddress);
    assertThat(m.headers().get("CC").isEmpty()).isTrue();
}
#method_after
protected void assertNotifyTo(Address expected) {
    assertThat(sender.getMessages()).hasSize(1);
    Message m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(expected);
    assertThat(((EmailHeader.AddressList) m.headers().get("To")).getAddressList()).containsExactly(expected);
    assertThat(m.headers().get("CC").isEmpty()).isTrue();
}
#end_block

#method_before
protected void assertNotifyCc(TestAccount expected) {
    assertThat(sender.getMessages()).hasSize(1);
    Message m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(expected.emailAddress);
    assertThat(m.headers().get("To").isEmpty()).isTrue();
    assertThat(((EmailHeader.AddressList) m.headers().get("CC")).getAddressList()).containsExactly(expected.emailAddress);
}
#method_after
protected void assertNotifyCc(TestAccount expected) {
    assertNotifyCc(expected.emailAddress);
}
#end_block

#method_before
protected void assertNotifyCc(TestAccount expected) {
    assertThat(sender.getMessages()).hasSize(1);
    Message m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(expected.emailAddress);
    assertThat(m.headers().get("To").isEmpty()).isTrue();
    assertThat(((EmailHeader.AddressList) m.headers().get("CC")).getAddressList()).containsExactly(expected.emailAddress);
}
#method_after
protected void assertNotifyCc(Address expected) {
    assertThat(sender.getMessages()).hasSize(1);
    Message m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(expected);
    assertThat(m.headers().get("To").isEmpty()).isTrue();
    assertThat(((EmailHeader.AddressList) m.headers().get("CC")).getAddressList()).containsExactly(expected);
}
#end_block

#method_before
protected void watch(String project, String filter) throws RestApiException {
    List<ProjectWatchInfo> projectsToWatch = new ArrayList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = project;
    pwi.filter = filter;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
}
#method_after
protected void watch(String project, ProjectWatchInfoConfiguration config) throws RestApiException {
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = project;
    config.configure(pwi);
    gApi.accounts().self().setWatchedProjects(ImmutableList.of(pwi));
}
#end_block

#method_before
protected void watch(String project, String filter) throws RestApiException {
    List<ProjectWatchInfo> projectsToWatch = new ArrayList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = project;
    pwi.filter = filter;
    pwi.notifyAbandonedChanges = true;
    pwi.notifyNewChanges = true;
    pwi.notifyAllComments = true;
    projectsToWatch.add(pwi);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
}
#method_after
protected void watch(String project, String filter) throws RestApiException {
    watch(project, pwi -> {
        pwi.filter = filter;
        pwi.notifyAbandonedChanges = true;
        pwi.notifyNewChanges = true;
        pwi.notifyAllComments = true;
    });
}
#end_block

#method_before
public ChangeAttribute asChangeAttribute(ReviewDb db, Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().get();
    a.subject = change.getSubject();
    try {
        a.commitMessage = changeDataFactory.create(db, change).commitMessage();
    } catch (Exception e) {
        log.error("Error while getting full commit message for" + " change " + a.number);
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.assignee = asAccountAttribute(change.getAssignee());
    a.status = change.getStatus();
    return a;
}
#method_after
public ChangeAttribute asChangeAttribute(ReviewDb db, Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().get();
    a.subject = change.getSubject();
    try {
        a.commitMessage = changeDataFactory.create(db, change).commitMessage();
    } catch (Exception e) {
        log.error("Error while getting full commit message for change " + a.number);
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.assignee = asAccountAttribute(change.getAssignee());
    a.status = change.getStatus();
    return a;
}
#end_block

#method_before
private void addNeededBy(RevWalk rw, ChangeAttribute ca, Change change, PatchSet currentPs) throws OrmException, IOException {
    if (currentPs.getGroups().isEmpty()) {
        return;
    }
    String rev = currentPs.getRevision().get();
    // set whose parent matches this patch set's revision.
    for (ChangeData cd : queryProvider.get().byProjectGroups(change.getProject(), currentPs.getGroups())) {
        patchSets: for (PatchSet ps : cd.patchSets()) {
            RevCommit commit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
            for (RevCommit p : commit.getParents()) {
                if (!p.name().equals(rev)) {
                    continue;
                }
                ca.neededBy.add(newNeededBy(checkNotNull(cd.change()), ps));
                continue patchSets;
            }
        }
    }
}
#method_after
private void addNeededBy(RevWalk rw, ChangeAttribute ca, Change change, PatchSet currentPs) throws OrmException, IOException {
    if (currentPs.getGroups().isEmpty()) {
        return;
    }
    String rev = currentPs.getRevision().get();
    // set whose parent matches this patch set's revision.
    for (ChangeData cd : queryProvider.get().byProjectGroups(change.getProject(), currentPs.getGroups())) {
        PATCH_SETS: for (PatchSet ps : cd.patchSets()) {
            RevCommit commit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
            for (RevCommit p : commit.getParents()) {
                if (!p.name().equals(rev)) {
                    continue;
                }
                ca.neededBy.add(newNeededBy(checkNotNull(cd.change()), ps));
                continue PATCH_SETS;
            }
        }
    }
}
#end_block

#method_before
public PatchSetAttribute asPatchSetAttribute(ReviewDb db, RevWalk revWalk, Change change, PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = patchSet.getPatchSetId();
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    PatchSet.Id pId = patchSet.getId();
    try {
        p.parents = new ArrayList<>();
        RevCommit c = revWalk.parseCommit(ObjectId.fromString(p.revision));
        for (RevCommit parent : c.getParents()) {
            p.parents.add(parent.name());
        }
        UserIdentity author = toUserIdentity(c.getAuthorIdent());
        if (author.getAccount() == null) {
            p.author = new AccountAttribute();
            p.author.email = author.getEmail();
            p.author.name = author.getName();
            p.author.username = "";
        } else {
            p.author = asAccountAttribute(author.getAccount());
        }
        List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
        for (Patch pe : list) {
            if (!Patch.isMagic(pe.getFileName())) {
                p.sizeDeletions -= pe.getDeletions();
                p.sizeInsertions += pe.getInsertions();
            }
        }
        p.kind = changeKindCache.getChangeKind(db, change, patchSet);
    } catch (IOException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#method_after
public PatchSetAttribute asPatchSetAttribute(ReviewDb db, RevWalk revWalk, Change change, PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = patchSet.getPatchSetId();
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    PatchSet.Id pId = patchSet.getId();
    try {
        p.parents = new ArrayList<>();
        RevCommit c = revWalk.parseCommit(ObjectId.fromString(p.revision));
        for (RevCommit parent : c.getParents()) {
            p.parents.add(parent.name());
        }
        UserIdentity author = toUserIdentity(c.getAuthorIdent());
        if (author.getAccount() == null) {
            p.author = new AccountAttribute();
            p.author.email = author.getEmail();
            p.author.name = author.getName();
            p.author.username = "";
        } else {
            p.author = asAccountAttribute(author.getAccount());
        }
        List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
        for (Patch pe : list) {
            if (!Patch.isMagic(pe.getFileName())) {
                p.sizeDeletions -= pe.getDeletions();
                p.sizeInsertions += pe.getInsertions();
            }
        }
        p.kind = changeKindCache.getChangeKind(db, change, patchSet);
    } catch (IOException | OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#end_block

#method_before
// TODO: The same method exists in PatchSetInfoFactory, find a common place
private UserIdentity toUserIdentity(PersonIdent who) {
    UserIdentity u = new UserIdentity();
    u.setName(who.getName());
    u.setEmail(who.getEmailAddress());
    u.setDate(new Timestamp(who.getWhen().getTime()));
    u.setTimeZone(who.getTimeZoneOffset());
    // If only one account has access to this email address, select it
    // as the identity of the user.
    // 
    Set<Account.Id> a = byEmailCache.get(u.getEmail());
    if (a.size() == 1) {
        u.setAccount(a.iterator().next());
    }
    return u;
}
#method_after
// TODO: The same method exists in PatchSetInfoFactory, find a common place
private UserIdentity toUserIdentity(PersonIdent who) throws IOException, OrmException {
    UserIdentity u = new UserIdentity();
    u.setName(who.getName());
    u.setEmail(who.getEmailAddress());
    u.setDate(new Timestamp(who.getWhen().getTime()));
    u.setTimeZone(who.getTimeZoneOffset());
    // If only one account has access to this email address, select it
    // as the identity of the user.
    // 
    Set<Account.Id> a = emails.getAccountFor(u.getEmail());
    if (a.size() == 1) {
        u.setAccount(a.iterator().next());
    }
    return u;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    admins = groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID();
    setUpPermissions();
    setUpChanges();
}
#method_after
@Before
public void setUp() throws Exception {
    admins = groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID();
    setUpPermissions();
    setUpChanges();
}
#end_block

#method_before
private void setUpChanges() throws Exception {
    gApi.projects().name(project.get()).branch("branch").create(new BranchInput());
    // First 2 changes are merged, which means the tags pointing to them are
    // visible.
    allow(Permission.SUBMIT, admins, "refs/for/refs/heads/*");
    PushOneCommit.Result mr = pushFactory.create(db, admin.getIdent(), testRepo).to("refs/for/master%submit");
    mr.assertOkStatus();
    c1 = mr.getChange();
    r1 = changeRefPrefix(c1.getId());
    PushOneCommit.Result br = pushFactory.create(db, admin.getIdent(), testRepo).to("refs/for/branch%submit");
    br.assertOkStatus();
    c2 = br.getChange();
    r2 = changeRefPrefix(c2.getId());
    // Second 2 changes are unmerged.
    mr = pushFactory.create(db, admin.getIdent(), testRepo).to("refs/for/master");
    mr.assertOkStatus();
    c3 = mr.getChange();
    r3 = changeRefPrefix(c3.getId());
    br = pushFactory.create(db, admin.getIdent(), testRepo).to("refs/for/branch");
    br.assertOkStatus();
    c4 = br.getChange();
    r4 = changeRefPrefix(c4.getId());
    try (Repository repo = repoManager.openRepository(project)) {
        // master-tag -> master
        RefUpdate mtu = repo.updateRef("refs/tags/master-tag");
        mtu.setExpectedOldObjectId(ObjectId.zeroId());
        mtu.setNewObjectId(repo.exactRef("refs/heads/master").getObjectId());
        assertThat(mtu.update()).isEqualTo(RefUpdate.Result.NEW);
        // branch-tag -> branch
        RefUpdate btu = repo.updateRef("refs/tags/branch-tag");
        btu.setExpectedOldObjectId(ObjectId.zeroId());
        btu.setNewObjectId(repo.exactRef("refs/heads/branch").getObjectId());
        assertThat(btu.update()).isEqualTo(RefUpdate.Result.NEW);
    }
}
#method_after
private void setUpChanges() throws Exception {
    gApi.projects().name(project.get()).branch("branch").create(new BranchInput());
    // First 2 changes are merged, which means the tags pointing to them are
    // visible.
    allow("refs/for/refs/heads/*", Permission.SUBMIT, admins);
    PushOneCommit.Result mr = pushFactory.create(db, admin.getIdent(), testRepo).to("refs/for/master%submit");
    mr.assertOkStatus();
    c1 = mr.getChange();
    r1 = changeRefPrefix(c1.getId());
    PushOneCommit.Result br = pushFactory.create(db, admin.getIdent(), testRepo).to("refs/for/branch%submit");
    br.assertOkStatus();
    c2 = br.getChange();
    r2 = changeRefPrefix(c2.getId());
    // Second 2 changes are unmerged.
    mr = pushFactory.create(db, admin.getIdent(), testRepo).to("refs/for/master");
    mr.assertOkStatus();
    c3 = mr.getChange();
    r3 = changeRefPrefix(c3.getId());
    br = pushFactory.create(db, admin.getIdent(), testRepo).to("refs/for/branch");
    br.assertOkStatus();
    c4 = br.getChange();
    r4 = changeRefPrefix(c4.getId());
    try (Repository repo = repoManager.openRepository(project)) {
        // master-tag -> master
        RefUpdate mtu = repo.updateRef("refs/tags/master-tag");
        mtu.setExpectedOldObjectId(ObjectId.zeroId());
        mtu.setNewObjectId(repo.exactRef("refs/heads/master").getObjectId());
        assertThat(mtu.update()).isEqualTo(RefUpdate.Result.NEW);
        // branch-tag -> branch
        RefUpdate btu = repo.updateRef("refs/tags/branch-tag");
        btu.setExpectedOldObjectId(ObjectId.zeroId());
        btu.setNewObjectId(repo.exactRef("refs/heads/branch").getObjectId());
        assertThat(btu.update()).isEqualTo(RefUpdate.Result.NEW);
    }
}
#end_block

#method_before
@Test
public void uploadPackAllRefsVisibleWithRefsMetaConfig() throws Exception {
    allow(Permission.READ, REGISTERED_USERS, "refs/*");
    allow(Permission.READ, REGISTERED_USERS, RefNames.REFS_CONFIG);
    assertUploadPackRefs("HEAD", r1 + "1", r1 + "meta", r2 + "1", r2 + "meta", r3 + "1", r3 + "meta", r4 + "1", r4 + "meta", "refs/heads/branch", "refs/heads/master", RefNames.REFS_CONFIG, "refs/tags/branch-tag", "refs/tags/master-tag");
}
#method_after
@Test
public void uploadPackAllRefsVisibleWithRefsMetaConfig() throws Exception {
    allow("refs/*", Permission.READ, REGISTERED_USERS);
    allow(RefNames.REFS_CONFIG, Permission.READ, REGISTERED_USERS);
    assertUploadPackRefs("HEAD", r1 + "1", r1 + "meta", r2 + "1", r2 + "meta", r3 + "1", r3 + "meta", r4 + "1", r4 + "meta", "refs/heads/branch", "refs/heads/master", RefNames.REFS_CONFIG, "refs/tags/branch-tag", "refs/tags/master-tag");
}
#end_block

#method_before
@Test
public void uploadPackSubsetOfBranchesVisibleIncludingHead() throws Exception {
    allow(Permission.READ, REGISTERED_USERS, "refs/heads/master");
    deny(Permission.READ, REGISTERED_USERS, "refs/heads/branch");
    setApiUser(user);
    assertUploadPackRefs("HEAD", r1 + "1", r1 + "meta", r3 + "1", r3 + "meta", "refs/heads/master", "refs/tags/master-tag");
}
#method_after
@Test
public void uploadPackSubsetOfBranchesVisibleIncludingHead() throws Exception {
    allow("refs/heads/master", Permission.READ, REGISTERED_USERS);
    deny("refs/heads/branch", Permission.READ, REGISTERED_USERS);
    setApiUser(user);
    assertUploadPackRefs("HEAD", r1 + "1", r1 + "meta", r3 + "1", r3 + "meta", "refs/heads/master", "refs/tags/master-tag");
}
#end_block

#method_before
@Test
public void uploadPackSubsetOfBranchesVisibleNotIncludingHead() throws Exception {
    deny(Permission.READ, REGISTERED_USERS, "refs/heads/master");
    allow(Permission.READ, REGISTERED_USERS, "refs/heads/branch");
    setApiUser(user);
    assertUploadPackRefs(r2 + "1", r2 + "meta", r4 + "1", r4 + "meta", "refs/heads/branch", "refs/tags/branch-tag", // (since PushOneCommit always bases changes on each other).
    "refs/tags/master-tag");
}
#method_after
@Test
public void uploadPackSubsetOfBranchesVisibleNotIncludingHead() throws Exception {
    deny("refs/heads/master", Permission.READ, REGISTERED_USERS);
    allow("refs/heads/branch", Permission.READ, REGISTERED_USERS);
    setApiUser(user);
    assertUploadPackRefs(r2 + "1", r2 + "meta", r4 + "1", r4 + "meta", "refs/heads/branch", "refs/tags/branch-tag", // (since PushOneCommit always bases changes on each other).
    "refs/tags/master-tag");
}
#end_block

#method_before
@Test
public void uploadPackSubsetOfBranchesVisibleWithEdit() throws Exception {
    allow(Permission.READ, REGISTERED_USERS, "refs/heads/master");
    deny(Permission.READ, REGISTERED_USERS, "refs/heads/branch");
    Change c = notesFactory.createChecked(db, project, c1.getId()).getChange();
    String changeId = c.getKey().get();
    // Admin's edit is not visible.
    setApiUser(admin);
    gApi.changes().id(changeId).edit().create();
    // User's edit is visible.
    setApiUser(user);
    gApi.changes().id(changeId).edit().create();
    assertUploadPackRefs("HEAD", r1 + "1", r1 + "meta", r3 + "1", r3 + "meta", "refs/heads/master", "refs/tags/master-tag", "refs/users/01/1000001/edit-" + c1.getId() + "/1");
}
#method_after
@Test
public void uploadPackSubsetOfBranchesVisibleWithEdit() throws Exception {
    allow("refs/heads/master", Permission.READ, REGISTERED_USERS);
    Change c = notesFactory.createChecked(db, project, c1.getId()).getChange();
    String changeId = c.getKey().get();
    // Admin's edit is not visible.
    setApiUser(admin);
    gApi.changes().id(changeId).edit().create();
    // User's edit is visible.
    setApiUser(user);
    gApi.changes().id(changeId).edit().create();
    assertUploadPackRefs("HEAD", r1 + "1", r1 + "meta", r3 + "1", r3 + "meta", "refs/heads/master", "refs/tags/master-tag", "refs/users/01/1000001/edit-" + c1.getId() + "/1");
}
#end_block

#method_before
@Test
public void uploadPackSubsetOfRefsVisibleWithAccessDatabase() throws Exception {
    allowGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
    try {
        deny(Permission.READ, REGISTERED_USERS, "refs/heads/master");
        allow(Permission.READ, REGISTERED_USERS, "refs/heads/branch");
        String changeId = c1.change().getKey().get();
        setApiUser(admin);
        gApi.changes().id(changeId).edit().create();
        setApiUser(user);
        assertUploadPackRefs(// refs/heads/master is not.
        r1 + "1", r1 + "meta", r2 + "1", r2 + "meta", r3 + "1", r3 + "meta", r4 + "1", r4 + "meta", "refs/heads/branch", "refs/tags/branch-tag", // See comment in subsetOfBranchesVisibleNotIncludingHead.
        "refs/tags/master-tag", // All edits are visible due to accessDatabase capability.
        "refs/users/00/1000000/edit-" + c1.getId() + "/1");
    } finally {
        removeGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
    }
}
#method_after
@Test
public void uploadPackSubsetOfRefsVisibleWithAccessDatabase() throws Exception {
    allowGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
    try {
        deny("refs/heads/master", Permission.READ, REGISTERED_USERS);
        allow("refs/heads/branch", Permission.READ, REGISTERED_USERS);
        String changeId = c1.change().getKey().get();
        setApiUser(admin);
        gApi.changes().id(changeId).edit().create();
        setApiUser(user);
        assertUploadPackRefs(// refs/heads/master is not.
        r1 + "1", r1 + "meta", r2 + "1", r2 + "meta", r3 + "1", r3 + "meta", r4 + "1", r4 + "meta", "refs/heads/branch", "refs/tags/branch-tag", // See comment in subsetOfBranchesVisibleNotIncludingHead.
        "refs/tags/master-tag", // All edits are visible due to accessDatabase capability.
        "refs/users/00/1000000/edit-" + c1.getId() + "/1");
    } finally {
        removeGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
    }
}
#end_block

#method_before
@Test
public void uploadPackNoSearchingChangeCacheImpl() throws Exception {
    allow(Permission.READ, REGISTERED_USERS, "refs/heads/*");
    setApiUser(user);
    try (Repository repo = repoManager.openRepository(project)) {
        assertRefs(repo, new VisibleRefFilter(tagCache, notesFactory, null, repo, projectControl(), db, true), // Can't use stored values from the index so DB must be enabled.
        false, "HEAD", r1 + "1", r1 + "meta", r2 + "1", r2 + "meta", r3 + "1", r3 + "meta", r4 + "1", r4 + "meta", "refs/heads/branch", "refs/heads/master", "refs/tags/branch-tag", "refs/tags/master-tag");
    }
}
#method_after
@Test
public void uploadPackNoSearchingChangeCacheImpl() throws Exception {
    allow("refs/heads/*", Permission.READ, REGISTERED_USERS);
    setApiUser(user);
    try (Repository repo = repoManager.openRepository(project)) {
        assertRefs(repo, refFilterFactory.create(projectCache.get(project), repo), // Can't use stored values from the index so DB must be enabled.
        false, "HEAD", r1 + "1", r1 + "meta", r2 + "1", r2 + "meta", r3 + "1", r3 + "meta", r4 + "1", r4 + "meta", "refs/heads/branch", "refs/heads/master", "refs/tags/branch-tag", "refs/tags/master-tag");
    }
}
#end_block

#method_before
@Test
public void uploadPackSequencesWithAccessDatabase() throws Exception {
    assume().that(notesMigration.readChangeSequence()).isTrue();
    try (Repository repo = repoManager.openRepository(allProjects)) {
        setApiUser(user);
        assertRefs(repo, newFilter(db, repo, allProjects), true);
        allowGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
        try {
            setApiUser(user);
            assertRefs(repo, newFilter(db, repo, allProjects), true, "refs/sequences/changes");
        } finally {
            removeGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
        }
    }
}
#method_after
@Test
public void uploadPackSequencesWithAccessDatabase() throws Exception {
    assume().that(notesMigration.readChangeSequence()).isTrue();
    try (Repository repo = repoManager.openRepository(allProjects)) {
        setApiUser(user);
        assertRefs(repo, newFilter(repo, allProjects), true);
        allowGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
        try {
            setApiUser(user);
            assertRefs(repo, newFilter(repo, allProjects), true, "refs/sequences/changes");
        } finally {
            removeGlobalCapabilities(REGISTERED_USERS, GlobalCapability.ACCESS_DATABASE);
        }
    }
}
#end_block

#method_before
@Test
public void receivePackRespectsVisibilityOfOpenChanges() throws Exception {
    allow(Permission.READ, REGISTERED_USERS, "refs/heads/master");
    deny(Permission.READ, REGISTERED_USERS, "refs/heads/branch");
    setApiUser(user);
    assertThat(getReceivePackRefs().additionalHaves()).containsExactly(obj(c3, 1));
}
#method_after
@Test
public void receivePackRespectsVisibilityOfOpenChanges() throws Exception {
    allow("refs/heads/master", Permission.READ, REGISTERED_USERS);
    deny("refs/heads/branch", Permission.READ, REGISTERED_USERS);
    setApiUser(user);
    assertThat(getReceivePackRefs().additionalHaves()).containsExactly(obj(c3, 1));
}
#end_block

#method_before
private void assertUploadPackRefs(String... expectedWithMeta) throws Exception {
    try (Repository repo = repoManager.openRepository(project)) {
        assertRefs(repo, new VisibleRefFilter(tagCache, notesFactory, changeCache, repo, projectControl(), new DisabledReviewDb(), true), true, expectedWithMeta);
    }
}
#method_after
private void assertUploadPackRefs(String... expectedWithMeta) throws Exception {
    try (Repository repo = repoManager.openRepository(project)) {
        assertRefs(repo, refFilterFactory.create(projectCache.get(project), repo), true, expectedWithMeta);
    }
}
#end_block

#method_before
private void assertRefs(Repository repo, VisibleRefFilter filter, boolean disableDb, String... expectedWithMeta) throws Exception {
    List<String> expected = new ArrayList<>(expectedWithMeta.length);
    for (String r : expectedWithMeta) {
        if (notesMigration.writeChanges() || !r.endsWith(RefNames.META_SUFFIX)) {
            expected.add(r);
        }
    }
    AcceptanceTestRequestScope.Context ctx = null;
    if (disableDb) {
        ctx = disableDb();
    }
    try {
        Map<String, Ref> all = repo.getAllRefs();
        assertThat(filter.filter(all, false).keySet()).containsExactlyElementsIn(expected);
    } finally {
        if (disableDb) {
            enableDb(ctx);
        }
    }
}
#method_after
private void assertRefs(Repository repo, VisibleRefFilter filter, boolean disableDb, String... expectedWithMeta) throws Exception {
    List<String> expected = new ArrayList<>(expectedWithMeta.length);
    for (String r : expectedWithMeta) {
        if (notesMigration.commitChangeWrites() || !r.endsWith(RefNames.META_SUFFIX)) {
            expected.add(r);
        }
    }
    AcceptanceTestRequestScope.Context ctx = null;
    if (disableDb) {
        ctx = disableDb();
    }
    try {
        Map<String, Ref> all = repo.getAllRefs();
        assertThat(filter.filter(all, false).keySet()).containsExactlyElementsIn(expected);
    } finally {
        if (disableDb) {
            enableDb(ctx);
        }
    }
}
#end_block

#method_before
private VisibleRefFilter newFilter(ReviewDb db, Repository repo, Project.NameKey project) throws Exception {
    return new VisibleRefFilter(tagCache, notesFactory, null, repo, projectControlFactory.controlFor(project, userProvider.get()), db, true);
}
#method_after
private VisibleRefFilter newFilter(Repository repo, Project.NameKey project) {
    return refFilterFactory.create(projectCache.get(project), repo);
}
#end_block

#method_before
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Created a revert of this change as %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
}
#method_after
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Created a revert of this change as %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
    assertThat(revertChange.revertOf).isEqualTo(gApi.changes().id(r.getChangeId()).get()._number);
}
#end_block

#method_before
@Test
@TestProjectInput(cloneAs = "user")
public void deleteNewChangeAsNormalUser() throws Exception {
    PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    String changeId = changeResult.getChangeId();
    Change.Id id = changeResult.getChange().getId();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage(String.format("Deleting change %s is not permitted", id));
    gApi.changes().id(changeId).delete();
}
#method_after
@Test
@TestProjectInput(cloneAs = "user")
public void deleteNewChangeAsNormalUser() throws Exception {
    PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    String changeId = changeResult.getChangeId();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("delete not permitted");
    gApi.changes().id(changeId).delete();
}
#end_block

#method_before
@Test
@TestProjectInput(cloneAs = "user")
public void deleteAbandonedChangeAsNormalUser() throws Exception {
    PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    String changeId = changeResult.getChangeId();
    Change.Id id = changeResult.getChange().getId();
    setApiUser(user);
    gApi.changes().id(changeId).abandon();
    exception.expect(AuthException.class);
    exception.expectMessage(String.format("Deleting change %s is not permitted", id));
    gApi.changes().id(changeId).delete();
}
#method_after
@Test
@TestProjectInput(cloneAs = "user")
public void deleteAbandonedChangeAsNormalUser() throws Exception {
    PushOneCommit.Result changeResult = pushFactory.create(db, user.getIdent(), testRepo).to("refs/for/master");
    String changeId = changeResult.getChangeId();
    setApiUser(user);
    gApi.changes().id(changeId).abandon();
    exception.expect(AuthException.class);
    exception.expectMessage("delete not permitted");
    gApi.changes().id(changeId).delete();
}
#end_block

#method_before
@Test
public void deleteMergedChange() throws Exception {
    PushOneCommit.Result changeResult = createChange();
    String changeId = changeResult.getChangeId();
    Change.Id id = changeResult.getChange().getId();
    merge(changeResult);
    exception.expect(MethodNotAllowedException.class);
    exception.expectMessage(String.format("Deleting merged change %s is not allowed", id));
    gApi.changes().id(changeId).delete();
}
#method_after
@Test
public void deleteMergedChange() throws Exception {
    PushOneCommit.Result changeResult = createChange();
    String changeId = changeResult.getChangeId();
    merge(changeResult);
    exception.expect(MethodNotAllowedException.class);
    exception.expectMessage("delete not permitted");
    gApi.changes().id(changeId).delete();
}
#end_block

#method_before
@Test
public void pushCommitOfOtherUser() throws Exception {
    // admin pushes commit of user
    PushOneCommit push = pushFactory.create(db, user.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check that the author/committer was added as reviewer
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has uploaded this change for review");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
}
#method_after
@Test
public void pushCommitOfOtherUser() throws Exception {
    // admin pushes commit of user
    PushOneCommit push = pushFactory.create(db, user.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check that the author/committer was added as reviewer
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has uploaded this change for review");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
}
#end_block

#method_before
@Test
public void pushCommitOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit of user
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, user.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that the author/committer was NOT added as reviewer (he can't see
    // the change)
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#method_after
@Test
public void pushCommitOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit of user
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, user.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.owner._accountId).isEqualTo(admin.id.get());
    CommitInfo commit = change.revisions.get(change.currentRevision).commit;
    assertThat(commit.author.email).isEqualTo(user.email);
    assertThat(commit.committer.email).isEqualTo(user.email);
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that the author/committer was NOT added as reviewer (he can't see
    // the change)
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
@Test
public void pushCommitWithFooterOfOtherUser() throws Exception {
    // admin pushes commit that references 'user' in a footer
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' was added as reviewer
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
}
#method_after
@Test
public void pushCommitWithFooterOfOtherUser() throws Exception {
    // admin pushes commit that references 'user' in a footer
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' was added as reviewer
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    Collection<AccountInfo> reviewers = change.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    assertThat(change.reviewers.get(CC)).isNull();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
}
#end_block

#method_before
@Test
public void pushCommitWithFooterOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit that references 'user' in a footer
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that 'user' was NOT added as cc ('user' can't see the change)
    setApiUser(admin);
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#method_after
@Test
public void pushCommitWithFooterOfOtherUserThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // admin pushes commit that references 'user' in a footer
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo, PushOneCommit.SUBJECT + "\n\n" + FooterConstants.REVIEWED_BY.getName() + ": " + user.getIdent().toExternalString(), PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check that 'user' cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // check that 'user' was NOT added as cc ('user' can't see the change)
    setApiUser(admin);
    ChangeInfo change = gApi.changes().id(result.getChangeId()).get();
    assertThat(change.reviewers.get(REVIEWER)).isNull();
    assertThat(change.reviewers.get(CC)).isNull();
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
@Test
public void addReviewerThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // create change
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // try to add user as reviewer
    setApiUser(admin);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage("Change not visible to " + user.email);
    gApi.changes().id(result.getChangeId()).addReviewer(in);
}
#method_after
@Test
public void addReviewerThatCannotSeeChange() throws Exception {
    // create hidden project that is only visible to administrators
    Project.NameKey p = createProject("p");
    ProjectConfig cfg = projectCache.checkedGet(p).getConfig();
    Util.allow(cfg, Permission.READ, groupCache.get(new AccountGroup.NameKey("Administrators")).orElse(null).getGroupUUID(), "refs/*");
    Util.block(cfg, Permission.READ, REGISTERED_USERS, "refs/*");
    saveProjectConfig(p, cfg);
    // create change
    TestRepository<InMemoryRepository> repo = cloneProject(p, admin);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), repo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    // check the user cannot see the change
    setApiUser(user);
    try {
        gApi.changes().id(result.getChangeId()).get();
        fail("Expected ResourceNotFoundException");
    } catch (ResourceNotFoundException e) {
    // Expected.
    }
    // try to add user as reviewer
    setApiUser(admin);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(user.email);
    assertThat(r.error).contains("does not have permission to see this change");
    assertThat(r.reviewers).isNull();
}
#end_block

#method_before
@Test
public void addReviewerThatIsInactive() throws Exception {
    PushOneCommit.Result r = createChange();
    String username = name("new-user");
    gApi.accounts().create(username).setActive(false);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = username;
    exception.expect(UnprocessableEntityException.class);
    exception.expectMessage("Account of " + username + " is inactive.");
    gApi.changes().id(r.getChangeId()).addReviewer(in);
}
#method_after
@Test
public void addReviewerThatIsInactive() throws Exception {
    PushOneCommit.Result result = createChange();
    String username = name("new-user");
    gApi.accounts().create(username).setActive(false);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = username;
    AddReviewerResult r = gApi.changes().id(result.getChangeId()).addReviewer(in);
    assertThat(r.input).isEqualTo(username);
    assertThat(r.error).contains("identifies an inactive account");
    assertThat(r.reviewers).isNull();
}
#end_block

#method_before
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailFrom(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#method_after
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    assertMailReplyTo(m, admin.email);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
    // Change status of reviewer and ensure ETag is updated.
    oldETag = rsrc.getETag();
    gApi.accounts().id(user.id.get()).setStatus("new status");
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
}
#end_block

#method_before
@Test
public void addReviewerWithNoteDbWhenDummyApprovalInReviewDbExists() throws Exception {
    assume().that(notesMigration.enabled()).isTrue();
    assume().that(notesMigration.changePrimaryStorage()).isEqualTo(PrimaryStorage.REVIEW_DB);
    PushOneCommit.Result r = createChange();
    // insert dummy approval in ReviewDb
    PatchSetApproval psa = new PatchSetApproval(new PatchSetApproval.Key(r.getPatchSetId(), user.id, new LabelId("Code-Review")), (short) 0, TimeUtil.nowTs());
    db.patchSetApprovals().insert(Collections.singleton(psa));
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
}
#method_after
@Test
public void addReviewerWithNoteDbWhenDummyApprovalInReviewDbExists() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    assume().that(notesMigration.changePrimaryStorage()).isEqualTo(PrimaryStorage.REVIEW_DB);
    PushOneCommit.Result r = createChange();
    // insert dummy approval in ReviewDb
    PatchSetApproval psa = new PatchSetApproval(new PatchSetApproval.Key(r.getPatchSetId(), user.id, new LabelId("Code-Review")), (short) 0, TimeUtil.nowTs());
    db.patchSetApprovals().insert(Collections.singleton(psa));
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
}
#end_block

#method_before
@Test
public void removeReviewerNotPermitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("delete reviewer not permitted");
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).remove();
}
#method_after
@Test
public void removeReviewerNotPermitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    gApi.changes().id(changeId).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("remove reviewer not permitted");
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).remove();
}
#end_block

#method_before
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote("Code-Review");
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message msg = messages.get(0);
    assertThat(msg.rcpt()).containsExactly(user.emailAddress);
    assertThat(msg.body()).contains(admin.fullName + " has removed a vote on this change.\n");
    assertThat(msg.body()).contains("Removed Code-Review+1 by " + user.fullName + " <" + user.email + ">" + "\n");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).votes();
    // Dummy 0 approval on the change to block vote copying to this patch set.
    assertThat(m).containsExactly("Code-Review", Short.valueOf((short) 0));
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#method_after
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote("Code-Review");
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message msg = messages.get(0);
    assertThat(msg.rcpt()).containsExactly(user.emailAddress);
    assertThat(msg.body()).contains(admin.fullName + " has removed a vote on this change.\n");
    assertThat(msg.body()).contains("Removed Code-Review+1 by " + user.fullName + " <" + user.email + ">\n");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).votes();
    // Dummy 0 approval on the change to block vote copying to this patch set.
    assertThat(m).containsExactly("Code-Review", Short.valueOf((short) 0));
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#end_block

#method_before
@Test
public void deleteVoteNotifyAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    DeleteVoteInput in = new DeleteVoteInput();
    in.label = "Code-Review";
    in.notify = NotifyHandling.NONE;
    // notify unrelated account as TO
    TestAccount user2 = accounts.user2();
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.TO, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyTo(user2);
    // notify unrelated account as CC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.CC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyCc(user2);
    // notify unrelated account as BCC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.BCC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyBcc(user2);
}
#method_after
@Test
public void deleteVoteNotifyAccount() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    DeleteVoteInput in = new DeleteVoteInput();
    in.label = "Code-Review";
    in.notify = NotifyHandling.NONE;
    // notify unrelated account as TO
    TestAccount user2 = accountCreator.user2();
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.TO, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyTo(user2);
    // notify unrelated account as CC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.CC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyCc(user2);
    // notify unrelated account as BCC
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    sender.clear();
    in.notifyDetails = new HashMap<>();
    in.notifyDetails.put(RecipientType.BCC, new NotifyInfo(ImmutableList.of(user2.email)));
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote(in);
    assertNotifyBcc(user2);
}
#end_block

#method_before
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).get());
    assertThat(result.labels).isNull();
    assertThat(result.messages).isNull();
    assertThat(result.actions).isNull();
    assertThat(result.revisions).isNull();
    EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CHANGE_ACTIONS, ListChangesOption.CURRENT_ACTIONS, ListChangesOption.DETAILED_LABELS, ListChangesOption.MESSAGES);
    result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(options).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.created).isNotNull();
    assertThat(rev.uploader._accountId).isEqualTo(admin.getId().get());
    assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName());
    assertThat(rev.actions).isNotEmpty();
}
#method_after
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).get());
    assertThat(result.labels).isNull();
    assertThat(result.messages).isNull();
    assertThat(result.actions).isNull();
    assertThat(result.revisions).isNull();
    result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(ALL_REVISIONS, CHANGE_ACTIONS, CURRENT_ACTIONS, DETAILED_LABELS, MESSAGES).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.created).isNotNull();
    assertThat(rev.uploader._accountId).isEqualTo(admin.getId().get());
    assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName());
    assertThat(rev.actions).isNotEmpty();
}
#end_block

#method_before
@Test
public void queryChangesOwnerWithDifferentUsers() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.getOnlyElement(query("project:{" + project.get() + "} owner:self")).changeId).isEqualTo(r.getChangeId());
    setApiUser(user);
    assertThat(query("owner:self")).isEmpty();
}
#method_after
@Test
public void queryChangesOwnerWithDifferentUsers() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.getOnlyElement(query("project:{" + project.get() + "} owner:self")).changeId).isEqualTo(r.getChangeId());
    setApiUser(user);
    assertThat(query("owner:self project:{" + project.get() + "}")).isEmpty();
}
#end_block

#method_before
@Test
public void submitted() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    assertThat(gApi.changes().id(r.getChangeId()).info().submitted).isNull();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    assertThat(gApi.changes().id(r.getChangeId()).info().submitted).isNotNull();
}
#method_after
@Test
public void submitted() throws Exception {
    PushOneCommit.Result r = createChange();
    String id = r.getChangeId();
    ChangeInfo c = gApi.changes().id(r.getChangeId()).info();
    assertThat(c.submitted).isNull();
    assertThat(c.submitter).isNull();
    gApi.changes().id(id).current().review(ReviewInput.approve());
    gApi.changes().id(id).current().submit();
    c = gApi.changes().id(r.getChangeId()).info();
    assertThat(c.submitted).isNotNull();
    assertThat(c.submitter).isNotNull();
    assertThat(c.submitter._accountId).isEqualTo(atrScope.get().getUser().getAccountId().get());
}
#end_block

#method_before
@Test
public void check() throws Exception {
    // TODO(dborowitz): Re-enable when ConsistencyChecker supports NoteDb.
    assume().that(notesMigration.enabled()).isFalse();
    PushOneCommit.Result r = createChange();
    assertThat(gApi.changes().id(r.getChangeId()).get().problems).isNull();
    assertThat(gApi.changes().id(r.getChangeId()).get(EnumSet.of(ListChangesOption.CHECK)).problems).isEmpty();
}
#method_after
@Test
public void check() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(gApi.changes().id(r.getChangeId()).get().problems).isNull();
    assertThat(gApi.changes().id(r.getChangeId()).get(CHECK).problems).isEmpty();
}
#end_block

#method_before
@Test
public void commitFooters() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    LabelType custom1 = category("Custom1", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    LabelType custom2 = category("Custom2", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    cfg.getLabelSections().put(custom1.getName(), custom1);
    cfg.getLabelSections().put(custom2.getName(), custom2);
    String heads = "refs/heads/*";
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel("Verified"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom1"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom2"), -1, 1, anon, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r1 = createChange();
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    r2.assertOkStatus();
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.label("Verified", 1);
    in.label("Custom1", -1);
    in.label("Custom2", 1);
    gApi.changes().id(r2.getChangeId()).current().review(in);
    EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
    ChangeInfo actual = gApi.changes().id(r2.getChangeId()).get(options);
    assertThat(actual.revisions).hasSize(2);
    // No footers except on latest patch set.
    assertThat(actual.revisions.get(r1.getCommit().getName()).commitWithFooters).isNull();
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(r2.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + r2.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + r2.getChange().getId(), "Reviewed-by: Administrator <admin@example.com>", "Custom2: Administrator <admin@example.com>", "Tested-by: Administrator <admin@example.com>");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#method_after
@Test
public void commitFooters() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    LabelType custom1 = category("Custom1", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    LabelType custom2 = category("Custom2", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    cfg.getLabelSections().put(custom1.getName(), custom1);
    cfg.getLabelSections().put(custom2.getName(), custom2);
    String heads = "refs/heads/*";
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel("Verified"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom1"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom2"), -1, 1, anon, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r1 = createChange();
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    r2.assertOkStatus();
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.label("Verified", 1);
    in.label("Custom1", -1);
    in.label("Custom2", 1);
    gApi.changes().id(r2.getChangeId()).current().review(in);
    ChangeInfo actual = gApi.changes().id(r2.getChangeId()).get(ALL_REVISIONS, COMMIT_FOOTERS);
    assertThat(actual.revisions).hasSize(2);
    // No footers except on latest patch set.
    assertThat(actual.revisions.get(r1.getCommit().getName()).commitWithFooters).isNull();
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(r2.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + r2.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + r2.getChange().getId(), "Reviewed-by: Administrator <admin@example.com>", "Custom2: Administrator <admin@example.com>", "Tested-by: Administrator <admin@example.com>");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#end_block

#method_before
@Test
public void customCommitFooters() throws Exception {
    PushOneCommit.Result change = createChange();
    RegistrationHandle handle = changeMessageModifiers.add(new ChangeMessageModifier() {

        @Override
        public String onSubmit(String newCommitMessage, RevCommit original, RevCommit mergeTip, Branch.NameKey destination) {
            assertThat(original.getName()).isNotEqualTo(mergeTip.getName());
            return newCommitMessage + "Custom: " + destination.get();
        }
    });
    ChangeInfo actual;
    try {
        EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
        actual = gApi.changes().id(change.getChangeId()).get(options);
    } finally {
        handle.remove();
    }
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(change.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + change.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + change.getChange().getId(), "Custom: refs/heads/master");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#method_after
@Test
public void customCommitFooters() throws Exception {
    PushOneCommit.Result change = createChange();
    RegistrationHandle handle = changeMessageModifiers.add(new ChangeMessageModifier() {

        @Override
        public String onSubmit(String newCommitMessage, RevCommit original, RevCommit mergeTip, Branch.NameKey destination) {
            assertThat(original.getName()).isNotEqualTo(mergeTip.getName());
            return newCommitMessage + "Custom: " + destination.get();
        }
    });
    ChangeInfo actual;
    try {
        actual = gApi.changes().id(change.getChangeId()).get(ALL_REVISIONS, COMMIT_FOOTERS);
    } finally {
        handle.remove();
    }
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(change.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + change.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + change.getChange().getId(), "Custom: refs/heads/master");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#end_block

#method_before
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    setApiUser(admin);
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    setApiUser(user);
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try {
        assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(ListChangesOption.LABELS).withOption(ListChangesOption.DETAILED_ACCOUNTS).withOption(ListChangesOption.REVIEWED).get()).hasSize(2);
    } finally {
        enableDb(ctx);
    }
}
#method_after
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    setApiUser(admin);
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    setApiUser(user);
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try {
        assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(LABELS).withOption(DETAILED_ACCOUNTS).withOption(REVIEWED).get()).hasSize(2);
    } finally {
        enableDb(ctx);
    }
}
#end_block

#method_before
@Test
public void votable() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isEqualTo(0);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    blockLabel(cfg, "Code-Review", REGISTERED_USERS, "refs/heads/*");
    saveProjectConfig(project, cfg);
    c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isNull();
}
#method_after
@Test
public void votable() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isEqualTo(0);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.blockLabel(cfg, "Code-Review", REGISTERED_USERS, "refs/heads/*");
    saveProjectConfig(project, cfg);
    c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.value).isNull();
}
#end_block

#method_before
@Test
@GerritConfig(name = "gerrit.editGpgKeys", value = "true")
@GerritConfig(name = "receive.enableSignedPush", value = "true")
public void pushCertificates() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = amendChange(r1.getChangeId());
    ChangeInfo info = gApi.changes().id(r1.getChangeId()).get(EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.PUSH_CERTIFICATES));
    RevisionInfo rev1 = info.revisions.get(r1.getCommit().name());
    assertThat(rev1).isNotNull();
    assertThat(rev1.pushCertificate).isNotNull();
    assertThat(rev1.pushCertificate.certificate).isNull();
    assertThat(rev1.pushCertificate.key).isNull();
    RevisionInfo rev2 = info.revisions.get(r2.getCommit().name());
    assertThat(rev2).isNotNull();
    assertThat(rev2.pushCertificate).isNotNull();
    assertThat(rev2.pushCertificate.certificate).isNull();
    assertThat(rev2.pushCertificate.key).isNull();
}
#method_after
@Test
@GerritConfig(name = "gerrit.editGpgKeys", value = "true")
@GerritConfig(name = "receive.enableSignedPush", value = "true")
public void pushCertificates() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = amendChange(r1.getChangeId());
    ChangeInfo info = gApi.changes().id(r1.getChangeId()).get(ALL_REVISIONS, PUSH_CERTIFICATES);
    RevisionInfo rev1 = info.revisions.get(r1.getCommit().name());
    assertThat(rev1).isNotNull();
    assertThat(rev1.pushCertificate).isNotNull();
    assertThat(rev1.pushCertificate.certificate).isNull();
    assertThat(rev1.pushCertificate.key).isNull();
    RevisionInfo rev2 = info.revisions.get(r2.getCommit().name());
    assertThat(rev2).isNotNull();
    assertThat(rev2.pushCertificate).isNotNull();
    assertThat(rev2.pushCertificate.certificate).isNull();
    assertThat(rev2.pushCertificate.key).isNull();
}
#end_block

#method_before
@Test
public void createNewPatchSetWithoutPermission() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet1");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<InMemoryRepository> adminTestRepo = cloneProject(p, admin);
    TestRepository<InMemoryRepository> userTestRepo = cloneProject(p, user);
    // Block default permission
    block(Permission.ADD_PATCH_SET, REGISTERED_USERS, "refs/for/*", p);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/for/master");
    r1.assertOkStatus();
    // Fetch change
    GitUtil.fetch(userTestRepo, r1.getPatchSet().getRefName() + ":ps");
    userTestRepo.reset("ps");
    // Amend change as user
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/for/master", user, userTestRepo);
    r2.assertErrorStatus("cannot add patch set to " + r1.getChange().getId().id + ".");
}
#method_after
@Test
public void createNewPatchSetWithoutPermission() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet1");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<InMemoryRepository> adminTestRepo = cloneProject(p, admin);
    TestRepository<InMemoryRepository> userTestRepo = cloneProject(p, user);
    // Block default permission
    block(p, "refs/for/*", Permission.ADD_PATCH_SET, REGISTERED_USERS);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/for/master");
    r1.assertOkStatus();
    // Fetch change
    GitUtil.fetch(userTestRepo, r1.getPatchSet().getRefName() + ":ps");
    userTestRepo.reset("ps");
    // Amend change as user
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/for/master", user, userTestRepo);
    r2.assertErrorStatus("cannot add patch set to " + r1.getChange().getId().id + ".");
}
#end_block

#method_before
@Test
public void createNewPatchSetAsOwnerWithoutPermission() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet2");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<?> adminTestRepo = cloneProject(project, admin);
    // Block default permission
    block(Permission.ADD_PATCH_SET, REGISTERED_USERS, "refs/for/*", p);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/for/master");
    r1.assertOkStatus();
    // Fetch change
    GitUtil.fetch(adminTestRepo, r1.getPatchSet().getRefName() + ":ps");
    adminTestRepo.reset("ps");
    // Amend change as admin
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/for/master", admin, adminTestRepo);
    r2.assertOkStatus();
}
#method_after
@Test
public void createNewPatchSetAsOwnerWithoutPermission() throws Exception {
    // Create new project with clean permissions
    Project.NameKey p = createProject("addPatchSet2");
    // Clone separate repositories of the same project as admin and as user
    TestRepository<?> adminTestRepo = cloneProject(project, admin);
    // Block default permission
    block(p, "refs/for/*", Permission.ADD_PATCH_SET, REGISTERED_USERS);
    // Create change as admin
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), adminTestRepo);
    PushOneCommit.Result r1 = push.to("refs/for/master");
    r1.assertOkStatus();
    // Fetch change
    GitUtil.fetch(adminTestRepo, r1.getPatchSet().getRefName() + ":ps");
    adminTestRepo.reset("ps");
    // Amend change as admin
    PushOneCommit.Result r2 = amendChange(r1.getChangeId(), "refs/for/master", admin, adminTestRepo);
    r2.assertOkStatus();
}
#end_block

#method_before
@Test
public void createMergePatchSet() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    String parent = currentMaster.getCommit().getName();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2";
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION));
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
}
#method_after
@Test
public void createMergePatchSet() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    String parent = currentMaster.getCommit().getName();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2";
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(ALL_REVISIONS, CURRENT_COMMIT, CURRENT_REVISION);
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
}
#end_block

#method_before
@Test
public void createMergePatchSetInheritParent() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    String parent = r.getCommit().getParent(0).getName();
    // advance master branch
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2 inherit parent of ps1";
    in.inheritParent = true;
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION));
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isNotEqualTo(currentMaster.getCommit().getName());
}
#method_after
@Test
public void createMergePatchSetInheritParent() throws Exception {
    PushOneCommit.Result start = pushTo("refs/heads/master");
    start.assertOkStatus();
    // create a change for master
    PushOneCommit.Result r = createChange();
    r.assertOkStatus();
    String changeId = r.getChangeId();
    String parent = r.getCommit().getParent(0).getName();
    // advance master branch
    testRepo.reset(start.getCommit());
    PushOneCommit.Result currentMaster = pushTo("refs/heads/master");
    currentMaster.assertOkStatus();
    // push a commit into dev branch
    createBranch(new Branch.NameKey(project, "dev"));
    PushOneCommit.Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", "A.txt", "A content").to("refs/heads/dev");
    changeA.assertOkStatus();
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = "dev";
    MergePatchSetInput in = new MergePatchSetInput();
    in.merge = mergeInput;
    in.subject = "update change by merge ps2 inherit parent of ps1";
    in.inheritParent = true;
    gApi.changes().id(changeId).createMergePatchSet(in);
    ChangeInfo changeInfo = gApi.changes().id(changeId).get(ALL_REVISIONS, CURRENT_COMMIT, CURRENT_REVISION);
    assertThat(changeInfo.revisions.size()).isEqualTo(2);
    assertThat(changeInfo.subject).isEqualTo(in.subject);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isEqualTo(parent);
    assertThat(changeInfo.revisions.get(changeInfo.currentRevision).commit.parents.get(0).commit).isNotEqualTo(currentMaster.getCommit().getName());
}
#end_block

#method_before
@Test
public void checkLabelsForMergedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
    // add new label and assert that it's returned for existing changes
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType verified = Util.verified();
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified", 0, 1);
    // ignore the new label by Prolog submit rule and assert that the label is
    // no longer returned
    GitUtil.fetch(testRepo, RefNames.REFS_CONFIG + ":config");
    testRepo.reset("config");
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), testRepo, "Ignore Verified", "rules.pl", "submit_rule(submit(CR)) :-\n" + "  gerrit:max_with_block(-2, 2, 'Code-Review', CR).");
    push2.to(RefNames.REFS_CONFIG);
    change = gApi.changes().id(r.getChangeId()).get();
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // add an approval on the new label and assert that the label is now
    // returned although it is ignored by the Prolog submit rule and hence not
    // included in the submit records
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(new ReviewInput().label(verified.getName(), verified.getMax().getValue()));
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // remove label and assert that it's no longer returned for existing
    // changes, even if there is an approval for it
    cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().remove(verified.getName());
    Util.remove(cfg, Permission.forLabel(verified.getName()), registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
}
#method_after
@Test
public void checkLabelsForMergedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
    // add new label and assert that it's returned for existing changes
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    LabelType verified = Util.verified();
    cfg.getLabelSections().put(verified.getName(), verified);
    AccountGroup.UUID registeredUsers = systemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    String heads = RefNames.REFS_HEADS + "*";
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified", 0, 1);
    // ignore the new label by Prolog submit rule and assert that the label is
    // no longer returned
    GitUtil.fetch(testRepo, RefNames.REFS_CONFIG + ":config");
    testRepo.reset("config");
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), testRepo, "Ignore Verified", "rules.pl", "submit_rule(submit(CR)) :-\n  gerrit:max_with_block(-2, 2, 'Code-Review', CR).");
    push2.to(RefNames.REFS_CONFIG);
    change = gApi.changes().id(r.getChangeId()).get();
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // add an approval on the new label and assert that the label is now
    // returned although it is ignored by the Prolog submit rule and hence not
    // included in the submit records
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(new ReviewInput().label(verified.getName(), verified.getMax().getValue()));
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review", "Verified");
    assertPermitted(change, "Code-Review", 2);
    assertPermitted(change, "Verified");
    // remove label and assert that it's no longer returned for existing
    // changes, even if there is an approval for it
    cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().remove(verified.getName());
    Util.remove(cfg, Permission.forLabel(verified.getName()), registeredUsers, heads);
    saveProjectConfig(project, cfg);
    change = gApi.changes().id(r.getChangeId()).get();
    assertThat(change.labels.keySet()).containsExactly("Code-Review");
    assertThat(change.permittedLabels.keySet()).containsExactly("Code-Review");
    assertPermitted(change, "Code-Review", 2);
}
#end_block

#method_before
@Test
public void maxPermittedValueAllowed() throws Exception {
    final int minPermittedValue = -2;
    final int maxPermittedValue = +2;
    String heads = "refs/heads/*";
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    // default values
    assertThat(approval.permittedVotingRange.min).isEqualTo(-1);
    assertThat(approval.permittedVotingRange.max).isEqualTo(1);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.allow(cfg, Permission.forLabel("Code-Review"), minPermittedValue, maxPermittedValue, REGISTERED_USERS, heads);
    saveProjectConfig(project, cfg);
    c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    assertThat(approval.permittedVotingRange.min).isEqualTo(minPermittedValue);
    assertThat(approval.permittedVotingRange.max).isEqualTo(maxPermittedValue);
}
#method_after
@Test
public void maxPermittedValueAllowed() throws Exception {
    final int minPermittedValue = -2;
    final int maxPermittedValue = +2;
    String heads = "refs/heads/*";
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    // default values
    assertThat(approval.permittedVotingRange.min).isEqualTo(-1);
    assertThat(approval.permittedVotingRange.max).isEqualTo(1);
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.allow(cfg, Permission.forLabel("Code-Review"), minPermittedValue, maxPermittedValue, REGISTERED_USERS, heads);
    saveProjectConfig(project, cfg);
    c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNotNull();
    assertThat(approval.permittedVotingRange.min).isEqualTo(minPermittedValue);
    assertThat(approval.permittedVotingRange.max).isEqualTo(maxPermittedValue);
}
#end_block

#method_before
@Test
public void maxPermittedValueBlocked() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    blockLabel(cfg, "Code-Review", REGISTERED_USERS, "refs/heads/*");
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNull();
}
#method_after
@Test
public void maxPermittedValueBlocked() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    Util.blockLabel(cfg, "Code-Review", REGISTERED_USERS, "refs/heads/*");
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(triplet).addReviewer(user.username);
    ChangeInfo c = gApi.changes().id(triplet).get(DETAILED_LABELS);
    LabelInfo codeReview = c.labels.get("Code-Review");
    assertThat(codeReview.all).hasSize(1);
    ApprovalInfo approval = codeReview.all.get(0);
    assertThat(approval._accountId).isEqualTo(user.id.get());
    assertThat(approval.permittedVotingRange).isNull();
}
#end_block

#method_before
private ChangeResource parseResource(PushOneCommit.Result r) throws Exception {
    List<ChangeControl> ctls = changeFinder.find(r.getChangeId(), atrScope.get().getUser());
    assertThat(ctls).hasSize(1);
    return changeResourceFactory.create(ctls.get(0));
}
#method_after
private ChangeResource parseResource(PushOneCommit.Result r) throws Exception {
    return parseChangeResource(r.getChangeId());
}
#end_block

#method_before
private Optional<ReviewerState> getReviewerState(String changeId, Account.Id accountId) throws Exception {
    ChangeInfo c = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.DETAILED_LABELS));
    Set<ReviewerState> states = c.reviewers.entrySet().stream().filter(e -> e.getValue().stream().anyMatch(a -> a._accountId == accountId.get())).map(e -> e.getKey()).collect(toSet());
    assertThat(states.size()).named(states.toString()).isAtMost(1);
    return states.stream().findFirst();
}
#method_after
private Optional<ReviewerState> getReviewerState(String changeId, Account.Id accountId) throws Exception {
    ChangeInfo c = gApi.changes().id(changeId).get(DETAILED_LABELS);
    Set<ReviewerState> states = c.reviewers.entrySet().stream().filter(e -> e.getValue().stream().anyMatch(a -> a._accountId == accountId.get())).map(e -> e.getKey()).collect(toSet());
    assertThat(states.size()).named(states.toString()).isAtMost(1);
    return states.stream().findFirst();
}
#end_block

#method_before
private void setChangeStatus(Change.Id id, Change.Status newStatus) throws Exception {
    try (BatchUpdate batchUpdate = updateFactory.create(db, project, atrScope.get().getUser(), TimeUtil.nowTs())) {
        batchUpdate.addOp(id, new ChangeStatusUpdateOp(newStatus));
        batchUpdate.execute();
    }
    ChangeStatus changeStatus = gApi.changes().id(id.get()).get().status;
    assertThat(changeStatus).isEqualTo(newStatus.asChangeStatus());
}
#method_after
private void setChangeStatus(Change.Id id, Change.Status newStatus) throws Exception {
    try (BatchUpdate batchUpdate = batchUpdateFactory.create(db, project, atrScope.get().getUser(), TimeUtil.nowTs())) {
        batchUpdate.addOp(id, new ChangeStatusUpdateOp(newStatus));
        batchUpdate.execute();
    }
    ChangeStatus changeStatus = gApi.changes().id(id.get()).get().status;
    assertThat(changeStatus).isEqualTo(newStatus.asChangeStatus());
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    // Change status in database.
    change.setStatus(newStatus);
    // Change status in NoteDb.
    PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    ctx.getUpdate(currentPatchSetId).setStatus(newStatus);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    // Change status in database.
    change.setStatus(newStatus);
    // Change status in NoteDb.
    PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    ctx.getUpdate(currentPatchSetId).setStatus(newStatus);
    return true;
}
#end_block

#method_before
@ConfigSuite.Default
public static Config defaultConfig() {
    Config cfg = new Config();
    cfg.setBoolean("noteDb", null, "testRebuilderWrapper", true);
    // Disable async reindex-if-stale check after index update. This avoids
    // unintentional auto-rebuilding of the change in NoteDb during the read
    // path of the reindex-if-stale check. For the purposes of this test, we
    // want precise control over when auto-rebuilding happens.
    cfg.setBoolean("index", null, "testReindexAfterUpdate", false);
    return cfg;
}
#method_after
@ConfigSuite.Default
public static Config defaultConfig() {
    Config cfg = new Config();
    cfg.setBoolean("noteDb", null, "testRebuilderWrapper", true);
    // Disable async reindex-if-stale check after index update. This avoids
    // unintentional auto-rebuilding of the change in NoteDb during the read
    // path of the reindex-if-stale check. For the purposes of this test, we
    // want precise control over when auto-rebuilding happens.
    cfg.setBoolean("index", null, "autoReindexIfStale", false);
    // setNotesMigration tries to keep IDs in sync between ReviewDb and NoteDb, which is behavior
    // unique to this test. This gets prohibitively slow if we use the default sequence gap.
    cfg.setInt("noteDb", "changes", "initialSequenceGap", 0);
    return cfg;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    assume().that(NoteDbMode.readWrite()).isFalse();
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    setNotesMigration(false, false);
}
#method_after
@Before
public void setUp() throws Exception {
    assume().that(NoteDbMode.get()).isEqualTo(NoteDbMode.OFF);
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    setNotesMigration(false, false);
}
#end_block

#method_before
@Test
public void patchSetWithNullGroups() throws Exception {
    Timestamp ts = TimeUtil.nowTs();
    Change c = TestChanges.newChange(project, user.getId(), seq.nextChangeId());
    c.setCreatedOn(ts);
    c.setLastUpdatedOn(ts);
    PatchSet ps = TestChanges.newPatchSet(c.currentPatchSetId(), "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef", user.getId());
    ps.setCreatedOn(ts);
    db.changes().insert(Collections.singleton(c));
    db.patchSets().insert(Collections.singleton(ps));
    assertThat(ps.getGroups()).isEmpty();
    checker.rebuildAndCheckChanges(c.getId());
}
#method_after
@Test
public void patchSetWithNullGroups() throws Exception {
    Timestamp ts = TimeUtil.nowTs();
    Change c = TestChanges.newChange(project, user.getId(), seq.nextChangeId());
    c.setCreatedOn(ts);
    c.setLastUpdatedOn(ts);
    c.setReviewStarted(true);
    PatchSet ps = TestChanges.newPatchSet(c.currentPatchSetId(), "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef", user.getId());
    ps.setCreatedOn(ts);
    db.changes().insert(Collections.singleton(c));
    db.patchSets().insert(Collections.singleton(ps));
    assertThat(ps.getGroups()).isEmpty();
    checker.rebuildAndCheckChanges(c.getId());
}
#end_block

#method_before
@Test
public void rebuildAutomaticallyWithinBatchUpdate() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    final Change.Id id = r.getPatchSetId().getParentKey();
    assertChangeUpToDate(true, id);
    // Update ReviewDb and NoteDb, then revert the corresponding NoteDb change
    // to simulate it failing.
    NoteDbChangeState oldState = NoteDbChangeState.parse(getUnwrappedDb().changes().get(id));
    String topic = name("a-topic");
    gApi.changes().id(id.get()).topic(topic);
    try (Repository repo = repoManager.openRepository(project)) {
        new TestRepository<>(repo).update(RefNames.changeMetaRef(id), oldState.getChangeMetaId());
    }
    assertChangeUpToDate(false, id);
    // Next NoteDb read comes inside the transaction started by BatchUpdate. In
    // reality this could be caused by a failed update happening between when
    // the change is parsed by ChangesCollection and when the BatchUpdate
    // executes. We simulate it here by using BatchUpdate directly and not going
    // through an API handler.
    final String msg = "message from BatchUpdate";
    try (BatchUpdate bu = batchUpdateFactory.create(db, project, identifiedUserFactory.create(user.getId()), TimeUtil.nowTs())) {
        bu.addOp(id, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                PatchSet.Id psId = ctx.getChange().currentPatchSetId();
                ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUuid()), ctx.getAccountId(), ctx.getWhen(), psId);
                cm.setMessage(msg);
                ctx.getDb().changeMessages().insert(Collections.singleton(cm));
                ctx.getUpdate(psId).setChangeMessage(msg);
                return true;
            }
        });
        try {
            bu.execute();
            fail("expected update to fail");
        } catch (UpdateException e) {
            assertThat(e.getMessage()).contains("cannot copy ChangeNotesState");
        }
    }
// TODO(dborowitz): Re-enable these assertions once we fix auto-rebuilding
// in the BatchUpdate path.
// // As an implementation detail, change wasn't actually rebuilt inside the
// // BatchUpdate transaction, but it was rebuilt during read for the
// // subsequent reindex. Thus it's impossible to actually observe an
// // out-of-date state in the caller.
// assertChangeUpToDate(true, id);
// // Check that the bundles are equal.
// ChangeNotes notes = notesFactory.create(dbProvider.get(), project, id);
// ChangeBundle actual = ChangeBundle.fromNotes(commentsUtil, notes);
// ChangeBundle expected = bundleReader.fromReviewDb(getUnwrappedDb(), id);
// assertThat(actual.differencesFrom(expected)).isEmpty();
// assertThat(
// Iterables.transform(
// notes.getChangeMessages(),
// ChangeMessage::getMessage))
// .contains(msg);
// assertThat(actual.getChange().getTopic()).isEqualTo(topic);
}
#method_after
@Test
public void rebuildAutomaticallyWithinBatchUpdate() throws Exception {
    setNotesMigration(true, true);
    PushOneCommit.Result r = createChange();
    final Change.Id id = r.getPatchSetId().getParentKey();
    assertChangeUpToDate(true, id);
    // Update ReviewDb and NoteDb, then revert the corresponding NoteDb change
    // to simulate it failing.
    NoteDbChangeState oldState = NoteDbChangeState.parse(getUnwrappedDb().changes().get(id));
    String topic = name("a-topic");
    gApi.changes().id(id.get()).topic(topic);
    try (Repository repo = repoManager.openRepository(project)) {
        new TestRepository<>(repo).update(RefNames.changeMetaRef(id), oldState.getChangeMetaId());
    }
    assertChangeUpToDate(false, id);
    // Next NoteDb read comes inside the transaction started by BatchUpdate. In
    // reality this could be caused by a failed update happening between when
    // the change is parsed by ChangesCollection and when the BatchUpdate
    // executes. We simulate it here by using BatchUpdate directly and not going
    // through an API handler.
    final String msg = "message from BatchUpdate";
    try (BatchUpdate bu = batchUpdateFactory.create(db, project, identifiedUserFactory.create(user.getId()), TimeUtil.nowTs())) {
        bu.addOp(id, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                PatchSet.Id psId = ctx.getChange().currentPatchSetId();
                ChangeMessage cm = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUuid()), ctx.getAccountId(), ctx.getWhen(), psId);
                cm.setMessage(msg);
                ctx.getDb().changeMessages().insert(Collections.singleton(cm));
                ctx.getUpdate(psId).setChangeMessage(msg);
                return true;
            }
        });
        try {
            bu.execute();
            fail("expected update to fail");
        } catch (UpdateException e) {
            assertThat(e.getMessage()).contains("cannot copy ChangeNotesState");
        }
    }
// TODO(dborowitz): Re-enable these assertions once we fix auto-rebuilding
// in the BatchUpdate path.
// As an implementation detail, change wasn't actually rebuilt inside the
// BatchUpdate transaction, but it was rebuilt during read for the
// subsequent reindex. Thus it's impossible to actually observe an
// out-of-date state in the caller.
// assertChangeUpToDate(true, id);
// Check that the bundles are equal.
// ChangeNotes notes = notesFactory.create(dbProvider.get(), project, id);
// ChangeBundle actual = ChangeBundle.fromNotes(commentsUtil, notes);
// ChangeBundle expected = bundleReader.fromReviewDb(getUnwrappedDb(), id);
// assertThat(actual.differencesFrom(expected)).isEmpty();
// assertThat(
// Iterables.transform(
// notes.getChangeMessages(),
// ChangeMessage::getMessage))
// .contains(msg);
// assertThat(actual.getChange().getTopic()).isEqualTo(topic);
}
#end_block

#method_before
@Test
public void commentBeforeFirstPatchSet() throws Exception {
    PushOneCommit.Result r = createChange();
    PatchSet.Id psId = r.getPatchSetId();
    Change.Id id = psId.getParentKey();
    Change c = db.changes().get(id);
    c.setCreatedOn(new Timestamp(c.getCreatedOn().getTime() - 5000));
    db.changes().update(Collections.singleton(c));
    indexer.index(db, project, id);
    ReviewInput rin = new ReviewInput();
    rin.message = "comment";
    Timestamp ts = new Timestamp(c.getCreatedOn().getTime() + 2000);
    assertThat(ts).isGreaterThan(c.getCreatedOn());
    assertThat(ts).isLessThan(db.patchSets().get(psId).getCreatedOn());
    RevisionResource revRsrc = parseCurrentRevisionResource(r.getChangeId());
    postReview.get().apply(revRsrc, rin, ts);
    checker.rebuildAndCheckChanges(id);
}
#method_after
@Test
public void commentBeforeFirstPatchSet() throws Exception {
    PushOneCommit.Result r = createChange();
    PatchSet.Id psId = r.getPatchSetId();
    Change.Id id = psId.getParentKey();
    Change c = db.changes().get(id);
    c.setCreatedOn(new Timestamp(c.getCreatedOn().getTime() - 5000));
    db.changes().update(Collections.singleton(c));
    indexer.index(db, project, id);
    ReviewInput rin = new ReviewInput();
    rin.message = "comment";
    Timestamp ts = new Timestamp(c.getCreatedOn().getTime() + 2000);
    assertThat(ts).isGreaterThan(c.getCreatedOn());
    assertThat(ts).isLessThan(db.patchSets().get(psId).getCreatedOn());
    RevisionResource revRsrc = parseCurrentRevisionResource(r.getChangeId());
    postReview.get().apply(batchUpdateFactory, revRsrc, rin, ts);
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void commentPredatingChangeBySomeoneOtherThanOwner() throws Exception {
    PushOneCommit.Result r = createChange();
    PatchSet.Id psId = r.getPatchSetId();
    Change.Id id = psId.getParentKey();
    Change c = db.changes().get(id);
    ReviewInput rin = new ReviewInput();
    rin.message = "comment";
    Timestamp ts = new Timestamp(c.getCreatedOn().getTime() - 10000);
    RevisionResource revRsrc = parseCurrentRevisionResource(r.getChangeId());
    setApiUser(user);
    postReview.get().apply(revRsrc, rin, ts);
    checker.rebuildAndCheckChanges(id);
}
#method_after
@Test
public void commentPredatingChangeBySomeoneOtherThanOwner() throws Exception {
    PushOneCommit.Result r = createChange();
    PatchSet.Id psId = r.getPatchSetId();
    Change.Id id = psId.getParentKey();
    Change c = db.changes().get(id);
    ReviewInput rin = new ReviewInput();
    rin.message = "comment";
    Timestamp ts = new Timestamp(c.getCreatedOn().getTime() - 10000);
    RevisionResource revRsrc = parseCurrentRevisionResource(r.getChangeId());
    setApiUser(user);
    postReview.get().apply(batchUpdateFactory, revRsrc, rin, ts);
    checker.rebuildAndCheckChanges(id);
}
#end_block

#method_before
@Test
public void highestNumberedPatchSetIsNotCurrent() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PatchSet.Id psId1 = r1.getPatchSetId();
    Change.Id id = psId1.getParentKey();
    PushOneCommit.Result r2 = amendChange(r1.getChangeId());
    PatchSet.Id psId2 = r2.getPatchSetId();
    try (BatchUpdate bu = batchUpdateFactory.create(db, project, identifiedUserFactory.create(user.getId()), TimeUtil.nowTs())) {
        bu.addOp(id, new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws PatchSetInfoNotAvailableException {
                ctx.getChange().setCurrentPatchSet(patchSetInfoFactory.get(ctx.getDb(), ctx.getNotes(), psId1));
                return true;
            }
        });
        bu.execute();
    }
    ChangeNotes notes = notesFactory.create(db, project, id);
    assertThat(psUtil.byChangeAsMap(db, notes).keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(psId1);
    assertThat(db.changes().get(id).currentPatchSetId()).isEqualTo(psId1);
    checker.rebuildAndCheckChanges(id);
    setNotesMigration(true, true);
    notes = notesFactory.create(db, project, id);
    assertThat(psUtil.byChangeAsMap(db, notes).keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(psId1);
}
#method_after
@Test
public void highestNumberedPatchSetIsNotCurrent() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PatchSet.Id psId1 = r1.getPatchSetId();
    Change.Id id = psId1.getParentKey();
    PushOneCommit.Result r2 = amendChange(r1.getChangeId());
    PatchSet.Id psId2 = r2.getPatchSetId();
    try (BatchUpdate bu = batchUpdateFactory.create(db, project, identifiedUserFactory.create(user.getId()), TimeUtil.nowTs())) {
        bu.addOp(id, new BatchUpdateOp() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws PatchSetInfoNotAvailableException {
                ctx.getChange().setCurrentPatchSet(patchSetInfoFactory.get(ctx.getDb(), ctx.getNotes(), psId1));
                return true;
            }
        });
        bu.execute();
    }
    ChangeNotes notes = notesFactory.create(db, project, id);
    assertThat(psUtil.byChangeAsMap(db, notes).keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(psId1);
    assertThat(db.changes().get(id).currentPatchSetId()).isEqualTo(psId1);
    checker.rebuildAndCheckChanges(id);
    setNotesMigration(true, true);
    notes = notesFactory.create(db, project, id);
    assertThat(psUtil.byChangeAsMap(db, notes).keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(psId1);
}
#end_block

#method_before
private void assertChangesReadOnly(RestApiException e) throws Exception {
    Throwable cause = e.getCause();
    assertThat(cause).isInstanceOf(UpdateException.class);
    assertThat(cause.getCause()).isInstanceOf(OrmException.class);
    assertThat(cause.getCause()).hasMessage(NoteDbUpdateManager.CHANGES_READ_ONLY);
}
#method_after
private void assertChangesReadOnly(RestApiException e) throws Exception {
    Throwable cause = e.getCause();
    assertThat(cause).isInstanceOf(UpdateException.class);
    assertThat(cause.getCause()).isInstanceOf(OrmException.class);
    assertThat(cause.getCause()).hasMessageThat().isEqualTo(NoteDbUpdateManager.CHANGES_READ_ONLY);
}
#end_block

#method_before
@Test
public void revisionActionsTwoChangesInTopic() throws Exception {
    String changeId = createChangeWithTopic().getChangeId();
    approve(changeId);
    String changeId2 = createChangeWithTopic().getChangeId();
    Map<String, ActionInfo> actions = getActions(changeId);
    commonActionsAssertions(actions);
    if (isSubmitWholeTopicEnabled()) {
        ActionInfo info = actions.get("submit");
        assertThat(info.enabled).isNull();
        assertThat(info.label).isEqualTo("Submit whole topic");
        assertThat(info.method).isEqualTo("POST");
        assertThat(info.title).isEqualTo("This change depends on other " + "changes which are not ready");
    } else {
        noSubmitWholeTopicAssertions(actions, 1);
        assertThat(getActions(changeId2).get("submit")).isNull();
        approve(changeId2);
        noSubmitWholeTopicAssertions(getActions(changeId2), 2);
    }
}
#method_after
@Test
public void revisionActionsTwoChangesInTopic() throws Exception {
    String changeId = createChangeWithTopic().getChangeId();
    approve(changeId);
    String changeId2 = createChangeWithTopic().getChangeId();
    Map<String, ActionInfo> actions = getActions(changeId);
    commonActionsAssertions(actions);
    if (isSubmitWholeTopicEnabled()) {
        ActionInfo info = actions.get("submit");
        assertThat(info.enabled).isNull();
        assertThat(info.label).isEqualTo("Submit whole topic");
        assertThat(info.method).isEqualTo("POST");
        assertThat(info.title).isEqualTo("This change depends on other changes which are not ready");
    } else {
        noSubmitWholeTopicAssertions(actions, 1);
        assertThat(getActions(changeId2).get("submit")).isNull();
        approve(changeId2);
        noSubmitWholeTopicAssertions(getActions(changeId2), 2);
    }
}
#end_block

#method_before
@Test
public void revisionActionsTwoChangesInTopic_conflicting() throws Exception {
    String changeId = createChangeWithTopic().getChangeId();
    approve(changeId);
    // create another change with the same topic
    String changeId2 = createChangeWithTopic(testRepo, "foo2", "touching b", "b.txt", "real content").getChangeId();
    approve(changeId2);
    // collide with the other change in the same topic
    testRepo.reset("HEAD~2");
    String collidingChange = createChangeWithTopic(testRepo, "off_topic", "rewriting file b", "b.txt", "garbage\ngarbage\ngarbage").getChangeId();
    gApi.changes().id(collidingChange).current().review(ReviewInput.approve());
    gApi.changes().id(collidingChange).current().submit();
    Map<String, ActionInfo> actions = getActions(changeId);
    commonActionsAssertions(actions);
    if (isSubmitWholeTopicEnabled()) {
        ActionInfo info = actions.get("submit");
        assertThat(info.enabled).isNull();
        assertThat(info.label).isEqualTo("Submit whole topic");
        assertThat(info.method).isEqualTo("POST");
        assertThat(info.title).isEqualTo("Problems with change(s): 2");
    } else {
        noSubmitWholeTopicAssertions(actions, 1);
    }
}
#method_after
@Test
public void revisionActionsTwoChangesInTopic_conflicting() throws Exception {
    String changeId = createChangeWithTopic().getChangeId();
    approve(changeId);
    // create another change with the same topic
    String changeId2 = createChangeWithTopic(testRepo, "topic", "touching b", "b.txt", "real content").getChangeId();
    int changeNum2 = gApi.changes().id(changeId2).info()._number;
    approve(changeId2);
    // collide with the other change in the same topic
    testRepo.reset("HEAD~2");
    String collidingChange = createChangeWithTopic(testRepo, "off_topic", "rewriting file b", "b.txt", "garbage\ngarbage\ngarbage").getChangeId();
    gApi.changes().id(collidingChange).current().review(ReviewInput.approve());
    gApi.changes().id(collidingChange).current().submit();
    Map<String, ActionInfo> actions = getActions(changeId);
    commonActionsAssertions(actions);
    if (isSubmitWholeTopicEnabled()) {
        ActionInfo info = actions.get("submit");
        assertThat(info.enabled).isNull();
        assertThat(info.label).isEqualTo("Submit whole topic");
        assertThat(info.method).isEqualTo("POST");
        assertThat(info.title).isEqualTo("Problems with change(s): " + changeNum2);
    } else {
        noSubmitWholeTopicAssertions(actions, 1);
    }
}
#end_block

#method_before
private void noSubmitWholeTopicAssertions(Map<String, ActionInfo> actions, int nrChanges) {
    ActionInfo info = actions.get("submit");
    assertThat(info.enabled).isTrue();
    if (nrChanges == 1) {
        assertThat(info.label).isEqualTo("Submit");
    } else {
        assertThat(info.label).isEqualTo("Submit including parents");
    }
    assertThat(info.method).isEqualTo("POST");
    if (nrChanges == 1) {
        assertThat(info.title).isEqualTo("Submit patch set 1 into master");
    } else {
        assertThat(info.title).isEqualTo(String.format("Submit patch set 1 and ancestors (%d changes " + "altogether) into master", nrChanges));
    }
}
#method_after
private void noSubmitWholeTopicAssertions(Map<String, ActionInfo> actions, int nrChanges) {
    ActionInfo info = actions.get("submit");
    assertThat(info.enabled).isTrue();
    if (nrChanges == 1) {
        assertThat(info.label).isEqualTo("Submit");
    } else {
        assertThat(info.label).isEqualTo("Submit including parents");
    }
    assertThat(info.method).isEqualTo("POST");
    if (nrChanges == 1) {
        assertThat(info.title).isEqualTo("Submit patch set 1 into master");
    } else {
        assertThat(info.title).isEqualTo(String.format("Submit patch set 1 and ancestors (%d changes altogether) into master", nrChanges));
    }
}
#end_block

#method_before
@Test
public void changeActionVisitor() throws Exception {
    String id = createChange().getChangeId();
    ChangeInfo origChange = gApi.changes().id(id).get(EnumSet.of(ListChangesOption.CHANGE_ACTIONS));
    class Visitor implements ActionVisitor {

        @Override
        public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo) {
            assertThat(changeInfo).isNotNull();
            assertThat(changeInfo._number).isEqualTo(origChange._number);
            if (name.equals("followup")) {
                return false;
            }
            if (name.equals("abandon")) {
                actionInfo.label = "Abandon All Hope";
            }
            return true;
        }

        @Override
        public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
            throw new UnsupportedOperationException();
        }
    }
    Map<String, ActionInfo> origActions = origChange.actions;
    assertThat(origActions.keySet()).containsAllOf("followup", "abandon");
    assertThat(origActions.get("abandon").label).isEqualTo("Abandon");
    Visitor v = new Visitor();
    visitorHandle = actionVisitors.add(v);
    Map<String, ActionInfo> newActions = gApi.changes().id(id).get(EnumSet.of(ListChangesOption.CHANGE_ACTIONS)).actions;
    Set<String> expectedNames = new TreeSet<>(origActions.keySet());
    expectedNames.remove("followup");
    assertThat(newActions.keySet()).isEqualTo(expectedNames);
    ActionInfo abandon = newActions.get("abandon");
    assertThat(abandon).isNotNull();
    assertThat(abandon.label).isEqualTo("Abandon All Hope");
}
#method_after
@Test
public void changeActionVisitor() throws Exception {
    String id = createChange().getChangeId();
    ChangeInfo origChange = gApi.changes().id(id).get(CHANGE_ACTIONS);
    class Visitor implements ActionVisitor {

        @Override
        public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo) {
            assertThat(changeInfo).isNotNull();
            assertThat(changeInfo._number).isEqualTo(origChange._number);
            if (name.equals("followup")) {
                return false;
            }
            if (name.equals("abandon")) {
                actionInfo.label = "Abandon All Hope";
            }
            return true;
        }

        @Override
        public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
            throw new UnsupportedOperationException();
        }
    }
    Map<String, ActionInfo> origActions = origChange.actions;
    assertThat(origActions.keySet()).containsAllOf("followup", "abandon");
    assertThat(origActions.get("abandon").label).isEqualTo("Abandon");
    Visitor v = new Visitor();
    visitorHandle = actionVisitors.add(v);
    Map<String, ActionInfo> newActions = gApi.changes().id(id).get(EnumSet.of(ListChangesOption.CHANGE_ACTIONS)).actions;
    Set<String> expectedNames = new TreeSet<>(origActions.keySet());
    expectedNames.remove("followup");
    assertThat(newActions.keySet()).isEqualTo(expectedNames);
    ActionInfo abandon = newActions.get("abandon");
    assertThat(abandon).isNotNull();
    assertThat(abandon.label).isEqualTo("Abandon All Hope");
}
#end_block

#method_before
@Override
public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
    assertThat(changeInfo).isNotNull();
    assertThat(changeInfo._number).isEqualTo(origChange._number);
    assertThat(revisionInfo).isNotNull();
    assertThat(revisionInfo._number).isEqualTo(1);
    if (name.equals("cherrypick")) {
        return false;
    }
    if (name.equals("rebase")) {
        actionInfo.label = "All Your Base";
    }
    return true;
}
#method_after
@Override
public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
    assertThat(changeInfo).isNotNull();
    assertThat(changeInfo._number).isEqualTo(origChange._number);
    assertThat(revisionInfo).isNotNull();
    assertThat(revisionInfo._number).isEqualTo(2);
    if (name.equals("cherrypick")) {
        return false;
    }
    if (name.equals("rebase")) {
        actionInfo.label = "All Your Base";
    }
    return true;
}
#end_block

#method_before
@Override
public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo, RevisionInfo revisionInfo) {
    assertThat(changeInfo).isNotNull();
    assertThat(changeInfo._number).isEqualTo(origChange._number);
    assertThat(revisionInfo).isNotNull();
    assertThat(revisionInfo._number).isEqualTo(1);
    if (name.equals("cherrypick")) {
        return false;
    }
    if (name.equals("rebase")) {
        actionInfo.label = "All Your Base";
    }
    return true;
}
#method_after
@Override
public boolean visit(String name, ActionInfo actionInfo, ChangeInfo changeInfo) {
    // Do nothing; implicitly called for CURRENT_ACTIONS.
    return true;
}
#end_block

#method_before
@Test
public void submitOnPush() throws Exception {
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/master");
    PushOneCommit.Result r = pushTo("refs/for/master%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
}
#method_after
@Test
public void submitOnPush() throws Exception {
    grant(project, "refs/for/refs/heads/master", Permission.SUBMIT);
    PushOneCommit.Result r = pushTo("refs/for/master%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
}
#end_block

#method_before
@Test
public void submitOnPushWithTag() throws Exception {
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/master");
    grant(Permission.CREATE, project, "refs/tags/*");
    grant(Permission.PUSH, project, "refs/tags/*");
    PushOneCommit.Tag tag = new PushOneCommit.Tag("v1.0");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo);
    push.setTag(tag);
    PushOneCommit.Result r = push.to("refs/for/master%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
    assertTag(project, "refs/heads/master", tag);
}
#method_after
@Test
public void submitOnPushWithTag() throws Exception {
    grant(project, "refs/for/refs/heads/master", Permission.SUBMIT);
    grant(project, "refs/tags/*", Permission.CREATE);
    grant(project, "refs/tags/*", Permission.PUSH);
    PushOneCommit.Tag tag = new PushOneCommit.Tag("v1.0");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo);
    push.setTag(tag);
    PushOneCommit.Result r = push.to("refs/for/master%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
    assertTag(project, "refs/heads/master", tag);
}
#end_block

#method_before
@Test
public void submitOnPushWithAnnotatedTag() throws Exception {
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/master");
    grant(Permission.PUSH, project, "refs/tags/*");
    PushOneCommit.AnnotatedTag tag = new PushOneCommit.AnnotatedTag("v1.0", "annotation", admin.getIdent());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo);
    push.setTag(tag);
    PushOneCommit.Result r = push.to("refs/for/master%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
    assertTag(project, "refs/heads/master", tag);
}
#method_after
@Test
public void submitOnPushWithAnnotatedTag() throws Exception {
    grant(project, "refs/for/refs/heads/master", Permission.SUBMIT);
    grant(project, "refs/tags/*", Permission.PUSH);
    PushOneCommit.AnnotatedTag tag = new PushOneCommit.AnnotatedTag("v1.0", "annotation", admin.getIdent());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo);
    push.setTag(tag);
    PushOneCommit.Result r = push.to("refs/for/master%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
    assertTag(project, "refs/heads/master", tag);
}
#end_block

#method_before
@Test
public void submitOnPushToRefsMetaConfig() throws Exception {
    grant(Permission.SUBMIT, project, "refs/for/refs/meta/config");
    git().fetch().setRefSpecs(new RefSpec("refs/meta/config:refs/meta/config")).call();
    testRepo.reset(RefNames.REFS_CONFIG);
    PushOneCommit.Result r = pushTo("refs/for/refs/meta/config%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, RefNames.REFS_CONFIG);
}
#method_after
@Test
public void submitOnPushToRefsMetaConfig() throws Exception {
    grant(project, "refs/for/refs/meta/config", Permission.SUBMIT);
    git().fetch().setRefSpecs(new RefSpec("refs/meta/config:refs/meta/config")).call();
    testRepo.reset(RefNames.REFS_CONFIG);
    PushOneCommit.Result r = pushTo("refs/for/refs/meta/config%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, RefNames.REFS_CONFIG);
}
#end_block

#method_before
@Test
public void submitOnPushMergeConflict() throws Exception {
    ObjectId objectId = repo().exactRef("HEAD").getObjectId();
    push("refs/heads/master", "one change", "a.txt", "some content");
    testRepo.reset(objectId);
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/master");
    PushOneCommit.Result r = push("refs/for/master%submit", "other change", "a.txt", "other content");
    r.assertErrorStatus();
    r.assertChange(Change.Status.NEW, null);
    r.assertMessage("Change " + r.getChange().getId() + ": change could not be merged due to a path conflict.");
}
#method_after
@Test
public void submitOnPushMergeConflict() throws Exception {
    ObjectId objectId = repo().exactRef("HEAD").getObjectId();
    push("refs/heads/master", "one change", "a.txt", "some content");
    testRepo.reset(objectId);
    grant(project, "refs/for/refs/heads/master", Permission.SUBMIT);
    PushOneCommit.Result r = push("refs/for/master%submit", "other change", "a.txt", "other content");
    r.assertErrorStatus();
    r.assertChange(Change.Status.NEW, null);
    r.assertMessage("Change " + r.getChange().getId() + ": change could not be merged due to a path conflict.");
}
#end_block

#method_before
@Test
public void submitOnPushSuccessfulMerge() throws Exception {
    String master = "refs/heads/master";
    ObjectId objectId = repo().exactRef("HEAD").getObjectId();
    push(master, "one change", "a.txt", "some content");
    testRepo.reset(objectId);
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/master");
    PushOneCommit.Result r = push("refs/for/master%submit", "other change", "b.txt", "other content");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertMergeCommit(master, "other change");
}
#method_after
@Test
public void submitOnPushSuccessfulMerge() throws Exception {
    String master = "refs/heads/master";
    ObjectId objectId = repo().exactRef("HEAD").getObjectId();
    push(master, "one change", "a.txt", "some content");
    testRepo.reset(objectId);
    grant(project, "refs/for/refs/heads/master", Permission.SUBMIT);
    PushOneCommit.Result r = push("refs/for/master%submit", "other change", "b.txt", "other content");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertMergeCommit(master, "other change");
}
#end_block

#method_before
@Test
public void submitOnPushNewPatchSet() throws Exception {
    PushOneCommit.Result r = push("refs/for/master", PushOneCommit.SUBJECT, "a.txt", "some content");
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/master");
    r = push("refs/for/master%submit", PushOneCommit.SUBJECT, "a.txt", "other content", r.getChangeId());
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    ChangeData cd = Iterables.getOnlyElement(queryProvider.get().byKeyPrefix(r.getChangeId()));
    assertThat(cd.patchSets()).hasSize(2);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
}
#method_after
@Test
public void submitOnPushNewPatchSet() throws Exception {
    PushOneCommit.Result r = push("refs/for/master", PushOneCommit.SUBJECT, "a.txt", "some content");
    grant(project, "refs/for/refs/heads/master", Permission.SUBMIT);
    r = push("refs/for/master%submit", PushOneCommit.SUBJECT, "a.txt", "other content", r.getChangeId());
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    ChangeData cd = Iterables.getOnlyElement(queryProvider.get().byKeyPrefix(r.getChangeId()));
    assertThat(cd.patchSets()).hasSize(2);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
}
#end_block

#method_before
@Test
public void submitOnPushNotAllowed_Error() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master%submit");
    r.assertErrorStatus("submit not allowed");
}
#method_after
@Test
public void submitOnPushNotAllowed_Error() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master%submit");
    r.assertErrorStatus("update by submit not permitted");
}
#end_block

#method_before
@Test
public void submitOnPushNewPatchSetNotAllowed_Error() throws Exception {
    PushOneCommit.Result r = push("refs/for/master", PushOneCommit.SUBJECT, "a.txt", "some content");
    r = push("refs/for/master%submit", PushOneCommit.SUBJECT, "a.txt", "other content", r.getChangeId());
    r.assertErrorStatus("submit not allowed");
}
#method_after
@Test
public void submitOnPushNewPatchSetNotAllowed_Error() throws Exception {
    PushOneCommit.Result r = push("refs/for/master", PushOneCommit.SUBJECT, "a.txt", "some content");
    r = push("refs/for/master%submit", PushOneCommit.SUBJECT, "a.txt", "other content", r.getChangeId());
    r.assertErrorStatus("update by submit not permitted");
}
#end_block

#method_before
@Test
public void mergeOnPushToBranch() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    PushOneCommit.Result r = push("refs/for/master", PushOneCommit.SUBJECT, "a.txt", "some content");
    r.assertOkStatus();
    git().push().setRefSpecs(new RefSpec(r.getCommit().name() + ":refs/heads/master")).call();
    assertCommit(project, "refs/heads/master");
    ChangeData cd = Iterables.getOnlyElement(queryProvider.get().byKey(new Change.Key(r.getChangeId())));
    RevCommit c = r.getCommit();
    PatchSet.Id psId = cd.currentPatchSet().getId();
    assertThat(psId.get()).isEqualTo(1);
    assertThat(cd.change().getStatus()).isEqualTo(Change.Status.MERGED);
    assertSubmitApproval(psId);
    assertThat(cd.patchSets()).hasSize(1);
    assertThat(cd.patchSet(psId).getRevision().get()).isEqualTo(c.name());
}
#method_after
@Test
public void mergeOnPushToBranch() throws Exception {
    grant(project, "refs/heads/master", Permission.PUSH);
    PushOneCommit.Result r = push("refs/for/master", PushOneCommit.SUBJECT, "a.txt", "some content");
    r.assertOkStatus();
    git().push().setRefSpecs(new RefSpec(r.getCommit().name() + ":refs/heads/master")).call();
    assertCommit(project, "refs/heads/master");
    ChangeData cd = Iterables.getOnlyElement(queryProvider.get().byKey(new Change.Key(r.getChangeId())));
    RevCommit c = r.getCommit();
    PatchSet.Id psId = cd.currentPatchSet().getId();
    assertThat(psId.get()).isEqualTo(1);
    assertThat(cd.change().getStatus()).isEqualTo(Change.Status.MERGED);
    assertSubmitApproval(psId);
    assertThat(cd.patchSets()).hasSize(1);
    assertThat(cd.patchSet(psId).getRevision().get()).isEqualTo(c.name());
}
#end_block

#method_before
@Test
public void mergeOnPushToBranchWithNewPatchset() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    RevCommit c1 = r.getCommit();
    PatchSet.Id psId1 = r.getPatchSetId();
    assertThat(psId1.get()).isEqualTo(1);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/heads/master");
    r.assertOkStatus();
    ChangeData cd = r.getChange();
    RevCommit c2 = r.getCommit();
    assertThat(cd.change().getStatus()).isEqualTo(Change.Status.MERGED);
    PatchSet.Id psId2 = cd.change().currentPatchSetId();
    assertThat(psId2.get()).isEqualTo(2);
    assertCommit(project, "refs/heads/master");
    assertSubmitApproval(psId2);
    assertThat(cd.patchSets()).hasSize(2);
    assertThat(cd.patchSet(psId1).getRevision().get()).isEqualTo(c1.name());
    assertThat(cd.patchSet(psId2).getRevision().get()).isEqualTo(c2.name());
}
#method_after
@Test
public void mergeOnPushToBranchWithNewPatchset() throws Exception {
    grant(project, "refs/heads/master", Permission.PUSH);
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    RevCommit c1 = r.getCommit();
    PatchSet.Id psId1 = r.getPatchSetId();
    assertThat(psId1.get()).isEqualTo(1);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/heads/master");
    r.assertOkStatus();
    ChangeData cd = r.getChange();
    RevCommit c2 = r.getCommit();
    assertThat(cd.change().getStatus()).isEqualTo(Change.Status.MERGED);
    PatchSet.Id psId2 = cd.change().currentPatchSetId();
    assertThat(psId2.get()).isEqualTo(2);
    assertCommit(project, "refs/heads/master");
    assertSubmitApproval(psId2);
    assertThat(cd.patchSets()).hasSize(2);
    assertThat(cd.patchSet(psId1).getRevision().get()).isEqualTo(c1.name());
    assertThat(cd.patchSet(psId2).getRevision().get()).isEqualTo(c2.name());
}
#end_block

#method_before
@Test
public void mergeOnPushToBranchWithOldPatchset() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    RevCommit c1 = r.getCommit();
    PatchSet.Id psId1 = r.getPatchSetId();
    String changeId = r.getChangeId();
    assertThat(psId1.get()).isEqualTo(1);
    r = amendChange(changeId);
    ChangeData cd = r.getChange();
    PatchSet.Id psId2 = cd.change().currentPatchSetId();
    assertThat(psId2.getParentKey()).isEqualTo(psId1.getParentKey());
    assertThat(psId2.get()).isEqualTo(2);
    testRepo.reset(c1);
    assertPushOk(pushHead(testRepo, "refs/heads/master", false), "refs/heads/master");
    cd = changeDataFactory.create(db, project, psId1.getParentKey());
    Change c = cd.change();
    assertThat(c.getStatus()).isEqualTo(Change.Status.MERGED);
    assertThat(c.currentPatchSetId()).isEqualTo(psId1);
    assertThat(cd.patchSets().stream().map(ps -> ps.getId()).collect(toList())).containsExactly(psId1, psId2);
}
#method_after
@Test
public void mergeOnPushToBranchWithOldPatchset() throws Exception {
    grant(project, "refs/heads/master", Permission.PUSH);
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    RevCommit c1 = r.getCommit();
    PatchSet.Id psId1 = r.getPatchSetId();
    String changeId = r.getChangeId();
    assertThat(psId1.get()).isEqualTo(1);
    r = amendChange(changeId);
    ChangeData cd = r.getChange();
    PatchSet.Id psId2 = cd.change().currentPatchSetId();
    assertThat(psId2.getParentKey()).isEqualTo(psId1.getParentKey());
    assertThat(psId2.get()).isEqualTo(2);
    testRepo.reset(c1);
    assertPushOk(pushHead(testRepo, "refs/heads/master", false), "refs/heads/master");
    cd = changeDataFactory.create(db, project, psId1.getParentKey());
    Change c = cd.change();
    assertThat(c.getStatus()).isEqualTo(Change.Status.MERGED);
    assertThat(c.currentPatchSetId()).isEqualTo(psId1);
    assertThat(cd.patchSets().stream().map(ps -> ps.getId()).collect(toList())).containsExactly(psId1, psId2);
}
#end_block

#method_before
@Test
public void mergeMultipleOnPushToBranchWithNewPatchset() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    // Create 2 changes.
    ObjectId initialHead = getRemoteHead();
    PushOneCommit.Result r1 = createChange("Change 1", "a", "a");
    r1.assertOkStatus();
    PushOneCommit.Result r2 = createChange("Change 2", "b", "b");
    r2.assertOkStatus();
    RevCommit c1_1 = r1.getCommit();
    RevCommit c2_1 = r2.getCommit();
    PatchSet.Id psId1_1 = r1.getPatchSetId();
    PatchSet.Id psId2_1 = r2.getPatchSetId();
    assertThat(c1_1.getParent(0)).isEqualTo(initialHead);
    assertThat(c2_1.getParent(0)).isEqualTo(c1_1);
    // Amend both changes.
    testRepo.reset(initialHead);
    RevCommit c1_2 = testRepo.branch("HEAD").commit().message(c1_1.getShortMessage() + "v2").insertChangeId(r1.getChangeId().substring(1)).create();
    RevCommit c2_2 = testRepo.cherryPick(c2_1);
    // Push directly to branch.
    assertPushOk(pushHead(testRepo, "refs/heads/master", false), "refs/heads/master");
    ChangeData cd2 = r2.getChange();
    assertThat(cd2.change().getStatus()).isEqualTo(Change.Status.MERGED);
    PatchSet.Id psId2_2 = cd2.change().currentPatchSetId();
    assertThat(psId2_2.get()).isEqualTo(2);
    assertThat(cd2.patchSet(psId2_1).getRevision().get()).isEqualTo(c2_1.name());
    assertThat(cd2.patchSet(psId2_2).getRevision().get()).isEqualTo(c2_2.name());
    ChangeData cd1 = r1.getChange();
    assertThat(cd1.change().getStatus()).isEqualTo(Change.Status.MERGED);
    PatchSet.Id psId1_2 = cd1.change().currentPatchSetId();
    assertThat(psId1_2.get()).isEqualTo(2);
    assertThat(cd1.patchSet(psId1_1).getRevision().get()).isEqualTo(c1_1.name());
    assertThat(cd1.patchSet(psId1_2).getRevision().get()).isEqualTo(c1_2.name());
}
#method_after
@Test
public void mergeMultipleOnPushToBranchWithNewPatchset() throws Exception {
    grant(project, "refs/heads/master", Permission.PUSH);
    // Create 2 changes.
    ObjectId initialHead = getRemoteHead();
    PushOneCommit.Result r1 = createChange("Change 1", "a", "a");
    r1.assertOkStatus();
    PushOneCommit.Result r2 = createChange("Change 2", "b", "b");
    r2.assertOkStatus();
    RevCommit c1_1 = r1.getCommit();
    RevCommit c2_1 = r2.getCommit();
    PatchSet.Id psId1_1 = r1.getPatchSetId();
    PatchSet.Id psId2_1 = r2.getPatchSetId();
    assertThat(c1_1.getParent(0)).isEqualTo(initialHead);
    assertThat(c2_1.getParent(0)).isEqualTo(c1_1);
    // Amend both changes.
    testRepo.reset(initialHead);
    RevCommit c1_2 = testRepo.branch("HEAD").commit().message(c1_1.getShortMessage() + "v2").insertChangeId(r1.getChangeId().substring(1)).create();
    RevCommit c2_2 = testRepo.cherryPick(c2_1);
    // Push directly to branch.
    assertPushOk(pushHead(testRepo, "refs/heads/master", false), "refs/heads/master");
    ChangeData cd2 = r2.getChange();
    assertThat(cd2.change().getStatus()).isEqualTo(Change.Status.MERGED);
    PatchSet.Id psId2_2 = cd2.change().currentPatchSetId();
    assertThat(psId2_2.get()).isEqualTo(2);
    assertThat(cd2.patchSet(psId2_1).getRevision().get()).isEqualTo(c2_1.name());
    assertThat(cd2.patchSet(psId2_2).getRevision().get()).isEqualTo(c2_2.name());
    ChangeData cd1 = r1.getChange();
    assertThat(cd1.change().getStatus()).isEqualTo(Change.Status.MERGED);
    PatchSet.Id psId1_2 = cd1.change().currentPatchSetId();
    assertThat(psId1_2.get()).isEqualTo(2);
    assertThat(cd1.patchSet(psId1_1).getRevision().get()).isEqualTo(c1_1.name());
    assertThat(cd1.patchSet(psId1_2).getRevision().get()).isEqualTo(c1_2.name());
}
#end_block

#method_before
Account.Id getAccountId() {
    return id;
}
#method_after
protected Account.Id getAccountId() {
    return id;
}
#end_block

#method_before
@Test
public void notificationsOnChangeCreation() throws Exception {
    setApiUser(user);
    watch(project.get(), null);
    // check that watcher is notified
    setApiUser(admin);
    assertCreateSucceeds(newChangeInput(ChangeStatus.NEW));
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has uploaded this change for review.");
    // check that watcher is not notified if notify=NONE
    sender.clear();
    ChangeInput input = newChangeInput(ChangeStatus.NEW);
    input.notify = NotifyHandling.NONE;
    assertCreateSucceeds(input);
    assertThat(sender.getMessages()).isEmpty();
}
#method_after
@Test
public void notificationsOnChangeCreation() throws Exception {
    setApiUser(user);
    watch(project.get());
    // check that watcher is notified
    setApiUser(admin);
    assertCreateSucceeds(newChangeInput(ChangeStatus.NEW));
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains(admin.fullName + " has uploaded this change for review.");
    // check that watcher is not notified if notify=NONE
    sender.clear();
    ChangeInput input = newChangeInput(ChangeStatus.NEW);
    input.notify = NotifyHandling.NONE;
    assertCreateSucceeds(input);
    assertThat(sender.getMessages()).isEmpty();
}
#end_block

#method_before
private ChangeInfo assertCreateSucceeds(ChangeInput in) throws Exception {
    ChangeInfo out = gApi.changes().create(in).get();
    assertThat(out.project).isEqualTo(in.project);
    assertThat(out.branch).isEqualTo(in.branch);
    assertThat(out.subject).isEqualTo(in.subject);
    assertThat(out.topic).isEqualTo(in.topic);
    assertThat(out.status).isEqualTo(in.status);
    assertThat(out.revisions).hasSize(1);
    assertThat(out.submitted).isNull();
    return out;
}
#method_after
private ChangeInfo assertCreateSucceeds(ChangeInput in) throws Exception {
    ChangeInfo out = gApi.changes().create(in).get();
    assertThat(out.project).isEqualTo(in.project);
    assertThat(out.branch).isEqualTo(in.branch);
    assertThat(out.subject).isEqualTo(in.subject);
    assertThat(out.topic).isEqualTo(in.topic);
    assertThat(out.status).isEqualTo(in.status);
    assertThat(out.isPrivate).isEqualTo(in.isPrivate);
    assertThat(out.workInProgress).isEqualTo(in.workInProgress);
    assertThat(out.revisions).hasSize(1);
    assertThat(out.submitted).isNull();
    assertThat(in.status).isEqualTo(ChangeStatus.NEW);
    return out;
}
#end_block

#method_before
private void changeInTwoBranches(String branchA, String fileA, String branchB, String fileB) throws Exception {
    // create a initial commit in master
    Result initialCommit = pushFactory.create(db, user.getIdent(), testRepo, "initial commit", "readme.txt", "initial commit").to("refs/heads/master");
    initialCommit.assertOkStatus();
    // create two new branches
    createBranch(new Branch.NameKey(project, branchA));
    createBranch(new Branch.NameKey(project, branchB));
    // create a commit in branchA
    Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", fileA, "A content").to("refs/heads/" + branchA);
    changeA.assertOkStatus();
    // create a commit in branchB
    PushOneCommit commitB = pushFactory.create(db, user.getIdent(), testRepo, "change B", fileB, "B content");
    commitB.setParent(initialCommit.getCommit());
    Result changeB = commitB.to("refs/heads/" + branchB);
    changeB.assertOkStatus();
}
#method_after
private Map<String, Result> changeInTwoBranches(String branchA, String fileA, String branchB, String fileB) throws Exception {
    // create a initial commit in master
    Result initialCommit = pushFactory.create(db, user.getIdent(), testRepo, "initial commit", "readme.txt", "initial commit").to("refs/heads/master");
    initialCommit.assertOkStatus();
    // create two new branches
    createBranch(new Branch.NameKey(project, branchA));
    createBranch(new Branch.NameKey(project, branchB));
    // create a commit in branchA
    Result changeA = pushFactory.create(db, user.getIdent(), testRepo, "change A", fileA, "A content").to("refs/heads/" + branchA);
    changeA.assertOkStatus();
    // create a commit in branchB
    PushOneCommit commitB = pushFactory.create(db, user.getIdent(), testRepo, "change B", fileB, "B content");
    commitB.setParent(initialCommit.getCommit());
    Result changeB = commitB.to("refs/heads/" + branchB);
    changeB.assertOkStatus();
    return ImmutableMap.of("master", initialCommit, branchA, changeA, branchB, changeB);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    patchSetLock = Util.patchSetLock();
    cfg.getLabelSections().put(patchSetLock.getName(), patchSetLock);
    AccountGroup.UUID anonymousUsers = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(patchSetLock.getName()), 0, 1, anonymousUsers, "refs/heads/*");
    saveProjectConfig(cfg);
    grant(Permission.LABEL + "Patch-Set-Lock", project, "refs/heads/*");
}
#method_after
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    patchSetLock = Util.patchSetLock();
    cfg.getLabelSections().put(patchSetLock.getName(), patchSetLock);
    AccountGroup.UUID anonymousUsers = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(patchSetLock.getName()), 0, 1, anonymousUsers, "refs/heads/*");
    saveProjectConfig(cfg);
    grant(project, "refs/heads/*", Permission.LABEL + "Patch-Set-Lock");
}
#end_block

#method_before
@Test
@TestProjectInput(createEmptyCommit = false)
public void pushInitialCommitForMasterBranch() throws Exception {
    RevCommit c = testRepo.commit().message("Initial commit").insertChangeId().create();
    String id = GitUtil.getChangeId(testRepo, c).get();
    testRepo.reset(c);
    String r = "refs/for/master";
    PushResult pr = pushHead(testRepo, r, false);
    assertPushOk(pr, r);
    ChangeInfo change = gApi.changes().id(id).info();
    assertThat(change.branch).isEqualTo("master");
    assertThat(change.status).isEqualTo(ChangeStatus.NEW);
    try (Repository repo = repoManager.openRepository(project)) {
        assertThat(repo.resolve("master")).isNull();
    }
}
#method_after
@Test
@TestProjectInput(createEmptyCommit = false)
public void pushInitialCommitForMasterBranch() throws Exception {
    RevCommit c = testRepo.commit().message("Initial commit").insertChangeId().create();
    String id = GitUtil.getChangeId(testRepo, c).get();
    testRepo.reset(c);
    String r = "refs/for/master";
    PushResult pr = pushHead(testRepo, r, false);
    assertPushOk(pr, r);
    ChangeInfo change = gApi.changes().id(id).info();
    assertThat(change.branch).isEqualTo("master");
    assertThat(change.status).isEqualTo(ChangeStatus.NEW);
    try (Repository repo = repoManager.openRepository(project)) {
        assertThat(repo.resolve("master")).isNull();
    }
    gApi.changes().id(change.id).current().review(ReviewInput.approve());
    gApi.changes().id(change.id).current().submit();
    try (Repository repo = repoManager.openRepository(project)) {
        assertThat(repo.resolve("master")).isEqualTo(c);
    }
}
#end_block

#method_before
@Test
public void output() throws Exception {
    String url = canonicalWebUrl.get();
    ObjectId initialHead = testRepo.getRepository().resolve("HEAD");
    PushOneCommit.Result r1 = pushTo("refs/for/master");
    Change.Id id1 = r1.getChange().getId();
    r1.assertOkStatus();
    r1.assertChange(Change.Status.NEW, null);
    r1.assertMessage("New changes:\n" + "  " + url + id1 + " " + r1.getCommit().getShortMessage() + "\n");
    testRepo.reset(initialHead);
    String newMsg = r1.getCommit().getShortMessage() + " v2";
    testRepo.branch("HEAD").commit().message(newMsg).insertChangeId(r1.getChangeId().substring(1)).create();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, "another commit", "b.txt", "bbb").to("refs/for/master");
    Change.Id id2 = r2.getChange().getId();
    r2.assertOkStatus();
    r2.assertChange(Change.Status.NEW, null);
    r2.assertMessage("New changes:\n" + "  " + url + id2 + " another commit\n" + "\n" + "\n" + "Updated changes:\n" + "  " + url + id1 + " " + newMsg + "\n");
}
#method_after
@Test
public void output() throws Exception {
    String url = canonicalWebUrl.get() + "#/c/" + project.get() + "/+/";
    ObjectId initialHead = testRepo.getRepository().resolve("HEAD");
    PushOneCommit.Result r1 = pushTo("refs/for/master");
    Change.Id id1 = r1.getChange().getId();
    r1.assertOkStatus();
    r1.assertChange(Change.Status.NEW, null);
    r1.assertMessage("New changes:\n  " + url + id1 + " " + r1.getCommit().getShortMessage() + "\n");
    testRepo.reset(initialHead);
    String newMsg = r1.getCommit().getShortMessage() + " v2";
    testRepo.branch("HEAD").commit().message(newMsg).insertChangeId(r1.getChangeId().substring(1)).create();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, "another commit", "b.txt", "bbb").to("refs/for/master");
    Change.Id id2 = r2.getChange().getId();
    r2.assertOkStatus();
    r2.assertChange(Change.Status.NEW, null);
    r2.assertMessage("New changes:\n" + "  " + url + id2 + " another commit\n" + "\n" + "\n" + "Updated changes:\n" + "  " + url + id1 + " " + newMsg + "\n");
}
#end_block

#method_before
@Test
public void pushForMasterWithNotify() throws Exception {
    // create a user that watches the project
    TestAccount user3 = accounts.create("user3", "user3@example.com", "User3");
    List<ProjectWatchInfo> projectsToWatch = new ArrayList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = project.get();
    pwi.filter = "*";
    pwi.notifyNewChanges = true;
    projectsToWatch.add(pwi);
    setApiUser(user3);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    TestAccount user2 = accounts.user2();
    String pushSpec = "refs/for/master" + "%reviewer=" + user.email + ",cc=" + user2.email;
    sender.clear();
    PushOneCommit.Result r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE);
    r.assertOkStatus();
    assertThat(sender.getMessages()).isEmpty();
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.OWNER);
    r.assertOkStatus();
    // no email notification about own changes
    assertThat(sender.getMessages()).isEmpty();
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.OWNER_REVIEWERS);
    r.assertOkStatus();
    assertThat(sender.getMessages()).hasSize(1);
    Message m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.ALL);
    r.assertOkStatus();
    assertThat(sender.getMessages()).hasSize(1);
    m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress, user2.emailAddress, user3.emailAddress);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-to=" + user3.email);
    r.assertOkStatus();
    assertNotifyTo(user3);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-cc=" + user3.email);
    r.assertOkStatus();
    assertNotifyCc(user3);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-bcc=" + user3.email);
    r.assertOkStatus();
    assertNotifyBcc(user3);
    // request that sender gets notified as TO, CC and BCC, email should be sent
    // even if the sender is the only recipient
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-to=" + admin.email);
    assertNotifyTo(admin);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-cc=" + admin.email);
    r.assertOkStatus();
    assertNotifyCc(admin);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-bcc=" + admin.email);
    r.assertOkStatus();
    assertNotifyBcc(admin);
}
#method_after
@Test
public void pushForMasterWithNotify() throws Exception {
    // create a user that watches the project
    TestAccount user3 = accountCreator.create("user3", "user3@example.com", "User3");
    List<ProjectWatchInfo> projectsToWatch = new ArrayList<>();
    ProjectWatchInfo pwi = new ProjectWatchInfo();
    pwi.project = project.get();
    pwi.filter = "*";
    pwi.notifyNewChanges = true;
    projectsToWatch.add(pwi);
    setApiUser(user3);
    gApi.accounts().self().setWatchedProjects(projectsToWatch);
    TestAccount user2 = accountCreator.user2();
    String pushSpec = "refs/for/master%reviewer=" + user.email + ",cc=" + user2.email;
    sender.clear();
    PushOneCommit.Result r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE);
    r.assertOkStatus();
    assertThat(sender.getMessages()).isEmpty();
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.OWNER);
    r.assertOkStatus();
    // no email notification about own changes
    assertThat(sender.getMessages()).isEmpty();
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.OWNER_REVIEWERS);
    r.assertOkStatus();
    assertThat(sender.getMessages()).hasSize(1);
    Message m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.ALL);
    r.assertOkStatus();
    assertThat(sender.getMessages()).hasSize(1);
    m = sender.getMessages().get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress, user2.emailAddress, user3.emailAddress);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-to=" + user3.email);
    r.assertOkStatus();
    assertNotifyTo(user3);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-cc=" + user3.email);
    r.assertOkStatus();
    assertNotifyCc(user3);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-bcc=" + user3.email);
    r.assertOkStatus();
    assertNotifyBcc(user3);
    // request that sender gets notified as TO, CC and BCC, email should be sent
    // even if the sender is the only recipient
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-to=" + admin.email);
    assertNotifyTo(admin);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-cc=" + admin.email);
    r.assertOkStatus();
    assertNotifyCc(admin);
    sender.clear();
    r = pushTo(pushSpec + ",notify=" + NotifyHandling.NONE + ",notify-bcc=" + admin.email);
    r.assertOkStatus();
    assertNotifyBcc(admin);
}
#end_block

#method_before
@Test
public void pushForMasterWithCc() throws Exception {
    // cc one user
    String topic = "my/topic";
    PushOneCommit.Result r = pushTo("refs/for/master/" + topic + "%cc=" + user.email);
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, topic);
    // cc several users
    TestAccount user2 = accounts.create("another-user", "another.user@example.com", "Another User");
    r = pushTo("refs/for/master/" + topic + "%cc=" + admin.email + ",cc=" + user.email + ",cc=" + user2.email);
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, topic);
    // cc non-existing user
    String nonExistingEmail = "non.existing@example.com";
    r = pushTo("refs/for/master/" + topic + "%cc=" + admin.email + ",cc=" + nonExistingEmail + ",cc=" + user.email);
    r.assertErrorStatus("user \"" + nonExistingEmail + "\" not found");
}
#method_after
@Test
public void pushForMasterWithCc() throws Exception {
    // cc one user
    String topic = "my/topic";
    PushOneCommit.Result r = pushTo("refs/for/master/" + topic + "%cc=" + user.email);
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, topic, ImmutableList.of(), ImmutableList.of(user));
    // cc several users
    r = pushTo("refs/for/master/" + topic + "%cc=" + admin.email + ",cc=" + user.email + ",cc=" + accountCreator.user2().email);
    r.assertOkStatus();
    // Check that admin isn't CC'd as they own the change
    r.assertChange(Change.Status.NEW, topic, ImmutableList.of(), ImmutableList.of(user, accountCreator.user2()));
    // cc non-existing user
    String nonExistingEmail = "non.existing@example.com";
    r = pushTo("refs/for/master/" + topic + "%cc=" + admin.email + ",cc=" + nonExistingEmail + ",cc=" + user.email);
    r.assertErrorStatus("user \"" + nonExistingEmail + "\" not found");
}
#end_block

#method_before
@Test
public void pushForMasterWithReviewer() throws Exception {
    // add one reviewer
    String topic = "my/topic";
    PushOneCommit.Result r = pushTo("refs/for/master/" + topic + "%r=" + user.email);
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, topic, user);
    // add several reviewers
    TestAccount user2 = accounts.create("another-user", "another.user@example.com", "Another User");
    r = pushTo("refs/for/master/" + topic + "%r=" + admin.email + ",r=" + user.email + ",r=" + user2.email);
    r.assertOkStatus();
    // admin is the owner of the change and should not appear as reviewer
    r.assertChange(Change.Status.NEW, topic, user, user2);
    // add non-existing user as reviewer
    String nonExistingEmail = "non.existing@example.com";
    r = pushTo("refs/for/master/" + topic + "%r=" + admin.email + ",r=" + nonExistingEmail + ",r=" + user.email);
    r.assertErrorStatus("user \"" + nonExistingEmail + "\" not found");
}
#method_after
@Test
public void pushForMasterWithReviewer() throws Exception {
    // add one reviewer
    String topic = "my/topic";
    PushOneCommit.Result r = pushTo("refs/for/master/" + topic + "%r=" + user.email);
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, topic, user);
    // add several reviewers
    TestAccount user2 = accountCreator.create("another-user", "another.user@example.com", "Another User");
    r = pushTo("refs/for/master/" + topic + "%r=" + admin.email + ",r=" + user.email + ",r=" + user2.email);
    r.assertOkStatus();
    // admin is the owner of the change and should not appear as reviewer
    r.assertChange(Change.Status.NEW, topic, user, user2);
    // add non-existing user as reviewer
    String nonExistingEmail = "non.existing@example.com";
    r = pushTo("refs/for/master/" + topic + "%r=" + admin.email + ",r=" + nonExistingEmail + ",r=" + user.email);
    r.assertErrorStatus("user \"" + nonExistingEmail + "\" not found");
}
#end_block

#method_before
@Test
public void pushForMasterAsEdit() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    Optional<EditInfo> edit = getEdit(r.getChangeId());
    assertThat(edit).isAbsent();
    // specify edit as option
    r = amendChange(r.getChangeId(), "refs/for/master%edit");
    r.assertOkStatus();
    edit = getEdit(r.getChangeId());
    assertThat(edit).isPresent();
    EditInfo editInfo = edit.get();
    r.assertMessage("Updated Changes:\n  " + canonicalWebUrl.get() + r.getChange().getId() + " " + editInfo.commit.subject + " [EDIT]\n");
}
#method_after
@Test
public void pushForMasterAsEdit() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    Optional<EditInfo> edit = getEdit(r.getChangeId());
    assertThat(edit).isAbsent();
    assertThat(query("has:edit")).isEmpty();
    // specify edit as option
    r = amendChange(r.getChangeId(), "refs/for/master%edit");
    r.assertOkStatus();
    edit = getEdit(r.getChangeId());
    assertThat(edit).isPresent();
    EditInfo editInfo = edit.get();
    r.assertMessage("Updated Changes:\n  " + canonicalWebUrl.get() + "#/c/" + project.get() + "/+/" + r.getChange().getId() + " " + editInfo.commit.subject + " [EDIT]\n");
    // verify that the re-indexing was triggered for the change
    assertThat(query("has:edit")).hasSize(1);
}
#end_block

#method_before
@Test
public void pushForMasterWithMessageTwiceWithDifferentMessages() throws Exception {
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setCreateNewChangeForAllNotInTarget(InheritableBoolean.TRUE);
    saveProjectConfig(project, config);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%m=new_test_message");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(2);
    for (RevisionInfo ri : revisions) {
        if (ri.isCurrent) {
            assertThat(ri.description).isEqualTo("new test message");
        } else {
            assertThat(ri.description).isEqualTo("my test message");
        }
    }
}
#method_after
@Test
public void pushForMasterWithMessageTwiceWithDifferentMessages() throws Exception {
    enableCreateNewChangeForAllNotInTarget();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%m=new_test_message");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    Collection<RevisionInfo> revisions = ci.revisions.values();
    assertThat(revisions).hasSize(2);
    for (RevisionInfo ri : revisions) {
        if (ri.isCurrent) {
            assertThat(ri.description).isEqualTo("new test message");
        } else {
            assertThat(ri.description).isEqualTo("my test message");
        }
    }
}
#end_block

#method_before
@Test
public void pushForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(1);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3.");
}
#method_after
@Test
public void pushForMasterWithApprovals() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%l=Code-Review");
    r.assertOkStatus();
    ChangeInfo ci = get(r.getChangeId());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(1);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    cr = ci.labels.get("Code-Review");
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 2: Code-Review+2.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value).isEqualTo(2);
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "c.txt", "moreContent", r.getChangeId());
    r = push.to("refs/for/master/%l=Code-Review+2");
    ci = get(r.getChangeId());
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 3.");
}
#end_block

#method_before
@Test
public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws Exception {
    // Create a commit with "User" as author and committer
    RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    // Push this commit as "Administrator" (requires Forge Committer Identity)
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false);
    // Expected Code-Review votes:
    // 1. 0 from User (committer):
    // When the committer is forged, the committer is automatically added as
    // reviewer, hence we expect a dummy 0 vote for the committer.
    // 2. +1 from Administrator (uploader):
    // On push Code-Review+1 was specified, hence we expect a +1 vote from
    // the uploader.
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(2);
    int indexAdmin = admin.fullName.equals(cr.all.get(0).name) ? 0 : 1;
    int indexUser = indexAdmin == 0 ? 1 : 0;
    assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName);
    assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1);
    assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName);
    assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
}
#method_after
@Test
public void pushForMasterWithApprovalsForgeCommitterButNoForgeVote() throws Exception {
    // Create a commit with "User" as author and committer
    RevCommit c = commitBuilder().author(user.getIdent()).committer(user.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    // Push this commit as "Administrator" (requires Forge Committer Identity)
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1", false);
    // Expected Code-Review votes:
    // 1. 0 from User (committer):
    // When the committer is forged, the committer is automatically added as
    // reviewer, hence we expect a dummy 0 vote for the committer.
    // 2. +1 from Administrator (uploader):
    // On push Code-Review+1 was specified, hence we expect a +1 vote from
    // the uploader.
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(2);
    int indexAdmin = admin.fullName.equals(cr.all.get(0).name) ? 0 : 1;
    int indexUser = indexAdmin == 0 ? 1 : 0;
    assertThat(cr.all.get(indexAdmin).name).isEqualTo(admin.fullName);
    assertThat(cr.all.get(indexAdmin).value.intValue()).isEqualTo(1);
    assertThat(cr.all.get(indexUser).name).isEqualTo(user.fullName);
    assertThat(cr.all.get(indexUser).value.intValue()).isEqualTo(0);
    assertThat(Iterables.getLast(ci.messages).message).isEqualTo("Uploaded patch set 1: Code-Review+1.");
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#end_block

#method_before
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
}
#method_after
@Test
public void pushWithMultipleApprovals() throws Exception {
    LabelType Q = category("Custom-Label", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    AccountGroup.UUID anon = systemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    String heads = "refs/heads/*";
    Util.allow(config, Permission.forLabel("Custom-Label"), -1, 1, anon, heads);
    config.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(project, config);
    RevCommit c = commitBuilder().author(admin.getIdent()).committer(admin.getIdent()).add(PushOneCommit.FILE_NAME, PushOneCommit.FILE_CONTENT).message(PushOneCommit.SUBJECT).create();
    pushHead(testRepo, "refs/for/master/%l=Code-Review+1,l=Custom-Label-1", false);
    ChangeInfo ci = get(GitUtil.getChangeId(testRepo, c).get());
    LabelInfo cr = ci.labels.get("Code-Review");
    assertThat(cr.all).hasSize(1);
    cr = ci.labels.get("Custom-Label");
    assertThat(cr.all).hasSize(1);
    // Check that the user who pushed the change was added as a reviewer since they added a vote
    assertThatUserIsOnlyReviewer(ci, admin);
}
#end_block

#method_before
@Test
public void pushNewPatchsetToPatchSetLockedChange() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    revision(r).review(new ReviewInput().label("Patch-Set-Lock", 1));
    r = push.to("refs/for/master");
    r.assertErrorStatus("cannot add patch set to " + r.getChange().change().getChangeId() + ". Change is patch set locked.");
}
#method_after
@Test
public void pushNewPatchsetToPatchSetLockedChange() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent", r.getChangeId());
    revision(r).review(new ReviewInput().label("Patch-Set-Lock", 1));
    r = push.to("refs/for/master");
    r.assertErrorStatus("cannot add patch set to " + r.getChange().change().getChangeId() + ".");
}
#end_block

#method_before
@Test
public void pushSameCommitTwiceUsingMagicBranchBaseOption() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    PushOneCommit.Result rBase = pushTo("refs/heads/master");
    rBase.assertOkStatus();
    gApi.projects().name(project.get()).branch("foo").create(new BranchInput());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    PushResult pr = GitUtil.pushHead(testRepo, "refs/for/foo%base=" + rBase.getCommit().name(), false, false);
    assertThat(pr.getMessages()).contains("changes: new: 1, refs: 1, done");
    assertTwoChangesWithSameRevision(r);
}
#method_after
@Test
public void pushSameCommitTwiceUsingMagicBranchBaseOption() throws Exception {
    grant(project, "refs/heads/master", Permission.PUSH);
    PushOneCommit.Result rBase = pushTo("refs/heads/master");
    rBase.assertOkStatus();
    gApi.projects().name(project.get()).branch("foo").create(new BranchInput());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    PushResult pr = GitUtil.pushHead(testRepo, "refs/for/foo%base=" + rBase.getCommit().name(), false, false);
    // BatchUpdate implementations differ in how they hook into progress monitors. We mostly just
    // care that there is a new change.
    assertThat(pr.getMessages()).containsMatch("changes: new: 1,( refs: 1)? done");
    assertTwoChangesWithSameRevision(r);
}
#end_block

#method_before
@Test
public void pushAFewChanges() throws Exception {
    int n = 10;
    String r = "refs/for/master";
    ObjectId initialHead = testRepo.getRepository().resolve("HEAD");
    List<RevCommit> commits = createChanges(n, r);
    // Check that a change was created for each.
    for (RevCommit c : commits) {
        assertThat(byCommit(c).change().getSubject()).named("change for " + c.name()).isEqualTo(c.getShortMessage());
    }
    List<RevCommit> commits2 = amendChanges(initialHead, commits, r);
    // Check that there are correct patch sets.
    for (int i = 0; i < n; i++) {
        RevCommit c = commits.get(i);
        RevCommit c2 = commits2.get(i);
        String name = "change for " + c2.name();
        ChangeData cd = byCommit(c);
        assertThat(cd.change().getSubject()).named(name).isEqualTo(c2.getShortMessage());
        assertThat(getPatchSetRevisions(cd)).named(name).containsExactlyEntriesIn(ImmutableMap.of(1, c.name(), 2, c2.name()));
    }
    // Pushing again results in "no new changes".
    assertPushRejected(pushHead(testRepo, r, false), r, "no new changes");
}
#method_after
@Test
public void pushAFewChanges() throws Exception {
    testPushAFewChanges();
}
#end_block

#method_before
private void testPushWithoutChangeId() throws Exception {
    RevCommit c = createCommit(testRepo, "Message without Change-Id");
    assertThat(GitUtil.getChangeId(testRepo, c).isPresent()).isFalse();
    pushForReviewRejected(testRepo, "missing Change-Id in commit message footer");
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setRequireChangeID(InheritableBoolean.FALSE);
    saveProjectConfig(project, config);
    pushForReviewOk(testRepo);
}
#method_after
private void testPushWithoutChangeId() throws Exception {
    RevCommit c = createCommit(testRepo, "Message without Change-Id");
    assertThat(GitUtil.getChangeId(testRepo, c)).isEmpty();
    pushForReviewRejected(testRepo, "missing Change-Id in commit message footer");
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setRequireChangeID(InheritableBoolean.FALSE);
    saveProjectConfig(project, config);
    pushForReviewOk(testRepo);
}
#end_block

#method_before
private void testpushWithInvalidChangeId() throws Exception {
    createCommit(testRepo, "Message with invalid Change-Id\n" + "\n" + "Change-Id: X\n");
    pushForReviewRejected(testRepo, "invalid Change-Id line format in commit message footer");
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setRequireChangeID(InheritableBoolean.FALSE);
    saveProjectConfig(project, config);
    pushForReviewRejected(testRepo, "invalid Change-Id line format in commit message footer");
}
#method_after
private void testpushWithInvalidChangeId() throws Exception {
    createCommit(testRepo, "Message with invalid Change-Id\n\nChange-Id: X\n");
    pushForReviewRejected(testRepo, "invalid Change-Id line format in commit message footer");
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setRequireChangeID(InheritableBoolean.FALSE);
    saveProjectConfig(project, config);
    pushForReviewRejected(testRepo, "invalid Change-Id line format in commit message footer");
}
#end_block

#method_before
@Test
public void createChangeForMergedCommit() throws Exception {
    String master = "refs/heads/master";
    grant(Permission.PUSH, project, master, true);
    // Update master with a direct push.
    RevCommit c1 = testRepo.commit().message("Non-change 1").create();
    RevCommit c2 = testRepo.parseBody(testRepo.commit().parent(c1).message("Non-change 2").insertChangeId().create());
    String changeId = Iterables.getOnlyElement(c2.getFooterLines(CHANGE_ID));
    testRepo.reset(c2);
    assertPushOk(pushHead(testRepo, master, false, true), master);
    String q = "commit:" + c1.name() + " OR commit:" + c2.name() + " OR change:" + changeId;
    assertThat(gApi.changes().query(q).get()).isEmpty();
    // Push c2 as a merged change.
    String r = "refs/for/master%merged";
    assertPushOk(pushHead(testRepo, r, false), r);
    EnumSet<ListChangesOption> opts = EnumSet.of(ListChangesOption.CURRENT_REVISION);
    ChangeInfo info = gApi.changes().id(changeId).get(opts);
    assertThat(info.currentRevision).isEqualTo(c2.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
    // Only c2 was created as a change.
    String q1 = "commit: " + c1.name();
    assertThat(gApi.changes().query(q1).get()).isEmpty();
    // Push c1 as a merged change.
    testRepo.reset(c1);
    assertPushOk(pushHead(testRepo, r, false), r);
    List<ChangeInfo> infos = gApi.changes().query(q1).withOptions(opts).get();
    assertThat(infos).hasSize(1);
    info = infos.get(0);
    assertThat(info.currentRevision).isEqualTo(c1.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
}
#method_after
@Test
public void createChangeForMergedCommit() throws Exception {
    String master = "refs/heads/master";
    grant(project, master, Permission.PUSH, true);
    // Update master with a direct push.
    RevCommit c1 = testRepo.commit().message("Non-change 1").create();
    RevCommit c2 = testRepo.parseBody(testRepo.commit().parent(c1).message("Non-change 2").insertChangeId().create());
    String changeId = Iterables.getOnlyElement(c2.getFooterLines(CHANGE_ID));
    testRepo.reset(c2);
    assertPushOk(pushHead(testRepo, master, false, true), master);
    String q = "commit:" + c1.name() + " OR commit:" + c2.name() + " OR change:" + changeId;
    assertThat(gApi.changes().query(q).get()).isEmpty();
    // Push c2 as a merged change.
    String r = "refs/for/master%merged";
    assertPushOk(pushHead(testRepo, r, false), r);
    EnumSet<ListChangesOption> opts = EnumSet.of(ListChangesOption.CURRENT_REVISION);
    ChangeInfo info = gApi.changes().id(changeId).get(opts);
    assertThat(info.currentRevision).isEqualTo(c2.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
    // Only c2 was created as a change.
    String q1 = "commit: " + c1.name();
    assertThat(gApi.changes().query(q1).get()).isEmpty();
    // Push c1 as a merged change.
    testRepo.reset(c1);
    assertPushOk(pushHead(testRepo, r, false), r);
    List<ChangeInfo> infos = gApi.changes().query(q1).withOptions(opts).get();
    assertThat(infos).hasSize(1);
    info = infos.get(0);
    assertThat(info.currentRevision).isEqualTo(c1.name());
    assertThat(info.status).isEqualTo(ChangeStatus.MERGED);
}
#end_block

#method_before
@Test
public void mergedOptionWithExistingChangeInsertsPatchSet() throws Exception {
    String master = "refs/heads/master";
    grant(Permission.PUSH, project, master, true);
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    ObjectId c1 = r.getCommit().copy();
    // Create a PS2 commit directly on master in the server's repo. This
    // simulates the client amending locally and pushing directly to the branch,
    // expecting the change to be auto-closed, but the change metadata update
    // fails.
    ObjectId c2;
    try (Repository repo = repoManager.openRepository(project)) {
        TestRepository<?> tr = new TestRepository<>(repo);
        RevCommit commit2 = tr.amend(c1).message("New subject").insertChangeId(r.getChangeId().substring(1)).create();
        c2 = commit2.copy();
        tr.update(master, c2);
    }
    testRepo.git().fetch().setRefSpecs(new RefSpec("refs/heads/master")).call();
    testRepo.reset(c2);
    String ref = "refs/for/master%merged";
    assertPushOk(pushHead(testRepo, ref, false), ref);
    EnumSet<ListChangesOption> opts = EnumSet.of(ListChangesOption.ALL_REVISIONS);
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get(opts);
    assertThat(info.currentRevision).isEqualTo(c2.name());
    assertThat(info.revisions.keySet()).containsExactly(c1.name(), c2.name());
    // TODO(dborowitz): Fix ReceiveCommits to also auto-close the change.
    assertThat(info.status).isEqualTo(ChangeStatus.NEW);
}
#method_after
@Test
public void mergedOptionWithExistingChangeInsertsPatchSet() throws Exception {
    String master = "refs/heads/master";
    grant(project, master, Permission.PUSH, true);
    PushOneCommit.Result r = pushTo("refs/for/master");
    r.assertOkStatus();
    ObjectId c1 = r.getCommit().copy();
    // Create a PS2 commit directly on master in the server's repo. This
    // simulates the client amending locally and pushing directly to the branch,
    // expecting the change to be auto-closed, but the change metadata update
    // fails.
    ObjectId c2;
    try (Repository repo = repoManager.openRepository(project)) {
        TestRepository<?> tr = new TestRepository<>(repo);
        RevCommit commit2 = tr.amend(c1).message("New subject").insertChangeId(r.getChangeId().substring(1)).create();
        c2 = commit2.copy();
        tr.update(master, c2);
    }
    testRepo.git().fetch().setRefSpecs(new RefSpec("refs/heads/master")).call();
    testRepo.reset(c2);
    String ref = "refs/for/master%merged";
    assertPushOk(pushHead(testRepo, ref, false), ref);
    ChangeInfo info = gApi.changes().id(r.getChangeId()).get(ALL_REVISIONS);
    assertThat(info.currentRevision).isEqualTo(c2.name());
    assertThat(info.revisions.keySet()).containsExactly(c1.name(), c2.name());
    // TODO(dborowitz): Fix ReceiveCommits to also auto-close the change.
    assertThat(info.status).isEqualTo(ChangeStatus.NEW);
}
#end_block

#method_before
private List<RevCommit> createChanges(int n, String refsFor) throws Exception {
    return createChanges(n, refsFor, ImmutableList.<String>of());
}
#method_after
private List<RevCommit> createChanges(int n, String refsFor) throws Exception {
    return createChanges(n, refsFor, ImmutableList.of());
}
#end_block

#method_before
private List<RevCommit> createChanges(int n, String refsFor, List<String> footerLines) throws Exception {
    List<RevCommit> commits = new ArrayList<>(n);
    for (int i = 1; i <= n; i++) {
        String msg = "Change " + i;
        if (!footerLines.isEmpty()) {
            StringBuilder sb = new StringBuilder(msg).append("\n\n");
            for (String line : footerLines) {
                sb.append(line).append('\n');
            }
            msg = sb.toString();
        }
        TestRepository<?>.CommitBuilder cb = testRepo.branch("HEAD").commit().message(msg).insertChangeId();
        if (!commits.isEmpty()) {
            cb.parent(commits.get(commits.size() - 1));
        }
        RevCommit c = cb.create();
        testRepo.getRevWalk().parseBody(c);
        commits.add(c);
    }
    assertPushOk(pushHead(testRepo, refsFor, false), refsFor);
    return commits;
}
#method_after
private List<RevCommit> createChanges(int n, String refsFor, List<String> footerLines) throws Exception {
    List<RevCommit> commits = initChanges(n, footerLines);
    assertPushOk(pushHead(testRepo, refsFor, false), refsFor);
    return commits;
}
#end_block

#method_before
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = sort(toMerge);
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    boolean first = true;
    for (CodeReviewCommit c : sorted) {
        if (c.getParentCount() > 1) {
            // Since there is a merge commit, sort and prune again using
            // MERGE_IF_NECESSARY semantics to avoid creating duplicate
            // commits.
            // 
            sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, sorted, args.incoming);
            break;
        }
    }
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (first && args.mergeTip.getInitialTip() == null) {
            // TODO(tandrii): Cherry-Pick strategy does this too, but it's wrong
            // and can be fixed.
            ops.add(new FastForwardOp(args, n));
        } else if (n.getParentCount() == 0) {
            ops.add(new RebaseRootOp(n));
        } else if (n.getParentCount() == 1) {
            ops.add(new RebaseOneOp(n));
        } else {
            ops.add(new RebaseMultipleParentsOp(n));
        }
        first = false;
    }
    return ops;
}
#method_after
@Override
public List<SubmitStrategyOp> buildOps(Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted;
    try {
        sorted = args.rebaseSorter.sort(toMerge);
    } catch (IOException e) {
        throw new IntegrationException("Commit sorting failed", e);
    }
    List<SubmitStrategyOp> ops = new ArrayList<>(sorted.size());
    boolean first = true;
    for (CodeReviewCommit c : sorted) {
        if (c.getParentCount() > 1) {
            // Since there is a merge commit, sort and prune again using
            // MERGE_IF_NECESSARY semantics to avoid creating duplicate
            // commits.
            // 
            sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, sorted);
            break;
        }
    }
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (first && args.mergeTip.getInitialTip() == null) {
            // TODO(tandrii): Cherry-Pick strategy does this too, but it's wrong
            // and can be fixed.
            ops.add(new FastForwardOp(args, n));
        } else if (n.getParentCount() == 0) {
            ops.add(new RebaseRootOp(n));
        } else if (n.getParentCount() == 1) {
            ops.add(new RebaseOneOp(n));
        } else {
            ops.add(new RebaseMultipleParentsOp(n));
        }
        first = false;
    }
    return ops;
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, InvalidChangeOperationException, RestApiException, IOException, OrmException {
    // BatchUpdate how to produce CodeReviewRevWalks.
    if (args.mergeUtil.canFastForward(args.mergeSorter, args.mergeTip.getCurrentTip(), args.rw, toMerge)) {
        if (!rebaseAlways) {
            args.mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
            toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            acceptMergeTip(args.mergeTip);
            return;
        }
        // RebaseAlways means we modify commit message.
        args.rw.parseBody(toMerge);
        newPatchSetId = ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId());
        RevCommit mergeTip = args.mergeTip.getCurrentTip();
        args.rw.parseBody(mergeTip);
        String cherryPickCmtMsg = args.mergeUtil.createCommitMessageOnSubmit(toMerge, mergeTip);
        PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
        try {
            newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, true);
        } catch (MergeConflictException mce) {
            // Unlike in Cherry-pick case, this should never happen.
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IllegalStateException("MergeConflictException on message edit must not happen");
        } catch (MergeIdenticalTreeException mie) {
            // this should not happen
            toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
            return;
        }
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSetId.toRefName()));
    } else {
        // Stale read of patch set is ok; see comments in RebaseChangeOp.
        PatchSet origPs = args.psUtil.get(ctx.getDb(), toMerge.getControl().getNotes(), toMerge.getPatchsetId());
        rebaseOp = args.rebaseFactory.create(toMerge.getControl(), origPs, args.mergeTip.getCurrentTip().name()).setFireRevisionCreated(false).setCopyApprovals(false).setValidatePolicy(CommitValidators.Policy.NONE).setCheckAddPatchSetPermission(false).setDetailedCommitMessage(rebaseAlways).setPostMessage(false);
        try {
            rebaseOp.updateRepo(ctx);
        } catch (MergeConflictException | NoSuchChangeException e) {
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IntegrationException("Cannot rebase " + toMerge.name() + ": " + e.getMessage(), e);
        }
        newCommit = args.rw.parseCommit(rebaseOp.getRebasedCommit());
        newPatchSetId = rebaseOp.getPatchSetId();
    }
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(newPatchSetId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_REBASE);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commitStatus.put(args.mergeTip.getCurrentTip());
    acceptMergeTip(args.mergeTip);
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, InvalidChangeOperationException, RestApiException, IOException, OrmException, PermissionBackendException {
    if (args.mergeUtil.canFastForward(args.mergeSorter, args.mergeTip.getCurrentTip(), args.rw, toMerge)) {
        if (!rebaseAlways) {
            args.mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
            toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            acceptMergeTip(args.mergeTip);
            return;
        }
        // RebaseAlways means we modify commit message.
        args.rw.parseBody(toMerge);
        newPatchSetId = ChangeUtil.nextPatchSetIdFromChangeRefsMap(ctx.getRepoView().getRefs(getId().toRefPrefix()), toMerge.change().currentPatchSetId());
        RevCommit mergeTip = args.mergeTip.getCurrentTip();
        args.rw.parseBody(mergeTip);
        String cherryPickCmtMsg = args.mergeUtil.createCommitMessageOnSubmit(toMerge, mergeTip);
        PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
        try {
            newCommit = args.mergeUtil.createCherryPickFromCommit(ctx.getInserter(), ctx.getRepoView().getConfig(), args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, true);
        } catch (MergeConflictException mce) {
            // Unlike in Cherry-pick case, this should never happen.
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IllegalStateException("MergeConflictException on message edit must not happen");
        } catch (MergeIdenticalTreeException mie) {
            // this should not happen
            toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
            return;
        }
        ctx.addRefUpdate(ObjectId.zeroId(), newCommit, newPatchSetId.toRefName());
    } else {
        // Stale read of patch set is ok; see comments in RebaseChangeOp.
        PatchSet origPs = args.psUtil.get(ctx.getDb(), toMerge.getNotes(), toMerge.getPatchsetId());
        rebaseOp = args.rebaseFactory.create(toMerge.notes(), origPs, args.mergeTip.getCurrentTip()).setFireRevisionCreated(false).setCopyApprovals(false).setValidate(false).setCheckAddPatchSetPermission(false).setDetailedCommitMessage(rebaseAlways).setPostMessage(false).setMatchAuthorToCommitterDate(args.project.isMatchAuthorToCommitterDate());
        try {
            rebaseOp.updateRepo(ctx);
        } catch (MergeConflictException | NoSuchChangeException e) {
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IntegrationException("Cannot rebase " + toMerge.name() + ": " + e.getMessage(), e);
        }
        newCommit = args.rw.parseCommit(rebaseOp.getRebasedCommit());
        newPatchSetId = rebaseOp.getPatchSetId();
    }
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(newPatchSetId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_REBASE);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commitStatus.put(args.mergeTip.getCurrentTip());
    acceptMergeTip(args.mergeTip);
}
#end_block

#method_before
@Override
public PatchSet updateChangeImpl(ChangeContext ctx) throws NoSuchChangeException, ResourceConflictException, OrmException, IOException {
    if (newCommit == null) {
        checkState(!rebaseAlways, "RebaseAlways must never fast forward");
        // otherwise, took the fast-forward option, nothing to do.
        return null;
    }
    PatchSet newPs;
    if (rebaseOp != null) {
        rebaseOp.updateChange(ctx);
        newPs = rebaseOp.getPatchSet();
    } else {
        // CherryPick
        PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
        newPs = args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(newPatchSetId), newPatchSetId, newCommit, prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of(), null, null);
    }
    ctx.getChange().setCurrentPatchSet(args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, newPatchSetId));
    newCommit.setControl(ctx.getControl());
    return newPs;
}
#method_after
@Override
public PatchSet updateChangeImpl(ChangeContext ctx) throws NoSuchChangeException, ResourceConflictException, OrmException, IOException {
    if (newCommit == null) {
        checkState(!rebaseAlways, "RebaseAlways must never fast forward");
        // otherwise, took the fast-forward option, nothing to do.
        return null;
    }
    PatchSet newPs;
    if (rebaseOp != null) {
        rebaseOp.updateChange(ctx);
        newPs = rebaseOp.getPatchSet();
    } else {
        // CherryPick
        PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
        newPs = args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(newPatchSetId), newPatchSetId, newCommit, prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of(), null, null);
    }
    ctx.getChange().setCurrentPatchSet(args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, newPatchSetId));
    newCommit.setNotes(ctx.getNotes());
    return newPs;
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    // There are multiple parents, so this is a merge commit. We don't want
    // to rebase the merge as clients can't easily rebase their history with
    // that merge present and replaced by an equivalent merge with a different
    // first parent. So instead behave as though MERGE_IF_NECESSARY was
    // configured.
    // TODO(tandrii): this is not in spirit of RebaseAlways strategy because
    // the commit messages can not be modified in the process. It's also
    // possible to implement rebasing of merge commits. E.g., the Cherry Pick
    // REST endpoint already supports cherry-picking of merge commits.
    // For now, users of RebaseAlways strategy for whom changed commit footers
    // are important would be well advised to prohibit uploading patches with
    // merge commits.
    MergeTip mergeTip = args.mergeTip;
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge) && !args.submoduleOp.hasSubscription(args.destBranch)) {
        mergeTip.moveTipTo(toMerge, toMerge);
    } else {
        CodeReviewCommit newTip = args.mergeUtil.mergeOneCommit(args.serverIdent, args.serverIdent, args.repo, args.rw, args.inserter, args.destBranch, mergeTip.getCurrentTip(), toMerge);
        mergeTip.moveTipTo(amendGitlink(newTip), toMerge);
    }
    args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    acceptMergeTip(mergeTip);
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, IOException {
    // There are multiple parents, so this is a merge commit. We don't want
    // to rebase the merge as clients can't easily rebase their history with
    // that merge present and replaced by an equivalent merge with a different
    // first parent. So instead behave as though MERGE_IF_NECESSARY was
    // configured.
    // TODO(tandrii): this is not in spirit of RebaseAlways strategy because
    // the commit messages can not be modified in the process. It's also
    // possible to implement rebasing of merge commits. E.g., the Cherry Pick
    // REST endpoint already supports cherry-picking of merge commits.
    // For now, users of RebaseAlways strategy for whom changed commit footers
    // are important would be well advised to prohibit uploading patches with
    // merge commits.
    MergeTip mergeTip = args.mergeTip;
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge) && !args.submoduleOp.hasSubscription(args.destBranch)) {
        mergeTip.moveTipTo(toMerge, toMerge);
    } else {
        PersonIdent caller = ctx.getIdentifiedUser().newCommitterIdent(ctx.getWhen(), ctx.getTimeZone());
        CodeReviewCommit newTip = args.mergeUtil.mergeOneCommit(caller, caller, args.rw, ctx.getInserter(), ctx.getRepoView().getConfig(), args.destBranch, mergeTip.getCurrentTip(), toMerge);
        mergeTip.moveTipTo(amendGitlink(newTip), toMerge);
    }
    args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    acceptMergeTip(mergeTip);
}
#end_block

#method_before
static boolean dryRun(SubmitDryRun.Arguments args, CodeReviewCommit mergeTip, CodeReviewCommit toMerge) throws IntegrationException {
    // on commit chains.
    return !args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge) && args.mergeUtil.canMerge(args.mergeSorter, args.repo, mergeTip, toMerge);
}
#method_after
static boolean dryRun(SubmitDryRun.Arguments args, Repository repo, CodeReviewCommit mergeTip, CodeReviewCommit toMerge) throws IntegrationException {
    // on commit chains.
    return !args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge) && args.mergeUtil.canMerge(args.mergeSorter, repo, mergeTip, toMerge);
}
#end_block

#method_before
@Override
public RevisionResource parse(ChangeResource change, IdString id) throws ResourceNotFoundException, AuthException, OrmException, IOException {
    if (id.equals("current")) {
        PatchSet ps = psUtil.current(dbProvider.get(), change.getNotes());
        if (ps != null && visible(change, ps)) {
            return new RevisionResource(change, ps).doNotCache();
        }
        throw new ResourceNotFoundException(id);
    }
    List<RevisionResource> match = Lists.newArrayListWithExpectedSize(2);
    for (RevisionResource rsrc : find(change, id.get())) {
        if (visible(change, rsrc.getPatchSet())) {
            match.add(rsrc);
        }
    }
    switch(match.size()) {
        case 0:
            throw new ResourceNotFoundException(id);
        case 1:
            return match.get(0);
        default:
            throw new ResourceNotFoundException("Multiple patch sets for \"" + id.get() + "\": " + Joiner.on("; ").join(match));
    }
}
#method_after
@Override
public RevisionResource parse(ChangeResource change, IdString id) throws ResourceNotFoundException, AuthException, OrmException, IOException {
    if (id.get().equals("current")) {
        PatchSet ps = psUtil.current(dbProvider.get(), change.getNotes());
        if (ps != null && visible(change)) {
            return new RevisionResource(change, ps).doNotCache();
        }
        throw new ResourceNotFoundException(id);
    }
    List<RevisionResource> match = Lists.newArrayListWithExpectedSize(2);
    for (RevisionResource rsrc : find(change, id.get())) {
        if (visible(change)) {
            match.add(rsrc);
        }
    }
    switch(match.size()) {
        case 0:
            throw new ResourceNotFoundException(id);
        case 1:
            return match.get(0);
        default:
            throw new ResourceNotFoundException("Multiple patch sets for \"" + id.get() + "\": " + Joiner.on("; ").join(match));
    }
}
#end_block

#method_before
private boolean visible(ChangeResource change, PatchSet ps) {
    return change.getControl().isPatchVisible(ps, dbProvider.get());
}
#method_after
private boolean visible(ChangeResource change) throws OrmException {
    return changeControlFactory.controlFor(change.getNotes(), change.getUser()).isVisible(dbProvider.get());
}
#end_block

#method_before
private List<RevisionResource> loadEdit(ChangeResource change, RevId revid) throws AuthException, IOException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(change.getChange());
    if (edit.isPresent()) {
        PatchSet ps = new PatchSet(new PatchSet.Id(change.getId(), 0));
        ps.setRevision(edit.get().getRevision());
        if (revid == null || edit.get().getRevision().equals(revid)) {
            return Collections.singletonList(new RevisionResource(change, ps, edit));
        }
    }
    return Collections.emptyList();
}
#method_after
private List<RevisionResource> loadEdit(ChangeResource change, RevId revid) throws AuthException, IOException {
    Optional<ChangeEdit> edit = editUtil.byChange(change.getNotes(), change.getUser());
    if (edit.isPresent()) {
        PatchSet ps = new PatchSet(new PatchSet.Id(change.getId(), 0));
        RevId editRevId = new RevId(ObjectId.toString(edit.get().getEditCommit()));
        ps.setRevision(editRevId);
        if (revid == null || editRevId.equals(revid)) {
            return Collections.singletonList(new RevisionResource(change, ps, edit));
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Test
public void postSubmitApproval() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    String label = "Code-Review";
    ApprovalInfo approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Submit by direct push.
    git().push().setRefSpecs(new RefSpec(r.getCommit().name() + ":refs/heads/master")).call();
    assertThat(gApi.changes().id(changeId).get().status).isEqualTo(ChangeStatus.MERGED);
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    assertPermitted(gApi.changes().id(changeId).get(EnumSet.of(DETAILED_LABELS)), "Code-Review", 1, 2);
    // Repeating the current label is allowed. Does not flip the postSubmit bit
    // due to deduplication codepath.
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Reducing vote is not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessage("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Increasing vote is allowed.
    gApi.changes().id(changeId).current().review(ReviewInput.approve());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
    assertPermitted(gApi.changes().id(changeId).get(EnumSet.of(DETAILED_LABELS)), "Code-Review", 2);
    // Decreasing to previous post-submit vote is still not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessage("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
}
#method_after
@Test
public void postSubmitApproval() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    String label = "Code-Review";
    ApprovalInfo approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Submit by direct push.
    git().push().setRefSpecs(new RefSpec(r.getCommit().name() + ":refs/heads/master")).call();
    assertThat(gApi.changes().id(changeId).get().status).isEqualTo(ChangeStatus.MERGED);
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    assertPermitted(gApi.changes().id(changeId).get(DETAILED_LABELS), "Code-Review", 1, 2);
    // Repeating the current label is allowed. Does not flip the postSubmit bit
    // due to deduplication codepath.
    gApi.changes().id(changeId).current().review(ReviewInput.recommend());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Reducing vote is not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessageThat().isEqualTo("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(1);
    assertThat(approval.postSubmit).isNull();
    // Increasing vote is allowed.
    gApi.changes().id(changeId).current().review(ReviewInput.approve());
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
    assertPermitted(gApi.changes().id(changeId).get(DETAILED_LABELS), "Code-Review", 2);
    // Decreasing to previous post-submit vote is still not allowed.
    try {
        gApi.changes().id(changeId).current().review(ReviewInput.dislike());
        fail("expected ResourceConflictException");
    } catch (ResourceConflictException e) {
        assertThat(e).hasMessageThat().isEqualTo("Cannot reduce vote on labels for closed change: Code-Review");
    }
    approval = getApproval(changeId, label);
    assertThat(approval.value).isEqualTo(2);
    assertThat(approval.postSubmit).isTrue();
}
#end_block

#method_before
@Test
public void postSubmitApprovalAfterVoteRemoved() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    setApiUser(admin);
    revision(r).review(ReviewInput.approve());
    setApiUser(user);
    revision(r).review(ReviewInput.recommend());
    setApiUser(admin);
    gApi.changes().id(changeId).reviewer(user.username).deleteVote("Code-Review");
    Optional<ApprovalInfo> crUser = get(changeId, DETAILED_LABELS).labels.get("Code-Review").all.stream().filter(a -> a._accountId == user.id.get()).findFirst();
    assertThat(crUser.isPresent()).isTrue();
    assertThat(crUser.get().value).isEqualTo(0);
    revision(r).submit();
    setApiUser(user);
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.message = "Still LGTM";
    revision(r).review(in);
    ApprovalInfo cr = gApi.changes().id(changeId).get(EnumSet.of(ListChangesOption.DETAILED_LABELS)).labels.get("Code-Review").all.stream().filter(a -> a._accountId == user.getId().get()).findFirst().get();
    assertThat(cr.postSubmit).isTrue();
}
#method_after
@Test
public void postSubmitApprovalAfterVoteRemoved() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    setApiUser(admin);
    revision(r).review(ReviewInput.approve());
    setApiUser(user);
    revision(r).review(ReviewInput.recommend());
    setApiUser(admin);
    gApi.changes().id(changeId).reviewer(user.username).deleteVote("Code-Review");
    Optional<ApprovalInfo> crUser = get(changeId, DETAILED_LABELS).labels.get("Code-Review").all.stream().filter(a -> a._accountId == user.id.get()).findFirst();
    assertThat(crUser).isPresent();
    assertThat(crUser.get().value).isEqualTo(0);
    revision(r).submit();
    setApiUser(user);
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.message = "Still LGTM";
    revision(r).review(in);
    ApprovalInfo cr = gApi.changes().id(changeId).get(DETAILED_LABELS).labels.get("Code-Review").all.stream().filter(a -> a._accountId == user.getId().get()).findFirst().get();
    assertThat(cr.postSubmit).isTrue();
}
#end_block

#method_before
@Test
public void cherryPickToSameBranchWithRebase() throws Exception {
    // Push a new change, then merge it
    PushOneCommit.Result baseChange = createChange();
    String triplet = project.get() + "~master~" + baseChange.getChangeId();
    RevisionApi baseRevision = gApi.changes().id(triplet).current();
    baseRevision.review(ReviewInput.approve());
    baseRevision.submit();
    // Push a new change (change 1)
    PushOneCommit.Result r1 = createChange();
    // Push another new change (change 2)
    String subject = "Test change\n\n" + "Change-Id: Ideadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, subject, "another_file.txt", "another content");
    PushOneCommit.Result r2 = push.to("refs/for/master");
    // Change 2's parent should be change 1
    assertThat(r2.getCommit().getParents()[0].name()).isEqualTo(r1.getCommit().name());
    // Cherry pick change 2 onto the same branch
    triplet = project.get() + "~master~" + r2.getChangeId();
    ChangeApi orig = gApi.changes().id(triplet);
    CherryPickInput in = new CherryPickInput();
    in.destination = "master";
    in.message = subject;
    ChangeApi cherry = orig.revision(r2.getCommit().name()).cherryPick(in);
    ChangeInfo cherryInfo = cherry.get();
    assertThat(cherryInfo.messages).hasSize(2);
    Iterator<ChangeMessageInfo> cherryIt = cherryInfo.messages.iterator();
    assertThat(cherryIt.next().message).isEqualTo("Uploaded patch set 1.");
    assertThat(cherryIt.next().message).isEqualTo("Uploaded patch set 2.");
    // Parent of change 2 should now be the change that was merged, i.e.
    // change 2 is rebased onto the head of the master branch.
    String newParent = cherryInfo.revisions.get(cherryInfo.currentRevision).commit.parents.get(0).commit;
    assertThat(newParent).isEqualTo(baseChange.getCommit().name());
}
#method_after
@Test
public void cherryPickToSameBranchWithRebase() throws Exception {
    // Push a new change, then merge it
    PushOneCommit.Result baseChange = createChange();
    String triplet = project.get() + "~master~" + baseChange.getChangeId();
    RevisionApi baseRevision = gApi.changes().id(triplet).current();
    baseRevision.review(ReviewInput.approve());
    baseRevision.submit();
    // Push a new change (change 1)
    PushOneCommit.Result r1 = createChange();
    // Push another new change (change 2)
    String subject = "Test change\n\nChange-Id: Ideadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, subject, "another_file.txt", "another content");
    PushOneCommit.Result r2 = push.to("refs/for/master");
    // Change 2's parent should be change 1
    assertThat(r2.getCommit().getParents()[0].name()).isEqualTo(r1.getCommit().name());
    // Cherry pick change 2 onto the same branch
    triplet = project.get() + "~master~" + r2.getChangeId();
    ChangeApi orig = gApi.changes().id(triplet);
    CherryPickInput in = new CherryPickInput();
    in.destination = "master";
    in.message = subject;
    ChangeApi cherry = orig.revision(r2.getCommit().name()).cherryPick(in);
    ChangeInfo cherryInfo = cherry.get();
    assertThat(cherryInfo.messages).hasSize(2);
    Iterator<ChangeMessageInfo> cherryIt = cherryInfo.messages.iterator();
    assertThat(cherryIt.next().message).isEqualTo("Uploaded patch set 1.");
    assertThat(cherryIt.next().message).isEqualTo("Uploaded patch set 2.");
    // Parent of change 2 should now be the change that was merged, i.e.
    // change 2 is rebased onto the head of the master branch.
    String newParent = cherryInfo.revisions.get(cherryInfo.currentRevision).commit.parents.get(0).commit;
    assertThat(newParent).isEqualTo(baseChange.getCommit().name());
}
#end_block

#method_before
@Test
public void cherryPickMergeUsingInvalidParent() throws Exception {
    String parent1FileName = "a.txt";
    String parent2FileName = "b.txt";
    PushOneCommit.Result mergeChangeResult = createCherryPickableMerge(parent1FileName, parent2FileName);
    String cherryPickBranchName = "branch_for_cherry_pick";
    createBranch(new Branch.NameKey(project, cherryPickBranchName));
    CherryPickInput cherryPickInput = new CherryPickInput();
    cherryPickInput.destination = cherryPickBranchName;
    cherryPickInput.message = "Cherry-pick a merge commit to another branch";
    cherryPickInput.parent = 0;
    exception.expect(BadRequestException.class);
    exception.expectMessage("Cherry Pick: Parent 0 does not exist. Please" + " specify a parent in range [1, 2].");
    gApi.changes().id(mergeChangeResult.getChangeId()).current().cherryPick(cherryPickInput);
}
#method_after
@Test
public void cherryPickMergeUsingInvalidParent() throws Exception {
    String parent1FileName = "a.txt";
    String parent2FileName = "b.txt";
    PushOneCommit.Result mergeChangeResult = createCherryPickableMerge(parent1FileName, parent2FileName);
    String cherryPickBranchName = "branch_for_cherry_pick";
    createBranch(new Branch.NameKey(project, cherryPickBranchName));
    CherryPickInput cherryPickInput = new CherryPickInput();
    cherryPickInput.destination = cherryPickBranchName;
    cherryPickInput.message = "Cherry-pick a merge commit to another branch";
    cherryPickInput.parent = 0;
    exception.expect(BadRequestException.class);
    exception.expectMessage("Cherry Pick: Parent 0 does not exist. Please specify a parent in range [1, 2].");
    gApi.changes().id(mergeChangeResult.getChangeId()).current().cherryPick(cherryPickInput);
}
#end_block

#method_before
@Test
public void cherryPickMergeUsingNonExistentParent() throws Exception {
    String parent1FileName = "a.txt";
    String parent2FileName = "b.txt";
    PushOneCommit.Result mergeChangeResult = createCherryPickableMerge(parent1FileName, parent2FileName);
    String cherryPickBranchName = "branch_for_cherry_pick";
    createBranch(new Branch.NameKey(project, cherryPickBranchName));
    CherryPickInput cherryPickInput = new CherryPickInput();
    cherryPickInput.destination = cherryPickBranchName;
    cherryPickInput.message = "Cherry-pick a merge commit to another branch";
    cherryPickInput.parent = 3;
    exception.expect(BadRequestException.class);
    exception.expectMessage("Cherry Pick: Parent 3 does not exist. Please" + " specify a parent in range [1, 2].");
    gApi.changes().id(mergeChangeResult.getChangeId()).current().cherryPick(cherryPickInput);
}
#method_after
@Test
public void cherryPickMergeUsingNonExistentParent() throws Exception {
    String parent1FileName = "a.txt";
    String parent2FileName = "b.txt";
    PushOneCommit.Result mergeChangeResult = createCherryPickableMerge(parent1FileName, parent2FileName);
    String cherryPickBranchName = "branch_for_cherry_pick";
    createBranch(new Branch.NameKey(project, cherryPickBranchName));
    CherryPickInput cherryPickInput = new CherryPickInput();
    cherryPickInput.destination = cherryPickBranchName;
    cherryPickInput.message = "Cherry-pick a merge commit to another branch";
    cherryPickInput.parent = 3;
    exception.expect(BadRequestException.class);
    exception.expectMessage("Cherry Pick: Parent 3 does not exist. Please specify a parent in range [1, 2].");
    gApi.changes().id(mergeChangeResult.getChangeId()).current().cherryPick(cherryPickInput);
}
#end_block

#method_before
@Test
public void description() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).description()).isEqualTo("");
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).description("test");
    assertThat(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).description()).isEqualTo("test");
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).description("");
    assertThat(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).description()).isEqualTo("");
}
#method_after
@Test
public void description() throws Exception {
    PushOneCommit.Result r = createChange();
    assertDescription(r, "");
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).description("test");
    assertDescription(r, "test");
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).description("");
    assertDescription(r, "");
}
#end_block

#method_before
@Test
public void deleteVoteOnNonCurrentPatchSet() throws Exception {
    // patch set 1
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    // patch set 2
    amendChange(r.getChangeId());
    // code-review
    setApiUser(user);
    recommend(r.getChangeId());
    // check if it's blocked to delete a vote on a non-current patch set.
    exception.expect(MethodNotAllowedException.class);
    exception.expectMessage("Cannot access on non-current patch set");
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().getName()).reviewer(user.getId().toString()).deleteVote("Code-Review");
}
#method_after
@Test
public void deleteVoteOnNonCurrentPatchSet() throws Exception {
    // patch set 1
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    // patch set 2
    amendChange(r.getChangeId());
    // code-review
    setApiUser(user);
    recommend(r.getChangeId());
    // check if it's blocked to delete a vote on a non-current patch set.
    setApiUser(admin);
    exception.expect(MethodNotAllowedException.class);
    exception.expectMessage("Cannot access on non-current patch set");
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().getName()).reviewer(user.getId().toString()).deleteVote("Code-Review");
}
#end_block

#method_before
@Test
public void deleteVoteOnCurrentPatchSet() throws Exception {
    // patch set 1
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    // patch set 2
    amendChange(r.getChangeId());
    // code-review
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).current().reviewer(user.getId().toString()).deleteVote("Code-Review");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).current().reviewer(user.getId().toString()).votes();
    assertThat(m).containsExactly("Code-Review", Short.valueOf((short) 0));
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#method_after
@Test
public void deleteVoteOnCurrentPatchSet() throws Exception {
    // patch set 1
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    // patch set 2
    amendChange(r.getChangeId());
    // code-review
    setApiUser(user);
    recommend(r.getChangeId());
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).current().reviewer(user.getId().toString()).deleteVote("Code-Review");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).current().reviewer(user.getId().toString()).votes();
    assertThat(m).containsExactly("Code-Review", Short.valueOf((short) 0));
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    assertThat(getReviewers(c.reviewers.get(ReviewerState.REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#end_block

#method_before
private ApprovalInfo getApproval(String changeId, String label) throws Exception {
    ChangeInfo info = gApi.changes().id(changeId).get(EnumSet.of(DETAILED_LABELS));
    LabelInfo li = info.labels.get(label);
    assertThat(li).isNotNull();
    int accountId = atrScope.get().getUser().getAccountId().get();
    return li.all.stream().filter(a -> a._accountId == accountId).findFirst().get();
}
#method_after
private ApprovalInfo getApproval(String changeId, String label) throws Exception {
    ChangeInfo info = gApi.changes().id(changeId).get(DETAILED_LABELS);
    LabelInfo li = info.labels.get(label);
    assertThat(li).isNotNull();
    int accountId = atrScope.get().getUser().getAccountId().get();
    return li.all.stream().filter(a -> a._accountId == accountId).findFirst().get();
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws RestApiException, RepositoryNotFoundException, IOException, OrmException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    try (MergeOp op = mergeOpProvider.get()) {
        ReviewDb db = dbProvider.get();
        op.merge(db, change, caller, true, input, false);
        try {
            change = changeNotesFactory.createChecked(db, change.getProject(), change.getId()).getChange();
        } catch (NoSuchChangeException e) {
            throw new ResourceConflictException("change is deleted");
        }
    }
    switch(change.getStatus()) {
        case MERGED:
            return new Output(change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        case ABANDONED:
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws RestApiException, RepositoryNotFoundException, IOException, OrmException, PermissionBackendException, UpdateException, ConfigInvalidException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    IdentifiedUser submitter;
    if (input.onBehalfOf != null) {
        submitter = onBehalfOf(rsrc, input);
    } else {
        rsrc.permissions().check(ChangePermission.SUBMIT);
        submitter = rsrc.getUser().asIdentifiedUser();
    }
    return new Output(mergeChange(rsrc, submitter, input));
}
#end_block

#method_before
private String problemsForSubmittingChangeset(ChangeData cd, ChangeSet cs, CurrentUser user) {
    try {
        @SuppressWarnings("resource")
        ReviewDb db = dbProvider.get();
        if (cs.furtherHiddenChanges()) {
            return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
        }
        for (ChangeData c : cs.changes()) {
            ChangeControl changeControl = c.changeControl(user);
            if (!changeControl.isVisible(db)) {
                return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
            }
            if (!changeControl.canSubmit()) {
                return BLOCKED_SUBMIT_TOOLTIP;
            }
            MergeOp.checkSubmitRule(c);
        }
        Collection<ChangeData> unmergeable = unmergeableChanges(cs);
        if (unmergeable == null) {
            return CLICK_FAILURE_TOOLTIP;
        } else if (!unmergeable.isEmpty()) {
            for (ChangeData c : unmergeable) {
                if (c.change().getKey().equals(cd.change().getKey())) {
                    return CHANGE_UNMERGEABLE;
                }
            }
            return CHANGES_NOT_MERGEABLE + unmergeable.stream().map(c -> c.getId().toString()).collect(joining(", "));
        }
    } catch (ResourceConflictException e) {
        return BLOCKED_SUBMIT_TOOLTIP;
    } catch (OrmException | IOException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    return null;
}
#method_after
private String problemsForSubmittingChangeset(ChangeData cd, ChangeSet cs, CurrentUser user) {
    try {
        if (cs.furtherHiddenChanges()) {
            return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
        }
        for (ChangeData c : cs.changes()) {
            Set<ChangePermission> can = permissionBackend.user(user).database(dbProvider).change(c).test(EnumSet.of(ChangePermission.READ, ChangePermission.SUBMIT));
            if (!can.contains(ChangePermission.READ)) {
                return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
            }
            if (!can.contains(ChangePermission.SUBMIT)) {
                return BLOCKED_SUBMIT_TOOLTIP;
            }
            if (c.change().isWorkInProgress()) {
                return BLOCKED_WORK_IN_PROGRESS;
            }
            MergeOp.checkSubmitRule(c, false);
        }
        Collection<ChangeData> unmergeable = unmergeableChanges(cs);
        if (unmergeable == null) {
            return CLICK_FAILURE_TOOLTIP;
        } else if (!unmergeable.isEmpty()) {
            for (ChangeData c : unmergeable) {
                if (c.change().getKey().equals(cd.change().getKey())) {
                    return CHANGE_UNMERGEABLE;
                }
            }
            return CHANGES_NOT_MERGEABLE + unmergeable.stream().map(c -> c.getId().toString()).collect(joining(", "));
        }
    } catch (ResourceConflictException e) {
        return BLOCKED_SUBMIT_TOOLTIP;
    } catch (PermissionBackendException | OrmException | IOException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    return null;
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        MergeOp.checkSubmitRule(cd);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.get().completeChangeSet(db, cd.change(), resource.getControl().getUser());
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of " + "changes to be submitted", e);
    }
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cd, cs, resource.getUser());
    Boolean enabled;
    try {
        // Recheck mergeability rather than using value stored in the index,
        // which may be stale.
        // TODO(dborowitz): This is ugly; consider providing a way to not read
        // stored fields from the index in the first place.
        // cd.setMergeable(null);
        // That was done in unmergeableChanges which was called by
        // problemsForSubmittingChangeset, so now it is safe to read from
        // the cache, as it yields the same result.
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
    ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
    return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    Change change = resource.getChange();
    if (!change.getStatus().isOpen() || !resource.isCurrent() || !resource.permissions().testOrFalse(ChangePermission.SUBMIT)) {
        // submit not visible
        return null;
    }
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getNotes());
    try {
        MergeOp.checkSubmitRule(cd, false);
    } catch (ResourceConflictException e) {
        // submit not visible
        return null;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.get().completeChangeSet(db, cd.change(), resource.getUser());
    } catch (OrmException | IOException | PermissionBackendException e) {
        throw new OrmRuntimeException("Could not determine complete set of changes to be submitted", e);
    }
    String topic = change.getTopic();
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cd, cs, resource.getUser());
    Boolean enabled;
    try {
        // Recheck mergeability rather than using value stored in the index,
        // which may be stale.
        // TODO(dborowitz): This is ugly; consider providing a way to not read
        // stored fields from the index in the first place.
        // cd.setMergeable(null);
        // That was done in unmergeableChanges which was called by
        // problemsForSubmittingChangeset, so now it is safe to read from
        // the cache, as it yields the same result.
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", change.getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
    ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
    return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
}
#end_block

#method_before
private RevisionResource onBehalfOf(RevisionResource rsrc, SubmitInput in) throws AuthException, UnprocessableEntityException, OrmException {
    ChangeControl caller = rsrc.getControl();
    if (!caller.canSubmit()) {
        throw new AuthException("submit not permitted");
    }
    if (!caller.canSubmitAs()) {
        throw new AuthException("submit on behalf of not permitted");
    }
    ChangeControl target = caller.forUser(accounts.parseOnBehalfOf(caller.getUser(), in.onBehalfOf));
    if (!target.getRefControl().isVisible()) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see destination ref", target.getUser().getAccountId()));
    }
    return new RevisionResource(changes.parse(target), rsrc.getPatchSet());
}
#method_after
private IdentifiedUser onBehalfOf(RevisionResource rsrc, SubmitInput in) throws AuthException, UnprocessableEntityException, OrmException, PermissionBackendException, IOException, ConfigInvalidException {
    PermissionBackend.ForChange perm = rsrc.permissions().database(dbProvider);
    perm.check(ChangePermission.SUBMIT);
    perm.check(ChangePermission.SUBMIT_AS);
    CurrentUser caller = rsrc.getUser();
    IdentifiedUser submitter = accounts.parseOnBehalfOf(caller, in.onBehalfOf);
    try {
        perm.user(submitter).check(ChangePermission.READ);
    } catch (AuthException e) {
        throw new UnprocessableEntityException(String.format("on_behalf_of account %s cannot see change", submitter.getAccountId()));
    }
    return submitter;
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource rsrc, SubmitInput input) throws RestApiException, RepositoryNotFoundException, IOException, OrmException {
    PatchSet ps = psUtil.current(dbProvider.get(), rsrc.getNotes());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(ps, dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    Output out = submit.apply(new RevisionResource(rsrc, ps), input);
    return json.create(ChangeJson.NO_OPTIONS).format(out.change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource rsrc, SubmitInput input) throws RestApiException, RepositoryNotFoundException, IOException, OrmException, PermissionBackendException, UpdateException, ConfigInvalidException {
    PatchSet ps = psUtil.current(dbProvider.get(), rsrc.getNotes());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!changeControlFactory.controlFor(rsrc.getNotes(), rsrc.getUser()).isVisible(dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    Output out = submit.apply(new RevisionResource(rsrc, ps), input);
    return json.noOptions().format(out.change);
}
#end_block

#method_before
public static Id parse(final String str) {
    final Id r = new Id();
    r.fromString(str);
    return r;
}
#method_after
public static Id parse(String str) {
    final Id r = new Id();
    r.fromString(str);
    return r;
}
#end_block

#method_before
public void setRevision(final RevId i) {
    revision = i;
}
#method_after
public void setRevision(RevId i) {
    revision = i;
}
#end_block

#method_before
public void setUploader(final Account.Id who) {
    uploader = who;
}
#method_after
public void setUploader(Account.Id who) {
    uploader = who;
}
#end_block

#method_before
public void setCreatedOn(final Timestamp ts) {
    createdOn = ts;
}
#method_after
public void setCreatedOn(Timestamp ts) {
    createdOn = ts;
}
#end_block

#method_before
public static String toLongString(final Change.Status status) {
    if (status == null) {
        return "";
    }
    switch(status) {
        case NEW:
            return C.statusLongNew();
        case MERGED:
            return C.statusLongMerged();
        case ABANDONED:
            return C.statusLongAbandoned();
        default:
            return status.name();
    }
}
#method_after
public static String toLongString(Change.Status status) {
    if (status == null) {
        return "";
    }
    switch(status) {
        case NEW:
            return C.statusLongNew();
        case MERGED:
            return C.statusLongMerged();
        case ABANDONED:
            return C.statusLongAbandoned();
        default:
            return status.name();
    }
}
#end_block

#method_before
@SuppressWarnings("deprecation")
public static String cropSubject(final String subject) {
    if (subject.length() > SUBJECT_MAX_LENGTH) {
        final int maxLength = SUBJECT_MAX_LENGTH - SUBJECT_CROP_APPENDIX.length();
        for (int cropPosition = maxLength; cropPosition > maxLength - SUBJECT_CROP_RANGE; cropPosition--) {
            // see https://developers.google.com/web-toolkit/doc/1.6/RefJreEmulation#Package_java_lang
            if (Character.isSpace(subject.charAt(cropPosition - 1))) {
                return subject.substring(0, cropPosition) + SUBJECT_CROP_APPENDIX;
            }
        }
        return subject.substring(0, maxLength) + SUBJECT_CROP_APPENDIX;
    }
    return subject;
}
#method_after
@SuppressWarnings("deprecation")
public static String cropSubject(String subject) {
    if (subject.length() > SUBJECT_MAX_LENGTH) {
        final int maxLength = SUBJECT_MAX_LENGTH - SUBJECT_CROP_APPENDIX.length();
        for (int cropPosition = maxLength; cropPosition > maxLength - SUBJECT_CROP_RANGE; cropPosition--) {
            // see https://developers.google.com/web-toolkit/doc/1.6/RefJreEmulation#Package_java_lang
            if (Character.isSpace(subject.charAt(cropPosition - 1))) {
                return subject.substring(0, cropPosition) + SUBJECT_CROP_APPENDIX;
            }
        }
        return subject.substring(0, maxLength) + SUBJECT_CROP_APPENDIX;
    }
    return subject;
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, notesFactory, changeDataFactory, fillArgs, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, starredChangesUtil, accountCache);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, hasOperands, userFactory, Providers.of(otherUser), permissionBackend, changeControlGenericFactory, notesFactory, changeDataFactory, commentsUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, index, indexConfig, listMembers, starredChangesUtil, accountCache, allowsDrafts, notesMigration);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> change(String query) throws QueryParseException {
    if (PAT_LEGACY_ID.matcher(query).matches()) {
        return new LegacyChangeIdPredicate(Change.Id.parse(query));
    } else if (PAT_CHANGE_ID.matcher(query).matches()) {
        return new ChangeIdPredicate(parseChangeId(query));
    }
    Optional<ChangeTriplet> triplet = ChangeTriplet.parse(query);
    if (triplet.isPresent()) {
        return Predicate.and(project(triplet.get().project().get()), branch(triplet.get().branch().get()), new ChangeIdPredicate(parseChangeId(triplet.get().id().get())));
    }
    throw new QueryParseException("Invalid change format");
}
#method_after
@Operator
public Predicate<ChangeData> change(String query) throws QueryParseException {
    Optional<ChangeTriplet> triplet = ChangeTriplet.parse(query);
    if (triplet.isPresent()) {
        return Predicate.and(project(triplet.get().project().get()), branch(triplet.get().branch().get()), new ChangeIdPredicate(parseChangeId(triplet.get().id().get())));
    }
    if (PAT_LEGACY_ID.matcher(query).matches()) {
        return new LegacyChangeIdPredicate(Change.Id.parse(query));
    } else if (PAT_CHANGE_ID.matcher(query).matches()) {
        return new ChangeIdPredicate(parseChangeId(query));
    }
    throw new QueryParseException("Invalid change format");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return ReviewerPredicate.create(self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return starredby(self());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP)), ReviewerPredicate.reviewer(args, self()));
        }
        return ReviewerPredicate.reviewer(args, self());
    }
    if ("cc".equalsIgnoreCase(value)) {
        return ReviewerPredicate.cc(self());
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new BooleanPredicate(ChangeField.MERGEABLE);
    }
    if ("private".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.PRIVATE)) {
            return new BooleanPredicate(ChangeField.PRIVATE);
        }
        throw new QueryParseException("'is:private' operator is not supported by change index version");
    }
    if ("assigned".equalsIgnoreCase(value)) {
        return Predicate.not(new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE)));
    }
    if ("unassigned".equalsIgnoreCase(value)) {
        return new AssigneePredicate(new Account.Id(ChangeField.NO_ASSIGNEE));
    }
    if ("submittable".equalsIgnoreCase(value)) {
        return new SubmittablePredicate(SubmitRecord.Status.OK);
    }
    if ("ignored".equalsIgnoreCase(value)) {
        return star("ignore");
    }
    if ("started".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.STARTED)) {
            return new BooleanPredicate(ChangeField.STARTED);
        }
        throw new QueryParseException("'is:started' operator is not supported by change index version");
    }
    if ("wip".equalsIgnoreCase(value)) {
        if (args.getSchema().hasField(ChangeField.WIP)) {
            return new BooleanPredicate(ChangeField.WIP);
        }
        throw new QueryParseException("'is:wip' operator is not supported by change index version");
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw error("Invalid query");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> conflicts(String value) throws OrmException, QueryParseException {
    return new ConflictsPredicate(args, value, parseChange(value));
}
#method_after
@Operator
public Predicate<ChangeData> conflicts(String value) throws OrmException, QueryParseException {
    List<Change> changes = parseChange(value);
    List<Predicate<ChangeData>> or = new ArrayList<>(changes.size());
    for (Change c : changes) {
        or.add(ConflictsPredicate.create(args, value, c));
    }
    return Predicate.or(or);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    // Special case: votes by owners can be tracked with ",owner":
    // label:Code-Review+2,owner
    // label:Code-Review+2,user=owner
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                if (pair.getValue().equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(pair.getValue());
                }
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                if (value.equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(value);
                }
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found", e);
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = args.listMembers.get().setRecursive(true).apply(group).stream().map(a -> new Account.Id(a._accountId)).collect(toSet());
        int maxLimit = args.indexConfig.maxLimit();
        if (allMembers.size() > maxLimit) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxLimit));
        } else {
            accounts = allMembers;
        }
    }
    // If the vote piece looks like Code-Review=NEED with a valid non-numeric
    // submit record status, interpret as a submit record query.
    int eq = name.indexOf('=');
    if (args.getSchema().hasField(ChangeField.SUBMIT_RECORD) && eq > 0) {
        String statusName = name.substring(eq + 1).toUpperCase();
        if (!isInt(statusName)) {
            SubmitRecord.Label.Status status = Enums.getIfPresent(SubmitRecord.Label.Status.class, statusName).orNull();
            if (status == null) {
                throw error("Invalid label status " + statusName + " in " + name);
            }
            return SubmitRecordPredicate.create(name.substring(0, eq), status, accounts);
        }
    }
    return new LabelPredicate(args, name, accounts, group);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    // Special case: votes by owners can be tracked with ",owner":
    // label:Code-Review+2,owner
    // label:Code-Review+2,user=owner
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                if (pair.getValue().equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(pair.getValue());
                }
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                if (value.equals(ARG_ID_OWNER)) {
                    accounts = Collections.singleton(OWNER_ACCOUNT_ID);
                } else {
                    accounts = parseAccount(value);
                }
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found", e);
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = args.listMembers.get().setRecursive(true).apply(group).stream().map(a -> new Account.Id(a._accountId)).collect(toSet());
        int maxLimit = args.indexConfig.maxLimit();
        if (allMembers.size() > maxLimit) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxLimit));
        } else {
            accounts = allMembers;
        }
    }
    // If the vote piece looks like Code-Review=NEED with a valid non-numeric
    // submit record status, interpret as a submit record query.
    int eq = name.indexOf('=');
    if (args.getSchema().hasField(ChangeField.SUBMIT_RECORD) && eq > 0) {
        String statusName = name.substring(eq + 1).toUpperCase();
        if (!isInt(statusName)) {
            SubmitRecord.Label.Status status = Enums.getIfPresent(SubmitRecord.Label.Status.class, statusName).orNull();
            if (status == null) {
                throw error("Invalid label status " + statusName + " in " + name);
            }
            return SubmitRecordPredicate.create(name.substring(0, eq), status, accounts);
        }
    }
    return new LabelPredicate(args, name, accounts, group);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> starredby(String who) throws QueryParseException, OrmException {
    return starredby(parseAccount(who));
}
#method_after
@Operator
public Predicate<ChangeData> starredby(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    return starredby(parseAccount(who));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    Account.Id callerId;
    try {
        CurrentUser caller = args.self.get();
        callerId = caller.isIdentifiedUser() ? caller.getAccountId() : null;
    } catch (ProvisionException e) {
        callerId = null;
    }
    for (Account.Id id : m) {
        // Each child IsWatchedByPredicate includes a visibility filter for the
        // corresponding user, to ensure that predicate subtree only returns
        // changes visible to that user. The exception is if one of the users is
        // the caller of this method, in which case visibility is already being
        // checked at the top level.
        p.add(new IsWatchedByPredicate(args.asUser(id), !id.equals(callerId)));
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    Account.Id callerId;
    try {
        CurrentUser caller = args.self.get();
        callerId = caller.isIdentifiedUser() ? caller.getAccountId() : null;
    } catch (ProvisionException e) {
        callerId = null;
    }
    for (Account.Id id : m) {
        // Each child IsWatchedByPredicate includes a visibility filter for the
        // corresponding user, to ensure that predicate subtree only returns
        // changes visible to that user. The exception is if one of the users is
        // the caller of this method, in which case visibility is already being
        // checked at the top level.
        p.add(new IsWatchedByPredicate(args.asUser(id), !id.equals(callerId)));
    }
    return Predicate.or(p);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> draftby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(draftby(id));
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> draftby(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    Set<Account.Id> m = parseAccount(who);
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(draftby(id));
    }
    return Predicate.or(p);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    if (isSelf(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(args.db.get(), who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
public Predicate<ChangeData> visibleto(CurrentUser user) {
    return new ChangeIsVisibleToPredicate(args.db, args.notesFactory, args.changeControlGenericFactory, user);
}
#method_after
public Predicate<ChangeData> visibleto(CurrentUser user) {
    return new ChangeIsVisibleToPredicate(args.db, args.notesFactory, args.changeControlGenericFactory, user, args.permissionBackend);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> o(String who) throws QueryParseException, OrmException {
    return owner(who);
}
#method_after
@Operator
public Predicate<ChangeData> o(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    return owner(who);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> owner(String who) throws QueryParseException, OrmException {
    return owner(parseAccount(who));
}
#method_after
@Operator
public Predicate<ChangeData> owner(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    return owner(parseAccount(who));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> assignee(String who) throws QueryParseException, OrmException {
    return assignee(parseAccount(who));
}
#method_after
@Operator
public Predicate<ChangeData> assignee(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    return assignee(parseAccount(who));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> r(String who) throws QueryParseException, OrmException {
    return reviewer(who);
}
#method_after
@Operator
public Predicate<ChangeData> r(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    return reviewer(who);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(ReviewerPredicate.create(id));
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    return reviewer(who, false);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewer(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(ReviewerPredicate.create(id));
    }
    return Predicate.or(p);
}
#method_after
private Predicate<ChangeData> reviewer(String who, boolean forDefaultField) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    Predicate<ChangeData> byState = reviewerByState(who, ReviewerStateInternal.REVIEWER, forDefaultField);
    if (Objects.equals(byState, Predicate.<ChangeData>any())) {
        return Predicate.any();
    }
    if (args.getSchema().hasField(ChangeField.WIP)) {
        return Predicate.and(Predicate.not(new BooleanPredicate(ChangeField.WIP)), byState);
    }
    return byState;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> tr(String trackingId) {
    return new TrackingIdPredicate(args.trackingFooters, trackingId);
}
#method_after
@Operator
public Predicate<ChangeData> tr(String trackingId) {
    return new TrackingIdPredicate(trackingId);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> commentby(String who) throws QueryParseException, OrmException {
    return commentby(parseAccount(who));
}
#method_after
@Operator
public Predicate<ChangeData> commentby(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    return commentby(parseAccount(who));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> from(String who) throws QueryParseException, OrmException {
    Set<Account.Id> ownerIds = parseAccount(who);
    return Predicate.or(owner(ownerIds), commentby(ownerIds));
}
#method_after
@Operator
public Predicate<ChangeData> from(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    Set<Account.Id> ownerIds = parseAccount(who);
    return Predicate.or(owner(ownerIds), commentby(ownerIds));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewedby(String who) throws QueryParseException, OrmException {
    return IsReviewedPredicate.create(parseAccount(who));
}
#method_after
@Operator
public Predicate<ChangeData> reviewedby(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    return IsReviewedPredicate.create(parseAccount(who));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> author(String who) {
    return new AuthorPredicate(who);
}
#method_after
@Operator
public Predicate<ChangeData> author(String who) throws QueryParseException {
    if (args.getSchema().hasField(ChangeField.EXACT_AUTHOR)) {
        return getAuthorOrCommitterPredicate(who.trim(), ExactAuthorPredicate::new, AuthorPredicate::new);
    }
    return getAuthorOrCommitterFullTextPredicate(who.trim(), AuthorPredicate::new);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> committer(String who) {
    return new CommitterPredicate(who);
}
#method_after
@Operator
public Predicate<ChangeData> committer(String who) throws QueryParseException {
    if (args.getSchema().hasField(ChangeField.EXACT_COMMITTER)) {
        return getAuthorOrCommitterPredicate(who.trim(), ExactCommitterPredicate::new, CommitterPredicate::new);
    }
    return getAuthorOrCommitterFullTextPredicate(who.trim(), CommitterPredicate::new);
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(2);
        try {
            predicates.add(change(query));
        } catch (QueryParseException e) {
        // Skip.
        }
        // For PAT_LEGACY_ID, it may also be the prefix of some commits.
        if (query.length() >= 6 && PAT_LEGACY_ID.matcher(query).matches()) {
            predicates.add(commit(query));
        }
        return Predicate.or(predicates);
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        Predicate<ChangeData> p = ownerDefaultField(query);
        if (!Objects.equals(p, Predicate.<ChangeData>any())) {
            predicates.add(p);
        }
    } catch (OrmException | IOException | ConfigInvalidException | QueryParseException e) {
    // Skip.
    }
    try {
        Predicate<ChangeData> p = reviewerDefaultField(query);
        if (!Objects.equals(p, Predicate.<ChangeData>any())) {
            predicates.add(p);
        }
    } catch (OrmException | IOException | ConfigInvalidException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | IOException | ConfigInvalidException | QueryParseException e) {
    // Skip.
    }
    predicates.add(commit(query));
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#method_after
private Set<Account.Id> parseAccount(String who) throws QueryParseException, OrmException, IOException, ConfigInvalidException {
    if (isSelf(who)) {
        return Collections.singleton(self());
    }
    Set<Account.Id> matches = args.accountResolver.findAll(args.db.get(), who);
    if (matches.isEmpty()) {
        throw error("User " + who + " not found");
    }
    return matches;
}
#end_block

#method_before
@Override
public Change createChange(Context ctx) {
    change = new Change(getChangeKey(commit), changeId, ctx.getAccountId(), new Branch.NameKey(ctx.getProject(), refName), ctx.getWhen());
    change.setStatus(MoreObjects.firstNonNull(status, Change.Status.NEW));
    change.setTopic(topic);
    return change;
}
#method_after
@Override
public Change createChange(Context ctx) throws IOException {
    change = new Change(getChangeKey(ctx.getRevWalk(), commitId), changeId, ctx.getAccountId(), new Branch.NameKey(ctx.getProject(), refName), ctx.getWhen());
    change.setStatus(MoreObjects.firstNonNull(status, Change.Status.NEW));
    change.setTopic(topic);
    change.setPrivate(isPrivate);
    change.setWorkInProgress(workInProgress);
    change.setReviewStarted(!workInProgress);
    change.setRevertOf(revertOf);
    return change;
}
#end_block

#method_before
private static Change.Key getChangeKey(RevCommit commit) {
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    if (!idList.isEmpty()) {
        return new Change.Key(idList.get(idList.size() - 1).trim());
    }
    ObjectId id = ChangeIdUtil.computeChangeId(commit.getTree(), commit, commit.getAuthorIdent(), commit.getCommitterIdent(), commit.getShortMessage());
    StringBuilder changeId = new StringBuilder();
    changeId.append("I").append(ObjectId.toString(id));
    return new Change.Key(changeId.toString());
}
#method_after
private static Change.Key getChangeKey(RevWalk rw, ObjectId id) throws IOException {
    RevCommit commit = rw.parseCommit(id);
    rw.parseBody(commit);
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    if (!idList.isEmpty()) {
        return new Change.Key(idList.get(idList.size() - 1).trim());
    }
    ObjectId changeId = ChangeIdUtil.computeChangeId(commit.getTree(), commit, commit.getAuthorIdent(), commit.getCommitterIdent(), commit.getShortMessage());
    StringBuilder changeIdStr = new StringBuilder();
    changeIdStr.append("I").append(ObjectId.toString(changeId));
    return new Change.Key(changeIdStr.toString());
}
#end_block

#method_before
public ChangeInserter setUpdateRef(boolean updateRef) {
    this.updateRef = updateRef;
    return this;
}
#method_after
@Deprecated
public ChangeInserter setUpdateRef(boolean updateRef) {
    this.updateRef = updateRef;
    return this;
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    validate(ctx);
    if (!updateRef) {
        return;
    }
    if (updateRefCommand == null) {
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, psId.toRefName()));
    } else {
        ctx.addRefUpdate(updateRefCommand);
    }
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    cmd = new ReceiveCommand(ObjectId.zeroId(), commitId, psId.toRefName());
    projectState = projectCache.checkedGet(ctx.getProject());
    validate(ctx);
    if (!updateRef) {
        return;
    }
    ctx.addRefUpdate(cmd);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commit);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commit, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewers), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.TAG_UPLOADED_PATCH_SET);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, PermissionBackendException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), ctx.getRevWalk().parseCommit(commitId), psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    update.setPsDescription(patchSetDescription);
    update.setPrivate(isPrivate);
    update.setWorkInProgress(workInProgress);
    if (revertOf != null) {
        update.setRevertOf(revertOf.get());
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commitId);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commitId, newGroups, pushCert, patchSetDescription);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    Set<Account.Id> reviewersToAdd = new HashSet<>(reviewers);
    if (migration.readChanges()) {
        approvalsUtil.addCcs(ctx.getNotes(), update, filterOnChangeVisibility(db, ctx.getNotes(), extraCC));
    } else {
        reviewersToAdd.addAll(extraCC);
    }
    LabelTypes labelTypes = projectState.getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, filterOnChangeVisibility(db, ctx.getNotes(), reviewersToAdd), Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovalsForNewPatchSet(db, update, labelTypes, patchSet, ctx.getUser(), approvals);
    // reviewer which is needed in several other code paths.
    if (!approvals.isEmpty()) {
        update.putReviewer(ctx.getAccountId(), REVIEWER);
    }
    if (message != null) {
        changeMessage = ChangeMessagesUtil.newMessage(patchSet.getId(), ctx.getUser(), patchSet.getCreatedOn(), message, ChangeMessagesUtil.uploadedPatchSetTag(workInProgress));
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
private Set<Account.Id> filterOnChangeVisibility(final ReviewDb db, final ChangeNotes notes, Set<Account.Id> accounts) {
    return accounts.stream().filter(accountId -> {
        try {
            IdentifiedUser user = userFactory.create(accountId);
            return changeControlFactory.controlFor(notes, user).isVisible(db);
        } catch (OrmException e) {
            log.warn(String.format("Failed to check if account %d can see change %d", accountId.get(), notes.getChangeId().get()), e);
            return false;
        }
    }).collect(toSet());
}
#method_after
private Set<Account.Id> filterOnChangeVisibility(final ReviewDb db, ChangeNotes notes, Set<Account.Id> accounts) {
    return accounts.stream().filter(accountId -> {
        try {
            IdentifiedUser user = userFactory.create(accountId);
            return permissionBackend.user(user).change(notes).database(db).test(ChangePermission.READ);
        } catch (PermissionBackendException e) {
            log.warn(String.format("Failed to check if account %d can see change %d", accountId.get(), notes.getChangeId().get()), e);
            return false;
        }
    }).collect(toSet());
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (sendMail && (notify != NotifyHandling.NONE || !accountsToNotify.isEmpty())) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getProject(), change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.setNotify(notify);
                    cm.setAccountsToNotify(accountsToNotify);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            @SuppressWarnings("unused")
            Future<?> possiblyIgnoredError = sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
        if (approvals != null && !approvals.isEmpty()) {
            ChangeControl changeControl = changeControlFactory.controlFor(ctx.getDb(), change, ctx.getUser());
            List<LabelType> labels = changeControl.getLabelTypes().getLabelTypes();
            Map<String, Short> allApprovals = new HashMap<>();
            Map<String, Short> oldApprovals = new HashMap<>();
            for (LabelType lt : labels) {
                allApprovals.put(lt.getName(), (short) 0);
                oldApprovals.put(lt.getName(), null);
            }
            for (Map.Entry<String, Short> entry : approvals.entrySet()) {
                if (entry.getValue() != 0) {
                    allApprovals.put(entry.getKey(), entry.getValue());
                    oldApprovals.put(entry.getKey(), (short) 0);
                }
            }
            commentAdded.fire(change, patchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException, IOException {
    if (sendMail && (notify != NotifyHandling.NONE || !accountsToNotify.isEmpty())) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getProject(), change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.setNotify(notify);
                    cm.setAccountsToNotify(accountsToNotify);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            @SuppressWarnings("unused")
            Future<?> possiblyIgnoredError = sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
        if (approvals != null && !approvals.isEmpty()) {
            List<LabelType> labels = projectState.getLabelTypes(change.getDest(), ctx.getUser()).getLabelTypes();
            Map<String, Short> allApprovals = new HashMap<>();
            Map<String, Short> oldApprovals = new HashMap<>();
            for (LabelType lt : labels) {
                allApprovals.put(lt.getName(), (short) 0);
                oldApprovals.put(lt.getName(), null);
            }
            for (Map.Entry<String, Short> entry : approvals.entrySet()) {
                if (entry.getValue() != 0) {
                    allApprovals.put(entry.getKey(), entry.getValue());
                    oldApprovals.put(entry.getKey(), (short) 0);
                }
            }
            commentAdded.fire(change, patchSet, ctx.getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
        }
    }
}
#end_block

#method_before
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        String refName = psId.toRefName();
        CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName), refControl.getProjectControl().getProject(), change.getDest().get(), commit, ctx.getIdentifiedUser());
        commitValidatorsFactory.create(validatePolicy, refControl, new NoSshInfo(), ctx.getRepository()).validate(event);
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (!validate) {
        return;
    }
    PermissionBackend.ForRef perm = permissionBackend.user(ctx.getUser()).project(ctx.getProject()).ref(refName);
    try {
        try (CommitReceivedEvent event = new CommitReceivedEvent(cmd, projectState.getProject(), change.getDest().get(), ctx.getRevWalk().getObjectReader(), commitId, ctx.getIdentifiedUser())) {
            commitValidatorsFactory.forGerritCommits(perm, new Branch.NameKey(ctx.getProject(), refName), ctx.getIdentifiedUser(), new NoSshInfo(), ctx.getRevWalk()).validate(event);
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    }
}
#end_block

#method_before
void setLimit(int n) {
    queryProcessor.setLimit(n);
}
#method_after
void setLimit(int n) {
    queryProcessor.setUserProvidedLimit(n);
}
#end_block

#method_before
private ChangeAttribute buildChangeAttribute(ChangeData d, Map<Project.NameKey, Repository> repos, Map<Project.NameKey, RevWalk> revWalks) throws OrmException, IOException {
    ChangeControl cc = d.changeControl().forUser(user);
    LabelTypes labelTypes = cc.getLabelTypes();
    ChangeAttribute c = eventFactory.asChangeAttribute(db, d.change());
    eventFactory.extend(c, d.change());
    if (!trackingFooters.isEmpty()) {
        eventFactory.addTrackingIds(c, trackingFooters.extract(d.commitFooters()));
    }
    if (includeAllReviewers) {
        eventFactory.addAllReviewers(db, c, d.notes());
    }
    if (includeSubmitRecords) {
        eventFactory.addSubmitRecords(c, new SubmitRuleEvaluator(d).setAllowClosed(true).evaluate());
    }
    if (includeCommitMessage) {
        eventFactory.addCommitMessage(c, d.commitMessage());
    }
    RevWalk rw = null;
    if (includePatchSets || includeCurrentPatchSet || includeDependencies) {
        Project.NameKey p = d.change().getProject();
        rw = revWalks.get(p);
        // Cache and reuse repos and revwalks.
        if (rw == null) {
            Repository repo = repoManager.openRepository(p);
            checkState(repos.put(p, repo) == null);
            rw = new RevWalk(repo);
            revWalks.put(p, rw);
        }
    }
    if (includePatchSets) {
        eventFactory.addPatchSets(db, rw, c, d.visiblePatchSets(), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
    }
    if (includeCurrentPatchSet) {
        PatchSet current = d.currentPatchSet();
        if (current != null && cc.isPatchVisible(current, d.db())) {
            c.currentPatchSet = eventFactory.asPatchSetAttribute(db, rw, d.change(), current);
            eventFactory.addApprovals(c.currentPatchSet, d.currentApprovals(), labelTypes);
            if (includeFiles) {
                eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(), d.currentPatchSet());
            }
            if (includeComments) {
                eventFactory.addPatchSetComments(c.currentPatchSet, d.publishedComments());
            }
        }
    }
    if (includeComments) {
        eventFactory.addComments(c, d.messages());
        if (includePatchSets) {
            eventFactory.addPatchSets(db, rw, c, d.visiblePatchSets(), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
            for (PatchSetAttribute attribute : c.patchSets) {
                eventFactory.addPatchSetComments(attribute, d.publishedComments());
            }
        }
    }
    if (includeDependencies) {
        eventFactory.addDependencies(rw, c, d.change(), d.currentPatchSet());
    }
    return c;
}
#method_after
private ChangeAttribute buildChangeAttribute(ChangeData d, Map<Project.NameKey, Repository> repos, Map<Project.NameKey, RevWalk> revWalks) throws OrmException, IOException {
    LabelTypes labelTypes = d.getLabelTypes();
    ChangeAttribute c = eventFactory.asChangeAttribute(db, d.change());
    eventFactory.extend(c, d.change());
    if (!trackingFooters.isEmpty()) {
        eventFactory.addTrackingIds(c, d.trackingFooters());
    }
    if (includeAllReviewers) {
        eventFactory.addAllReviewers(db, c, d.notes());
    }
    if (includeSubmitRecords) {
        eventFactory.addSubmitRecords(c, submitRuleEvaluatorFactory.create(user, d).setAllowClosed(true).evaluate());
    }
    if (includeCommitMessage) {
        eventFactory.addCommitMessage(c, d.commitMessage());
    }
    RevWalk rw = null;
    if (includePatchSets || includeCurrentPatchSet || includeDependencies) {
        Project.NameKey p = d.change().getProject();
        rw = revWalks.get(p);
        // Cache and reuse repos and revwalks.
        if (rw == null) {
            Repository repo = repoManager.openRepository(p);
            checkState(repos.put(p, repo) == null);
            rw = new RevWalk(repo);
            revWalks.put(p, rw);
        }
    }
    ChangeControl ctl = changeControlFactory.controlFor(db, d.change(), user);
    if (includePatchSets) {
        eventFactory.addPatchSets(db, rw, c, ctl.getVisiblePatchSets(d.patchSets(), db), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
    }
    if (includeCurrentPatchSet) {
        PatchSet current = d.currentPatchSet();
        if (current != null && ctl.isVisible(d.db())) {
            c.currentPatchSet = eventFactory.asPatchSetAttribute(db, rw, d.change(), current);
            eventFactory.addApprovals(c.currentPatchSet, d.currentApprovals(), labelTypes);
            if (includeFiles) {
                eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(), d.currentPatchSet());
            }
            if (includeComments) {
                eventFactory.addPatchSetComments(c.currentPatchSet, d.publishedComments());
            }
        }
    }
    if (includeComments) {
        eventFactory.addComments(c, d.messages());
        if (includePatchSets) {
            eventFactory.addPatchSets(db, rw, c, ctl.getVisiblePatchSets(d.patchSets(), db), includeApprovals ? d.approvals().asMap() : null, includeFiles, d.change(), labelTypes);
            for (PatchSetAttribute attribute : c.patchSets) {
                eventFactory.addPatchSetComments(attribute, d.publishedComments());
            }
        }
    }
    if (includeDependencies) {
        eventFactory.addDependencies(rw, c, d.change(), d.currentPatchSet());
    }
    c.plugins = queryProcessor.create(d);
    return c;
}
#end_block

#method_before
public List<ReviewerInfo> format(Collection<ReviewerResource> rsrcs) throws OrmException {
    List<ReviewerInfo> infos = Lists.newArrayListWithCapacity(rsrcs.size());
    AccountLoader loader = accountLoaderFactory.create(true);
    for (ReviewerResource rsrc : rsrcs) {
        ReviewerInfo info = format(new ReviewerInfo(rsrc.getReviewerUser().getAccountId().get()), rsrc.getReviewerControl());
        loader.put(info);
        infos.add(info);
    }
    loader.fill();
    return infos;
}
#method_after
public List<ReviewerInfo> format(Collection<ReviewerResource> rsrcs) throws OrmException, PermissionBackendException {
    List<ReviewerInfo> infos = Lists.newArrayListWithCapacity(rsrcs.size());
    AccountLoader loader = accountLoaderFactory.create(true);
    ChangeData cd = null;
    for (ReviewerResource rsrc : rsrcs) {
        if (cd == null || !cd.getId().equals(rsrc.getChangeId())) {
            cd = changeDataFactory.create(db.get(), rsrc.getChangeResource().getNotes());
        }
        ReviewerInfo info = format(rsrc.getChangeResource().getUser(), new ReviewerInfo(rsrc.getReviewerUser().getAccountId().get()), permissionBackend.user(rsrc.getReviewerUser()).database(db).change(cd), cd);
        loader.put(info);
        infos.add(info);
    }
    loader.fill();
    return infos;
}
#end_block

#method_before
public List<ReviewerInfo> format(ReviewerResource rsrc) throws OrmException {
    return format(ImmutableList.<ReviewerResource>of(rsrc));
}
#method_after
public List<ReviewerInfo> format(ReviewerResource rsrc) throws OrmException, PermissionBackendException {
    return format(ImmutableList.<ReviewerResource>of(rsrc));
}
#end_block

#method_before
public ReviewerInfo format(ReviewerInfo out, ChangeControl ctl, Iterable<PatchSetApproval> approvals) throws OrmException {
    LabelTypes labelTypes = ctl.getLabelTypes();
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    out.approvals = new TreeMap<>(labelTypes.nameComparator());
    for (PatchSetApproval ca : approvals) {
        for (PermissionRange pr : ctl.getLabelRanges()) {
            if (!pr.isEmpty()) {
                LabelType at = labelTypes.byLabel(ca.getLabelId());
                if (at != null) {
                    out.approvals.put(at.getName(), formatValue(ca.getValue()));
                }
            }
        }
    }
    // Add dummy approvals for all permitted labels for the user even if they
    // do not exist in the DB.
    ChangeData cd = changeDataFactory.create(db.get(), ctl);
    PatchSet ps = cd.currentPatchSet();
    if (ps != null) {
        for (SubmitRecord rec : new SubmitRuleEvaluator(cd).setFastEvalLabels(true).evaluate()) {
            if (rec.labels == null) {
                continue;
            }
            for (SubmitRecord.Label label : rec.labels) {
                String name = label.label;
                if (!out.approvals.containsKey(name) && !ctl.getRange(Permission.forLabel(name)).isEmpty()) {
                    out.approvals.put(name, formatValue((short) 0));
                }
            }
        }
    }
    if (out.approvals.isEmpty()) {
        out.approvals = null;
    }
    return out;
}
#method_after
public ReviewerInfo format(CurrentUser user, ReviewerInfo out, PermissionBackend.ForChange perm, ChangeData cd) throws OrmException, PermissionBackendException {
    PatchSet.Id psId = cd.change().currentPatchSetId();
    return format(user, out, perm, cd, approvalsUtil.byPatchSetUser(db.get(), cd.notes(), perm.user(), psId, new Account.Id(out._accountId), null, null));
}
#end_block

#method_before
public static MailRecipients getRecipientsFromFooters(ReviewDb db, AccountResolver accountResolver, List<FooterLine> footerLines) throws OrmException {
    MailRecipients recipients = new MailRecipients();
    for (FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                recipients.reviewers.add(toAccountId(db, accountResolver, footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                recipients.cc.add(toAccountId(db, accountResolver, footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    return recipients;
}
#method_after
public static MailRecipients getRecipientsFromFooters(ReviewDb db, AccountResolver accountResolver, List<FooterLine> footerLines) throws OrmException, IOException {
    MailRecipients recipients = new MailRecipients();
    for (FooterLine footerLine : footerLines) {
        try {
            if (isReviewer(footerLine)) {
                recipients.reviewers.add(toAccountId(db, accountResolver, footerLine.getValue().trim()));
            } else if (footerLine.matches(FooterKey.CC)) {
                recipients.cc.add(toAccountId(db, accountResolver, footerLine.getValue().trim()));
            }
        } catch (NoSuchAccountException e) {
            continue;
        }
    }
    return recipients;
}
#end_block

#method_before
private static Account.Id toAccountId(ReviewDb db, AccountResolver accountResolver, String nameOrEmail) throws OrmException, NoSuchAccountException {
    Account a = accountResolver.findByNameOrEmail(db, nameOrEmail);
    if (a == null) {
        throw new NoSuchAccountException("\"" + nameOrEmail + "\" is not registered");
    }
    return a.getId();
}
#method_after
private static Account.Id toAccountId(ReviewDb db, AccountResolver accountResolver, String nameOrEmail) throws OrmException, NoSuchAccountException, IOException {
    Account a = accountResolver.findByNameOrEmail(db, nameOrEmail);
    if (a == null) {
        throw new NoSuchAccountException("\"" + nameOrEmail + "\" is not registered");
    }
    return a.getId();
}
#end_block

#method_before
private static boolean isReviewer(final FooterLine candidateFooterLine) {
    return candidateFooterLine.matches(FooterKey.SIGNED_OFF_BY) || candidateFooterLine.matches(FooterKey.ACKED_BY) || candidateFooterLine.matches(FooterConstants.REVIEWED_BY) || candidateFooterLine.matches(FooterConstants.TESTED_BY);
}
#method_after
private static boolean isReviewer(FooterLine candidateFooterLine) {
    return candidateFooterLine.matches(FooterKey.SIGNED_OFF_BY) || candidateFooterLine.matches(FooterKey.ACKED_BY) || candidateFooterLine.matches(FooterConstants.REVIEWED_BY) || candidateFooterLine.matches(FooterConstants.TESTED_BY);
}
#end_block

#method_before
public void add(final MailRecipients recipients) {
    reviewers.addAll(recipients.reviewers);
    cc.addAll(recipients.cc);
}
#method_after
public void add(MailRecipients recipients) {
    reviewers.addAll(recipients.reviewers);
    cc.addAll(recipients.cc);
}
#end_block

#method_before
public void remove(final Account.Id toRemove) {
    reviewers.remove(toRemove);
    cc.remove(toRemove);
}
#method_after
public void remove(Account.Id toRemove) {
    reviewers.remove(toRemove);
    cc.remove(toRemove);
}
#end_block

#method_before
public Change.Id cherryPick(Change change, PatchSet patch, final String message, final String ref, final RefControl refControl, int parent) throws NoSuchChangeException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    if (Strings.isNullOrEmpty(ref)) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    Project.NameKey project = change.getProject();
    String destinationBranch = RefNames.shortName(ref);
    IdentifiedUser identifiedUser = user.get();
    try (Repository git = gitManager.openRepository(project);
        // before patch sets are updated.
        ObjectInserter oi = git.newObjectInserter();
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(oi.newReader())) {
        Ref destRef = git.getRefDatabase().exactRef(ref);
        if (destRef == null) {
            throw new InvalidChangeOperationException(String.format("Branch %s does not exist.", destinationBranch));
        }
        CodeReviewCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
        CodeReviewCommit commitToCherryPick = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (parent <= 0 || parent > commitToCherryPick.getParentCount()) {
            throw new InvalidChangeOperationException(String.format("Cherry Pick: Parent %s does not exist. Please specify a parent in" + " range [1, %s].", parent, commitToCherryPick.getParentCount()));
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = identifiedUser.newCommitterIdent(now, serverTimeZone);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), mergeTip, commitToCherryPick.getAuthorIdent(), committerIdent, message);
        String commitMessage = ChangeIdUtil.insertId(message, computedChangeId).trim() + '\n';
        CodeReviewCommit cherryPickCommit;
        try {
            ProjectState projectState = refControl.getProjectControl().getProjectState();
            cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, commitMessage, revWalk, parent - 1, false);
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            Branch.NameKey newDest = new Branch.NameKey(change.getProject(), destRef.getName());
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " reside on the same branch. " + "Cannot create a new patch set.");
            }
            try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getDest().getParentKey(), identifiedUser, now)) {
                bu.setRepository(git, revWalk, oi);
                Change.Id result;
                if (destChanges.size() == 1) {
                    // The change key exists on the destination branch. The cherry pick
                    // will be added as a new patch set.
                    ChangeControl destCtl = refControl.getProjectControl().controlFor(destChanges.get(0).notes());
                    result = insertPatchSet(bu, git, destCtl, cherryPickCommit);
                } else {
                    // Change key not found on destination branch. We can create a new
                    // change.
                    String newTopic = null;
                    if (!Strings.isNullOrEmpty(change.getTopic())) {
                        newTopic = change.getTopic() + "-" + newDest.getShortName();
                    }
                    result = createNewChange(bu, cherryPickCommit, refControl.getRefName(), newTopic, change.getDest());
                    bu.addOp(change.getId(), new AddMessageToSourceChangeOp(changeMessagesUtil, patch.getId(), destinationBranch, cherryPickCommit));
                }
                bu.execute();
                return result;
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(change.getId(), e);
    }
}
#method_after
public Change.Id cherryPick(BatchUpdate.Factory batchUpdateFactory, Change change, PatchSet patch, CherryPickInput input, Branch.NameKey dest) throws OrmException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException, ConfigInvalidException, NoSuchProjectException {
    return cherryPick(batchUpdateFactory, change, patch.getId(), change.getProject(), ObjectId.fromString(patch.getRevision().get()), input, dest);
}
#end_block

#method_before
private Change.Id insertPatchSet(BatchUpdate bu, Repository git, ChangeControl destCtl, CodeReviewCommit cherryPickCommit) throws IOException {
    Change destChange = destCtl.getChange();
    PatchSet.Id psId = ChangeUtil.nextPatchSetId(git, destChange.currentPatchSetId());
    PatchSetInserter inserter = patchSetInserterFactory.create(destCtl, psId, cherryPickCommit);
    PatchSet.Id newPatchSetId = inserter.getPatchSetId();
    bu.addOp(destChange.getId(), inserter.setMessage("Uploaded patch set " + newPatchSetId.get() + ".").setNotify(NotifyHandling.NONE));
    return destChange.getId();
}
#method_after
private Change.Id insertPatchSet(BatchUpdate bu, Repository git, ChangeNotes destNotes, CodeReviewCommit cherryPickCommit, CherryPickInput input) throws IOException, OrmException, BadRequestException, ConfigInvalidException {
    Change destChange = destNotes.getChange();
    PatchSet.Id psId = ChangeUtil.nextPatchSetId(git, destChange.currentPatchSetId());
    PatchSetInserter inserter = patchSetInserterFactory.create(destNotes, psId, cherryPickCommit);
    inserter.setMessage("Uploaded patch set " + inserter.getPatchSetId().get() + ".").setNotify(input.notify).setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
    bu.addOp(destChange.getId(), inserter);
    return destChange.getId();
}
#end_block

#method_before
private Change.Id createNewChange(BatchUpdate bu, CodeReviewCommit cherryPickCommit, String refName, String topic, Branch.NameKey sourceBranch) throws OrmException {
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeInserterFactory.create(changeId, cherryPickCommit, refName).setValidatePolicy(CommitValidators.Policy.GERRIT).setTopic(topic);
    ins.setMessage(messageForDestinationChange(ins.getPatchSetId(), sourceBranch));
    bu.insertChange(ins);
    return changeId;
}
#method_after
private Change.Id createNewChange(BatchUpdate bu, CodeReviewCommit cherryPickCommit, String refName, String topic, @Nullable Change sourceChange, ObjectId sourceCommit, CherryPickInput input) throws OrmException, IOException, BadRequestException, ConfigInvalidException {
    Change.Id changeId = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeInserterFactory.create(changeId, cherryPickCommit, refName);
    Branch.NameKey sourceBranch = sourceChange == null ? null : sourceChange.getDest();
    ins.setMessage(messageForDestinationChange(ins.getPatchSetId(), sourceBranch, sourceCommit)).setTopic(topic).setNotify(input.notify).setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
    if (input.keepReviewers && sourceChange != null) {
        ReviewerSet reviewerSet = approvalsUtil.getReviewers(dbProvider.get(), changeNotesFactory.createChecked(dbProvider.get(), sourceChange));
        Set<Account.Id> reviewers = new HashSet<>(reviewerSet.byState(ReviewerStateInternal.REVIEWER));
        reviewers.add(sourceChange.getOwner());
        reviewers.remove(user.get().getAccountId());
        Set<Account.Id> ccs = new HashSet<>(reviewerSet.byState(ReviewerStateInternal.CC));
        ccs.remove(user.get().getAccountId());
        ins.setReviewers(reviewers).setExtraCC(ccs);
    }
    bu.insertChange(ins);
    return changeId;
}
#end_block

#method_before
private String messageForDestinationChange(PatchSet.Id patchSetId, Branch.NameKey sourceBranch) {
    return new StringBuilder("Patch Set ").append(patchSetId.get()).append(": Cherry Picked from branch ").append(sourceBranch.getShortName()).append(".").toString();
}
#method_after
private String messageForDestinationChange(PatchSet.Id patchSetId, Branch.NameKey sourceBranch, ObjectId sourceCommit) {
    StringBuilder stringBuilder = new StringBuilder("Patch Set ").append(patchSetId.get());
    if (sourceBranch != null) {
        stringBuilder.append(": Cherry Picked from branch ").append(sourceBranch.getShortName());
    } else {
        stringBuilder.append(": Cherry Picked from commit ").append(sourceCommit.getName());
    }
    return stringBuilder.append(".").toString();
}
#end_block

#method_before
protected void setUpDatabase() throws Exception {
    db = schemaFactory.open();
    schemaCreator.create(db);
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    Account userAccount = db.accounts().get(userId);
    userAccount.setPreferredEmail("user@example.com");
    db.accounts().update(ImmutableList.of(userAccount));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userAccount.getId()));
}
#method_after
protected void setUpDatabase() throws Exception {
    try (ReviewDb underlyingDb = inMemoryDatabase.getDatabase().open()) {
        schemaCreator.create(underlyingDb);
    }
    db = schemaFactory.open();
    userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    String email = "user@example.com";
    externalIdsUpdate.create().insert(ExternalId.createEmail(userId, email));
    accountsUpdate.create().update(userId, a -> a.setPreferredEmail(email));
    user = userFactory.create(userId);
    requestContext.setContext(newRequestContext(userId));
}
#end_block

#method_before
@After
public void tearDownInjector() {
    if (lifecycle != null) {
        lifecycle.stop();
    }
    requestContext.setContext(null);
    if (db != null) {
        db.close();
    }
    InMemoryDatabase.drop(schemaFactory);
}
#method_after
@After
public void tearDownInjector() {
    if (lifecycle != null) {
        lifecycle.stop();
    }
    requestContext.setContext(null);
    if (db != null) {
        db.close();
    }
    InMemoryDatabase.drop(inMemoryDatabase);
}
#end_block

#method_before
@Test
public void byTriplet() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChangeForBranch(repo, "branch"));
    String k = change.getKey().get();
    assertQuery("repo~branch~" + k, change);
    assertQuery("change:repo~branch~" + k, change);
    assertQuery("repo~refs/heads/branch~" + k, change);
    assertQuery("change:repo~refs/heads/branch~" + k, change);
    assertQuery("repo~branch~" + k.substring(0, 10), change);
    assertQuery("change:repo~branch~" + k.substring(0, 10), change);
    assertQuery("foo~bar");
    assertThatQueryException("change:foo~bar").hasMessage("Invalid change format");
    assertQuery("otherrepo~branch~" + k);
    assertQuery("change:otherrepo~branch~" + k);
    assertQuery("repo~otherbranch~" + k);
    assertQuery("change:repo~otherbranch~" + k);
    assertQuery("repo~branch~I0000000000000000000000000000000000000000");
    assertQuery("change:repo~branch~I0000000000000000000000000000000000000000");
}
#method_after
@Test
public void byTriplet() throws Exception {
    TestRepository<Repo> repo = createProject("iabcde");
    Change change = insert(repo, newChangeForBranch(repo, "branch"));
    String k = change.getKey().get();
    assertQuery("iabcde~branch~" + k, change);
    assertQuery("change:iabcde~branch~" + k, change);
    assertQuery("iabcde~refs/heads/branch~" + k, change);
    assertQuery("change:iabcde~refs/heads/branch~" + k, change);
    assertQuery("iabcde~branch~" + k.substring(0, 10), change);
    assertQuery("change:iabcde~branch~" + k.substring(0, 10), change);
    assertQuery("foo~bar");
    assertThatQueryException("change:foo~bar").hasMessageThat().isEqualTo("Invalid change format");
    assertQuery("otherrepo~branch~" + k);
    assertQuery("change:otherrepo~branch~" + k);
    assertQuery("iabcde~otherbranch~" + k);
    assertQuery("change:iabcde~otherbranch~" + k);
    assertQuery("iabcde~branch~I0000000000000000000000000000000000000000");
    assertQuery("change:iabcde~branch~I0000000000000000000000000000000000000000");
}
#end_block

#method_before
@Test
public void byStatusOpen() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    ChangeInserter ins2 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change2 = insert(repo, ins2);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change[] expected = new Change[] { change2, change1 };
    assertQuery("status:open", expected);
    assertQuery("status:OPEN", expected);
    assertQuery("status:o", expected);
    assertQuery("status:op", expected);
    assertQuery("status:ope", expected);
    assertQuery("status:pending", expected);
    assertQuery("status:PENDING", expected);
    assertQuery("status:p", expected);
    assertQuery("status:pe", expected);
    assertQuery("status:pen", expected);
    assertQuery("is:open", expected);
}
#method_after
@Test
public void byStatusOpen() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change[] expected = new Change[] { change1 };
    assertQuery("status:open", expected);
    assertQuery("status:OPEN", expected);
    assertQuery("status:o", expected);
    assertQuery("status:op", expected);
    assertQuery("status:ope", expected);
    assertQuery("status:pending", expected);
    assertQuery("status:PENDING", expected);
    assertQuery("status:p", expected);
    assertQuery("status:pe", expected);
    assertQuery("status:pen", expected);
    assertQuery("is:open", expected);
}
#end_block

#method_before
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    assertQuery("status:n", change1);
    assertQuery("status:ne", change1);
    assertQuery("status:new", change1);
    assertQuery("status:N", change1);
    assertQuery("status:nE", change1);
    assertQuery("status:neW", change1);
    assertThatQueryException("status:nx").hasMessage("invalid change status: nx");
    assertThatQueryException("status:newx").hasMessage("invalid change status: newx");
}
#method_after
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChangeWithStatus(repo, Change.Status.NEW);
    Change change1 = insert(repo, ins1);
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    assertQuery("status:n", change1);
    assertQuery("status:ne", change1);
    assertQuery("status:new", change1);
    assertQuery("status:N", change1);
    assertQuery("status:nE", change1);
    assertQuery("status:neW", change1);
    assertThatQueryException("status:nx").hasMessageThat().isEqualTo("invalid change status: nx");
    assertThatQueryException("status:newx").hasMessageThat().isEqualTo("invalid change status: newx");
}
#end_block

#method_before
@Test
public void byCommit() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo);
    insert(repo, ins);
    String sha = ins.getCommit().name();
    assertQuery("0000000000000000000000000000000000000000");
    for (int i = 0; i <= 36; i++) {
        String q = sha.substring(0, 40 - i);
        assertQuery(q, ins.getChange());
    }
}
#method_after
@Test
public void byCommit() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo);
    insert(repo, ins);
    String sha = ins.getCommitId().name();
    assertQuery("0000000000000000000000000000000000000000");
    for (int i = 0; i <= 36; i++) {
        String q = sha.substring(0, 40 - i);
        assertQuery(q, ins.getChange());
    }
}
#end_block

#method_before
@Test
public void byLabel() throws Exception {
    accountManager.authenticate(AuthRequest.forUser("anotheruser"));
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo, null, null, null, null);
    ChangeInserter ins2 = newChange(repo, null, null, null, null);
    ChangeInserter ins3 = newChange(repo, null, null, null, null);
    ChangeInserter ins4 = newChange(repo, null, null, null, null);
    ChangeInserter ins5 = newChange(repo, null, null, null, null);
    Change reviewMinus2Change = insert(repo, ins);
    gApi.changes().id(reviewMinus2Change.getId().get()).current().review(ReviewInput.reject());
    Change reviewMinus1Change = insert(repo, ins2);
    gApi.changes().id(reviewMinus1Change.getId().get()).current().review(ReviewInput.dislike());
    Change noLabelChange = insert(repo, ins3);
    Change reviewPlus1Change = insert(repo, ins4);
    gApi.changes().id(reviewPlus1Change.getId().get()).current().review(ReviewInput.recommend());
    Change reviewPlus2Change = insert(repo, ins5);
    gApi.changes().id(reviewPlus2Change.getId().get()).current().review(ReviewInput.approve());
    Map<String, Short> m = gApi.changes().id(reviewPlus1Change.getId().get()).reviewer(user.getAccountId().toString()).votes();
    assertThat(m).hasSize(1);
    assertThat(m).containsEntry("Code-Review", Short.valueOf((short) 1));
    Map<Integer, Change> changes = new LinkedHashMap<>(5);
    changes.put(2, reviewPlus2Change);
    changes.put(1, reviewPlus1Change);
    changes.put(0, noLabelChange);
    changes.put(-1, reviewMinus1Change);
    changes.put(-2, reviewMinus2Change);
    assertQuery("label:Code-Review=-2", reviewMinus2Change);
    assertQuery("label:Code-Review-2", reviewMinus2Change);
    assertQuery("label:Code-Review=-1", reviewMinus1Change);
    assertQuery("label:Code-Review-1", reviewMinus1Change);
    assertQuery("label:Code-Review=0", noLabelChange);
    assertQuery("label:Code-Review=+1", reviewPlus1Change);
    assertQuery("label:Code-Review=1", reviewPlus1Change);
    assertQuery("label:Code-Review+1", reviewPlus1Change);
    assertQuery("label:Code-Review=+2", reviewPlus2Change);
    assertQuery("label:Code-Review=2", reviewPlus2Change);
    assertQuery("label:Code-Review+2", reviewPlus2Change);
    assertQuery("label:Code-Review>-3", codeReviewInRange(changes, -2, 2));
    assertQuery("label:Code-Review>=-2", codeReviewInRange(changes, -2, 2));
    assertQuery("label:Code-Review>-2", codeReviewInRange(changes, -1, 2));
    assertQuery("label:Code-Review>=-1", codeReviewInRange(changes, -1, 2));
    assertQuery("label:Code-Review>-1", codeReviewInRange(changes, 0, 2));
    assertQuery("label:Code-Review>=0", codeReviewInRange(changes, 0, 2));
    assertQuery("label:Code-Review>0", codeReviewInRange(changes, 1, 2));
    assertQuery("label:Code-Review>=1", codeReviewInRange(changes, 1, 2));
    assertQuery("label:Code-Review>1", reviewPlus2Change);
    assertQuery("label:Code-Review>=2", reviewPlus2Change);
    assertQuery("label:Code-Review>2");
    assertQuery("label:Code-Review<=2", codeReviewInRange(changes, -2, 2));
    assertQuery("label:Code-Review<2", codeReviewInRange(changes, -2, 1));
    assertQuery("label:Code-Review<=1", codeReviewInRange(changes, -2, 1));
    assertQuery("label:Code-Review<1", codeReviewInRange(changes, -2, 0));
    assertQuery("label:Code-Review<=0", codeReviewInRange(changes, -2, 0));
    assertQuery("label:Code-Review<0", codeReviewInRange(changes, -2, -1));
    assertQuery("label:Code-Review<=-1", codeReviewInRange(changes, -2, -1));
    assertQuery("label:Code-Review<-1", reviewMinus2Change);
    assertQuery("label:Code-Review<=-2", reviewMinus2Change);
    assertQuery("label:Code-Review<-2");
    assertQuery("label:Code-Review=+1,anotheruser");
    assertQuery("label:Code-Review=+1,user", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,user=user", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,Administrators", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,group=Administrators", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,user=owner", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,owner", reviewPlus1Change);
    assertQuery("label:Code-Review=+2,owner", reviewPlus2Change);
    assertQuery("label:Code-Review=-2,owner", reviewMinus2Change);
}
#method_after
@Test
public void byLabel() throws Exception {
    accountManager.authenticate(AuthRequest.forUser("anotheruser"));
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo, null, null, null, null, false);
    ChangeInserter ins2 = newChange(repo, null, null, null, null, false);
    ChangeInserter ins3 = newChange(repo, null, null, null, null, false);
    ChangeInserter ins4 = newChange(repo, null, null, null, null, false);
    ChangeInserter ins5 = newChange(repo, null, null, null, null, false);
    Change reviewMinus2Change = insert(repo, ins);
    gApi.changes().id(reviewMinus2Change.getId().get()).current().review(ReviewInput.reject());
    Change reviewMinus1Change = insert(repo, ins2);
    gApi.changes().id(reviewMinus1Change.getId().get()).current().review(ReviewInput.dislike());
    Change noLabelChange = insert(repo, ins3);
    Change reviewPlus1Change = insert(repo, ins4);
    gApi.changes().id(reviewPlus1Change.getId().get()).current().review(ReviewInput.recommend());
    Change reviewPlus2Change = insert(repo, ins5);
    gApi.changes().id(reviewPlus2Change.getId().get()).current().review(ReviewInput.approve());
    Map<String, Short> m = gApi.changes().id(reviewPlus1Change.getId().get()).reviewer(user.getAccountId().toString()).votes();
    assertThat(m).hasSize(1);
    assertThat(m).containsEntry("Code-Review", Short.valueOf((short) 1));
    Map<Integer, Change> changes = new LinkedHashMap<>(5);
    changes.put(2, reviewPlus2Change);
    changes.put(1, reviewPlus1Change);
    changes.put(0, noLabelChange);
    changes.put(-1, reviewMinus1Change);
    changes.put(-2, reviewMinus2Change);
    assertQuery("label:Code-Review=-2", reviewMinus2Change);
    assertQuery("label:Code-Review-2", reviewMinus2Change);
    assertQuery("label:Code-Review=-1", reviewMinus1Change);
    assertQuery("label:Code-Review-1", reviewMinus1Change);
    assertQuery("label:Code-Review=0", noLabelChange);
    assertQuery("label:Code-Review=+1", reviewPlus1Change);
    assertQuery("label:Code-Review=1", reviewPlus1Change);
    assertQuery("label:Code-Review+1", reviewPlus1Change);
    assertQuery("label:Code-Review=+2", reviewPlus2Change);
    assertQuery("label:Code-Review=2", reviewPlus2Change);
    assertQuery("label:Code-Review+2", reviewPlus2Change);
    assertQuery("label:Code-Review>-3", codeReviewInRange(changes, -2, 2));
    assertQuery("label:Code-Review>=-2", codeReviewInRange(changes, -2, 2));
    assertQuery("label:Code-Review>-2", codeReviewInRange(changes, -1, 2));
    assertQuery("label:Code-Review>=-1", codeReviewInRange(changes, -1, 2));
    assertQuery("label:Code-Review>-1", codeReviewInRange(changes, 0, 2));
    assertQuery("label:Code-Review>=0", codeReviewInRange(changes, 0, 2));
    assertQuery("label:Code-Review>0", codeReviewInRange(changes, 1, 2));
    assertQuery("label:Code-Review>=1", codeReviewInRange(changes, 1, 2));
    assertQuery("label:Code-Review>1", reviewPlus2Change);
    assertQuery("label:Code-Review>=2", reviewPlus2Change);
    assertQuery("label:Code-Review>2");
    assertQuery("label:Code-Review<=2", codeReviewInRange(changes, -2, 2));
    assertQuery("label:Code-Review<2", codeReviewInRange(changes, -2, 1));
    assertQuery("label:Code-Review<=1", codeReviewInRange(changes, -2, 1));
    assertQuery("label:Code-Review<1", codeReviewInRange(changes, -2, 0));
    assertQuery("label:Code-Review<=0", codeReviewInRange(changes, -2, 0));
    assertQuery("label:Code-Review<0", codeReviewInRange(changes, -2, -1));
    assertQuery("label:Code-Review<=-1", codeReviewInRange(changes, -2, -1));
    assertQuery("label:Code-Review<-1", reviewMinus2Change);
    assertQuery("label:Code-Review<=-2", reviewMinus2Change);
    assertQuery("label:Code-Review<-2");
    assertQuery("label:Code-Review=+1,anotheruser");
    assertQuery("label:Code-Review=+1,user", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,user=user", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,Administrators", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,group=Administrators", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,user=owner", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,owner", reviewPlus1Change);
    assertQuery("label:Code-Review=+2,owner", reviewPlus2Change);
    assertQuery("label:Code-Review=-2,owner", reviewMinus2Change);
}
#end_block

#method_before
@Test
public void byLabelNotOwner() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo, null, null, null, null);
    Account.Id user1 = createAccount("user1");
    Change reviewPlus1Change = insert(repo, ins);
    // post a review with user1
    requestContext.setContext(newRequestContext(user1));
    gApi.changes().id(reviewPlus1Change.getId().get()).current().review(ReviewInput.recommend());
    assertQuery("label:Code-Review=+1,user=user1", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,owner");
}
#method_after
@Test
public void byLabelNotOwner() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo, null, null, null, null, false);
    Account.Id user1 = createAccount("user1");
    Change reviewPlus1Change = insert(repo, ins);
    // post a review with user1
    requestContext.setContext(newRequestContext(user1));
    gApi.changes().id(reviewPlus1Change.getId().get()).current().review(ReviewInput.recommend());
    assertQuery("label:Code-Review=+1,user=user1", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,owner");
}
#end_block

#method_before
@Test
public void maxPages() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    QueryRequest query = newQuery("status:new").withLimit(10);
    assertQuery(query, change);
    assertQuery(query.withStart(1));
    assertQuery(query.withStart(99));
    assertThatQueryException(query.withStart(100)).hasMessage("Cannot go beyond page 10 of results");
    assertQuery(query.withLimit(100).withStart(100));
}
#method_after
@Test
public void maxPages() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    QueryRequest query = newQuery("status:new").withLimit(10);
    assertQuery(query, change);
    assertQuery(query.withStart(1));
    assertQuery(query.withStart(99));
    assertThatQueryException(query.withStart(100)).hasMessageThat().isEqualTo("Cannot go beyond page 10 of results");
    assertQuery(query.withLimit(100).withStart(100));
}
#end_block

#method_before
@Test
public void byStar() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    gApi.accounts().self().setStars(change1.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList("red", "blue"))));
    gApi.accounts().self().setStars(change2.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "green", "blue"))));
    // check labeled stars
    assertQuery("star:red", change1);
    assertQuery("star:blue", change2, change1);
    assertQuery("has:stars", change2, change1);
    // check default star
    assertQuery("has:star", change2);
    assertQuery("is:starred", change2);
    assertQuery("starredby:self", change2);
    assertQuery("star:" + StarredChangesUtil.DEFAULT_LABEL, change2);
}
#method_after
@Test
public void byStar() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChange(repo));
    Change change2 = insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change change3 = insert(repo, newChangeWithStatus(repo, Change.Status.MERGED));
    Change change4 = insert(repo, newChange(repo));
    gApi.accounts().self().setStars(change1.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList("red", "blue"))));
    gApi.accounts().self().setStars(change2.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "green", "blue"))));
    gApi.accounts().self().setStars(change4.getId().toString(), new StarsInput(new HashSet<>(Arrays.asList("ignore"))));
    // check labeled stars
    assertQuery("star:red", change1);
    assertQuery("star:blue", change2, change1);
    assertQuery("has:stars", change4, change2, change1);
    // check default star
    assertQuery("has:star", change2);
    assertQuery("is:starred", change2);
    assertQuery("starredby:self", change2);
    assertQuery("star:" + StarredChangesUtil.DEFAULT_LABEL, change2);
    // check ignored
    assertQuery("is:ignored", change4);
    assertQuery("-is:ignored", change3, change2, change1);
}
#end_block

#method_before
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    int n = 10;
    List<String> shas = new ArrayList<>(n);
    List<Integer> expectedIds = new ArrayList<>(n);
    Branch.NameKey dest = null;
    for (int i = 0; i < n; i++) {
        ChangeInserter ins = newChange(repo);
        insert(repo, ins);
        if (dest == null) {
            dest = ins.getChange().getDest();
        }
        shas.add(ins.getCommit().name());
        expectedIds.add(ins.getChange().getId().get());
    }
    for (int i = 1; i <= 11; i++) {
        Iterable<ChangeData> cds = internalChangeQuery.byCommitsOnBranchNotMerged(repo.getRepository(), db, dest, shas, i);
        Iterable<Integer> ids = FluentIterable.from(cds).transform(in -> in.getId().get());
        String name = "limit " + i;
        assertThat(ids).named(name).hasSize(n);
        assertThat(ids).named(name).containsExactlyElementsIn(expectedIds);
    }
}
#method_after
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> tr = createProject("repo");
    testByCommitsOnBranchNotMerged(tr, ImmutableSet.of());
}
#end_block

#method_before
@Test
public void prepopulatedFields() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    db = new DisabledReviewDb();
    requestContext.setContext(newRequestContext(userId));
    // Use QueryProcessor directly instead of API so we get ChangeDatas back.
    List<ChangeData> cds = queryProcessor.query(queryBuilder.parse(change.getId().toString())).entities();
    assertThat(cds).hasSize(1);
    ChangeData cd = cds.get(0);
    cd.change();
    cd.patchSets();
    cd.currentApprovals();
    cd.changedLines();
    cd.reviewedBy();
    cd.reviewers();
    cd.unresolvedCommentCount();
    // TODO(dborowitz): Swap out GitRepositoryManager somehow? Will probably be
    // necessary for NoteDb anyway.
    cd.isMergeable();
    exception.expect(DisabledReviewDb.Disabled.class);
    cd.messages();
}
#method_after
@Test
public void prepopulatedFields() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    db = new DisabledReviewDb();
    requestContext.setContext(newRequestContext(userId));
    // Use QueryProcessor directly instead of API so we get ChangeDatas back.
    List<ChangeData> cds = queryProcessorProvider.get().query(queryBuilder.parse(change.getId().toString())).entities();
    assertThat(cds).hasSize(1);
    ChangeData cd = cds.get(0);
    cd.change();
    cd.patchSets();
    cd.currentApprovals();
    cd.changedLines();
    cd.reviewedBy();
    cd.reviewers();
    cd.unresolvedCommentCount();
    // TODO(dborowitz): Swap out GitRepositoryManager somehow? Will probably be
    // necessary for NoteDb anyway.
    cd.isMergeable();
    exception.expect(DisabledReviewDb.Disabled.class);
    cd.messages();
}
#end_block

#method_before
@Test
public void prepopulateOnlyRequestedFields() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    db = new DisabledReviewDb();
    requestContext.setContext(newRequestContext(userId));
    // Use QueryProcessor directly instead of API so we get ChangeDatas back.
    List<ChangeData> cds = queryProcessor.setRequestedFields(ImmutableSet.of(ChangeField.PATCH_SET.getName(), ChangeField.CHANGE.getName())).query(queryBuilder.parse(change.getId().toString())).entities();
    assertThat(cds).hasSize(1);
    ChangeData cd = cds.get(0);
    cd.change();
    cd.patchSets();
    exception.expect(DisabledReviewDb.Disabled.class);
    cd.currentApprovals();
}
#method_after
@Test
public void prepopulateOnlyRequestedFields() throws Exception {
    assume().that(notesMigration.readChanges()).isFalse();
    TestRepository<Repo> repo = createProject("repo");
    Change change = insert(repo, newChange(repo));
    db = new DisabledReviewDb();
    requestContext.setContext(newRequestContext(userId));
    // Use QueryProcessor directly instead of API so we get ChangeDatas back.
    List<ChangeData> cds = queryProcessorProvider.get().setRequestedFields(ImmutableSet.of(ChangeField.PATCH_SET.getName(), ChangeField.CHANGE.getName())).query(queryBuilder.parse(change.getId().toString())).entities();
    assertThat(cds).hasSize(1);
    ChangeData cd = cds.get(0);
    cd.change();
    cd.patchSets();
    exception.expect(DisabledReviewDb.Disabled.class);
    cd.currentApprovals();
}
#end_block

#method_before
protected ChangeInserter newChange(TestRepository<Repo> repo) throws Exception {
    return newChange(repo, null, null, null, null);
}
#method_after
protected ChangeInserter newChange(TestRepository<Repo> repo) throws Exception {
    return newChange(repo, null, null, null, null, false);
}
#end_block

#method_before
protected ChangeInserter newChangeForCommit(TestRepository<Repo> repo, RevCommit commit) throws Exception {
    return newChange(repo, commit, null, null, null);
}
#method_after
protected ChangeInserter newChangeForCommit(TestRepository<Repo> repo, RevCommit commit) throws Exception {
    return newChange(repo, commit, null, null, null, false);
}
#end_block

#method_before
protected ChangeInserter newChangeForBranch(TestRepository<Repo> repo, String branch) throws Exception {
    return newChange(repo, null, branch, null, null);
}
#method_after
protected ChangeInserter newChangeForBranch(TestRepository<Repo> repo, String branch) throws Exception {
    return newChange(repo, null, branch, null, null, false);
}
#end_block

#method_before
protected ChangeInserter newChangeWithStatus(TestRepository<Repo> repo, Change.Status status) throws Exception {
    return newChange(repo, null, null, status, null);
}
#method_after
protected ChangeInserter newChangeWithStatus(TestRepository<Repo> repo, Change.Status status) throws Exception {
    return newChange(repo, null, null, status, null, false);
}
#end_block

#method_before
protected ChangeInserter newChangeWithTopic(TestRepository<Repo> repo, String topic) throws Exception {
    return newChange(repo, null, null, null, topic);
}
#method_after
protected ChangeInserter newChangeWithTopic(TestRepository<Repo> repo, String topic) throws Exception {
    return newChange(repo, null, null, null, topic, false);
}
#end_block

#method_before
protected ChangeInserter newChange(TestRepository<Repo> repo, @Nullable RevCommit commit, @Nullable String branch, @Nullable Change.Status status, @Nullable String topic) throws Exception {
    if (commit == null) {
        commit = repo.parseBody(repo.commit().message("message").create());
    }
    branch = MoreObjects.firstNonNull(branch, "refs/heads/master");
    if (!branch.startsWith("refs/heads/")) {
        branch = "refs/heads/" + branch;
    }
    Change.Id id = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeFactory.create(id, commit, branch).setValidatePolicy(CommitValidators.Policy.NONE).setStatus(status).setTopic(topic);
    return ins;
}
#method_after
protected ChangeInserter newChange(TestRepository<Repo> repo, @Nullable RevCommit commit, @Nullable String branch, @Nullable Change.Status status, @Nullable String topic, boolean workInProgress) throws Exception {
    if (commit == null) {
        commit = repo.parseBody(repo.commit().message("message").create());
    }
    branch = MoreObjects.firstNonNull(branch, "refs/heads/master");
    if (!branch.startsWith("refs/heads/")) {
        branch = "refs/heads/" + branch;
    }
    Change.Id id = new Change.Id(seq.nextChangeId());
    ChangeInserter ins = changeFactory.create(id, commit, branch).setValidate(false).setStatus(status).setTopic(topic).setWorkInProgress(workInProgress);
    return ins;
}
#end_block

#method_before
protected Change newPatchSet(TestRepository<Repo> repo, Change c) throws Exception {
    // Add a new file so the patch set is not a trivial rebase, to avoid default
    // Code-Review label copying.
    int n = c.currentPatchSetId().get() + 1;
    RevCommit commit = repo.parseBody(repo.commit().message("message").add("file" + n, "contents " + n).create());
    ChangeControl ctl = changeControlFactory.controlFor(db, c, user);
    PatchSetInserter inserter = patchSetFactory.create(ctl, new PatchSet.Id(c.getId(), n), commit).setNotify(NotifyHandling.NONE).setFireRevisionCreated(false).setValidatePolicy(CommitValidators.Policy.NONE);
    try (BatchUpdate bu = updateFactory.create(db, c.getProject(), user, TimeUtil.nowTs());
        ObjectInserter oi = repo.getRepository().newObjectInserter()) {
        bu.setRepository(repo.getRepository(), repo.getRevWalk(), oi);
        bu.addOp(c.getId(), inserter);
        bu.execute();
    }
    return inserter.getChange();
}
#method_after
protected Change newPatchSet(TestRepository<Repo> repo, Change c) throws Exception {
    // Add a new file so the patch set is not a trivial rebase, to avoid default
    // Code-Review label copying.
    int n = c.currentPatchSetId().get() + 1;
    RevCommit commit = repo.parseBody(repo.commit().message("message").add("file" + n, "contents " + n).create());
    PatchSetInserter inserter = patchSetFactory.create(changeNotesFactory.createChecked(db, c), new PatchSet.Id(c.getId(), n), commit).setNotify(NotifyHandling.NONE).setFireRevisionCreated(false).setValidate(false);
    try (BatchUpdate bu = updateFactory.create(db, c.getProject(), user, TimeUtil.nowTs());
        ObjectInserter oi = repo.getRepository().newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo.getRepository(), rw, oi);
        bu.addOp(c.getId(), inserter);
        bu.execute();
    }
    return inserter.getChange();
}
#end_block

#method_before
protected List<ChangeInfo> assertQuery(QueryRequest query, Change... changes) throws Exception {
    List<ChangeInfo> result = query.get();
    Iterable<Integer> ids = ids(result);
    assertThat(ids).named(format(query, ids, changes)).containsExactlyElementsIn(ids(changes)).inOrder();
    return result;
}
#method_after
protected List<ChangeInfo> assertQuery(QueryRequest query, Change... changes) throws Exception {
    return assertQueryByIds(query, Arrays.stream(changes).map(Change::getId).toArray(Change.Id[]::new));
}
#end_block

#method_before
private String format(Iterator<Integer> changeIds) throws RestApiException {
    StringBuilder b = new StringBuilder();
    b.append("[");
    while (changeIds.hasNext()) {
        int id = changeIds.next();
        ChangeInfo c = gApi.changes().id(id).get();
        b.append("{").append(id).append(" (").append(c.changeId).append("), ").append("dest=").append(new Branch.NameKey(new Project.NameKey(c.project), c.branch)).append(", ").append("status=").append(c.status).append(", ").append("lastUpdated=").append(c.updated.getTime()).append("}");
        if (changeIds.hasNext()) {
            b.append(", ");
        }
    }
    b.append("]");
    return b.toString();
}
#method_after
private String format(QueryRequest query, Iterable<Change.Id> actualIds, Change.Id... expectedChanges) throws RestApiException {
    StringBuilder b = new StringBuilder();
    b.append("query '").append(query.getQuery()).append("' with expected changes ");
    b.append(format(Arrays.asList(expectedChanges)));
    b.append(" and result ");
    b.append(format(actualIds));
    return b.toString();
}
#end_block

#method_before
protected static Iterable<Integer> ids(Change... changes) {
    return FluentIterable.from(Arrays.asList(changes)).transform(in -> in.getId().get());
}
#method_after
protected static Iterable<Change.Id> ids(Change... changes) {
    return Arrays.stream(changes).map(c -> c.getId()).collect(toList());
}
#end_block

#method_before
protected static Iterable<Integer> ids(Iterable<ChangeInfo> changes) {
    return FluentIterable.from(changes).transform(in -> in._number);
}
#method_after
protected static Iterable<Change.Id> ids(Iterable<ChangeInfo> changes) {
    return Streams.stream(changes).map(c -> new Change.Id(c._number)).collect(toList());
}
#end_block

#method_before
private Account.Id createAccount(String name) throws Exception {
    return accountManager.authenticate(AuthRequest.forUser(name)).getAccountId();
}
#method_after
private Account.Id createAccount(String username, String fullName, String email, boolean active) throws Exception {
    try (ManualRequestContext ctx = oneOffRequestContext.open()) {
        Account.Id id = accountManager.authenticate(AuthRequest.forUser(username)).getAccountId();
        if (email != null) {
            accountManager.link(id, AuthRequest.forEmail(email));
        }
        accountsUpdate.create().update(id, a -> {
            a.setFullName(fullName);
            a.setPreferredEmail(email);
            a.setActive(active);
        });
        return id;
    }
}
#end_block

#method_before
@Override
public RevisionApi current() {
    throw new NotImplementedException();
}
#method_after
@Override
public RevisionApi current() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public RevisionApi revision(int id) {
    throw new NotImplementedException();
}
#method_after
@Override
public RevisionApi revision(int id) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ReviewerApi reviewer(String id) {
    throw new NotImplementedException();
}
#method_after
@Override
public ReviewerApi reviewer(String id) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public RevisionApi revision(String id) {
    throw new NotImplementedException();
}
#method_after
@Override
public RevisionApi revision(String id) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void abandon() {
    throw new NotImplementedException();
}
#method_after
@Override
public void abandon() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public void abandon(AbandonInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void restore() {
    throw new NotImplementedException();
}
#method_after
@Override
public void restore() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public void restore(RestoreInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void move(String destination) {
    throw new NotImplementedException();
}
#method_after
@Override
public void move(String destination) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void move(MoveInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public void move(MoveInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeApi revert() {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi revert() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeApi revert(RevertInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void delete() {
    throw new NotImplementedException();
}
#method_after
@Override
public void delete() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public String topic() {
    throw new NotImplementedException();
}
#method_after
@Override
public String topic() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void topic(String topic) {
    throw new NotImplementedException();
}
#method_after
@Override
public void topic(String topic) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public IncludedInInfo includedIn() {
    throw new NotImplementedException();
}
#method_after
@Override
public IncludedInInfo includedIn() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void addReviewer(AddReviewerInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public AddReviewerResult addReviewer(AddReviewerInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void addReviewer(String in) {
    throw new NotImplementedException();
}
#method_after
@Override
public AddReviewerResult addReviewer(String in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SuggestedReviewersRequest suggestReviewers() {
    throw new NotImplementedException();
}
#method_after
@Override
public SuggestedReviewersRequest suggestReviewers() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SuggestedReviewersRequest suggestReviewers(String query) {
    throw new NotImplementedException();
}
#method_after
@Override
public SuggestedReviewersRequest suggestReviewers(String query) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeInfo get(EnumSet<ListChangesOption> options) {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> options) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeInfo get() {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeInfo get() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeInfo info() {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeInfo info() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public EditInfo getEdit() {
    throw new NotImplementedException();
}
#method_after
@Override
public EditInfo getEdit() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeEditApi edit() {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeEditApi edit() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void setHashtags(HashtagsInput input) {
    throw new NotImplementedException();
}
#method_after
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Set<String> getHashtags() {
    throw new NotImplementedException();
}
#method_after
@Override
public Set<String> getHashtags() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public AccountInfo setAssignee(AssigneeInput input) {
    throw new NotImplementedException();
}
#method_after
@Override
public AccountInfo setAssignee(AssigneeInput input) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public AccountInfo getAssignee() {
    throw new NotImplementedException();
}
#method_after
@Override
public AccountInfo getAssignee() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<AccountInfo> getPastAssignees() {
    throw new NotImplementedException();
}
#method_after
@Override
public List<AccountInfo> getPastAssignees() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public AccountInfo deleteAssignee() {
    throw new NotImplementedException();
}
#method_after
@Override
public AccountInfo deleteAssignee() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> comments() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, List<RobotCommentInfo>> robotComments() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> drafts() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeInfo check() {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeInfo check() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeInfo check(FixInput fix) {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeInfo check(FixInput fix) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void index() {
    throw new NotImplementedException();
}
#method_after
@Override
public void index() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<ChangeInfo> submittedTogether() {
    throw new NotImplementedException();
}
#method_after
@Override
public List<ChangeInfo> submittedTogether() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<SubmittedTogetherOption> options) {
    throw new NotImplementedException();
}
#method_after
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<SubmittedTogetherOption> options) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<ListChangesOption> a, EnumSet<SubmittedTogetherOption> b) {
    throw new NotImplementedException();
}
#method_after
@Override
public SubmittedTogetherInfo submittedTogether(EnumSet<ListChangesOption> a, EnumSet<SubmittedTogetherOption> b) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public ChangeInfo createMergePatchSet(MergePatchSetInput in) {
    throw new NotImplementedException();
}
#method_after
@Override
public ChangeInfo createMergePatchSet(MergePatchSetInput in) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public PatchScript call() throws OrmException, LargeObjectException, AuthException, InvalidChangeOperationException, IOException {
    if (parentNum < 0) {
        validatePatchSetId(psa);
    }
    validatePatchSetId(psb);
    change = control.getChange();
    project = change.getProject();
    PatchSet psEntityA = psa != null ? psUtil.get(db, control.getNotes(), psa) : null;
    PatchSet psEntityB = psb.get() == 0 ? new PatchSet(psb) : psUtil.get(db, control.getNotes(), psb);
    try (Repository git = repoManager.openRepository(project)) {
        bId = toObjectId(psEntityB);
        if (parentNum < 0) {
            aId = psEntityA != null ? toObjectId(psEntityA) : null;
        }
        try {
            final PatchList list = listFor(keyFor(diffPrefs.ignoreWhitespace));
            final PatchScriptBuilder b = newBuilder(list, git);
            final PatchListEntry content = list.get(fileName);
            loadCommentsAndHistory(control.getNotes(), content.getChangeType(), content.getOldName(), content.getNewName());
            return b.toPatchScript(content, comments, history);
        } catch (PatchListNotAvailableException e) {
            throw new NoSuchChangeException(changeId, e);
        } catch (IOException e) {
            log.error("File content unavailable", e);
            throw new NoSuchChangeException(changeId, e);
        } catch (org.eclipse.jgit.errors.LargeObjectException err) {
            throw new LargeObjectException("File content is too large", err);
        }
    } catch (RepositoryNotFoundException e) {
        log.error("Repository " + project + " not found", e);
        throw new NoSuchChangeException(changeId, e);
    } catch (IOException e) {
        log.error("Cannot open repository " + project, e);
        throw new NoSuchChangeException(changeId, e);
    }
}
#method_after
@Override
public PatchScript call() throws OrmException, LargeObjectException, AuthException, InvalidChangeOperationException, IOException {
    if (parentNum < 0) {
        validatePatchSetId(psa);
    }
    validatePatchSetId(psb);
    PatchSet psEntityA = psa != null ? psUtil.get(db, notes, psa) : null;
    PatchSet psEntityB = psb.get() == 0 ? new PatchSet(psb) : psUtil.get(db, notes, psb);
    ChangeControl ctl = changeControlFactory.controlFor(notes, userProvider.get());
    if ((psEntityA != null && !ctl.isVisible(db)) || (psEntityB != null && !ctl.isVisible(db))) {
        throw new NoSuchChangeException(changeId);
    }
    try (Repository git = repoManager.openRepository(notes.getProjectName())) {
        bId = toObjectId(psEntityB);
        if (parentNum < 0) {
            aId = psEntityA != null ? toObjectId(psEntityA) : null;
        }
        try {
            final PatchList list = listFor(keyFor(diffPrefs.ignoreWhitespace));
            final PatchScriptBuilder b = newBuilder(list, git);
            final PatchListEntry content = list.get(fileName);
            loadCommentsAndHistory(ctl, content.getChangeType(), content.getOldName(), content.getNewName());
            return b.toPatchScript(content, comments, history);
        } catch (PatchListNotAvailableException e) {
            throw new NoSuchChangeException(changeId, e);
        } catch (IOException e) {
            log.error("File content unavailable", e);
            throw new NoSuchChangeException(changeId, e);
        } catch (org.eclipse.jgit.errors.LargeObjectException err) {
            throw new LargeObjectException("File content is too large", err);
        }
    } catch (RepositoryNotFoundException e) {
        log.error("Repository " + notes.getProjectName() + " not found", e);
        throw new NoSuchChangeException(changeId, e);
    } catch (IOException e) {
        log.error("Cannot open repository " + notes.getProjectName(), e);
        throw new NoSuchChangeException(changeId, e);
    }
}
#end_block

#method_before
private PatchListKey keyFor(final Whitespace whitespace) {
    if (parentNum < 0) {
        return new PatchListKey(aId, bId, whitespace);
    }
    return PatchListKey.againstParentNum(parentNum + 1, bId, whitespace);
}
#method_after
private PatchListKey keyFor(Whitespace whitespace) {
    if (parentNum < 0) {
        return PatchListKey.againstCommit(aId, bId, whitespace);
    }
    return PatchListKey.againstParentNum(parentNum + 1, bId, whitespace);
}
#end_block

#method_before
private PatchList listFor(final PatchListKey key) throws PatchListNotAvailableException {
    return patchListCache.get(key, project);
}
#method_after
private PatchList listFor(PatchListKey key) throws PatchListNotAvailableException {
    return patchListCache.get(key, notes.getProjectName());
}
#end_block

#method_before
private PatchScriptBuilder newBuilder(final PatchList list, Repository git) {
    final PatchScriptBuilder b = builderFactory.get();
    b.setRepository(git, project);
    b.setChange(change);
    b.setDiffPrefs(diffPrefs);
    b.setTrees(list.getComparisonType(), list.getOldId(), list.getNewId());
    return b;
}
#method_after
private PatchScriptBuilder newBuilder(PatchList list, Repository git) {
    final PatchScriptBuilder b = builderFactory.get();
    b.setRepository(git, notes.getProjectName());
    b.setChange(notes.getChange());
    b.setDiffPrefs(diffPrefs);
    b.setTrees(list.getComparisonType(), list.getOldId(), list.getNewId());
    return b;
}
#end_block

#method_before
private ObjectId toObjectId(PatchSet ps) throws NoSuchChangeException, AuthException, NoSuchChangeException, IOException, OrmException {
    if (ps.getId().get() == 0) {
        return getEditRev();
    }
    if (ps.getRevision() == null || ps.getRevision().get() == null) {
        throw new NoSuchChangeException(changeId);
    }
    try {
        return ObjectId.fromString(ps.getRevision().get());
    } catch (IllegalArgumentException e) {
        log.error("Patch set " + ps.getId() + " has invalid revision");
        throw new NoSuchChangeException(changeId, e);
    }
}
#method_after
private ObjectId toObjectId(PatchSet ps) throws AuthException, IOException, OrmException {
    if (ps.getId().get() == 0) {
        return getEditRev();
    }
    if (ps.getRevision() == null || ps.getRevision().get() == null) {
        throw new NoSuchChangeException(changeId);
    }
    try {
        return ObjectId.fromString(ps.getRevision().get());
    } catch (IllegalArgumentException e) {
        log.error("Patch set " + ps.getId() + " has invalid revision");
        throw new NoSuchChangeException(changeId, e);
    }
}
#end_block

#method_before
private ObjectId getEditRev() throws AuthException, NoSuchChangeException, IOException, OrmException {
    edit = editReader.byChange(change);
    if (edit.isPresent()) {
        return edit.get().getRef().getObjectId();
    }
    throw new NoSuchChangeException(change.getId());
}
#method_after
private ObjectId getEditRev() throws AuthException, IOException, OrmException {
    edit = editReader.byChange(notes);
    if (edit.isPresent()) {
        return edit.get().getEditCommit();
    }
    throw new NoSuchChangeException(notes.getChangeId());
}
#end_block

#method_before
private void validatePatchSetId(final PatchSet.Id psId) throws NoSuchChangeException {
    if (psId == null) {
    // OK, means use base;
    } else if (changeId.equals(psId.getParentKey())) {
    // OK, same change;
    } else {
        throw new NoSuchChangeException(changeId);
    }
}
#method_after
private void validatePatchSetId(PatchSet.Id psId) throws NoSuchChangeException {
    if (psId == null) {
    // OK, means use base;
    } else if (changeId.equals(psId.getParentKey())) {
    // OK, same change;
    } else {
        throw new NoSuchChangeException(changeId);
    }
}
#end_block

#method_before
private void loadCommentsAndHistory(ChangeNotes notes, ChangeType changeType, String oldName, String newName) throws OrmException {
    Map<Patch.Key, Patch> byKey = new HashMap<>();
    if (loadHistory) {
        // This seems like a cheap trick. It doesn't properly account for a
        // file that gets renamed between patch set 1 and patch set 2. We
        // will wind up packing the wrong Patch object because we didn't do
        // proper rename detection between the patch sets.
        // 
        history = new ArrayList<>();
        for (PatchSet ps : psUtil.byChange(db, notes)) {
            String name = fileName;
            if (psa != null) {
                switch(changeType) {
                    case COPIED:
                    case RENAMED:
                        if (ps.getId().equals(psa)) {
                            name = oldName;
                        }
                        break;
                    case MODIFIED:
                    case DELETED:
                    case ADDED:
                    case REWRITE:
                        break;
                }
            }
            Patch p = new Patch(new Patch.Key(ps.getId(), name));
            history.add(p);
            byKey.put(p.getKey(), p);
        }
        if (edit != null && edit.isPresent()) {
            Patch p = new Patch(new Patch.Key(new PatchSet.Id(psb.getParentKey(), 0), fileName));
            history.add(p);
            byKey.put(p.getKey(), p);
        }
    }
    if (loadComments && edit == null) {
        comments = new CommentDetail(psa, psb);
        switch(changeType) {
            case ADDED:
            case MODIFIED:
                loadPublished(byKey, newName);
                break;
            case DELETED:
                loadPublished(byKey, newName);
                break;
            case COPIED:
            case RENAMED:
                if (psa != null) {
                    loadPublished(byKey, oldName);
                }
                loadPublished(byKey, newName);
                break;
            case REWRITE:
                break;
        }
        CurrentUser user = control.getUser();
        if (user.isIdentifiedUser()) {
            Account.Id me = user.getAccountId();
            switch(changeType) {
                case ADDED:
                case MODIFIED:
                    loadDrafts(byKey, me, newName);
                    break;
                case DELETED:
                    loadDrafts(byKey, me, newName);
                    break;
                case COPIED:
                case RENAMED:
                    if (psa != null) {
                        loadDrafts(byKey, me, oldName);
                    }
                    loadDrafts(byKey, me, newName);
                    break;
                case REWRITE:
                    break;
            }
        }
    }
}
#method_after
private void loadCommentsAndHistory(ChangeControl ctl, ChangeType changeType, String oldName, String newName) throws OrmException {
    Map<Patch.Key, Patch> byKey = new HashMap<>();
    if (loadHistory) {
        // This seems like a cheap trick. It doesn't properly account for a
        // file that gets renamed between patch set 1 and patch set 2. We
        // will wind up packing the wrong Patch object because we didn't do
        // proper rename detection between the patch sets.
        // 
        history = new ArrayList<>();
        for (PatchSet ps : psUtil.byChange(db, notes)) {
            if (!ctl.isVisible(db)) {
                continue;
            }
            String name = fileName;
            if (psa != null) {
                switch(changeType) {
                    case COPIED:
                    case RENAMED:
                        if (ps.getId().equals(psa)) {
                            name = oldName;
                        }
                        break;
                    case MODIFIED:
                    case DELETED:
                    case ADDED:
                    case REWRITE:
                        break;
                }
            }
            Patch p = new Patch(new Patch.Key(ps.getId(), name));
            history.add(p);
            byKey.put(p.getKey(), p);
        }
        if (edit != null && edit.isPresent()) {
            Patch p = new Patch(new Patch.Key(new PatchSet.Id(psb.getParentKey(), 0), fileName));
            history.add(p);
            byKey.put(p.getKey(), p);
        }
    }
    if (loadComments && edit == null) {
        comments = new CommentDetail(psa, psb);
        switch(changeType) {
            case ADDED:
            case MODIFIED:
                loadPublished(byKey, newName);
                break;
            case DELETED:
                loadPublished(byKey, newName);
                break;
            case COPIED:
            case RENAMED:
                if (psa != null) {
                    loadPublished(byKey, oldName);
                }
                loadPublished(byKey, newName);
                break;
            case REWRITE:
                break;
        }
        CurrentUser user = userProvider.get();
        if (user.isIdentifiedUser()) {
            Account.Id me = user.getAccountId();
            switch(changeType) {
                case ADDED:
                case MODIFIED:
                    loadDrafts(byKey, me, newName);
                    break;
                case DELETED:
                    loadDrafts(byKey, me, newName);
                    break;
                case COPIED:
                case RENAMED:
                    if (psa != null) {
                        loadDrafts(byKey, me, oldName);
                    }
                    loadDrafts(byKey, me, newName);
                    break;
                case REWRITE:
                    break;
            }
        }
    }
}
#end_block

#method_before
private void loadPublished(Map<Patch.Key, Patch> byKey, String file) throws OrmException {
    ChangeNotes notes = control.getNotes();
    for (Comment c : commentsUtil.publishedByChangeFile(db, notes, changeId, file)) {
        comments.include(change.getId(), c);
        PatchSet.Id psId = new PatchSet.Id(change.getId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
}
#method_after
private void loadPublished(Map<Patch.Key, Patch> byKey, String file) throws OrmException {
    for (Comment c : commentsUtil.publishedByChangeFile(db, notes, changeId, file)) {
        comments.include(notes.getChangeId(), c);
        PatchSet.Id psId = new PatchSet.Id(notes.getChangeId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
}
#end_block

#method_before
private void loadDrafts(Map<Patch.Key, Patch> byKey, Account.Id me, String file) throws OrmException {
    for (Comment c : commentsUtil.draftByChangeFileAuthor(db, control.getNotes(), file, me)) {
        comments.include(change.getId(), c);
        PatchSet.Id psId = new PatchSet.Id(change.getId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setDraftCount(p.getDraftCount() + 1);
        }
    }
}
#method_after
private void loadDrafts(Map<Patch.Key, Patch> byKey, Account.Id me, String file) throws OrmException {
    for (Comment c : commentsUtil.draftByChangeFileAuthor(db, notes, file, me)) {
        comments.include(notes.getChangeId(), c);
        PatchSet.Id psId = new PatchSet.Id(notes.getChangeId(), c.key.patchSetId);
        Patch.Key pKey = new Patch.Key(psId, c.key.filename);
        Patch p = byKey.get(pKey);
        if (p != null) {
            p.setDraftCount(p.getDraftCount() + 1);
        }
    }
}
#end_block

#method_before
public static String toChangeInEditMode(Change.Id c) {
    return "/c/" + c + ",edit/";
}
#method_after
public static String toChangeInEditMode(@Nullable Project.NameKey project, Change.Id c) {
    return toChangeNoSlash(project, c) + ",edit/";
}
#end_block

#method_before
public static String toChange(final PatchSet.Id ps) {
    return "/c/" + ps.getParentKey() + "/" + ps.getId();
}
#method_after
public static String toChange(@Nullable Project.NameKey project, Change.Id c) {
    return toChangeNoSlash(project, c) + "/";
}
#end_block

#method_before
public static String toProject(final Project.NameKey p) {
    return ADMIN_PROJECTS + p.get();
}
#method_after
public static String toProject(Project.NameKey p) {
    return ADMIN_PROJECTS + p.get();
}
#end_block

#method_before
public static String toProjectAcceess(final Project.NameKey p) {
    return "/admin/projects/" + p.get() + ",access";
}
#method_after
public static String toProjectAcceess(Project.NameKey p) {
    return "/admin/projects/" + p.get() + ",access";
}
#end_block

#method_before
public static String toCustomDashboard(final String params) {
    return "/dashboard/?" + params;
}
#method_after
public static String toCustomDashboard(String params) {
    return "/dashboard/?" + params;
}
#end_block

#method_before
public static GerritCallback<JavaScriptObject> cs(final Change.Id id, final Button... draftButtons) {
    setEnabled(false, draftButtons);
    return new GerritCallback<JavaScriptObject>() {

        @Override
        public void onSuccess(JavaScriptObject result) {
            Gerrit.display(PageLinks.toChange(id));
        }

        @Override
        public void onFailure(Throwable err) {
            setEnabled(true, draftButtons);
            if (SubmitFailureDialog.isConflict(err)) {
                new SubmitFailureDialog(err.getMessage()).center();
                Gerrit.display(PageLinks.toChange(id));
            } else {
                super.onFailure(err);
            }
        }
    };
}
#method_after
public static GerritCallback<JavaScriptObject> cs(Project.NameKey project, final Change.Id id, Button... draftButtons) {
    setEnabled(false, draftButtons);
    return new GerritCallback<JavaScriptObject>() {

        @Override
        public void onSuccess(JavaScriptObject result) {
            Gerrit.display(PageLinks.toChange(project, id));
        }

        @Override
        public void onFailure(Throwable err) {
            setEnabled(true, draftButtons);
            if (SubmitFailureDialog.isConflict(err)) {
                new SubmitFailureDialog(err.getMessage()).center();
                Gerrit.display(PageLinks.toChange(project, id));
            } else {
                super.onFailure(err);
            }
        }
    };
}
#end_block

#method_before
private RevCommit createMergeCommit(MergePatchSetInput in, ProjectControl projectControl, Branch.NameKey dest, Repository git, ObjectInserter oi, RevWalk rw, RevCommit currentPsCommit, RevCommit sourceCommit, PersonIdent author, ObjectId changeId) throws ResourceNotFoundException, MergeIdenticalTreeException, MergeConflictException, IOException {
    ObjectId parentCommit;
    if (in.inheritParent) {
        // inherit first parent from previous patch set
        parentCommit = currentPsCommit.getParent(0);
    } else {
        // get the current branch tip of destination branch
        Ref destRef = git.getRefDatabase().exactRef(dest.get());
        if (destRef != null) {
            parentCommit = destRef.getObjectId();
        } else {
            throw new ResourceNotFoundException("cannot find destination branch");
        }
    }
    RevCommit mergeTip = rw.parseCommit(parentCommit);
    String commitMsg;
    if (Strings.emptyToNull(in.subject) != null) {
        commitMsg = ChangeIdUtil.insertId(in.subject, changeId);
    } else {
        // reuse previous patch set commit message
        commitMsg = currentPsCommit.getFullMessage();
    }
    String mergeStrategy = MoreObjects.firstNonNull(Strings.emptyToNull(in.merge.strategy), mergeUtilFactory.create(projectControl.getProjectState()).mergeStrategyName());
    return MergeUtil.createMergeCommit(git, oi, mergeTip, sourceCommit, mergeStrategy, author, commitMsg, rw);
}
#method_after
private RevCommit createMergeCommit(MergePatchSetInput in, ProjectState projectState, Branch.NameKey dest, Repository git, ObjectInserter oi, RevWalk rw, RevCommit currentPsCommit, RevCommit sourceCommit, PersonIdent author, ObjectId changeId) throws ResourceNotFoundException, MergeIdenticalTreeException, MergeConflictException, IOException {
    ObjectId parentCommit;
    if (in.inheritParent) {
        // inherit first parent from previous patch set
        parentCommit = currentPsCommit.getParent(0);
    } else {
        // get the current branch tip of destination branch
        Ref destRef = git.getRefDatabase().exactRef(dest.get());
        if (destRef != null) {
            parentCommit = destRef.getObjectId();
        } else {
            throw new ResourceNotFoundException("cannot find destination branch");
        }
    }
    RevCommit mergeTip = rw.parseCommit(parentCommit);
    String commitMsg;
    if (Strings.emptyToNull(in.subject) != null) {
        commitMsg = ChangeIdUtil.insertId(in.subject, changeId);
    } else {
        // reuse previous patch set commit message
        commitMsg = currentPsCommit.getFullMessage();
    }
    String mergeStrategy = MoreObjects.firstNonNull(Strings.emptyToNull(in.merge.strategy), mergeUtilFactory.create(projectState).mergeStrategyName());
    return MergeUtil.createMergeCommit(oi, git.getConfig(), mergeTip, sourceCommit, mergeStrategy, author, commitMsg, rw);
}
#end_block

#method_before
@Override
public final void updateRepo(RepoContext ctx) throws Exception {
    logDebug("{}#updateRepo for change {}", getClass().getSimpleName(), toMerge.change().getId());
    // Run the submit strategy implementation and record the merge tip state so
    // we can create the ref update.
    CodeReviewCommit tipBefore = args.mergeTip.getCurrentTip();
    alreadyMerged = getAlreadyMergedCommit(ctx);
    if (alreadyMerged == null) {
        updateRepoImpl(ctx);
    } else {
        logDebug("Already merged as {}", alreadyMerged.name());
    }
    CodeReviewCommit tipAfter = args.mergeTip.getCurrentTip();
    if (Objects.equals(tipBefore, tipAfter)) {
        logDebug("Did not move tip", getClass().getSimpleName());
        return;
    } else if (tipAfter == null) {
        logDebug("No merge tip, no update to perform");
        return;
    }
    logDebug("Moved tip from {} to {}", tipBefore, tipAfter);
    checkProjectConfig(ctx, tipAfter);
    // Needed by postUpdate, at which point mergeTip will have advanced further,
    // so it's easier to just snapshot the command.
    command = new ReceiveCommand(firstNonNull(tipBefore, ObjectId.zeroId()), tipAfter, getDest().get());
    ctx.addRefUpdate(command);
    args.submoduleOp.addBranchTip(getDest(), tipAfter);
}
#method_after
@Override
public final void updateRepo(RepoContext ctx) throws Exception {
    logDebug("{}#updateRepo for change {}", getClass().getSimpleName(), toMerge.change().getId());
    checkState(ctx.getRevWalk() == args.rw, "SubmitStrategyOp requires callers to call BatchUpdate#setRepository with exactly the same" + " CodeReviewRevWalk instance from the SubmitStrategy.Arguments: %s != %s", ctx.getRevWalk(), args.rw);
    // Run the submit strategy implementation and record the merge tip state so
    // we can create the ref update.
    CodeReviewCommit tipBefore = args.mergeTip.getCurrentTip();
    alreadyMergedCommit = getAlreadyMergedCommit(ctx);
    if (alreadyMergedCommit == null) {
        updateRepoImpl(ctx);
    } else {
        logDebug("Already merged as {}", alreadyMergedCommit.name());
    }
    CodeReviewCommit tipAfter = args.mergeTip.getCurrentTip();
    if (Objects.equals(tipBefore, tipAfter)) {
        logDebug("Did not move tip", getClass().getSimpleName());
        return;
    } else if (tipAfter == null) {
        logDebug("No merge tip, no update to perform");
        return;
    }
    logDebug("Moved tip from {} to {}", tipBefore, tipAfter);
    checkProjectConfig(ctx, tipAfter);
    // Needed by postUpdate, at which point mergeTip will have advanced further,
    // so it's easier to just snapshot the command.
    command = new ReceiveCommand(firstNonNull(tipBefore, ObjectId.zeroId()), tipAfter, getDest().get());
    ctx.addRefUpdate(command);
    args.submoduleOp.addBranchTip(getDest(), tipAfter);
}
#end_block

#method_before
private CodeReviewCommit getAlreadyMergedCommit(RepoContext ctx) throws IOException {
    CodeReviewCommit tip = args.mergeTip.getInitialTip();
    if (tip == null) {
        return null;
    }
    CodeReviewRevWalk rw = (CodeReviewRevWalk) ctx.getRevWalk();
    Change.Id id = getId();
    Collection<Ref> refs = ctx.getRepository().getRefDatabase().getRefs(id.toRefPrefix()).values();
    List<CodeReviewCommit> commits = new ArrayList<>(refs.size());
    for (Ref ref : refs) {
        PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
        if (psId == null) {
            continue;
        }
        try {
            CodeReviewCommit c = rw.parseCommit(ref.getObjectId());
            c.setPatchsetId(psId);
            commits.add(c);
        } catch (MissingObjectException | IncorrectObjectTypeException e) {
            // Bogus ref, can't be merged into tip so we don't care.
            continue;
        }
    }
    Collections.sort(commits, ReviewDbUtil.intKeyOrdering().reverse().onResultOf(c -> c.getPatchsetId()));
    CodeReviewCommit result = MergeUtil.findAnyMergedInto(rw, commits, tip);
    if (result == null) {
        return null;
    }
    // Some patch set of this change is actually merged into the target
    // branch, most likely because a previous run of MergeOp failed after
    // updateRepo, during updateChange.
    // 
    // Do the best we can to clean this up: mark the change as merged and set
    // the current patch set. Don't touch the dest branch at all. This can
    // lead to some odd situations like another change in the set merging in
    // a different patch set of this change, but that's unavoidable at this
    // point.  At least the change will end up in the right state.
    // 
    // TODO(dborowitz): Consider deleting later junk patch set refs. They
    // presumably don't have PatchSets pointing to them.
    rw.parseBody(result);
    result.add(args.canMergeFlag);
    PatchSet.Id psId = result.getPatchsetId();
    result.copyFrom(toMerge);
    // Got overwriten by copyFrom.
    result.setPatchsetId(psId);
    result.setStatusCode(CommitMergeStatus.ALREADY_MERGED);
    args.commitStatus.put(result);
    return result;
}
#method_after
private CodeReviewCommit getAlreadyMergedCommit(RepoContext ctx) throws IOException {
    CodeReviewCommit tip = args.mergeTip.getInitialTip();
    if (tip == null) {
        return null;
    }
    CodeReviewRevWalk rw = (CodeReviewRevWalk) ctx.getRevWalk();
    Change.Id id = getId();
    String refPrefix = id.toRefPrefix();
    Map<String, ObjectId> refs = ctx.getRepoView().getRefs(refPrefix);
    List<CodeReviewCommit> commits = new ArrayList<>(refs.size());
    for (Map.Entry<String, ObjectId> e : refs.entrySet()) {
        PatchSet.Id psId = PatchSet.Id.fromRef(refPrefix + e.getKey());
        if (psId == null) {
            continue;
        }
        try {
            CodeReviewCommit c = rw.parseCommit(e.getValue());
            c.setPatchsetId(psId);
            commits.add(c);
        } catch (MissingObjectException | IncorrectObjectTypeException ex) {
            // Bogus ref, can't be merged into tip so we don't care.
            continue;
        }
    }
    Collections.sort(commits, ReviewDbUtil.intKeyOrdering().reverse().onResultOf(c -> c.getPatchsetId()));
    CodeReviewCommit result = MergeUtil.findAnyMergedInto(rw, commits, tip);
    if (result == null) {
        return null;
    }
    // Some patch set of this change is actually merged into the target
    // branch, most likely because a previous run of MergeOp failed after
    // updateRepo, during updateChange.
    // 
    // Do the best we can to clean this up: mark the change as merged and set
    // the current patch set. Don't touch the dest branch at all. This can
    // lead to some odd situations like another change in the set merging in
    // a different patch set of this change, but that's unavoidable at this
    // point.  At least the change will end up in the right state.
    // 
    // TODO(dborowitz): Consider deleting later junk patch set refs. They
    // presumably don't have PatchSets pointing to them.
    rw.parseBody(result);
    result.add(args.canMergeFlag);
    PatchSet.Id psId = result.getPatchsetId();
    result.copyFrom(toMerge);
    // Got overwriten by copyFrom.
    result.setPatchsetId(psId);
    result.setStatusCode(CommitMergeStatus.ALREADY_MERGED);
    args.commitStatus.put(result);
    return result;
}
#end_block

#method_before
@Override
public final boolean updateChange(ChangeContext ctx) throws Exception {
    logDebug("{}#updateChange for change {}", getClass().getSimpleName(), toMerge.change().getId());
    // Update change and notes from ctx.
    toMerge.setControl(ctx.getControl());
    PatchSet.Id oldPsId = checkNotNull(toMerge.getPatchsetId());
    PatchSet.Id newPsId;
    if (alreadyMerged != null) {
        alreadyMerged.setControl(ctx.getControl());
        mergedPatchSet = getOrCreateAlreadyMergedPatchSet(ctx);
        newPsId = mergedPatchSet.getId();
    } else {
        PatchSet newPatchSet = updateChangeImpl(ctx);
        newPsId = checkNotNull(ctx.getChange().currentPatchSetId());
        if (newPatchSet == null) {
            checkState(oldPsId.equals(newPsId), "patch set advanced from %s to %s but updateChangeImpl did not" + " return new patch set instance", oldPsId, newPsId);
            // Ok to use stale notes to get the old patch set, which didn't change
            // during the submit strategy.
            mergedPatchSet = checkNotNull(args.psUtil.get(ctx.getDb(), ctx.getNotes(), oldPsId), "missing old patch set %s", oldPsId);
        } else {
            PatchSet.Id n = newPatchSet.getId();
            checkState(!n.equals(oldPsId) && n.equals(newPsId), "current patch was %s and is now %s, but updateChangeImpl returned" + " new patch set instance at %s", oldPsId, newPsId, n);
            mergedPatchSet = newPatchSet;
        }
    }
    Change c = ctx.getChange();
    Change.Id id = c.getId();
    CodeReviewCommit commit = args.commitStatus.get(id);
    checkNotNull(commit, "missing commit for change " + id);
    CommitMergeStatus s = commit.getStatusCode();
    checkNotNull(s, "status not set for change " + id + " expected to previously fail fast");
    logDebug("Status of change {} ({}) on {}: {}", id, commit.name(), c.getDest(), s);
    setApproval(ctx, args.caller);
    mergeResultRev = alreadyMerged == null ? args.mergeTip.getMergeResults().get(commit) : // ChangeMergedEvent in the fixup case, but we'll just live with that.
    alreadyMerged;
    try {
        setMerged(ctx, message(ctx, commit, s));
    } catch (OrmException err) {
        String msg = "Error updating change status for " + id;
        log.error(msg, err);
        args.commitStatus.logProblem(id, msg);
    // It's possible this happened before updating anything in the db, but
    // it's hard to know for sure, so just return true below to be safe.
    }
    updatedChange = c;
    return true;
}
#method_after
@Override
public final boolean updateChange(ChangeContext ctx) throws Exception {
    logDebug("{}#updateChange for change {}", getClass().getSimpleName(), toMerge.change().getId());
    // Update change and notes from ctx.
    toMerge.setNotes(ctx.getNotes());
    PatchSet.Id oldPsId = checkNotNull(toMerge.getPatchsetId());
    PatchSet.Id newPsId;
    if (ctx.getChange().getStatus() == Change.Status.MERGED) {
        // repo failed with lock failure.
        if (alreadyMergedCommit == null) {
            logDebug("Change is already merged according to its status, but we were unable to find it" + " merged into the current tip ({})", args.mergeTip.getCurrentTip().name());
        } else {
            logDebug("Change is already merged");
        }
        changeAlreadyMerged = true;
        return false;
    }
    if (alreadyMergedCommit != null) {
        alreadyMergedCommit.setNotes(ctx.getNotes());
        mergedPatchSet = getOrCreateAlreadyMergedPatchSet(ctx);
        newPsId = mergedPatchSet.getId();
    } else {
        PatchSet newPatchSet = updateChangeImpl(ctx);
        newPsId = checkNotNull(ctx.getChange().currentPatchSetId());
        if (newPatchSet == null) {
            checkState(oldPsId.equals(newPsId), "patch set advanced from %s to %s but updateChangeImpl did not" + " return new patch set instance", oldPsId, newPsId);
            // Ok to use stale notes to get the old patch set, which didn't change
            // during the submit strategy.
            mergedPatchSet = checkNotNull(args.psUtil.get(ctx.getDb(), ctx.getNotes(), oldPsId), "missing old patch set %s", oldPsId);
        } else {
            PatchSet.Id n = newPatchSet.getId();
            checkState(!n.equals(oldPsId) && n.equals(newPsId), "current patch was %s and is now %s, but updateChangeImpl returned" + " new patch set instance at %s", oldPsId, newPsId, n);
            mergedPatchSet = newPatchSet;
        }
    }
    Change c = ctx.getChange();
    Change.Id id = c.getId();
    CodeReviewCommit commit = args.commitStatus.get(id);
    checkNotNull(commit, "missing commit for change " + id);
    CommitMergeStatus s = commit.getStatusCode();
    checkNotNull(s, "status not set for change " + id + " expected to previously fail fast");
    logDebug("Status of change {} ({}) on {}: {}", id, commit.name(), c.getDest(), s);
    setApproval(ctx, args.caller);
    mergeResultRev = alreadyMergedCommit == null ? args.mergeTip.getMergeResults().get(commit) : // ChangeMergedEvent in the fixup case, but we'll just live with that.
    alreadyMergedCommit;
    try {
        setMerged(ctx, message(ctx, commit, s));
    } catch (OrmException err) {
        String msg = "Error updating change status for " + id;
        log.error(msg, err);
        args.commitStatus.logProblem(id, msg);
    // It's possible this happened before updating anything in the db, but
    // it's hard to know for sure, so just return true below to be safe.
    }
    updatedChange = c;
    return true;
}
#end_block

#method_before
private PatchSet getOrCreateAlreadyMergedPatchSet(ChangeContext ctx) throws IOException, OrmException {
    PatchSet.Id psId = alreadyMerged.getPatchsetId();
    logDebug("Fixing up already-merged patch set {}", psId);
    PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
    ctx.getRevWalk().parseBody(alreadyMerged);
    ctx.getChange().setCurrentPatchSet(psId, alreadyMerged.getShortMessage(), ctx.getChange().getOriginalSubject());
    PatchSet existing = args.psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (existing != null) {
        logDebug("Patch set row exists, only updating change");
        return existing;
    }
    // No patch set for the already merged commit, although we know it came form
    // a patch set ref. Fix up the database. Note that this uses the current
    // user as the uploader, which is as good a guess as any.
    List<String> groups = prevPs != null ? prevPs.getGroups() : GroupCollector.getDefaultGroups(alreadyMerged);
    return args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, alreadyMerged, groups, null, null);
}
#method_after
private PatchSet getOrCreateAlreadyMergedPatchSet(ChangeContext ctx) throws IOException, OrmException {
    PatchSet.Id psId = alreadyMergedCommit.getPatchsetId();
    logDebug("Fixing up already-merged patch set {}", psId);
    PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
    ctx.getRevWalk().parseBody(alreadyMergedCommit);
    ctx.getChange().setCurrentPatchSet(psId, alreadyMergedCommit.getShortMessage(), ctx.getChange().getOriginalSubject());
    PatchSet existing = args.psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (existing != null) {
        logDebug("Patch set row exists, only updating change");
        return existing;
    }
    // No patch set for the already merged commit, although we know it came form
    // a patch set ref. Fix up the database. Note that this uses the current
    // user as the uploader, which is as good a guess as any.
    List<String> groups = prevPs != null ? prevPs.getGroups() : GroupCollector.getDefaultGroups(alreadyMergedCommit);
    return args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, alreadyMergedCommit, groups, null, null);
}
#end_block

#method_before
private void setApproval(ChangeContext ctx, IdentifiedUser user) throws OrmException {
    Change.Id id = ctx.getChange().getId();
    List<SubmitRecord> records = args.commitStatus.getSubmitRecords(id);
    PatchSet.Id oldPsId = toMerge.getPatchsetId();
    PatchSet.Id newPsId = ctx.getChange().currentPatchSetId();
    logDebug("Add approval for " + id);
    ChangeUpdate origPsUpdate = ctx.getUpdate(oldPsId);
    origPsUpdate.putReviewer(user.getAccountId(), REVIEWER);
    LabelNormalizer.Result normalized = approve(ctx, origPsUpdate);
    ChangeUpdate newPsUpdate = ctx.getUpdate(newPsId);
    newPsUpdate.merge(args.submissionId, records);
    // approvals as well.
    if (!newPsId.equals(oldPsId)) {
        saveApprovals(normalized, ctx, newPsUpdate, true);
        submitter = convertPatchSet(newPsId).apply(submitter);
    }
}
#method_after
private void setApproval(ChangeContext ctx, IdentifiedUser user) throws OrmException, IOException, PermissionBackendException {
    Change.Id id = ctx.getChange().getId();
    List<SubmitRecord> records = args.commitStatus.getSubmitRecords(id);
    PatchSet.Id oldPsId = toMerge.getPatchsetId();
    PatchSet.Id newPsId = ctx.getChange().currentPatchSetId();
    logDebug("Add approval for " + id);
    ChangeUpdate origPsUpdate = ctx.getUpdate(oldPsId);
    origPsUpdate.putReviewer(user.getAccountId(), REVIEWER);
    LabelNormalizer.Result normalized = approve(ctx, origPsUpdate);
    ChangeUpdate newPsUpdate = ctx.getUpdate(newPsId);
    newPsUpdate.merge(args.submissionId, records);
    // approvals as well.
    if (!newPsId.equals(oldPsId)) {
        saveApprovals(normalized, ctx, newPsUpdate, true);
        submitter = convertPatchSet(newPsId).apply(submitter);
    }
}
#end_block

#method_before
private LabelNormalizer.Result approve(ChangeContext ctx, ChangeUpdate update) throws OrmException {
    PatchSet.Id psId = update.getPatchSetId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = new HashMap<>();
    for (PatchSetApproval psa : args.approvalsUtil.byPatchSet(ctx.getDb(), ctx.getControl(), psId)) {
        byKey.put(psa.getKey(), psa);
    }
    submitter = ApprovalsUtil.newApproval(psId, ctx.getUser(), LabelId.legacySubmit(), 1, ctx.getWhen());
    byKey.put(submitter.getKey(), submitter);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = args.labelNormalizer.normalize(ctx.getControl(), byKey.values());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    saveApprovals(normalized, ctx, update, false);
    return normalized;
}
#method_after
private LabelNormalizer.Result approve(ChangeContext ctx, ChangeUpdate update) throws OrmException, IOException, PermissionBackendException {
    PatchSet.Id psId = update.getPatchSetId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = new HashMap<>();
    for (PatchSetApproval psa : args.approvalsUtil.byPatchSet(ctx.getDb(), ctx.getNotes(), ctx.getUser(), psId, ctx.getRevWalk(), ctx.getRepoView().getConfig())) {
        byKey.put(psa.getKey(), psa);
    }
    submitter = ApprovalsUtil.newApproval(psId, ctx.getUser(), LabelId.legacySubmit(), 1, ctx.getWhen());
    byKey.put(submitter.getKey(), submitter);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = args.labelNormalizer.normalize(ctx.getNotes(), ctx.getUser(), byKey.values());
    update.putApproval(submitter.getLabel(), submitter.getValue());
    saveApprovals(normalized, ctx, update, false);
    return normalized;
}
#end_block

#method_before
@Override
public final void postUpdate(Context ctx) throws Exception {
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            try (Repository git = args.repoManager.openRepository(getProject())) {
                git.setGitwebDescription(p.getProject().getDescription());
            } catch (IOException e) {
                log.error("cannot update description of " + p.getProject().getName(), e);
            }
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.notifyHandling, args.accountsToNotify).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null && !args.dryrun) {
        args.changeMerged.fire(updatedChange, mergedPatchSet, args.accountCache.get(submitter.getAccountId()).getAccount(), args.mergeTip.getCurrentTip().name(), ctx.getWhen());
    }
}
#method_after
@Override
public final void postUpdate(Context ctx) throws Exception {
    if (changeAlreadyMerged) {
        // TODO(dborowitz): This is suboptimal behavior in the presence of retries: postUpdate steps
        // will never get run for changes that submitted successfully on any but the final attempt.
        // This is primarily a temporary workaround for the fact that the submitter field is not
        // populated in the changeAlreadyMerged case.
        // 
        // If we naively execute postUpdate even if the change is already merged when updateChange
        // being, then we are subject to a race where postUpdate steps are run twice if two submit
        // processes run at the same time.
        logDebug("Skipping post-update steps for change {}", getId());
        return;
    }
    postUpdateImpl(ctx);
    if (command != null) {
        args.tagCache.updateFastForward(getProject(), command.getRefName(), command.getOldId(), command.getNewId());
        // per project even if multiple changes to refs/meta/config are submitted.
        if (RefNames.REFS_CONFIG.equals(getDest().get())) {
            args.projectCache.evict(getProject());
            ProjectState p = args.projectCache.get(getProject());
            try (Repository git = args.repoManager.openRepository(getProject())) {
                git.setGitwebDescription(p.getProject().getDescription());
            } catch (IOException e) {
                log.error("cannot update description of " + p.getName(), e);
            }
        }
    }
    // have failed fast in one of the other steps.
    try {
        args.mergedSenderFactory.create(ctx.getProject(), getId(), submitter.getAccountId(), args.submitInput.notify, args.accountsToNotify).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + getId(), e);
    }
    if (mergeResultRev != null && !args.dryrun) {
        args.changeMerged.fire(updatedChange, mergedPatchSet, args.accountCache.get(submitter.getAccountId()).getAccount(), args.mergeTip.getCurrentTip().name(), ctx.getWhen());
    }
}
#end_block

#method_before
@Override
public void review(ReviewInput in) throws RestApiException {
    try {
        review.apply(revision, in);
    } catch (OrmException | UpdateException | IOException e) {
        throw new RestApiException("Cannot post review", e);
    }
}
#method_after
@Override
public ReviewResult review(ReviewInput in) throws RestApiException {
    try {
        return review.apply(revision, in).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot post review", e);
    }
}
#end_block

#method_before
@Override
public void submit(SubmitInput in) throws RestApiException {
    try {
        submit.apply(revision, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot submit change", e);
    }
}
#method_after
@Override
public void submit(SubmitInput in) throws RestApiException {
    try {
        submit.apply(revision, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot submit change", e);
    }
}
#end_block

#method_before
@Override
public BinaryResult submitPreview(String format) throws RestApiException {
    submitPreview.setFormat(format);
    return submitPreview.apply(revision);
}
#method_after
@Override
public BinaryResult submitPreview(String format) throws RestApiException {
    try {
        submitPreview.setFormat(format);
        return submitPreview.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot get submit preview", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi rebase(RebaseInput in) throws RestApiException {
    try {
        return changes.id(rebase.apply(revision, in)._number);
    } catch (OrmException | EmailException | UpdateException | IOException e) {
        throw new RestApiException("Cannot rebase ps", e);
    }
}
#method_after
@Override
public ChangeApi rebase(RebaseInput in) throws RestApiException {
    try {
        return changes.id(rebase.apply(revision, in)._number);
    } catch (Exception e) {
        throw asRestApiException("Cannot rebase ps", e);
    }
}
#end_block

#method_before
@Override
public boolean canRebase() throws RestApiException {
    try (Repository repo = repoManager.openRepository(revision.getProject());
        RevWalk rw = new RevWalk(repo)) {
        return rebaseUtil.canRebase(revision.getPatchSet(), revision.getChange().getDest(), repo, rw);
    } catch (IOException e) {
        throw new RestApiException("Cannot check if rebase is possible", e);
    }
}
#method_after
@Override
public boolean canRebase() throws RestApiException {
    try (Repository repo = repoManager.openRepository(revision.getProject());
        RevWalk rw = new RevWalk(repo)) {
        return rebaseUtil.canRebase(revision.getPatchSet(), revision.getChange().getDest(), repo, rw);
    } catch (Exception e) {
        throw asRestApiException("Cannot check if rebase is possible", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi cherryPick(CherryPickInput in) throws RestApiException {
    try {
        return changes.id(cherryPick.apply(revision, in)._number);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot cherry pick", e);
    }
}
#method_after
@Override
public ChangeApi cherryPick(CherryPickInput in) throws RestApiException {
    try {
        return changes.id(cherryPick.apply(revision, in)._number);
    } catch (Exception e) {
        throw asRestApiException("Cannot cherry pick", e);
    }
}
#end_block

#method_before
@Override
public RevisionReviewerApi reviewer(String id) throws RestApiException {
    try {
        return revisionReviewerApi.create(revisionReviewers.parse(revision, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot parse reviewer", e);
    }
}
#method_after
@Override
public RevisionReviewerApi reviewer(String id) throws RestApiException {
    try {
        return revisionReviewerApi.create(revisionReviewers.parse(revision, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot parse reviewer", e);
    }
}
#end_block

#method_before
@Override
public void setReviewed(String path, boolean reviewed) throws RestApiException {
    try {
        RestModifyView<FileResource, Reviewed.Input> view;
        if (reviewed) {
            view = putReviewed;
        } else {
            view = deleteReviewed;
        }
        view.apply(files.parse(revision, IdString.fromDecoded(path)), new Reviewed.Input());
    } catch (Exception e) {
        throw new RestApiException("Cannot update reviewed flag", e);
    }
}
#method_after
@Override
public void setReviewed(String path, boolean reviewed) throws RestApiException {
    try {
        RestModifyView<FileResource, Reviewed.Input> view;
        if (reviewed) {
            view = putReviewed;
        } else {
            view = deleteReviewed;
        }
        view.apply(files.parse(revision, IdString.fromDecoded(path)), new Reviewed.Input());
    } catch (Exception e) {
        throw asRestApiException("Cannot update reviewed flag", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Set<String> reviewed() throws RestApiException {
    try {
        return ImmutableSet.copyOf((Iterable<String>) listFiles.setReviewed(true).apply(revision).value());
    } catch (OrmException | IOException | PatchListNotAvailableException e) {
        throw new RestApiException("Cannot list reviewed files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Set<String> reviewed() throws RestApiException {
    try {
        return ImmutableSet.copyOf((Iterable<String>) listFiles.setReviewed(true).apply(revision).value());
    } catch (Exception e) {
        throw asRestApiException("Cannot list reviewed files", e);
    }
}
#end_block

#method_before
@Override
public MergeableInfo mergeable() throws RestApiException {
    try {
        return mergeable.apply(revision);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot check mergeability", e);
    }
}
#method_after
@Override
public MergeableInfo mergeable() throws RestApiException {
    try {
        return mergeable.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot check mergeability", e);
    }
}
#end_block

#method_before
@Override
public MergeableInfo mergeableOtherBranches() throws RestApiException {
    try {
        mergeable.setOtherBranches(true);
        return mergeable.apply(revision);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot check mergeability", e);
    }
}
#method_after
@Override
public MergeableInfo mergeableOtherBranches() throws RestApiException {
    try {
        mergeable.setOtherBranches(true);
        return mergeable.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot check mergeability", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files() throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.apply(revision).value();
    } catch (OrmException | IOException | PatchListNotAvailableException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files() throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.apply(revision).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve files", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files(String base) throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.setBase(base).apply(revision).value();
    } catch (OrmException | IOException | PatchListNotAvailableException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files(String base) throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.setBase(base).apply(revision).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve files", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files(int parentNum) throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.setParent(parentNum).apply(revision).value();
    } catch (OrmException | IOException | PatchListNotAvailableException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files(int parentNum) throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.setParent(parentNum).apply(revision).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve files", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    try {
        return listComments.apply(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve comments", e);
    }
}
#method_after
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    try {
        return listComments.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve comments", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listRobotComments.apply(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve robot comments", e);
    }
}
#method_after
@Override
public Map<String, List<RobotCommentInfo>> robotComments() throws RestApiException {
    try {
        return listRobotComments.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve robot comments", e);
    }
}
#end_block

#method_before
@Override
public List<CommentInfo> commentsAsList() throws RestApiException {
    try {
        return listComments.getComments(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve comments", e);
    }
}
#method_after
@Override
public List<CommentInfo> commentsAsList() throws RestApiException {
    try {
        return listComments.getComments(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve comments", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    try {
        return listDrafts.apply(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve drafts", e);
    }
}
#method_after
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    try {
        return listDrafts.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve drafts", e);
    }
}
#end_block

#method_before
@Override
public List<RobotCommentInfo> robotCommentsAsList() throws RestApiException {
    try {
        return listRobotComments.getComments(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve robot comments", e);
    }
}
#method_after
@Override
public List<RobotCommentInfo> robotCommentsAsList() throws RestApiException {
    try {
        return listRobotComments.getComments(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve robot comments", e);
    }
}
#end_block

#method_before
@Override
public List<CommentInfo> draftsAsList() throws RestApiException {
    try {
        return listDrafts.getComments(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve drafts", e);
    }
}
#method_after
@Override
public List<CommentInfo> draftsAsList() throws RestApiException {
    try {
        return listDrafts.getComments(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve drafts", e);
    }
}
#end_block

#method_before
@Override
public DraftApi draft(String id) throws RestApiException {
    try {
        return draftFactory.create(drafts.parse(revision, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve draft", e);
    }
}
#method_after
@Override
public DraftApi draft(String id) throws RestApiException {
    try {
        return draftFactory.create(drafts.parse(revision, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve draft", e);
    }
}
#end_block

#method_before
@Override
public DraftApi createDraft(DraftInput in) throws RestApiException {
    try {
        String id = createDraft.apply(revision, in).value().id;
        // Reread change to pick up new notes refs.
        return changes.id(revision.getChange().getId().get()).revision(revision.getPatchSet().getId().get()).draft(id);
    } catch (UpdateException | OrmException e) {
        throw new RestApiException("Cannot create draft", e);
    }
}
#method_after
@Override
public DraftApi createDraft(DraftInput in) throws RestApiException {
    try {
        String id = createDraft.apply(revision, in).value().id;
        // Reread change to pick up new notes refs.
        return changes.id(revision.getChange().getId().get()).revision(revision.getPatchSet().getId().get()).draft(id);
    } catch (Exception e) {
        throw asRestApiException("Cannot create draft", e);
    }
}
#end_block

#method_before
@Override
public CommentApi comment(String id) throws RestApiException {
    try {
        return commentFactory.create(comments.parse(revision, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve comment", e);
    }
}
#method_after
@Override
public CommentApi comment(String id) throws RestApiException {
    try {
        return commentFactory.create(comments.parse(revision, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve comment", e);
    }
}
#end_block

#method_before
@Override
public RobotCommentApi robotComment(String id) throws RestApiException {
    try {
        return robotCommentFactory.create(robotComments.parse(revision, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve robot comment", e);
    }
}
#method_after
@Override
public RobotCommentApi robotComment(String id) throws RestApiException {
    try {
        return robotCommentFactory.create(robotComments.parse(revision, IdString.fromDecoded(id)));
    } catch (Exception e) {
        throw asRestApiException("Cannot retrieve robot comment", e);
    }
}
#end_block

#method_before
@Override
public BinaryResult patch() throws RestApiException {
    try {
        return getPatch.apply(revision);
    } catch (IOException e) {
        throw new RestApiException("Cannot get patch", e);
    }
}
#method_after
@Override
public BinaryResult patch() throws RestApiException {
    try {
        return getPatch.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot get patch", e);
    }
}
#end_block

#method_before
@Override
public BinaryResult patch(String path) throws RestApiException {
    try {
        return getPatch.setPath(path).apply(revision);
    } catch (IOException e) {
        throw new RestApiException("Cannot get patch", e);
    }
}
#method_after
@Override
public BinaryResult patch(String path) throws RestApiException {
    try {
        return getPatch.setPath(path).apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot get patch", e);
    }
}
#end_block

#method_before
@Override
public Map<String, ActionInfo> actions() throws RestApiException {
    try {
        return revisionActions.apply(revision).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get actions", e);
    }
}
#method_after
@Override
public Map<String, ActionInfo> actions() throws RestApiException {
    try {
        return revisionActions.apply(revision).value();
    } catch (Exception e) {
        throw asRestApiException("Cannot get actions", e);
    }
}
#end_block

#method_before
@Override
public SubmitType submitType() throws RestApiException {
    try {
        return getSubmitType.apply(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get submit type", e);
    }
}
#method_after
@Override
public SubmitType submitType() throws RestApiException {
    try {
        return getSubmitType.apply(revision);
    } catch (Exception e) {
        throw asRestApiException("Cannot get submit type", e);
    }
}
#end_block

#method_before
@Override
public SubmitType testSubmitType(TestSubmitRuleInput in) throws RestApiException {
    try {
        return testSubmitType.apply(revision, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot test submit type", e);
    }
}
#method_after
@Override
public SubmitType testSubmitType(TestSubmitRuleInput in) throws RestApiException {
    try {
        return testSubmitType.apply(revision, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot test submit type", e);
    }
}
#end_block

#method_before
@Override
public MergeListRequest getMergeList() throws RestApiException {
    return new MergeListRequest() {

        @Override
        public List<CommitInfo> get() throws RestApiException {
            try {
                GetMergeList gml = getMergeList.get();
                gml.setUninterestingParent(getUninterestingParent());
                gml.setAddLinks(getAddLinks());
                return gml.apply(revision).value();
            } catch (IOException e) {
                throw new RestApiException("Cannot get merge list", e);
            }
        }
    };
}
#method_after
@Override
public MergeListRequest getMergeList() throws RestApiException {
    return new MergeListRequest() {

        @Override
        public List<CommitInfo> get() throws RestApiException {
            try {
                GetMergeList gml = getMergeList.get();
                gml.setUninterestingParent(getUninterestingParent());
                gml.setAddLinks(getAddLinks());
                return gml.apply(revision).value();
            } catch (Exception e) {
                throw asRestApiException("Cannot get merge list", e);
            }
        }
    };
}
#end_block

#method_before
@Override
public void description(String description) throws RestApiException {
    PutDescription.Input in = new PutDescription.Input();
    in.description = description;
    try {
        putDescription.apply(revision, in);
    } catch (UpdateException e) {
        throw new RestApiException("Cannot set description", e);
    }
}
#method_after
@Override
public void description(String description) throws RestApiException {
    PutDescription.Input in = new PutDescription.Input();
    in.description = description;
    try {
        putDescription.apply(revision, in);
    } catch (Exception e) {
        throw asRestApiException("Cannot set description", e);
    }
}
#end_block

#method_before
public static Set<String> getFileParts(ChangeData cd) throws OrmException {
    List<String> paths = cd.currentFilePaths();
    if (paths == null) {
        return ImmutableSet.of();
    }
    Splitter s = Splitter.on('/').omitEmptyStrings();
    Set<String> r = new HashSet<>();
    for (String path : paths) {
        for (String part : s.split(path)) {
            r.add(part);
        }
    }
    return r;
}
#method_after
public static Set<String> getFileParts(ChangeData cd) throws OrmException {
    List<String> paths;
    try {
        paths = cd.currentFilePaths();
    } catch (IOException e) {
        throw new OrmException(e);
    }
    Splitter s = Splitter.on('/').omitEmptyStrings();
    Set<String> r = new HashSet<>();
    for (String path : paths) {
        for (String part : s.split(path)) {
            r.add(part);
        }
    }
    return r;
}
#end_block

#method_before
private static Iterable<String> getLabels(ChangeData input, boolean owners) throws OrmException {
    Set<String> allApprovals = new HashSet<>();
    Set<String> distinctApprovals = new HashSet<>();
    for (PatchSetApproval a : input.currentApprovals()) {
        if (a.getValue() != 0 && !a.isLegacySubmit()) {
            allApprovals.add(formatLabel(a.getLabel(), a.getValue(), a.getAccountId()));
            if (owners && input.change().getOwner().equals(a.getAccountId())) {
                allApprovals.add(formatLabel(a.getLabel(), a.getValue(), ChangeQueryBuilder.OWNER_ACCOUNT_ID));
            }
            distinctApprovals.add(formatLabel(a.getLabel(), a.getValue()));
        }
    }
    allApprovals.addAll(distinctApprovals);
    return allApprovals;
}
#method_after
private static Iterable<String> getLabels(ChangeData cd, boolean owners) throws OrmException {
    Set<String> allApprovals = new HashSet<>();
    Set<String> distinctApprovals = new HashSet<>();
    for (PatchSetApproval a : cd.currentApprovals()) {
        if (a.getValue() != 0 && !a.isLegacySubmit()) {
            allApprovals.add(formatLabel(a.getLabel(), a.getValue(), a.getAccountId()));
            if (owners && cd.change().getOwner().equals(a.getAccountId())) {
                allApprovals.add(formatLabel(a.getLabel(), a.getValue(), ChangeQueryBuilder.OWNER_ACCOUNT_ID));
            }
            distinctApprovals.add(formatLabel(a.getLabel(), a.getValue()));
        }
    }
    allApprovals.addAll(distinctApprovals);
    return allApprovals;
}
#end_block

#method_before
public static Set<String> getAuthorParts(ChangeData cd) throws OrmException {
    try {
        return SchemaUtil.getPersonParts(cd.getAuthor());
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
public static Set<String> getAuthorParts(ChangeData cd) throws OrmException, IOException {
    return SchemaUtil.getPersonParts(cd.getAuthor());
}
#end_block

#method_before
public static Set<String> getCommitterParts(ChangeData cd) throws OrmException {
    try {
        return SchemaUtil.getPersonParts(cd.getCommitter());
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
public static Set<String> getCommitterParts(ChangeData cd) throws OrmException, IOException {
    return SchemaUtil.getPersonParts(cd.getCommitter());
}
#end_block

#method_before
private static String getTopic(ChangeData input) throws OrmException {
    Change c = input.change();
    if (c == null) {
        return null;
    }
    return firstNonNull(c.getTopic(), "");
}
#method_after
private static String getTopic(ChangeData cd) throws OrmException {
    Change c = cd.change();
    if (c == null) {
        return null;
    }
    return firstNonNull(c.getTopic(), "");
}
#end_block

#method_before
public List<SubmitRecord> evaluate() {
    initOptions();
    Change c = control.getChange();
    if (!opts.allowClosed() && c.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", control.getUser());
    } catch (RuleEvalException e) {
        return ruleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // whether or not that is actually possible given the permissions.
        return ruleError(String.format("Submit rule '%s' for change %s of %s has " + "no solution.", getSubmitRuleName(), cd.getId(), getProjectName()));
    }
    return resultsToSubmitRecord(getSubmitRule(), results);
}
#method_after
public List<SubmitRecord> evaluate() {
    initOptions();
    try {
        init();
    } catch (OrmException e) {
        return ruleError("Error looking up change " + cd.getId(), e);
    }
    if (!opts.allowClosed() && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", user);
    } catch (RuleEvalException e) {
        return ruleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // whether or not that is actually possible given the permissions.
        return ruleError(String.format("Submit rule '%s' for change %s of %s has no solution.", getSubmitRuleName(), cd.getId(), getProjectName()));
    }
    return resultsToSubmitRecord(getSubmitRule(), results);
}
#end_block

#method_before
private List<SubmitRecord> invalidResult(Term rule, Term record, String reason) {
    return ruleError(String.format("Submit rule %s for change %s of %s output " + "invalid result: %s%s", rule, cd.getId(), getProjectName(), record, (reason == null ? "" : ". Reason: " + reason)));
}
#method_after
private List<SubmitRecord> invalidResult(Term rule, Term record, String reason) {
    return ruleError(String.format("Submit rule %s for change %s of %s output invalid result: %s%s", rule, cd.getId(), getProjectName(), record, (reason == null ? "" : ". Reason: " + reason)));
}
#end_block

#method_before
public SubmitTypeRecord getSubmitType() {
    initOptions();
    try {
        initPatchSet();
    } catch (OrmException e) {
        return typeError("Error looking up patch set " + control.getChange().currentPatchSetId(), e);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results", // have a consistent view of the submit type.
        null);
    } catch (RuleEvalException e) {
        return typeError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " has no solution.");
    }
    Term typeTerm = results.get(0);
    if (!(typeTerm instanceof SymbolTerm)) {
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " did not return a symbol.");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return typeError("Submit type rule " + getSubmitRule() + " for change " + cd.getId() + " of " + getProjectName() + " output invalid result: " + typeName);
    }
}
#method_after
public SubmitTypeRecord getSubmitType() {
    initOptions();
    try {
        init();
    } catch (OrmException e) {
        return typeError("Error looking up change " + cd.getId(), e);
    }
    List<Term> results;
    try {
        results = evaluateImpl("locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results", // have a consistent view of the submit type.
        null);
    } catch (RuleEvalException e) {
        return typeError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " has no solution.");
    }
    Term typeTerm = results.get(0);
    if (!(typeTerm instanceof SymbolTerm)) {
        return typeError("Submit rule '" + getSubmitRuleName() + "' for change " + cd.getId() + " of " + getProjectName() + " did not return a symbol.");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return typeError("Submit type rule " + getSubmitRule() + " for change " + cd.getId() + " of " + getProjectName() + " output invalid result: " + typeName);
    }
}
#end_block

#method_before
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (opts.rule() == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new StringReader(opts.rule()));
        }
    } catch (CompileException err) {
        String msg;
        if (opts.rule() == null && control.getProjectControl().isOwner()) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else if (opts.rule() != null) {
            msg = err.getMessage();
        } else {
            msg = String.format("Cannot load rules.pl for %s", getProjectName());
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.CHANGE_CONTROL, control);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    return env;
}
#method_after
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    PrologEnvironment env;
    try {
        if (opts.rule() == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new StringReader(opts.rule()));
        }
    } catch (CompileException err) {
        String msg;
        if (opts.rule() == null) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else {
            msg = err.getMessage();
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.ACCOUNTS, accounts);
    env.set(StoredValues.ACCOUNT_CACHE, accountCache);
    env.set(StoredValues.EMAILS, emails);
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    env.set(StoredValues.PROJECT_STATE, projectState);
    return env;
}
#end_block

#method_before
private Term runSubmitFilters(Term results, PrologEnvironment env, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment childEnv = env;
    for (ProjectState parentState : projectState.parents()) {
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            throw new RuleEvalException("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", filterRuleLocatorName, new VariableTerm());
        try {
            if (opts.fastEvalLabels()) {
                env.once("gerrit", "assume_range_from_label");
            }
            Term[] template = parentEnv.once("gerrit", filterRuleWrapperName, filterRule, results, new VariableTerm());
            results = template[2];
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), parentState.getProject().getName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", filterRule, cd.getId().get(), parentState.getProject().getName()), err);
        } finally {
            reductionsConsumed += env.getReductions();
        }
        childEnv = parentEnv;
    }
    return results;
}
#method_after
private Term runSubmitFilters(Term results, PrologEnvironment env, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    PrologEnvironment childEnv = env;
    for (ProjectState parentState : projectState.parents()) {
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            throw new RuleEvalException("Cannot consult rules.pl for " + parentState.getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", filterRuleLocatorName, new VariableTerm());
        try {
            if (opts.fastEvalLabels()) {
                env.once("gerrit", "assume_range_from_label");
            }
            Term[] template = parentEnv.once("gerrit", filterRuleWrapperName, filterRule, results, new VariableTerm());
            results = template[2];
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), parentState.getName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", filterRule, cd.getId().get(), parentState.getName()), err);
        } finally {
            reductionsConsumed += env.getReductions();
        }
        childEnv = parentEnv;
    }
    return results;
}
#end_block

#method_before
private String getProjectName() {
    return control.getProjectControl().getProjectState().getProject().getName();
}
#method_after
private String getProjectName() {
    return projectState.getName();
}
#end_block

#method_before
public static String getDestBranchName(String refName) {
    String magicBranch = NEW_CHANGE;
    return refName.substring(magicBranch.length());
}
#method_after
public static String getDestBranchName(String refName) {
    String magicBranch = NEW_CHANGE;
    if (refName.startsWith(NEW_DRAFT_CHANGE)) {
        magicBranch = NEW_DRAFT_CHANGE;
    }
    return refName.substring(magicBranch.length());
}
#end_block

#method_before
public static boolean isMagicBranch(String refName) {
    return refName.startsWith(NEW_CHANGE);
}
#method_after
public static boolean isMagicBranch(String refName) {
    return refName.startsWith(NEW_DRAFT_CHANGE) || refName.startsWith(NEW_CHANGE);
}
#end_block

#method_before
public static String getMagicRefNamePrefix(String refName) {
    if (refName.startsWith(NEW_CHANGE)) {
        return NEW_CHANGE;
    }
    return null;
}
#method_after
public static String getMagicRefNamePrefix(String refName) {
    if (refName.startsWith(NEW_DRAFT_CHANGE)) {
        return NEW_DRAFT_CHANGE;
    }
    if (refName.startsWith(NEW_CHANGE)) {
        return NEW_CHANGE;
    }
    return null;
}
#end_block

#method_before
public static Capable checkMagicBranchRefs(Repository repo, Project project) {
    Capable result = checkMagicBranchRef(NEW_CHANGE, repo, project);
    if (result != Capable.OK) {
        return result;
    }
    return Capable.OK;
}
#method_after
public static Capable checkMagicBranchRefs(Repository repo, Project project) {
    Capable result = checkMagicBranchRef(NEW_CHANGE, repo, project);
    if (result != Capable.OK) {
        return result;
    }
    result = checkMagicBranchRef(NEW_DRAFT_CHANGE, repo, project);
    if (result != Capable.OK) {
        return result;
    }
    return Capable.OK;
}
#end_block

#method_before
public boolean isVisibleTo(Branch.NameKey branchName, IdentifiedUser user) {
    if (branchName == null) {
        return false;
    }
    final ProjectState pe = projectCache.get(branchName.getParentKey());
    if (pe == null) {
        return false;
    }
    final ProjectControl pc = pe.controlFor(user);
    return pc.controlForRef(branchName).isVisible();
}
#method_after
public boolean isVisibleTo(Branch.NameKey branchName, IdentifiedUser user) {
    if (branchName == null) {
        return false;
    }
    ProjectState pe = projectCache.get(branchName.getParentKey());
    if (pe == null) {
        return false;
    }
    return pe.controlFor(user).controlForRef(branchName).isVisible();
}
#end_block

#method_before
protected static Branch.NameKey getBranch(String project, String branch) {
    return new Branch.NameKey(new Project.NameKey(project), RefNames.fullName(branch));
}
#method_after
protected static Branch.NameKey getBranch(String project, String branch) {
    return new Branch.NameKey(new Project.NameKey(project), (branch.startsWith("refs/") ? "" : "refs/heads/") + branch);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(HookQueue.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(HookQueue.class);
    bind(HookExecutor.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(HookExecutor.class);
    DynamicSet.bind(binder(), AgreementSignupListener.class).to(AgreementSignup.class);
    DynamicSet.bind(binder(), ChangeAbandonedListener.class).to(ChangeAbandoned.class);
    DynamicSet.bind(binder(), ChangeMergedListener.class).to(ChangeMerged.class);
    DynamicSet.bind(binder(), ChangeRestoredListener.class).to(ChangeRestored.class);
    DynamicSet.bind(binder(), CommentAddedListener.class).to(CommentAdded.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(GitReferenceUpdated.class);
    DynamicSet.bind(binder(), HashtagsEditedListener.class).to(HashtagsEdited.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(NewProjectCreated.class);
    DynamicSet.bind(binder(), RefOperationValidationListener.class).to(RefUpdate.class);
    DynamicSet.bind(binder(), ReviewerAddedListener.class).to(ReviewerAdded.class);
    DynamicSet.bind(binder(), ReviewerDeletedListener.class).to(ReviewerDeleted.class);
    DynamicSet.bind(binder(), RevisionCreatedListener.class).to(RevisionCreated.class);
    DynamicSet.bind(binder(), TopicEditedListener.class).to(TopicEdited.class);
    DynamicSet.bind(binder(), CommitValidationListener.class).to(CommitReceived.class);
}
#method_after
@Override
protected void configure() {
    bind(HookQueue.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(HookQueue.class);
    bind(HookExecutor.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(HookExecutor.class);
    factory(HookArgs.Factory.class);
    DynamicSet.bind(binder(), AgreementSignupListener.class).to(AgreementSignup.class);
    DynamicSet.bind(binder(), ChangeAbandonedListener.class).to(ChangeAbandoned.class);
    DynamicSet.bind(binder(), ChangeMergedListener.class).to(ChangeMerged.class);
    DynamicSet.bind(binder(), ChangeRestoredListener.class).to(ChangeRestored.class);
    DynamicSet.bind(binder(), CommentAddedListener.class).to(CommentAdded.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(GitReferenceUpdated.class);
    DynamicSet.bind(binder(), HashtagsEditedListener.class).to(HashtagsEdited.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(NewProjectCreated.class);
    DynamicSet.bind(binder(), RefOperationValidationListener.class).to(RefUpdate.class);
    DynamicSet.bind(binder(), ReviewerAddedListener.class).to(ReviewerAdded.class);
    DynamicSet.bind(binder(), ReviewerDeletedListener.class).to(ReviewerDeleted.class);
    DynamicSet.bind(binder(), RevisionCreatedListener.class).to(RevisionCreated.class);
    DynamicSet.bind(binder(), TopicEditedListener.class).to(TopicEdited.class);
    DynamicSet.bind(binder(), CommitValidationListener.class).to(CommitReceived.class);
}
#end_block

#method_before
@Override
public void onCommentAdded(CommentAddedListener.Event event) {
    HookArgs args = hookFactory.createArgs();
    ChangeInfo c = event.getChange();
    args.add("--change", c.id);
    args.addUrl(c);
    args.add("--change-owner", c.owner);
    args.add("--project", c.project);
    args.add("--branch", c.branch);
    args.add("--topic", c.topic);
    args.add("--author", event.getWho());
    args.add("--commit", event.getRevision().commit.commit);
    args.add("--comment", event.getComment());
    args.addApprovals(event.getApprovals(), event.getOldApprovals());
    hook.submit(c.project, args);
}
#method_after
@Override
public void onCommentAdded(CommentAddedListener.Event event) {
    HookArgs args = hookFactory.createArgs();
    ChangeInfo c = event.getChange();
    args.add("--change", c.id);
    args.addUrl(c);
    args.add("--change-owner", c.owner);
    args.add("--project", c.project);
    args.add("--branch", c.branch);
    args.add("--topic", c.topic);
    args.add("--author", event.getWho());
    args.add("--commit", event.getRevision().commit.commit);
    args.add("--comment", event.getComment());
    args.addApprovals(event.getApprovals(), event.getOldApprovals());
    hook.execute(c.project, args);
}
#end_block

#method_before
@Override
public void onRevisionCreated(Event event) {
    HookArgs args = hookFactory.createArgs();
    ChangeInfo c = event.getChange();
    args.add("--change", c.id);
    args.add("--kind", String.valueOf(event.getRevision().kind));
    args.addUrl(c);
    args.add("--change-owner", c.owner);
    args.add("--project", c.project);
    args.add("--branch", c.branch);
    args.add("--topic", c.topic);
    args.add("--uploader", event.getWho());
    args.add("--commit", event.getRevision().commit.commit);
    args.add("--patchset", event.getRevision()._number);
    hook.submit(c.project, args);
}
#method_after
@Override
public void onRevisionCreated(Event event) {
    HookArgs args = hookFactory.createArgs();
    ChangeInfo c = event.getChange();
    args.add("--change", c.id);
    args.add("--kind", String.valueOf(event.getRevision().kind));
    args.addUrl(c);
    args.add("--change-owner", c.owner);
    args.add("--project", c.project);
    args.add("--branch", c.branch);
    args.add("--topic", c.topic);
    args.add("--uploader", event.getWho());
    args.add("--commit", event.getRevision().commit.commit);
    args.add("--patchset", event.getRevision()._number);
    hook.execute(c.project, args);
}
#end_block

#method_before
@Override
public void onChangeAbandoned(ChangeAbandonedListener.Event event) {
    ChangeInfo change = event.getChange();
    String revision = event.getRevision().commit.commit;
    log.debug("Detected revision {} abandoned on {}.", revision, change.project);
    try {
        abandonDownstream(change, revision);
    } catch (ConfigInvalidException e) {
        log.error("Automerger plugin failed onChangeAbandoned for {}", change.id, e);
    }
}
#method_after
@Override
public void onChangeAbandoned(ChangeAbandonedListener.Event event) {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        ChangeInfo change = event.getChange();
        String revision = event.getRevision().commit.commit;
        log.debug("Detected revision {} abandoned on {}.", revision, change.project);
        abandonDownstream(change, revision);
    } catch (ConfigInvalidException | OrmException e) {
        log.error("Automerger plugin failed onChangeAbandoned for {}", event.getChange().id, e);
    }
}
#end_block

#method_before
@Override
public void onTopicEdited(TopicEditedListener.Event event) {
    ChangeInfo eventChange = event.getChange();
    // We have to re-query for this in order to include the current revision
    ChangeInfo change;
    try {
        change = gApi.changes().id(eventChange._number).get(EnumSet.of(ListChangesOption.CURRENT_REVISION));
    } catch (RestApiException e) {
        log.error("Automerger could not get change with current revision for onTopicEdited: ", e);
        return;
    }
    String oldTopic = event.getOldTopic();
    String revision = change.currentRevision;
    Set<String> downstreamBranches;
    try {
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    } catch (RestApiException | IOException | ConfigInvalidException e) {
        log.error("Failed to edit downstream topics of {}", change.id, e);
        return;
    }
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    // If change is empty, prevent someone breaking topic.
    if (isNullOrEmpty(change.topic)) {
        try {
            gApi.changes().id(change._number).topic(oldTopic);
            ReviewInput reviewInput = new ReviewInput();
            reviewInput.message("Automerger prevented the topic from changing. Topic can only be modified on " + "non-automerger-created CLs to a non-empty value.");
            reviewInput.notify = NotifyHandling.NONE;
            gApi.changes().id(change._number).revision(change.currentRevision).review(reviewInput);
        } catch (RestApiException e) {
            log.error("Failed to prevent setting empty topic for automerger plugin.", e);
        }
    } else {
        for (String downstreamBranch : downstreamBranches) {
            try {
                List<Integer> existingDownstream = getExistingMergesOnBranch(revision, oldTopic, downstreamBranch);
                for (Integer changeNumber : existingDownstream) {
                    log.debug("Setting topic {} on {}", change.topic, changeNumber);
                    gApi.changes().id(changeNumber).topic(change.topic);
                }
            } catch (RestApiException | InvalidQueryParameterException e) {
                log.error("Failed to edit downstream topics of {}", change.id, e);
            }
        }
    }
}
#method_after
@Override
public void onTopicEdited(TopicEditedListener.Event event) {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        ChangeInfo eventChange = event.getChange();
        // We have to re-query for this in order to include the current revision
        ChangeInfo change;
        try {
            change = gApi.changes().id(eventChange._number).get(EnumSet.of(ListChangesOption.CURRENT_REVISION));
        } catch (RestApiException e) {
            log.error("Automerger could not get change with current revision for onTopicEdited: ", e);
            return;
        }
        String oldTopic = event.getOldTopic();
        String revision = change.currentRevision;
        Set<String> downstreamBranches;
        try {
            downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        } catch (RestApiException | IOException | ConfigInvalidException e) {
            log.error("Failed to edit downstream topics of {}", change.id, e);
            return;
        }
        if (downstreamBranches.isEmpty()) {
            log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        // If change is empty, prevent someone breaking topic.
        if (isNullOrEmpty(change.topic)) {
            try {
                gApi.changes().id(change._number).topic(oldTopic);
                ReviewInput reviewInput = new ReviewInput();
                reviewInput.message("Automerger prevented the topic from changing. Topic can only be modified on " + "non-automerger-created CLs to a non-empty value.");
                reviewInput.notify = NotifyHandling.NONE;
                gApi.changes().id(change._number).revision(CURRENT).review(reviewInput);
            } catch (RestApiException e) {
                log.error("Failed to prevent setting empty topic for automerger plugin.", e);
            }
        } else {
            for (String downstreamBranch : downstreamBranches) {
                try {
                    List<Integer> existingDownstream = getExistingMergesOnBranch(revision, oldTopic, downstreamBranch);
                    for (Integer changeNumber : existingDownstream) {
                        log.debug("Setting topic {} on {}", change.topic, changeNumber);
                        gApi.changes().id(changeNumber).topic(change.topic);
                    }
                } catch (RestApiException | InvalidQueryParameterException e) {
                    log.error("Failed to edit downstream topics of {}", change.id, e);
                }
            }
        }
    } catch (OrmException | ConfigInvalidException e) {
        log.error("Automerger plugin failed onTopicEdited for {}", event.getChange().id, e);
    }
}
#end_block

#method_before
@Override
public void onCommentAdded(CommentAddedListener.Event event) {
    RevisionInfo eventRevision = event.getRevision();
    if (!eventRevision.isCurrent) {
        log.info("Not updating downstream votes since revision {} is not current.", eventRevision._number);
        return;
    }
    ChangeInfo change = event.getChange();
    String revision = change.currentRevision;
    Set<String> downstreamBranches;
    try {
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    } catch (RestApiException | IOException | ConfigInvalidException e) {
        log.error("Failed to update downstream votes of {}", change.id, e);
        return;
    }
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    Map<String, ApprovalInfo> approvals = event.getApprovals();
    for (String downstreamBranch : downstreamBranches) {
        try {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            for (Integer changeNumber : existingDownstream) {
                ChangeInfo downstreamChange = gApi.changes().id(changeNumber).get(EnumSet.of(ListChangesOption.CURRENT_REVISION));
                for (Map.Entry<String, ApprovalInfo> label : approvals.entrySet()) {
                    updateVote(downstreamChange, label.getKey(), label.getValue().value.shortValue());
                }
            }
        } catch (RestApiException | InvalidQueryParameterException e) {
            log.error("Exception when updating downstream votes of {}", change.id, e);
        }
    }
}
#method_after
@Override
public void onCommentAdded(CommentAddedListener.Event event) {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        RevisionInfo eventRevision = event.getRevision();
        if (!eventRevision.isCurrent) {
            log.info("Not updating downstream votes since revision {} is not current.", eventRevision._number);
            return;
        }
        ChangeInfo change = event.getChange();
        String revision = change.currentRevision;
        Set<String> downstreamBranches;
        downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        if (downstreamBranches.isEmpty()) {
            log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        Map<String, LabelInfo> labels = gApi.changes().id(change._number).get(EnumSet.of(ListChangesOption.DETAILED_LABELS)).labels;
        for (String downstreamBranch : downstreamBranches) {
            try {
                List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
                for (Integer changeNumber : existingDownstream) {
                    ChangeInfo downstreamChange = gApi.changes().id(changeNumber).get(EnumSet.of(ListChangesOption.CURRENT_REVISION));
                    for (Map.Entry<String, LabelInfo> labelEntry : labels.entrySet()) {
                        if (labelEntry.getValue().all.size() > 0) {
                            OptionalInt maxVote = labelEntry.getValue().all.stream().filter(o -> o.value != null).mapToInt(i -> i.value).max();
                            if (maxVote.isPresent()) {
                                updateVote(downstreamChange, labelEntry.getKey(), (short) maxVote.getAsInt());
                            }
                        }
                    }
                }
            } catch (RestApiException | InvalidQueryParameterException e) {
                log.error("Exception when updating downstream votes of {}", change.id, e);
            }
        }
    } catch (OrmException | ConfigInvalidException | RestApiException | IOException e) {
        log.error("Automerger plugin failed onCommentAdded for {}", event.getChange().id, e);
    }
}
#end_block

#method_before
@Override
public void onChangeRestored(ChangeRestoredListener.Event event) {
    ChangeInfo change = event.getChange();
    try {
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException | ConfigInvalidException | InvalidQueryParameterException e) {
        log.error("Automerger plugin failed onChangeRestored for {}", change.id, e);
    }
}
#method_after
@Override
public void onChangeRestored(ChangeRestoredListener.Event event) {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        ChangeInfo change = event.getChange();
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException | ConfigInvalidException | InvalidQueryParameterException | OrmException e) {
        log.error("Automerger plugin failed onChangeRestored for {}", event.getChange().id, e);
    }
}
#end_block

#method_before
@Override
public void onRevisionCreated(RevisionCreatedListener.Event event) {
    ChangeInfo change = event.getChange();
    try {
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException | ConfigInvalidException | InvalidQueryParameterException e) {
        log.error("Automerger plugin failed onRevisionCreated for {}", change.id, e);
    }
}
#method_after
@Override
public void onRevisionCreated(RevisionCreatedListener.Event event) {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        ChangeInfo change = event.getChange();
        automergeChanges(change, event.getRevision());
    } catch (RestApiException | IOException | ConfigInvalidException | InvalidQueryParameterException | OrmException e) {
        log.error("Automerger plugin failed onRevisionCreated for {}", event.getChange().id, e);
    }
}
#end_block

#method_before
public void createMergesAndHandleConflicts(MultipleDownstreamMergeInput mdsMergeInput) throws RestApiException, ConfigInvalidException, InvalidQueryParameterException {
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<String, Short>();
    try {
        createDownstreamMerges(mdsMergeInput);
        reviewInput.message = "Automerging to " + Joiner.on(", ").join(mdsMergeInput.dsBranchMap.keySet()) + " succeeded!";
        reviewInput.notify = NotifyHandling.NONE;
    } catch (FailedMergeException e) {
        reviewInput.message = e.getDisplayString();
        reviewInput.notify = NotifyHandling.ALL;
        reviewInput.tag = MERGE_CONFLICT_TAG;
        // Vote minAutomergeVote if we hit a conflict.
        if (!config.minAutomergeVoteDisabled()) {
            labels.put(config.getAutomergeLabel(), config.getMinAutomergeVote());
        }
    }
    reviewInput.labels = labels;
    // if this fails, i.e. -2 is restricted, catch it and still post message without a vote.
    try {
        gApi.changes().id(mdsMergeInput.changeNumber).revision(mdsMergeInput.currentRevision).review(reviewInput);
    } catch (AuthException e) {
        reviewInput.labels = null;
        gApi.changes().id(mdsMergeInput.changeNumber).revision(mdsMergeInput.currentRevision).review(reviewInput);
    }
}
#method_after
public void createMergesAndHandleConflicts(MultipleDownstreamMergeInput mdsMergeInput) throws RestApiException, ConfigInvalidException, InvalidQueryParameterException, OrmException {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        ReviewInput reviewInput = new ReviewInput();
        Map<String, Short> labels = new HashMap<>();
        try {
            createDownstreamMerges(mdsMergeInput);
            reviewInput.message = "Automerging change " + mdsMergeInput.changeNumber + " to " + Joiner.on(", ").join(mdsMergeInput.dsBranchMap.keySet()) + " succeeded!";
            reviewInput.notify = NotifyHandling.NONE;
        } catch (FailedMergeException e) {
            reviewInput.message = e.getDisplayString();
            reviewInput.notify = NotifyHandling.ALL;
            reviewInput.tag = MERGE_CONFLICT_TAG;
            // Vote minAutomergeVote if we hit a conflict.
            if (!config.minAutomergeVoteDisabled()) {
                labels.put(config.getAutomergeLabel(), config.getMinAutomergeVote());
            }
        }
        reviewInput.labels = labels;
        // Make the vote on the original change
        ChangeInfo originalChange = getOriginalChange(mdsMergeInput.changeNumber, mdsMergeInput.currentRevision);
        // if this fails, i.e. -2 is restricted, catch it and still post message without a vote.
        try {
            gApi.changes().id(originalChange._number).revision(CURRENT).review(reviewInput);
        } catch (AuthException e) {
            reviewInput.labels = null;
            gApi.changes().id(originalChange._number).revision(CURRENT).review(reviewInput);
        }
    }
}
#end_block

#method_before
public void createDownstreamMerges(MultipleDownstreamMergeInput mdsMergeInput) throws RestApiException, FailedMergeException, ConfigInvalidException, InvalidQueryParameterException {
    // Map from branch to error message
    Map<String, String> failedMergeBranchMap = new TreeMap<String, String>();
    List<Integer> existingDownstream;
    for (String downstreamBranch : mdsMergeInput.dsBranchMap.keySet()) {
        // If there are existing downstream merges, update them
        // Otherwise, create them.
        boolean createDownstreams = true;
        if (mdsMergeInput.obsoleteRevision != null) {
            existingDownstream = getExistingMergesOnBranch(mdsMergeInput.obsoleteRevision, mdsMergeInput.topic, downstreamBranch);
            if (!existingDownstream.isEmpty()) {
                log.debug("Attempting to update downstream merge of {} on branch {}", mdsMergeInput.currentRevision, downstreamBranch);
                // it's possible to construct it so that it's not
                for (Integer dsChangeNumber : existingDownstream) {
                    try {
                        updateDownstreamMerge(mdsMergeInput.currentRevision, mdsMergeInput.subject, dsChangeNumber, mdsMergeInput.dsBranchMap.get(downstreamBranch));
                        createDownstreams = false;
                    } catch (MergeConflictException e) {
                        failedMergeBranchMap.put(downstreamBranch, e.getMessage());
                        log.debug("Abandoning existing, obsolete {} due to merge conflict.", dsChangeNumber);
                        abandonChange(dsChangeNumber);
                    }
                }
            }
        }
        if (createDownstreams) {
            log.debug("Attempting to create downstream merge of {} on branch {}", mdsMergeInput.currentRevision, downstreamBranch);
            SingleDownstreamMergeInput sdsMergeInput = new SingleDownstreamMergeInput();
            sdsMergeInput.currentRevision = mdsMergeInput.currentRevision;
            sdsMergeInput.changeNumber = mdsMergeInput.changeNumber;
            sdsMergeInput.project = mdsMergeInput.project;
            sdsMergeInput.topic = mdsMergeInput.topic;
            sdsMergeInput.subject = mdsMergeInput.subject;
            sdsMergeInput.downstreamBranch = downstreamBranch;
            sdsMergeInput.doMerge = mdsMergeInput.dsBranchMap.get(downstreamBranch);
            try {
                createSingleDownstreamMerge(sdsMergeInput);
            } catch (MergeConflictException e) {
                failedMergeBranchMap.put(downstreamBranch, e.getMessage());
            }
        }
    }
    if (!failedMergeBranchMap.isEmpty()) {
        throw new FailedMergeException(failedMergeBranchMap, mdsMergeInput.currentRevision, config.getHostName(), mdsMergeInput.project, mdsMergeInput.changeNumber, mdsMergeInput.patchsetNumber, config.getConflictMessage(), mdsMergeInput.topic);
    }
}
#method_after
public void createDownstreamMerges(MultipleDownstreamMergeInput mdsMergeInput) throws RestApiException, FailedMergeException, ConfigInvalidException, InvalidQueryParameterException, OrmException {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        // Map from branch to error message
        Map<String, String> failedMergeBranchMap = new TreeMap<>();
        List<Integer> existingDownstream;
        for (String downstreamBranch : mdsMergeInput.dsBranchMap.keySet()) {
            // If there are existing downstream merges, update them
            // Otherwise, create them.
            boolean createDownstreams = true;
            if (mdsMergeInput.obsoleteRevision != null) {
                existingDownstream = getExistingMergesOnBranch(mdsMergeInput.obsoleteRevision, mdsMergeInput.topic, downstreamBranch);
                if (!existingDownstream.isEmpty()) {
                    log.debug("Attempting to update downstream merge of {} on branch {}", mdsMergeInput.currentRevision, downstreamBranch);
                    // it's possible to construct it so that it's not
                    for (Integer dsChangeNumber : existingDownstream) {
                        try {
                            updateDownstreamMerge(mdsMergeInput.currentRevision, mdsMergeInput.subject, dsChangeNumber, mdsMergeInput.dsBranchMap.get(downstreamBranch));
                            createDownstreams = false;
                        } catch (MergeConflictException e) {
                            failedMergeBranchMap.put(downstreamBranch, e.getMessage());
                            log.debug("Abandoning existing, obsolete {} due to merge conflict.", dsChangeNumber);
                            abandonChange(dsChangeNumber);
                        }
                    }
                }
            }
            if (createDownstreams) {
                log.debug("Attempting to create downstream merge of {} on branch {}", mdsMergeInput.currentRevision, downstreamBranch);
                SingleDownstreamMergeInput sdsMergeInput = new SingleDownstreamMergeInput();
                sdsMergeInput.currentRevision = mdsMergeInput.currentRevision;
                sdsMergeInput.changeNumber = mdsMergeInput.changeNumber;
                sdsMergeInput.project = mdsMergeInput.project;
                sdsMergeInput.topic = mdsMergeInput.topic;
                sdsMergeInput.subject = mdsMergeInput.subject;
                sdsMergeInput.downstreamBranch = downstreamBranch;
                sdsMergeInput.doMerge = mdsMergeInput.dsBranchMap.get(downstreamBranch);
                try {
                    createSingleDownstreamMerge(sdsMergeInput);
                } catch (MergeConflictException e) {
                    failedMergeBranchMap.put(downstreamBranch, e.getMessage());
                }
            }
        }
        if (!failedMergeBranchMap.isEmpty()) {
            throw new FailedMergeException(failedMergeBranchMap, mdsMergeInput.currentRevision, config.getHostName(), mdsMergeInput.project, mdsMergeInput.changeNumber, mdsMergeInput.patchsetNumber, config.getConflictMessage(), mdsMergeInput.topic);
        }
    }
}
#end_block

#method_before
public List<Integer> getExistingMergesOnBranch(String upstreamRevision, String topic, String downstreamBranch) throws RestApiException, InvalidQueryParameterException {
    List<Integer> downstreamChangeNumbers = new ArrayList<Integer>();
    List<ChangeInfo> changes = getChangesInTopicAndBranch(topic, downstreamBranch);
    for (ChangeInfo change : changes) {
        String changeRevision = change.currentRevision;
        RevisionInfo revision = change.revisions.get(changeRevision);
        List<CommitInfo> parents = revision.commit.parents;
        if (parents.size() > 1) {
            String secondParent = parents.get(1).commit;
            if (secondParent.equals(upstreamRevision)) {
                downstreamChangeNumbers.add(change._number);
            }
        }
    }
    return downstreamChangeNumbers;
}
#method_after
public List<Integer> getExistingMergesOnBranch(String upstreamRevision, String topic, String downstreamBranch) throws RestApiException, InvalidQueryParameterException, OrmException, ConfigInvalidException {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        List<Integer> downstreamChangeNumbers = new ArrayList<>();
        List<ChangeInfo> changes = getChangesInTopicAndBranch(topic, downstreamBranch);
        for (ChangeInfo change : changes) {
            String changeRevision = change.currentRevision;
            RevisionInfo revision = change.revisions.get(changeRevision);
            List<CommitInfo> parents = revision.commit.parents;
            if (parents.size() > 1) {
                String secondParent = parents.get(1).commit;
                if (secondParent.equals(upstreamRevision)) {
                    downstreamChangeNumbers.add(change._number);
                }
            }
        }
        return downstreamChangeNumbers;
    }
}
#end_block

#method_before
public void createSingleDownstreamMerge(SingleDownstreamMergeInput sdsMergeInput) throws RestApiException, ConfigInvalidException, InvalidQueryParameterException {
    String currentTopic = getOrSetTopic(sdsMergeInput.changeNumber, sdsMergeInput.topic);
    if (isAlreadyMerged(sdsMergeInput, currentTopic)) {
        log.info("Commit {} already merged into {}, not automerging again.", sdsMergeInput.currentRevision, sdsMergeInput.downstreamBranch);
        return;
    }
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = sdsMergeInput.currentRevision;
    mergeInput.strategy = "recursive";
    log.debug("Creating downstream merge for {}", sdsMergeInput.currentRevision);
    ChangeInput downstreamChangeInput = new ChangeInput();
    downstreamChangeInput.project = sdsMergeInput.project;
    downstreamChangeInput.branch = sdsMergeInput.downstreamBranch;
    downstreamChangeInput.subject = getSubjectForDownstreamMerge(sdsMergeInput.subject, sdsMergeInput.currentRevision, false);
    downstreamChangeInput.topic = currentTopic;
    downstreamChangeInput.merge = mergeInput;
    downstreamChangeInput.notify = NotifyHandling.NONE;
    downstreamChangeInput.baseChange = getBaseChangeId(getChangeParents(sdsMergeInput.changeNumber, sdsMergeInput.currentRevision), sdsMergeInput.downstreamBranch);
    if (!sdsMergeInput.doMerge) {
        mergeInput.strategy = "ours";
        downstreamChangeInput.subject = getSubjectForDownstreamMerge(sdsMergeInput.subject, sdsMergeInput.currentRevision, true);
        log.debug("Skipping merge for {} to {}", sdsMergeInput.currentRevision, sdsMergeInput.downstreamBranch);
    }
    ChangeApi downstreamChange = gApi.changes().create(downstreamChangeInput);
    // Vote maxAutomergeVote on the change so we know it was successful.
    if (!config.maxAutomergeVoteDisabled()) {
        updateVote(downstreamChange.get(), config.getAutomergeLabel(), config.getMaxAutomergeVote());
    }
}
#method_after
public void createSingleDownstreamMerge(SingleDownstreamMergeInput sdsMergeInput) throws RestApiException, ConfigInvalidException, InvalidQueryParameterException, OrmException {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        String currentTopic = getOrSetTopic(sdsMergeInput.changeNumber, sdsMergeInput.topic);
        if (isAlreadyMerged(sdsMergeInput, currentTopic)) {
            log.info("Commit {} already merged into {}, not automerging again.", sdsMergeInput.currentRevision, sdsMergeInput.downstreamBranch);
            return;
        }
        MergeInput mergeInput = new MergeInput();
        mergeInput.source = sdsMergeInput.currentRevision;
        mergeInput.strategy = "recursive";
        log.debug("Creating downstream merge for {}", sdsMergeInput.currentRevision);
        ChangeInput downstreamChangeInput = new ChangeInput();
        downstreamChangeInput.project = sdsMergeInput.project;
        downstreamChangeInput.branch = sdsMergeInput.downstreamBranch;
        downstreamChangeInput.subject = getSubjectForDownstreamMerge(sdsMergeInput.subject, sdsMergeInput.currentRevision, false);
        downstreamChangeInput.topic = currentTopic;
        downstreamChangeInput.merge = mergeInput;
        downstreamChangeInput.notify = NotifyHandling.NONE;
        downstreamChangeInput.baseChange = getBaseChangeId(getChangeParents(sdsMergeInput.changeNumber, sdsMergeInput.currentRevision), sdsMergeInput.downstreamBranch);
        if (!sdsMergeInput.doMerge) {
            mergeInput.strategy = "ours";
            downstreamChangeInput.subject = getSubjectForDownstreamMerge(sdsMergeInput.subject, sdsMergeInput.currentRevision, true);
            log.debug("Skipping merge for {} to {}", sdsMergeInput.currentRevision, sdsMergeInput.downstreamBranch);
        }
        ChangeApi downstreamChange = gApi.changes().create(downstreamChangeInput);
        tagChange(downstreamChange.get(), "Automerger change created!");
    }
}
#end_block

#method_before
public String getOrSetTopic(int sourceId, String topic) throws RestApiException {
    if (isNullOrEmpty(topic)) {
        topic = "am-" + UUID.randomUUID();
        log.debug("Setting original change {} topic to {}", sourceId, topic);
        gApi.changes().id(sourceId).topic(topic);
    }
    return topic;
}
#method_after
public String getOrSetTopic(int sourceId, String topic) throws RestApiException, OrmException, ConfigInvalidException {
    try (ManualRequestContext ctx = oneOffRequestContext.openAs(config.getContextUserId())) {
        if (isNullOrEmpty(topic)) {
            topic = "am-" + UUID.randomUUID();
            log.debug("Setting original change {} topic to {}", sourceId, topic);
            gApi.changes().id(sourceId).topic(topic);
        }
        return topic;
    }
}
#end_block

#method_before
private void automergeChanges(ChangeInfo change, RevisionInfo revisionInfo) throws RestApiException, IOException, ConfigInvalidException, InvalidQueryParameterException {
    if (revisionInfo.draft != null && revisionInfo.draft) {
        log.debug("Patchset {} is draft change, ignoring.", revisionInfo.commit.commit);
        return;
    }
    String currentRevision = revisionInfo.commit.commit;
    log.debug("Handling patchsetevent with change id {} and revision {}", change.id, currentRevision);
    Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    // Map whether or not we should merge it or skip it for each downstream
    Map<String, Boolean> dsBranchMap = new HashMap<String, Boolean>();
    for (String downstreamBranch : downstreamBranches) {
        boolean isSkipMerge = config.isSkipMerge(change.branch, downstreamBranch, change.subject);
        dsBranchMap.put(downstreamBranch, !isSkipMerge);
    }
    log.debug("Automerging change {} from branch {}", change.id, change.branch);
    ChangeApi currentChange = gApi.changes().id(change._number);
    String previousRevision = getPreviousRevision(currentChange, revisionInfo._number);
    MultipleDownstreamMergeInput mdsMergeInput = new MultipleDownstreamMergeInput();
    mdsMergeInput.dsBranchMap = dsBranchMap;
    mdsMergeInput.changeNumber = change._number;
    mdsMergeInput.patchsetNumber = revisionInfo._number;
    mdsMergeInput.project = change.project;
    mdsMergeInput.topic = getOrSetTopic(change._number, change.topic);
    mdsMergeInput.subject = change.subject;
    mdsMergeInput.obsoleteRevision = previousRevision;
    mdsMergeInput.currentRevision = currentRevision;
    createMergesAndHandleConflicts(mdsMergeInput);
}
#method_after
private void automergeChanges(ChangeInfo change, RevisionInfo revisionInfo) throws RestApiException, IOException, ConfigInvalidException, InvalidQueryParameterException, OrmException {
    if (revisionInfo.draft != null && revisionInfo.draft) {
        log.debug("Patchset {} is draft change, ignoring.", revisionInfo.commit.commit);
        return;
    }
    String currentRevision = revisionInfo.commit.commit;
    log.debug("Handling patchsetevent with change id {} and revision {}", change.id, currentRevision);
    Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
    if (downstreamBranches.isEmpty()) {
        log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
        return;
    }
    // Map whether or not we should merge it or skip it for each downstream
    Map<String, Boolean> dsBranchMap = new HashMap<String, Boolean>();
    for (String downstreamBranch : downstreamBranches) {
        boolean isSkipMerge = config.isSkipMerge(change.branch, downstreamBranch, change.subject);
        dsBranchMap.put(downstreamBranch, !isSkipMerge);
    }
    log.debug("Automerging change {} from branch {}", change.id, change.branch);
    ChangeApi currentChange = gApi.changes().id(change._number);
    String previousRevision = getPreviousRevision(currentChange, revisionInfo._number);
    MultipleDownstreamMergeInput mdsMergeInput = new MultipleDownstreamMergeInput();
    mdsMergeInput.dsBranchMap = dsBranchMap;
    mdsMergeInput.changeNumber = change._number;
    mdsMergeInput.patchsetNumber = revisionInfo._number;
    mdsMergeInput.project = change.project;
    mdsMergeInput.topic = getOrSetTopic(change._number, change.topic);
    mdsMergeInput.subject = change.subject;
    mdsMergeInput.obsoleteRevision = previousRevision;
    mdsMergeInput.currentRevision = currentRevision;
    createMergesAndHandleConflicts(mdsMergeInput);
}
#end_block

#method_before
private void abandonDownstream(ChangeInfo change, String revision) throws ConfigInvalidException {
    try {
        Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        if (downstreamBranches.isEmpty()) {
            log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        for (String downstreamBranch : downstreamBranches) {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            log.debug("Abandoning existing downstreams: {}", existingDownstream);
            for (Integer changeNumber : existingDownstream) {
                abandonChange(changeNumber);
            }
        }
    } catch (RestApiException | IOException | InvalidQueryParameterException e) {
        log.error("Failed to abandon downstreams of {}", change.id, e);
    }
}
#method_after
private void abandonDownstream(ChangeInfo change, String revision) throws ConfigInvalidException, OrmException {
    try {
        Set<String> downstreamBranches = config.getDownstreamBranches(change.branch, change.project);
        if (downstreamBranches.isEmpty()) {
            log.debug("Downstream branches of {} on {} are empty", change.branch, change.project);
            return;
        }
        for (String downstreamBranch : downstreamBranches) {
            List<Integer> existingDownstream = getExistingMergesOnBranch(revision, change.topic, downstreamBranch);
            log.debug("Abandoning existing downstreams: {}", existingDownstream);
            for (Integer changeNumber : existingDownstream) {
                abandonChange(changeNumber);
            }
        }
    } catch (RestApiException | IOException | InvalidQueryParameterException e) {
        log.error("Failed to abandon downstreams of {}", change.id, e);
    }
}
#end_block

#method_before
private void updateVote(ChangeInfo change, String label, short vote) throws RestApiException {
    log.debug("Giving {} for label {} to {}", vote, label, change.id);
    // Vote on all downstream branches unless merge conflict.
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<String, Short>();
    labels.put(label, vote);
    reviewInput.labels = labels;
    reviewInput.notify = NotifyHandling.NONE;
    reviewInput.tag = AUTOMERGER_TAG;
    try {
        gApi.changes().id(change.id).revision(change.currentRevision).review(reviewInput);
    } catch (AuthException e) {
        log.error("Automerger could not set label, but still continuing.", e);
    }
}
#method_after
private void updateVote(ChangeInfo change, String label, short vote) throws RestApiException {
    log.debug("Giving {} for label {} to {}", vote, label, change.id);
    // Vote on all downstream branches unless merge conflict.
    ReviewInput reviewInput = new ReviewInput();
    Map<String, Short> labels = new HashMap<String, Short>();
    labels.put(label, vote);
    reviewInput.labels = labels;
    reviewInput.notify = NotifyHandling.NONE;
    reviewInput.tag = AUTOMERGER_TAG;
    try {
        gApi.changes().id(change.id).revision(CURRENT).review(reviewInput);
    } catch (AuthException e) {
        log.error("Automerger could not set label, but still continuing.", e);
    }
}
#end_block

#method_before
private void updateDownstreamMerge(String newParentRevision, String upstreamSubject, Integer sourceNum, boolean doMerge) throws RestApiException, ConfigInvalidException {
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = newParentRevision;
    MergePatchSetInput mergePatchSetInput = new MergePatchSetInput();
    mergePatchSetInput.subject = getSubjectForDownstreamMerge(upstreamSubject, newParentRevision, false);
    if (!doMerge) {
        mergeInput.strategy = "ours";
        mergePatchSetInput.subject = getSubjectForDownstreamMerge(upstreamSubject, newParentRevision, true);
        log.debug("Skipping merge for {} on {}", newParentRevision, sourceNum);
    }
    mergePatchSetInput.merge = mergeInput;
    ChangeApi originalChange = gApi.changes().id(sourceNum);
    if (originalChange.info().status == ChangeStatus.ABANDONED) {
        RestoreInput restoreInput = new RestoreInput();
        restoreInput.message = "Restoring change due to upstream automerge.";
        originalChange.restore(restoreInput);
    }
    ChangeInfo downstreamChange = originalChange.createMergePatchSet(mergePatchSetInput);
    if (!config.maxAutomergeVoteDisabled()) {
        updateVote(downstreamChange, config.getAutomergeLabel(), config.getMaxAutomergeVote());
    }
}
#method_after
private void updateDownstreamMerge(String newParentRevision, String upstreamSubject, Integer sourceNum, boolean doMerge) throws RestApiException {
    MergeInput mergeInput = new MergeInput();
    mergeInput.source = newParentRevision;
    MergePatchSetInput mergePatchSetInput = new MergePatchSetInput();
    mergePatchSetInput.subject = getSubjectForDownstreamMerge(upstreamSubject, newParentRevision, false);
    if (!doMerge) {
        mergeInput.strategy = "ours";
        mergePatchSetInput.subject = getSubjectForDownstreamMerge(upstreamSubject, newParentRevision, true);
        log.debug("Skipping merge for {} on {}", newParentRevision, sourceNum);
    }
    mergePatchSetInput.merge = mergeInput;
    ChangeApi originalChange = gApi.changes().id(sourceNum);
    if (originalChange.info().status == ChangeStatus.ABANDONED) {
        RestoreInput restoreInput = new RestoreInput();
        restoreInput.message = "Restoring change due to upstream automerge.";
        originalChange.restore(restoreInput);
    }
    originalChange.createMergePatchSet(mergePatchSetInput);
}
#end_block

#method_before
private List<ChangeInfo> getChangesInTopicAndBranch(String topic, String downstreamBranch) throws InvalidQueryParameterException, RestApiException {
    QueryBuilder queryBuilder = new QueryBuilder();
    queryBuilder.addParameter("topic", topic);
    queryBuilder.addParameter("branch", downstreamBranch);
    queryBuilder.addParameter("status", "open");
    return gApi.changes().query(queryBuilder.get()).withOptions(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT).get();
}
#method_after
private List<ChangeInfo> getChangesInTopicAndBranch(String topic, String downstreamBranch) throws InvalidQueryParameterException, RestApiException {
    QueryBuilder queryBuilder = constructTopicQuery(topic);
    queryBuilder.addParameter("branch", downstreamBranch);
    return gApi.changes().query(queryBuilder.get()).withOptions(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_COMMIT).get();
}
#end_block

#method_before
private String getSubjectForDownstreamMerge(String upstreamSubject, String upstreamRevision, boolean skipped) {
    if (!upstreamSubject.startsWith(SUBJECT_PREFIX)) {
        upstreamSubject = Joiner.on(" ").join(SUBJECT_PREFIX, upstreamSubject);
    }
    String denotationString = skipped ? "skipped:" : "am:";
    return Joiner.on(" ").join(upstreamSubject, denotationString, upstreamRevision.substring(0, 10));
}
#method_after
private String getSubjectForDownstreamMerge(String upstreamSubject, String upstreamRevision, boolean skipped) {
    if (!upstreamSubject.startsWith("[" + SUBJECT_PREFIX)) {
        String prefix = "[" + SUBJECT_PREFIX + "]";
        if (skipped) {
            prefix = "[" + SUBJECT_PREFIX + " " + SKIPPED_PREFIX + "]";
        }
        upstreamSubject = Joiner.on(" ").join(prefix, upstreamSubject);
    }
    String denotationString = skipped ? "skipped:" : "am:";
    return Joiner.on(" ").join(upstreamSubject, denotationString, upstreamRevision.substring(0, 10));
}
#end_block

#method_before
@Override
public void onRevisionCreated(RevisionCreatedListener.Event event) {
    ChangeInfo c = event.getChange();
    if (ignoreDrafts && c.status == ChangeStatus.DRAFT) {
        log.debug("Ignoring draft change");
        return;
    }
    onEvent(new Project.NameKey(c.project), c._number, event.getWho().email);
}
#method_after
@Override
public void onRevisionCreated(RevisionCreatedListener.Event event) {
    ChangeInfo c = event.getChange();
    onEvent(new Project.NameKey(c.project), c._number, event.getWho());
}
#end_block

#method_before
private void onEvent(Project.NameKey projectName, int changeNumber, String email) {
    // TODO(davido): we have to cache per project configuration
    ReviewersConfig config = configFactory.create(projectName);
    List<ReviewerFilterSection> sections = config.getReviewerFilterSections();
    if (sections.isEmpty()) {
        return;
    }
    try (Repository git = repoManager.openRepository(projectName);
        RevWalk rw = new RevWalk(git);
        ReviewDb reviewDb = schemaFactory.open()) {
        ChangeData changeData = changeDataFactory.create(reviewDb, projectName, new Change.Id(changeNumber));
        Set<String> reviewers = findReviewers(sections, changeData);
        if (reviewers.isEmpty()) {
            return;
        }
        final Change change = changeData.change();
        final Runnable task = reviewersFactory.create(change, toAccounts(reviewDb, reviewers, projectName, email));
        workQueue.getDefaultQueue().submit(new Runnable() {

            ReviewDb db = null;

            @Override
            public void run() {
                RequestContext old = tl.setContext(new RequestContext() {

                    @Override
                    public CurrentUser getUser() {
                        return identifiedUserFactory.create(change.getOwner());
                    }

                    @Override
                    public Provider<ReviewDb> getReviewDbProvider() {
                        return new Provider<ReviewDb>() {

                            @Override
                            public ReviewDb get() {
                                if (db == null) {
                                    try {
                                        db = schemaFactory.open();
                                    } catch (OrmException e) {
                                        throw new ProvisionException("Cannot open ReviewDb", e);
                                    }
                                }
                                return db;
                            }
                        };
                    }
                });
                try {
                    task.run();
                } finally {
                    tl.setContext(old);
                    if (db != null) {
                        db.close();
                        db = null;
                    }
                }
            }
        });
    } catch (OrmException | IOException | QueryParseException x) {
        log.error(x.getMessage(), x);
    }
}
#method_after
private void onEvent(Project.NameKey projectName, int changeNumber, AccountInfo uploader) {
    // TODO(davido): we have to cache per project configuration
    ReviewersConfig config = configFactory.create(projectName);
    List<ReviewerFilterSection> sections = config.getReviewerFilterSections();
    if (sections.isEmpty()) {
        return;
    }
    try (Repository git = repoManager.openRepository(projectName);
        RevWalk rw = new RevWalk(git);
        ReviewDb reviewDb = schemaFactory.open()) {
        ChangeData changeData = changeDataFactory.create(reviewDb, projectName, new Change.Id(changeNumber));
        Set<String> reviewers = findReviewers(sections, changeData);
        if (reviewers.isEmpty()) {
            return;
        }
        final Change change = changeData.change();
        final Runnable task = reviewersFactory.create(change, toAccounts(reviewDb, reviewers, projectName, uploader));
        workQueue.getDefaultQueue().submit(new Runnable() {

            ReviewDb db = null;

            @Override
            public void run() {
                RequestContext old = tl.setContext(new RequestContext() {

                    @Override
                    public CurrentUser getUser() {
                        return identifiedUserFactory.create(change.getOwner());
                    }

                    @Override
                    public Provider<ReviewDb> getReviewDbProvider() {
                        return new Provider<ReviewDb>() {

                            @Override
                            public ReviewDb get() {
                                if (db == null) {
                                    try {
                                        db = schemaFactory.open();
                                    } catch (OrmException e) {
                                        throw new ProvisionException("Cannot open ReviewDb", e);
                                    }
                                }
                                return db;
                            }
                        };
                    }
                });
                try {
                    task.run();
                } finally {
                    tl.setContext(old);
                    if (db != null) {
                        db.close();
                        db = null;
                    }
                }
            }
        });
    } catch (OrmException | IOException | QueryParseException x) {
        log.error(x.getMessage(), x);
    }
}
#end_block

#method_before
private Set<Account> toAccounts(ReviewDb reviewDb, Set<String> in, Project.NameKey p, String uploaderEMail) {
    Set<Account> reviewers = Sets.newHashSetWithExpectedSize(in.size());
    GroupMembers groupMembers = null;
    for (String r : in) {
        try {
            Account account = accountResolver.find(reviewDb, r);
            if (account != null) {
                reviewers.add(account);
                continue;
            }
        } catch (OrmException | IOException | ConfigInvalidException e) {
            // If the account doesn't exist, find() will return null.  We only
            // get here if something went wrong accessing the database
            log.error("Failed to resolve account " + r, e);
            continue;
        }
        if (groupMembers == null) {
            groupMembers = groupMembersFactory.create(identifiedUserFactory.create(Iterables.getOnlyElement(byEmailCache.get(uploaderEMail))));
        }
        try {
            reviewers.addAll(groupMembers.listAccounts(groupsCollection.get().parse(r).getGroupUUID(), p));
        } catch (UnprocessableEntityException | NoSuchGroupException e) {
            log.warn(String.format("Reviewer %s is neither an account nor a group", r));
        } catch (NoSuchProjectException e) {
            log.warn(String.format("Failed to list accounts for group %s and project %s", r, p));
        } catch (IOException | OrmException e) {
            log.warn(String.format("Failed to list accounts for group %s", r), e);
        }
    }
    return reviewers;
}
#method_after
private Set<Account> toAccounts(ReviewDb reviewDb, Set<String> in, Project.NameKey p, AccountInfo uploader) {
    Set<Account> reviewers = Sets.newHashSetWithExpectedSize(in.size());
    GroupMembers groupMembers = null;
    for (String r : in) {
        try {
            Account account = accountResolver.find(reviewDb, r);
            if (account != null) {
                reviewers.add(account);
                continue;
            }
        } catch (OrmException | IOException | ConfigInvalidException e) {
            // If the account doesn't exist, find() will return null.  We only
            // get here if something went wrong accessing the database
            log.error("Failed to resolve account " + r, e);
            continue;
        }
        if (groupMembers == null) {
            // email is not unique to one account, try to locate the account using
            // "Full name <email>" to increase chance of finding only one.
            String uploaderNameEmail = String.format("%s <%s>", uploader.name, uploader.email);
            try {
                Account uploaderAccount = accountResolver.findByNameOrEmail(reviewDb, uploaderNameEmail);
                if (uploaderAccount != null) {
                    groupMembers = groupMembersFactory.create(identifiedUserFactory.create(uploaderAccount.getId()));
                }
            } catch (OrmException | IOException e) {
                log.warn(String.format("Failed to list accounts for group %s, cannot retrieve uploader account %s", r, uploaderNameEmail), e);
            }
            try {
                if (groupMembers != null) {
                    reviewers.addAll(groupMembers.listAccounts(groupsCollection.get().parse(r).getGroupUUID(), p));
                } else {
                    log.warn(String.format("Failed to list accounts for group %s; cannot retrieve uploader account for %s", r, uploader.email));
                }
            } catch (UnprocessableEntityException | NoSuchGroupException e) {
                log.warn(String.format("Reviewer %s is neither an account nor a group", r));
            } catch (NoSuchProjectException e) {
                log.warn(String.format("Failed to list accounts for group %s and project %s", r, p));
            } catch (IOException | OrmException e) {
                log.warn(String.format("Failed to list accounts for group %s", r), e);
            }
        }
    }
    return reviewers;
}
#end_block

#method_before
private Stream<GroupDescription.Internal> getAllExistingGroups() throws OrmException {
    if (!projects.isEmpty()) {
        return projects.stream().map(ProjectControl::getAllGroups).flatMap(Collection::stream).map(GroupReference::getUUID).distinct().map(groupCache::get).flatMap(Streams::stream).map(InternalGroupDescription::new);
    } else {
        return groups.getAll(db.get()).map(GroupDescriptions::forAccountGroup);
    }
}
#method_after
private Stream<GroupDescription.Internal> getAllExistingGroups() throws OrmException {
    if (!projects.isEmpty()) {
        return projects.stream().map(ProjectControl::getProjectState).map(ProjectState::getAllGroups).flatMap(Collection::stream).map(GroupReference::getUUID).distinct().map(groupCache::get).flatMap(Streams::stream).map(InternalGroupDescription::new);
    }
    return groups.getAll(db.get()).map(GroupDescriptions::forAccountGroup);
}
#end_block

#method_before
@Override
public void check() throws StartupException {
    Map<AccountGroup.UUID, String> configuredNames = new HashMap<>();
    Map<String, AccountGroup.UUID> byLowerCaseConfiguredName = new HashMap<>();
    for (AccountGroup.UUID uuid : all) {
        String configuredName = cfg.getString("groups", uuid.get(), "name");
        if (configuredName != null) {
            configuredNames.put(uuid, configuredName);
            byLowerCaseConfiguredName.put(configuredName.toLowerCase(Locale.US), uuid);
        }
    }
    if (configuredNames.isEmpty()) {
        return;
    }
    Optional<AccountGroup> conflictingGroup;
    try {
        conflictingGroup = groups.getAll(db.get()).filter(group -> hasConfiguredName(byLowerCaseConfiguredName, group)).findAny();
    } catch (OrmException ignored) {
        return;
    }
    if (conflictingGroup.isPresent()) {
        AccountGroup group = conflictingGroup.get();
        String groupName = group.getName();
        AccountGroup.UUID systemGroupUuid = byLowerCaseConfiguredName.get(groupName);
        throw new StartupException(getAmbiguousNameMessage(groupName, group.getGroupUUID(), systemGroupUuid));
    }
}
#method_after
@Override
public void check() throws StartupException {
    Map<AccountGroup.UUID, String> configuredNames = new HashMap<>();
    Map<String, AccountGroup.UUID> byLowerCaseConfiguredName = new HashMap<>();
    for (AccountGroup.UUID uuid : all) {
        String configuredName = cfg.getString("groups", uuid.get(), "name");
        if (configuredName != null) {
            configuredNames.put(uuid, configuredName);
            byLowerCaseConfiguredName.put(configuredName.toLowerCase(Locale.US), uuid);
        }
    }
    if (configuredNames.isEmpty()) {
        return;
    }
    Optional<AccountGroup> conflictingGroup;
    try {
        conflictingGroup = groups.getAll(schema.open()).filter(group -> hasConfiguredName(byLowerCaseConfiguredName, group)).findAny();
    } catch (OrmException ignored) {
        return;
    }
    if (conflictingGroup.isPresent()) {
        AccountGroup group = conflictingGroup.get();
        String groupName = group.getName();
        AccountGroup.UUID systemGroupUuid = byLowerCaseConfiguredName.get(groupName);
        throw new StartupException(getAmbiguousNameMessage(groupName, group.getGroupUUID(), systemGroupUuid));
    }
}
#end_block

#method_before
private AccountState missing(Account.Id accountId) {
    Account account = new Account(accountId, TimeUtil.nowTs());
    account.setActive(false);
    Set<AccountGroup.UUID> anon = ImmutableSet.of();
    return new AccountState(allUsersName, account, anon, Collections.emptySet(), new HashMap<>());
}
#method_after
private AccountState missing(Account.Id accountId) {
    Account account = new Account(accountId, TimeUtil.nowTs());
    account.setActive(false);
    Set<AccountGroup.UUID> anon = ImmutableSet.of();
    return new AccountState(allUsersName, account, anon, Collections.emptySet(), new HashMap<ProjectWatchKey, Set<NotifyType>>());
}
#end_block

#method_before
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.canceledByReplication();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, config.getDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    pushOp.setToRetry();
                    pool.schedule(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    break;
            }
        }
    }
}
#method_after
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.canceledByReplication();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, config.getDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    if (pushOp.setToRetry()) {
                        pool.schedule(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    } else {
                        pushOp.canceledByReplication();
                        pending.remove(uri);
                        stateLog.error("Push to " + pushOp.getURI() + " cancelled after maximum number of retries", pushOp.getStatesAsArray());
                    }
                    break;
            }
        }
    }
}
#end_block

#method_before
@Override
public ImportStatistic apply(ProjectResource rsrc, Input input) throws RestApiException, OrmException, IOException, ValidationException, GitAPIException, NoSuchChangeException, NoSuchAccountException, UpdateException, ConfigInvalidException {
    if (Strings.isNullOrEmpty(input.name)) {
        throw new BadRequestException("name is required");
    }
    ImportProject.Input in = new ImportProject.Input();
    in.name = rsrc.getName();
    return importProjectFactory.create(new Project.NameKey(input.name)).setCopy(true).setErr(err).apply(new ConfigResource(), in);
}
#method_after
@Override
public ImportStatistic apply(ProjectResource rsrc, Input input) throws RestApiException, OrmException, IOException, ValidationException, GitAPIException, NoSuchChangeException, NoSuchAccountException, UpdateException, ConfigInvalidException, PermissionBackendException {
    if (Strings.isNullOrEmpty(input.name)) {
        throw new BadRequestException("name is required");
    }
    ImportProject.Input in = new ImportProject.Input();
    in.name = rsrc.getName();
    return importProjectFactory.create(new Project.NameKey(input.name)).setCopy(true).setErr(err).apply(new ConfigResource(), in);
}
#end_block

#method_before
private boolean canCopy() {
    CapabilityControl ctl = currentUserProvider.get().getCapabilities();
    return ctl.canAdministrateServer() || ctl.canPerform(pluginName + "-" + CopyProjectCapability.ID);
}
#method_after
private boolean canCopy() {
    return permissionBackend.user(currentUserProvider).testOrFalse(ADMINISTRATE_SERVER) || permissionBackend.user(currentUserProvider).testOrFalse(new PluginPermission(pluginName, CopyProjectCapability.ID));
}
#end_block

