944
#method_before
private void newMacPool() {
    SharedMacPoolModel model = new NewSharedMacPoolModel(this);
    setWindow(model);
}
#method_after
private void newMacPool() {
    SharedMacPoolModel model = new NewSharedMacPoolModel(this);
    model.setEntity(new MacPool());
    setWindow(model);
}
#end_block

#method_before
private void editMacPool() {
    SharedMacPoolModel model = new SharedMacPoolModel(this, VdcActionType.UpdateMacPool);
    model.setTitle(ConstantsManager.getInstance().getConstants().editSharedMacPoolTitle());
    // $NON-NLS-1$
    model.setHashName("edit_shared_mac_pool");
    model.setHelpTag(HelpTag.edit_shared_mac_pool);
    setWindow(model);
    model.setEntity((MacPool) getSelectedItem());
}
#method_after
private void editMacPool() {
    SharedMacPoolModel model = new SharedMacPoolModel(this, VdcActionType.UpdateMacPool);
    model.setTitle(ConstantsManager.getInstance().getConstants().editSharedMacPoolTitle());
    // $NON-NLS-1$
    model.setHashName("edit_shared_mac_pool");
    model.setHelpTag(HelpTag.edit_shared_mac_pool);
    model.setEntity((MacPool) getSelectedItem());
    setWindow(model);
}
#end_block

#method_before
private void removeMacPools() {
    ConfirmationModel model = new ConfirmationModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().removeSharedMacPoolsTitle());
    // $NON-NLS-1$
    model.setHashName("remove_shared_mac_pools");
    model.setHelpTag(HelpTag.remove_shared_mac_pools);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand(CMD_REMOVE, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand(CMD_CANCEL, this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    setConfirmWindow(model);
    List<String> macPoolNames = new ArrayList<String>();
    for (MacPool macPool : (Iterable<MacPool>) getSelectedItems()) {
        macPoolNames.add(macPool.getName());
    }
    model.setItems(macPoolNames);
}
#method_after
private void removeMacPools() {
    ConfirmationModel model = new ConfirmationModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().removeSharedMacPoolsTitle());
    // $NON-NLS-1$
    model.setHashName("remove_shared_mac_pools");
    model.setHelpTag(HelpTag.remove_shared_mac_pools);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand(CMD_REMOVE, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand(CMD_CANCEL, this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    List<String> macPoolNames = new ArrayList<String>();
    for (MacPool macPool : (Iterable<MacPool>) getSelectedItems()) {
        macPoolNames.add(macPool.getName());
    }
    model.setItems(macPoolNames);
    setConfirmWindow(model);
}
#end_block

#method_before
private void onRemove() {
    cancel();
    ArrayList<VdcActionParametersBase> params = new ArrayList<VdcActionParametersBase>();
    for (MacPool macPool : (Iterable<MacPool>) getSelectedItems()) {
        params.add(new IdParameters(macPool.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveMacPool, params);
}
#method_after
private void onRemove() {
    cancel();
    ArrayList<VdcActionParametersBase> params = new ArrayList<VdcActionParametersBase>();
    for (MacPool macPool : (Iterable<MacPool>) getSelectedItems()) {
        params.add(new RemoveMacPoolByIdParameters(macPool.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveMacPool, params);
}
#end_block

#method_before
public void guide() {
    DataCenterGuideModel model = new DataCenterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDataCenterGuideMeTitle());
    model.setHelpTag(HelpTag.new_data_center___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_data_center_-_guide_me");
    if (getGuideContext() == null) {
        StoragePool dataCenter = (StoragePool) getSelectedItem();
        setGuideContext(dataCenter.getId());
    }
    AsyncDataProvider.getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterListModel dataCenterListModel = (DataCenterListModel) target;
            DataCenterGuideModel model = (DataCenterGuideModel) dataCenterListModel.getWindow();
            model.setEntity((StoragePool) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", dataCenterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
public void guide() {
    DataCenterGuideModel model = new DataCenterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDataCenterGuideMeTitle());
    model.setHelpTag(HelpTag.new_data_center___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_data_center_-_guide_me");
    if (getGuideContext() == null) {
        StoragePool dataCenter = (StoragePool) getSelectedItem();
        setGuideContext(dataCenter.getId());
    }
    AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DataCenterListModel dataCenterListModel = (DataCenterListModel) target;
            DataCenterGuideModel model = (DataCenterGuideModel) dataCenterListModel.getWindow();
            model.setEntity((StoragePool) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", dataCenterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.StoragePool, isCaseSensitiveSearch());
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#method_after
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(applySortOptions(getSearchString()), SearchType.StoragePool, isCaseSensitiveSearch());
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    DataCenterModel model = new DataCenterModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDataCenterTitle());
    model.setHelpTag(HelpTag.new_data_center);
    // $NON-NLS-1$
    model.setHashName("new_data_center");
    model.setIsNew(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.setAddMacPoolCommand(addMacPoolCommand);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    DataCenterModel model = new DataCenterModel();
    model.setAddMacPoolCommand(addMacPoolCommand);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newDataCenterTitle());
    model.setHelpTag(HelpTag.new_data_center);
    // $NON-NLS-1$
    model.setHashName("new_data_center");
    model.setIsNew(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void edit() {
    StoragePool dataCenter = (StoragePool) getSelectedItem();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getWindow() != null) {
        return;
    }
    final DataCenterModel model = new DataCenterModel();
    setWindow(model);
    model.setEntity(dataCenter);
    model.setDataCenterId(dataCenter.getId());
    model.setTitle(constants.editDataCenterTitle());
    model.setHelpTag(HelpTag.edit_data_center);
    // $NON-NLS-1$
    model.setHashName("edit_data_center");
    model.getName().setEntity(dataCenter.getName());
    model.initSelectedMacPool();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.DataCenter) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    model.getDescription().setEntity(dataCenter.getdescription());
    model.getComment().setEntity(dataCenter.getComment());
    model.setOriginalName(dataCenter.getName());
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            if (storageDomainList.size() != 0) {
                model.getStoragePoolType().setChangeProhibitionReason(constants.cannotChangeRepositoryTypeWithSDAttached());
                model.getStoragePoolType().setIsChangable(false);
            }
        }
    }), dataCenter.getId());
    model.getStoragePoolType().setSelectedItem(dataCenter.isLocal());
    model.getQuotaEnforceTypeListModel().setSelectedItem(dataCenter.getQuotaEnforcementType());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.setAddMacPoolCommand(addMacPoolCommand);
}
#method_after
public void edit() {
    StoragePool dataCenter = (StoragePool) getSelectedItem();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getWindow() != null) {
        return;
    }
    final DataCenterModel model = new DataCenterModel();
    model.setAddMacPoolCommand(addMacPoolCommand);
    setWindow(model);
    model.setEntity(dataCenter);
    model.setDataCenterId(dataCenter.getId());
    model.setTitle(constants.editDataCenterTitle());
    model.setHelpTag(HelpTag.edit_data_center);
    // $NON-NLS-1$
    model.setHashName("edit_data_center");
    model.getName().setEntity(dataCenter.getName());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.DataCenter) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    model.getDescription().setEntity(dataCenter.getdescription());
    model.getComment().setEntity(dataCenter.getComment());
    model.setOriginalName(dataCenter.getName());
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            if (storageDomainList.size() != 0) {
                model.getStoragePoolType().setChangeProhibitionReason(constants.cannotChangeRepositoryTypeWithSDAttached());
                model.getStoragePoolType().setIsChangable(false);
            }
        }
    }), dataCenter.getId());
    model.getStoragePoolType().setSelectedItem(dataCenter.isLocal());
    model.getQuotaEnforceTypeListModel().setSelectedItem(dataCenter.getQuotaEnforcementType());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void addMacPool(final DataCenterModel dcModel) {
    SharedMacPoolModel macPoolModel = new NewSharedMacPoolModel(this) {

        @Override
        protected void postSave(Guid macPoolId) {
            super.postSave(macPoolId);
            ArrayList<MacPool> macPools = new ArrayList<MacPool>(dcModel.getMacPoolListModel().getItems());
            macPools.add(1, getEntity());
            dcModel.getMacPoolListModel().setItems(macPools);
            dcModel.getMacPoolListModel().setSelectedItem(getEntity());
        }
    };
    setConfirmWindow(macPoolModel);
}
#method_after
private void addMacPool(final DataCenterModel dcModel) {
    SharedMacPoolModel macPoolModel = new NewSharedMacPoolModel(this) {

        @Override
        protected void onActionSucceeded(Guid macPoolId) {
            MacPool macPool = getEntity();
            macPool.setId(macPoolId);
            Collection<MacPool> macPools = new ArrayList<MacPool>(dcModel.getMacPoolListModel().getItems());
            macPools.add(macPool);
            dcModel.getMacPoolListModel().setItems(macPools);
            dcModel.getMacPoolListModel().setSelectedItem(macPool);
            DataCenterListModel.this.setConfirmWindow(null);
        }
    };
    macPoolModel.setEntity(new MacPool());
    setConfirmWindow(macPoolModel);
}
#end_block

#method_before
public void recoveryStorage() {
    final ConfirmationModel windowModel = new ConfirmationModel();
    setWindow(windowModel);
    windowModel.setTitle(ConstantsManager.getInstance().getConstants().dataCenterReInitializeTitle());
    windowModel.setHelpTag(HelpTag.data_center_re_initialize);
    // $NON-NLS-1$
    windowModel.setHashName("data_center_re-initialize");
    windowModel.getLatch().setIsAvailable(true);
    windowModel.getLatch().setIsChangable(true);
    windowModel.startProgress(null);
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            windowModel.stopProgress();
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            List<EntityModel> models = new ArrayList<EntityModel>();
            for (StorageDomain a : storageDomainList) {
                if (a.getStorageDomainType() == StorageDomainType.Data && (a.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached)) {
                    EntityModel tempVar = new EntityModel();
                    tempVar.setEntity(a);
                    models.add(tempVar);
                }
            }
            windowModel.setItems(models);
            if (models.size() > 0) {
                EntityModel entityModel = models.size() != 0 ? models.get(0) : null;
                if (entityModel != null) {
                    entityModel.setIsSelected(true);
                }
            }
            if (models.isEmpty()) {
                windowModel.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoCompatibleStorageDomainsAttachThisDcMsg());
                windowModel.getLatch().setIsAvailable(false);
                // $NON-NLS-1$
                UICommand tempVar2 = new UICommand("Cancel", DataCenterListModel.this);
                tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                tempVar2.setIsDefault(true);
                tempVar2.setIsCancel(true);
                windowModel.getCommands().add(tempVar2);
            } else {
                // $NON-NLS-1$
                UICommand tempVar3 = new UICommand("OnRecover", DataCenterListModel.this);
                tempVar3.setTitle(ConstantsManager.getInstance().getConstants().ok());
                tempVar3.setIsDefault(true);
                windowModel.getCommands().add(tempVar3);
                // $NON-NLS-1$
                UICommand tempVar4 = new UICommand("Cancel", DataCenterListModel.this);
                tempVar4.setTitle(ConstantsManager.getInstance().getConstants().cancel());
                tempVar4.setIsCancel(true);
                windowModel.getCommands().add(tempVar4);
            }
        }
    }));
}
#method_after
public void recoveryStorage() {
    final ConfirmationModel windowModel = new ConfirmationModel();
    setWindow(windowModel);
    windowModel.setTitle(ConstantsManager.getInstance().getConstants().dataCenterReInitializeTitle());
    windowModel.setHelpTag(HelpTag.data_center_re_initialize);
    // $NON-NLS-1$
    windowModel.setHashName("data_center_re-initialize");
    windowModel.getLatch().setIsAvailable(true);
    windowModel.getLatch().setIsChangable(true);
    windowModel.startProgress(null);
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            windowModel.stopProgress();
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            List<EntityModel> models = new ArrayList<EntityModel>();
            for (StorageDomain a : storageDomainList) {
                if (a.getStorageDomainType() == StorageDomainType.Data && (a.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached)) {
                    EntityModel tempVar = new EntityModel();
                    tempVar.setEntity(a);
                    models.add(tempVar);
                }
            }
            windowModel.setItems(models);
            if (models.size() > 0) {
                EntityModel entityModel = models.size() != 0 ? models.get(0) : null;
                if (entityModel != null) {
                    entityModel.setIsSelected(true);
                }
            }
            if (models.isEmpty()) {
                windowModel.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoCompatibleStorageDomainsAttachThisDcMsg());
                windowModel.getLatch().setIsAvailable(false);
                // $NON-NLS-1$
                UICommand tempVar2 = new UICommand("Cancel", DataCenterListModel.this);
                tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                tempVar2.setIsDefault(true);
                tempVar2.setIsCancel(true);
                windowModel.getCommands().add(tempVar2);
            } else {
                // $NON-NLS-1$
                UICommand tempVar3 = new UICommand("OnRecover", DataCenterListModel.this);
                tempVar3.setTitle(ConstantsManager.getInstance().getConstants().ok());
                tempVar3.setIsDefault(true);
                windowModel.getCommands().add(tempVar3);
                // $NON-NLS-1$
                UICommand tempVar4 = new UICommand("Cancel", DataCenterListModel.this);
                tempVar4.setTitle(ConstantsManager.getInstance().getConstants().cancel());
                tempVar4.setIsCancel(true);
                windowModel.getCommands().add(tempVar4);
            }
        }
    }));
}
#end_block

#method_before
public void onRecover() {
    final ConfirmationModel windowModel = (ConfirmationModel) getWindow();
    if (!windowModel.validate()) {
        return;
    }
    AsyncDataProvider.getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            for (StorageDomain a : storageDomainList) {
                if (a.getStorageDomainType() == StorageDomainType.Master) {
                    break;
                }
            }
            List<StorageDomain> items = new ArrayList<StorageDomain>();
            for (EntityModel a : Linq.<EntityModel>cast(windowModel.getItems())) {
                if (a.getIsSelected()) {
                    items.add((StorageDomain) a.getEntity());
                }
            }
            if (items.size() > 0) {
                if (windowModel.getProgress() != null) {
                    return;
                }
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                for (StorageDomain a : items) {
                    parameters.add(new RecoveryStoragePoolParameters(((StoragePool) getSelectedItem()).getId(), a.getId()));
                }
                windowModel.startProgress(null);
                Frontend.getInstance().runMultipleAction(VdcActionType.RecoveryStoragePool, parameters, new IFrontendMultipleActionAsyncCallback() {

                    @Override
                    public void executed(FrontendMultipleActionAsyncResult result) {
                        ConfirmationModel localModel = (ConfirmationModel) result.getState();
                        localModel.stopProgress();
                        cancel();
                    }
                }, windowModel);
            } else {
                cancel();
            }
        }
    }), ((StoragePool) getSelectedItem()).getId());
}
#method_after
public void onRecover() {
    final ConfirmationModel windowModel = (ConfirmationModel) getWindow();
    if (!windowModel.validate()) {
        return;
    }
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<StorageDomain> storageDomainList = (List<StorageDomain>) returnValue;
            for (StorageDomain a : storageDomainList) {
                if (a.getStorageDomainType() == StorageDomainType.Master) {
                    break;
                }
            }
            List<StorageDomain> items = new ArrayList<StorageDomain>();
            for (EntityModel a : Linq.<EntityModel>cast(windowModel.getItems())) {
                if (a.getIsSelected()) {
                    items.add((StorageDomain) a.getEntity());
                }
            }
            if (items.size() > 0) {
                if (windowModel.getProgress() != null) {
                    return;
                }
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                for (StorageDomain a : items) {
                    parameters.add(new RecoveryStoragePoolParameters(((StoragePool) getSelectedItem()).getId(), a.getId()));
                }
                windowModel.startProgress(null);
                Frontend.getInstance().runMultipleAction(VdcActionType.RecoveryStoragePool, parameters, new IFrontendMultipleActionAsyncCallback() {

                    @Override
                    public void executed(FrontendMultipleActionAsyncResult result) {
                        ConfirmationModel localModel = (ConfirmationModel) result.getState();
                        localModel.stopProgress();
                        cancel();
                    }
                }, windowModel);
            } else {
                cancel();
            }
        }
    }), ((StoragePool) getSelectedItem()).getId());
}
#end_block

#method_before
private void updateIscsiBondListAvailability(StoragePool storagePool) {
    boolean iscsiBondSupported = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.IscsiMultipathingSupported, storagePool.getcompatibility_version().getValue());
    if (iscsiBondSupported) {
        AsyncDataProvider.getStorageConnectionsByDataCenterIdAndStorageType(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                boolean hasIscsiStorage = false;
                ArrayList<StorageServerConnections> connections = (ArrayList<StorageServerConnections>) returnValue;
                for (StorageServerConnections connection : connections) {
                    if (connection.getstorage_type() == StorageType.ISCSI) {
                        hasIscsiStorage = true;
                        break;
                    }
                }
                iscsiBondListModel.setIsAvailable(hasIscsiStorage);
            }
        }), storagePool.getId(), StorageType.ISCSI);
    } else {
        iscsiBondListModel.setIsAvailable(false);
    }
}
#method_after
private void updateIscsiBondListAvailability(StoragePool storagePool) {
    boolean iscsiBondSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.IscsiMultipathingSupported, storagePool.getcompatibility_version().getValue());
    if (iscsiBondSupported) {
        AsyncDataProvider.getInstance().getStorageConnectionsByDataCenterIdAndStorageType(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                boolean hasIscsiStorage = false;
                ArrayList<StorageServerConnections> connections = (ArrayList<StorageServerConnections>) returnValue;
                for (StorageServerConnections connection : connections) {
                    if (connection.getstorage_type() == StorageType.ISCSI) {
                        hasIscsiStorage = true;
                        break;
                    }
                }
                iscsiBondListModel.setIsAvailable(hasIscsiStorage);
            }
        }), storagePool.getId(), StorageType.ISCSI);
    } else {
        iscsiBondListModel.setIsAvailable(false);
    }
}
#end_block

#method_before
@Override
public UiCommandButton getMacPoolButton() {
    return addMacPoolButton;
}
#method_after
@Override
public HasUiCommandClickHandlers getMacPoolButton() {
    return addMacPoolButton;
}
#end_block

#method_before
public void setEntity(StoragePool value) {
    privateEntity = value;
}
#method_after
public void setEntity(StoragePool value) {
    privateEntity = value;
    initSelectedMacPool();
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getStoragePoolType()) {
        storagePoolType_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getMacPoolListModel()) {
        getMacPoolModel().setEntity(getMacPoolListModel().getSelectedItem());
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getStoragePoolType()) {
        storagePoolType_SelectedItemChanged();
    } else if (sender == getMacPoolListModel()) {
        if (ev.matchesDefinition(ListModel.itemsChangedEventDefinition)) {
            initSelectedMacPool();
        } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
            getMacPoolModel().setEntity(getMacPoolListModel().getSelectedItem());
        }
    }
}
#end_block

#method_before
private void storagePoolType_SelectedItemChanged() {
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            DataCenterModel dataCenterModel = (DataCenterModel) model;
            ArrayList<Version> versions = (ArrayList<Version>) result;
            // Rebuild version items.
            ArrayList<Version> list = new ArrayList<Version>();
            Boolean isLocalType = dataCenterModel.getStoragePoolType().getSelectedItem();
            for (Version item : versions) {
                if (AsyncDataProvider.isVersionMatchStorageType(item, isLocalType)) {
                    list.add(item);
                }
            }
            Version selectedVersion = null;
            if (dataCenterModel.getVersion().getSelectedItem() != null) {
                selectedVersion = dataCenterModel.getVersion().getSelectedItem();
                boolean hasSelectedVersion = false;
                for (Version version : list) {
                    if (selectedVersion.equals(version)) {
                        selectedVersion = version;
                        hasSelectedVersion = true;
                        break;
                    }
                }
                if (!hasSelectedVersion) {
                    selectedVersion = null;
                }
            }
            dataCenterModel.getVersion().setItems(list);
            if (selectedVersion == null) {
                dataCenterModel.getVersion().setSelectedItem(Linq.selectHighestVersion(list));
                if (getEntity() != null) {
                    initVersion();
                }
            } else {
                dataCenterModel.getVersion().setSelectedItem(selectedVersion);
            }
        }
    };
    AsyncDataProvider.getDataCenterVersions(_asyncQuery, getDataCenterId());
}
#method_after
private void storagePoolType_SelectedItemChanged() {
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            DataCenterModel dataCenterModel = (DataCenterModel) model;
            ArrayList<Version> versions = (ArrayList<Version>) result;
            // Rebuild version items.
            ArrayList<Version> list = new ArrayList<Version>();
            Boolean isLocalType = dataCenterModel.getStoragePoolType().getSelectedItem();
            for (Version item : versions) {
                if (AsyncDataProvider.getInstance().isVersionMatchStorageType(item, isLocalType)) {
                    list.add(item);
                }
            }
            Version selectedVersion = null;
            if (dataCenterModel.getVersion().getSelectedItem() != null) {
                selectedVersion = dataCenterModel.getVersion().getSelectedItem();
                boolean hasSelectedVersion = false;
                for (Version version : list) {
                    if (selectedVersion.equals(version)) {
                        selectedVersion = version;
                        hasSelectedVersion = true;
                        break;
                    }
                }
                if (!hasSelectedVersion) {
                    selectedVersion = null;
                }
            }
            dataCenterModel.getVersion().setItems(list);
            if (selectedVersion == null) {
                dataCenterModel.getVersion().setSelectedItem(Linq.selectHighestVersion(list));
                if (getEntity() != null) {
                    initVersion();
                }
            } else {
                dataCenterModel.getVersion().setSelectedItem(selectedVersion);
            }
        }
    };
    AsyncDataProvider.getInstance().getDataCenterVersions(_asyncQuery, getDataCenterId());
}
#end_block

#method_before
public void initSelectedMacPool() {
    Collection<MacPool> allMacPools = getMacPoolListModel().getItems();
    StoragePool dc = getEntity();
    if (allMacPools != null && dc != null) {
        Guid macPoolId = dc.getMacPoolId();
        if (macPoolId != null) {
            for (MacPool macPool : allMacPools) {
                if (macPoolId.equals(macPool.getId())) {
                    getMacPoolListModel().setSelectedItem(macPool);
                    break;
                }
            }
        }
    }
}
#method_after
private void initSelectedMacPool() {
    Collection<MacPool> allMacPools = getMacPoolListModel().getItems();
    StoragePool dc = getEntity();
    if (allMacPools != null && dc != null) {
        Guid macPoolId = dc.getMacPoolId();
        for (MacPool macPool : allMacPools) {
            if (macPool.getId().equals(macPoolId)) {
                getMacPoolListModel().setSelectedItem(macPool);
                break;
            }
        }
    }
}
#end_block

#method_before
@Override
public boolean validate() {
    super.validate();
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    setIsValid(getIsValid() && getName().getIsValid());
    return getIsValid();
}
#method_after
@Override
public boolean validate() {
    super.validate();
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getDescription().validateEntity(new IValidation[] { new AsciiOrNoneValidation() });
    setIsValid(getIsValid() && getName().getIsValid());
    return getIsValid();
}
#end_block

#method_before
private void cancel() {
    sourceModel.setWindow(null);
}
#method_after
protected void cancel() {
    sourceModel.setWindow(null);
}
#end_block

#method_before
private void onSave() {
    if (getProgress() != null) {
        return;
    }
    startProgress(null);
    MacPool macPool = flush();
    Frontend.getInstance().runAction(actionType, new MacPoolParameters(macPool), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            stopProgress();
            if (result.getReturnValue() != null && result.getReturnValue().getSucceeded()) {
                postSave((Guid) result.getReturnValue().getActionReturnValue());
            }
        }
    });
}
#method_after
private void onSave() {
    if (getProgress() != null || !validate()) {
        return;
    }
    startProgress(null);
    MacPool macPool = flush();
    Frontend.getInstance().runAction(actionType, new MacPoolParameters(macPool), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            stopProgress();
            if (result.getReturnValue() != null && result.getReturnValue().getSucceeded()) {
                onActionSucceeded((Guid) result.getReturnValue().getActionReturnValue());
            }
        }
    });
}
#end_block

#method_before
private static Collection<LongRange> clipMultiCastsFromRanges(Collection<LongRange> ranges) {
    final Collection<LongRange> result = new ArrayList<>();
    for (LongRange range : ranges) {
        final LongRange clippedRange = clipRange(range);
        if (clippedRange != null) {
            result.add(clippedRange);
        }
    }
    return result;
}
#method_after
public static Collection<LongRange> clipMultiCastsFromRanges(Collection<LongRange> ranges) {
    final Collection<LongRange> result = new ArrayList<>();
    for (LongRange range : ranges) {
        final LongRange clippedRange = clipRange(range);
        if (clippedRange != null) {
            result.add(clippedRange);
        }
    }
    return result;
}
#end_block

#method_before
@Override
public VdsStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VdsStatic entity = new VdsStatic();
    entity.setHostName(rs.getString("host_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueID(rs.getString("vds_unique_id"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setVdsGroupId(Guid.createGuidFromStringDefaultEmpty(rs.getString("vds_group_id")));
    entity.setId(Guid.createGuidFromStringDefaultEmpty(rs.getString("vds_id")));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setPmEnabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setHostProviderId(getGuidDefaultEmpty(rs, "host_provider_id"));
    return entity;
}
#method_after
@Override
public VdsStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VdsStatic entity = new VdsStatic();
    entity.setHostName(rs.getString("host_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueID(rs.getString("vds_unique_id"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setVdsGroupId(Guid.createGuidFromStringDefaultEmpty(rs.getString("vds_group_id")));
    entity.setId(Guid.createGuidFromStringDefaultEmpty(rs.getString("vds_id")));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setPmEnabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setHostProviderId(getGuid(rs, "host_provider_id"));
    return entity;
}
#end_block

#method_before
private boolean registerNewHost(Guid vdsGroupId, boolean IsPending) {
    boolean returnValue = true;
    VdsStatic vds = new VdsStatic(getParameters().getVdsHostName(), "", getStrippedVdsUniqueId(), getParameters().getVdsPort(), getParameters().getSSHPort(), getParameters().getSSHUser(), vdsGroupId, Guid.Empty, getParameters().getVdsName(), Config.<Boolean>getValue(ConfigValues.SSLEnabled), VDSType.VDS, Guid.Empty);
    vds.setSshKeyFingerprint(getParameters().getSSHFingerprint());
    log.debugFormat("RegisterVdsQuery::Register - Will try now to add VDS from scratch; Name: {0}, Hostname: {1}, Unique: {2}, VdsPort: {3},Subnet mask: {4}, IsPending: {5} with force synchronize", getParameters().getVdsName(), getParameters().getVdsHostName(), getStrippedVdsUniqueId(), getParameters().getVdsPort(), IsPending);
    AddVdsActionParameters p = new AddVdsActionParameters(vds, "");
    p.setAddPending(IsPending);
    VdcReturnValueBase ret = Backend.getInstance().runInternalAction(VdcActionType.AddVds, p);
    if (ret == null || !ret.getSucceeded()) {
        log.errorFormat("RegisterVdsQuery::Register - Registration failed for VDS - Name: {0}, Hostname: {1}, UniqueID: {2}, Subnet mask: {3}", getParameters().getVdsName(), getParameters().getVdsHostName(), getStrippedVdsUniqueId());
        CaptureCommandErrorsToLogger(ret, "RegisterVdsQuery::Register");
        error = AuditLogType.VDS_REGISTER_FAILED;
        returnValue = false;
    } else {
        log.infoFormat("RegisterVdsQuery::Register - Registered a new VDS {3} - Name: {0}, Hostname: {1}, UniqueID: {2}", getParameters().getVdsName(), getParameters().getVdsHostName(), getStrippedVdsUniqueId(), IsPending ? "pending approval" : "automatically approved");
    }
    return returnValue;
}
#method_after
private boolean registerNewHost(Guid vdsGroupId, boolean IsPending) {
    boolean returnValue = true;
    VdsStatic vds = new VdsStatic(getParameters().getVdsHostName(), "", getStrippedVdsUniqueId(), getParameters().getVdsPort(), getParameters().getSSHPort(), getParameters().getSSHUser(), vdsGroupId, Guid.Empty, getParameters().getVdsName(), Config.<Boolean>getValue(ConfigValues.SSLEnabled), VDSType.VDS, null);
    vds.setSshKeyFingerprint(getParameters().getSSHFingerprint());
    log.debugFormat("RegisterVdsQuery::Register - Will try now to add VDS from scratch; Name: {0}, Hostname: {1}, Unique: {2}, VdsPort: {3},Subnet mask: {4}, IsPending: {5} with force synchronize", getParameters().getVdsName(), getParameters().getVdsHostName(), getStrippedVdsUniqueId(), getParameters().getVdsPort(), IsPending);
    AddVdsActionParameters p = new AddVdsActionParameters(vds, "");
    p.setAddPending(IsPending);
    VdcReturnValueBase ret = Backend.getInstance().runInternalAction(VdcActionType.AddVds, p);
    if (ret == null || !ret.getSucceeded()) {
        log.errorFormat("RegisterVdsQuery::Register - Registration failed for VDS - Name: {0}, Hostname: {1}, UniqueID: {2}, Subnet mask: {3}", getParameters().getVdsName(), getParameters().getVdsHostName(), getStrippedVdsUniqueId());
        CaptureCommandErrorsToLogger(ret, "RegisterVdsQuery::Register");
        error = AuditLogType.VDS_REGISTER_FAILED;
        returnValue = false;
    } else {
        log.infoFormat("RegisterVdsQuery::Register - Registered a new VDS {3} - Name: {0}, Hostname: {1}, UniqueID: {2}", getParameters().getVdsName(), getParameters().getVdsHostName(), getStrippedVdsUniqueId(), IsPending ? "pending approval" : "automatically approved");
    }
    return returnValue;
}
#end_block

#method_before
public Integer getMemSharedPercent() {
    Long shared = mVdsStatistics.getmem_shared();
    Integer physical = mVdsDynamic.getphysical_mem_mb();
    if (shared == null || physical == null || physical == 0) {
        return 0;
    }
    return ((int) (shared * 100) / physical);
}
#method_after
public Integer getMemSharedPercent() {
    Long shared = mVdsStatistics.getmem_shared();
    Integer physical = mVdsDynamic.getphysical_mem_mb();
    if (shared == null || physical == null || physical == 0) {
        return 0;
    }
    return (int) ((shared * 100) / physical);
}
#end_block

#method_before
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHostProviderId(getGuidDefaultEmpty(rs, "host_provider_id"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.calculateFreeVirtualMemory();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    return entity;
}
#method_after
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHostProviderId(getGuid(rs, "host_provider_id"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.setKdumpStatus(KdumpStatus.valueOfNumber(rs.getInt("kdump_status")));
    entity.getSupportedRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("supported_rng_sources")));
    entity.calculateFreeVirtualMemory();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    entity.setSELinuxEnforceMode((Integer) rs.getObject("selinux_enforce_mode"));
    entity.setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(rs.getInt("auto_numa_balancing")));
    entity.setNumaSupport(rs.getBoolean("is_numa_supported"));
    entity.setLiveSnapshotSupport(rs.getBoolean("is_live_snapshot_supported"));
    return entity;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    oldMacPool = getMacPoolDao().get(getMacPoolId());
    final MacPoolValidator validator = new MacPoolValidator(oldMacPool, getMacPool());
    return validate(validator.macPoolExists()) && validate(validator.hasUniqueName()) && validate(validator.defaultFlagIsNotChanged());
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    oldMacPool = getMacPoolDao().get(getMacPoolId());
    return validate(new MacPoolValidator(oldMacPool).macPoolExists()) && validate(new MacPoolValidator(getMacPoolEntity()).hasUniqueName()) && validate(validateDefaultFlagIsNotChanged(oldMacPool, getMacPoolEntity()));
}
#end_block

#method_before
private Guid getMacPoolId() {
    return getMacPool().getId();
}
#method_after
public Guid getMacPoolId() {
    return getMacPoolEntity().getId();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setMacPoolIdForLog(getMacPoolId());
    setMacPoolNameForLog(oldMacPool.getName());
    getMacPoolDao().update(getMacPool());
    MacPoolPerDc.getInstance().modifyPool(getMacPool());
    setSucceeded(true);
    getReturnValue().setActionReturnValue(getMacPoolId());
}
#method_after
@Override
protected void executeCommand() {
    getMacPoolDao().update(getMacPoolEntity());
    MacPoolPerDcSingleton.getInstance().modifyPool(getMacPoolEntity());
    setSucceeded(true);
    getReturnValue().setActionReturnValue(getMacPoolId());
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, /* VdcObjectType.MacPool */
    ActionGroup.CONFIGURE_ENGINE));
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, ActionGroup.CONFIGURE_ENGINE));
}
#end_block

#method_before
@Override
public void rollback() {
    super.rollback();
    MacPoolPerDc.getInstance().modifyPool(oldMacPool);
}
#method_after
@Override
public void rollback() {
    super.rollback();
    MacPoolPerDcSingleton.getInstance().modifyPool(oldMacPool);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, // TODO MM: fix?
    VdcObjectType.System, ActionGroup.CONFIGURE_ENGINE));
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, ActionGroup.CONFIGURE_ENGINE));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    final MacPoolValidator validator = new MacPoolValidator(null, getMacPool());
    // TODO MM: improve.
    return validate(validator.defaultPoolFlagIsNotSet()) && validate(validator.hasUniqueName());
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    final MacPoolValidator validator = new MacPoolValidator(getMacPoolEntity());
    return validate(validator.defaultPoolFlagIsNotSet()) && validate(validator.hasUniqueName());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    MacPool macPool = getMacPool();
    macPool.setId(Guid.newGuid());
    setMacPoolNameForLog(macPool.getName());
    setMacPoolIdForLog(macPool.getId());
    getMacPoolDao().save(macPool);
    MacPoolPerDc.getInstance().createPool(macPool);
    setSucceeded(true);
    getReturnValue().setActionReturnValue(macPool.getId());
}
#method_after
@Override
protected void executeCommand() {
    getMacPoolEntity().setId(Guid.newGuid());
    getMacPoolDao().save(getMacPoolEntity());
    MacPoolPerDcSingleton.getInstance().createPool(getMacPoolEntity());
    setSucceeded(true);
    getReturnValue().setActionReturnValue(getMacPoolId());
}
#end_block

#method_before
@Override
public void rollback() {
    super.rollback();
    MacPoolPerDc.getInstance().removePool(getMacPool().getId());
}
#method_after
@Override
public void rollback() {
    super.rollback();
    MacPoolPerDcSingleton.getInstance().removePool(getMacPoolId());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setMacPoolIdForLog(getParameters().getMacPoolId());
    setMacPoolNameForLog(oldMacPool.getName());
    final Guid macPoolId = getParameters().getMacPoolId();
    getMacPoolDao().remove(macPoolId);
    MacPoolPerDc.getInstance().removePool(macPoolId);
    getReturnValue().setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getMacPoolDao().remove(getParameters().getMacPoolId());
    MacPoolPerDcSingleton.getInstance().removePool(getParameters().getMacPoolId());
    getReturnValue().setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    oldMacPool = getMacPoolDao().get(getParameters().getMacPoolId());
    final MacPoolValidator validator = new MacPoolValidator(oldMacPool, null);
    return validate(validator.macPoolExists()) && validate(validator.isNotUsed()) && validate(validator.oldMacPoolIsNotDefault());
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    oldMacPool = getMacPoolDao().get(getParameters().getMacPoolId());
    final MacPoolValidator validator = new MacPoolValidator(oldMacPool);
    return validate(validator.macPoolExists()) && validate(validator.notRemovingUsedPool()) && validate(validator.notRemovingDefaultPool());
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, /* VdcObjectType.MacPool */
    ActionGroup.CONFIGURE_ENGINE));
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, ActionGroup.CONFIGURE_ENGINE));
}
#end_block

#method_before
@Override
public void rollback() {
    super.rollback();
    MacPoolPerDc.getInstance().createPool(oldMacPool);
}
#method_after
@Override
public void rollback() {
    super.rollback();
    MacPoolPerDcSingleton.getInstance().createPool(oldMacPool);
}
#end_block

#method_before
private void updateHostList(boolean isDiscovered) {
    Provider provider = getProviders().getSelectedItem();
    if (provider == null) {
        return;
    }
    if (!isDiscovered) {
        AsyncQuery getHostsQuery = new AsyncQuery();
        getHostsQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                ArrayList<VDS> hosts = (ArrayList<VDS>) result;
                ListModel<VDS> hostNameListModel = getExternalHostName();
                hostNameListModel.setItems(hosts);
                hostNameListModel.setIsChangable(true);
                setEnableSearchHost(true);
                getProviders().setIsChangable(true);
            }
        };
        AsyncDataProvider.getExternalProviderHostList(getHostsQuery, provider.getId(), true, getProviderSearchFilter().getEntity());
    } else {
        AsyncQuery getDiscoveredHostsQuery = new AsyncQuery();
        getDiscoveredHostsQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                ArrayList<ExternalDiscoveredHost> hosts = (ArrayList<ExternalDiscoveredHost>) result;
                ListModel externalDiscoveredHostsListModel = getExternalDiscoveredHosts();
                externalDiscoveredHostsListModel.setItems(hosts);
                externalDiscoveredHostsListModel.setIsChangable(true);
                getProviders().setIsChangable(true);
            }
        };
        AsyncDataProvider.getExternalProviderDiscoveredHostList(getDiscoveredHostsQuery, provider);
        AsyncQuery getHostGroupsQuery = new AsyncQuery();
        getHostGroupsQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                ArrayList<ExternalHostGroup> hostGroups = (ArrayList<ExternalHostGroup>) result;
                ListModel externalHostGroupsListModel = getExternalHostGroups();
                externalHostGroupsListModel.setItems(hostGroups);
                externalHostGroupsListModel.setIsChangable(true);
            }
        };
        AsyncDataProvider.getExternalProviderHostGroupList(getHostGroupsQuery, provider);
        AsyncQuery getComputeResourceQuery = new AsyncQuery();
        getComputeResourceQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                ArrayList<ExternalComputeResource> computeResources = (ArrayList<ExternalComputeResource>) result;
                ListModel externalComputeResourceListModel = getExternalComputeResource();
                externalComputeResourceListModel.setItems(computeResources);
                externalComputeResourceListModel.setIsChangable(true);
            }
        };
        AsyncDataProvider.getExternalProviderComputeResourceList(getComputeResourceQuery, provider);
    }
}
#method_after
private void updateHostList() {
    Provider provider = getProviders().getSelectedItem();
    if (provider == null) {
        return;
    }
    AsyncQuery getHostsQuery = new AsyncQuery();
    getHostsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<VDS> hosts = (ArrayList<VDS>) result;
            ListModel<VDS> hostNameListModel = getExternalHostName();
            hostNameListModel.setItems(hosts);
            hostNameListModel.setIsChangable(true);
            setEnableSearchHost(true);
            getProviders().setIsChangable(true);
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderHostList(getHostsQuery, provider.getId(), true, getProviderSearchFilter().getEntity());
    AsyncQuery getDiscoveredHostsQuery = new AsyncQuery();
    getDiscoveredHostsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<ExternalDiscoveredHost> hosts = (ArrayList<ExternalDiscoveredHost>) result;
            ListModel externalDiscoveredHostsListModel = getExternalDiscoveredHosts();
            externalDiscoveredHostsListModel.setItems(hosts);
            externalDiscoveredHostsListModel.setIsChangable(true);
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderDiscoveredHostList(getDiscoveredHostsQuery, provider);
    AsyncQuery getHostGroupsQuery = new AsyncQuery();
    getHostGroupsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<ExternalHostGroup> hostGroups = (ArrayList<ExternalHostGroup>) result;
            ListModel externalHostGroupsListModel = getExternalHostGroups();
            externalHostGroupsListModel.setItems(hostGroups);
            externalHostGroupsListModel.setIsChangable(true);
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderHostGroupList(getHostGroupsQuery, provider);
    AsyncQuery getComputeResourceQuery = new AsyncQuery();
    getComputeResourceQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<ExternalComputeResource> computeResources = (ArrayList<ExternalComputeResource>) result;
            ListModel externalComputeResourceListModel = getExternalComputeResource();
            externalComputeResourceListModel.setItems(computeResources);
            externalComputeResourceListModel.setIsChangable(true);
        }
    };
    AsyncDataProvider.getInstance().getExternalProviderComputeResourceList(getComputeResourceQuery, provider);
}
#end_block

#method_before
private void updateExternalHostModels() {
    AsyncQuery getProvidersQuery = new AsyncQuery();
    getProvidersQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<Provider> providers = (ArrayList<Provider>) result;
            ListModel<Provider> providersListModel = getProviders();
            providersListModel.setItems(providers);
            providersListModel.setIsChangable(true);
            providersListModel.setSelectedItem(providers.get(0));
            getIsDiscorveredHosts().setEntity(null);
            getIsDiscorveredHosts().setEntity(true);
        }
    };
    AsyncDataProvider.getAllProvidersByType(getProvidersQuery, ProviderType.FOREMAN);
}
#method_after
private void updateExternalHostModels() {
    AsyncQuery getProvidersQuery = new AsyncQuery();
    getProvidersQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ArrayList<Provider> providers = (ArrayList<Provider>) result;
            ListModel<Provider> providersListModel = getProviders();
            providersListModel.setItems(providers);
            providersListModel.setIsChangable(true);
            providersListModel.setSelectedItem(providers.get(0));
            getIsDiscorveredHosts().setEntity(null);
            getIsDiscorveredHosts().setEntity(true);
        }
    };
    AsyncDataProvider.getInstance().getAllProvidersByType(getProvidersQuery, ProviderType.FOREMAN);
}
#end_block

#method_before
public void fetchPublicKey() {
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            String pk = (String) result;
            if (pk != null && pk.length() > 0) {
                getPublicKey().setEntity(pk);
            }
        }
    };
    AsyncDataProvider.getHostPublicKey(aQuery);
}
#method_after
public void fetchPublicKey() {
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            String pk = (String) result;
            if (pk != null && pk.length() > 0) {
                getPublicKey().setEntity(pk);
            }
        }
    };
    AsyncDataProvider.getInstance().getHostPublicKey(aQuery);
}
#end_block

#method_before
private void fetchSSHFingerprint() {
    // Cleaning up fields for initialization
    getFetchSshFingerprint().setEntity(ConstantsManager.getInstance().getConstants().empty());
    getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().empty());
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            String fingerprint = (String) result;
            if (fingerprint != null && fingerprint.length() > 0) {
                getFetchSshFingerprint().setEntity(fingerprint);
                getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().successLoadingFingerprint());
            } else {
                getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().errorLoadingFingerprint());
            }
        }
    };
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    if (!getHost().getIsValid()) {
        getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().fingerprintAddressError() + getHost().getInvalidityReasons().get(0));
    } else {
        getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().loadingFingerprint());
        AsyncDataProvider.getHostFingerprint(aQuery, getHost().getEntity());
    }
}
#method_after
private void fetchSSHFingerprint() {
    // Cleaning up fields for initialization
    getFetchSshFingerprint().setEntity(ConstantsManager.getInstance().getConstants().empty());
    getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().empty());
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            String fingerprint = (String) result;
            if (fingerprint != null && fingerprint.length() > 0) {
                getFetchSshFingerprint().setEntity(fingerprint);
                getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().successLoadingFingerprint());
            } else {
                getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().errorLoadingFingerprint());
            }
        }
    };
    getHost().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(255), new HostAddressValidation() });
    if (!getHost().getIsValid()) {
        getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().fingerprintAddressError() + getHost().getInvalidityReasons().get(0));
    } else {
        getFetchResult().setEntity(ConstantsManager.getInstance().getConstants().loadingFingerprint());
        AsyncDataProvider.getInstance().getHostFingerprint(aQuery, getHost().getEntity());
    }
}
#end_block

#method_before
private void initSpmPriorities() {
    AsyncDataProvider.getMaxSpmPriority(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            HostModel model = (HostModel) target;
            model.maxSpmPriority = (Integer) returnValue;
            initSpmPriorities1();
        }
    }));
}
#method_after
private void initSpmPriorities() {
    AsyncDataProvider.getInstance().getMaxSpmPriority(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            HostModel model = (HostModel) target;
            model.maxSpmPriority = (Integer) returnValue;
            initSpmPriorities1();
        }
    }));
}
#end_block

#method_before
private void initSpmPriorities1() {
    AsyncDataProvider.getDefaultSpmPriority(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            HostModel model = (HostModel) target;
            model.defaultSpmPriority = (Integer) returnValue;
            if (postponedSpmPriority != null) {
                updateSpmPriority(postponedSpmPriority);
            }
            spmInitialized = true;
        }
    }));
}
#method_after
private void initSpmPriorities1() {
    AsyncDataProvider.getInstance().getDefaultSpmPriority(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            HostModel model = (HostModel) target;
            model.defaultSpmPriority = (Integer) returnValue;
            if (postponedSpmPriority != null) {
                updateSpmPriority(postponedSpmPriority);
            }
            spmInitialized = true;
        }
    }));
}
#end_block

#method_before
private void dataCenter_SelectedItemChanged() {
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    if (dataCenter != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                HostModel hostModel = (HostModel) model;
                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) result;
                StoragePool selectedDataCenter = getDataCenter().getSelectedItem();
                // clusters
                if (clusters.isEmpty() || clusters.size() > 0 && clusters.get(0).getStoragePoolId().equals(selectedDataCenter.getId())) {
                    if (hostModel.getIsNew()) {
                        updateClusterList(hostModel, clusters);
                    } else {
                        AsyncQuery architectureQuery = new AsyncQuery();
                        architectureQuery.setModel(new Object[] { hostModel, clusters });
                        architectureQuery.asyncCallback = new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                Object[] objArray = (Object[]) model;
                                HostModel hostModel = (HostModel) objArray[0];
                                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) objArray[1];
                                ArchitectureType architecture = (ArchitectureType) returnValue;
                                ArrayList<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
                                for (VDSGroup cluster : clusters) {
                                    if (architecture == ArchitectureType.undefined || cluster.getArchitecture() == ArchitectureType.undefined || cluster.getArchitecture() == architecture) {
                                        filteredClusters.add(cluster);
                                    }
                                }
                                updateClusterList(hostModel, filteredClusters);
                            }
                        };
                        AsyncDataProvider.getHostArchitecture(architectureQuery, hostModel.getHostId());
                    }
                }
            }
        };
        AsyncDataProvider.getClusterList(_asyncQuery, dataCenter.getId());
    }
}
#method_after
private void dataCenter_SelectedItemChanged() {
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    if (dataCenter != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                HostModel hostModel = (HostModel) model;
                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) result;
                StoragePool selectedDataCenter = getDataCenter().getSelectedItem();
                // clusters
                if (clusters.isEmpty() || clusters.size() > 0 && clusters.get(0).getStoragePoolId().equals(selectedDataCenter.getId())) {
                    if (hostModel.getIsNew()) {
                        updateClusterList(hostModel, clusters);
                    } else {
                        AsyncQuery architectureQuery = new AsyncQuery();
                        architectureQuery.setModel(new Object[] { hostModel, clusters });
                        architectureQuery.asyncCallback = new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                Object[] objArray = (Object[]) model;
                                HostModel hostModel = (HostModel) objArray[0];
                                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) objArray[1];
                                ArchitectureType architecture = (ArchitectureType) returnValue;
                                ArrayList<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
                                for (VDSGroup cluster : clusters) {
                                    if (architecture == ArchitectureType.undefined || cluster.getArchitecture() == ArchitectureType.undefined || cluster.getArchitecture() == architecture) {
                                        filteredClusters.add(cluster);
                                    }
                                }
                                updateClusterList(hostModel, filteredClusters);
                            }
                        };
                        AsyncDataProvider.getInstance().getHostArchitecture(architectureQuery, hostModel.getHostId());
                    }
                }
            }
        };
        AsyncDataProvider.getInstance().getClusterList(_asyncQuery, dataCenter.getId());
    }
}
#end_block

#method_before
private void cluster_SelectedItemChanged() {
    VDSGroup cluster = getCluster().getSelectedItem();
    if (cluster != null) {
        AsyncDataProvider.getPmTypeList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                ArrayList<String> pmTypes = (ArrayList<String>) returnValue;
                updatePmTypeList(pmTypes, getPmType());
                updatePmTypeList(pmTypes, getPmSecondaryType());
            }
        }), cluster.getcompatibility_version());
    }
}
#method_after
private void cluster_SelectedItemChanged() {
    VDSGroup cluster = getCluster().getSelectedItem();
    if (cluster != null) {
        AsyncDataProvider.getInstance().getPmTypeList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                ArrayList<String> pmTypes = (ArrayList<String>) returnValue;
                updatePmTypeList(pmTypes, getPmType());
                updatePmTypeList(pmTypes, getPmSecondaryType());
            }
        }), cluster.getcompatibility_version());
    }
}
#end_block

#method_before
private HashMap<String, String> getPmOptionsMapInternal(EntityModel<String> port, EntityModel<String> slot, EntityModel<Boolean> secure, EntityModel<String> options) {
    HashMap<String, String> dict = new HashMap<String, String>();
    if (getIsPm().getEntity()) {
        // Add well known pm options.
        if (port.getIsAvailable() && port.getEntity() != null) {
            dict.put(PmPortKey, port.getEntity());
        }
        if (slot.getIsAvailable() && slot.getEntity() != null) {
            dict.put(PmSlotKey, slot.getEntity());
        }
        if (secure.getIsAvailable()) {
            dict.put(PmSecureKey, secure.getEntity().toString());
        }
        // Add unknown pm options.
        // Assume Validate method was called before this getter.
        String pmOptions = options.getEntity();
        if (!StringHelper.isNullOrEmpty(pmOptions)) {
            for (// $NON-NLS-1$
            String pair : // $NON-NLS-1$
            pmOptions.split("[,]", -1)) {
                // $NON-NLS-1$
                String[] array = pair.split("[=]", -1);
                if (array.length == 2) {
                    dict.put(array[0], array[1]);
                } else if (array.length == 1) {
                    // $NON-NLS-1$
                    dict.put(array[0], "");
                }
            }
        }
    }
    return dict;
}
#method_after
private HashMap<String, String> getPmOptionsMapInternal(EntityModel<String> port, EntityModel<String> slot, EntityModel<Boolean> secure, EntityModel<String> options) {
    HashMap<String, String> dict = new HashMap<String, String>();
    // Add well known pm options.
    if (port.getIsAvailable() && port.getEntity() != null) {
        dict.put(PmPortKey, port.getEntity());
    }
    if (slot.getIsAvailable() && slot.getEntity() != null) {
        dict.put(PmSlotKey, slot.getEntity());
    }
    if (secure.getIsAvailable()) {
        dict.put(PmSecureKey, secure.getEntity().toString());
    }
    // Add unknown pm options.
    // Assume Validate method was called before this getter.
    String pmOptions = options.getEntity();
    if (!StringHelper.isNullOrEmpty(pmOptions)) {
        for (// $NON-NLS-1$
        String pair : // $NON-NLS-1$
        pmOptions.split("[,]", -1)) {
            // $NON-NLS-1$
            String[] array = pair.split("[=]", -1);
            if (array.length == 2) {
                dict.put(array[0], array[1]);
            } else if (array.length == 1) {
                // $NON-NLS-1$
                dict.put(array[0], "");
            }
        }
    }
    return dict;
}
#end_block

#method_before
private void updatePmModels() {
    boolean isPm = getIsPm().getEntity();
    // $NON-NLS-1$
    final String ciscoUcsValue = "cisco_ucs";
    // Update primary PM fields.
    getManagementIp().setIsChangable(isPm);
    getManagementIp().setIsValid(true);
    getPmUserName().setIsChangable(isPm);
    getPmUserName().setIsValid(true);
    getPmPassword().setIsChangable(isPm);
    getPmPassword().setIsValid(true);
    getPmType().setIsChangable(isPm);
    getPmType().setIsValid(true);
    getPmPort().setIsChangable(isPm);
    getPmPort().setIsValid(true);
    getPmProxyPreferencesList().setIsChangable(getIsPm().getEntity());
    String proxySelectedItem = getPmProxyPreferencesList().getSelectedItem();
    getTestCommand().setIsExecutionAllowed(isPm);
    getProxyUpCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getProxyDownCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getPmSlot().setIsChangable(isPm);
    getPmOptions().setIsChangable(isPm);
    getPmOptions().setIsValid(true);
    getPmSecure().setIsChangable(isPm);
    VDSGroup cluster = getCluster().getSelectedItem();
    String version = AsyncDataProvider.getDefaultConfigurationVersion();
    if (cluster != null) {
        version = cluster.getcompatibility_version().toString();
    }
    String pmType = getPmType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmType)) {
        AsyncDataProvider.getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmType, version);
        setCiscoUcsPrimaryPmTypeSelected(pmType.equals(ciscoUcsValue));
    } else {
        getPmPort().setIsAvailable(false);
        getPmSlot().setIsAvailable(false);
        getPmSecure().setIsAvailable(false);
    }
    // Update secondary PM fields.
    getPmSecondaryIp().setIsChangable(isPm);
    getPmSecondaryIp().setIsValid(true);
    getPmSecondaryUserName().setIsChangable(isPm);
    getPmSecondaryUserName().setIsValid(true);
    getPmSecondaryPassword().setIsChangable(isPm);
    getPmSecondaryPassword().setIsValid(true);
    getPmSecondaryType().setIsChangable(isPm);
    getPmSecondaryType().setIsValid(true);
    getPmSecondaryPort().setIsChangable(isPm);
    getPmSecondaryPort().setIsValid(true);
    getPmSecondarySlot().setIsChangable(isPm);
    getPmSecondaryOptions().setIsChangable(isPm);
    getPmSecondaryOptions().setIsValid(true);
    getPmSecondarySecure().setIsChangable(isPm);
    getDisableAutomaticPowerManagement().setIsValid(true);
    getDisableAutomaticPowerManagement().setIsChangable(isPm);
    String pmSecondaryType = getPmSecondaryType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmSecondaryType)) {
        AsyncDataProvider.getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmSecondaryPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSecondarySlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecondarySecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmSecondaryType, version);
        setCiscoUcsSecondaryPmTypeSelected(pmSecondaryType.equals(ciscoUcsValue));
    } else {
        getPmSecondaryPort().setIsAvailable(false);
        getPmSecondarySlot().setIsAvailable(false);
        getPmSecondarySecure().setIsAvailable(false);
    }
    // Update other PM fields.
    getPmVariants().setIsChangable(isPm);
    getPmSecondaryConcurrent().setIsChangable(isPm);
    getPmKdumpDetection().setIsChangable(isPm);
    getTestCommand().setIsExecutionAllowed(isPm);
}
#method_after
private void updatePmModels() {
    boolean isPm = getIsPm().getEntity();
    // $NON-NLS-1$
    final String ciscoUcsValue = "cisco_ucs";
    // Update primary PM fields.
    getManagementIp().setIsChangable(isPm);
    getManagementIp().setIsValid(true);
    getPmUserName().setIsChangable(isPm);
    getPmUserName().setIsValid(true);
    getPmPassword().setIsChangable(isPm);
    getPmPassword().setIsValid(true);
    getPmType().setIsChangable(isPm);
    getPmType().setIsValid(true);
    getPmPort().setIsChangable(isPm);
    getPmPort().setIsValid(true);
    getPmProxyPreferencesList().setIsChangable(getIsPm().getEntity());
    String proxySelectedItem = getPmProxyPreferencesList().getSelectedItem();
    getTestCommand().setIsExecutionAllowed(isPm);
    getProxyUpCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getProxyDownCommand().setIsExecutionAllowed(isPm && proxySelectedItem != null);
    getPmSlot().setIsChangable(isPm);
    getPmOptions().setIsChangable(isPm);
    getPmOptions().setIsValid(true);
    getPmSecure().setIsChangable(isPm);
    VDSGroup cluster = getCluster().getSelectedItem();
    String version = AsyncDataProvider.getInstance().getDefaultConfigurationVersion();
    if (cluster != null) {
        version = cluster.getcompatibility_version().toString();
    }
    String pmType = getPmType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmType)) {
        AsyncDataProvider.getInstance().getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmType, version);
        setCiscoUcsPrimaryPmTypeSelected(pmType.equals(ciscoUcsValue));
    } else {
        getPmPort().setIsAvailable(false);
        getPmSlot().setIsAvailable(false);
        getPmSecure().setIsAvailable(false);
    }
    // Update secondary PM fields.
    getPmSecondaryIp().setIsChangable(isPm);
    getPmSecondaryIp().setIsValid(true);
    getPmSecondaryUserName().setIsChangable(isPm);
    getPmSecondaryUserName().setIsValid(true);
    getPmSecondaryPassword().setIsChangable(isPm);
    getPmSecondaryPassword().setIsValid(true);
    getPmSecondaryType().setIsChangable(isPm);
    getPmSecondaryType().setIsValid(true);
    getPmSecondaryPort().setIsChangable(isPm);
    getPmSecondaryPort().setIsValid(true);
    getPmSecondarySlot().setIsChangable(isPm);
    getPmSecondaryOptions().setIsChangable(isPm);
    getPmSecondaryOptions().setIsValid(true);
    getPmSecondarySecure().setIsChangable(isPm);
    getDisableAutomaticPowerManagement().setIsValid(true);
    getDisableAutomaticPowerManagement().setIsChangable(isPm);
    String pmSecondaryType = getPmSecondaryType().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(pmSecondaryType)) {
        AsyncDataProvider.getInstance().getPmOptions(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<String> pmOptions = (ArrayList<String>) returnValue;
                if (pmOptions != null) {
                    getPmSecondaryPort().setIsAvailable(pmOptions.contains(PmPortKey));
                    getPmSecondarySlot().setIsAvailable(pmOptions.contains(PmSlotKey));
                    getPmSecondarySecure().setIsAvailable(pmOptions.contains(PmSecureKey));
                }
            }
        }), pmSecondaryType, version);
        setCiscoUcsSecondaryPmTypeSelected(pmSecondaryType.equals(ciscoUcsValue));
    } else {
        getPmSecondaryPort().setIsAvailable(false);
        getPmSecondarySlot().setIsAvailable(false);
        getPmSecondarySecure().setIsAvailable(false);
    }
    // Update other PM fields.
    getPmVariants().setIsChangable(isPm);
    getPmSecondaryConcurrent().setIsChangable(isPm);
    getPmKdumpDetection().setIsChangable(isPm);
    getTestCommand().setIsExecutionAllowed(isPm);
}
#end_block

#method_before
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    getProtocol().setIsAvailable(showTransportProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.pmOptionsStringToMap(vds.getPmOptions()));
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#method_after
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    getProtocol().setEntity(VdsProtocol.STOMP == vds.getProtocol());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    if (!showInstallationProperties()) {
        getPkSection().setIsChangable(false);
        getPkSection().setIsAvailable(false);
        // Use public key when edit or approve host
        setAuthenticationMethod(AuthenticationMethod.PublicKey);
    }
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.pmOptionsStringToMap(vds.getPmOptions()));
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    getDisableAutomaticPowerManagement().setEntity(vds.isDisablePowerManagementPolicy());
    getPmKdumpDetection().setEntity(vds.isPmKdumpDetection());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval && vds.getStatus() != VDSStatus.InstallingOS) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
@Override
public StoragePool mapRow(ResultSet rs, int rowNum) throws SQLException {
    StoragePool entity = new StoragePool();
    entity.setdescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setName(rs.getString("name"));
    entity.setIsLocal(rs.getBoolean("is_local"));
    entity.setStatus(StoragePoolStatus.forValue(rs.getInt("status")));
    entity.setmaster_domain_version(rs.getInt("master_domain_version"));
    entity.setspm_vds_id(getGuid(rs, "spm_vds_id"));
    entity.setcompatibility_version(new Version(rs.getString("compatibility_version")));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setStoragePoolFormatType(getStorageFormatTypeForPool(rs));
    try {
        entity.setMacPoolRanges(rs.getString("mac_pool_ranges"));
    } catch (SQLException e) {
    // that columns not there.
    }
    return entity;
}
#method_after
@Override
public StoragePool mapRow(ResultSet rs, int rowNum) throws SQLException {
    StoragePool entity = new StoragePool();
    entity.setdescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setName(rs.getString("name"));
    entity.setIsLocal(rs.getBoolean("is_local"));
    entity.setStatus(StoragePoolStatus.forValue(rs.getInt("status")));
    entity.setmaster_domain_version(rs.getInt("master_domain_version"));
    entity.setspm_vds_id(getGuid(rs, "spm_vds_id"));
    entity.setcompatibility_version(new Version(rs.getString("compatibility_version")));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setStoragePoolFormatType(StorageFormatType.forValue(rs.getString("storage_pool_format_type")));
    entity.setMacPoolId(getGuid(rs, "mac_pool_id"));
    return entity;
}
#end_block

#method_before
@Override
public void save(StoragePool pool) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", pool.getdescription()).addValue("free_text_comment", pool.getComment()).addValue("id", pool.getId()).addValue("name", pool.getName()).addValue("is_local", pool.isLocal()).addValue("status", pool.getStatus()).addValue("master_domain_version", pool.getmaster_domain_version()).addValue("spm_vds_id", pool.getspm_vds_id()).addValue("quota_enforcement_type", pool.getQuotaEnforcementType()).addValue("compatibility_version", pool.getcompatibility_version()).addValue("mac_pool_ranges", pool.getMacPoolRanges());
    getCallsHandler().executeModification("Insertstorage_pool", parameterSource);
}
#method_after
@Override
public void save(StoragePool pool) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", pool.getdescription()).addValue("free_text_comment", pool.getComment()).addValue("id", pool.getId()).addValue("name", pool.getName()).addValue("is_local", pool.isLocal()).addValue("status", pool.getStatus()).addValue("master_domain_version", pool.getmaster_domain_version()).addValue("spm_vds_id", pool.getspm_vds_id()).addValue("quota_enforcement_type", pool.getQuotaEnforcementType()).addValue("compatibility_version", pool.getcompatibility_version()).addValue("mac_pool_id", pool.getMacPoolId());
    getCallsHandler().executeModification("Insertstorage_pool", parameterSource);
}
#end_block

#method_before
@Override
public void update(StoragePool pool) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", pool.getdescription()).addValue("free_text_comment", pool.getComment()).addValue("id", pool.getId()).addValue("name", pool.getName()).addValue("status", pool.getStatus()).addValue("is_local", pool.isLocal()).addValue("storage_pool_format_type", pool.getStoragePoolFormatType()).addValue("master_domain_version", pool.getmaster_domain_version()).addValue("spm_vds_id", pool.getspm_vds_id()).addValue("compatibility_version", pool.getcompatibility_version()).addValue("quota_enforcement_type", pool.getQuotaEnforcementType().getValue()).addValue("mac_pool_ranges", pool.getMacPoolRanges());
    getCallsHandler().executeModification("Updatestorage_pool", parameterSource);
}
#method_after
@Override
public void update(StoragePool pool) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", pool.getdescription()).addValue("free_text_comment", pool.getComment()).addValue("id", pool.getId()).addValue("name", pool.getName()).addValue("status", pool.getStatus()).addValue("is_local", pool.isLocal()).addValue("storage_pool_format_type", pool.getStoragePoolFormatType()).addValue("master_domain_version", pool.getmaster_domain_version()).addValue("spm_vds_id", pool.getspm_vds_id()).addValue("compatibility_version", pool.getcompatibility_version()).addValue("quota_enforcement_type", pool.getQuotaEnforcementType().getValue()).addValue("mac_pool_id", pool.getMacPoolId());
    getCallsHandler().executeModification("Updatestorage_pool", parameterSource);
}
#end_block

#method_before
@Override
public void updatePartial(StoragePool pool) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", pool.getdescription()).addValue("free_text_comment", pool.getComment()).addValue("id", pool.getId()).addValue("name", pool.getName()).addValue("is_local", pool.isLocal()).addValue("storage_pool_format_type", pool.getStoragePoolFormatType()).addValue("compatibility_version", pool.getcompatibility_version()).addValue("quota_enforcement_type", pool.getQuotaEnforcementType().getValue()).addValue("mac_pool_ranges", pool.getMacPoolRanges());
    getCallsHandler().executeModification("Updatestorage_pool_partial", parameterSource);
}
#method_after
@Override
public void updatePartial(StoragePool pool) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", pool.getdescription()).addValue("free_text_comment", pool.getComment()).addValue("id", pool.getId()).addValue("name", pool.getName()).addValue("is_local", pool.isLocal()).addValue("storage_pool_format_type", pool.getStoragePoolFormatType()).addValue("compatibility_version", pool.getcompatibility_version()).addValue("quota_enforcement_type", pool.getQuotaEnforcementType().getValue()).addValue("mac_pool_id", pool.getMacPoolId());
    getCallsHandler().executeModification("Updatestorage_pool_partial", parameterSource);
}
#end_block

#method_before
@Override
public String getComment() {
    if (comment == null) {
        comment = "";
    }
    return comment;
}
#method_after
@Override
public String getComment() {
    return comment;
}
#end_block

#method_before
@Override
public void setComment(String value) {
    this.comment = value;
}
#method_after
@Override
public void setComment(String value) {
    this.comment = (value == null) ? "" : value;
}
#end_block

#method_before
@Override
public Guid getId() {
    return this.id;
}
#method_after
@Override
public Guid getId() {
    return id;
}
#end_block

#method_before
@Override
public String getName() {
    return this.name;
}
#method_after
@Override
public String getName() {
    return name;
}
#end_block

#method_before
public int getmaster_domain_version() {
    return this.masterDomainVersion;
}
#method_after
public int getmaster_domain_version() {
    return masterDomainVersion;
}
#end_block

#method_before
@Override
public void initTable(final CommonApplicationConstants constants) {
    getTable().enableColumnResizing();
    NicActivateStatusColumn<VmNetworkInterface> statusColumn = new NicActivateStatusColumn<VmNetworkInterface>();
    statusColumn.makeSortable(VmNetworkInterfaceComparator.BY_PLUGGED_AND_LINKED);
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.empty(), "30px");
    TextColumnWithTooltip<VmNetworkInterface> nameColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(VmNetworkInterfaceComparator.BY_NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameInterface(), "150px");
    CheckboxColumn<VmNetworkInterface> pluggedColumn = new CheckboxColumn<VmNetworkInterface>() {

        @Override
        public Boolean getValue(VmNetworkInterface object) {
            return object.isPlugged();
        }

        @Override
        protected boolean canEdit(VmNetworkInterface object) {
            return false;
        }
    };
    pluggedColumn.makeSortable(VmNetworkInterfaceComparator.BY_PLUGGED);
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(pluggedColumn, constants.plugged(), "60px");
    TextColumnWithTooltip<VmNetworkInterface> networkNameColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getNetworkName();
        }
    };
    networkNameColumn.makeSortable(VmNetworkInterfaceComparator.BY_NETWORK_NAME);
    // $NON-NLS-1$
    getTable().addColumn(networkNameColumn, constants.networkNameInterface(), "150px");
    TextColumnWithTooltip<VmNetworkInterface> profileNameColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getVnicProfileName();
        }
    };
    profileNameColumn.makeSortable(VmNetworkInterfaceComparator.BY_PROFILE_NAME);
    // $NON-NLS-1$
    getTable().addColumn(profileNameColumn, constants.profileNameInterface(), "150px");
    BooleanColumn<VmNetworkInterface> linkStateColumn = new BooleanColumn<VmNetworkInterface>(constants.linkedNetworkInterface(), constants.unlinkedNetworkInterface()) {

        @Override
        protected Boolean getRawValue(VmNetworkInterface object) {
            return object.isLinked();
        }
    };
    linkStateColumn.makeSortable(VmNetworkInterfaceComparator.BY_LINK_STATE);
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(linkStateColumn, constants.linkStateNetworkInterface(), "65px");
    TextColumnWithTooltip<VmNetworkInterface> typeColumn = new EnumColumn<VmNetworkInterface, VmInterfaceType>() {

        @Override
        protected VmInterfaceType getRawValue(VmNetworkInterface object) {
            return VmInterfaceType.forValue(object.getType());
        }
    };
    typeColumn.makeSortable(VmNetworkInterfaceComparator.BY_TYPE);
    // $NON-NLS-1$
    getTable().addColumn(typeColumn, constants.typeInterface(), "100px");
    TextColumnWithTooltip<VmNetworkInterface> macColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getMacAddress();
        }
    };
    macColumn.makeSortable(VmNetworkInterfaceComparator.BY_MAC_ADDRESS);
    // $NON-NLS-1$
    getTable().addColumn(macColumn, constants.macInterface(), "150px");
    TextColumnWithTooltip<VmNetworkInterface> speedColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().toString();
            } else {
                return null;
            }
        }
    };
    speedColumn.makeSortable(VmNetworkInterfaceComparator.BY_SPEED);
    getTable().addColumnWithHtmlHeader(speedColumn, templates.sub(constants.speedInterface(), constants.mbps()).asString(), // $NON-NLS-1$
    "150px");
    getTable().addActionButton(new UiCommandButtonDefinition<VmNetworkInterface>(getEventBus(), constants.newInterface()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getNewCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<VmNetworkInterface>(getEventBus(), constants.editInterface()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getEditCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<VmNetworkInterface>(getEventBus(), constants.removeInterface()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRemoveCommand();
        }
    });
    // Add selection listener
    getModel().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateInfoPanel();
        }
    });
    getModel().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateInfoPanel();
        }
    });
}
#method_after
@Override
public void initTable(final CommonApplicationConstants constants) {
    getTable().enableColumnResizing();
    NicActivateStatusColumn<VmNetworkInterface> statusColumn = new NicActivateStatusColumn<VmNetworkInterface>();
    statusColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.empty(), "30px");
    TextColumnWithTooltip<VmNetworkInterface> nameColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameInterface(), "150px");
    CheckboxColumn<VmNetworkInterface> pluggedColumn = new CheckboxColumn<VmNetworkInterface>() {

        @Override
        public Boolean getValue(VmNetworkInterface object) {
            return object.isPlugged();
        }

        @Override
        protected boolean canEdit(VmNetworkInterface object) {
            return false;
        }
    };
    pluggedColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(pluggedColumn, constants.plugged(), "60px");
    TextColumnWithTooltip<VmNetworkInterface> networkNameColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getNetworkName();
        }
    };
    networkNameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(networkNameColumn, constants.networkNameInterface(), "150px");
    TextColumnWithTooltip<VmNetworkInterface> profileNameColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getVnicProfileName();
        }
    };
    profileNameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(profileNameColumn, constants.profileNameInterface(), "150px");
    BooleanColumn<VmNetworkInterface> linkStateColumn = new BooleanColumn<VmNetworkInterface>(constants.linkedNetworkInterface(), constants.unlinkedNetworkInterface()) {

        @Override
        protected Boolean getRawValue(VmNetworkInterface object) {
            return object.isLinked();
        }
    };
    linkStateColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(linkStateColumn, constants.linkStateNetworkInterface(), "65px");
    TextColumnWithTooltip<VmNetworkInterface> typeColumn = new EnumColumn<VmNetworkInterface, VmInterfaceType>() {

        @Override
        protected VmInterfaceType getRawValue(VmNetworkInterface object) {
            return VmInterfaceType.forValue(object.getType());
        }
    };
    typeColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(typeColumn, constants.typeInterface(), "100px");
    TextColumnWithTooltip<VmNetworkInterface> macColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            return object.getMacAddress();
        }
    };
    macColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(macColumn, constants.macInterface(), "150px");
    TextColumnWithTooltip<VmNetworkInterface> speedColumn = new TextColumnWithTooltip<VmNetworkInterface>() {

        @Override
        public String getValue(VmNetworkInterface object) {
            if (object.getSpeed() != null) {
                return object.getSpeed().toString();
            } else {
                return null;
            }
        }
    };
    speedColumn.makeSortable();
    getTable().addColumnWithHtmlHeader(speedColumn, templates.sub(constants.speedInterface(), constants.mbps()).asString(), // $NON-NLS-1$
    "150px");
    getTable().addActionButton(new UiCommandButtonDefinition<VmNetworkInterface>(getEventBus(), constants.newInterface()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getNewCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<VmNetworkInterface>(getEventBus(), constants.editInterface()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getEditCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<VmNetworkInterface>(getEventBus(), constants.removeInterface()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRemoveCommand();
        }
    });
    // Add selection listener
    getModel().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateInfoPanel();
        }
    });
    getModel().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateInfoPanel();
        }
    });
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.api.model.MacPool.class, to = MacPool.class)
public static MacPool map(org.ovirt.engine.api.model.MacPool model, MacPool template) {
    if (model == null) {
        return template;
    }
    MacPool entity = template == null ? new MacPool() : template;
    entity.setId(GuidUtils.asGuidNullable(model.getId()));
    entity.setName(model.getName());
    entity.setShared(model.isShared());
    entity.setAllowDuplicateMacAddresses(model.isAllowDuplicates());
    entity.setComment(model.getComment());
    entity.setDefaultPool(model.isSetDefaultPool() && model.isDefaultPool());
    entity.setShared(model.isSetShared() ? model.isShared() : false);
    mapRanges(model, entity);
    return entity;
}
#method_after
@Mapping(from = org.ovirt.engine.api.model.MacPool.class, to = MacPool.class)
public static MacPool map(org.ovirt.engine.api.model.MacPool model, MacPool template) {
    if (model == null) {
        return template;
    }
    MacPool entity = template == null ? new MacPool() : template;
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetAllowDuplicates()) {
        entity.setAllowDuplicateMacAddresses(model.isAllowDuplicates());
    }
    if (model.isSetDefaultPool()) {
        entity.setDefaultPool(model.isDefaultPool());
    }
    if (model.isSetRanges()) {
        mapRanges(model, entity);
    }
    return entity;
}
#end_block

#method_before
private static void mapRanges(org.ovirt.engine.api.model.MacPool model, MacPool entity) {
    final List<MacRange> rangesList = new ArrayList<MacRange>();
    for (org.ovirt.engine.api.model.MacPool.Ranges.Range range : model.getRanges().getRange()) {
        rangesList.add(mapRange(range));
    }
    entity.setRanges(rangesList);
}
#method_after
private static void mapRanges(org.ovirt.engine.api.model.MacPool model, MacPool entity) {
    final List<MacRange> ranges = new ArrayList<>();
    for (org.ovirt.engine.api.model.Range range : model.getRanges().getRanges()) {
        ranges.add(mapRange(range));
    }
    entity.setRanges(ranges);
}
#end_block

#method_before
private static org.ovirt.engine.api.model.MacPool.Ranges.Range mapRange(MacRange range) {
    final org.ovirt.engine.api.model.MacPool.Ranges.Range model = new org.ovirt.engine.api.model.MacPool.Ranges.Range();
    model.setFrom(range.getMacFrom());
    model.setTo(range.getMacTo());
    model.setComment(range.getComment());
    return model;
}
#method_after
private static MacRange mapRange(org.ovirt.engine.api.model.Range range) {
    final MacRange result = new MacRange();
    result.setMacFrom(range.getFrom());
    result.setMacTo(range.getTo());
    return result;
}
#end_block

#method_before
@Mapping(from = MacPool.class, to = org.ovirt.engine.api.model.MacPool.class)
public static org.ovirt.engine.api.model.MacPool map(MacPool entity, org.ovirt.engine.api.model.MacPool template) {
    if (entity == null) {
        return template;
    }
    org.ovirt.engine.api.model.MacPool model = template == null ? new org.ovirt.engine.api.model.MacPool() : template;
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setShared(entity.isShared());
    model.setAllowDuplicates(entity.isAllowDuplicateMacAddresses());
    model.setComment(entity.getComment());
    model.setDefaultPool(entity.isDefaultPool());
    mapRanges(entity, model);
    return model;
}
#method_after
@Mapping(from = MacPool.class, to = org.ovirt.engine.api.model.MacPool.class)
public static org.ovirt.engine.api.model.MacPool map(MacPool entity, org.ovirt.engine.api.model.MacPool template) {
    if (entity == null) {
        return template;
    }
    org.ovirt.engine.api.model.MacPool model = template == null ? new org.ovirt.engine.api.model.MacPool() : template;
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setAllowDuplicates(entity.isAllowDuplicateMacAddresses());
    model.setDescription(entity.getDescription());
    model.setDefaultPool(entity.isDefaultPool());
    mapRanges(entity, model);
    return model;
}
#end_block

#method_before
protected static void mapRanges(MacPool entity, org.ovirt.engine.api.model.MacPool result) {
    final org.ovirt.engine.api.model.MacPool.Ranges ranges = new org.ovirt.engine.api.model.MacPool.Ranges();
    for (MacRange macRange : entity.getRanges()) {
        ranges.getRange().add(mapRange(macRange));
    }
    result.setRanges(ranges);
}
#method_after
private static void mapRanges(MacPool entity, org.ovirt.engine.api.model.MacPool result) {
    if (entity.getRanges() != null) {
        final Ranges ranges = new Ranges();
        for (MacRange macRange : entity.getRanges()) {
            ranges.getRanges().add(mapRange(macRange));
        }
        result.setRanges(ranges);
    }
}
#end_block

#method_before
private static org.ovirt.engine.api.model.MacPool.Ranges.Range mapRange(MacRange range) {
    final org.ovirt.engine.api.model.MacPool.Ranges.Range model = new org.ovirt.engine.api.model.MacPool.Ranges.Range();
    model.setFrom(range.getMacFrom());
    model.setTo(range.getMacTo());
    model.setComment(range.getComment());
    return model;
}
#method_after
private static Range mapRange(MacRange range) {
    final Range model = new Range();
    model.setFrom(range.getMacFrom());
    model.setTo(range.getMacTo());
    return model;
}
#end_block

#method_before
@Override
protected Response performRemove(String id) {
    return performAction(VdcActionType.RemoveMacPool, new IdParameters(asGuid(id)));
}
#method_after
@Override
protected Response performRemove(String id) {
    return performAction(VdcActionType.RemoveMacPool, new RemoveMacPoolByIdParameters(asGuid(id)));
}
#end_block

#method_before
@Override
public MacPools list() {
    return mapCollection(getBackendCollection(SearchType.MacPool));
}
#method_after
@Override
public MacPools list() {
    return mapCollection(getBackendCollection(VdcQueryType.GetAllMacPools, new VdcQueryParametersBase()));
}
#end_block

#method_before
@Override
public Response add(MacPool macPool) {
    final org.ovirt.engine.core.common.businessentities.MacPool entity = map(macPool);
    return performCreate(VdcActionType.AddMacPool, new MacPoolParameter(entity), new QueryIdResolver<Guid>(VdcQueryType.GetMacPoolById, IdQueryParameters.class));
}
#method_after
@Override
public Response add(MacPool macPool) {
    validateParameters(macPool, "name");
    final org.ovirt.engine.core.common.businessentities.MacPool entity = map(macPool);
    return performCreate(VdcActionType.AddMacPool, new MacPoolParameters(entity), new QueryIdResolver<Guid>(VdcQueryType.GetMacPoolById, IdQueryParameters.class));
}
#end_block

#method_before
@Override
public MacPoolResource getMacPoolSubResource(String id) {
    return inject(new BackendMacPoolResource(id));
}
#method_after
@SingleEntityResource
@Override
public MacPoolResource getMacPoolSubResource(String id) {
    return inject(new BackendMacPoolResource(id));
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(MacPool model, org.ovirt.engine.core.common.businessentities.MacPool entity) {
    final org.ovirt.engine.core.common.businessentities.MacPool macPool = map(model, entity);
    macPool.setId(guid);
    return new MacPoolParameter(macPool);
}
#method_after
@Override
public VdcActionParametersBase getParameters(MacPool model, org.ovirt.engine.core.common.businessentities.MacPool entity) {
    final org.ovirt.engine.core.common.businessentities.MacPool macPool = map(model, entity);
    return new MacPoolParameters(macPool);
}
#end_block

#method_before
public static Collection<DetailedLink> getLinks(String baseUri) {
    Collection<DetailedLink> links = new LinkedList<DetailedLink>();
    links.add(createLink("capabilities", baseUri));
    links.add(createLink("clusters", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("datacenters", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("macpools", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("events", LinkFlags.SEARCHABLE, getEventParams(), baseUri));
    links.add(createLink("hosts", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("networks", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("roles", baseUri));
    links.add(createLink("storagedomains", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("tags", baseUri));
    links.add(createLink("bookmarks", baseUri));
    links.add(createLink("templates", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("instancetypes", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("users", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("groups", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("domains", baseUri));
    links.add(createLink("vmpools", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("vms", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("disks", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("jobs", baseUri));
    links.add(createLink("storageconnections", baseUri));
    links.add(createLink("vnicprofiles", baseUri));
    links.add(createLink("schedulingpolicyunits", baseUri));
    links.add(createLink("schedulingpolicies", baseUri));
    links.add(createLink("permissions", baseUri));
    return links;
}
#method_after
public static Collection<DetailedLink> getLinks(String baseUri) {
    Collection<DetailedLink> links = new LinkedList<DetailedLink>();
    links.add(createLink("capabilities", baseUri));
    links.add(createLink("clusters", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("datacenters", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("events", LinkFlags.SEARCHABLE, getEventParams(), baseUri));
    links.add(createLink("hosts", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("networks", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("roles", baseUri));
    links.add(createLink("storagedomains", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("tags", baseUri));
    links.add(createLink("bookmarks", baseUri));
    links.add(createLink("templates", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("instancetypes", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("users", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("groups", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("domains", baseUri));
    links.add(createLink("vmpools", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("vms", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("disks", LinkFlags.SEARCHABLE, baseUri));
    links.add(createLink("jobs", baseUri));
    links.add(createLink("storageconnections", baseUri));
    links.add(createLink("vnicprofiles", baseUri));
    links.add(createLink("schedulingpolicyunits", baseUri));
    links.add(createLink("schedulingpolicies", baseUri));
    links.add(createLink("permissions", baseUri));
    links.add(createLink("macpools", baseUri));
    return links;
}
#end_block

#method_before
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
        createInfo.put(VdsProperties.max_number_of_sockets, Config.<Integer>getValue(ConfigValues.MaxNumOfVmSockets).toString());
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getVdsGroupCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, String.valueOf(Config.<Integer>getValue(ConfigValues.MaxNumOfVmCpus, vm.getVdsGroupCompatibilityVersion().getValue())));
        }
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    createInfo.put(VdsProperties.emulatedMachine, getVdsGroup().getEmulatedMachine());
    // enabled.
    if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
        createInfo.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
        createInfo.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getVdsGroupCpuFlagsData() != null) {
        createInfo.put(VdsProperties.cpuType, vm.getVdsGroupCpuFlagsData());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
    if (keyboardLayout == null) {
        keyboardLayout = vm.getDefaultVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
        }
    }
    createInfo.put(VdsProperties.KeyboardLayout, keyboardLayout);
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getDisplayType() == DisplayType.vnc) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    addNumaSetting(compatibilityVersion);
    if (vm.getDisplayType() == DisplayType.qxl) {
        createInfo.put(VdsProperties.spiceFileTransferEnable, Boolean.toString(vm.isSpiceFileTransferEnabled()));
        createInfo.put(VdsProperties.spiceCopyPasteEnable, Boolean.toString(vm.isSpiceCopyPasteEnabled()));
    }
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getVdsGroupCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
}
#method_after
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
        createInfo.put(VdsProperties.max_number_of_sockets, Config.<Integer>getValue(ConfigValues.MaxNumOfVmSockets, vm.getVdsGroupCompatibilityVersion().getValue()).toString());
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getVdsGroupCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, Config.<Integer>getValue(ConfigValues.MaxNumOfVmCpus, vm.getVdsGroupCompatibilityVersion().getValue()).toString());
        }
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    createInfo.put(VdsProperties.emulatedMachine, getVdsGroup().getEmulatedMachine());
    // enabled.
    if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
        createInfo.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
        createInfo.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getVdsGroupCpuFlagsData() != null) {
        createInfo.put(VdsProperties.cpuType, vm.getVdsGroupCpuFlagsData());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
    if (keyboardLayout == null) {
        keyboardLayout = vm.getDefaultVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
        }
    }
    createInfo.put(VdsProperties.KeyboardLayout, keyboardLayout);
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getDisplayType() == DisplayType.vnc) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    addNumaSetting(compatibilityVersion);
    if (vm.getDisplayType() == DisplayType.qxl) {
        createInfo.put(VdsProperties.spiceFileTransferEnable, Boolean.toString(vm.isSpiceFileTransferEnabled()));
        createInfo.put(VdsProperties.spiceCopyPasteEnable, Boolean.toString(vm.isSpiceCopyPasteEnabled()));
    }
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getVdsGroupCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    final Guid id = getParameters().getId();
    final MacPool macPool = getDbFacade().getMacPoolDao().get(id);
    getQueryReturnValue().setReturnValue(macPool);
}
#method_after
@Override
protected void executeQueryCommand() {
    final MacPool macPool = getDbFacade().getMacPoolDao().get(getParameters().getId());
    getQueryReturnValue().setReturnValue(macPool);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final Guid macPoolId = getParameters().getId();
    deletedMacPool = macPoolDao.get(getParameters().getId());
    macPoolDao.remove(macPoolId);
    MacPoolPerDC.getInstance().removePool(macPoolId);
    getReturnValue().setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getMacPoolDao().remove(getParameters().getMacPoolId());
    MacPoolPerDcSingleton.getInstance().removePool(getParameters().getMacPoolId());
    getReturnValue().setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    final boolean wrongInput = getParameters() == null || getParameters().getId() == null || getParameters().getId().equals(Guid.Empty);
    if (!super.canDoAction() || wrongInput) {
        return false;
    }
    final MacPoolDAO macPoolDao = getDbFacade().getMacPoolDao();
    final Guid macPoolId = getParameters().getId();
    final MacPool macPool = macPoolDao.get(macPoolId);
    final int dcUsageCount = macPoolDao.getDCUsageCount(macPoolId);
    if (macPool == null) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_DOES_NOT_EXIST);
        return false;
    }
    final boolean canBeRemoved = macPool.canBeRemoved() && dcUsageCount == 0;
    if (!canBeRemoved) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_CANNOT_BE_REMOVED);
        return false;
    } else {
        return true;
    }
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    oldMacPool = getMacPoolDao().get(getParameters().getMacPoolId());
    final MacPoolValidator validator = new MacPoolValidator(oldMacPool);
    return validate(validator.macPoolExists()) && validate(validator.notRemovingUsedPool()) && validate(validator.notRemovingDefaultPool());
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, /*VdcObjectType.MacPool*/
    getActionType().getActionGroup()));
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, ActionGroup.CONFIGURE_ENGINE));
}
#end_block

#method_before
@Override
public void rollback() {
    super.rollback();
    MacPoolPerDC.getInstance().createPool(deletedMacPool);
}
#method_after
@Override
public void rollback() {
    super.rollback();
    MacPoolPerDcSingleton.getInstance().createPool(oldMacPool);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, // TODO MM: fix?
    VdcObjectType.System, getActionType().getActionGroup()));
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, ActionGroup.CONFIGURE_ENGINE));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    final boolean wrongInput = getParameters() == null || getParameters().getMacPool() == null;
    if (!super.canDoAction() || wrongInput) {
        return false;
    }
    final MacPool macPool = getMacPool();
    if (macPool.isDefaultPool()) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_CANNOT_SET_DEFAULT_POOL_THIS_WAY);
        return false;
    }
    if (StringUtils.isEmpty(macPool.getName())) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_MUST_HAVE_NAME);
        return false;
    }
    if (macPool.getRanges() == null || macPool.getRanges().isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_MUST_HAVE_RANGE);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    final MacPoolValidator validator = new MacPoolValidator(getMacPoolEntity());
    return validate(validator.defaultPoolFlagIsNotSet()) && validate(validator.hasUniqueName());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    this.macPoolDao = getDbFacade().getMacPoolDao();
    MacPool macPool = getMacPool();
    macPoolDao.save(macPool);
    MacPoolPerDC.getInstance().createPool(macPool);
    setSucceeded(true);
    getReturnValue().setActionReturnValue(macPool.getId());
}
#method_after
@Override
protected void executeCommand() {
    getMacPoolEntity().setId(Guid.newGuid());
    getMacPoolDao().save(getMacPoolEntity());
    MacPoolPerDcSingleton.getInstance().createPool(getMacPoolEntity());
    setSucceeded(true);
    getReturnValue().setActionReturnValue(getMacPoolEntity().getId());
}
#end_block

#method_before
@Override
public void rollback() {
    super.rollback();
    MacPoolPerDC.getInstance().removePool(getMacPool().getId());
}
#method_after
@Override
public void rollback() {
    super.rollback();
    MacPoolPerDcSingleton.getInstance().removePool(getMacPoolEntity().getId());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    final boolean wrongInput = getParameters() == null || getMacPool() == null || getMacPoolId() == null;
    if (!super.canDoAction() || wrongInput) {
        return false;
    }
    final MacPool macPool = getParameters().getMacPool();
    if (StringUtils.isEmpty(macPool.getName())) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_MUST_HAVE_NAME);
        return false;
    }
    if (macPool.getRanges() == null || macPool.getRanges().isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_MUST_HAVE_RANGE);
        return false;
    }
    oldMacPool = macPoolDao.get(getMacPoolId());
    if (oldMacPool == null) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_DOES_NOT_EXIST);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    oldMacPool = getMacPoolDao().get(getMacPoolId());
    return validate(new MacPoolValidator(oldMacPool).macPoolExists()) && validate(new MacPoolValidator(getMacPoolEntity()).hasUniqueName()) && validate(validateDefaultFlagIsNotChanged(oldMacPool, getMacPoolEntity()));
}
#end_block

#method_before
private Guid getMacPoolId() {
    return getMacPool().getId();
}
#method_after
private Guid getMacPoolId() {
    return getMacPoolEntity().getId();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    macPoolDao.update(getMacPool());
    MacPoolPerDC.getInstance().modifyPool(getMacPool());
    setSucceeded(true);
    getReturnValue().setActionReturnValue(getMacPoolId());
}
#method_after
@Override
protected void executeCommand() {
    getMacPoolDao().update(getMacPoolEntity());
    MacPoolPerDcSingleton.getInstance().modifyPool(getMacPoolEntity());
    setSucceeded(true);
    getReturnValue().setActionReturnValue(getMacPoolId());
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, /*VdcObjectType.MacPool*/
    getActionType().getActionGroup()));
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return Collections.singletonList(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, ActionGroup.CONFIGURE_ENGINE));
}
#end_block

#method_before
@Override
public void rollback() {
    super.rollback();
    MacPoolPerDC.getInstance().modifyPool(oldMacPool);
}
#method_after
@Override
public void rollback() {
    super.rollback();
    MacPoolPerDcSingleton.getInstance().modifyPool(oldMacPool);
}
#end_block

#method_before
public void add(final VmNic iface, CompensationContext compensationContext, boolean reserveExistingMac, int osId, Version clusterCompatibilityVersion) {
    if (reserveExistingMac) {
        final MacPoolManagerStrategy macPoolManager = getMacPoolManager(iface.getVmId());
        final String ifaceMacAddress = iface.getMacAddress();
        if (FeatureSupported.hotPlug(clusterCompatibilityVersion) && getOsRepository().hasNicHotplugSupport(osId, clusterCompatibilityVersion)) {
            macPoolManager.forceAddMac(ifaceMacAddress);
        } else if (!macPoolManager.addMac(ifaceMacAddress)) {
            auditLogMacInUse(iface);
            throw new VdcBLLException(VdcBllErrors.MAC_ADDRESS_IS_IN_USE);
        }
    }
    getVmNicDao().save(iface);
    getVmNetworkStatisticsDao().save(iface.getStatistics());
    compensationContext.snapshotNewEntity(iface);
    compensationContext.snapshotNewEntity(iface.getStatistics());
}
#method_after
public void add(final VmNic iface, CompensationContext compensationContext, boolean reserveExistingMac, int osId, Version clusterCompatibilityVersion) {
    if (reserveExistingMac) {
        if (FeatureSupported.hotPlug(clusterCompatibilityVersion) && getOsRepository().hasNicHotplugSupport(osId, clusterCompatibilityVersion)) {
            macPool.forceAddMac(iface.getMacAddress());
        } else if (!macPool.addMac(iface.getMacAddress())) {
            auditLogMacInUse(iface);
            throw new VdcBLLException(VdcBllErrors.MAC_ADDRESS_IS_IN_USE);
        }
    }
    getVmNicDao().save(iface);
    getVmNetworkStatisticsDao().save(iface.getStatistics());
    compensationContext.snapshotNewEntity(iface);
    compensationContext.snapshotNewEntity(iface.getStatistics());
}
#end_block

#method_before
public void removeAll(Guid vmId) {
    List<VmNic> interfaces = getVmNicDao().getAllForVm(vmId);
    if (interfaces != null) {
        removeFromExternalNetworks(interfaces);
        final MacPoolManagerStrategy macPool = getMacPoolManager(vmId);
        for (VmNic iface : interfaces) {
            macPool.freeMac(iface.getMacAddress());
            getVmNicDao().remove(iface.getId());
            getVmNetworkStatisticsDao().remove(iface.getId());
        }
    }
}
#method_after
public void removeAll(Guid vmId) {
    List<VmNic> interfaces = getVmNicDao().getAllForVm(vmId);
    if (interfaces != null) {
        removeFromExternalNetworks(interfaces);
        for (VmNic iface : interfaces) {
            macPool.freeMac(iface.getMacAddress());
            getVmNicDao().remove(iface.getId());
            getVmNetworkStatisticsDao().remove(iface.getId());
        }
    }
}
#end_block

#method_before
public List<String> findActiveVmsUsingNetworks(Guid vdsId, List<String> networks) {
    List<VM> runningVms = getVmDAO().getAllRunningForVds(vdsId);
    List<String> vmNames = new ArrayList<String>();
    for (VM vm : runningVms) {
        List<VmNetworkInterface> vmInterfaces = getVmNetworkInterfaceDao().getAllForVm(vm.getId());
        for (VmNetworkInterface vmNic : vmInterfaces) {
            if (vmNic.getNetworkName() != null && networks.contains(vmNic.getNetworkName())) {
                vmNames.add(vm.getName());
                break;
            }
        }
    }
    return vmNames;
}
#method_after
public List<String> findActiveVmsUsingNetworks(Guid vdsId, List<String> networks) {
    if (networks.isEmpty()) {
        return Collections.emptyList();
    }
    List<VM> runningVms = getVmDAO().getAllRunningForVds(vdsId);
    List<String> vmNames = new ArrayList<String>();
    for (VM vm : runningVms) {
        List<VmNetworkInterface> vmInterfaces = getVmNetworkInterfaceDao().getAllForVm(vm.getId());
        for (VmNetworkInterface vmNic : vmInterfaces) {
            if (VmNetworkCanBeUpdatedPredicate.getInstance().eval(vmNic) && vmNic.getNetworkName() != null && networks.contains(vmNic.getNetworkName())) {
                vmNames.add(vm.getName());
                break;
            }
        }
    }
    return vmNames;
}
#end_block

#method_before
protected void removeVmNetwork() {
    if (getInterfaces() != null) {
        final MacPoolManagerStrategy macPool = getMacPoolForVm();
        for (VmNic iface : getInterfaces()) {
            macPool.freeMac(iface.getMacAddress());
        }
    }
}
#method_after
protected void removeVmNetwork() {
    if (getInterfaces() != null) {
        for (VmNic iface : getInterfaces()) {
            getMacPool().freeMac(iface.getMacAddress());
        }
    }
}
#end_block

#method_before
protected void endActionOnDisks() {
    for (VdcActionParametersBase p : getParametersForChildCommand()) {
        if (overrideChildCommandSuccess()) {
            p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        }
        getBackend().endAction(p.getCommandType() == VdcActionType.Unknown ? getChildActionType() : p.getCommandType(), p);
    }
}
#method_after
protected void endActionOnDisks() {
    for (VdcActionParametersBase p : getParametersForChildCommand()) {
        if (overrideChildCommandSuccess()) {
            p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        }
        getBackend().endAction(p.getCommandType() == VdcActionType.Unknown ? getChildActionType() : p.getCommandType(), p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#end_block

#method_before
protected boolean checkPayload(VmPayload payload, String isoPath) {
    boolean returnValue = true;
    if (payload.getType() != VmDeviceType.CDROM && payload.getType() != VmDeviceType.FLOPPY) {
        addCanDoActionMessage(VdcBllMessages.VMPAYLOAD_INVALID_PAYLOAD_TYPE);
        returnValue = false;
    } else {
        for (String content : payload.getFiles().values()) {
            // Check each file individually, no constraint on total size
            if (!VmPayload.isPayloadSizeLegal(content)) {
                Integer lengthInKb = 2 * Config.<Integer>getValue(ConfigValues.PayloadSize) / Kb;
                addCanDoActionMessage(VdcBllMessages.VMPAYLOAD_SIZE_EXCEEDED);
                addCanDoActionMessage(String.format("$size %1$s", lengthInKb.toString()));
                returnValue = false;
                break;
            }
        }
    }
    return returnValue;
}
#method_after
protected boolean checkPayload(VmPayload payload, String isoPath) {
    boolean returnValue = true;
    if (payload.getType() != VmDeviceType.CDROM && payload.getType() != VmDeviceType.FLOPPY) {
        addCanDoActionMessage(VdcBllMessages.VMPAYLOAD_INVALID_PAYLOAD_TYPE);
        returnValue = false;
    } else {
        for (String content : payload.getFiles().values()) {
            // Check each file individually, no constraint on total size
            if (!VmPayload.isPayloadSizeLegal(content)) {
                Integer lengthInKb = 2 * Config.<Integer>getValue(ConfigValues.PayloadSize) / Kb;
                addCanDoActionMessage(VdcBllMessages.VMPAYLOAD_SIZE_EXCEEDED);
                addCanDoActionMessageVariable("size", lengthInKb.toString());
                returnValue = false;
                break;
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
protected boolean canRunActionOnNonManagedVm() {
    ValidationResult nonManagedVmValidationResult = VmHandler.canRunActionOnNonManagedVm(getVm(), getActionType());
    if (!nonManagedVmValidationResult.isValid()) {
        return failCanDoAction(nonManagedVmValidationResult.getMessage());
    }
    return true;
}
#method_after
protected boolean canRunActionOnNonManagedVm() {
    ValidationResult nonManagedVmValidationResult = VmHandler.canRunActionOnNonManagedVm(getVm(), this.getActionType());
    if (!nonManagedVmValidationResult.isValid()) {
        return failCanDoAction(nonManagedVmValidationResult.getMessage());
    }
    return true;
}
#end_block

#method_before
@Before
@SuppressWarnings("unchecked")
public void setupMocks() {
    MockitoAnnotations.initMocks(this);
    doReturn(macPoolManagerStrategy).when(vmInterfaceManager).getMacPoolManager(Mockito.any(Guid.class));
    doReturn(vmNetworkStatisticsDAO).when(vmInterfaceManager).getVmNetworkStatisticsDao();
    doReturn(vmNetworkInterfaceDAO).when(vmInterfaceManager).getVmNetworkInterfaceDao();
    doReturn(vmNicDao).when(vmInterfaceManager).getVmNicDao();
    doReturn(vmDAO).when(vmInterfaceManager).getVmDAO();
    doNothing().when(vmInterfaceManager).auditLogMacInUseUnplug(any(VmNic.class));
    doNothing().when(vmInterfaceManager).removeFromExternalNetworks(anyList());
    doNothing().when(vmInterfaceManager).log(any(AuditLogableBase.class), any(AuditLogType.class));
}
#method_after
@Before
@SuppressWarnings("unchecked")
public void setupMocks() {
    vmInterfaceManager = Mockito.spy(new VmInterfaceManager(macPoolManagerStrategy));
    doReturn(vmNetworkStatisticsDAO).when(vmInterfaceManager).getVmNetworkStatisticsDao();
    doReturn(vmNetworkInterfaceDAO).when(vmInterfaceManager).getVmNetworkInterfaceDao();
    doReturn(vmNicDao).when(vmInterfaceManager).getVmNicDao();
    doReturn(vmDAO).when(vmInterfaceManager).getVmDAO();
    doNothing().when(vmInterfaceManager).auditLogMacInUseUnplug(any(VmNic.class));
    doNothing().when(vmInterfaceManager).removeFromExternalNetworks(anyList());
    doNothing().when(vmInterfaceManager).log(any(AuditLogableBase.class), any(AuditLogType.class));
}
#end_block

#method_before
@Test
public void findActiveVmsUsingNetworks() {
    mockDaos();
    List<String> vmNames = vmInterfaceManager.findActiveVmsUsingNetworks(Guid.newGuid(), Collections.singletonList(NETWORK_NAME));
    assertTrue(vmNames.contains(VM_NAME));
}
#method_after
@Test
public void findActiveVmsUsingNetworks() {
    mockDaos(true);
    List<String> vmNames = vmInterfaceManager.findActiveVmsUsingNetworks(Guid.newGuid(), Collections.singletonList(NETWORK_NAME));
    assertTrue(vmNames.contains(VM_NAME));
}
#end_block

#method_before
@Test
public void findNoneOfActiveVmsUsingNetworks() {
    mockDaos();
    List<String> vmNames = vmInterfaceManager.findActiveVmsUsingNetworks(Guid.newGuid(), Collections.singletonList(NETWORK_NAME + "1"));
    assertTrue(vmNames.isEmpty());
}
#method_after
@Test
public void findNoneOfActiveVmsUsingNetworks() {
    mockDaos(true);
    List<String> vmNames = vmInterfaceManager.findActiveVmsUsingNetworks(Guid.newGuid(), Collections.singletonList(NETWORK_NAME + "1"));
    assertTrue(vmNames.isEmpty());
}
#end_block

#method_before
private void mockDaos() {
    VM vm = createVM(VM_NAME, NETWORK_NAME);
    when(vmDAO.getAllRunningForVds(any(Guid.class))).thenReturn(Arrays.asList(vm));
    when(vmNetworkInterfaceDAO.getAllForVm(vm.getId())).thenReturn(vm.getInterfaces());
}
#method_after
private void mockDaos(boolean pluggedInterface) {
    VM vm = createVM(VM_NAME, NETWORK_NAME, pluggedInterface);
    when(vmDAO.getAllRunningForVds(any(Guid.class))).thenReturn(Arrays.asList(vm));
    when(vmNetworkInterfaceDAO.getAllForVm(vm.getId())).thenReturn(vm.getInterfaces());
}
#end_block

#method_before
protected VmNic createNewInterface() {
    VmNic iface = new VmNic();
    iface.setId(Guid.newGuid());
    final long from = MacAddressRangeUtils.macToLong("00:1A:4A:01:00:00");
    final int MAX_MACS_IN_POOL = 100000;
    final int rndInt = RandomUtils.instance().nextInt(MAX_MACS_IN_POOL);
    long macLong = from + rndInt;
    iface.setMacAddress(MacAddressRangeUtils.macToString(macLong));
    return iface;
}
#method_after
protected VmNic createNewInterface() {
    VmNic iface = new VmNic();
    iface.setId(Guid.newGuid());
    iface.setMacAddress(RandomUtils.instance().nextString(10));
    return iface;
}
#end_block

#method_before
protected VmNetworkInterface createNewViewableInterface() {
    VmNetworkInterface iface = new VmNetworkInterface();
    iface.setId(Guid.newGuid());
    iface.setMacAddress(RandomUtils.instance().nextString(10));
    return iface;
}
#method_after
protected VmNetworkInterface createNewViewableInterface(boolean plugged) {
    VmNetworkInterface iface = new VmNetworkInterface();
    iface.setId(Guid.newGuid());
    iface.setMacAddress(RandomUtils.instance().nextString(10));
    iface.setPlugged(plugged);
    return iface;
}
#end_block

#method_before
private VM createVM(String vmName, String networkName) {
    VM vm = new VM();
    vm.setId(Guid.newGuid());
    vm.setName(vmName);
    VmNetworkInterface vmIface = createNewViewableInterface();
    vmIface.setVmId(vm.getId());
    vmIface.setNetworkName(networkName);
    vm.getInterfaces().add(vmIface);
    return vm;
}
#method_after
private VM createVM(String vmName, String networkName, boolean pluggedInterface) {
    VM vm = new VM();
    vm.setId(Guid.newGuid());
    vm.setName(vmName);
    VmNetworkInterface vmIface = createNewViewableInterface(pluggedInterface);
    vmIface.setVmId(vm.getId());
    vmIface.setNetworkName(networkName);
    vm.getInterfaces().add(vmIface);
    return vm;
}
#end_block

#method_before
protected VdcReturnValueBase attemptRollback(VdcActionType commandType, VdcActionParametersBase params, CommandContext rollbackContext) {
    if (canPerformRollbackUsingCommand(commandType, params)) {
        params.setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        params.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        return getBackend().runInternalAction(commandType, params, rollbackContext);
    }
    return new VdcReturnValueBase();
}
#method_after
protected VdcReturnValueBase attemptRollback(VdcActionType commandType, VdcActionParametersBase params) {
    if (canPerformRollbackUsingCommand(commandType, params)) {
        params.setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        params.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        return getBackend().runInternalAction(commandType, params, context.clone());
    }
    return new VdcReturnValueBase();
}
#end_block

#method_before
protected VdcReturnValueBase checkAndPerformRollbackUsingCommand(VdcActionType commandType, VdcActionParametersBase params) {
    return attemptRollback(commandType, params, null);
}
#method_after
protected VdcReturnValueBase checkAndPerformRollbackUsingCommand(VdcActionType commandType, VdcActionParametersBase params) {
    return attemptRollback(commandType, params);
}
#end_block

#method_before
public void setCompensationContext(CompensationContext compensationContext) {
    context.setCompensationContext(compensationContext);
}
#method_after
public void setCompensationContext(CompensationContext compensationContext) {
    context.withCompensationContext(compensationContext);
}
#end_block

#method_before
public VdcReturnValueBase executeAction() {
    determineExecutionReason();
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed = false;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        actionAllowed = getReturnValue().getCanDoAction() || internalCanDoAction();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setCanDoAction(false);
        }
    } finally {
        freeLockExecute();
        if (!getReturnValue().getSucceeded()) {
            clearAsyncTasksWithOutVdsmId();
        }
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase executeAction() {
    determineExecutionReason();
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    Step validatingStep = null;
    boolean actionAllowed = false;
    boolean isExternal = this.getParameters().getJobId() != null || this.getParameters().getStepId() != null;
    if (!isExternal) {
        validatingStep = ExecutionHandler.addStep(getExecutionContext(), StepEnum.VALIDATING, null);
    }
    try {
        actionAllowed = getReturnValue().getCanDoAction() || internalCanDoAction();
        if (!isExternal) {
            ExecutionHandler.endStep(getExecutionContext(), validatingStep, actionAllowed);
        }
        if (actionAllowed) {
            execute();
        } else {
            getReturnValue().setCanDoAction(false);
        }
    } finally {
        freeLockExecute();
        clearAsyncTasksWithOutVdsmId();
    }
    return getReturnValue();
}
#end_block

#method_before
private void initiateLockEndAction() {
    if (commandLock == null) {
        LockIdNameAttribute annotation = getClass().getAnnotation(LockIdNameAttribute.class);
        if (annotation != null && !annotation.isReleaseAtEndOfExecute()) {
            commandLock = buildLock();
        }
    }
}
#method_after
private void initiateLockEndAction() {
    if (context.getLock() == null) {
        LockProperties lockProperties = getLockProperties();
        if (Scope.Command.equals(lockProperties.getScope())) {
            context.withLock(buildLock());
        }
    }
}
#end_block

#method_before
private void handleTransactivity() {
    scope = (getParameters() != null) ? getParameters().getTransactionScopeOption() : TransactionScopeOption.Required;
    endActionScope = scope;
    boolean forceCompensation = getForceCompensation();
    // command parameters
    if (!getTransactive()) {
        scope = TransactionScopeOption.Suppress;
        // Set the end action scope to suppress only for non-compensating commands, or the end action for commands
        // will run without transaction but compensation is not supported for end action.
        endActionScope = forceCompensation ? endActionScope : scope;
    }
    if (getCompensationContext() == null) {
        context.setCompensationContext(createCompensationContext(scope, forceCompensation));
    }
}
#method_after
private void handleTransactivity() {
    scope = (getParameters() != null) ? getParameters().getTransactionScopeOption() : TransactionScopeOption.Required;
    endActionScope = scope;
    boolean forceCompensation = getForceCompensation();
    // command parameters
    if (!getTransactive()) {
        scope = TransactionScopeOption.Suppress;
        // Set the end action scope to suppress only for non-compensating commands, or the end action for commands
        // will run without transaction but compensation is not supported for end action.
        endActionScope = forceCompensation ? endActionScope : scope;
    }
    if (getCompensationContext() == null) {
        context.withCompensationContext(createCompensationContext(scope, forceCompensation));
    }
}
#end_block

#method_before
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    // if quota enforcement is not in HARD_ENFORCEMENT the quota may be null.
    if (!isInternalExecution() && getStoragePool() != null && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            for (QuotaConsumptionParameter parameter : getQuotaConsumptionParameters()) {
                if (parameter.getQuotaGuid() != null && !Guid.Empty.equals(parameter.getQuotaGuid()) && !QuotaConsumptionParameter.QuotaAction.RELEASE.equals(parameter.getQuotaAction())) {
                    quotaPermissionList.add(new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA, VdcBllMessages.USER_NOT_AUTHORIZED_TO_CONSUME_QUOTA));
                }
            }
        }
    }
}
#method_after
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    // if quota enforcement is not in HARD_ENFORCEMENT the quota may be null.
    if (!isInternalExecution() && getStoragePool() != null && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            for (QuotaConsumptionParameter parameter : consumptionParameters) {
                if (parameter.getQuotaGuid() != null && !Guid.Empty.equals(parameter.getQuotaGuid()) && !QuotaConsumptionParameter.QuotaAction.RELEASE.equals(parameter.getQuotaAction())) {
                    quotaPermissionList.add(new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA, VdcBllMessages.USER_NOT_AUTHORIZED_TO_CONSUME_QUOTA));
                }
            }
        }
    }
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            compensate();
        } else {
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#method_after
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        setCommandExecuted();
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#end_block

#method_before
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = BackendUtils.getBackendCommandObjectsHandler(log).createAction(entry.getValue().getFirst(), entry.getValue().getSecond());
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#method_after
protected void insertAsyncTaskPlaceHolders() {
    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            buildChildCommandInfos();
            for (Map.Entry<Guid, Pair<VdcActionType, VdcActionParametersBase>> entry : childCommandInfoMap.entrySet()) {
                CommandBase<?> command = BackendUtils.getBackendCommandObjectsHandler(log).createAction(entry.getValue().getFirst(), entry.getValue().getSecond(), context);
                command.insertAsyncTaskPlaceHolders();
                childCommandsMap.put(entry.getKey(), command);
            }
            return null;
        }
    });
}
#end_block

#method_before
protected EngineLock getLock() {
    return commandLock;
}
#method_after
protected EngineLock getLock() {
    return context.getLock();
}
#end_block

#method_before
protected void setLock(EngineLock lock) {
    commandLock = lock;
}
#method_after
protected void setLock(EngineLock lock) {
    context.withLock(lock);
}
#end_block

#method_before
protected boolean acquireLock() {
    LockIdNameAttribute annotation = getClass().getAnnotation(LockIdNameAttribute.class);
    boolean returnValue = true;
    if (annotation != null) {
        releaseLocksAtEndOfExecute = annotation.isReleaseAtEndOfExecute();
        if (!annotation.isWait()) {
            returnValue = acquireLockInternal();
        } else {
            acquireLockAndWait();
        }
    }
    return returnValue;
}
#method_after
protected boolean acquireLock() {
    LockProperties lockProperties = getLockProperties();
    boolean returnValue = true;
    if (!Scope.None.equals(lockProperties.getScope())) {
        releaseLocksAtEndOfExecute = Scope.Execution.equals(lockProperties.getScope());
        if (!lockProperties.isWait()) {
            returnValue = acquireLockInternal();
        } else {
            acquireLockAndWait();
        }
    }
    return returnValue;
}
#end_block

#method_before
public final boolean acquireLockAsyncTask() {
    LockIdNameAttribute annotation = getClass().getAnnotation(LockIdNameAttribute.class);
    boolean returnValue = true;
    if (annotation != null) {
        releaseLocksAtEndOfExecute = annotation.isReleaseAtEndOfExecute();
        if (!releaseLocksAtEndOfExecute) {
            returnValue = acquireLockInternal();
        }
    }
    return returnValue;
}
#method_after
public final boolean acquireLockAsyncTask() {
    LockProperties lockProperties = getLockProperties();
    boolean returnValue = true;
    if (!Scope.None.equals(lockProperties.getScope())) {
        releaseLocksAtEndOfExecute = Scope.Execution.equals(lockProperties.getScope());
        if (!releaseLocksAtEndOfExecute) {
            returnValue = acquireLockInternal();
        }
    }
    return returnValue;
}
#end_block

#method_before
protected boolean acquireLockInternal() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (commandLock == null) {
        EngineLock lock = buildLock();
        if (lock != null) {
            Pair<Boolean, Set<String>> lockAcquireResult = getLockManager().acquireLock(lock);
            if (lockAcquireResult.getFirst()) {
                log.infoFormat("Lock Acquired to object {0}", lock);
                commandLock = lock;
            } else {
                log.infoFormat("Failed to Acquire Lock to object {0}", lock);
                getReturnValue().getCanDoActionMessages().addAll(extractVariableDeclarations(lockAcquireResult.getSecond()));
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean acquireLockInternal() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        EngineLock lock = buildLock();
        if (lock != null) {
            Pair<Boolean, Set<String>> lockAcquireResult = getLockManager().acquireLock(lock);
            if (lockAcquireResult.getFirst()) {
                log.infoFormat("Lock Acquired to object {0}", lock);
                context.withLock(lock);
            } else {
                log.infoFormat("Failed to Acquire Lock to object {0}", lock);
                getReturnValue().getCanDoActionMessages().addAll(extractVariableDeclarations(lockAcquireResult.getSecond()));
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
private void acquireLockAndWait() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (commandLock == null) {
        Map<String, Pair<String, String>> exclusiveLocks = getExclusiveLocks();
        if (exclusiveLocks != null) {
            EngineLock lock = new EngineLock(exclusiveLocks, null);
            getLockManager().acquireLockWait(lock);
            commandLock = lock;
        }
    }
}
#method_after
private void acquireLockAndWait() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        Map<String, Pair<String, String>> exclusiveLocks = getExclusiveLocks();
        if (exclusiveLocks != null) {
            EngineLock lock = new EngineLock(exclusiveLocks, null);
            getLockManager().acquireLockWait(lock);
            context.withLock(lock);
        }
    }
}
#end_block

#method_before
protected void freeLock() {
    if (commandLock != null) {
        getLockManager().releaseLock(commandLock);
        log.infoFormat("Lock freed to object {0}", commandLock);
        commandLock = null;
    }
}
#method_after
protected void freeLock() {
    if (context.getLock() != null) {
        getLockManager().releaseLock(context.getLock());
        log.infoFormat("Lock freed to object {0}", context.getLock());
        context.withLock(null);
    }
}
#end_block

#method_before
public void setExecutionContext(ExecutionContext executionContext) {
    context.setExecutionContext(executionContext);
}
#method_after
public void setExecutionContext(ExecutionContext executionContext) {
    context.withExecutionContext(executionContext);
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand, boolean enableCallBack) {
    VdcActionParametersBase parentParameters = getParentParameters(parentCommand);
    Transaction transaction = TransactionSupport.suspend();
    try {
        TaskManagerUtil.persistCommand(CommandEntity.buildCommandEntity(getCommandId(), parentParameters.getCommandId(), getActionType(), getParameters(), commandStatus, enableCallBack, getReturnValue()));
    } finally {
        TransactionSupport.resume(transaction);
    }
}
#method_after
public void persistCommand(VdcActionType parentCommand, boolean enableCallBack) {
    persistCommand(parentCommand, getContext(), enableCallBack);
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand, boolean enableCallBack) {
    VdcActionParametersBase parentParameters = getParentParameters(parentCommand);
    Transaction transaction = TransactionSupport.suspend();
    try {
        TaskManagerUtil.persistCommand(CommandEntity.buildCommandEntity(getCommandId(), parentParameters.getCommandId(), getActionType(), getParameters(), commandStatus, enableCallBack, getReturnValue()));
    } finally {
        TransactionSupport.resume(transaction);
    }
}
#method_after
public void persistCommand(VdcActionType parentCommand, CommandContext cmdContext, boolean enableCallBack) {
    VdcActionParametersBase parentParameters = getParentParameters(parentCommand);
    Transaction transaction = TransactionSupport.suspend();
    try {
        TaskManagerUtil.persistCommand(CommandEntity.buildCommandEntity(getCommandId(), parentParameters.getCommandId(), getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallBack, getReturnValue()), cmdContext);
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#end_block

#method_before
protected void removeCommand() {
    Transaction transaction = TransactionSupport.suspend();
    try {
        TaskManagerUtil.removeCommand(getCommandId());
    } finally {
        TransactionSupport.resume(transaction);
    }
}
#method_after
protected void removeCommand() {
    Transaction transaction = TransactionSupport.suspend();
    try {
        TaskManagerUtil.removeCommand(getCommandId());
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#end_block

#method_before
public void setCommandStatus(CommandStatus status, boolean updateDB) {
    this.commandStatus = status;
    if (updateDB) {
        Transaction transaction = TransactionSupport.suspend();
        try {
            TaskManagerUtil.updateCommandStatus(getCommandId(), getTaskType(), commandStatus);
        } finally {
            TransactionSupport.resume(transaction);
        }
    }
}
#method_after
public void setCommandStatus(CommandStatus status, boolean updateDB) {
    this.commandStatus = status;
    if (updateDB) {
        Transaction transaction = TransactionSupport.suspend();
        try {
            TaskManagerUtil.updateCommandStatus(getCommandId(), commandStatus);
        } finally {
            if (transaction != null) {
                TransactionSupport.resume(transaction);
            }
        }
    }
}
#end_block

#method_before
protected VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return Backend.getInstance().runInternalAction(actionType, parameters);
}
#method_after
protected VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return getBackend().runInternalAction(actionType, parameters, context.clone());
}
#end_block

#method_before
protected VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext context) {
    return Backend.getInstance().runInternalAction(actionType, parameters, context);
}
#method_after
protected VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext internalCommandContext) {
    return getBackend().runInternalAction(actionType, parameters, internalCommandContext);
}
#end_block

#method_before
protected ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters) {
    return Backend.getInstance().runInternalMultipleActions(actionType, parameters);
}
#method_after
protected ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters) {
    return getBackend().runInternalMultipleActions(actionType, parameters, context.clone());
}
#end_block

#method_before
protected ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, ExecutionContext executionContext) {
    return Backend.getInstance().runInternalMultipleActions(actionType, parameters, executionContext);
}
#method_after
protected ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, ExecutionContext executionContext) {
    return getBackend().runInternalMultipleActions(actionType, parameters, context.clone().withExecutionContext(executionContext));
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    final VmNetworkInterface anInterface = getInterface();
    final VmStatic vmStatic = getVmStaticDAO().get(getParameters().getVmId());
    addCustomValue("InterfaceType", (VmInterfaceType.forValue(anInterface.getType()).getDescription()).toString());
    this.setVmName(vmStatic.getName());
    boolean succeeded = false;
    boolean macAddedToPool = false;
    final String macAddress = getMacAddress();
    final MacPoolManagerStrategy pool = getMacPoolManager();
    try {
        if (StringUtils.isEmpty(macAddress)) {
            anInterface.setMacAddress(pool.allocateNewMac());
            macAddedToPool = true;
        } else {
            macAddedToPool = addMacToPool(macAddress, getMacPoolManager());
        }
        anInterface.setSpeed(VmInterfaceType.forValue(anInterface.getType()).getSpeed());
        anInterface.setId(Guid.newGuid());
        anInterface.setVmId(getParameters().getVmId());
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addInterfaceToDb(anInterface);
                addInterfaceDeviceToDb();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (anInterface.isPlugged()) {
            succeeded = activateOrDeactivateNewNic(anInterface, PlugAction.PLUG);
        } else {
            succeeded = true;
        }
    } finally {
        setSucceeded(succeeded);
        if (macAddedToPool && !succeeded) {
            pool.freeMac(macAddress);
        }
    }
}
#method_after
@Override
protected void executeVmCommand() {
    addCustomValue("InterfaceType", (VmInterfaceType.forValue(getInterface().getType()).getDescription()).toString());
    this.setVmName(getVmStaticDAO().get(getParameters().getVmId()).getName());
    boolean succeeded = false;
    boolean macAddedToPool = false;
    try {
        if (StringUtils.isEmpty(getMacAddress())) {
            getInterface().setMacAddress(getMacPool().allocateNewMac());
            macAddedToPool = true;
        } else {
            macAddedToPool = addMacToPool(getMacAddress());
        }
        getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
        getInterface().setId(Guid.newGuid());
        getInterface().setVmId(getParameters().getVmId());
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addInterfaceToDb(getInterface());
                addInterfaceDeviceToDb();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (getInterface().isPlugged()) {
            succeeded = activateOrDeactivateNewNic(getInterface(), PlugAction.PLUG);
        } else {
            succeeded = true;
        }
    } finally {
        setSucceeded(succeeded);
        if (macAddedToPool && !succeeded) {
            getMacPool().freeMac(getMacAddress());
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVmDynamicDao().get(getParameters().getVmId()).getStatus()))) {
        return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
    if (!uniqueInterfaceName(interfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.add(getInterface());
    if (!pciAndIdeWithinLimit(getVm(), allInterfaces)) {
        return false;
    }
    Version compatibilityVersion = getVm().getVdsGroupCompatibilityVersion();
    VmNicValidator nicValidator = new VmNicValidator(getInterface(), compatibilityVersion, getVm().getOs());
    if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.profileValid(vm.getVdsGroupId()))) {
        return false;
    }
    if (StringUtils.isNotEmpty(getMacAddress())) {
        if (!validate(macAvailable(getMacPoolManager()))) {
            return false;
        }
    } else if (getMacPoolManager().getAvailableMacsCount() <= 0) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVmDynamicDao().get(getParameters().getVmId()).getStatus()))) {
        return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
    if (!uniqueInterfaceName(interfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.add(getInterface());
    if (!pciAndIdeWithinLimit(getVm(), allInterfaces)) {
        return false;
    }
    Version compatibilityVersion = getVm().getVdsGroupCompatibilityVersion();
    VmNicValidator nicValidator = new VmNicValidator(getInterface(), compatibilityVersion, getVm().getOs());
    if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.profileValid(vm.getVdsGroupId()))) {
        return false;
    }
    if (StringUtils.isNotEmpty(getMacAddress())) {
        if (!validate(macAvailable())) {
            return false;
        }
    } else if (getMacPool().getAvailableMacsCount() <= 0) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#end_block

#method_before
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (DiskImage disk : disks) {
                VdcReturnValueBase vdcRetValue = getBackend().runInternalAction(getImagesActionType(), buildModeOrCopyImageGroupParameters(containerID, disk), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
            }
            return null;
        }

        private MoveOrCopyImageGroupParameters buildModeOrCopyImageGroupParameters(final Guid containerID, DiskImage disk) {
            MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(containerID, disk.getId(), disk.getImageId(), getParameters().getStorageDomainId(), getMoveOrCopyImageOperation());
            params.setParentCommand(getActionType());
            params.setEntityInfo(getParameters().getEntityInfo());
            params.setAddImageDomainMapping(getMoveOrCopyImageOperation() == ImageOperation.Copy);
            params.setSourceDomainId(imageFromSourceDomainMap.get(disk.getId()).getStorageIds().get(0));
            params.setParentParameters(getParameters());
            return params;
        }
    });
}
#method_after
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (DiskImage disk : disks) {
                VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(getImagesActionType(), buildModeOrCopyImageGroupParameters(containerID, disk));
                getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
            }
            return null;
        }

        private MoveOrCopyImageGroupParameters buildModeOrCopyImageGroupParameters(final Guid containerID, DiskImage disk) {
            MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(containerID, disk.getId(), disk.getImageId(), getParameters().getStorageDomainId(), getMoveOrCopyImageOperation());
            params.setParentCommand(getActionType());
            params.setEntityInfo(getParameters().getEntityInfo());
            params.setAddImageDomainMapping(getMoveOrCopyImageOperation() == ImageOperation.Copy);
            params.setSourceDomainId(imageFromSourceDomainMap.get(disk.getId()).getStorageIds().get(0));
            params.setParentParameters(getParameters());
            return params;
        }
    });
}
#end_block

#method_before
protected boolean checkIfDisksExist(Iterable<DiskImage> disksList) {
    Map<Guid, List<Guid>> alreadyRetrieved = new HashMap<>();
    for (DiskImage disk : disksList) {
        Guid targetStorageDomainId = imageToDestinationDomainMap.get(disk.getId());
        List<Guid> imagesOnStorageDomain = alreadyRetrieved.get(targetStorageDomainId);
        if (imagesOnStorageDomain == null) {
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetImagesList, new GetImagesListVDSCommandParameters(targetStorageDomainId, getStoragePoolId()));
            if (returnValue.getSucceeded()) {
                imagesOnStorageDomain = (List<Guid>) returnValue.getReturnValue();
                alreadyRetrieved.put(targetStorageDomainId, imagesOnStorageDomain);
            } else {
                addCanDoActionMessage(String.format("$sdName %1$s", getStorageDomain(targetStorageDomainId).getName()));
                addCanDoActionMessage(VdcBllMessages.ERROR_GET_IMAGE_LIST);
                return false;
            }
        }
        if (imagesOnStorageDomain.contains(disk.getId())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_CONTAINS_DISK);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkIfDisksExist(Iterable<DiskImage> disksList) {
    Map<Guid, List<Guid>> alreadyRetrieved = new HashMap<>();
    for (DiskImage disk : disksList) {
        Guid targetStorageDomainId = imageToDestinationDomainMap.get(disk.getId());
        List<Guid> imagesOnStorageDomain = alreadyRetrieved.get(targetStorageDomainId);
        if (imagesOnStorageDomain == null) {
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetImagesList, new GetImagesListVDSCommandParameters(targetStorageDomainId, getStoragePoolId()));
            if (returnValue.getSucceeded()) {
                imagesOnStorageDomain = (List<Guid>) returnValue.getReturnValue();
                alreadyRetrieved.put(targetStorageDomainId, imagesOnStorageDomain);
            } else {
                addCanDoActionMessageVariable("sdName", getStorageDomain(targetStorageDomainId).getName());
                addCanDoActionMessage(VdcBllMessages.ERROR_GET_IMAGE_LIST);
                return false;
            }
        }
        if (imagesOnStorageDomain.contains(disk.getId())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_CONTAINS_DISK);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        getBackend().endAction(getImagesActionType(), p);
    }
}
#method_after
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        getBackend().endAction(getImagesActionType(), p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#end_block

#method_before
protected void fillMacAddressIfMissing(VmNic iface) {
    final MacPoolManagerStrategy pool = getMacPoolForVmNic(iface);
    if (StringUtils.isEmpty(iface.getMacAddress()) && (pool.getAvailableMacsCount() >= 1)) {
        iface.setMacAddress(pool.allocateNewMac());
    }
}
#method_after
protected void fillMacAddressIfMissing(VmNic iface) {
    if (StringUtils.isEmpty(iface.getMacAddress()) && (getMacPool().getAvailableMacsCount() >= 1)) {
        iface.setMacAddress(getMacPool().allocateNewMac());
    }
}
#end_block

#method_before
protected boolean validateMacAddress(List<VmNic> ifaces) {
    int freeMacs = 0;
    for (VmNic iface : ifaces) {
        if (!StringUtils.isEmpty(iface.getMacAddress())) {
            if (!VALIDATE_MAC_ADDRESS.matcher(iface.getMacAddress()).matches()) {
                addCanDoActionMessage("$IfaceName " + iface.getName());
                addCanDoActionMessage("$MacAddress " + iface.getMacAddress());
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_INTERFACE_MAC_INVALID);
                return false;
            }
        } else {
            freeMacs++;
        }
    }
    final MacPoolManagerStrategy macPool = getMacPoolForDataCenter();
    if (freeMacs > 0 && !(macPool.getAvailableMacsCount() >= freeMacs)) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#method_after
protected boolean validateMacAddress(List<VmNic> ifaces) {
    int freeMacs = 0;
    for (VmNic iface : ifaces) {
        if (!StringUtils.isEmpty(iface.getMacAddress())) {
            if (!VALIDATE_MAC_ADDRESS.matcher(iface.getMacAddress()).matches()) {
                addCanDoActionMessageVariable("IfaceName ", iface.getName());
                addCanDoActionMessageVariable("MacAddress ", iface.getMacAddress());
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_INTERFACE_MAC_INVALID);
                return false;
            }
        } else {
            freeMacs++;
        }
    }
    if (freeMacs > 0 && !(getMacPool().getAvailableMacsCount() >= freeMacs)) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#end_block

#method_before
private CommandContext createAddVmStepContext(String currentVmName) {
    CommandContext commandCtx = null;
    try {
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VM.name().toLowerCase(), currentVmName);
        Step addVmStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.ADD_VM_TO_POOL, ExecutionMessageDirector.resolveStepMessage(StepEnum.ADD_VM_TO_POOL, values));
        ExecutionContext ctx = new ExecutionContext();
        ctx.setStep(addVmStep);
        ctx.setMonitored(true);
        commandCtx = new CommandContext(ctx);
    } catch (RuntimeException e) {
        log.errorFormat("Failed to create command context of adding VM {0} to Pool {1}", currentVmName, getParameters().getVmPool().getName(), e);
    }
    return commandCtx;
}
#method_after
private CommandContext createAddVmStepContext(String currentVmName) {
    CommandContext commandCtx = null;
    try {
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VM.name().toLowerCase(), currentVmName);
        Step addVmStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.ADD_VM_TO_POOL, ExecutionMessageDirector.resolveStepMessage(StepEnum.ADD_VM_TO_POOL, values));
        ExecutionContext ctx = new ExecutionContext();
        ctx.setStep(addVmStep);
        ctx.setMonitored(true);
        commandCtx = cloneContextAndDetachFromParent().withExecutionContext(ctx);
    } catch (RuntimeException e) {
        log.errorFormat("Failed to create command context of adding VM {0} to Pool {1}", currentVmName, getParameters().getVmPool().getName(), e);
    }
    return commandCtx;
}
#end_block

#method_before
protected boolean verifyAddVM() {
    final MacPoolManagerStrategy macPool = getMacPoolForVm();
    final List<String> reasons = getReturnValue().getCanDoActionMessages();
    final int nicsCount = getParameters().getVmsCount() * getVmNicDao().getAllForTemplate(getVmTemplateId()).size();
    final int priority = getParameters().getVmStaticData().getPriority();
    return VmHandler.verifyAddVm(reasons, nicsCount, priority, macPool);
}
#method_after
protected boolean verifyAddVM() {
    final List<String> reasons = getReturnValue().getCanDoActionMessages();
    final int nicsCount = getParameters().getVmsCount() * getVmNicDao().getAllForTemplate(getVmTemplateId()).size();
    final int priority = getParameters().getVmStaticData().getPriority();
    return VmHandler.verifyAddVm(reasons, nicsCount, priority, getMacPool());
}
#end_block

#method_before
public static void init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class };
    osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames));
    for (Pair<EditableField, String> pair : BaseHandler.extractAnnotatedFields(EditableField.class, (inspectedClassNames))) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond());
    }
    for (Pair<EditableOnVm, String> pair : BaseHandler.extractAnnotatedFields(EditableOnVm.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond());
    }
    for (Pair<EditableOnVmStatusField, String> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond());
    }
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.StopVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.ShutdownVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RemoveVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RebootVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.VmLogon);
}
#method_after
public static void init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class, VmManagementParametersBase.class };
    osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames));
    for (Pair<EditableField, Field> pair : BaseHandler.extractAnnotatedFields(EditableField.class, (inspectedClassNames))) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVm, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVm.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond().getName());
    }
    for (Pair<EditableOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
    }
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond().getName());
    }
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.StopVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.ShutdownVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RemoveVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RebootVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.VmLogon);
}
#end_block

#method_before
public static void updateVmGuestAgentVersion(final VM vm) {
    if (vm.getAppList() != null) {
        final String[] parts = vm.getAppList().split("[,]", -1);
        if (parts.length != 0) {
            final List<String> possibleAgentAppNames = Config.<List<String>>getValue(ConfigValues.AgentAppName);
            final Map<String, String> spiceDriversInGuest = Config.<Map<String, String>>getValue(ConfigValues.SpiceDriverNameInGuest);
            final String spiceDriverInGuest = spiceDriversInGuest.get(osRepository.getOsFamily(vm.getOs()).toLowerCase());
            for (final String part : parts) {
                for (String agentName : possibleAgentAppNames) {
                    if (StringUtils.containsIgnoreCase(part, agentName)) {
                        vm.setGuestAgentVersion(getApplicationVersion(part, agentName));
                    }
                    if (StringUtils.containsIgnoreCase(part, spiceDriverInGuest)) {
                        vm.setSpiceDriverVersion(getApplicationVersion(part, spiceDriverInGuest));
                    }
                }
            }
        }
    }
}
#method_after
public static void updateVmGuestAgentVersion(final VM vm) {
    if (vm.getAppList() != null) {
        final String[] parts = vm.getAppList().split("[,]", -1);
        if (parts != null && parts.length != 0) {
            final List<String> possibleAgentAppNames = Config.<List<String>>getValue(ConfigValues.AgentAppName);
            final Map<String, String> spiceDriversInGuest = Config.<Map<String, String>>getValue(ConfigValues.SpiceDriverNameInGuest);
            final String spiceDriverInGuest = spiceDriversInGuest.get(osRepository.getOsFamily(vm.getOs()).toLowerCase());
            for (final String part : parts) {
                for (String agentName : possibleAgentAppNames) {
                    if (StringUtils.containsIgnoreCase(part, agentName)) {
                        vm.setGuestAgentVersion(getApplicationVersion(part, agentName));
                    }
                    if (StringUtils.containsIgnoreCase(part, spiceDriverInGuest)) {
                        vm.setSpiceDriverVersion(getApplicationVersion(part, spiceDriverInGuest));
                    }
                }
            }
        }
    }
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
        // Initialize Power Management Health Check
        PmHealthCheckManager.getInstance().initialize();
        // recover from engine failure
        PmHealthCheckManager.getInstance().recover(hosts);
        // Create authentication profiles for all the domains that exist in the database:
        // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
        DbUserCacheManager.getInstance().init();
        TaskManagerUtil.initAsyncTaskManager();
        ResourceManager.getInstance().init();
        OvfDataUpdater.getInstance().initOvfDataUpdater();
        SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

            @Override
            public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
                MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
                parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
            }
        });
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                MacPoolPerDc.getInstance().initialize();
            }
        });
        StoragePoolStatusHandler.init();
        GlusterJobsManager.init();
        ExternalTrustStoreInitializer.init();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        SchedulingManager.getInstance().init();
        new DwhHeartBeat().init();
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#method_after
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
        // Initialize Power Management Health Check
        PmHealthCheckManager.getInstance().initialize();
        // recover from engine failure
        PmHealthCheckManager.getInstance().recover(hosts);
        // Create authentication profiles for all the domains that exist in the database:
        // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
        DbUserCacheManager.getInstance().init();
        TaskManagerUtil.initAsyncTaskManager();
        ResourceManager.getInstance().init();
        OvfDataUpdater.getInstance().initOvfDataUpdater();
        SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

            @Override
            public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
                MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
                parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
            }
        });
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                MacPoolPerDcSingleton.getInstance().initialize();
            }
        });
        StoragePoolStatusHandler.init();
        GlusterJobsManager.init();
        ExternalTrustStoreInitializer.init();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        SchedulingManager.getInstance().init();
        new DwhHeartBeat().init();
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    addCustomValue("InterfaceType", (VmInterfaceType.forValue(getInterface().getType()).getDescription()).toString());
    boolean succeeded = false;
    boolean macAddedToPool = false;
    final MacPoolManagerStrategy macPool = getMacPoolForVm();
    try {
        if (isVnicProfileChanged(oldIface, getInterface())) {
            Network newNetwork = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
            Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
            if (ObjectUtils.notEqual(oldNetwork, newNetwork)) {
                new ExternalNetworkManager(oldIface).deallocateIfExternal();
            }
        }
        if (macShouldBeChanged) {
            macAddedToPool = addMacToPool(getMacAddress(), macPool);
        }
        if (mustChangeAddress(oldIface.getType(), getInterface().getType())) {
            getVmDeviceDao().clearDeviceAddress(getInterface().getId());
        }
        getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getCompensationContext().snapshotEntity(oldIface);
                getVmNicDao().update(getInterface());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        succeeded = updateHost();
    } finally {
        setSucceeded(succeeded);
        if (macAddedToPool) {
            if (succeeded) {
                macPool.freeMac(oldIface.getMacAddress());
            } else {
                macPool.freeMac(getMacAddress());
            }
        }
    }
}
#method_after
@Override
protected void executeVmCommand() {
    addCustomValue("InterfaceType", (VmInterfaceType.forValue(getInterface().getType()).getDescription()).toString());
    boolean succeeded = false;
    boolean macAddedToPool = false;
    try {
        if (isVnicProfileChanged(oldIface, getInterface())) {
            Network newNetwork = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
            Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
            if (ObjectUtils.notEqual(oldNetwork, newNetwork)) {
                new ExternalNetworkManager(oldIface).deallocateIfExternal();
            }
        }
        if (macShouldBeChanged) {
            macAddedToPool = addMacToPool(getMacAddress());
        }
        if (mustChangeAddress(oldIface.getType(), getInterface().getType())) {
            getVmDeviceDao().clearDeviceAddress(getInterface().getId());
        }
        getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getCompensationContext().snapshotEntity(oldIface);
                getVmNicDao().update(getInterface());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        succeeded = updateHost();
    } finally {
        setSucceeded(succeeded);
        if (macAddedToPool) {
            if (succeeded) {
                getMacPool().freeMac(oldIface.getMacAddress());
            } else {
                getMacPool().freeMac(getMacAddress());
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    final MacPoolManagerStrategy macPool = getMacPoolForVm();
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVm().getStatus()))) {
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!updateVnicForBackwardCompatibility(oldIface)) {
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(interfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    if (!pciAndIdeWithinLimit(getVm(), allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getVdsGroupCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.hotUpdatePossible()) || !validate(nicValidator.profileValid(getVm().getVdsGroupId()))) {
        return false;
    }
    Network network = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network)) || !validate(nicValidator.networkExistsOnHost(network))) {
            return false;
        }
    }
    macShouldBeChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macShouldBeChanged && !validate(macAvailable(macPool))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVm().getStatus()))) {
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!updateVnicForBackwardCompatibility(oldIface)) {
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(interfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    if (!pciAndIdeWithinLimit(getVm(), allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getVdsGroupCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.hotUpdatePossible()) || !validate(nicValidator.profileValid(getVm().getVdsGroupId()))) {
        return false;
    }
    Network network = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network)) || !validate(nicValidator.networkExistsOnHost(network))) {
            return false;
        }
    }
    macShouldBeChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macShouldBeChanged && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    final DbFacade dbFacadeMock = mock(DbFacade.class);
    storagePoolDaoMock = mock(StoragePoolDAO.class);
    vmNicDaoMock = mock(VmNicDao.class);
    macPoolDaoMock = mock(MacPoolDao.class);
    vmDaoMock = mock(VmDAO.class);
    DbFacadeLocator.setDbFacade(dbFacadeMock);
    when(dbFacadeMock.getStoragePoolDao()).thenReturn(storagePoolDaoMock);
    when(dbFacadeMock.getVmNicDao()).thenReturn(vmNicDaoMock);
    when(dbFacadeMock.getVmDao()).thenReturn(vmDaoMock);
    when(dbFacadeMock.getMacPoolDao()).thenReturn(macPoolDaoMock);
    // reinit ScopedMacPoolManagerInstance -- very ugly,unintended consequence of using static methods instead of DI.
    MacPoolPerDc.INSTANCE = new MacPoolPerDc();
}
#method_after
@Before
public void setUp() throws Exception {
    DbFacadeLocator.setDbFacade(dbFacade);
    when(dbFacade.getStoragePoolDao()).thenReturn(storagePoolDao);
    when(dbFacade.getVmNicDao()).thenReturn(vmNicDao);
    when(dbFacade.getMacPoolDao()).thenReturn(macPoolDao);
    when(dbFacade.getAuditLogDao()).thenReturn(auditLogDao);
    macPool = createMacPool(MAC_FROM, MAC_TO);
    dataCenter = createStoragePool(macPool);
    vmNic = createVmNic();
    pool = new MacPoolPerDc();
}
#end_block

#method_before
@Test
public void testNicIsCorrectlyAllocatedInScopedPool() throws Exception {
    final MacPool macPool = createMacPool("00:1a:4a:15:c0:00", "00:1a:4a:15:c0:ff");
    final StoragePool storagePool = createStoragePool(macPool);
    when(storagePoolDaoMock.getAll()).thenReturn(Collections.singletonList(storagePool));
    // mock existing vmNics
    final String macAddress = "00:1a:4a:15:c0:fe";
    final VmNic vmNic = new VmNic();
    vmNic.setMacAddress(macAddress);
    // when(vmNicDaoMock.getAll()).thenReturn(Collections.singletonList(vmNic));
    // mock querying for existing mac addresses for given data center.
    when(macPoolDaoMock.getAllMacsForMacPool(eq(storagePool.getMacPoolId()))).thenReturn(Collections.singletonList(macAddress));
    // mock all available pools
    when(macPoolDaoMock.getAll()).thenReturn(Collections.singletonList(macPool));
    // mock obtaining storagepool by id.
    when(storagePoolDaoMock.get(eq(storagePool.getId()))).thenReturn(storagePool);
    // mock existing vms
    final VM vm = new VM();
    vm.setStoragePoolId(storagePool.getId());
    when(vmDaoMock.get(any(Guid.class))).thenReturn(vm);
    MacPoolPerDc.INSTANCE.initialize();
    assertThat("scoped pool for this nic should exist", MacPoolPerDc.INSTANCE.poolForVmNic(vmNic), notNullValue());
    assertThat("provided mac should be used in returned pool", MacPoolPerDc.INSTANCE.poolForVmNic(vmNic).isMacInUse(macAddress), is(true));
}
#method_after
@Test
public void testNicIsCorrectlyAllocatedInScopedPool() throws Exception {
    mockStoragePool(dataCenter);
    mockGettingAllMacPools(macPool);
    mockAllMacsForStoragePool(dataCenter, vmNic.getMacAddress());
    pool.initialize();
    assertThat("scoped pool for this nic should exist", pool.poolForDataCenter(dataCenter.getId()), is(notNullValue()));
    assertThat("provided mac should be used in returned pool", pool.poolForDataCenter(dataCenter.getId()).isMacInUse(vmNic.getMacAddress()), is(true));
}
#end_block

#method_before
public final void initialize() {
    lockObj.writeLock().lock();
    try {
        if (initialized) {
            LOGGER.error("Trying to initialized " + getClass().getName() + " multiple times.");
            return;
        }
        final List<MacPool> macPools = getMacPoolDao().getAll();
        for (MacPool macPool : macPools) {
            initializeMacPool(macPool);
        }
        initialized = true;
    } catch (Throwable t) {
        LOGGER.error("MAC pool not initialized.");
        throw t;
    } finally {
        LOGGER.info("MAC pool successfully initialized");
        lockObj.writeLock().unlock();
    }
}
#method_after
public final void initialize() {
    try (AutoCloseableLock lock = writeLockResource()) {
        if (initialized) {
            log.error("Trying to initialize multiple times.");
            return;
        }
        final List<MacPool> macPools = getMacPoolDao().getAll();
        for (MacPool macPool : macPools) {
            initializeMacPool(macPool);
        }
        initialized = true;
        log.info("successfully initialized");
    } catch (RuntimeException e) {
        log.error("not initialized.");
        throw e;
    }
}
#end_block

#method_before
public MacPoolManagerStrategy poolForDataCenter(Guid dataCenterId) {
    lockObj.readLock().lock();
    try {
        checkInitialized();
        return getPoolWithoutLocking(getMacPoolId(dataCenterId));
    } finally {
        lockObj.readLock().unlock();
    }
}
#method_after
public MacPoolManagerStrategy poolForDataCenter(Guid dataCenterId) {
    try (AutoCloseableLock lock = readLockResource()) {
        checkInitialized();
        return getPoolWithoutLocking(getMacPoolId(dataCenterId));
    }
}
#end_block

#method_before
protected Guid getMacPoolId(Guid dataCenterId) {
    final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(dataCenterId);
    return storagePool == null ? null : storagePool.getMacPoolId();
}
#method_after
private Guid getMacPoolId(Guid dataCenterId) {
    final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(dataCenterId);
    return storagePool == null ? null : storagePool.getMacPoolId();
}
#end_block

#method_before
public final void createPool(MacPool macPool) {
    lockObj.writeLock().lock();
    try {
        checkInitialized();
        createPoolWithoutLocking(macPool);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
public final void createPool(MacPool macPool) {
    try (AutoCloseableLock lock = writeLockResource()) {
        checkInitialized();
        createPoolWithoutLocking(macPool);
    }
}
#end_block

#method_before
private MacPoolManagerStrategy createPoolWithoutLocking(MacPool macPool) {
    MacPoolManagerStrategy poolForScope = createAndInitPool(macPool);
    macPools.put(macPool.getId(), poolForScope);
    return poolForScope;
}
#method_after
private MacPoolManagerStrategy createPoolWithoutLocking(MacPool macPool) {
    if (macPools.containsKey(macPool.getId())) {
        throw new IllegalStateException(UNABLE_TO_CREATE_MAC_POOL_IT_ALREADY_EXIST);
    }
    MacPoolManagerStrategy poolForScope = new MacPoolManagerRanges(macPoolToRanges(macPool), macPool.isAllowDuplicateMacAddresses());
    poolForScope.initialize();
    macPools.put(macPool.getId(), poolForScope);
    return poolForScope;
}
#end_block

#method_before
public final void modifyPool(MacPool macPool) {
    lockObj.writeLock().lock();
    try {
        checkInitialized();
        removeWithoutLocking(macPool.getId());
        initializeMacPool(macPool);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
public final void modifyPool(MacPool macPool) {
    try (AutoCloseableLock lock = writeLockResource()) {
        checkInitialized();
        if (!macPools.containsKey(macPool.getId())) {
            throw new IllegalStateException(INEXISTENT_POOL_EXCEPTION_MESSAGE);
        }
        removeWithoutLocking(macPool.getId());
        initializeMacPool(macPool);
    }
}
#end_block

#method_before
public void removePool(Guid macPoolId) {
    lockObj.writeLock().lock();
    try {
        removeWithoutLocking(macPoolId);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
public void removePool(Guid macPoolId) {
    try (AutoCloseableLock lock = writeLockResource()) {
        checkInitialized();
        removeWithoutLocking(macPoolId);
    }
}
#end_block

#method_before
@Test
public void insufficientDiskSpace() {
    final int lotsOfSpaceRequired = 1073741824;
    final ImportVmTemplateCommand c = setupDiskSpaceTest(lotsOfSpaceRequired);
    assertFalse(c.canDoAction());
    assertTrue(c.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN.toString()));
}
#method_after
@Test
public void insufficientDiskSpace() {
    final int lotsOfSpaceRequired = 1073741824;
    final ImportVmTemplateCommand c = setupDiskSpaceTest(lotsOfSpaceRequired);
    assertFalse(c.canDoAction());
    assertTrue(c.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN.toString()));
}
#end_block

#method_before
private ImportVmTemplateCommand setupVolumeFormatAndTypeTest(VolumeFormat volumeFormat, VolumeType volumeType, StorageType storageType, int freeSpaceCritical) {
    mcr.mockConfigValue(ConfigValues.FreeSpaceCriticalLowInGB, freeSpaceCritical);
    ImportVmTemplateCommand command = spy(new ImportVmTemplateCommand(createParameters()));
    Backend backend = mock(Backend.class);
    doReturn(backend).when(command).getBackend();
    doReturn(false).when(command).isVmTemplateWithSameNameExist();
    doReturn(true).when(command).isVDSGroupCompatible();
    doReturn(true).when(command).validateNoDuplicateDiskImages(any(Iterable.class));
    mockGetTemplatesFromExportDomainQuery(volumeFormat, volumeType, command);
    mockStorageDomainStatic(command, storageType);
    doReturn(mock(VmTemplateDAO.class)).when(command).getVmTemplateDAO();
    mockStoragePool(command);
    mockStorageDomains(command);
    return command;
}
#method_after
private ImportVmTemplateCommand setupVolumeFormatAndTypeTest(VolumeFormat volumeFormat, VolumeType volumeType, StorageType storageType, int freeSpaceCritical) {
    mcr.mockConfigValue(ConfigValues.FreeSpaceCriticalLowInGB, freeSpaceCritical);
    ImportVmTemplateCommand command = spy(new ImportVmTemplateCommand(createParameters()));
    Backend backend = mock(Backend.class);
    doReturn(backend).when(command).getBackend();
    doReturn(false).when(command).isVmTemplateWithSameNameExist();
    doReturn(true).when(command).isVDSGroupCompatible();
    doReturn(true).when(command).validateNoDuplicateDiskImages(any(Iterable.class));
    mockGetTemplatesFromExportDomainQuery(volumeFormat, volumeType, command);
    mockStorageDomainStatic(command, storageType);
    doReturn(mock(VmTemplateDAO.class)).when(command).getVmTemplateDAO();
    doReturn(Mockito.mock(MacPoolManagerStrategy.class)).when(command).getMacPool();
    mockStoragePool(command);
    mockStorageDomains(command);
    return command;
}
#end_block

#method_before
private static void mockGetTemplatesFromExportDomainQuery(VolumeFormat volumeFormat, VolumeType volumeType, ImportVmTemplateCommand command) {
    final VdcQueryReturnValue result = new VdcQueryReturnValue();
    Map<VmTemplate, List<DiskImage>> resultMap = new HashMap<VmTemplate, List<DiskImage>>();
    DiskImage image = new DiskImage();
    image.setActualSizeInBytes(2);
    image.setvolumeFormat(volumeFormat);
    image.setVolumeType(volumeType);
    resultMap.put(new VmTemplate(), Arrays.asList(image));
    result.setReturnValue(resultMap);
    result.setSucceeded(true);
    when(command.getBackend().runInternalQuery(eq(VdcQueryType.GetTemplatesFromExportDomain), any(VdcQueryParametersBase.class))).thenReturn(result);
}
#method_after
private static void mockGetTemplatesFromExportDomainQuery(VolumeFormat volumeFormat, VolumeType volumeType, ImportVmTemplateCommand command) {
    final VdcQueryReturnValue result = new VdcQueryReturnValue();
    Map<VmTemplate, List<DiskImage>> resultMap = new HashMap<VmTemplate, List<DiskImage>>();
    DiskImage image = new DiskImage();
    image.setActualSizeInBytes(2);
    image.setvolumeFormat(volumeFormat);
    image.setVolumeType(volumeType);
    resultMap.put(new VmTemplate(), Arrays.asList(image));
    result.setReturnValue(resultMap);
    result.setSucceeded(true);
    when(command.getBackend().runInternalQuery(eq(VdcQueryType.GetTemplatesFromExportDomain), any(VdcQueryParametersBase.class), any(EngineContext.class))).thenReturn(result);
}
#end_block

#method_before
@Override
protected void init(T parameters) {
    super.init(parameters);
    setVmId(parameters.getContainerId());
    setVm(parameters.getVm());
    macPool = MacPoolPerDc.getInstance().poolForVm(getParameters().getVm());
    setVdsGroupId(parameters.getVdsGroupId());
    if (parameters.getVm() != null && getVm().getDiskMap() != null) {
        imageList = new ArrayList<DiskImage>();
        for (Disk disk : getVm().getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                imageList.add((DiskImage) disk);
            }
        }
    }
    ensureDomainMap(imageList, parameters.getDestDomainId());
}
#method_after
@Override
protected void init(T parameters) {
    super.init(parameters);
    setVmId(parameters.getContainerId());
    setVm(parameters.getVm());
    setVdsGroupId(parameters.getVdsGroupId());
    if (parameters.getVm() != null && getVm().getDiskMap() != null) {
        imageList = new ArrayList<DiskImage>();
        for (Disk disk : getVm().getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                imageList.add((DiskImage) disk);
            }
        }
    }
    ensureDomainMap(imageList, parameters.getDestDomainId());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        final VM vm = getVm();
        if (vm.getInterfaces().size() > getMacPoolForVm().getAvailableMacsCount()) {
            addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
            return false;
        }
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#method_after
@Override
protected boolean canDoAction() {
    Map<Guid, StorageDomain> domainsMap = new HashMap<Guid, StorageDomain>();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > getMacPool().getAvailableMacsCount()) {
            addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
            return false;
        }
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#end_block

#method_before
private boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (!checkStoragePool()) {
        return false;
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVm().getId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            } else {
                // If no copy collapse sent, validate each image configuration (snapshot or active image).
                if (!isImagesAlreadyOnTarget() && !validateImageConfig(canDoActionMessages, domainsMap, image)) {
                    return false;
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getSourceDomainId(image))));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#method_after
protected boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (!checkStoragePool()) {
        return false;
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVm().getId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            } else {
                // If no copy collapse sent, validate each image configuration (snapshot or active image).
                if (!isImagesAlreadyOnTarget() && !validateImageConfig(canDoActionMessages, domainsMap, image)) {
                    return false;
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getSourceDomainId(image))));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#end_block

#method_before
protected List<VM> getVmsFromExportDomain() {
    GetAllFromExportDomainQueryParameters p = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
    VdcQueryReturnValue qRetVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, p);
    return qRetVal.getSucceeded() ? qRetVal.<List<VM>>getReturnValue() : null;
}
#method_after
protected List<VM> getVmsFromExportDomain() {
    GetAllFromExportDomainQueryParameters p = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
    VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetVmsFromExportDomain, p);
    return qRetVal.getSucceeded() ? qRetVal.<List<VM>>getReturnValue() : null;
}
#end_block

#method_before
private boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vmFromParams = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vmFromParams.getDiskMap() != null) {
        for (Disk disk : vmFromParams.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!isImagesAlreadyOnTarget()) {
        Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        if (!setDomainsForMemoryImages(domainMap)) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces()))) {
        return false;
    }
    return true;
}
#method_after
protected boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vmFromParams = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vmFromParams.getDiskMap() != null) {
        for (Disk disk : vmFromParams.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!isImagesAlreadyOnTarget()) {
        Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        if (!setDomainsForMemoryImages(domainMap)) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
        }
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean isTemplateExistsOnExportDomain() {
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getParameters().getVm().getVmtGuid())) {
        return true;
    }
    VdcQueryReturnValue qRetVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    if (qRetVal.getSucceeded()) {
        Map<VmTemplate, ?> templates = qRetVal.getReturnValue();
        for (VmTemplate template : templates.keySet()) {
            if (getParameters().getVm().getVmtGuid().equals(template.getId())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
private boolean isTemplateExistsOnExportDomain() {
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getParameters().getVm().getVmtGuid())) {
        return true;
    }
    VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    if (qRetVal.getSucceeded()) {
        Map<VmTemplate, ?> templates = qRetVal.getReturnValue();
        for (VmTemplate template : templates.keySet()) {
            if (getParameters().getVm().getVmtGuid().equals(template.getId())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = verifyDisksIfNeeded();
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<StorageDomain, Guid>() {

            @Override
            public Guid eval(StorageDomain storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = verifyDisksIfNeeded();
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<StorageDomain, Guid>() {

            @Override
            public Guid eval(StorageDomain storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
protected boolean checkImagesGUIDsLegal() {
    for (DiskImage image : getImages()) {
        Guid imageGUID = image.getImageId();
        Guid storagePoolId = image.getStoragePoolId() != null ? image.getStoragePoolId() : Guid.Empty;
        Guid storageDomainId = getSourceDomainId(image);
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        VDSReturnValue retValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DoesImageExist, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, imageGUID));
        if (Boolean.FALSE.equals(retValue.getReturnValue())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
        }
    }
    return true;
}
#method_after
protected boolean checkImagesGUIDsLegal() {
    for (DiskImage image : getImages()) {
        Guid imageGUID = image.getImageId();
        Guid storagePoolId = image.getStoragePoolId() != null ? image.getStoragePoolId() : Guid.Empty;
        Guid storageDomainId = getSourceDomainId(image);
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        VDSReturnValue retValue = runVdsCommand(VDSCommandType.DoesImageExist, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, imageGUID));
        if (Boolean.FALSE.equals(retValue.getReturnValue())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        addVmToDb();
        processImages(!isImagesAlreadyOnTarget());
        // vm related ops
        if (getReturnValue().getVdsmTaskIdList().isEmpty()) {
            endVmRelatedOps();
        }
        // Save Vm Init
        VmHandler.addVmInitToDB(getVm().getStaticData());
    } catch (RuntimeException e) {
        getMacPoolForVm().freeMacs(macsAdded);
        throw e;
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    try {
        addVmToDb();
        processImages(!isImagesAlreadyOnTarget());
        // vm related ops
        if (getReturnValue().getVdsmTaskIdList().isEmpty()) {
            endVmRelatedOps();
        }
        // Save Vm Init
        VmHandler.addVmInitToDB(getVm().getStaticData());
    } catch (RuntimeException e) {
        getMacPool().freeMacs(macsAdded);
        throw e;
    }
    setSucceeded(true);
}
#end_block

#method_before
private void copyAllMemoryImages(Guid containerId) {
    for (String memoryVolumes : MemoryUtils.getMemoryVolumesFromSnapshots(getVm().getSnapshots())) {
        List<Guid> guids = GuidUtils.getGuidListFromString(memoryVolumes);
        // copy the memory dump image
        VdcReturnValueBase vdcRetValue = runInternalAction(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerId, guids.get(0), guids.get(2), guids.get(3)), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalAction(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerId, guids.get(0), guids.get(4), guids.get(5)), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
private void copyAllMemoryImages(Guid containerId) {
    for (String memoryVolumes : MemoryUtils.getMemoryVolumesFromSnapshots(getVm().getSnapshots())) {
        List<Guid> guids = GuidUtils.getGuidListFromString(memoryVolumes);
        // copy the memory dump image
        VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryDumpImage(containerId, guids.get(0), guids.get(2), guids.get(3)));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
        // copy the memory configuration (of the VM) image
        vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForMemoryConfImage(containerId, guids.get(0), guids.get(4), guids.get(5)));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "Failed during ExportVmCommand");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        VdcReturnValueBase vdcRetValue = runInternalAction(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(disk, containerID), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "ImportVmCommand::MoveOrCopyAllImageGroups: Failed to copy disk!");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(disk, containerID));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "ImportVmCommand::MoveOrCopyAllImageGroups: Failed to copy disk!");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    List<VmNetworkInterface> nics = getVm().getInterfaces();
    vmInterfaceManager.sortVmNics(nics, getVm().getStaticData().getManagedDeviceMap());
    // If we import it as a new entity, then we allocate all MAC addresses in advance
    if (getParameters().isImportAsNewEntity()) {
        List<String> macAddresses = getMacPoolForVm().allocateMacAddresses(nics.size());
        for (int i = 0; i < nics.size(); ++i) {
            nics.get(i).setMacAddress(macAddresses.get(i));
        }
    }
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), !getParameters().isImportAsNewEntity(), getVm().getOs(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(getMacPool());
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    List<VmNetworkInterface> nics = getVm().getInterfaces();
    vmInterfaceManager.sortVmNics(nics, getVm().getStaticData().getManagedDeviceMap());
    // If we import it as a new entity, then we allocate all MAC addresses in advance
    if (getParameters().isImportAsNewEntity()) {
        List<String> macAddresses = getMacPool().allocateMacAddresses(nics.size());
        for (int i = 0; i < nics.size(); ++i) {
            nics.get(i).setMacAddress(macAddresses.get(i));
        }
    }
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), !getParameters().isImportAsNewEntity(), getVm().getOs(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#end_block

#method_before
@Override
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(getImagesActionType(), p);
    }
}
#method_after
@Override
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(getImagesActionType(), p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#end_block

#method_before
private void removeMemoryVolumes(String memoryVolume, Guid vmId) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryVolume, vmId));
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes: {0}", memoryVolume);
    }
}
#method_after
private void removeMemoryVolumes(String memoryVolume, Guid vmId) {
    VdcReturnValueBase retVal = runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryVolume, vmId), cloneContextAndDetachFromParent());
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes: {0}", memoryVolume);
    }
}
#end_block

#method_before
protected void removeVmNetworkInterfaces() {
    new VmInterfaceManager().removeAll(getVmId());
}
#method_after
protected void removeVmNetworkInterfaces() {
    new VmInterfaceManager(getMacPool()).removeAll(getVmId());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    List<String> macsToRemove = getVmNicDao().getAllMacsByDataCenter(getStoragePool().getId());
    removeNetworks();
    /**
     * Detach master storage domain last.
     */
    List<StorageDomain> storageDomains = getStorageDomainDAO().getAllForStoragePool(getStoragePool().getId());
    Collections.sort(storageDomains, new Comparator<StorageDomain>() {

        @Override
        public int compare(StorageDomain o1, StorageDomain o2) {
            return o1.getStorageDomainType().compareTo(o2.getStorageDomainType());
        }
    });
    if (storageDomains.size() > 0) {
        if (!getParameters().getForceDelete() && getAllRunningVdssInPool().size() > 0) {
            if (!regularRemoveStorageDomains(storageDomains)) {
                setSucceeded(false);
                return;
            }
        } else if (getParameters().getForceDelete()) {
            forceRemoveStorageDomains(storageDomains);
        } else {
            return;
        }
    }
    removeDataCenter();
    getMacPoolForDataCenter().freeMacs(macsToRemove);
    MacPoolPerDc.getInstance().removePool(getStoragePoolId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    List<String> macsToRemove = getVmNicDao().getAllMacsByDataCenter(getStoragePool().getId());
    removeNetworks();
    /**
     * Detach master storage domain last.
     */
    List<StorageDomain> storageDomains = getStorageDomainDAO().getAllForStoragePool(getStoragePool().getId());
    Collections.sort(storageDomains, new Comparator<StorageDomain>() {

        @Override
        public int compare(StorageDomain o1, StorageDomain o2) {
            return o1.getStorageDomainType().compareTo(o2.getStorageDomainType());
        }
    });
    if (storageDomains.size() > 0) {
        if (!getParameters().getForceDelete() && getAllRunningVdssInPool().size() > 0) {
            if (!regularRemoveStorageDomains(storageDomains)) {
                setSucceeded(false);
                return;
            }
        } else if (getParameters().getForceDelete()) {
            forceRemoveStorageDomains(storageDomains);
        } else {
            return;
        }
    }
    removeDataCenter();
    getMacPool().freeMacs(macsToRemove);
    setSucceeded(true);
}
#end_block

#method_before
private boolean regularRemoveStorageDomains(List<StorageDomain> storageDomains) {
    boolean retVal = true;
    List<StorageDomain> temp = LinqUtils.filter(storageDomains, new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain storage_domain) {
            return storage_domain.getStorageDomainType() == StorageDomainType.Master;
        }
    });
    final StorageDomain masterDomain = LinqUtils.first(temp);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(masterDomain.getStoragePoolIsoMapData());
            masterDomain.setStatus(StorageDomainStatus.Locked);
            getDbFacade().getStoragePoolIsoMapDao().update(masterDomain.getStoragePoolIsoMapData());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // destroying a pool is an SPM action. We need to connect all hosts
    // to the pool. Later on, during spm election, one of the hosts will
    // lock the pool
    // and the spm status will be FREE. Only then we can invoke the
    // destroy verb.
    connectAllHostToPoolAndDomain(masterDomain);
    List<VDS> vdss = getAllRunningVdssInPool();
    for (StorageDomain storageDomain : storageDomains) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            if (!removeDomainFromPool(storageDomain, vdss.get(0))) {
                log.errorFormat("Unable to detach storage domain {0} {1}", storageDomain.getStorageName(), storageDomain.getId());
                retVal = false;
            }
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            detachStorageDomainWithEntities(masterDomain);
            getCompensationContext().snapshotEntity(masterDomain.getStorageStaticData());
            masterDomain.setStorageDomainType(StorageDomainType.Data);
            getDbFacade().getStorageDomainStaticDao().update(masterDomain.getStorageStaticData());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    handleDestroyStoragePoolCommand();
    setSucceeded(true);
    if (!getStoragePool().isLocal()) {
        for (VDS vds : vdss) {
            StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vds.getId());
        }
    } else {
        try {
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FormatStorageDomain, new FormatStorageDomainVDSCommandParameters(vdss.get(0).getId(), masterDomain.getId()));
        } catch (VdcBLLException e) {
        // Do nothing, exception already printed at logs
        }
        StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vdss.get(0).getId());
        removeDomainFromDb(masterDomain);
    }
    runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    return retVal;
}
#method_after
private boolean regularRemoveStorageDomains(List<StorageDomain> storageDomains) {
    boolean retVal = true;
    List<StorageDomain> temp = LinqUtils.filter(storageDomains, new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain storage_domain) {
            return storage_domain.getStorageDomainType() == StorageDomainType.Master;
        }
    });
    final StorageDomain masterDomain = LinqUtils.first(temp);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(masterDomain.getStoragePoolIsoMapData());
            masterDomain.setStatus(StorageDomainStatus.Locked);
            getDbFacade().getStoragePoolIsoMapDao().update(masterDomain.getStoragePoolIsoMapData());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // destroying a pool is an SPM action. We need to connect all hosts
    // to the pool. Later on, during spm election, one of the hosts will
    // lock the pool
    // and the spm status will be FREE. Only then we can invoke the
    // destroy verb.
    connectAllHostToPoolAndDomain(masterDomain);
    List<VDS> vdss = getAllRunningVdssInPool();
    for (StorageDomain storageDomain : storageDomains) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            if (!removeDomainFromPool(storageDomain, vdss.get(0))) {
                log.errorFormat("Unable to detach storage domain {0} {1}", storageDomain.getStorageName(), storageDomain.getId());
                retVal = false;
            }
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            detachStorageDomainWithEntities(masterDomain);
            getCompensationContext().snapshotEntity(masterDomain.getStorageStaticData());
            masterDomain.setStorageDomainType(StorageDomainType.Data);
            getDbFacade().getStorageDomainStaticDao().update(masterDomain.getStorageStaticData());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    handleDestroyStoragePoolCommand();
    setSucceeded(true);
    if (!getStoragePool().isLocal()) {
        for (VDS vds : vdss) {
            StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vds.getId());
        }
    } else {
        try {
            runVdsCommand(VDSCommandType.FormatStorageDomain, new FormatStorageDomainVDSCommandParameters(vdss.get(0).getId(), masterDomain.getId()));
        } catch (VdcBLLException e) {
        // Do nothing, exception already printed at logs
        }
        StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vdss.get(0).getId());
        removeDomainFromDb(masterDomain);
    }
    runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    return retVal;
}
#end_block

#method_before
private void handleDestroyStoragePoolCommand() {
    try {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DestroyStoragePool, new IrsBaseVDSCommandParameters(getStoragePool().getId()));
    } catch (VdcBLLException e) {
        try {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
                    return null;
                }
            });
        } catch (Exception e1) {
            log.errorFormat("Failed destroy storage pool with id {0} and after that failed to stop spm because of {1}", getStoragePoolId(), e1);
        }
        throw e;
    }
}
#method_after
private void handleDestroyStoragePoolCommand() {
    try {
        runVdsCommand(VDSCommandType.DestroyStoragePool, new IrsBaseVDSCommandParameters(getStoragePool().getId()));
    } catch (VdcBLLException e) {
        try {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
                    return null;
                }
            });
        } catch (Exception e1) {
            log.errorFormat("Failed destroy storage pool with id {0} and after that failed to stop spm because of {1}", getStoragePoolId(), e1);
        }
        throw e;
    }
}
#end_block

#method_before
protected boolean removeDomainFromPool(StorageDomain storageDomain, VDS vds) {
    if (storageDomain.getStorageType() != StorageType.LOCALFS || storageDomain.getStorageDomainType() == StorageDomainType.ISO) {
        DetachStorageDomainFromPoolParameters tempVar = new DetachStorageDomainFromPoolParameters(storageDomain.getId(), getStoragePool().getId());
        tempVar.setRemoveLast(true);
        tempVar.setDestroyingPool(true);
        // in detach of one of storage domains
        if (!Backend.getInstance().runInternalAction(VdcActionType.DetachStorageDomainFromPool, tempVar).getSucceeded()) {
            return false;
        }
    } else {
        RemoveStorageDomainParameters tempVar = new RemoveStorageDomainParameters(storageDomain.getId());
        tempVar.setDestroyingPool(true);
        tempVar.setDoFormat(true);
        tempVar.setVdsId(vds.getId());
        if (!Backend.getInstance().runInternalAction(VdcActionType.RemoveStorageDomain, tempVar, new CommandContext(getCompensationContext())).getSucceeded()) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean removeDomainFromPool(StorageDomain storageDomain, VDS vds) {
    if (storageDomain.getStorageType() != StorageType.LOCALFS || storageDomain.getStorageDomainType() == StorageDomainType.ISO) {
        DetachStorageDomainFromPoolParameters tempVar = new DetachStorageDomainFromPoolParameters(storageDomain.getId(), getStoragePool().getId());
        tempVar.setRemoveLast(true);
        tempVar.setDestroyingPool(true);
        // in detach of one of storage domains
        if (!Backend.getInstance().runInternalAction(VdcActionType.DetachStorageDomainFromPool, tempVar).getSucceeded()) {
            return false;
        }
    } else {
        RemoveStorageDomainParameters tempVar = new RemoveStorageDomainParameters(storageDomain.getId());
        tempVar.setDestroyingPool(true);
        tempVar.setDoFormat(true);
        tempVar.setVdsId(vds.getId());
        if (!runInternalAction(VdcActionType.RemoveStorageDomain, tempVar, cloneContext().withoutLock().withoutExecutionContext()).getSucceeded()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public void initialize() {
    lockObj.writeLock().lock();
    try {
        if (initialized) {
            log.error("Trying to initialized " + getClass().getName() + " multiple times.");
            return;
        }
        log.infoFormat("Start initializing " + getClass().getSimpleName());
        this.macsStorage = createMacsStorage(rangesBoundaries);
        onInit();
        initialized = true;
        log.infoFormat("Finished initializing. Available MACs in pool: {0}", macsStorage.getAvailableMacsCount());
    } catch (Exception ex) {
        log.errorFormat("Error in initializing MAC Addresses pool manager.", ex);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public void initialize() {
    try (AutoCloseableLock l = new AutoCloseableLock(lockObj.writeLock())) {
        if (initialized) {
            log.error("Trying to initialized " + getClass().getName() + " multiple times.");
            return;
        }
        log.infoFormat("Start initializing " + getClass().getSimpleName());
        this.macsStorage = createMacsStorage(rangesBoundaries);
        initialized = true;
        log.infoFormat("Finished initializing. Available MACs in pool: {0}", macsStorage.getAvailableMacsCount());
    } catch (Exception ex) {
        log.errorFormat("Error in initializing MAC Addresses pool manager.", ex);
    }
}
#end_block

#method_before
@Override
public String allocateNewMac() {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        return allocateNewMacsWithoutLocking(1).get(0);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public String allocateNewMac() {
    try (AutoCloseableLock l = new AutoCloseableLock(lockObj.writeLock())) {
        checkIfInitialized();
        return allocateNewMacsWithoutLocking(1).get(0);
    }
}
#end_block

#method_before
@Override
public int getAvailableMacsCount() {
    lockObj.readLock().lock();
    try {
        checkIfInitialized();
        int availableMacsSize = macsStorage.getAvailableMacsCount();
        log.debugFormat("Number of available Mac addresses = {1}", availableMacsSize);
        return availableMacsSize;
    } finally {
        lockObj.readLock().unlock();
    }
}
#method_after
@Override
public int getAvailableMacsCount() {
    try (AutoCloseableLock l = new AutoCloseableLock(lockObj.readLock())) {
        checkIfInitialized();
        int availableMacsSize = macsStorage.getAvailableMacsCount();
        log.debugFormat("Number of available Mac addresses = {1}", availableMacsSize);
        return availableMacsSize;
    }
}
#end_block

#method_before
@Override
public void freeMac(String mac) {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        macsStorage.freeMac(MacAddressRangeUtils.macToLong(mac));
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public void freeMac(String mac) {
    try (AutoCloseableLock l = new AutoCloseableLock(lockObj.writeLock())) {
        checkIfInitialized();
        macsStorage.freeMac(MacAddressRangeUtils.macToLong(mac));
    }
}
#end_block

#method_before
@Override
public boolean addMac(String mac) {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        boolean added = macsStorage.useMac(MacAddressRangeUtils.macToLong(mac));
        logWhenMacPoolIsEmpty();
        return added;
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public boolean addMac(String mac) {
    try (AutoCloseableLock l = new AutoCloseableLock(lockObj.writeLock())) {
        checkIfInitialized();
        boolean added = macsStorage.useMac(MacAddressRangeUtils.macToLong(mac));
        logWhenMacPoolIsEmpty();
        return added;
    }
}
#end_block

#method_before
@Override
public void forceAddMac(String mac) {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        forceAddMacWithoutLocking(mac);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public void forceAddMac(String mac) {
    try (AutoCloseableLock l = new AutoCloseableLock(lockObj.writeLock())) {
        checkIfInitialized();
        forceAddMacWithoutLocking(mac);
    }
}
#end_block

#method_before
@Override
public boolean isMacInUse(String mac) {
    lockObj.readLock().lock();
    try {
        checkIfInitialized();
        return macsStorage.isMacInUse(MacAddressRangeUtils.macToLong(mac));
    } finally {
        lockObj.readLock().unlock();
    }
}
#method_after
@Override
public boolean isMacInUse(String mac) {
    try (AutoCloseableLock l = new AutoCloseableLock(lockObj.readLock())) {
        checkIfInitialized();
        return macsStorage.isMacInUse(MacAddressRangeUtils.macToLong(mac));
    }
}
#end_block

#method_before
@Override
public void freeMacs(List<String> macs) {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        for (String mac : macs) {
            macsStorage.freeMac(MacAddressRangeUtils.macToLong(mac));
        }
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public void freeMacs(List<String> macs) {
    try (AutoCloseableLock l = new AutoCloseableLock(lockObj.writeLock())) {
        checkIfInitialized();
        for (String mac : macs) {
            macsStorage.freeMac(MacAddressRangeUtils.macToLong(mac));
        }
    }
}
#end_block

#method_before
@Override
public List<String> allocateMacAddresses(int numberOfAddresses) {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        return allocateNewMacsWithoutLocking(numberOfAddresses);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public List<String> allocateMacAddresses(int numberOfAddresses) {
    try (AutoCloseableLock l = new AutoCloseableLock(lockObj.writeLock())) {
        checkIfInitialized();
        return allocateNewMacsWithoutLocking(numberOfAddresses);
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    setVmName(getVmStaticDAO().get(getParameters().getVmId()).getName());
    VmNic iface = getVmNicDao().get(getParameters().getInterfaceId());
    if (iface != null) {
        new ExternalNetworkManager(iface).deallocateIfExternal();
        // return mac to pool
        getMacPoolForVmNic(iface).freeMac(iface.getMacAddress());
        interfaceName = iface.getName();
        // Get Interface type.
        String interType = VmInterfaceType.forValue(iface.getType()).getDescription();
        if (interType != null) {
            addCustomValue("InterfaceType", interType);
        }
    }
    // remove from db
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getVmNicDao().remove(getParameters().getInterfaceId());
            getDbFacade().getVmNetworkStatisticsDao().remove(getParameters().getInterfaceId());
            getDbFacade().getVmDeviceDao().remove(new VmDeviceId(getParameters().getInterfaceId(), getParameters().getVmId()));
            setSucceeded(true);
            return null;
        }
    });
}
#method_after
@Override
protected void executeVmCommand() {
    this.setVmName(getVmStaticDAO().get(getParameters().getVmId()).getName());
    VmNic iface = getVmNicDao().get(getParameters().getInterfaceId());
    if (iface != null) {
        interfaceName = iface.getName();
        // Get Interface type.
        String interType = VmInterfaceType.forValue(iface.getType()).getDescription();
        if (interType != null) {
            addCustomValue("InterfaceType", interType);
        }
        new ExternalNetworkManager(iface).deallocateIfExternal();
        // return mac to pool
        getMacPool().freeMac(iface.getMacAddress());
    }
    // remove from db
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getVmNicDao().remove(getParameters().getInterfaceId());
            getDbFacade().getVmNetworkStatisticsDao().remove(getParameters().getInterfaceId());
            getDbFacade().getVmDeviceDao().remove(new VmDeviceId(getParameters().getInterfaceId(), getParameters().getVmId()));
            setSucceeded(true);
            return null;
        }
    });
}
#end_block

#method_before
@Test
public void insufficientDiskSpace() {
    final int lotsOfSpace = 1073741824;
    final ImportVmCommand<ImportVmParameters> c = setupDiskSpaceTest(lotsOfSpace);
    assertFalse(c.canDoAction());
    assertTrue(c.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN.toString()));
}
#method_after
@Test
public void insufficientDiskSpace() {
    final int lotsOfSpace = 1073741824;
    final ImportVmCommand<ImportVmParameters> c = setupDiskSpaceTest(lotsOfSpace);
    assertFalse(c.canDoAction());
    assertTrue(c.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN.toString()));
}
#end_block

#method_before
private ImportVmCommand<ImportVmParameters> setupDiskSpaceTest(final int diskSpaceRequired) {
    mcr.mockConfigValue(ConfigValues.FreeSpaceCriticalLowInGB, diskSpaceRequired);
    ImportVmCommand<ImportVmParameters> cmd = spy(new ImportVmCommand<ImportVmParameters>(createParameters()));
    doReturn(true).when(cmd).validateNoDuplicateVm();
    doReturn(true).when(cmd).validateVdsCluster();
    doReturn(true).when(cmd).validateUsbPolicy();
    doReturn(true).when(cmd).canAddVm();
    doReturn(true).when(cmd).checkTemplateInStorageDomain();
    doReturn(true).when(cmd).checkImagesGUIDsLegal();
    doReturn(true).when(cmd).validateNoDuplicateDiskImages(any(Iterable.class));
    doReturn(createSourceDomain()).when(cmd).getSourceDomain();
    doReturn(createStorageDomain()).when(cmd).getStorageDomain(any(Guid.class));
    doReturn(Collections.<VM>singletonList(createVM())).when(cmd).getVmsFromExportDomain();
    doReturn(new VmTemplate()).when(cmd).getVmTemplate();
    doReturn(new StoragePool()).when(cmd).getStoragePool();
    doReturn(new VDSGroup()).when(cmd).getVdsGroup();
    return cmd;
}
#method_after
private ImportVmCommand<ImportVmParameters> setupDiskSpaceTest(final int diskSpaceRequired) {
    mcr.mockConfigValue(ConfigValues.FreeSpaceCriticalLowInGB, diskSpaceRequired);
    ImportVmCommand<ImportVmParameters> cmd = spy(new ImportVmCommand<ImportVmParameters>(createParameters()));
    doReturn(true).when(cmd).validateNoDuplicateVm();
    doReturn(true).when(cmd).validateVdsCluster();
    doReturn(true).when(cmd).validateUsbPolicy();
    doReturn(true).when(cmd).canAddVm();
    doReturn(true).when(cmd).checkTemplateInStorageDomain();
    doReturn(true).when(cmd).checkImagesGUIDsLegal();
    doReturn(true).when(cmd).validateNoDuplicateDiskImages(any(Iterable.class));
    doReturn(createSourceDomain()).when(cmd).getSourceDomain();
    doReturn(createStorageDomain()).when(cmd).getStorageDomain(any(Guid.class));
    doReturn(Collections.<VM>singletonList(createVM())).when(cmd).getVmsFromExportDomain();
    doReturn(new VmTemplate()).when(cmd).getVmTemplate();
    doReturn(new StoragePool()).when(cmd).getStoragePool();
    doReturn(new VDSGroup()).when(cmd).getVdsGroup();
    doReturn(macPoolManagerStrategy).when(cmd).getMacPool();
    return cmd;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#end_block

#method_before
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.verifyAddVm(reasons, getVmInterfaces().size(), vmPriority, getMacPoolForDataCenter());
}
#method_after
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.verifyAddVm(reasons, getVmInterfaces().size(), vmPriority, getMacPool());
}
#end_block

#method_before
protected void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        WatchdogParameters parameters = new WatchdogParameters();
        parameters.setId(getParameters().getVmId());
        parameters.setAction(vmWatchdog.getAction());
        parameters.setModel(vmWatchdog.getModel());
        getBackend().runInternalAction(VdcActionType.AddWatchdog, parameters);
    }
}
#method_after
protected void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        WatchdogParameters parameters = new WatchdogParameters();
        parameters.setId(getParameters().getVmId());
        parameters.setAction(vmWatchdog.getAction());
        parameters.setModel(vmWatchdog.getModel());
        runInternalAction(VdcActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
    }
}
#end_block

#method_before
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.AddRngDevice, params);
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#method_after
private void addVmRngDevice() {
    VmRngDevice rngDev = getParameters().getRngDevice();
    if (rngDev != null) {
        rngDev.setVmId(getVmId());
        RngDeviceParameters params = new RngDeviceParameters(rngDev, true);
        VdcReturnValueBase result = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            log.error("Couldn't add RNG device for new VM.");
            throw new IllegalArgumentException("Couldn't add RNG device for new VM.");
        }
    }
}
#end_block

#method_before
private void copyDiskDevicesFromTemplate() {
    List<VmDevice> disks = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vmDisksSource.getId(), VmDeviceGeneralType.DISK);
    VmDeviceUtils.copyVmDevices(vmDisksSource.getId(), getVmId(), getVm(), getVm().getStaticData(), true, disks, getSrcDeviceIdToTargetDeviceIdMapping(), false, false, false, false, false);
}
#method_after
private void copyDiskDevicesFromTemplate() {
    List<VmDevice> disks = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmDisksSource.getId(), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName());
    VmDeviceUtils.copyDiskDevices(getVmId(), disks, getSrcDeviceIdToTargetDeviceIdMapping());
}
#end_block

#method_before
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = getMacPoolForDataCenter().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(getMacPool());
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = getMacPool().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        updateProfileOnNic(iface);
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
protected boolean addVmImages() {
    if (vmDisksSource.getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (vmDisksSource.getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, tempVar);
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#end_block

#method_before
private boolean activateOrDeactivateNic(VmNic nic, PlugAction plugAction, boolean newNic) {
    ActivateDeactivateVmNicParameters parameters = new ActivateDeactivateVmNicParameters(nic, plugAction, newNic);
    parameters.setVmId(getParameters().getVmId());
    VdcReturnValueBase returnValue = getBackend().runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameters);
    if (!returnValue.getSucceeded()) {
        propagateFailure(returnValue);
    }
    return returnValue.getSucceeded();
}
#method_after
private boolean activateOrDeactivateNic(VmNic nic, PlugAction plugAction, boolean newNic) {
    ActivateDeactivateVmNicParameters parameters = new ActivateDeactivateVmNicParameters(nic, plugAction, newNic);
    parameters.setVmId(getParameters().getVmId());
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameters, cloneContextAndDetachFromParent());
    if (!returnValue.getSucceeded()) {
        propagateFailure(returnValue);
    }
    return returnValue.getSucceeded();
}
#end_block

#method_before
protected boolean addMacToPool(String macAddress, MacPoolManagerStrategy macPool) {
    if (macPool.addMac(macAddress)) {
        return true;
    } else {
        throw new VdcBLLException(VdcBllErrors.MAC_ADDRESS_IS_IN_USE);
    }
}
#method_after
protected boolean addMacToPool(String macAddress) {
    if (getMacPool().addMac(macAddress)) {
        return true;
    } else {
        throw new VdcBLLException(VdcBllErrors.MAC_ADDRESS_IS_IN_USE);
    }
}
#end_block

#method_before
protected ValidationResult macAvailable(MacPoolManagerStrategy macPool) {
    Boolean allowDupMacs = Config.<Boolean>getValue(ConfigValues.AllowDuplicateMacAddresses);
    return macPool.isMacInUse(getMacAddress()) && !allowDupMacs ? new ValidationResult(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE) : ValidationResult.VALID;
}
#method_after
protected ValidationResult macAvailable() {
    Boolean allowDupMacs = Config.<Boolean>getValue(ConfigValues.AllowDuplicateMacAddresses);
    return getMacPool().isMacInUse(getMacAddress()) && !allowDupMacs ? new ValidationResult(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE) : ValidationResult.VALID;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    final DbFacade dbFacadeMock = mock(DbFacade.class);
    storagePoolDaoMock = mock(StoragePoolDAO.class);
    vmNicDaoMock = mock(VmNicDao.class);
    macPoolDaoMock = mock(MacPoolDao.class);
    vmDaoMock = mock(VmDAO.class);
    DbFacadeLocator.setDbFacade(dbFacadeMock);
    when(dbFacadeMock.getStoragePoolDao()).thenReturn(storagePoolDaoMock);
    when(dbFacadeMock.getVmNicDao()).thenReturn(vmNicDaoMock);
    when(dbFacadeMock.getVmDao()).thenReturn(vmDaoMock);
    when(dbFacadeMock.getMacPoolDao()).thenReturn(macPoolDaoMock);
    // reinit ScopedMacPoolManagerInstance -- very ugly,unintended consequence of using static methods instead of DI.
    MacPoolPerDc.INSTANCE = new MacPoolPerDc();
}
#method_after
@Before
public void setUp() throws Exception {
    DbFacadeLocator.setDbFacade(dbFacade);
    when(dbFacade.getStoragePoolDao()).thenReturn(storagePoolDao);
    when(dbFacade.getVmNicDao()).thenReturn(vmNicDao);
    when(dbFacade.getMacPoolDao()).thenReturn(macPoolDao);
    when(dbFacade.getAuditLogDao()).thenReturn(auditLogDao);
    macPool = createMacPool(MAC_FROM, MAC_TO);
    dataCenter = createStoragePool(macPool);
    vmNic = createVmNic();
    pool = new MacPoolPerDc();
}
#end_block

#method_before
@Test
public void testNicIsCorrectlyAllocatedInScopedPool() throws Exception {
    final MacPool macPool = createMacPool("00:1a:4a:15:c0:00", "00:1a:4a:15:c0:ff");
    final StoragePool storagePool = createStoragePool(macPool);
    when(storagePoolDaoMock.getAll()).thenReturn(Collections.singletonList(storagePool));
    // mock existing vmNics
    final String macAddress = "00:1a:4a:15:c0:fe";
    final VmNic vmNic = new VmNic();
    vmNic.setMacAddress(macAddress);
    // when(vmNicDaoMock.getAll()).thenReturn(Collections.singletonList(vmNic));
    // mock querying for existing mac addresses for given data center.
    when(macPoolDaoMock.getAllMacsForMacPool(eq(storagePool.getMacPoolId()))).thenReturn(Collections.singletonList(macAddress));
    // mock all available pools
    when(macPoolDaoMock.getAll()).thenReturn(Collections.singletonList(macPool));
    // mock obtaining storagepool by id.
    when(storagePoolDaoMock.get(eq(storagePool.getId()))).thenReturn(storagePool);
    // mock existing vms
    final VM vm = new VM();
    vm.setStoragePoolId(storagePool.getId());
    when(vmDaoMock.get(any(Guid.class))).thenReturn(vm);
    MacPoolPerDc.INSTANCE.initialize();
    assertThat("scoped pool for this nic should exist", MacPoolPerDc.INSTANCE.poolForVmNic(vmNic), notNullValue());
    assertThat("provided mac should be used in returned pool", MacPoolPerDc.INSTANCE.poolForVmNic(vmNic).isMacInUse(macAddress), is(true));
}
#method_after
@Test
public void testNicIsCorrectlyAllocatedInScopedPool() throws Exception {
    mockStoragePool(dataCenter);
    mockGettingAllMacPools(macPool);
    mockAllMacsForStoragePool(dataCenter, vmNic.getMacAddress());
    pool.initialize();
    assertThat("scoped pool for this nic should exist", pool.poolForDataCenter(dataCenter.getId()), is(notNullValue()));
    assertThat("provided mac should be used in returned pool", pool.poolForDataCenter(dataCenter.getId()).isMacInUse(vmNic.getMacAddress()), is(true));
}
#end_block

#method_before
@Override
public void initialize() {
    lockObj.writeLock().lock();
    try {
        if (initialized) {
            log.error("Trying to initialized " + getClass().getName() + " multiple times.");
            return;
        }
        log.infoFormat("Start initializing " + getClass().getSimpleName());
        this.macsStorage = createMacsStorage(rangesBoundaries);
        onInit();
        initialized = true;
        log.infoFormat("Finished initializing. Available MACs in pool: {0}", macsStorage.getAvailableMacsCount());
    } catch (Exception ex) {
        log.errorFormat("Error in initializing MAC Addresses pool manager.", ex);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public void initialize() {
    try (AutoCloseableLock l = new AutoCloseableLock(lockObj.writeLock())) {
        if (initialized) {
            log.error("Trying to initialized " + getClass().getName() + " multiple times.");
            return;
        }
        log.infoFormat("Start initializing " + getClass().getSimpleName());
        this.macsStorage = createMacsStorage(rangesBoundaries);
        onInit();
        initialized = true;
        log.infoFormat("Finished initializing. Available MACs in pool: {0}", macsStorage.getAvailableMacsCount());
    } catch (Exception ex) {
        log.errorFormat("Error in initializing MAC Addresses pool manager.", ex);
    }
}
#end_block

#method_before
@Override
public String allocateNewMac() {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        return allocateNewMacsWithoutLocking(1).get(0);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public String allocateNewMac() {
    try (AutoCloseableLock l = new AutoCloseableLock(lockObj.writeLock())) {
        checkIfInitialized();
        return allocateNewMacsWithoutLocking(1).get(0);
    }
}
#end_block

#method_before
@Override
public int getAvailableMacsCount() {
    lockObj.readLock().lock();
    try {
        checkIfInitialized();
        int availableMacsSize = macsStorage.getAvailableMacsCount();
        log.debugFormat("Number of available Mac addresses = {1}", availableMacsSize);
        return availableMacsSize;
    } finally {
        lockObj.readLock().unlock();
    }
}
#method_after
@Override
public int getAvailableMacsCount() {
    try (AutoCloseableLock l = new AutoCloseableLock(lockObj.readLock())) {
        checkIfInitialized();
        int availableMacsSize = macsStorage.getAvailableMacsCount();
        log.debugFormat("Number of available Mac addresses = {1}", availableMacsSize);
        return availableMacsSize;
    }
}
#end_block

#method_before
@Override
public void freeMac(String mac) {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        macsStorage.freeMac(MacAddressRangeUtils.macToLong(mac));
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public void freeMac(String mac) {
    try (AutoCloseableLock l = new AutoCloseableLock(lockObj.writeLock())) {
        checkIfInitialized();
        macsStorage.freeMac(MacAddressRangeUtils.macToLong(mac));
    }
}
#end_block

#method_before
@Override
public boolean addMac(String mac) {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        boolean added = macsStorage.useMac(MacAddressRangeUtils.macToLong(mac));
        logWhenMacPoolIsEmpty();
        return added;
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public boolean addMac(String mac) {
    try (AutoCloseableLock l = new AutoCloseableLock(lockObj.writeLock())) {
        checkIfInitialized();
        boolean added = macsStorage.useMac(MacAddressRangeUtils.macToLong(mac));
        logWhenMacPoolIsEmpty();
        return added;
    }
}
#end_block

#method_before
@Override
public void forceAddMac(String mac) {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        forceAddMacWithoutLocking(mac);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public void forceAddMac(String mac) {
    try (AutoCloseableLock l = new AutoCloseableLock(lockObj.writeLock())) {
        checkIfInitialized();
        forceAddMacWithoutLocking(mac);
    }
}
#end_block

#method_before
@Override
public boolean isMacInUse(String mac) {
    lockObj.readLock().lock();
    try {
        checkIfInitialized();
        return macsStorage.isMacInUse(MacAddressRangeUtils.macToLong(mac));
    } finally {
        lockObj.readLock().unlock();
    }
}
#method_after
@Override
public boolean isMacInUse(String mac) {
    try (AutoCloseableLock l = new AutoCloseableLock(lockObj.readLock())) {
        checkIfInitialized();
        return macsStorage.isMacInUse(MacAddressRangeUtils.macToLong(mac));
    }
}
#end_block

#method_before
@Override
public void freeMacs(List<String> macs) {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        for (String mac : macs) {
            macsStorage.freeMac(MacAddressRangeUtils.macToLong(mac));
        }
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public void freeMacs(List<String> macs) {
    try (AutoCloseableLock l = new AutoCloseableLock(lockObj.writeLock())) {
        checkIfInitialized();
        for (String mac : macs) {
            macsStorage.freeMac(MacAddressRangeUtils.macToLong(mac));
        }
    }
}
#end_block

#method_before
@Override
public List<String> allocateMacAddresses(int numberOfAddresses) {
    lockObj.writeLock().lock();
    try {
        checkIfInitialized();
        return allocateNewMacsWithoutLocking(numberOfAddresses);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
@Override
public List<String> allocateMacAddresses(int numberOfAddresses) {
    try (AutoCloseableLock l = new AutoCloseableLock(lockObj.writeLock())) {
        checkIfInitialized();
        return allocateNewMacsWithoutLocking(numberOfAddresses);
    }
}
#end_block

#method_before
public final void initialize() {
    lockObj.writeLock().lock();
    try {
        if (initialized) {
            LOGGER.error("Trying to initialized " + getClass().getName() + " multiple times.");
            return;
        }
        final List<MacPool> macPools = getMacPoolDao().getAll();
        for (MacPool macPool : macPools) {
            initializeMacPool(macPool);
        }
        initialized = true;
    } catch (Throwable t) {
        LOGGER.error("MAC pool not initialized.");
        throw t;
    } finally {
        LOGGER.info("MAC pool successfully initialized");
        lockObj.writeLock().unlock();
    }
}
#method_after
public final void initialize() {
    try (AutoCloseableLock lock = writeLockResource()) {
        if (initialized) {
            log.error("Trying to initialize multiple times.");
            return;
        }
        final List<MacPool> macPools = getMacPoolDao().getAll();
        for (MacPool macPool : macPools) {
            initializeMacPool(macPool);
        }
        initialized = true;
        log.info("successfully initialized");
    } catch (RuntimeException e) {
        log.error("not initialized.");
        throw e;
    }
}
#end_block

#method_before
public MacPoolManagerStrategy poolForDataCenter(Guid dataCenterId) {
    lockObj.readLock().lock();
    try {
        checkInitialized();
        return getPoolWithoutLocking(getMacPoolId(dataCenterId));
    } finally {
        lockObj.readLock().unlock();
    }
}
#method_after
public MacPoolManagerStrategy poolForDataCenter(Guid dataCenterId) {
    try (AutoCloseableLock lock = readLockResource()) {
        checkInitialized();
        return getPoolWithoutLocking(getMacPoolId(dataCenterId));
    }
}
#end_block

#method_before
protected Guid getMacPoolId(Guid dataCenterId) {
    final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(dataCenterId);
    return storagePool == null ? null : storagePool.getMacPoolId();
}
#method_after
private Guid getMacPoolId(Guid dataCenterId) {
    final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(dataCenterId);
    return storagePool == null ? null : storagePool.getMacPoolId();
}
#end_block

#method_before
public final void createPool(MacPool macPool) {
    lockObj.writeLock().lock();
    try {
        checkInitialized();
        createPoolWithoutLocking(macPool);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
public final void createPool(MacPool macPool) {
    try (AutoCloseableLock lock = writeLockResource()) {
        checkInitialized();
        createPoolWithoutLocking(macPool);
    }
}
#end_block

#method_before
private MacPoolManagerStrategy createPoolWithoutLocking(MacPool macPool) {
    MacPoolManagerStrategy poolForScope = createAndInitPool(macPool);
    macPools.put(macPool.getId(), poolForScope);
    return poolForScope;
}
#method_after
private MacPoolManagerStrategy createPoolWithoutLocking(MacPool macPool) {
    if (macPools.containsKey(macPool.getId())) {
        throw new IllegalStateException(UNABLE_TO_CREATE_MAC_POOL_IT_ALREADY_EXIST);
    }
    MacPoolManagerStrategy poolForScope = new MacPoolManagerRanges(macPoolToRanges(macPool), macPool.isAllowDuplicateMacAddresses());
    poolForScope.initialize();
    macPools.put(macPool.getId(), poolForScope);
    return poolForScope;
}
#end_block

#method_before
public final void modifyPool(MacPool macPool) {
    lockObj.writeLock().lock();
    try {
        checkInitialized();
        removeWithoutLocking(macPool.getId());
        initializeMacPool(macPool);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
public final void modifyPool(MacPool macPool) {
    try (AutoCloseableLock lock = writeLockResource()) {
        checkInitialized();
        if (!macPools.containsKey(macPool.getId())) {
            throw new IllegalStateException(INEXISTENT_POOL_EXCEPTION_MESSAGE);
        }
        removeWithoutLocking(macPool.getId());
        initializeMacPool(macPool);
    }
}
#end_block

#method_before
public void removePool(Guid macPoolId) {
    lockObj.writeLock().lock();
    try {
        removeWithoutLocking(macPoolId);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
public void removePool(Guid macPoolId) {
    try (AutoCloseableLock lock = writeLockResource()) {
        checkInitialized();
        removeWithoutLocking(macPoolId);
    }
}
#end_block

#method_before
private void addAuditLogForRemovedNetowrks(Set<Guid> removedNetworks) {
    List<String> networkrNames = new ArrayList<>();
    for (Guid networkId : removedNetworks) {
        Network network = getDbFacade().getNetworkDao().get(networkId);
        networkrNames.add(network.getName());
    }
    addCustomValue("NetowrkNames", StringUtils.join(networkrNames, ","));
    addCustomValue("IscsiBondName", getIscsiBond().getName());
    AuditLogDirector.log(this, AuditLogType.USER_FAILED_HOTPLUG_DISK);
}
#method_after
private void addAuditLogForRemovedNetowrks(Set<Guid> removedNetworks) {
    List<String> networkNames = new ArrayList<>();
    for (Guid networkId : removedNetworks) {
        Network network = getDbFacade().getNetworkDao().get(networkId);
        networkNames.add(network.getName());
    }
    addCustomValue("NetworkNames", StringUtils.join(networkNames, ","));
    addCustomValue("IscsiBondName", getIscsiBond().getName());
    AuditLogDirector.log(this, AuditLogType.USER_ISCSI_BOND_HOST_RESTART_WARNING);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    NetworkValidator validator = new NetworkValidator(getNetworkDAO().get(getNetwork().getId()));
    return validate(validator.networkIsSet()) && validate(validator.notManagementNetwork()) && validate(validator.notISCSIBondNetwork()) && validate(validator.networkNotUsedByVms()) && validate(validator.networkNotUsedByTemplates());
}
#method_after
@Override
protected boolean canDoAction() {
    NetworkValidator validator = new NetworkValidator(getNetworkDAO().get(getNetwork().getId()));
    return validate(validator.networkIsSet()) && validate(validator.notManagementNetwork()) && validate(validator.notIscsiBondNetwork()) && validate(validator.networkNotUsedByVms()) && validate(validator.networkNotUsedByTemplates());
}
#end_block

#method_before
@Override
public List<IscsiBond> getIscsiBondsByNetworkId(Guid netowrkId) {
    return getCallsHandler().executeReadList("GetIscsiByNetworkId", IscsiBondRowMapper.instance, getCustomMapSqlParameterSource().addValue("network_id", netowrkId));
}
#method_after
@Override
public List<IscsiBond> getIscsiBondsByNetworkId(Guid netowrkId) {
    return getCallsHandler().executeReadList("GetIscsiBondsByNetworkId", IscsiBondRowMapper.instance, getCustomMapSqlParameterSource().addValue("network_id", netowrkId));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!getVmTemplateId().equals(Guid.Empty) && !isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#end_block

#method_before
protected boolean isTemplateInValidDc() {
    return getVmTemplate().getStoragePoolId().equals(getStoragePoolId());
}
#method_after
protected boolean isTemplateInValidDc() {
    return VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVmTemplateId()) || getVmTemplate().getStoragePoolId().equals(getStoragePoolId());
}
#end_block

#method_before
public ValidationResult isReadOnlyPropertyCompatibleWithInterface() {
    if (Boolean.TRUE.equals(disk.getReadOnly())) {
        DiskInterface diskInterface = disk.getDiskInterface();
        if (diskInterface == DiskInterface.IDE) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR, String.format("$interface %1$s", diskInterface));
        }
        boolean isVirtioScsiDirectLunPassthrough = diskInterface == DiskInterface.VirtIO_SCSI && disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough();
        if (isVirtioScsiDirectLunPassthrough) {
            return new ValidationResult(VdcBllMessages.SCSI_PASSTHROUGH_IS_NOT_SUPPORTED_FOR_READ_ONLY_DISK);
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult isReadOnlyPropertyCompatibleWithInterface() {
    if (Boolean.TRUE.equals(disk.getReadOnly())) {
        DiskInterface diskInterface = disk.getDiskInterface();
        if (diskInterface == DiskInterface.IDE) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR, String.format("$interface %1$s", diskInterface));
        }
        if (disk.isScsiPassthrough()) {
            return new ValidationResult(VdcBllMessages.SCSI_PASSTHROUGH_IS_NOT_SUPPORTED_FOR_READ_ONLY_DISK);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private void disableNonChangeableEntities() {
    getStorageDomain().setIsChangable(false);
    getHost().setIsChangable(false);
    getStorageType().setIsChangable(false);
    getDataCenter().setIsChangable(false);
    getVolumeType().setIsChangable(false);
    getSize().setIsChangable(false);
    if (!isEditEnabled()) {
        getDescription().setIsChangable(false);
        getIsShareable().setIsChangable(false);
        getIsBootable().setIsChangable(false);
        getIsWipeAfterDelete().setIsChangable(false);
        getDiskInterface().setIsChangable(false);
        getIsReadOnly().setIsChangable(false);
    }
}
#method_after
private void disableNonChangeableEntities() {
    getStorageDomain().setIsChangable(false);
    getHost().setIsChangable(false);
    getStorageType().setIsChangable(false);
    getDataCenter().setIsChangable(false);
    getVolumeType().setIsChangable(false);
    getSize().setIsChangable(false);
    if (!isEditEnabled()) {
        getIsShareable().setIsChangable(false);
        getIsBootable().setIsChangable(false);
        getIsWipeAfterDelete().setIsChangable(false);
        getDiskInterface().setIsChangable(false);
        getIsReadOnly().setIsChangable(false);
    }
}
#end_block

#method_before
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getStatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<String>() {

                @Override
                public String runInTransaction() {
                    return gethostFromVds();
                }
            });
            if (host != null) {
                // Get the values of the timeouts:
                int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
                int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
                int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
                irsProxy = TransportFactory.createIrsServer(getProtocol(), host, getmIrsPort(), clientTimeOut, connectionTimeOut, clientRetries);
                runStoragePoolUpEvent(storagePool);
            }
        }
    }
    return getmIrsProxy();
}
#method_after
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getStatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<String>() {

                @Override
                public String runInTransaction() {
                    return gethostFromVds();
                }
            });
            if (host != null) {
                // Get the values of the timeouts:
                int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
                int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
                int heartbeat = Config.<Integer>getValue(ConfigValues.vdsHeartbeatInSeconds) * 1000;
                int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
                irsProxy = TransportFactory.createIrsServer(getProtocol(), host, getmIrsPort(), clientTimeOut, connectionTimeOut, clientRetries, heartbeat);
                runStoragePoolUpEvent(storagePool);
            }
        }
    }
    return getmIrsProxy();
}
#end_block

#method_before
protected UnitVmModel createModel(VmModelBehaviorBase behavior) {
    UnitVmModel model = new UnitVmModel(behavior) {

        @Override
        public EntityModel<Boolean> getIsSingleQxlEnabled() {
            return new EntityModel<Boolean>(true);
        }

        VDSGroup cluster = new VDSGroup();

        {
            cluster.setcompatibility_version(new Version(3, 5));
        }

        @Override
        public VDSGroup getSelectedCluster() {
            return cluster;
        }
    };
    model.initialize(null);
    return model;
}
#method_after
protected UnitVmModel createModel(VmModelBehaviorBase behavior) {
    final VDSGroup cluster = new VDSGroup();
    cluster.setcompatibility_version(Version.v3_5);
    UnitVmModel model = new UnitVmModel(behavior) {

        @Override
        public EntityModel<Boolean> getIsSingleQxlEnabled() {
            return new EntityModel<Boolean>(true);
        }

        @Override
        public VDSGroup getSelectedCluster() {
            return cluster;
        }
    };
    model.initialize(null);
    return model;
}
#end_block

#method_before
@Before
public void setUp() {
    // init the injector with the osRepository instance
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    final int osId = 0;
    Map<Integer, Map<Version, List<DisplayType>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<DisplayType>>());
    displayTypeMap.get(osId).put(null, Arrays.asList(DisplayType.qxl));
    when(osRepository.getDisplayTypes()).thenReturn(displayTypeMap);
    setupTest();
}
#method_after
@Before
public void setUp() throws IOException {
    vmId = Guid.newGuid();
    storageDomainId = Guid.newGuid();
    storagePoolId = Guid.newGuid();
    clusterId = Guid.newGuid();
    // init the injector with the osRepository instance
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    final int osId = 0;
    Map<Integer, Map<Version, List<DisplayType>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<DisplayType>>());
    displayTypeMap.get(osId).put(null, Arrays.asList(DisplayType.qxl));
    when(osRepository.getDisplayTypes()).thenReturn(displayTypeMap);
    mockVdsGroup();
    setXmlOvfData();
}
#end_block

#method_before
@Test
public void testPositiveImportVmFromConfiguration() {
    initCommand(getOvfEntityData());
    doReturn(createStorageDomain()).when(cmd).getStorageDomain();
    doReturn(Boolean.TRUE).when(cmd).canDoActionAfterCloneVm(anyMap());
    doReturn(Boolean.TRUE).when(cmd).canDoActionBeforeCloneVm(anyMap());
    assertTrue(cmd.canDoAction());
}
#method_after
@Test
public void testPositiveImportVmFromConfiguration() {
    initCommand(getOvfEntityData());
    doReturn(createStorageDomain()).when(cmd).getStorageDomain();
    doReturn(Boolean.TRUE).when(cmd).canDoActionAfterCloneVm(anyMap());
    doReturn(Boolean.TRUE).when(cmd).canDoActionBeforeCloneVm(anyMap());
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(cmd);
}
#end_block

#method_before
@Test
public void testImportVMFromConfigurationWhenStorageDomainIsInMaintenance() {
    initCommand(getOvfEntityData());
    StorageDomain storageDomain = createStorageDomain();
    storageDomain.setStatus(StorageDomainStatus.Maintenance);
    doReturn(storageDomain).when(cmd).getStorageDomain();
    assertFalse(cmd.canDoAction());
}
#method_after
@Test
public void testImportVMFromConfigurationWhenStorageDomainIsInMaintenance() {
    initCommand(getOvfEntityData());
    StorageDomain storageDomain = createStorageDomain();
    storageDomain.setStatus(StorageDomainStatus.Maintenance);
    doReturn(storageDomain).when(cmd).getStorageDomain();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2);
}
#end_block

#method_before
@Test
public void testImportVMFromConfigurationWhenStorageDomainIsInactive() {
    initCommand(getOvfEntityData());
    StorageDomain storageDomain = createStorageDomain();
    storageDomain.setStatus(StorageDomainStatus.Inactive);
    doReturn(storageDomain).when(cmd).getStorageDomain();
    assertFalse(cmd.canDoAction());
}
#method_after
@Test
public void testImportVMFromConfigurationWhenStorageDomainIsInactive() {
    initCommand(getOvfEntityData());
    StorageDomain storageDomain = createStorageDomain();
    storageDomain.setStatus(StorageDomainStatus.Inactive);
    doReturn(storageDomain).when(cmd).getStorageDomain();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2);
}
#end_block

#method_before
@Test
public void testImportVMFromConfigurationWhenVMDoesNotExists() {
    initCommand(null);
    assertFalse(cmd.canDoAction());
    Assert.assertTrue(cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_UNSUPPORTED_OVF.toString()));
}
#method_after
@Test
public void testImportVMFromConfigurationWhenVMDoesNotExists() {
    initCommand(null);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_UNSUPPORTED_OVF);
}
#end_block

#method_before
@Test
public void testImportVMFromConfigurationXMLCouldNotGetParsed() {
    OvfEntityData ovfEntity = getOvfEntityData();
    ovfEntity.setOvfData("This is not a valid XML");
    initCommand(ovfEntity);
    when(unregisteredOVFDataDao.getByEntityIdAndStorageDomain(vmId, storageDomainId)).thenReturn(ovfEntity);
    assertFalse(cmd.canDoAction());
    Assert.assertTrue(cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED.toString()));
}
#method_after
@Test
public void testImportVMFromConfigurationXMLCouldNotGetParsed() {
    OvfEntityData ovfEntity = getOvfEntityData();
    ovfEntity.setOvfData("This is not a valid XML");
    initCommand(ovfEntity);
    when(unregisteredOVFDataDao.getByEntityIdAndStorageDomain(vmId, storageDomainId)).thenReturn(ovfEntity);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED);
}
#end_block

#method_before
protected ImportVmParameters createParametersWhenImagesExistOnTargetStorageDomain() {
    ImportVmParameters params = new ImportVmParameters();
    params.setContainerId(vmId);
    params.setStorageDomainId(storageDomainId);
    params.setVdsGroupId(clusterId);
    params.setImagesExistOnTargetStorageDomain(true);
    return params;
}
#method_after
private ImportVmParameters createParametersWhenImagesExistOnTargetStorageDomain() {
    ImportVmParameters params = new ImportVmParameters();
    params.setContainerId(vmId);
    params.setStorageDomainId(storageDomainId);
    params.setVdsGroupId(clusterId);
    params.setImagesExistOnTargetStorageDomain(true);
    return params;
}
#end_block

#method_before
private OvfEntityData getOvfEntityData() {
    OvfEntityData ovfEntity = new OvfEntityData();
    ovfEntity.setEntityId(vmId);
    ovfEntity.setEntityName("Some VM");
    ovfEntity.setOvfData(getVmOvfDataXmlString());
    return ovfEntity;
}
#method_after
private OvfEntityData getOvfEntityData() {
    OvfEntityData ovfEntity = new OvfEntityData();
    ovfEntity.setEntityId(vmId);
    ovfEntity.setEntityName("Some VM");
    ovfEntity.setOvfData(xmlOvfData);
    return ovfEntity;
}
#end_block

#method_before
public static JsonRpcClient createStompClient(String hostname, int port, int connectionTimeout, int clientTimeout, int connectionRetry, int heartBeat, boolean isSecure) {
    return createClient(hostname, port, connectionTimeout, clientTimeout, connectionRetry, heartBeat, isSecure, ReactorType.STOMP);
}
#method_after
public static JsonRpcClient createStompClient(String hostname, int port, int connectionTimeout, int clientTimeout, int connectionRetry, int heartbeat, boolean isSecure) {
    return createClient(hostname, port, connectionTimeout, clientTimeout, connectionRetry, heartbeat, isSecure, ReactorType.STOMP);
}
#end_block

#method_before
private static JsonRpcClient createClient(String hostname, int port, int connectionTimeout, int clientTimeout, int connectionRetry, int heartBeat, boolean isSecure, ReactorType type) {
    final ManagerProvider provider = getManagerProvider(isSecure);
    try {
        final Reactor reactor = ReactorFactory.getReactor(provider, type);
        return getJsonClient(reactor, hostname, port, connectionTimeout, clientTimeout, connectionRetry, heartBeat);
    } catch (ClientConnectionException e) {
        log.error("Exception occured during building ssl context or obtaining selector", e);
        throw new IllegalStateException(e);
    }
}
#method_after
private static JsonRpcClient createClient(String hostname, int port, int connectionTimeout, int clientTimeout, int connectionRetry, int heartbeat, boolean isSecure, ReactorType type) {
    final ManagerProvider provider = getManagerProvider(isSecure);
    try {
        final Reactor reactor = ReactorFactory.getReactor(provider, type);
        return getJsonClient(reactor, hostname, port, connectionTimeout, clientTimeout, connectionRetry, heartbeat);
    } catch (ClientConnectionException e) {
        log.error("Exception occured during building ssl context or obtaining selector", e);
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
private static JsonRpcClient getJsonClient(Reactor reactor, String hostName, int port, int connectionTimeOut, int clientTimeOut, int connectionRetry, int heartBeat) throws ClientConnectionException {
    final ReactorClient client = reactor.createClient(hostName, port);
    client.setRetryPolicy(new RetryPolicy(connectionTimeOut, connectionRetry, heartBeat, IOException.class));
    ResponseWorker worker = ReactorFactory.getWorker();
    JsonRpcClient jsonClient = worker.register(client);
    jsonClient.setRetryPolicy(new RetryPolicy(clientTimeOut, connectionRetry, heartBeat, IOException.class));
    return jsonClient;
}
#method_after
private static JsonRpcClient getJsonClient(Reactor reactor, String hostName, int port, int connectionTimeOut, int clientTimeOut, int connectionRetry, int heartbeat) throws ClientConnectionException {
    final ReactorClient client = reactor.createClient(hostName, port);
    client.setRetryPolicy(new RetryPolicy(connectionTimeOut, connectionRetry, heartbeat, IOException.class));
    ResponseWorker worker = ReactorFactory.getWorker();
    JsonRpcClient jsonClient = worker.register(client);
    jsonClient.setRetryPolicy(new RetryPolicy(clientTimeOut, connectionRetry, heartbeat, IOException.class));
    return jsonClient;
}
#end_block

#method_before
public static IIrsServer createIrsServer(VdsProtocol vdsProtocol, String hostname, int port, int clientTimeOut, int connectionTimeOut, int clientRetries, int heartBeat) {
    IIrsServer irsServer = null;
    if (VdsProtocol.STOMP == vdsProtocol) {
        irsServer = new JsonRpcIIrsServer(JsonRpcUtils.createStompClient(hostname, port, connectionTimeOut, clientTimeOut, clientRetries, heartBeat, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication)));
    } else if (VdsProtocol.XML == vdsProtocol) {
        Pair<IrsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(hostname, port, clientTimeOut, connectionTimeOut, clientRetries, IrsServerConnector.class, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication));
        irsServer = new IrsServerWrapper(returnValue.getFirst(), returnValue.getSecond());
    }
    return irsServer;
}
#method_after
public static IIrsServer createIrsServer(VdsProtocol vdsProtocol, String hostname, int port, int clientTimeOut, int connectionTimeOut, int clientRetries, int heartbeat) {
    IIrsServer irsServer = null;
    if (VdsProtocol.STOMP == vdsProtocol) {
        irsServer = new JsonRpcIIrsServer(JsonRpcUtils.createStompClient(hostname, port, connectionTimeOut, clientTimeOut, clientRetries, heartbeat, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication)));
    } else if (VdsProtocol.XML == vdsProtocol) {
        Pair<IrsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(hostname, port, clientTimeOut, connectionTimeOut, clientRetries, IrsServerConnector.class, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication));
        irsServer = new IrsServerWrapper(returnValue.getFirst(), returnValue.getSecond());
    }
    return irsServer;
}
#end_block

#method_before
public static IVdsServer createVdsServer(VdsProtocol vdsProtocol, String hostname, int port, int clientTimeOut, int connectionTimeOut, int clientRetries, int heartBeat) {
    IVdsServer vdsServer = null;
    if (VdsProtocol.STOMP == vdsProtocol) {
        vdsServer = new JsonRpcVdsServer(JsonRpcUtils.createStompClient(hostname, port, connectionTimeOut, clientTimeOut, clientRetries, heartBeat, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication)));
    } else if (VdsProtocol.XML == vdsProtocol) {
        Pair<VdsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(hostname, port, clientTimeOut, connectionTimeOut, clientRetries, VdsServerConnector.class, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication));
        vdsServer = new VdsServerWrapper(returnValue.getFirst(), returnValue.getSecond());
    }
    return vdsServer;
}
#method_after
public static IVdsServer createVdsServer(VdsProtocol vdsProtocol, String hostname, int port, int clientTimeOut, int connectionTimeOut, int clientRetries, int heartbeat) {
    IVdsServer vdsServer = null;
    if (VdsProtocol.STOMP == vdsProtocol) {
        vdsServer = new JsonRpcVdsServer(JsonRpcUtils.createStompClient(hostname, port, connectionTimeOut, clientTimeOut, clientRetries, heartbeat, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication)));
    } else if (VdsProtocol.XML == vdsProtocol) {
        Pair<VdsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(hostname, port, clientTimeOut, connectionTimeOut, clientRetries, VdsServerConnector.class, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication));
        vdsServer = new VdsServerWrapper(returnValue.getFirst(), returnValue.getSecond());
    }
    return vdsServer;
}
#end_block

#method_before
private void InitVdsBroker() {
    log.infoFormat("Initialize vdsBroker ({0},{1})", _vds.getHostName(), _vds.getPort());
    // Get the values of the timeouts:
    int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
    int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
    int heartBeat = Config.<Integer>getValue(ConfigValues.vdsHeartBeat) * 1000;
    int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
    _vdsProxy = TransportFactory.createVdsServer(_vds.getProtocol(), _vds.getHostName(), _vds.getPort(), clientTimeOut, connectionTimeOut, clientRetries, heartBeat);
}
#method_after
private void InitVdsBroker() {
    log.infoFormat("Initialize vdsBroker ({0},{1})", _vds.getHostName(), _vds.getPort());
    // Get the values of the timeouts:
    int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
    int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
    int heartbeat = Config.<Integer>getValue(ConfigValues.vdsHeartbeatInSeconds) * 1000;
    int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
    _vdsProxy = TransportFactory.createVdsServer(_vds.getProtocol(), _vds.getHostName(), _vds.getPort(), clientTimeOut, connectionTimeOut, clientRetries, heartbeat);
}
#end_block

#method_before
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getStatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<String>() {

                @Override
                public String runInTransaction() {
                    return gethostFromVds();
                }
            });
            if (host != null) {
                // Get the values of the timeouts:
                int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
                int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
                int heartBeat = Config.<Integer>getValue(ConfigValues.vdsHeartBeat) * 1000;
                int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
                irsProxy = TransportFactory.createIrsServer(getProtocol(), host, getmIrsPort(), clientTimeOut, connectionTimeOut, clientRetries, heartBeat);
                runStoragePoolUpEvent(storagePool);
            }
        }
    }
    return getmIrsProxy();
}
#method_after
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getStatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<String>() {

                @Override
                public String runInTransaction() {
                    return gethostFromVds();
                }
            });
            if (host != null) {
                // Get the values of the timeouts:
                int clientTimeOut = Config.<Integer>getValue(ConfigValues.vdsTimeout) * 1000;
                int connectionTimeOut = Config.<Integer>getValue(ConfigValues.vdsConnectionTimeout) * 1000;
                int heartbeat = Config.<Integer>getValue(ConfigValues.vdsHeartbeatInSeconds) * 1000;
                int clientRetries = Config.<Integer>getValue(ConfigValues.vdsRetries);
                irsProxy = TransportFactory.createIrsServer(getProtocol(), host, getmIrsPort(), clientTimeOut, connectionTimeOut, clientRetries, heartbeat);
                runStoragePoolUpEvent(storagePool);
            }
        }
    }
    return getmIrsProxy();
}
#end_block

#method_before
private SpmStatusResult handleSpmStatusResult(Guid curVdsId, List<VDS> vdsByPool, final StoragePool storagePool, RefObject<VDS> selectedVds, SpmStatusResult spmStatus) {
    if (spmStatus.getSpmStatus() == SpmStatus.Free) {
        int vdsSpmIdToFence = -1;
        boolean startSpm = true;
        if (spmStatus.getSpmId() != -1) {
            int spmId = spmStatus.getSpmId();
            Guid spmVdsId = Guid.Empty;
            VDS spmVds = null;
            if (selectedVds.argvalue.getVdsSpmId() == spmId) {
                spmVdsId = selectedVds.argvalue.getId();
            } else {
                for (VDS tempVds : vdsByPool) {
                    if (tempVds.getVdsSpmId() == spmId) {
                        log.infoFormat("Found spm host {0}, host name: {1}, according to spmId: {2}.", tempVds.getId(), tempVds.getName(), spmId);
                        spmVds = tempVds;
                        break;
                    }
                }
                // non operational we want to find it as well
                if (spmVds == null) {
                    List<VDS> nonOperationalVds = DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, VDSStatus.NonOperational);
                    for (VDS tempVds : nonOperationalVds) {
                        if (tempVds.getVdsSpmId() == spmId) {
                            spmVds = tempVds;
                            break;
                        }
                    }
                }
                if (spmVds != null) {
                    spmVdsId = spmVds.getId();
                } else if (!curVdsId.equals(Guid.Empty)) {
                    VDS currentVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
                    if (currentVds != null && currentVds.getStatus() == VDSStatus.Up && currentVds.getVdsSpmId() != null && currentVds.getVdsSpmId().equals(spmId)) {
                        spmVdsId = curVdsId;
                        spmVds = currentVds;
                    }
                }
            }
            try {
                if (!spmVdsId.equals(Guid.Empty)) {
                    SpmStatusResult destSpmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(spmVdsId, _storagePoolId)).getReturnValue();
                    log.infoFormat("SpmStatus on vds {0}: {1}", spmVdsId, destSpmStatus == null ? "NULL" : destSpmStatus.getSpmStatus().toString());
                    /**
                     * intentional unreachable code
                     */
                    if (destSpmStatus != null && destSpmStatus.getSpmStatus() == SpmStatus.SPM) {
                        if (spmVdsId != selectedVds.argvalue.getId() && spmVds != null && spmVds.getStatus() == VDSStatus.Up) {
                            selectedVds.argvalue = spmVds;
                            startSpm = false;
                            log.infoFormat("Using old spm server: {0}, no start needed", spmVds.getName());
                            return destSpmStatus;
                        } else // VDS is non-operational and SPM
                        {
                            log.warn("Host reports to be SPM but is not up. " + spmVdsId);
                            vdsSpmIdToFence = spmStatus.getSpmId();
                        }
                    } else // it is not SPM and continue.
                    if (destSpmStatus == null || (destSpmStatus.getSpmStatus() != SpmStatus.Free && destSpmStatus.getSpmStatus() != SpmStatus.Unknown_Pool)) {
                        vdsSpmIdToFence = spmStatus.getSpmId();
                    }
                } else {
                    log.errorFormat("SPM Init: could not find reported vds or not up - pool:{0} vds_spm_id: {1}", storagePool.getName(), spmStatus.getSpmId());
                    vdsSpmIdToFence = spmStatus.getSpmId();
                }
            } catch (Exception ex) {
                vdsSpmIdToFence = spmStatus.getSpmId();
            }
        }
        if (startSpm) {
            vds_spm_id_map map = DbFacade.getInstance().getVdsSpmIdMapDao().get(_storagePoolId, vdsSpmIdToFence);
            if (map != null) {
                VDS vdsToFenceObject = DbFacade.getInstance().getVdsDao().get(map.getId());
                if (vdsToFenceObject != null) {
                    log.infoFormat("SPM selection - vds seems as spm {0}", vdsToFenceObject.getName());
                    if (vdsToFenceObject.getStatus() == VDSStatus.NonResponsive) {
                        log.warn("spm vds is non responsive, stopping spm selection.");
                        selectedVds.argvalue = null;
                        return spmStatus;
                    } else {
                        // try to stop spm
                        VDSReturnValue spmStopReturnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsToFenceObject.getId(), _storagePoolId));
                        // continue with spm selection
                        if (spmStopReturnValue != null && spmStopReturnValue.getSucceeded()) {
                            log.info("spm stop succeeded, continuing with spm selection");
                        } else // if spm stop failed for any reason we stop spm
                        // selection
                        {
                            log.warn("spm stop on spm failed, stopping spm selection!");
                            selectedVds.argvalue = null;
                            return spmStatus;
                        }
                    }
                }
            }
            storagePool.setStatus(StoragePoolStatus.Contend);
            storagePool.setspm_vds_id(selectedVds.argvalue.getId());
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    DbFacade.getInstance().getStoragePoolDao().update(storagePool);
                    return null;
                }
            });
            log.infoFormat("starting spm on vds {0}, storage pool {1}, prevId {2}, LVER {3}", selectedVds.argvalue.getName(), storagePool.getName(), spmStatus.getSpmId(), spmStatus.getSpmLVER());
            spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.argvalue.getId(), _storagePoolId, spmStatus.getSpmId(), spmStatus.getSpmLVER(), storagePool.getrecovery_mode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
            if (spmStatus == null || spmStatus.getSpmStatus() != SpmStatus.SPM) {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
                if (spmStatus != null) {
                    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePool.getId());
                            pool.setspm_vds_id(null);
                            DbFacade.getInstance().getStoragePoolDao().update(pool);
                            return null;
                        }
                    });
                }
                throw new IrsSpmStartFailedException();
            }
        }
    }
    return spmStatus;
}
#method_after
private SpmStatusResult handleSpmStatusResult(Guid curVdsId, List<VDS> vdsByPool, final StoragePool storagePool, RefObject<VDS> selectedVds, SpmStatusResult spmStatus) {
    if (spmStatus.getSpmStatus() == SpmStatus.Free) {
        int vdsSpmIdToFence = -1;
        boolean startSpm = true;
        if (spmStatus.getSpmId() != -1) {
            int spmId = spmStatus.getSpmId();
            Guid spmVdsId = Guid.Empty;
            VDS spmVds = null;
            if (selectedVds.argvalue.getVdsSpmId() == spmId) {
                spmVdsId = selectedVds.argvalue.getId();
            } else {
                for (VDS tempVds : vdsByPool) {
                    if (tempVds.getVdsSpmId() == spmId) {
                        log.infoFormat("Found spm host {0}, host name: {1}, according to spmId: {2}.", tempVds.getId(), tempVds.getName(), spmId);
                        spmVds = tempVds;
                        break;
                    }
                }
                // non operational we want to find it as well
                if (spmVds == null) {
                    List<VDS> nonOperationalVds = DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, VDSStatus.NonOperational);
                    for (VDS tempVds : nonOperationalVds) {
                        if (tempVds.getVdsSpmId() == spmId) {
                            spmVds = tempVds;
                            break;
                        }
                    }
                }
                if (spmVds != null) {
                    spmVdsId = spmVds.getId();
                } else if (!curVdsId.equals(Guid.Empty)) {
                    VDS currentVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
                    if (currentVds != null && currentVds.getStatus() == VDSStatus.Up && currentVds.getVdsSpmId() != null && currentVds.getVdsSpmId().equals(spmId)) {
                        spmVdsId = curVdsId;
                        spmVds = currentVds;
                    }
                }
            }
            try {
                if (!spmVdsId.equals(Guid.Empty)) {
                    SpmStatusResult destSpmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(spmVdsId, _storagePoolId)).getReturnValue();
                    log.infoFormat("SpmStatus on vds {0}: {1}", spmVdsId, destSpmStatus == null ? "NULL" : destSpmStatus.getSpmStatus().toString());
                    // intentionally unreachable code
                    if (destSpmStatus != null && destSpmStatus.getSpmStatus() == SpmStatus.SPM) {
                        if (!spmVdsId.equals(selectedVds.argvalue.getId()) && spmVds != null && spmVds.getStatus() == VDSStatus.Up) {
                            selectedVds.argvalue = spmVds;
                            startSpm = false;
                            log.infoFormat("Using old spm server: {0}, no start needed", spmVds.getName());
                            return destSpmStatus;
                        } else // VDS is non-operational and SPM
                        {
                            log.warn("Host reports to be SPM but is not up. " + spmVdsId);
                            vdsSpmIdToFence = spmStatus.getSpmId();
                        }
                    } else // it is not SPM and continue.
                    if (destSpmStatus == null || (destSpmStatus.getSpmStatus() != SpmStatus.Free && destSpmStatus.getSpmStatus() != SpmStatus.Unknown_Pool)) {
                        vdsSpmIdToFence = spmStatus.getSpmId();
                    }
                } else {
                    log.errorFormat("SPM Init: could not find reported vds or not up - pool:{0} vds_spm_id: {1}", storagePool.getName(), spmStatus.getSpmId());
                    vdsSpmIdToFence = spmStatus.getSpmId();
                }
            } catch (Exception ex) {
                vdsSpmIdToFence = spmStatus.getSpmId();
            }
        }
        if (startSpm) {
            vds_spm_id_map map = DbFacade.getInstance().getVdsSpmIdMapDao().get(_storagePoolId, vdsSpmIdToFence);
            if (map != null) {
                VDS vdsToFenceObject = DbFacade.getInstance().getVdsDao().get(map.getId());
                if (vdsToFenceObject != null) {
                    log.infoFormat("SPM selection - vds seems as spm {0}", vdsToFenceObject.getName());
                    if (vdsToFenceObject.getStatus() == VDSStatus.NonResponsive) {
                        log.warn("spm vds is non responsive, stopping spm selection.");
                        selectedVds.argvalue = null;
                        return spmStatus;
                    } else {
                        // try to stop spm
                        VDSReturnValue spmStopReturnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsToFenceObject.getId(), _storagePoolId));
                        // continue with spm selection
                        if (spmStopReturnValue != null && spmStopReturnValue.getSucceeded()) {
                            log.info("spm stop succeeded, continuing with spm selection");
                        } else // if spm stop failed for any reason we stop spm
                        // selection
                        {
                            log.warn("spm stop on spm failed, stopping spm selection!");
                            selectedVds.argvalue = null;
                            return spmStatus;
                        }
                    }
                }
            }
            storagePool.setStatus(StoragePoolStatus.Contend);
            storagePool.setspm_vds_id(selectedVds.argvalue.getId());
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    DbFacade.getInstance().getStoragePoolDao().update(storagePool);
                    return null;
                }
            });
            log.infoFormat("starting spm on vds {0}, storage pool {1}, prevId {2}, LVER {3}", selectedVds.argvalue.getName(), storagePool.getName(), spmStatus.getSpmId(), spmStatus.getSpmLVER());
            spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.argvalue.getId(), _storagePoolId, spmStatus.getSpmId(), spmStatus.getSpmLVER(), storagePool.getrecovery_mode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
            if (spmStatus == null || spmStatus.getSpmStatus() != SpmStatus.SPM) {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
                if (spmStatus != null) {
                    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePool.getId());
                            pool.setspm_vds_id(null);
                            DbFacade.getInstance().getStoragePoolDao().update(pool);
                            return null;
                        }
                    });
                }
                throw new IrsSpmStartFailedException();
            }
        }
    }
    return spmStatus;
}
#end_block

#method_before
protected void onMouseOut() {
    dragImage.setVisible(false);
    infoPopup.hide(true);
    // handle nested panels (for example bonded nics) so nic.mouseOut() should cause parent.mouseIn()
    if (parentPanel != null) {
        parentPanel.onMouseOver();
    }
    actionButton.setVisible(false);
}
#method_after
protected void onMouseOut() {
    dragImage.setVisible(false);
    infoPopup.hide(true);
    // handle nested panels (for example bonded nics) so nic.mouseOut() should cause parent.mouseIn()
    if (parentPanel != null) {
        parentPanel.onMouseOver();
    }
}
#end_block

#method_before
@Test
public void testAllDomainsHaveSpaceForAllDisksFailure() {
    setUpGeneralValidations();
    setUpDiskValidations();
    doReturn(Collections.EMPTY_LIST).when(cmd).getDisksList();
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(multipleStorageDomainsValidator).allDomainsHaveSpaceForAllDisks(anyList(), anyList());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN);
    verify(multipleStorageDomainsValidator).allDomainsHaveSpaceForAllDisks(anyList(), anyList());
}
#method_after
@Test
public void testAllDomainsHaveSpaceForAllDisksFailure() {
    setUpGeneralValidations();
    setUpDiskValidations();
    doReturn(Collections.emptyList()).when(cmd).getDisksList();
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(multipleStorageDomainsValidator).allDomainsHaveSpaceForAllDisks(eq(Collections.<DiskImage>emptyList()), anyList());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN);
    verify(multipleStorageDomainsValidator).allDomainsHaveSpaceForAllDisks(eq(Collections.<DiskImage>emptyList()), anyList());
}
#end_block

#method_before
@Test
public void testAllDomainsHaveSpaceForAllDisksSuccess() {
    setUpGeneralValidations();
    setUpDiskValidations();
    doReturn(Collections.EMPTY_LIST).when(cmd).getDisksList();
    doReturn(ValidationResult.VALID).when(multipleStorageDomainsValidator).allDomainsHaveSpaceForAllDisks(anyList(), anyList());
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(cmd);
    verify(multipleStorageDomainsValidator).allDomainsHaveSpaceForAllDisks(anyList(), anyList());
}
#method_after
@Test
public void testAllDomainsHaveSpaceForAllDisksSuccess() {
    setUpGeneralValidations();
    setUpDiskValidations();
    doReturn(Collections.emptyList()).when(cmd).getDisksList();
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(cmd);
    verify(multipleStorageDomainsValidator).allDomainsHaveSpaceForAllDisks(eq(Collections.<DiskImage>emptyList()), anyList());
}
#end_block

#method_before
private VolumeType getVolumeTypeForDomain() {
    if (null == volumeTypeForDomain) {
        StorageDomainStatic sdStatic = DbFacade.getInstance().getStorageDomainStaticDao().get(storageDomainId);
        volumeTypeForDomain = HibernateVmCommand.getMemoryVolumeTypeForStorageDomain(sdStatic.getStorageType());
    }
    return volumeTypeForDomain;
}
#method_after
private VolumeType getVolumeTypeForDomain() {
    if (volumeTypeForDomain == null) {
        StorageDomainStatic sdStatic = DbFacade.getInstance().getStorageDomainStaticDao().get(storageDomainId);
        volumeTypeForDomain = HibernateVmCommand.getMemoryVolumeTypeForStorageDomain(sdStatic.getStorageType());
    }
    return volumeTypeForDomain;
}
#end_block

#method_before
protected MemoryImageBuilder getMemoryImageBuilder() {
    if (null == memoryBuilder) {
        memoryBuilder = createMemoryImageBuilder();
    }
    return memoryBuilder;
}
#method_after
protected MemoryImageBuilder getMemoryImageBuilder() {
    if (memoryBuilder == null) {
        memoryBuilder = createMemoryImageBuilder();
    }
    return memoryBuilder;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isSpecifiedDisksExist(getParameters().getDisks())) {
        return false;
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()))) {
        return false;
    }
    List<DiskImage> disksList = getDisksListForChecks();
    MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(disksList);
    if (disksList.size() > 0) {
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()) && validate(sdValidator.allDomainsExistAndActive()))) {
            return false;
        }
    }
    if (!validateSpaceRequirements(sdValidator, disksList)) {
        return false;
    }
    if (getParameters().isSaveMemory() && Guid.Empty.equals(getStorageDomainIdForVmMemory())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isSpecifiedDisksExist(getParameters().getDisks())) {
        return false;
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()))) {
        return false;
    }
    List<DiskImage> disksList = getDisksListForChecks();
    if (disksList.size() > 0) {
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()))) {
            return false;
        }
    }
    if (!validateStorageDomains(disksList)) {
        return false;
    }
    if (getParameters().isSaveMemory() && Guid.Empty.equals(getStorageDomainIdForVmMemory())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    return true;
}
#end_block

#method_before
public ValidationResult allDomainsHaveSpaceForAllDisks(List<DiskImage> newDisksList, final List<DiskImage> clonedDisksList) {
    final Map<Guid, List<DiskImage>> domainsNewDisksMap = getDomainsDisksMap(newDisksList);
    final Map<Guid, List<DiskImage>> domainsClonedDisksMap = getDomainsDisksMap(clonedDisksList);
    return validOrFirstFailure(new ValidatorPredicate() {

        @Override
        public ValidationResult evaluate(Map.Entry<Guid, StorageDomainValidator> entry) {
            Guid sdId = entry.getKey();
            List<DiskImage> newDisksForDomain = domainsNewDisksMap.get(sdId);
            List<DiskImage> clonedDisksForDomain = domainsClonedDisksMap.get(sdId);
            return getStorageDomainValidator(entry).hasSpaceForAllDisks(newDisksForDomain, clonedDisksForDomain);
        }
    });
}
#method_after
public ValidationResult allDomainsHaveSpaceForAllDisks(List<DiskImage> newDisksList, List<DiskImage> clonedDisksList) {
    final Map<Guid, List<DiskImage>> domainsNewDisksMap = getDomainsDisksMap(newDisksList);
    final Map<Guid, List<DiskImage>> domainsClonedDisksMap = getDomainsDisksMap(clonedDisksList);
    return validOrFirstFailure(new ValidatorPredicate() {

        @Override
        public ValidationResult evaluate(Map.Entry<Guid, StorageDomainValidator> entry) {
            Guid sdId = entry.getKey();
            List<DiskImage> newDisksForDomain = domainsNewDisksMap.get(sdId);
            List<DiskImage> clonedDisksForDomain = domainsClonedDisksMap.get(sdId);
            return getStorageDomainValidator(entry).hasSpaceForAllDisks(newDisksForDomain, clonedDisksForDomain);
        }
    });
}
#end_block

#method_before
private double getTotalSizeForNewDisks(Collection<DiskImage> diskImages) {
    double totalSizeForDisks = 0.0;
    if (null != diskImages) {
        for (DiskImage diskImage : diskImages) {
            double sizeForDisk = diskImage.getSize();
            if (diskImage.getVolumeFormat() == VolumeFormat.COW) {
                if (storageDomain.getStorageType().isFileDomain()) {
                    sizeForDisk = EMPTY_QCOW_HEADER_SIZE;
                } else {
                    sizeForDisk = INITIAL_BLOCK_ALLOCATION_SIZE;
                }
            } else if (diskImage.getVolumeType() == VolumeType.Sparse) {
                sizeForDisk = EMPTY_QCOW_HEADER_SIZE;
            }
            totalSizeForDisks += sizeForDisk;
        }
    }
    return totalSizeForDisks;
}
#method_after
private double getTotalSizeForNewDisks(Collection<DiskImage> diskImages) {
    double totalSizeForDisks = 0.0;
    if (diskImages != null) {
        for (DiskImage diskImage : diskImages) {
            double sizeForDisk = diskImage.getSize();
            if (diskImage.getVolumeFormat() == VolumeFormat.COW) {
                if (storageDomain.getStorageType().isFileDomain()) {
                    sizeForDisk = EMPTY_QCOW_HEADER_SIZE;
                } else {
                    sizeForDisk = INITIAL_BLOCK_ALLOCATION_SIZE;
                }
            } else if (diskImage.getVolumeType() == VolumeType.Sparse) {
                sizeForDisk = EMPTY_QCOW_HEADER_SIZE;
            }
            totalSizeForDisks += sizeForDisk;
        }
    }
    return totalSizeForDisks;
}
#end_block

#method_before
private double getTotalSizeForClonedDisks(Collection<DiskImage> diskImages) {
    double totalSizeForDisks = 0.0;
    if (null != diskImages) {
        for (DiskImage diskImage : diskImages) {
            double diskCapacity = diskImage.getSize();
            double sizeForDisk = diskCapacity;
            if ((storageDomain.getStorageType().isFileDomain() && diskImage.getVolumeType() == VolumeType.Sparse) || storageDomain.getStorageType().isBlockDomain() && diskImage.getVolumeFormat() == VolumeFormat.COW) {
                double usedSapce = diskImage.getActualDiskWithSnapshotsSizeInBytes();
                sizeForDisk = Math.min(diskCapacity, usedSapce);
            }
            if (diskImage.getVolumeFormat() == VolumeFormat.COW) {
                sizeForDisk = Math.ceil(QCOW_OVERHEAD_FACTOR * sizeForDisk);
            }
            totalSizeForDisks += sizeForDisk;
        }
    }
    return totalSizeForDisks;
}
#method_after
private double getTotalSizeForClonedDisks(Collection<DiskImage> diskImages) {
    double totalSizeForDisks = 0.0;
    if (diskImages != null) {
        for (DiskImage diskImage : diskImages) {
            double diskCapacity = diskImage.getSize();
            double sizeForDisk = diskCapacity;
            if ((storageDomain.getStorageType().isFileDomain() && diskImage.getVolumeType() == VolumeType.Sparse) || storageDomain.getStorageType().isBlockDomain() && diskImage.getVolumeFormat() == VolumeFormat.COW) {
                double usedSapce = diskImage.getActualDiskWithSnapshotsSizeInBytes();
                sizeForDisk = Math.min(diskCapacity, usedSapce);
            }
            if (diskImage.getVolumeFormat() == VolumeFormat.COW) {
                sizeForDisk = Math.ceil(QCOW_OVERHEAD_FACTOR * sizeForDisk);
            }
            totalSizeForDisks += sizeForDisk;
        }
    }
    return totalSizeForDisks;
}
#end_block

#method_before
public void start() {
    try {
        String hostName = "localhost";
        log.debug("Opening a Stomp server " + hostName + ":" + jsonPort);
        Reactor reactor = ReactorFactory.getReactor(null, ReactorType.STOMP);
        final Future<ReactorListener> futureListener = reactor.createListener(hostName, jsonPort, new ReactorListener.EventListener() {

            @Override
            public void onAcccept(final ReactorClient client) {
                client.addEventListener(new MessageListener() {

                    // you can provide your implementation of MessageListener
                    // to handle all the message types
                    @Override
                    public void onMessageReceived(byte[] message) {
                        try {
                            JsonRpcRequest request = JsonRpcRequest.fromJsonNode(mapper.readTree(message));
                            // We need ResponseBuilder similar to RequesrBuilder
                            ObjectNode parameters = mapper.createObjectNode();
                            ContextHolder.init();
                            // TODO: Not sure if this is the host or source
                            ContextHolder.setServerName(client.getHostname());
                            if (request.getMethod().equalsIgnoreCase("Host.getCapabilities")) {
                                Map response = api.getVdsCapabilities();
                                // for (Object obj : response.entrySet()) {
                                // Map.Entry entry = (Map.Entry) obj;
                                // parameters.put(entry.getKey().toString(), entry.getValue().toString());
                                // }
                                parameters.putPOJO("info", response);
                            }
                            JsonRpcResponse response = new JsonRpcResponse(parameters, null, request.getId());
                            client.sendMessage(fromJson(response));
                        } catch (IOException e) {
                            log.error("Failure in processing request", e);
                        }
                    }
                });
            }
        });
        Thread t = new Thread(new Runnable() {

            @Override
            public void run() {
                while (true) {
                    try {
                        futureListener.get();
                    } catch (Exception e) {
                        log.error("Error while waiting on listener", e);
                    }
                }
            }
        });
        t.start();
    // this.listener = futureListener.get(TIMEOUT, TimeUnit.MILLISECONDS);
    } catch (Exception e) {
        log.error("Failure to start json server socket", e);
    }
}
#method_after
public void start() {
    try {
        String hostName = "localhost";
        log.debug("Opening a Stomp server " + hostName + ":" + jsonPort);
        Reactor reactor = ReactorFactory.getReactor(null, ReactorType.STOMP);
        final Future<ReactorListener> futureListener = reactor.createListener(hostName, jsonPort, new ReactorListener.EventListener() {

            @Override
            public void onAcccept(final ReactorClient client) {
                client.addEventListener(new MessageListener() {

                    // you can provide your implementation of MessageListener
                    @Override
                    public void onMessageReceived(byte[] message) {
                        try {
                            JsonRpcRequest request = JsonRpcRequest.fromByteArray(message);
                            ContextHolder.init();
                            ContextHolder.setServerName(client.getHostname());
                            ResponseBuilder builder = new ResponseBuilder(request.getId());
                            String methodName = request.getMethod();
                            builder = CommandFactory.createCommand(methodName).run(request.getParams(), builder);
                            JsonRpcResponse response = builder.build();
                            log.info("Request is " + request.getMethod() + " got response " + new String(response.toByteArray()));
                            client.sendMessage(response.toByteArray());
                        } catch (Throwable e) {
                            log.error("Failure in processing request", e);
                        }
                    }
                });
            }
        });
        listener = futureListener.get(TIMEOUT, TimeUnit.MILLISECONDS);
    } catch (Exception e) {
        log.error("Failure to start json server socket", e);
    }
}
#end_block

#method_before
@Override
public void contextDestroyed(ServletContextEvent event) {
    log.info("Application destroyed.");
    final TaskProcessor taskProcessor = TaskProcessor.getInstance();
    taskProcessor.destroy();
}
#method_after
@Override
public void contextDestroyed(ServletContextEvent event) {
    log.info("Application destroyed.");
    final TaskProcessor taskProcessor = TaskProcessor.getInstance();
    taskProcessor.destroy();
    JsonRpcServer.shutdown();
}
#end_block

#method_before
protected boolean checkIfImageDiskCanBeAdded(VM vm, DiskValidator diskValidator) {
    if (Guid.Empty.equals(getParameters().getStorageDomainId()) && Guid.Empty.equals(getStorageDomainId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_SPECIFIED);
    }
    boolean returnValue;
    StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
    // vm agnostic checks
    returnValue = validate(storageDomainValidator.isDomainExistAndActive()) && !isShareableDiskOnGlusterDomain() && checkImageConfiguration() && validate(storageDomainValidator.hasSpaceForNewDisk(getDiskImageInfo())) && validate(storageDomainValidator.isDomainWithinThresholds()) && checkExceedingMaxBlockDiskSize() && canAddShareableDisk() && validate(diskValidator.isVirtIoScsiValid(vm)) && validate(diskValidator.isDiskInterfaceSupported(getVm()));
    if (returnValue && vm != null) {
        // Note this is done according to the VM's spId.
        StoragePool sp = getStoragePool();
        returnValue = validate(new StoragePoolValidator(sp).isUp()) && isStoragePoolMatching(vm) && isVmNotLocked() && isVmNotInPreviewSnapshot();
    }
    return returnValue;
}
#method_after
protected boolean checkIfImageDiskCanBeAdded(VM vm, DiskValidator diskValidator) {
    if (Guid.Empty.equals(getStorageDomainId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_SPECIFIED);
    }
    boolean returnValue;
    StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
    // vm agnostic checks
    returnValue = validate(storageDomainValidator.isDomainExistAndActive()) && !isShareableDiskOnGlusterDomain() && checkImageConfiguration() && validate(storageDomainValidator.hasSpaceForNewDisk(getDiskImageInfo())) && validate(storageDomainValidator.isDomainWithinThresholds()) && checkExceedingMaxBlockDiskSize() && canAddShareableDisk() && validate(diskValidator.isVirtIoScsiValid(vm)) && validate(diskValidator.isDiskInterfaceSupported(getVm()));
    if (returnValue && vm != null) {
        // Note this is done according to the VM's spId.
        StoragePool sp = getStoragePool();
        returnValue = validate(new StoragePoolValidator(sp).isUp()) && isStoragePoolMatching(vm) && isVmNotLocked() && isVmNotInPreviewSnapshot();
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected SearchParameters createSearchParameters(SearchType searchType, String constraint) {
    return new DirectorySearchParameters(constraint, searchType, "*");
}
#method_after
@Override
protected SearchParameters createSearchParameters(SearchType searchType, String constraint) {
    return new DirectorySearchParameters(constraint, searchType);
}
#end_block

#method_before
public void setNamespace(ListModel value) {
    privateNamespace = value;
}
#method_after
public void setNamespace(ListModel<String> value) {
    privateNamespace = value;
}
#end_block

#method_before
public ListModel getNamespace() {
    return privateNamespace;
}
#method_after
public ListModel<String> getNamespace() {
    return privateNamespace;
}
#end_block

#method_before
protected void populateNamespaces(List<String> namespaces) {
    getNamespace().setItems(namespaces);
    getNamespace().setSelectedItem(Linq.firstOrDefault(namespaces));
}
#method_after
protected void populateNamespaces() {
    if (namespacesMap != null) {
        getNamespace().setItems(namespacesMap.get(((ProfileEntry) getProfile().getSelectedItem()).getAuthz()));
    }
}
#end_block

#method_before
protected void findGroups(String searchString, AsyncQuery query) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new DirectorySearchParameters("ADGROUP@" + ((ProfileEntry) getProfile().getSelectedItem()).getAuthz() + ": " + searchString, SearchType.DirectoryGroup, (String) getNamespace().getSelectedItem()), // $NON-NLS-1$ //$NON-NLS-2$
    query);
}
#method_after
protected void findGroups(String searchString, AsyncQuery query) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new DirectorySearchParameters("ADGROUP@" + ((ProfileEntry) getProfile().getSelectedItem()).getAuthz() + ": " + searchString, SearchType.DirectoryGroup, getNamespace().getSelectedItem()), // $NON-NLS-1$ //$NON-NLS-2$
    query);
}
#end_block

#method_before
protected void findUsers(String searchString, AsyncQuery query) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new DirectorySearchParameters("ADUSER@" + ((ProfileEntry) getProfile().getSelectedItem()).getAuthz() + ": " + searchString, SearchType.DirectoryUser, (String) getNamespace().getSelectedItem()), // $NON-NLS-1$ //$NON-NLS-2$
    query);
}
#method_after
protected void findUsers(String searchString, AsyncQuery query) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new DirectorySearchParameters("ADUSER@" + ((ProfileEntry) getProfile().getSelectedItem()).getAuthz() + ": " + searchString, SearchType.DirectoryUser, getNamespace().getSelectedItem()), // $NON-NLS-1$ //$NON-NLS-2$
    query);
}
#end_block

#method_before
@Override
protected SearchParameters createSearchParameters(SearchType searchType, String constraint) {
    return new DirectorySearchParameters(constraint, searchType, "*");
}
#method_after
@Override
protected SearchParameters createSearchParameters(SearchType searchType, String constraint) {
    return new DirectorySearchParameters(constraint, searchType);
}
#end_block

#method_before
private void initListBoxEditors() {
    profileSelection = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((ProfileEntry) object).toString();
        }
    });
    roleSelection = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Role) object).getname();
        }
    });
    namespaceSelection = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        protected String renderNullSafe(Object object) {
            return object.toString();
        }
    });
}
#method_after
private void initListBoxEditors() {
    profileSelection = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((ProfileEntry) object).toString();
        }
    });
    roleSelection = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Role) object).getname();
        }
    });
    namespaceSelection = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        protected String renderNullSafe(String object) {
            return object;
        }
    });
}
#end_block

#method_before
void localize(CommonApplicationConstants constants) {
    searchButton.setLabel(constants.goPermissionsPopup());
}
#method_after
void localize(CommonApplicationConstants constants) {
    searchButton.setLabel(constants.goPermissionsPopup());
    namespaceSelection.setLabel(constants.namespacePermissionsPopup());
}
#end_block

#method_before
private List<DirectoryUser> searchDirectoryUsers() {
    // Parse the query:
    QueryData data = initQueryData(true);
    if (data == null) {
        return Collections.emptyList();
    }
    ExtensionProxy authz = EngineExtensionsManager.getInstance().getExtensionByName(data.getDomain());
    return new ArrayList<DirectoryUser>(DirectoryUtils.findDirectoryUsersByQuery(authz, ((DirectorySearchParameters) getParameters()).getNamespace(), data.getQuery()));
}
#method_after
private List<DirectoryUser> searchDirectoryUsers() {
    // Parse the query:
    QueryData data = initQueryData(true);
    if (data == null) {
        return Collections.emptyList();
    }
    ExtensionProxy authz = EngineExtensionsManager.getInstance().getExtensionByName(data.getDomain());
    DirectorySearchParameters directorySearchParams = (DirectorySearchParameters) getParameters();
    List<String> namespaces = Arrays.asList(directorySearchParams.getNamespace());
    if (directorySearchParams.getNamespace() == null) {
        HashMap<String, List<String>> namespacesMap = runInternalQuery(VdcQueryType.GetAvailableNamespaces, new VdcQueryParametersBase()).getReturnValue();
        namespaces = namespacesMap.get(data.getDomain());
    }
    List<DirectoryUser> results = new ArrayList<>();
    for (String namespace : namespaces) {
        results.addAll(DirectoryUtils.findDirectoryUsersByQuery(authz, namespace, data.getQuery()));
    }
    return results;
}
#end_block

#method_before
private List<DirectoryGroup> searchDirectoryGroups() {
    // Parse the query:
    QueryData data = initQueryData(true);
    if (data == null) {
        return Collections.emptyList();
    }
    ExtensionProxy authz = EngineExtensionsManager.getInstance().getExtensionByName(data.getDomain());
    return new ArrayList<DirectoryGroup>(DirectoryUtils.findDirectoryGroupsByQuery(authz, ((DirectorySearchParameters) getParameters()).getNamespace(), data.getQuery()));
}
#method_after
private List<DirectoryGroup> searchDirectoryGroups() {
    // Parse the query:
    QueryData data = initQueryData(true);
    if (data == null) {
        return Collections.emptyList();
    }
    ExtensionProxy authz = EngineExtensionsManager.getInstance().getExtensionByName(data.getDomain());
    DirectorySearchParameters directorySearchParams = (DirectorySearchParameters) getParameters();
    List<String> namespaces = Arrays.asList(directorySearchParams.getNamespace());
    if (directorySearchParams.getNamespace() == null) {
        HashMap<String, List<String>> namespacesMap = runInternalQuery(VdcQueryType.GetAvailableNamespaces, new VdcQueryParametersBase()).getReturnValue();
        namespaces = namespacesMap.get(data.getDomain());
    }
    List<DirectoryGroup> results = new ArrayList<>();
    for (String namespace : namespaces) {
        results.addAll(DirectoryUtils.findDirectoryGroupsByQuery(authz, namespace, data.getQuery()));
    }
    return results;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    Permissions other = (Permissions) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(adElementId, other.adElementId) && ObjectUtils.objectsEqual(objectId, other.objectId) && objectType == other.objectType && ObjectUtils.objectsEqual(roleId, other.roleId) && ObjectUtils.objectsEqual(authz, other.authz) && ObjectUtils.objectsEqual(namespace, other.namespace));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    Permissions other = (Permissions) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(adElementId, other.adElementId) && ObjectUtils.objectsEqual(objectId, other.objectId) && objectType == other.objectType && ObjectUtils.objectsEqual(roleId, other.roleId));
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new UserStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<DbUser> firstNameColumn = new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return object.getFirstName();
        }
    };
    firstNameColumn.makeSortable(VdcUserConditionFieldAutoCompleter.FIRST_NAME);
    // $NON-NLS-1$
    getTable().addColumn(firstNameColumn, constants.firstnameUser(), "150px");
    TextColumnWithTooltip<DbUser> lastNameColumn = new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return object.getLastName();
        }
    };
    lastNameColumn.makeSortable(VdcUserConditionFieldAutoCompleter.LAST_NAME);
    // $NON-NLS-1$
    getTable().addColumn(lastNameColumn, constants.lastNameUser(), "150px");
    TextColumnWithTooltip<DbUser> userNameColumn = new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return FormatUtils.getFullLoginName(object);
        }
    };
    userNameColumn.makeSortable(VdcUserConditionFieldAutoCompleter.USER_NAME);
    // $NON-NLS-1$
    getTable().addColumn(userNameColumn, constants.userNameUser(), "150px");
    getTable().addColumn(new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return object.getNamespace();
        }
    }, constants.namespace(), // $NON-NLS-1$
    "150px");
    getTable().addColumn(new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return object.getDomain();
        }
    }, constants.authzProvider(), // $NON-NLS-1$
    "150px");
    TextColumnWithTooltip<DbUser> groupColumn = new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            StringBuilder builder = new StringBuilder();
            for (String name : object.getGroupNames()) {
                if (builder.length() > 0) {
                    // $NON-NLS-1$
                    builder.append(",");
                }
                builder.append(name);
            }
            return builder.toString();
        }
    };
    groupColumn.makeSortable(VdcUserConditionFieldAutoCompleter.GROUP);
    // $NON-NLS-1$
    getTable().addColumn(groupColumn, constants.groupUser(), "150px");
    getTable().addColumn(new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return object.getEmail();
        }
    }, constants.emailUser(), // $NON-NLS-1$
    "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<DbUser>(constants.addUser()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAddCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<DbUser>(constants.removeUser()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<DbUser>(constants.assignTagsUser()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new UserStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<DbUser> firstNameColumn = new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return object.getFirstName();
        }
    };
    firstNameColumn.makeSortable(VdcUserConditionFieldAutoCompleter.FIRST_NAME);
    // $NON-NLS-1$
    getTable().addColumn(firstNameColumn, constants.firstnameUser(), "150px");
    TextColumnWithTooltip<DbUser> lastNameColumn = new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return object.getLastName();
        }
    };
    lastNameColumn.makeSortable(VdcUserConditionFieldAutoCompleter.LAST_NAME);
    // $NON-NLS-1$
    getTable().addColumn(lastNameColumn, constants.lastNameUser(), "150px");
    TextColumnWithTooltip<DbUser> userNameColumn = new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return FormatUtils.getFullLoginName(object);
        }
    };
    userNameColumn.makeSortable(VdcUserConditionFieldAutoCompleter.USER_NAME);
    // $NON-NLS-1$
    getTable().addColumn(userNameColumn, constants.userNameUser(), "150px");
    TextColumnWithTooltip<DbUser> namespaceColumn = new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return object.getNamespace();
        }
    };
    namespaceColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(namespaceColumn, constants.namespace(), "150px");
    TextColumnWithTooltip<DbUser> authzColumn = new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return object.getDomain();
        }
    };
    authzColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(authzColumn, constants.authz(), "150px");
    TextColumnWithTooltip<DbUser> groupColumn = new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            StringBuilder builder = new StringBuilder();
            for (String name : object.getGroupNames()) {
                if (builder.length() > 0) {
                    // $NON-NLS-1$
                    builder.append(",");
                }
                builder.append(name);
            }
            return builder.toString();
        }
    };
    groupColumn.makeSortable(VdcUserConditionFieldAutoCompleter.GROUP);
    // $NON-NLS-1$
    getTable().addColumn(groupColumn, constants.groupUser(), "150px");
    getTable().addColumn(new TextColumnWithTooltip<DbUser>() {

        @Override
        public String getValue(DbUser object) {
            return object.getEmail();
        }
    }, constants.emailUser(), // $NON-NLS-1$
    "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<DbUser>(constants.addUser()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAddCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<DbUser>(constants.removeUser()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<DbUser>(constants.assignTagsUser()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
}
#end_block

#method_before
@Override
public void initTable(CommonApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new PermissionTypeColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<Permissions> userColumn = new TextColumnWithTooltip<Permissions>() {

        @Override
        public String getValue(Permissions object) {
            return object.getOwnerName();
        }
    };
    userColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(userColumn, constants.userPermission(), "300px");
    TextColumnWithTooltip<Permissions> namespaceColumn = new TextColumnWithTooltip<Permissions>() {

        @Override
        public String getValue(Permissions object) {
            return object.getNamespace();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(namespaceColumn, constants.namespace(), "300px");
    TextColumnWithTooltip<Permissions> authzColumn = new TextColumnWithTooltip<Permissions>() {

        @Override
        public String getValue(Permissions object) {
            return object.getAuthz();
        }
    };
    authzColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(namespaceColumn, constants.authz(), "300px");
    TextColumnWithTooltip<Permissions> roleColumn = new TextColumnWithTooltip<Permissions>() {

        @Override
        public String getValue(Permissions object) {
            return object.getRoleName();
        }
    };
    roleColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(roleColumn, constants.rolePermission(), "300px");
    getTable().addActionButton(new UiCommandButtonDefinition<Permissions>(getEventBus(), constants.addPermission()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getAddCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Permissions>(getEventBus(), constants.removePermission()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRemoveCommand();
        }
    });
}
#method_after
@Override
public void initTable(CommonApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new PermissionTypeColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<Permissions> userColumn = new TextColumnWithTooltip<Permissions>() {

        @Override
        public String getValue(Permissions object) {
            return object.getOwnerName();
        }
    };
    userColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(userColumn, constants.userPermission(), "300px");
    TextColumnWithTooltip<Permissions> namespaceColumn = new TextColumnWithTooltip<Permissions>() {

        @Override
        public String getValue(Permissions object) {
            return object.getNamespace();
        }
    };
    namespaceColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(namespaceColumn, constants.namespace(), "300px");
    TextColumnWithTooltip<Permissions> authzColumn = new TextColumnWithTooltip<Permissions>() {

        @Override
        public String getValue(Permissions object) {
            return object.getAuthz();
        }
    };
    authzColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(authzColumn, constants.authz(), "300px");
    TextColumnWithTooltip<Permissions> roleColumn = new TextColumnWithTooltip<Permissions>() {

        @Override
        public String getValue(Permissions object) {
            return object.getRoleName();
        }
    };
    roleColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(roleColumn, constants.rolePermission(), "300px");
    getTable().addActionButton(new UiCommandButtonDefinition<Permissions>(getEventBus(), constants.addPermission()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getAddCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Permissions>(getEventBus(), constants.removePermission()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRemoveCommand();
        }
    });
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    TextColumnWithTooltip<UserGroup> nameColumn = new TextColumnWithTooltip<UserGroup>() {

        @Override
        public String getValue(UserGroup object) {
            return object.getGroupName();
        }
    };
    nameColumn.makeSortable(UserGroupComparator.NAME);
    getTable().addColumn(nameColumn, constants.groupNameGroup());
    TextColumnWithTooltip<UserGroup> namespaceColumn = new TextColumnWithTooltip<UserGroup>() {

        @Override
        public String getValue(UserGroup object) {
            return object.getNamespace();
        }
    };
    namespaceColumn.makeSortable(UserGroupComparator.NAMESPACE);
    getTable().addColumn(namespaceColumn, constants.namespaceGroup());
    TextColumnWithTooltip<UserGroup> authzColumn = new TextColumnWithTooltip<UserGroup>() {

        @Override
        public String getValue(UserGroup object) {
            return object.getAuthz();
        }
    };
    authzColumn.makeSortable(UserGroupComparator.AUTHZ);
    getTable().addColumn(authzColumn, constants.authzGroup());
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<UserGroup> nameColumn = new TextColumnWithTooltip<UserGroup>() {

        @Override
        public String getValue(UserGroup object) {
            return object.getGroupName();
        }
    };
    nameColumn.makeSortable(UserGroupComparator.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.groupNameGroup(), "300px");
    TextColumnWithTooltip<UserGroup> namespaceColumn = new TextColumnWithTooltip<UserGroup>() {

        @Override
        public String getValue(UserGroup object) {
            return object.getNamespace();
        }
    };
    namespaceColumn.makeSortable(UserGroupComparator.NAMESPACE);
    // $NON-NLS-1$
    getTable().addColumn(namespaceColumn, constants.namespaceGroup(), "300px");
    TextColumnWithTooltip<UserGroup> authzColumn = new TextColumnWithTooltip<UserGroup>() {

        @Override
        public String getValue(UserGroup object) {
            return object.getAuthz();
        }
    };
    authzColumn.makeSortable(UserGroupComparator.AUTHZ);
    // $NON-NLS-1$
    getTable().addColumn(authzColumn, constants.authzGroup(), "300px");
}
#end_block

#method_before
@Override
public void sendMessage(byte[] message) {
    waitForConnect();
    send(new Message().send().withHeader(HEADER_DESTINATION, REQUEST_QUEUE).withContent(new String(message, UTF8)).build());
}
#method_after
@Override
public void sendMessage(byte[] message) {
    waitForConnect();
    send(new Message().send().withHeader(HEADER_DESTINATION, REQUEST_QUEUE).withContent(message).build());
}
#end_block

#method_before
@Override
protected void postConnect(OneTimeCallback callback) throws ClientConnectionException {
    super.postConnect(getCallback());
}
#method_after
@Override
protected void postConnect(OneTimeCallback callback) throws ClientConnectionException {
    super.postConnect(getPostConnectCallback());
}
#end_block

#method_before
@Override
public void sendMessage(byte[] message) {
    send(new Message().message().withHeader(HEADER_DESTINATION, RESPONSE_QUEUE).withContent(new String(message, UTF8)).build());
}
#method_after
@Override
public void sendMessage(byte[] message) {
    send(new Message().message().withHeader(HEADER_DESTINATION, RESPONSE_QUEUE).withContent(message).build());
}
#end_block

#method_before
@Override
public void sendMessage(byte[] message) {
    send(new Message().send().withHeader(HEADER_DESTINATION, REQUEST_QUEUE).withContent(new String(message, UTF8)).build());
}
#method_after
@Override
public void sendMessage(byte[] message) {
    send(new Message().send().withHeader(HEADER_DESTINATION, REQUEST_QUEUE).withContent(message).build());
}
#end_block

#method_before
public Message withContent(String content) {
    this.content = content;
    return this;
}
#method_after
public Message withContent(byte[] content) {
    this.content = content;
    return this;
}
#end_block

#method_before
public byte[] build() {
    if (isEmpty(this.command)) {
        throw new IllegalArgumentException("Command can't be empty");
    }
    StringBuilder builder = new StringBuilder(this.command);
    builder.append("\n");
    for (String key : this.headers.keySet()) {
        builder.append(key);
        builder.append(":");
        builder.append(this.headers.get(key));
        builder.append("\n");
    }
    builder.append("\n");
    if (!isEmpty(this.content)) {
        builder.append(this.content);
    }
    builder.append(END_OF_MESSAGE + "\n");
    return builder.toString().getBytes(UTF8);
}
#method_after
public byte[] build() {
    if (isEmpty(this.command)) {
        throw new IllegalArgumentException("Command can't be empty");
    }
    StringBuilder builder = new StringBuilder(this.command);
    builder.append("\n");
    for (String key : this.headers.keySet()) {
        builder.append(key);
        builder.append(":");
        builder.append(this.headers.get(key));
        builder.append("\n");
    }
    if (this.content.length != 0) {
        builder.append(HEADER_CONTENT_LENGTH).append(":").append(this.content.length).append("\n");
    }
    builder.append("\n");
    if (this.content.length != 0) {
        builder.append(new String(this.content, getEncoding()));
    }
    builder.append(END_OF_MESSAGE);
    return builder.toString().getBytes(UTF8);
}
#end_block

#method_before
public String getContent() {
    return content;
}
#method_after
public byte[] getContent() {
    return content;
}
#end_block

#method_before
public String getContent() {
    return content;
}
#method_after
private static byte[] getContent(byte[] array, String[] message, int lineNumber) {
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < lineNumber; i++) {
        builder.append(message[i]);
        builder.append("\n");
    }
    return Arrays.copyOfRange(array, builder.toString().getBytes(UTF8).length, array.length);
}
#end_block

#method_before
public void connect() throws ClientConnectionException {
    if (isOpen()) {
        return;
    }
    try (LockWrapper wrapper = new LockWrapper(this.lock)) {
        if (isOpen()) {
            return;
        }
        final FutureTask<SocketChannel> task = scheduleTask(new Retryable<SocketChannel>(new Callable<SocketChannel>() {

            @Override
            public SocketChannel call() throws IOException {
                InetAddress address = InetAddress.getByName(hostname);
                log.info("Connecting to " + address);
                final InetSocketAddress addr = new InetSocketAddress(address, port);
                final SocketChannel socketChannel = SocketChannel.open();
                socketChannel.connect(addr);
                socketChannel.configureBlocking(false);
                updateLastHeartBeat();
                return socketChannel;
            }
        }, this.policy));
        this.channel = task.get();
        postConnect(getCallback());
    } catch (InterruptedException | ExecutionException e) {
        log.error("Exception during connection", e);
        throw new ClientConnectionException(e);
    }
}
#method_after
public void connect() throws ClientConnectionException {
    if (isOpen()) {
        return;
    }
    try (LockWrapper wrapper = new LockWrapper(this.lock)) {
        if (isOpen()) {
            return;
        }
        final FutureTask<SocketChannel> task = scheduleTask(new Retryable<SocketChannel>(new Callable<SocketChannel>() {

            @Override
            public SocketChannel call() throws IOException {
                InetAddress address = InetAddress.getByName(hostname);
                log.info("Connecting to " + address);
                final InetSocketAddress addr = new InetSocketAddress(address, port);
                final SocketChannel socketChannel = SocketChannel.open();
                socketChannel.connect(addr);
                socketChannel.configureBlocking(false);
                updateLastHeartbeat();
                return socketChannel;
            }
        }, this.policy));
        this.channel = task.get();
        postConnect(getPostConnectCallback());
    } catch (InterruptedException | ExecutionException e) {
        log.error("Exception during connection", e);
        throw new ClientConnectionException(e);
    }
}
#end_block

#method_before
public Future<Void> close() {
    final Callable<Void> callable = new Callable<Void>() {

        @Override
        public Void call() {
            closeChannel();
            return null;
        }
    };
    return scheduleTask(callable);
}
#method_after
public Future<Void> close() {
    return disconnect();
}
#end_block

#method_before
public void process() throws IOException, ClientConnectionException {
    processIncoming();
    checkHeartBeat();
    processOutgoing();
}
#method_after
public void process() throws IOException, ClientConnectionException {
    processIncoming();
    processHeartbeat();
    processOutgoing();
}
#end_block

#method_before
@SuppressWarnings("incomplete-switch")
public Runnable process() throws IOException, ClientConnectionException {
    if (!handshakeInProgress()) {
        if (this.callback != null) {
            this.callback.checkAndExecute();
        }
        return null;
    }
    final SSLEngineResult.HandshakeStatus hs = this.engine.getHandshakeStatus();
    switch(hs) {
        case NEED_UNWRAP:
            this.read(appPeerBuffer);
            this.client.updateLastHeartBeat();
            return null;
        case NEED_WRAP:
            this.write(appBuffer);
            return null;
        case NEED_TASK:
            return engine.getDelegatedTask();
    }
    return null;
}
#method_after
@SuppressWarnings("incomplete-switch")
public Runnable process() throws IOException, ClientConnectionException {
    if (!handshakeInProgress()) {
        if (this.callback != null) {
            this.callback.checkAndExecute();
        }
        return null;
    }
    final SSLEngineResult.HandshakeStatus hs = this.engine.getHandshakeStatus();
    switch(hs) {
        case NEED_UNWRAP:
            this.read(appPeerBuffer);
            this.client.updateLastHeartbeat();
            return null;
        case NEED_WRAP:
            this.write(appBuffer);
            return null;
        case NEED_TASK:
            return engine.getDelegatedTask();
    }
    return null;
}
#end_block

#method_before
private boolean validate() {
    RegexValidation tempVar = new RegexValidation();
    // $NON-NLS-1$
    tempVar.setExpression("^[A-Za-z0-9_]{1,15}$");
    tempVar.setMessage(ConstantsManager.getInstance().getConstants().nameMustContainAlphanumericMaxLenMsg());
    RegexValidation tempVar2 = new RegexValidation();
    tempVar2.setIsNegate(true);
    // $NON-NLS-1$
    tempVar2.setExpression("^(bond)");
    tempVar2.setMessage(ConstantsManager.getInstance().getConstants().networkNameStartMsg());
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar, tempVar2 });
    LengthValidation tempVar3 = new LengthValidation();
    tempVar3.setMaxLength(40);
    getDescription().validateEntity(new IValidation[] { tempVar3 });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getVLanTag().setIsValid(true);
    if (getHasVLanTag().getEntity()) {
        IntegerValidation tempVar4 = new IntegerValidation();
        tempVar4.setMinimum(0);
        tempVar4.setMaximum(4094);
        getVLanTag().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar4 });
    }
    IntegerValidation tempVar5 = new IntegerValidation();
    tempVar5.setMinimum(68);
    getMtu().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar5 });
    getExternalProviders().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    boolean subnetValid = true;
    if ((Boolean) getExport().getEntity() && (Boolean) getCreateSubnet().getEntity()) {
        subnetValid = getSubnetModel().validate();
    }
    boolean profilesValid = true;
    Iterable<VnicProfileModel> profiles = getProfiles().getItems();
    for (VnicProfileModel profileModel : profiles) {
        if (!profileModel.validate()) {
            profilesValid = false;
        }
    }
    getNetworkLabel().validateSelectedItem(new IValidation[] { new AsciiNameValidation() });
    setIsGeneralTabValid(getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && subnetValid && getNetworkLabel().getIsValid());
    setIsVnicProfileTabValid(profilesValid);
    return getIsGeneralTabValid() && getIsVnicProfileTabValid();
}
#method_after
private boolean validate() {
    RegexValidation tempVar = new RegexValidation();
    // $NON-NLS-1$
    tempVar.setExpression("^[A-Za-z0-9_]{1,15}$");
    tempVar.setMessage(ConstantsManager.getInstance().getConstants().nameMustContainAlphanumericMaxLenMsg());
    RegexValidation tempVar2 = new RegexValidation();
    tempVar2.setIsNegate(true);
    // $NON-NLS-1$
    tempVar2.setExpression("^(bond)");
    tempVar2.setMessage(ConstantsManager.getInstance().getConstants().networkNameStartMsg());
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar, tempVar2 });
    LengthValidation tempVar3 = new LengthValidation();
    tempVar3.setMaxLength(40);
    getDescription().validateEntity(new IValidation[] { tempVar3 });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getVLanTag().setIsValid(true);
    if (getHasVLanTag().getEntity()) {
        IntegerValidation tempVar4 = new IntegerValidation();
        tempVar4.setMinimum(0);
        tempVar4.setMaximum(4094);
        getVLanTag().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar4 });
    }
    IntegerValidation tempVar5 = new IntegerValidation();
    tempVar5.setMinimum(68);
    getMtu().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar5 });
    getExternalProviders().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    boolean subnetValid = true;
    if ((Boolean) getExport().getEntity() && (Boolean) getCreateSubnet().getEntity()) {
        subnetValid = getSubnetModel().validate();
    }
    boolean profilesValid = true;
    Iterable<VnicProfileModel> profiles = getProfiles().getItems();
    for (VnicProfileModel profileModel : profiles) {
        if (!profileModel.validate()) {
            profilesValid = false;
        }
    }
    getNetworkLabel().validateSelectedItem(new IValidation[] { new AsciiNameValidation() });
    setIsGeneralTabValid(getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && getNetworkLabel().getIsValid());
    setIsVnicProfileTabValid(profilesValid);
    setIsSubnetTabValid(subnetValid);
    return getIsGeneralTabValid() && getIsVnicProfileTabValid() && getIsSubnetTabValid();
}
#end_block

#method_before
@Override
public void init(final T model) {
    // Let the parent do its work
    super.init(model);
    // Listen to Properties
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            NetworkModel model = (NetworkModel) sender;
            String propertyName = ((PropertyChangedEventArgs) args).propertyName;
            if ("Message".equals(propertyName)) {
                // $NON-NLS-1$
                getView().setMessageLabel(model.getMessage());
            } else if ("IsGeneralTabValid".equals(propertyName)) {
                // $NON-NLS-1$
                getView().updateGeneralTabValidity(model.getIsGeneralTabValid());
            } else if ("IsVnicProfileTabValid".equals(propertyName)) {
                // $NON-NLS-1$
                getView().updateVnicProfileTabValidity(model.getIsVnicProfileTabValid());
            }
        }
    });
    getView().toggleSubnetVisibility((Boolean) model.getExport().getEntity());
    model.getExport().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            getView().toggleSubnetVisibility((Boolean) model.getExport().getEntity());
        }
    });
    getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
    model.getProfiles().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
            }
        }
    });
    getView().getQosButton().setCommand(model.getAddQosCommand());
    getView().getQosButton().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getQosButton().getCommand().execute();
        }
    });
    getView().addMtuEditor();
}
#method_after
@Override
public void init(final T model) {
    // Let the parent do its work
    super.init(model);
    // Listen to Properties
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            NetworkModel model = (NetworkModel) sender;
            String propertyName = ((PropertyChangedEventArgs) args).propertyName;
            if ("Message".equals(propertyName)) {
                // $NON-NLS-1$
                getView().setMessageLabel(model.getMessage());
            } else if ("IsGeneralTabValid".equals(propertyName)) {
                // $NON-NLS-1$
                getView().updateGeneralTabValidity(model.getIsGeneralTabValid());
            } else if ("IsVnicProfileTabValid".equals(propertyName)) {
                // $NON-NLS-1$
                getView().updateVnicProfileTabValidity(model.getIsVnicProfileTabValid());
            } else if ("IsSubnetTabValid".equals(propertyName)) {
                // $NON-NLS-1$
                getView().updateSubnetTabValidity(model.getIsSubnetTabValid());
            }
        }
    });
    getView().toggleSubnetVisibility((Boolean) model.getExport().getEntity());
    model.getExport().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            getView().toggleSubnetVisibility((Boolean) model.getExport().getEntity());
        }
    });
    getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
    model.getProfiles().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
            }
        }
    });
    getView().getQosButton().setCommand(model.getAddQosCommand());
    getView().getQosButton().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getQosButton().getCommand().execute();
        }
    });
    getView().addMtuEditor();
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getInstanceTypes().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getSerialNumberPolicy().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangable(false);
        getRngPeriod().setIsChangable(false);
        getRngBytes().setIsChangable(false);
        getRngSourceRandom().setIsChangable(false);
        getRngSourceHwrng().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getInstanceTypes().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getSerialNumberPolicy().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangable(false);
        getRngPeriod().setIsChangable(false);
        getRngBytes().setIsChangable(false);
        getRngSourceRandom().setIsChangable(false);
        getRngSourceHwrng().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        getCustomPropertySheet().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            vmTypeChanged();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            vmTypeChanged();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            updateMemoryBalloonDevice();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            deactivateInstanceTypeManagerAndUpdateFields();
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            updateMemoryBalloonDevice();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        }
    }
}
#end_block

#method_before
protected void initNumOfMonitors() {
    AsyncDataProvider.getNumOfMonitorList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            Integer oldNumOfMonitors = null;
            if (model.getNumOfMonitors().getSelectedItem() != null) {
                oldNumOfMonitors = model.getNumOfMonitors().getSelectedItem();
            }
            ArrayList<Integer> numOfMonitors = (ArrayList<Integer>) returnValue;
            model.getNumOfMonitors().setItems(numOfMonitors);
            if (oldNumOfMonitors != null) {
                model.getNumOfMonitors().setSelectedItem(oldNumOfMonitors);
            }
        }
    }, getHash()));
}
#method_after
protected void initNumOfMonitors() {
    AsyncDataProvider.getInstance().getNumOfMonitorList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            Integer oldNumOfMonitors = null;
            if (model.getNumOfMonitors().getSelectedItem() != null) {
                oldNumOfMonitors = model.getNumOfMonitors().getSelectedItem();
            }
            ArrayList<Integer> numOfMonitors = (ArrayList<Integer>) returnValue;
            model.getNumOfMonitors().setItems(numOfMonitors);
            if (oldNumOfMonitors != null) {
                model.getNumOfMonitors().setSelectedItem(oldNumOfMonitors);
            }
        }
    }, getHash()));
}
#end_block

#method_before
private void initUsbPolicy() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    DisplayType displayType = (getDisplayProtocol().getSelectedItem() != null ? getDisplayProtocol().getSelectedItem().getEntity() : null);
    if (osType == null || cluster == null || displayType == null) {
        return;
    }
    getUsbPolicy().setIsChangable(true);
    UsbPolicy prevSelectedUsbPolicy = getUsbPolicy().getSelectedItem();
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) > 0) {
        if (AsyncDataProvider.isWindowsOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED));
            getUsbPolicy().setIsChangable(false);
        }
    }
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) <= 0) {
        if (AsyncDataProvider.isLinuxOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_NATIVE));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY, UsbPolicy.ENABLED_NATIVE));
        }
    }
    if (displayType != DisplayType.qxl) {
        getUsbPolicy().setIsChangable(false);
    }
    Collection<UsbPolicy> policies = getUsbPolicy().getItems();
    if (policies.contains(prevSelectedUsbPolicy)) {
        getUsbPolicy().setSelectedItem(prevSelectedUsbPolicy);
    } else if (policies.size() > 0) {
        getUsbPolicy().setSelectedItem(policies.iterator().next());
    }
}
#method_after
private void initUsbPolicy() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    DisplayType displayType = (getDisplayProtocol().getSelectedItem() != null ? getDisplayProtocol().getSelectedItem().getEntity() : null);
    if (osType == null || cluster == null || displayType == null) {
        return;
    }
    getUsbPolicy().setIsChangable(true);
    UsbPolicy prevSelectedUsbPolicy = getUsbPolicy().getSelectedItem();
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) > 0) {
        if (AsyncDataProvider.getInstance().isWindowsOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED));
            getUsbPolicy().setIsChangable(false);
        }
    }
    if (Version.v3_1.compareTo(cluster.getcompatibility_version()) <= 0) {
        if (AsyncDataProvider.getInstance().isLinuxOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_NATIVE));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY, UsbPolicy.ENABLED_NATIVE));
        }
    }
    if (displayType != DisplayType.qxl) {
        getUsbPolicy().setIsChangable(false);
    }
    Collection<UsbPolicy> policies = getUsbPolicy().getItems();
    if (policies.contains(prevSelectedUsbPolicy)) {
        getUsbPolicy().setSelectedItem(prevSelectedUsbPolicy);
    } else if (policies.size() > 0) {
        getUsbPolicy().setSelectedItem(policies.iterator().next());
    }
}
#end_block

#method_before
private void updateMigrationOptions() {
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    VDSGroup cluster = dataCenterWithCluster.getCluster();
    Boolean isMigrationSupported = AsyncDataProvider.isMigrationSupported(cluster.getArchitecture(), cluster.getcompatibility_version());
    if (isMigrationSupported) {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.values()));
    } else {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.PINNED_TO_HOST));
    }
}
#method_after
private void updateMigrationOptions() {
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster == null) {
        return;
    }
    VDSGroup cluster = dataCenterWithCluster.getCluster();
    Boolean isMigrationSupported = AsyncDataProvider.getInstance().isMigrationSupported(cluster.getArchitecture(), cluster.getcompatibility_version());
    if (isMigrationSupported) {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.values()));
    } else {
        getMigrationMode().setItems(Arrays.asList(MigrationSupport.PINNED_TO_HOST));
    }
}
#end_block

#method_before
private void updateDisplayProtocol() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    List<DisplayType> displayTypes = AsyncDataProvider.getDisplayTypes(osType, cluster.getcompatibility_version());
    initDisplayProtocolWithTypes(displayTypes);
}
#method_after
private void updateDisplayProtocol() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    List<DisplayType> displayTypes = AsyncDataProvider.getInstance().getDisplayTypes(osType, cluster.getcompatibility_version());
    initDisplayProtocolWithTypes(displayTypes);
}
#end_block

#method_before
private void initVncKeyboardLayout() {
    final List<String> layouts = (List<String>) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayoutValidValues);
    final ArrayList<String> vncKeyboardLayoutItems = new ArrayList<String>();
    // null value means the global VncKeyboardLayout from vdc_options will be used
    vncKeyboardLayoutItems.add(null);
    vncKeyboardLayoutItems.addAll(layouts);
    getVncKeyboardLayout().setItems(vncKeyboardLayoutItems);
    getVncKeyboardLayout().setIsAvailable(isVncSelected());
}
#method_after
private void initVncKeyboardLayout() {
    final List<String> layouts = (List<String>) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayoutValidValues);
    final ArrayList<String> vncKeyboardLayoutItems = new ArrayList<String>();
    // null value means the global VncKeyboardLayout from vdc_options will be used
    vncKeyboardLayoutItems.add(null);
    vncKeyboardLayoutItems.addAll(layouts);
    getVncKeyboardLayout().setItems(vncKeyboardLayoutItems);
    getVncKeyboardLayout().setIsAvailable(isVncSelected());
}
#end_block

#method_before
private void updateBootMenu() {
    if (getSelectedCluster() != null) {
        Version version = getSelectedCluster().getcompatibility_version();
        final boolean supported = AsyncDataProvider.isBootMenuSupported(version.toString());
        if (!supported) {
            getBootMenuEnabled().setEntity(false);
            getBootMenuEnabled().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().bootMenuNotSupported(version.toString(2)));
        }
        getBootMenuEnabled().setIsChangable(supported);
    }
}
#method_after
private void updateBootMenu() {
    if (getSelectedCluster() != null) {
        Version version = getSelectedCluster().getcompatibility_version();
        final boolean supported = AsyncDataProvider.getInstance().isBootMenuSupported(version.toString());
        if (!supported) {
            getBootMenuEnabled().setEntity(false);
            getBootMenuEnabled().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().bootMenuNotSupported(version.toString(2)));
        }
        getBootMenuEnabled().setIsChangable(supported);
    }
}
#end_block

#method_before
private void handleQxlClusterLevel() {
    // Enable Single PCI only on cluster 3.3 and high and on Linux OS
    boolean isLinux = getIsLinuxOS();
    boolean isQxl = getDisplayType() == DisplayType.qxl;
    boolean clusterSupportsSinglePci = getSelectedCluster() != null && Version.v3_3.compareTo(getSelectedCluster().getcompatibility_version()) <= 0;
    getBehavior().enableSinglePCI(isLinux && isQxl && clusterSupportsSinglePci);
    if (getSelectedCluster() != null) {
        boolean spiceFileTransferToggle = isQxl && AsyncDataProvider.isSpiceFileTransferToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceFileTransferToggle) {
            handleQxlChangeProhibitionReason(getSpiceFileTransferEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceFileTransferEnabled().setIsChangable(spiceFileTransferToggle);
        boolean spiceCopyPasteToggle = isQxl && AsyncDataProvider.isSpiceCopyPasteToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceCopyPasteToggle) {
            handleQxlChangeProhibitionReason(getSpiceCopyPasteEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceCopyPasteEnabled().setIsChangable(spiceCopyPasteToggle);
    }
}
#method_after
private void handleQxlClusterLevel() {
    getBehavior().enableSinglePCI(getIsQxlSupported());
    if (getSelectedCluster() != null) {
        boolean isQxl = getDisplayType() == DisplayType.qxl;
        boolean spiceFileTransferToggle = isQxl && AsyncDataProvider.getInstance().isSpiceFileTransferToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceFileTransferToggle) {
            handleQxlChangeProhibitionReason(getSpiceFileTransferEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceFileTransferEnabled().setIsChangable(spiceFileTransferToggle);
        boolean spiceCopyPasteToggle = isQxl && AsyncDataProvider.getInstance().isSpiceCopyPasteToggleSupported(getSelectedCluster().getcompatibility_version().toString());
        if (!spiceCopyPasteToggle) {
            handleQxlChangeProhibitionReason(getSpiceCopyPasteEnabled(), getSelectedCluster().getcompatibility_version().toString(), isQxl);
        }
        getSpiceCopyPasteEnabled().setIsChangable(spiceCopyPasteToggle);
    }
}
#end_block

#method_before
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
    updateWatchdogModels(osType);
    vmInitEnabledChanged();
}
#method_after
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.getInstance().isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.getInstance().isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
    updateWatchdogModels(osType);
    vmInitEnabledChanged();
}
#end_block

#method_before
private void updateWatchdogModels(Integer osType) {
    VDSGroup cluster = getSelectedCluster();
    if (osType != null && cluster != null && getWatchdogModel() != null) {
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                getBehavior().deactivateInstanceTypeManager();
                updateWatchdogItems((HashSet<VmWatchdogType>) ((VdcQueryReturnValue) returnValue).getReturnValue());
                getBehavior().activateInstanceTypeManager();
            }
        };
        AsyncDataProvider.getVmWatchdogTypes(osType, cluster.getcompatibility_version(), asyncQuery);
    }
}
#method_after
private void updateWatchdogModels(Integer osType) {
    VDSGroup cluster = getSelectedCluster();
    if (osType != null && cluster != null && getWatchdogModel() != null) {
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                getBehavior().deactivateInstanceTypeManager();
                updateWatchdogItems((HashSet<VmWatchdogType>) ((VdcQueryReturnValue) returnValue).getReturnValue());
                getBehavior().activateInstanceTypeManager();
            }
        };
        AsyncDataProvider.getInstance().getVmWatchdogTypes(osType, cluster.getcompatibility_version(), asyncQuery);
    }
}
#end_block

#method_before
public void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<String> watchDogModels = new ArrayList<String>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(EnumTranslator.createAndTranslate(vmWatchdogType));
    }
    watchDogModels.add(0, null);
    String oldWatchdogSelected = (String) getWatchdogModel().getSelectedItem();
    getWatchdogModel().setItems(watchDogModels);
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#method_after
public void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<String> watchDogModels = new ArrayList<String>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(EnumTranslator.getInstance().get(vmWatchdogType));
    }
    watchDogModels.add(0, null);
    String oldWatchdogSelected = (String) getWatchdogModel().getSelectedItem();
    getWatchdogModel().setItems(watchDogModels);
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#end_block

#method_before
private DisplayType getDisplayType() {
    EntityModel<DisplayType> entityModel = getDisplayProtocol().getSelectedItem();
    if (entityModel == null) {
        return null;
    }
    return entityModel.getEntity();
}
#method_after
public DisplayType getDisplayType() {
    EntityModel<DisplayType> entityModel = getDisplayProtocol().getSelectedItem();
    if (entityModel == null) {
        return null;
    }
    return entityModel.getEntity();
}
#end_block

#method_before
public boolean validate() {
    boolean hwPartValid = validateHwPart();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    setIsGeneralTabValid(getIsGeneralTabValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid());
    setIsFirstRunTabValid(getTimeZone().getIsValid());
    setIsHostTabValid(getIsHostTabValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getIsAllocationTabValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setIsFirstRunTabValid(vmInitIsValid);
    boolean isValid = hwPartValid && vmInitIsValid && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && getQuota().getIsValid();
    getValid().setEntity(isValid);
    return isValid;
}
#method_after
public boolean validate() {
    boolean hwPartValid = validateHwPart();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.getInstance().isWindowsOsType(osType) ? AsyncDataProvider.getInstance().getMaxVmNameLengthWin() : AsyncDataProvider.getInstance().getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    setIsGeneralTabValid(getIsGeneralTabValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid());
    setIsFirstRunTabValid(getTimeZone().getIsValid());
    setIsHostTabValid(getIsHostTabValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getIsAllocationTabValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setIsFirstRunTabValid(vmInitIsValid);
    boolean isValid = hwPartValid && vmInitIsValid && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && getQuota().getIsValid();
    getValid().setEntity(isValid);
    return isValid;
}
#end_block

#method_before
public boolean validateHwPart() {
    resetTabsValidity();
    getValid().setEntity(true);
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getMinAllocatedMemory().getIsValid());
    getRngBytes().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE), new RngDevValidation() });
    getRngPeriod().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE) });
    setRngTabValid(getRngBytes().getIsValid() && getRngPeriod().getIsValid());
    setIsSystemTabValid(getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid());
    // Minimum 'Physical Memory Guaranteed' is 1MB
    validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
    if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
        validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
    }
    boolean isValid = behaviorValid && customPropertySheetValid && getName().getIsValid() && getDescription().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getUsbPolicy().getIsValid() && getMigrationDowntime().getIsValid() && getRngBytes().getIsValid() && getRngPeriod().getIsValid() && getTotalCPUCores().getIsValid();
    getValid().setEntity(isValid);
    return isValid;
}
#method_after
public boolean validateHwPart() {
    resetTabsValidity();
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getMinAllocatedMemory().getIsValid());
    getRngBytes().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE), new RngDevValidation() });
    getRngPeriod().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE) });
    setRngTabValid(getRngBytes().getIsValid() && getRngPeriod().getIsValid());
    setIsSystemTabValid(getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid());
    // Minimum 'Physical Memory Guaranteed' is 1MB
    validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
    if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
        validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
    }
    boolean isValid = behaviorValid && customPropertySheetValid && getName().getIsValid() && getDescription().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getUsbPolicy().getIsValid() && getMigrationDowntime().getIsValid() && getRngBytes().getIsValid() && getRngPeriod().getIsValid() && getTotalCPUCores().getIsValid();
    getValid().setEntity(isValid);
    return isValid;
}
#end_block

#method_before
private void resetTabsValidity() {
    setIsGeneralTabValid(true);
    setIsSystemTabValid(true);
    setIsFirstRunTabValid(true);
    setIsDisplayTabValid(true);
    setIsHostTabValid(true);
    setIsAllocationTabValid(true);
    setIsBootSequenceTabValid(true);
    setRngTabValid(true);
    setIsCustomPropertiesTabValid(true);
}
#method_after
private void resetTabsValidity() {
    setIsGeneralTabValid(true);
    setIsSystemTabValid(true);
    setIsFirstRunTabValid(true);
    setIsDisplayTabValid(true);
    setIsHostTabValid(true);
    setIsAllocationTabValid(true);
    setIsBootSequenceTabValid(true);
    setRngTabValid(true);
    setIsCustomPropertiesTabValid(true);
    getValid().setEntity(true);
}
#end_block

#method_before
@Override
public HandlerRegistration addValueChangeHandler(final ValueChangeHandler<E> handler) {
    // don't add to peer, since its changed value is the entire item list
    return bus.addHandler(ValueChangeEvent.getType(), handler);
}
#method_after
@Override
public HandlerRegistration addValueChangeHandler(final ValueChangeHandler<E> handler) {
    // don't add to peer, since its changed value is the entire item list
    return handlerManager.addHandler(ValueChangeEvent.getType(), handler);
}
#end_block

#method_before
@Override
public void fireEvent(GwtEvent<?> event) {
    bus.fireEvent(event);
}
#method_after
@Override
public void fireEvent(GwtEvent<?> event) {
    handlerManager.fireEvent(event);
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return getDisplayableTemplateVersionName(data);
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(getDisplayableTemplateVersionName(data), data.getDescription());
        }

        private String getDisplayableTemplateVersionName(VmTemplate template) {
            String versionName = template.getTemplateVersionName();
            if (ConstantsManager.getInstance().getConstants().latestTemplateVersionName().equals(versionName)) {
                return constants.latest();
            }
            versionName = template.getId().equals(template.getBaseTemplateId()) ? constants.baseTemplate() : template.getTemplateVersionName();
            return // $NON-NLS-1$
            (versionName == null ? "" : versionName) + // $NON-NLS-1$
            StringFormat.format(" (%d)", template.getTemplateVersionNumber());
        }
    }, new ModeSwitchingVisibilityRenderer());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    instanceTypesEditor = new ListModelTypeAheadListBoxEditor<InstanceType>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<InstanceType>() {

        @Override
        public String getReplacementStringNullSafe(InstanceType data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(InstanceType data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(numOfSocketsEditor);
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(corePerSocketEditor);
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxOnlyEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.tzVmPopup());
    timeZoneEditorWithInfo = new EntityModelWidgetWithInfo<String>(label, timeZoneEditor);
    timeZoneEditorWithInfo.setExplanation(applicationTemplates.italicText(constants.timeZoneInfo()));
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<EntityModel<DisplayType>>(new NullSafeRenderer<EntityModel<DisplayType>>() {

        @Override
        public String renderNullSafe(EntityModel<DisplayType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return getDisplayableTemplateVersionName(data);
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(getDisplayableTemplateVersionName(data), data.getDescription());
        }

        private String getDisplayableTemplateVersionName(VmTemplate template) {
            String versionName = template.getTemplateVersionName();
            if (ConstantsManager.getInstance().getConstants().latestTemplateVersionName().equals(versionName)) {
                return constants.latest();
            }
            versionName = template.getId().equals(template.getBaseTemplateId()) ? constants.baseTemplate() : template.getTemplateVersionName();
            return // $NON-NLS-1$
            (versionName == null ? "" : versionName) + // $NON-NLS-1$
            StringFormat.format(" (%d)", template.getTemplateVersionNumber());
        }
    }, new ModeSwitchingVisibilityRenderer());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getInstance().getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    instanceTypesEditor = new ListModelTypeAheadListBoxEditor<InstanceType>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<InstanceType>() {

        @Override
        public String getReplacementStringNullSafe(InstanceType data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(InstanceType data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(numOfSocketsEditor);
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(corePerSocketEditor);
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxOnlyEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.tzVmPopup());
    timeZoneEditorWithInfo = new EntityModelWidgetWithInfo<String>(label, timeZoneEditor);
    timeZoneEditorWithInfo.setExplanation(applicationTemplates.italicText(constants.timeZoneInfo()));
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<EntityModel<DisplayType>>(new NullSafeRenderer<EntityModel<DisplayType>>() {

        @Override
        public String renderNullSafe(EntityModel<DisplayType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#end_block

#method_before
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            VDSGroup vdsGroup = object.getSelectedCluster();
            if (vdsGroup != null && vdsGroup.getcompatibility_version() != null) {
                boolean enabled = AsyncDataProvider.isSerialNumberPolicySupported(vdsGroup.getcompatibility_version().getValue());
                changeApplicationLevelVisibility(serialNumberPolicyEditor, enabled);
            }
        }
    });
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            rngPanel.setVisible((Boolean) object.getIsRngEnabled().getEntity());
        }
    });
}
#method_after
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!(args instanceof PropertyChangedEventArgs)) {
                return;
            }
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            VDSGroup vdsGroup = object.getSelectedCluster();
            if (vdsGroup != null && vdsGroup.getcompatibility_version() != null) {
                boolean enabled = AsyncDataProvider.getInstance().isSerialNumberPolicySupported(vdsGroup.getcompatibility_version().getValue());
                changeApplicationLevelVisibility(serialNumberPolicyEditor, enabled);
            }
        }
    });
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            rngPanel.setVisible((Boolean) object.getIsRngEnabled().getEntity());
        }
    });
}
#end_block

#method_before
protected void updateUsbNativeMessageVisibility(final UnitVmModel object) {
    Version vdsGroupVersion = clusterVersionOrNull(object);
    changeApplicationLevelVisibility(nativeUsbWarningMessage, object.getUsbPolicy().getSelectedItem() == UsbPolicy.ENABLED_NATIVE && vdsGroupVersion != null && !(Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MigrationSupportForNativeUsb, vdsGroupVersion.getValue()));
}
#method_after
protected void updateUsbNativeMessageVisibility(final UnitVmModel object) {
    Version vdsGroupVersion = clusterVersionOrNull(object);
    changeApplicationLevelVisibility(nativeUsbWarningMessage, object.getUsbPolicy().getSelectedItem() == UsbPolicy.ENABLED_NATIVE && vdsGroupVersion != null && !(Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MigrationSupportForNativeUsb, vdsGroupVersion.getValue()));
}
#end_block

#method_before
private void updateDisksWarningByImageStatus(List<DiskModel> disks, ImageStatus imageStatus) {
    ArrayList<String> disksAliases = getDisksAliasesByImageStatus(disks, imageStatus);
    if (!disksAliases.isEmpty()) {
        generalWarningMessage.setText(messages.disksStatusWarning(EnumTranslator.createAndTranslate(imageStatus), // $NON-NLS-1$
        (StringUtils.join(disksAliases, ", "))));
    }
}
#method_after
private void updateDisksWarningByImageStatus(List<DiskModel> disks, ImageStatus imageStatus) {
    ArrayList<String> disksAliases = getDisksAliasesByImageStatus(disks, imageStatus);
    if (!disksAliases.isEmpty()) {
        generalWarningMessage.setText(messages.disksStatusWarning(EnumTranslator.getInstance().get(imageStatus), // $NON-NLS-1$
        (StringUtils.join(disksAliases, ", "))));
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    initCommandExecutor();
    CommandEntity cmdEntity;
    for (Iterator<Entry<Guid, CommandCallBack>> iterator = cmdCallBackMap.entrySet().iterator(); iterator.hasNext(); ) {
        Entry<Guid, CommandCallBack> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CommandCallBack callBack = entry.getValue();
        CommandStatus status = coco.getCommandStatus(cmdId);
        switch(status) {
            case FAILED:
                callBack.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case SUCCEEDED:
                callBack.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case ACTIVE:
                cmdEntity = coco.getCommandEntity(cmdId);
                if (cmdEntity.isExecuted()) {
                    callBack.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                }
                break;
            default:
                break;
        }
    }
}
#method_after
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    initCommandExecutor();
    for (Iterator<Entry<Guid, CommandCallBack>> iterator = cmdCallBackMap.entrySet().iterator(); iterator.hasNext(); ) {
        Entry<Guid, CommandCallBack> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CommandCallBack callBack = entry.getValue();
        CommandStatus status = coco.getCommandStatus(cmdId);
        switch(status) {
            case FAILED:
                callBack.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case SUCCEEDED:
                callBack.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case ACTIVE:
                if (coco.getCommandEntity(cmdId).isExecuted()) {
                    callBack.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                }
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    initCommandExecutor();
    for (Iterator<Entry<Guid, CommandCallBack>> iterator = cmdCallBackMap.entrySet().iterator(); iterator.hasNext(); ) {
        Entry<Guid, CommandCallBack> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CommandCallBack callBack = entry.getValue();
        CommandStatus status = coco.getCommandStatus(cmdId);
        switch(status) {
            case FAILED:
                try {
                    callBack.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                } catch (Exception ex) {
                    log.errorFormat("Error invoking onFailed for FAILED command {0}", cmdId.toString());
                }
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case SUCCEEDED:
                try {
                    callBack.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                } catch (Exception ex) {
                    log.errorFormat("Error invoking onSucceeded for SUCCEEDED command {0}", cmdId.toString());
                }
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case ACTIVE_ASYNC_EXECUTED:
                try {
                    callBack.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                } catch (Exception ex) {
                    // an unexpected error in doPolling has occurred, we fail the command
                    // so doPolling is not called invoked over and over again
                    coco.retrieveCommand(cmdId).setCommandStatus(CommandStatus.FAILED);
                    log.errorFormat("Error invoking doPooling for active command {0}", cmdId.toString());
                }
                break;
            default:
                break;
        }
    }
}
#method_after
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    initCommandExecutor();
    for (Iterator<Entry<Guid, CommandCallBack>> iterator = cmdCallBackMap.entrySet().iterator(); iterator.hasNext(); ) {
        Entry<Guid, CommandCallBack> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CommandCallBack callBack = entry.getValue();
        CommandStatus status = coco.getCommandStatus(cmdId);
        boolean errorInCallback = false;
        try {
            switch(status) {
                case FAILED:
                    callBack.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                    break;
                case SUCCEEDED:
                    callBack.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                    break;
                case ACTIVE:
                    if (coco.getCommandEntity(cmdId).isExecuted()) {
                        callBack.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                    }
                    break;
                default:
                    break;
            }
        } catch (Exception ex) {
            errorInCallback = true;
            handleError(ex, status, cmdId);
        } finally {
            if (CommandStatus.FAILED.equals(status) || (CommandStatus.SUCCEEDED.equals(status) && !errorInCallback)) {
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
            }
        }
    }
}
#end_block

#method_before
private void initCommandExecutor() {
    if (!cmdExecutorInitialized) {
        for (CommandEntity cmdEntity : coco.getCommandsWithCallBackEnabled()) {
            switch(cmdEntity.getCommandStatus()) {
                case ACTIVE_SYNC:
                case ACTIVE_ASYNC:
                case NOT_STARTED:
                    coco.retrieveCommand(cmdEntity.getId()).setCommandStatus(CommandStatus.FAILED_RESTARTED);
                    break;
                default:
                    if (!cmdEntity.isCallBackNotified()) {
                        addToCallBackMap(cmdEntity);
                    }
                    break;
            }
        }
        cmdExecutorInitialized = true;
    }
}
#method_after
private void initCommandExecutor() {
    if (!cmdExecutorInitialized) {
        for (CommandEntity cmdEntity : coco.getCommandsWithCallBackEnabled()) {
            if (!cmdEntity.isExecuted()) {
                coco.retrieveCommand(cmdEntity.getId()).setCommandStatus(CommandStatus.FAILED_RESTARTED);
            } else if (!cmdEntity.isCallBackNotified()) {
                addToCallBackMap(cmdEntity);
            }
        }
        cmdExecutorInitialized = true;
    }
}
#end_block

#method_before
public Guid executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters, final CommandContext cmdContext) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, cmdContext);
    command.persistCommand(command.getParameters().getParentCommand(), cmdContext, true);
    CommandCallBack callBack = command.getCallBack();
    if (callBack != null) {
        cmdCallBackMap.put(command.getCommandId(), callBack);
    }
    try {
        executor.submit(new Callable<VdcReturnValueBase>() {

            @Override
            public VdcReturnValueBase call() throws Exception {
                return executeCommand(command, cmdContext);
            }
        });
    } catch (RejectedExecutionException ex) {
        command.setCommandStatus(CommandStatus.FAILED);
    }
    return command.getCommandId();
}
#method_after
public Future<VdcReturnValueBase> executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters, final CommandContext cmdContext) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, cmdContext);
    command.persistCommand(command.getParameters().getParentCommand(), cmdContext, true);
    CommandCallBack callBack = command.getCallBack();
    if (callBack != null) {
        cmdCallBackMap.put(command.getCommandId(), callBack);
    }
    Future<VdcReturnValueBase> retVal;
    try {
        retVal = executor.submit(new Callable<VdcReturnValueBase>() {

            @Override
            public VdcReturnValueBase call() throws Exception {
                return executeCommand(command, cmdContext);
            }
        });
    } catch (RejectedExecutionException ex) {
        command.setCommandStatus(CommandStatus.FAILED);
        log.errorFormat("Failed to submit command to executor service, command {0} status has been set to FAILED", command.getCommandId().toString());
        retVal = new RejectedExecutionFuture();
    }
    return retVal;
}
#end_block

#method_before
private void updateCommand(final CommandBase<?> command, final VdcReturnValueBase result) {
    CommandEntity cmdEntity = coco.getCommandEntity(command.getCommandId());
    cmdEntity.setReturnValue(result);
    if (!result.getCanDoAction()) {
        cmdEntity.setCommandStatus(CommandStatus.FAILED);
    } else if (CommandStatus.ACTIVE_SYNC.equals(cmdEntity.getCommandStatus())) {
        cmdEntity.setCommandStatus(result.getSucceeded() ? CommandStatus.SUCCEEDED : CommandStatus.FAILED);
    }
    coco.persistCommand(cmdEntity);
}
#method_after
private void updateCommand(final CommandBase<?> command, final VdcReturnValueBase result) {
    CommandEntity cmdEntity = coco.getCommandEntity(command.getCommandId());
    cmdEntity.setReturnValue(result);
    if (!result.getCanDoAction()) {
        cmdEntity.setCommandStatus(CommandStatus.FAILED);
    }
    coco.persistCommand(cmdEntity);
}
#end_block

#method_before
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    initCommandExecutor();
    for (Iterator<Entry<Guid, CommandCallBack>> iterator = cmdCallBackMap.entrySet().iterator(); iterator.hasNext(); ) {
        Entry<Guid, CommandCallBack> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CommandCallBack callBack = entry.getValue();
        CommandStatus status = coco.getCommandStatus(cmdId);
        switch(status) {
            case FAILED:
                callBack.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case SUCCEEDED:
                callBack.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case ACTIVE_ASYNC_EXECUTED:
                callBack.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                break;
            default:
                break;
        }
    }
}
#method_after
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    initCommandExecutor();
    for (Iterator<Entry<Guid, CommandCallBack>> iterator = cmdCallBackMap.entrySet().iterator(); iterator.hasNext(); ) {
        Entry<Guid, CommandCallBack> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CommandCallBack callBack = entry.getValue();
        CommandStatus status = coco.getCommandStatus(cmdId);
        switch(status) {
            case FAILED:
                callBack.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case SUCCEEDED:
                callBack.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case ACTIVE:
            case ACTIVE_ASYNC:
                if (coco.getCommandEntity(cmdId).isExecuted()) {
                    callBack.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                }
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
private void initCommandExecutor() {
    if (!cmdExecutorInitialized) {
        for (CommandEntity cmdEntity : coco.getCommandsWithCallBackEnabled()) {
            switch(cmdEntity.getCommandStatus()) {
                case ACTIVE_SYNC:
                case ACTIVE_ASYNC:
                case NOT_STARTED:
                    coco.retrieveCommand(cmdEntity.getId()).setCommandStatus(CommandStatus.FAILED_RESTARTED);
                    break;
                default:
                    if (!cmdEntity.isCallBackNotified()) {
                        addToCallBackMap(cmdEntity);
                    }
                    break;
            }
        }
        cmdExecutorInitialized = true;
    }
}
#method_after
private void initCommandExecutor() {
    if (!cmdExecutorInitialized) {
        for (CommandEntity cmdEntity : coco.getCommandsWithCallBackEnabled()) {
            if (!cmdEntity.isExecuted()) {
                coco.retrieveCommand(cmdEntity.getId()).setCommandStatus(CommandStatus.FAILED_RESTARTED);
            } else if (!cmdEntity.isCallBackNotified()) {
                addToCallBackMap(cmdEntity);
            }
        }
        cmdExecutorInitialized = true;
    }
}
#end_block

#method_before
public Guid executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters, final CommandContext cmdContext) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, cmdContext);
    command.persistCommand(command.getParameters().getParentCommand(), cmdContext, true);
    CommandCallBack callBack = command.getCallBack();
    if (callBack != null) {
        cmdCallBackMap.put(command.getCommandId(), callBack);
    }
    try {
        executor.submit(new Callable<VdcReturnValueBase>() {

            @Override
            public VdcReturnValueBase call() throws Exception {
                return executeCommand(command, cmdContext);
            }
        });
    } catch (RejectedExecutionException ex) {
        command.setCommandStatus(CommandStatus.FAILED);
    }
    return command.getCommandId();
}
#method_after
public Future<VdcReturnValueBase> executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters, final CommandContext cmdContext) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, cmdContext);
    command.persistCommand(command.getParameters().getParentCommand(), cmdContext, true);
    CommandCallBack callBack = command.getCallBack();
    if (callBack != null) {
        cmdCallBackMap.put(command.getCommandId(), callBack);
    }
    Future<VdcReturnValueBase> retVal;
    try {
        retVal = executor.submit(new Callable<VdcReturnValueBase>() {

            @Override
            public VdcReturnValueBase call() throws Exception {
                return executeCommand(command, cmdContext);
            }
        });
    } catch (RejectedExecutionException ex) {
        command.setCommandStatus(CommandStatus.FAILED);
        log.errorFormat("Failed to submit command to executor service, command {0} status has been set to FAILED", command.getCommandId().toString());
        retVal = new RejectedExecutionFuture();
    }
    return retVal;
}
#end_block

#method_before
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        setCommandStatus(CommandStatus.FAILED);
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        setCommandStatus(CommandStatus.FAILED);
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setSucceeded(false);
            compensate();
        } else {
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#method_after
private boolean executeWithoutTransaction() {
    boolean functionReturnValue = false;
    boolean exceptionOccurred = true;
    try {
        logRunningCommand();
        if (hasTaskHandlers()) {
            getCurrentTaskHandler().execute();
        } else {
            executeCommand();
        }
        functionReturnValue = getSucceeded();
        exceptionOccurred = false;
    } catch (VdcBLLException e) {
        log.error(String.format("Command %1$s throw Vdc Bll exception. With error message %2$s", getClass().getName(), e.getMessage()));
        if (log.isDebugEnabled()) {
            log.debug(String.format("Command %1$s throw Vdc Bll exception", getClass().getName()), e);
        }
        processExceptionToClient(new VdcFault(e, e.getVdsError().getCode()));
    } catch (RuntimeException e) {
        processExceptionToClient(new VdcFault(e, VdcBllErrors.ENGINE));
        log.error(String.format("Command %1$s throw exception", getClass().getName()), e);
    } finally {
        // If we failed to execute due to exception or some other reason, we compensate for the failure.
        if (exceptionOccurred || !getSucceeded()) {
            setCommandStatus(CommandStatus.FAILED);
            setSucceeded(false);
            compensate();
        } else {
            cleanUpCompensationData();
        }
    }
    return functionReturnValue;
}
#end_block

#method_before
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#method_after
protected final void execute() {
    setCommandStatus(CommandStatus.ACTIVE);
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        setCommandExecuted();
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#end_block

#method_before
public void persistCommand(VdcActionType parentCommand, CommandContext cmdContext, boolean enableCallBack) {
    VdcActionParametersBase parentParameters = getParentParameters(parentCommand);
    Transaction transaction = TransactionSupport.suspend();
    try {
        TaskManagerUtil.persistCommand(CommandEntity.buildCommandEntity(getCommandId(), parentParameters.getCommandId(), getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallBack, getReturnValue()), cmdContext);
    } finally {
        TransactionSupport.resume(transaction);
    }
}
#method_after
public void persistCommand(VdcActionType parentCommand, CommandContext cmdContext, boolean enableCallBack) {
    VdcActionParametersBase parentParameters = getParentParameters(parentCommand);
    Transaction transaction = TransactionSupport.suspend();
    try {
        TaskManagerUtil.persistCommand(CommandEntity.buildCommandEntity(getCommandId(), parentParameters.getCommandId(), getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId(), getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId(), getActionType(), getParameters(), commandStatus, enableCallBack, getReturnValue()), cmdContext);
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#end_block

#method_before
protected void removeCommand() {
    Transaction transaction = TransactionSupport.suspend();
    try {
        TaskManagerUtil.removeCommand(getCommandId());
    } finally {
        TransactionSupport.resume(transaction);
    }
}
#method_after
protected void removeCommand() {
    Transaction transaction = TransactionSupport.suspend();
    try {
        TaskManagerUtil.removeCommand(getCommandId());
    } finally {
        if (transaction != null) {
            TransactionSupport.resume(transaction);
        }
    }
}
#end_block

#method_before
public void setCommandStatus(CommandStatus status, boolean updateDB) {
    this.commandStatus = status;
    if (updateDB) {
        Transaction transaction = TransactionSupport.suspend();
        try {
            TaskManagerUtil.updateCommandStatus(getCommandId(), getTaskType(), commandStatus);
        } finally {
            TransactionSupport.resume(transaction);
        }
    }
}
#method_after
public void setCommandStatus(CommandStatus status, boolean updateDB) {
    this.commandStatus = status;
    if (updateDB) {
        Transaction transaction = TransactionSupport.suspend();
        try {
            TaskManagerUtil.updateCommandStatus(getCommandId(), getTaskType(), commandStatus);
        } finally {
            if (transaction != null) {
                TransactionSupport.resume(transaction);
            }
        }
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("invokeCallbackMethods")
public synchronized void invokeCallbackMethods() {
    initCommandExecutor();
    for (Iterator<Entry<Guid, CommandCallBack>> iterator = cmdCallBackMap.entrySet().iterator(); iterator.hasNext(); ) {
        Entry<Guid, CommandCallBack> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CommandCallBack callBack = entry.getValue();
        CommandStatus status = coco.getCommandStatus(cmdId);
        switch(status) {
            case FAILED:
                callBack.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case SUCCEEDED:
                callBack.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case ACTIVE:
            case ACTIVE_ASYNC:
                callBack.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                break;
            default:
                break;
        }
    }
}
#method_after
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    initCommandExecutor();
    for (Iterator<Entry<Guid, CommandCallBack>> iterator = cmdCallBackMap.entrySet().iterator(); iterator.hasNext(); ) {
        Entry<Guid, CommandCallBack> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CommandCallBack callBack = entry.getValue();
        CommandStatus status = coco.getCommandStatus(cmdId);
        switch(status) {
            case FAILED:
                callBack.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case SUCCEEDED:
                callBack.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
                break;
            case ACTIVE:
            case ACTIVE_ASYNC:
                callBack.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
private void initCommandExecutor() {
    if (!cmdExecutorInitialized) {
        synchronized (LOCK) {
            if (!cmdExecutorInitialized) {
                for (CommandEntity cmdEntity : coco.getCommandsWithCallBackEnabled()) {
                    if (!cmdEntity.isCallBackNotified()) {
                        switch(cmdEntity.getCommandStatus()) {
                            case ACTIVE_SYNC:
                                coco.retrieveCommand(cmdEntity.getId()).setCommandStatus(CommandStatus.FAILED_RESTARTED);
                                break;
                            case NOT_STARTED:
                                executeAsyncCommand(cmdEntity.getCommandType(), cmdEntity.getActionParameters());
                                break;
                            default:
                                addToCallBackMap(cmdEntity);
                        }
                    }
                }
                cmdExecutorInitialized = true;
            }
        }
    }
}
#method_after
private void initCommandExecutor() {
    if (!cmdExecutorInitialized) {
        for (CommandEntity cmdEntity : coco.getCommandsWithCallBackEnabled()) {
            switch(cmdEntity.getCommandStatus()) {
                case ACTIVE_SYNC:
                case NOT_STARTED:
                    coco.retrieveCommand(cmdEntity.getId()).setCommandStatus(CommandStatus.FAILED_RESTARTED);
                    break;
                default:
                    if (!cmdEntity.isCallBackNotified()) {
                        addToCallBackMap(cmdEntity);
                    }
                    break;
            }
        }
        cmdExecutorInitialized = true;
    }
}
#end_block

#method_before
public Future<VdcReturnValueBase> executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters);
    command.persistCommand(command.getParameters().getParentCommand(), true);
    return executor.submit(new Callable<VdcReturnValueBase>() {

        @Override
        public VdcReturnValueBase call() throws Exception {
            return executeCommand(command);
        }
    });
}
#method_after
public Future<VdcReturnValueBase> executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters, final CommandContext cmdContext) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, cmdContext);
    command.persistCommand(command.getParameters().getParentCommand(), cmdContext, true);
    CommandCallBack callBack = command.getCallBack();
    if (callBack != null) {
        cmdCallBackMap.put(command.getCommandId(), callBack);
    }
    Future<VdcReturnValueBase> retVal;
    try {
        retVal = executor.submit(new Callable<VdcReturnValueBase>() {

            @Override
            public VdcReturnValueBase call() throws Exception {
                return executeCommand(command, cmdContext);
            }
        });
    } catch (RejectedExecutionException ex) {
        command.setCommandStatus(CommandStatus.FAILED);
        log.errorFormat("Failed to submit command to executor service, command {0} status has been set to FAILED", command.getCommandId().toString());
        retVal = new RejectedExecutionFuture();
    }
    return retVal;
}
#end_block

#method_before
private VdcReturnValueBase executeCommand(final CommandBase<?> command) {
    CommandCallBack callBack = command.getCallBack();
    if (callBack != null) {
        cmdCallBackMap.put(command.getCommandId(), callBack);
    }
    VdcReturnValueBase result = BackendUtils.getBackendCommandObjectsHandler(log).runAction(command, null);
    updateCommand(command, result);
    if (callBack != null) {
        callBack.executed(result);
    }
    return result;
}
#method_after
private VdcReturnValueBase executeCommand(final CommandBase<?> command, final CommandContext cmdContext) {
    CommandCallBack callBack = command.getCallBack();
    VdcReturnValueBase result = BackendUtils.getBackendCommandObjectsHandler(log).runAction(command, null);
    updateCommand(command, result);
    if (callBack != null) {
        callBack.executed(result);
    }
    return result;
}
#end_block

#method_before
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.VDS, isCaseSensitiveSearch());
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#method_after
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(applySortOptions(getSearchString()), SearchType.VDS, isCaseSensitiveSearch());
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#end_block

#method_before
private void updateAlerts() {
    final VDS vds = (VDS) getSelectedItem();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (vds.getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getInstance().getoVirtISOsList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                if (isos.size() > 0) {
                    // $NON-NLS-1$ //$NON-NLS-2$
                    String[] hostOsInfo = vds.getHostOs().split("-");
                    for (int counter = 0; counter < hostOsInfo.length; counter++) {
                        hostOsInfo[counter] = hostOsInfo[counter].trim();
                    }
                    generalModel.setHasUpgradeAlert(generalModel.shouldAlertUpgrade(isos, hostOsInfo));
                    boolean executionAllowed = vds.getStatus() != VDSStatus.Up && vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.Reboot && vds.getStatus() != VDSStatus.PendingApproval;
                    if (!executionAllowed) {
                        getUpgradeCommand().getExecuteProhibitionReasons().add(constants.switchToMaintenanceModeToEnableUpgradeReason());
                    }
                    getUpgradeCommand().setIsExecutionAllowed(executionAllowed);
                }
                generalModel.setHasAnyAlert();
            }
        }), vds.getId());
    }
}
#method_after
private void updateAlerts() {
    final VDS vds = (VDS) getSelectedItem();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (vds.getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getInstance().getoVirtISOsList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                if (isos.size() > 0) {
                    // $NON-NLS-1$
                    String[] hostOsInfo = vds.getHostOs().split("-");
                    for (int counter = 0; counter < hostOsInfo.length; counter++) {
                        hostOsInfo[counter] = hostOsInfo[counter].trim();
                    }
                    generalModel.setHasUpgradeAlert(generalModel.shouldAlertUpgrade(isos, hostOsInfo));
                    boolean executionAllowed = vds.getStatus() != VDSStatus.Up && vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.Reboot && vds.getStatus() != VDSStatus.PendingApproval;
                    if (!executionAllowed) {
                        getUpgradeCommand().getExecuteProhibitionReasons().add(constants.switchToMaintenanceModeToEnableUpgradeReason());
                    }
                    getUpgradeCommand().setIsExecutionAllowed(executionAllowed);
                }
                generalModel.setHasAnyAlert();
            }
        }), vds.getId());
    }
}
#end_block

#method_before
public void deallocateIfExternal() {
    if (getNetwork() != null && getNetwork().isExternal()) {
        Provider<?> provider = DbFacade.getInstance().getProviderDao().get(getNetwork().getProvidedBy().getProviderId());
        NetworkProviderProxy providerProxy = ProviderProxyFactory.getInstance().create(provider);
        try {
            providerProxy.deallocate(nic);
        } catch (VdcBLLException e) {
            AuditLogableBase removePortFailureEvent = new AuditLogableBase();
            removePortFailureEvent.addCustomValue("PortName", nic.getName());
            removePortFailureEvent.addCustomValue("PortId", nic.getId().toString());
            removePortFailureEvent.addCustomValue("ProviderName", provider.getName());
            AuditLogDirector.log(removePortFailureEvent, AuditLogType.REMOVE_PORT_FROM_EXTERNAL_PROVIDER_FAILED);
        }
    }
}
#method_after
public void deallocateIfExternal() {
    if (getNetwork() != null && getNetwork().isExternal()) {
        Provider<?> provider = DbFacade.getInstance().getProviderDao().get(getNetwork().getProvidedBy().getProviderId());
        NetworkProviderProxy providerProxy = ProviderProxyFactory.getInstance().create(provider);
        try {
            providerProxy.deallocate(nic);
        } catch (VdcBLLException e) {
            AuditLogableBase removePortFailureEvent = new AuditLogableBase();
            removePortFailureEvent.addCustomValue("NicName", nic.getName());
            removePortFailureEvent.addCustomValue("NicId", nic.getId().toString());
            removePortFailureEvent.addCustomValue("ProviderName", provider.getName());
            AuditLogDirector.log(removePortFailureEvent, AuditLogType.REMOVE_PORT_FROM_EXTERNAL_PROVIDER_FAILED);
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isValidTemplate()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#end_block

#method_before
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        updateProfiles(iface);
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        updateProfileOnNic(iface);
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isValidTemplate()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#end_block

#method_before
@Override
public void edit(final VnicInstanceType model) {
    driver.edit(model);
    String vnicName = model.getNetworkInterface().getName();
    profileEditor.addLabelStyleName(style.noDisplay());
    profileEditor.addContentWidgetStyleName(style.contentStyle());
    profileEditor.setElementId(ElementIdUtils.createElementId(elementId, vnicName));
    syncSelectedItemWithNetworkInterface(model);
    model.getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            syncSelectedItemWithNetworkInterface(model);
            ValueChangeEvent.fire(ProfileInstanceTypeEditor.this, model);
        }
    });
}
#method_after
@Override
public void edit(final VnicInstanceType model) {
    driver.edit(model);
    profileEditor.addLabelStyleName(style.noDisplay());
    profileEditor.addContentWidgetStyleName(style.contentStyle());
    profileEditor.setElementId(ElementIdUtils.createElementId(elementId, model.getNetworkInterface().getName()));
    syncSelectedItemWithNetworkInterface(model);
    model.getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            syncSelectedItemWithNetworkInterface(model);
            ValueChangeEvent.fire(ProfileInstanceTypeEditor.this, model);
        }
    });
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VmStatic vm) {
    return createBaseParametersMapper(vm).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("is_initialized", vm.isInitialized()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId()).addValue("original_template_name", vm.getOriginalTemplateName()).addValue("original_template_id", vm.getOriginalTemplateGuid()).addValue("template_version_number", vm.isUseLatestVersion() ? USE_LATEST_VERSION_NUMBER_INDICATOR : DONT_USE_LATEST_VERSION_NUMBER_INDICATOR).addValue("numatune_mode", vm.getNumaTuneMode() == null ? NumaTuneMode.PREFERRED.getValue() : vm.getNumaTuneMode().getValue());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VmStatic vm) {
    return createBaseParametersMapper(vm).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("is_initialized", vm.isInitialized()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId()).addValue("original_template_name", vm.getOriginalTemplateName()).addValue("original_template_id", vm.getOriginalTemplateGuid()).addValue("template_version_number", vm.isUseLatestVersion() ? USE_LATEST_VERSION_NUMBER_INDICATOR : DONT_USE_LATEST_VERSION_NUMBER_INDICATOR).addValue("numatune_mode", vm.getNumaTuneMode() == null ? NumaTuneMode.INTERLEAVE.getValue() : vm.getNumaTuneMode().getValue());
}
#end_block

#method_before
@Before
public void setUp() {
    control = EasyMock.createNiceControl();
    backend = control.createMock(BackendLocal.class);
    current = control.createMock(Current.class);
    sessionHelper = new SessionHelper();
    sessionHelper.setCurrent(current);
    sessionHelper.setSessionId(sessionId);
    httpHeaders = control.createMock(HttpHeaders.class);
    locales = new ArrayList<Locale>();
    expect(httpHeaders.getAcceptableLanguages()).andReturn(locales).anyTimes();
    accepts = new ArrayList<String>();
    expect(httpHeaders.getRequestHeader("Accept")).andReturn(accepts).anyTimes();
    List<String> filterValue = new ArrayList<String>();
    filterValue.add("false");
    expect(httpHeaders.getRequestHeader(USER_FILTER_HEADER)).andReturn(filterValue).anyTimes();
    mapperLocator = new MappingLocator();
    mapperLocator.populate();
    validatorLocator = new ValidatorLocator();
    validatorLocator.populate();
    locale = Locale.getDefault();
    Locale.setDefault(Locale.GERMANY);
    messageBundle = new MessageBundle();
    messageBundle.setPath(BUNDLE_PATH);
    messageBundle.populate();
    init();
}
#method_after
@Before
public void setUp() {
    control = EasyMock.createNiceControl();
    backend = control.createMock(BackendLocal.class);
    current = control.createMock(Current.class);
    currentUser = new DbUser();
    currentUser.setFirstName(USER);
    currentUser.setLastName(USER);
    currentUser.setDomain(DOMAIN);
    currentUser.setNamespace(NAMESPACE);
    currentUser.setId(GUIDS[0]);
    expect(current.get(DbUser.class)).andReturn(currentUser).anyTimes();
    sessionHelper = new SessionHelper();
    sessionHelper.setCurrent(current);
    sessionHelper.setSessionId(sessionId);
    httpHeaders = control.createMock(HttpHeaders.class);
    locales = new ArrayList<Locale>();
    expect(httpHeaders.getAcceptableLanguages()).andReturn(locales).anyTimes();
    accepts = new ArrayList<String>();
    expect(httpHeaders.getRequestHeader("Accept")).andReturn(accepts).anyTimes();
    List<String> filterValue = new ArrayList<String>();
    filterValue.add("false");
    expect(httpHeaders.getRequestHeader(USER_FILTER_HEADER)).andReturn(filterValue).anyTimes();
    mapperLocator = new MappingLocator();
    mapperLocator.populate();
    validatorLocator = new ValidatorLocator();
    validatorLocator.populate();
    locale = Locale.getDefault();
    Locale.setDefault(Locale.GERMANY);
    messageBundle = new MessageBundle();
    messageBundle.setPath(BUNDLE_PATH);
    messageBundle.populate();
    init();
}
#end_block

#method_before
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getVdsGroupCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, String.valueOf(Config.<Integer>getValue(ConfigValues.MaxNumOfVmCpus, vm.getVdsGroupCompatibilityVersion().getValue())));
        }
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    createInfo.put(VdsProperties.emulatedMachine, getVdsGroup().getEmulatedMachine());
    // enabled.
    if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
        createInfo.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
        createInfo.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getVdsGroupCpuFlagsData() != null) {
        createInfo.put(VdsProperties.cpuType, vm.getVdsGroupCpuFlagsData());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
    if (keyboardLayout == null) {
        keyboardLayout = vm.getDefaultVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
        }
    }
    createInfo.put(VdsProperties.KeyboardLayout, keyboardLayout);
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getDisplayType() == DisplayType.vnc) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    addNumaSetting(compatibilityVersion);
    if (vm.getDisplayType() == DisplayType.qxl) {
        createInfo.put(VdsProperties.spiceFileTransferEnable, Boolean.toString(vm.isSpiceFileTransferEnabled()));
        createInfo.put(VdsProperties.spiceCopyPasteEnable, Boolean.toString(vm.isSpiceCopyPasteEnabled()));
    }
}
#method_after
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getVdsGroupCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, String.valueOf(Config.<Integer>getValue(ConfigValues.MaxNumOfVmCpus, vm.getVdsGroupCompatibilityVersion().getValue())));
        }
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    createInfo.put(VdsProperties.emulatedMachine, getVdsGroup().getEmulatedMachine());
    // enabled.
    if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
        createInfo.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
        createInfo.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getVdsGroupCpuFlagsData() != null) {
        createInfo.put(VdsProperties.cpuType, vm.getVdsGroupCpuFlagsData());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
    if (keyboardLayout == null) {
        keyboardLayout = vm.getDefaultVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
        }
    }
    createInfo.put(VdsProperties.KeyboardLayout, keyboardLayout);
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getDisplayType() == DisplayType.vnc) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    addNumaSetting(compatibilityVersion);
    if (vm.getDisplayType() == DisplayType.qxl) {
        createInfo.put(VdsProperties.spiceFileTransferEnable, Boolean.toString(vm.isSpiceFileTransferEnabled()));
        createInfo.put(VdsProperties.spiceCopyPasteEnable, Boolean.toString(vm.isSpiceCopyPasteEnabled()));
    }
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getVdsGroupCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
}
#end_block

#method_before
public void remove(Guid id, boolean removePermissions) {
    getCallsHandler().executeModification("DeleteVmStatic", getIdParamterSource(id).addValue("remove_permissions", removePermissions));
}
#method_after
public void remove(Guid id, boolean removePermissions) {
    getCallsHandler().executeModification("DeleteVmStatic", createIdParameterMapper(id).addValue("remove_permissions", removePermissions));
}
#end_block

#method_before
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setName(rs.getString("vm_name"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == USE_LATEST_VERSION_NUMBER_INDICATOR);
    entity.setNumaTuneMode(NumaTuneMode.forValue(rs.getString("numatune_mode")));
    return entity;
}
#method_after
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setName(rs.getString("vm_name"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == USE_LATEST_VERSION_NUMBER_INDICATOR);
    entity.setNumaTuneMode(NumaTuneMode.forValue(rs.getString("numatune_mode")));
    return entity;
}
#end_block

#method_before
private final <T extends IVdcQueryable> List<T> genericSearch(final SearchDAO<T> dao, final boolean useCache) {
    return genericSearch(dao, useCache, null);
}
#method_after
private <T extends IVdcQueryable> List<T> genericSearch(final SearchDAO<T> dao, final boolean useCache) {
    return genericSearch(dao, useCache, null);
}
#end_block

#method_before
private final <T extends IVdcQueryable> List<T> genericSearch(final SearchDAO<T> dao, final boolean useCache, final Filter<T> filter) {
    final QueryData data = initQueryData(useCache);
    if (data == null) {
        return new ArrayList<T>();
    }
    log.debug("Executing generic query: " + data.getQuery());
    return ListUtils.filter(dao.getAllWithQuery(data.getQuery()), filter);
}
#method_after
private <T extends IVdcQueryable> List<T> genericSearch(final SearchDAO<T> dao, final boolean useCache, final Filter<T> filter) {
    final QueryData data = initQueryData(useCache);
    if (data == null) {
        return new ArrayList<T>();
    }
    log.debug("Executing generic query: " + data.getQuery());
    return ListUtils.filter(dao.getAllWithQuery(data.getQuery()), filter);
}
#end_block

#method_before
private boolean isBalloonDeviceActiveOnVm(VmInternalData vmInternalData) {
    VM savedVm = _vmDict.get(vmInternalData.getVmDynamic().getId());
    if (savedVm != null) {
        VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
        return // minimum allocated mem of VM == total mem,
        savedVm.getMinAllocatedMem() < savedVm.getMemSizeMb() && // ballooning is impossible
        balloonInfo.isBalloonDeviceEnabled() && // ballooning
        balloonInfo.getBalloonTargetMemory().intValue() != balloonInfo.getBalloonMaxMemory().intValue();
    // was
    // not
    // requested/enabled
    // on
    // this
    // VM
    }
    return false;
}
#method_after
private boolean isBalloonDeviceActiveOnVm(VmInternalData vmInternalData) {
    VM savedVm = _vmDict.get(vmInternalData.getVmDynamic().getId());
    if (savedVm != null) {
        VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
        return // minimum allocated mem of VM == total mem, ballooning is impossible
        savedVm.getMinAllocatedMem() < savedVm.getMemSizeMb() && balloonInfo.isBalloonDeviceEnabled() && // ballooning was not requested/enabled on this VM
        balloonInfo.getBalloonTargetMemory().intValue() != balloonInfo.getBalloonMaxMemory().intValue();
    }
    return false;
}
#end_block

#method_before
public VdsNetworkInterface attach(NetworkInterfaceModel targetNic, boolean createBridge) {
    attachedToNic = targetNic;
    List<LogicalNetworkModel> networksOnTarget = targetNic.getItems();
    networksOnTarget.add(this);
    NetworkParameters netParams = getSetupModel().getNetworkToLastDetachParams().get(getName());
    if (!hasVlan()) {
        if (netParams != null) {
            targetNic.getEntity().setBootProtocol(netParams.getBootProtocol());
            targetNic.getEntity().setAddress(netParams.getAddress());
            targetNic.getEntity().setSubnet(netParams.getSubnet());
            targetNic.getEntity().setGateway(netParams.getGateway());
        } else {
            if (targetNic.getEntity().getBootProtocol() == null) {
                if (!isManagement()) {
                    targetNic.getEntity().setBootProtocol(NetworkBootProtocol.NONE);
                } else {
                    targetNic.getEntity().setBootProtocol(NetworkBootProtocol.DHCP);
                }
            }
        }
    }
    if (isManagement()) {
        // mark the nic as a management nic
        targetNic.getEntity().setType(2);
    }
    if (!createBridge) {
        return null;
    }
    VdsNetworkInterface targetNicEntity = targetNic.getEntity();
    if (hasVlan()) {
        // create vlan bridge (eth0.1)
        VdsNetworkInterface bridge = new VdsNetworkInterface();
        // $NON-NLS-1$
        bridge.setName(targetNic.getName() + "." + getVlanId());
        bridge.setNetworkName(getName());
        bridge.setBaseInterface(targetNic.getName());
        bridge.setVlanId(getVlanId());
        bridge.setMtu(getEntity().getMtu());
        bridge.setVdsId(targetNicEntity.getVdsId());
        bridge.setVdsName(targetNicEntity.getVdsName());
        bridge.setBridged(getEntity().isVmNetwork());
        if (netParams != null) {
            bridge.setBootProtocol(netParams.getBootProtocol());
            bridge.setAddress(netParams.getAddress());
            bridge.setSubnet(netParams.getSubnet());
            bridge.setGateway(netParams.getGateway());
        } else {
            if (bridge.getBootProtocol() == null) {
                if (!isManagement()) {
                    bridge.setBootProtocol(NetworkBootProtocol.NONE);
                } else {
                    bridge.setBootProtocol(NetworkBootProtocol.DHCP);
                }
            }
        }
        return bridge;
    } else {
        targetNicEntity.setNetworkName(getName());
        targetNicEntity.setMtu(getEntity().getMtu());
        targetNicEntity.setBridged(getEntity().isVmNetwork());
        return null;
    }
}
#method_after
public VdsNetworkInterface attach(NetworkInterfaceModel targetNic, boolean createBridge) {
    attachedToNic = targetNic;
    List<LogicalNetworkModel> networksOnTarget = targetNic.getItems();
    networksOnTarget.add(this);
    if (!hasVlan()) {
        restoreNetworkParameters(targetNic.getEntity());
    }
    if (isManagement()) {
        // mark the nic as a management nic
        targetNic.getEntity().setType(2);
    }
    if (!createBridge) {
        return null;
    }
    VdsNetworkInterface targetNicEntity = targetNic.getEntity();
    if (hasVlan()) {
        // create vlan bridge (eth0.1)
        VdsNetworkInterface bridge = new VdsNetworkInterface();
        // $NON-NLS-1$
        bridge.setName(targetNic.getName() + "." + getVlanId());
        bridge.setNetworkName(getName());
        bridge.setBaseInterface(targetNic.getName());
        bridge.setVlanId(getVlanId());
        bridge.setMtu(getEntity().getMtu());
        bridge.setVdsId(targetNicEntity.getVdsId());
        bridge.setVdsName(targetNicEntity.getVdsName());
        bridge.setBridged(getEntity().isVmNetwork());
        restoreNetworkParameters(bridge);
        return bridge;
    } else {
        targetNicEntity.setNetworkName(getName());
        targetNicEntity.setMtu(getEntity().getMtu());
        targetNicEntity.setBridged(getEntity().isVmNetwork());
        return null;
    }
}
#end_block

#method_before
@Test
public void canDoActionUpdateDescriptionVmDown() {
    canDoActionUpdateWipeAfterDelete(VMStatus.Down);
}
#method_after
@Test
public void canDoActionUpdateDescriptionVmDown() {
    canDoActionUpdateDescription(VMStatus.Down);
}
#end_block

#method_before
@Test
public void canDoActionUpdateDescriptionVmUp() {
    canDoActionUpdateWipeAfterDelete(VMStatus.Up);
}
#method_after
@Test
public void canDoActionUpdateDescriptionVmUp() {
    canDoActionUpdateDescription(VMStatus.Up);
}
#end_block

#method_before
@Override
public void sendMessage(byte[] message) {
    send(new Message().send().withHeader(HEADER_DESTINATION, REQUEST_QUEUE).withContent(new String(message, UTF8)).build());
}
#method_after
@Override
public void sendMessage(byte[] message) {
    send(new Message().send().withHeader(HEADER_DESTINATION, REQUEST_QUEUE).withContent(message).build());
}
#end_block

#method_before
public static ByteBuffer cloneBuffer(ByteBuffer original) {
    ByteBuffer clone = ByteBuffer.allocate(original.capacity());
    clone.put(original);
    clone.flip();
    return clone;
}
#method_after
public static ByteBuffer cloneBuffer(ByteBuffer original) {
    int pos = original.position();
    original.clear();
    ByteBuffer clone = ByteBuffer.allocate(original.capacity());
    clone.put(original);
    clone.flip();
    clone.position(pos);
    return clone;
}
#end_block

#method_before
public Message withContent(String content) {
    this.content = content;
    return this;
}
#method_after
public Message withContent(byte[] content) {
    this.content = content;
    return this;
}
#end_block

#method_before
public byte[] build() {
    if (isEmpty(this.command)) {
        throw new IllegalArgumentException("Command can't be empty");
    }
    StringBuilder builder = new StringBuilder(this.command);
    builder.append("\n");
    for (String key : this.headers.keySet()) {
        builder.append(key);
        builder.append(":");
        builder.append(this.headers.get(key));
        builder.append("\n");
    }
    builder.append("\n");
    if (!isEmpty(this.content)) {
        builder.append(this.content);
    }
    builder.append(END_OF_MESSAGE + "\n");
    return builder.toString().getBytes(UTF8);
}
#method_after
public byte[] build() {
    if (isEmpty(this.command)) {
        throw new IllegalArgumentException("Command can't be empty");
    }
    StringBuilder builder = new StringBuilder(this.command);
    builder.append("\n");
    for (String key : this.headers.keySet()) {
        builder.append(key);
        builder.append(":");
        builder.append(this.headers.get(key));
        builder.append("\n");
    }
    if (this.content.length != 0) {
        builder.append(HEADER_CONTENT_LENGTH).append(":").append(this.content.length).append("\n");
    }
    builder.append("\n");
    if (this.content.length != 0) {
        builder.append(new String(this.content, getEncoding()));
    }
    builder.append(END_OF_MESSAGE);
    return builder.toString().getBytes(UTF8);
}
#end_block

#method_before
public String getContent() {
    return content;
}
#method_after
public byte[] getContent() {
    return content;
}
#end_block

#method_before
public String getContent() {
    return content;
}
#method_after
private static byte[] getContent(byte[] array, String[] message, int lineNumber) {
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < lineNumber; i++) {
        builder.append(message[i]);
        builder.append("\n");
    }
    return Arrays.copyOfRange(array, builder.toString().getBytes(UTF8).length, array.length);
}
#end_block

#method_before
public static int getContentLength(String message) {
    String[] messageLines = message.split("\n");
    int lenght = 0;
    int i = 0;
    while (i < messageLines.length - 1) {
        String currentLine = messageLines[++i];
        while (currentLine.length() > 0) {
            currentLine = messageLines[++i];
        }
        i++;
        StringBuilder content = new StringBuilder();
        String endLine = null;
        for (int k = i; k < messageLines.length; k++, i++) {
            String line = messageLines[k];
            if (line.contains(END_OF_MESSAGE)) {
                int idx = line.indexOf(END_OF_MESSAGE);
                content.append(line.substring(0, idx));
                endLine = line.substring(idx + 1, line.length());
                break;
            } else {
                content.append(line);
            }
        }
        lenght += content.length();
        if (!isEmpty(endLine)) {
            messageLines[i] = endLine;
        } else {
            i++;
        }
    }
    return lenght;
}
#method_after
public int getContentLength() {
    String length = getHeaders().get(HEADER_CONTENT_LENGTH);
    int contentLength = -1;
    if (length != null) {
        try {
            contentLength = Integer.parseInt(length);
        } catch (NumberFormatException ignored) {
        }
    }
    return contentLength;
}
#end_block

#method_before
public Future<Void> close() {
    final Callable<Void> callable = new Callable<Void>() {

        @Override
        public Void call() {
            closeChannel();
            return null;
        }
    };
    return scheduleTask(callable);
}
#method_after
public Future<Void> close() {
    return disconnect();
}
#end_block

#method_before
@Override
public void sendMessage(byte[] message) {
    waitForConnect();
    send(new Message().send().withHeader(HEADER_DESTINATION, REQUEST_QUEUE).withContent(new String(message, UTF8)).build());
}
#method_after
@Override
public void sendMessage(byte[] message) {
    waitForConnect();
    send(new Message().send().withHeader(HEADER_DESTINATION, REQUEST_QUEUE).withContent(message).build());
}
#end_block

#method_before
private void extractModifiedInterfaces() {
    for (VdsNetworkInterface nic : params.getInterfaces()) {
        VdsNetworkInterface existingNic = getExistingIfaces().get(nic.getName());
        if (existingNic != null) {
            Set<String> newLabels = NetworkUtils.isLabeled(nic) ? nic.getLabels() : Collections.<String>emptySet();
            Set<String> existingLabels = NetworkUtils.isLabeled(existingNic) ? existingNic.getLabels() : Collections.<String>emptySet();
            if (!CollectionUtils.isEqualCollection(newLabels, existingLabels) || (!StringUtils.isEmpty(nic.getNetworkName()) && qosOrCustomPropertiesChanged(nic, existingNic))) {
                existingNic.setLabels(newLabels);
                existingNic.setQosOverridden(nic.isQosOverridden());
                existingNic.setCustomProperties(nic.getCustomProperties());
                modifiedInterfaces.add(existingNic);
            }
        }
    }
}
#method_after
private void extractModifiedInterfaces() {
    for (VdsNetworkInterface nic : params.getInterfaces()) {
        VdsNetworkInterface existingNic = getExistingIfaces().get(nic.getName());
        if (existingNic != null) {
            Set<String> newLabels = NetworkUtils.isLabeled(nic) ? nic.getLabels() : Collections.<String>emptySet();
            Set<String> existingLabels = NetworkUtils.isLabeled(existingNic) ? existingNic.getLabels() : Collections.<String>emptySet();
            if (!CollectionUtils.isEqualCollection(newLabels, existingLabels) || (StringUtils.isNotEmpty(nic.getNetworkName()) && qosOrCustomPropertiesChanged(nic, existingNic))) {
                existingNic.setLabels(newLabels);
                existingNic.setQosOverridden(nic.isQosOverridden());
                existingNic.setCustomProperties(nic.getCustomProperties());
                modifiedInterfaces.add(existingNic);
            }
        }
    }
}
#end_block

#method_before
private void validateCustomProperties() {
    String version = vds.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validProperties = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validProperties.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesNonVm = new HashMap<String, String>(validProperties);
    validPropertiesNonVm.remove("bridge_opts");
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String networkName = iface.getNetworkName();
        if (iface.hasCustomProperties() && !StringUtils.isEmpty(networkName)) {
            if (!networkCustomPropertiesSupported) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, networkName);
            }
            Network network = existingClusterNetworks.get(networkName);
            List<ValidationError> errors = util.validateProperties(network == null || network.isVmNetwork() ? validProperties : validPropertiesNonVm, iface.getCustomProperties());
            if (!errors.isEmpty()) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, networkName);
                List<String> messages = new ArrayList<>();
                util.handleCustomPropertiesError(errors, messages);
                log.error(StringUtils.join(translateErrorMessages(messages), ','));
            }
        }
    }
}
#method_after
private void validateCustomProperties() {
    String version = vds.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validProperties = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validProperties.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesNonVm = new HashMap<String, String>(validProperties);
    validPropertiesNonVm.remove("bridge_opts");
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String networkName = iface.getNetworkName();
        if (iface.hasCustomProperties() && StringUtils.isNotEmpty(networkName)) {
            if (!networkCustomPropertiesSupported) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, networkName);
            }
            Network network = existingClusterNetworks.get(networkName);
            List<ValidationError> errors = util.validateProperties(network == null || network.isVmNetwork() ? validProperties : validPropertiesNonVm, iface.getCustomProperties());
            if (!errors.isEmpty()) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, networkName);
                List<String> messages = new ArrayList<>();
                util.handleCustomPropertiesError(errors, messages);
                log.error(StringUtils.join(translateErrorMessages(messages), ','));
            }
        }
    }
}
#end_block

#method_before
private void extractNetwork(VdsNetworkInterface iface) {
    String networkName = iface.getNetworkName();
    // prevent attaching 2 interfaces to 1 network
    if (attachedNetworksNames.contains(networkName)) {
        addViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName);
    } else {
        attachedNetworksNames.add(networkName);
        // check if network exists on cluster
        if (getExistingClusterNetworks().containsKey(networkName)) {
            Network network = getExistingClusterNetworks().get(networkName);
            iface.setVlanId(network.getVlanId());
            validateNetworkInternal(network);
            validateNetworkExclusiveOnIface(iface, determineNetworkType(network.getVlanId(), network.isVmNetwork()));
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            if (existingIface != null && !networkName.equals(existingIface.getNetworkName())) {
                existingIface = getExistingIfaceByNetwork(networkName);
            }
            if (existingIface != null && existingIface.getNetworkImplementationDetails() != null && !existingIface.getNetworkImplementationDetails().isInSync()) {
                if (networkShouldBeSynced(networkName)) {
                    modifiedNetworks.add(network);
                    if (network.getQosId() != null && !hostNetworkQosSupported) {
                        addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, networkName);
                    }
                } else if (networkWasModified(iface)) {
                    addViolation(VdcBllMessages.NETWORKS_NOT_IN_SYNC, networkName);
                }
            } else if (networkWasModified(iface)) {
                if (networkIpAddressWasSameAsHostnameAndChanged(iface)) {
                    addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED, networkName);
                }
                modifiedNetworks.add(network);
            }
        } else {
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            existingIface = (existingIface == null ? iface : existingIface);
            iface.setVlanId(existingIface.getVlanId());
            validateNetworkExclusiveOnIface(iface, determineNetworkType(existingIface.getVlanId(), existingIface.isBridged()));
            if (unmanagedNetworkChanged(iface)) {
                addViolation(VdcBllMessages.NETWORKS_DONT_EXIST_IN_CLUSTER, networkName);
            }
        }
    }
}
#method_after
private void extractNetwork(VdsNetworkInterface iface) {
    String networkName = iface.getNetworkName();
    // prevent attaching 2 interfaces to 1 network
    if (attachedNetworksNames.contains(networkName)) {
        addViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName);
    } else {
        attachedNetworksNames.add(networkName);
        // check if network exists on cluster
        if (getExistingClusterNetworks().containsKey(networkName)) {
            Network network = getExistingClusterNetworks().get(networkName);
            iface.setVlanId(network.getVlanId());
            validateNetworkInternal(network);
            validateNetworkExclusiveOnIface(iface, determineNetworkType(network.getVlanId(), network.isVmNetwork()));
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            if (existingIface != null && !networkName.equals(existingIface.getNetworkName())) {
                existingIface = getExistingIfaceByNetwork(networkName);
            }
            if (existingIface != null && existingIface.getNetworkImplementationDetails() != null && !existingIface.getNetworkImplementationDetails().isInSync()) {
                iface.setVlanId(existingIface.getVlanId());
                if (networkShouldBeSynced(networkName)) {
                    modifiedNetworks.add(network);
                    if (network.getQosId() != null && !hostNetworkQosSupported) {
                        addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, networkName);
                    }
                } else if (networkWasModified(iface)) {
                    addViolation(VdcBllMessages.NETWORKS_NOT_IN_SYNC, networkName);
                }
            } else if (networkWasModified(iface)) {
                if (networkIpAddressWasSameAsHostnameAndChanged(iface)) {
                    addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED, networkName);
                }
                modifiedNetworks.add(network);
            }
        } else {
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            existingIface = (existingIface == null ? iface : existingIface);
            iface.setVlanId(existingIface.getVlanId());
            validateNetworkExclusiveOnIface(iface, determineNetworkType(existingIface.getVlanId(), existingIface.isBridged()));
            if (unmanagedNetworkChanged(iface)) {
                addViolation(VdcBllMessages.NETWORKS_DONT_EXIST_IN_CLUSTER, networkName);
            }
        }
    }
}
#end_block

#method_before
private void extractRemovedNetworks() {
    for (VdsNetworkInterface iface : getExistingIfaces().values()) {
        String net = iface.getNetworkName();
        if (StringUtils.isNotBlank(net) && !attachedNetworksNames.contains(net)) {
            removedNetworks.add(net);
        }
    }
    if (!removedNetworks.isEmpty()) {
        List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(params.getVdsId(), removedNetworks);
        if (!vmNames.isEmpty()) {
            for (String vmName : vmNames) {
                addViolation(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, vmName);
            }
        }
    }
}
#method_after
private void extractRemovedNetworks() {
    for (VdsNetworkInterface iface : getExistingIfaces().values()) {
        String net = iface.getNetworkName();
        if (StringUtils.isNotBlank(net) && !attachedNetworksNames.contains(net)) {
            removedNetworks.add(net);
        }
    }
    List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(params.getVdsId(), removedNetworks);
    for (String vmName : vmNames) {
        addViolation(VdcBllMessages.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, vmName);
    }
}
#end_block

#method_before
public static List<DbUser> sync(List<DbUser> dbUsers) {
    List<DbUser> usersToUpdate = new ArrayList<>();
    Map<String, Map<String, Set<String>>> authzToNamespaceToUserIds = new HashMap<>();
    Map<DirectoryEntryKey, DbUser> originalDbUsersMap = new HashMap<>();
    Map<String, List<DbUser>> dbUsersPerAuthz = new HashMap<>();
    // Initialize the entries based on authz in the map
    for (DbUser dbUser : dbUsers) {
        MultiValueMapUtils.addToMap(dbUser.getDomain(), dbUser, dbUsersPerAuthz);
        if (!authzToNamespaceToUserIds.containsKey(dbUser.getDomain())) {
            authzToNamespaceToUserIds.put(dbUser.getDomain(), new HashMap<String, Set<String>>());
        }
        MultiValueMapUtils.addToMapOfSets(dbUser.getNamespace(), dbUser.getExternalId(), authzToNamespaceToUserIds.get(dbUser.getDomain()));
        originalDbUsersMap.put(new DirectoryEntryKey(dbUser), dbUser);
    }
    for (Entry<String, Map<String, Set<String>>> entry : authzToNamespaceToUserIds.entrySet()) {
        Map<String, DbUser> activeUsers = new HashMap<>();
        String authz = entry.getKey();
        try {
            ExtensionProxy authzExtension = EngineExtensionsManager.getInstance().getExtensionByName(authz);
            for (Entry<String, Set<String>> userIdsPerNamespace : entry.getValue().entrySet()) {
                for (ExtMap principal : AuthzUtils.fetchPrincipalsByIdsRecursively(authzExtension, userIdsPerNamespace.getKey(), new ArrayList<String>(userIdsPerNamespace.getValue()))) {
                    DirectoryUtils.flatGroups(principal);
                    DbUser dbUser = DirectoryUtils.mapPrincipalRecordToDbUser(authz, principal);
                    dbUser.setGroupIds(DirectoryUtils.getGroupIdsFromPrincipal(authz, principal));
                    activeUsers.put(dbUser.getExternalId(), dbUser);
                }
            }
            for (DbUser dbUser : dbUsersPerAuthz.get(authz)) {
                DbUser activeUser = activeUsers.get(dbUser.getExternalId());
                if (activeUser != null) {
                    if (!activeUser.equals(dbUser)) {
                        activeUser.setId(dbUser.getId());
                        log.info(String.format("The user %1$s from authz extension %2$s got synchronized with the matching user persistent at oVirt-engine database", activeUser.getLoginName(), activeUser.getDomain()));
                        usersToUpdate.add(activeUser);
                    }
                } else {
                    log.info(String.format("The user %1$s from authz extension %2$s could not be found, and will be marked as inactive", dbUser.getLoginName(), dbUser.getDomain()));
                    dbUser.setActive(false);
                    usersToUpdate.add(dbUser);
                }
            }
        } catch (Exception ex) {
            log.error(String.format("Error during user synchronization of extension %1$s. Exception message is %2$s", authz, ex.getMessage()));
            log.debug("", ex);
        }
    }
    return usersToUpdate;
}
#method_after
public static List<DbUser> sync(List<DbUser> dbUsers) {
    List<DbUser> usersToUpdate = new ArrayList<>();
    Map<String, Map<String, Set<String>>> authzToNamespaceToUserIds = new HashMap<>();
    Map<DirectoryEntryKey, DbUser> originalDbUsersMap = new HashMap<>();
    Map<String, List<DbUser>> dbUsersPerAuthz = new HashMap<>();
    // Initialize the entries based on authz in the map
    for (DbUser dbUser : dbUsers) {
        MultiValueMapUtils.addToMap(dbUser.getDomain(), dbUser, dbUsersPerAuthz);
        if (!authzToNamespaceToUserIds.containsKey(dbUser.getDomain())) {
            authzToNamespaceToUserIds.put(dbUser.getDomain(), new HashMap<String, Set<String>>());
        }
        MultiValueMapUtils.addToMapOfSets(dbUser.getNamespace(), dbUser.getExternalId(), authzToNamespaceToUserIds.get(dbUser.getDomain()));
        originalDbUsersMap.put(new DirectoryEntryKey(dbUser), dbUser);
    }
    for (Entry<String, Map<String, Set<String>>> entry : authzToNamespaceToUserIds.entrySet()) {
        Map<String, DbUser> activeUsers = new HashMap<>();
        String authz = entry.getKey();
        try {
            ExtensionProxy authzExtension = EngineExtensionsManager.getInstance().getExtensionByName(authz);
            for (Entry<String, Set<String>> userIdsPerNamespace : entry.getValue().entrySet()) {
                for (ExtMap principal : AuthzUtils.fetchPrincipalsByIdsRecursively(authzExtension, userIdsPerNamespace.getKey(), new ArrayList<String>(userIdsPerNamespace.getValue()))) {
                    DirectoryUtils.flatGroups(principal);
                    DbUser dbUser = DirectoryUtils.mapPrincipalRecordToDbUser(authz, principal);
                    dbUser.setGroupIds(DirectoryUtils.getGroupIdsFromPrincipal(authz, principal));
                    activeUsers.put(dbUser.getExternalId(), dbUser);
                }
            }
            for (DbUser dbUser : dbUsersPerAuthz.get(authz)) {
                DbUser activeUser = activeUsers.get(dbUser.getExternalId());
                if (activeUser != null) {
                    if (!activeUser.equals(dbUser)) {
                        activeUser.setId(dbUser.getId());
                        log.infoFormat("Principal {0}::{1} synchronized", activeUser.getLoginName(), activeUser.getDomain());
                        usersToUpdate.add(activeUser);
                    }
                } else {
                    log.infoFormat("Deactivating non existing principal {0}::{1}", dbUser.getLoginName(), dbUser.getDomain());
                    dbUser.setActive(false);
                    usersToUpdate.add(dbUser);
                }
            }
        } catch (Exception ex) {
            log.errorFormat("Error during user synchronization of extension {0}. Exception message is {1}", authz, ex.getMessage());
            log.debug("", ex);
        }
    }
    return usersToUpdate;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    DbUser syncResult = SyncUsers.sync(getParameters().getUserToAdd());
    DbUser userToAdd = syncResult != null ? syncResult : getParameters().getUserToAdd();
    DbUser userFromDb = DbFacade.getInstance().getDbUserDao().getByExternalId(userToAdd.getDomain(), userToAdd.getExternalId());
    if (userFromDb == null) {
        if (userToAdd.isActive()) {
            DbFacade.getInstance().getDbUserDao().save(userToAdd);
        }
    } else {
        userToAdd.setId(userFromDb.getId());
        DbFacade.getInstance().getDbUserDao().update(userToAdd);
    }
    setActionReturnValue(userToAdd.getId());
    setSucceeded(userToAdd.isActive());
}
#method_after
@Override
protected void executeCommand() {
    DbUser user = getParameters().getUserToAdd();
    DbUser syncResult = SyncUsers.sync(user);
    user = syncResult != null ? syncResult : user;
    DbUser userFromDb = DbFacade.getInstance().getDbUserDao().getByExternalId(user.getDomain(), user.getExternalId());
    if (userFromDb == null) {
        if (user.isActive()) {
            DbFacade.getInstance().getDbUserDao().save(user);
        }
    } else {
        user.setId(userFromDb.getId());
        DbFacade.getInstance().getDbUserDao().update(user);
    }
    setActionReturnValue(user.getId());
    setSucceeded(user.isActive());
}
#end_block

#method_before
public static List<DbUser> sync(List<DbUser> dbUsers, boolean forceUpdate) {
    List<DbUser> usersToUpdate = new ArrayList<>();
    Map<String, Map<String, Set<String>>> authzToNamespaceToUserIds = new HashMap<>();
    Map<DirectoryEntryKey, DbUser> originalDbUsersMap = new HashMap<>();
    Map<String, List<DbUser>> dbUsersPerAuthz = new HashMap<>();
    // Initialize the entries based on authz in the map
    for (DbUser dbUser : dbUsers) {
        MultiValueMapUtils.addToMap(dbUser.getDomain(), dbUser, dbUsersPerAuthz);
        if (!authzToNamespaceToUserIds.containsKey(dbUser.getDomain())) {
            authzToNamespaceToUserIds.put(dbUser.getDomain(), new HashMap<String, Set<String>>());
        }
        MultiValueMapUtils.addToMapOfSets(dbUser.getNamespace(), dbUser.getExternalId(), authzToNamespaceToUserIds.get(dbUser.getDomain()));
        originalDbUsersMap.put(new DirectoryEntryKey(dbUser), dbUser);
    }
    for (Entry<String, Map<String, Set<String>>> entry : authzToNamespaceToUserIds.entrySet()) {
        Map<String, DbUser> activeUsers = new HashMap<>();
        String authz = entry.getKey();
        try {
            ExtensionProxy authzExtension = EngineExtensionsManager.getInstance().getExtensionByName(authz);
            for (Entry<String, Set<String>> userIdsPerNamespace : entry.getValue().entrySet()) {
                for (ExtMap principal : AuthzUtils.fetchPrincipalsByIdsRecursively(authzExtension, userIdsPerNamespace.getKey(), userIdsPerNamespace.getValue())) {
                    DirectoryUtils.flatGroups(principal);
                    DbUser dbUser = DirectoryUtils.mapPrincipalRecordToDbUser(authz, principal);
                    dbUser.setGroupIds(DirectoryUtils.getGroupIdsFromPrincipal(authz, principal));
                    activeUsers.put(dbUser.getExternalId(), dbUser);
                }
            }
            for (DbUser dbUser : dbUsersPerAuthz.get(authz)) {
                DbUser activeUser = activeUsers.get(dbUser.getExternalId());
                if (activeUser != null) {
                    if (!activeUser.equals(dbUser) || forceUpdate) {
                        activeUser.setId(dbUser.getId());
                        log.info(String.format("The user %1$s from authz extension %2$s got synchronized with the matching user persistent at oVirt-engine database", activeUser.getLoginName(), activeUser.getDomain()));
                        usersToUpdate.add(activeUser);
                    }
                } else {
                    log.info(String.format("The user %1$s from authz extension %2$s could not be found, and will be marked as inactive", dbUser.getLoginName(), dbUser.getDomain()));
                    dbUser.setActive(false);
                    usersToUpdate.add(dbUser);
                }
            }
        } catch (Exception ex) {
            log.error(String.format("Error during user synchronization of extension %1$s. Exception message is %2$s", authz, ex.getMessage()));
            log.debug("", ex);
        }
    }
    return usersToUpdate;
}
#method_after
public static DbUser sync(DbUser dbUser) {
    List<DbUser> synchedUsers = sync(Arrays.asList(dbUser));
    return synchedUsers.isEmpty() ? null : synchedUsers.get(0);
}
#end_block

#method_before
public static List<ExtMap> fetchPrincipalsByIdsRecursively(final ExtensionProxy extension, final String namespace, final List<String> ids) {
    Map<String, ExtMap> groupsCache = new HashMap<>();
    Set<String> idsToFetch = new HashSet<>();
    List<ExtMap> principals = findPrincipalsByIds(extension, namespace, ids, true, false);
    for (ExtMap principal : principals) {
        for (ExtMap memberOf : principal.get(PrincipalRecord.GROUPS, Collections.<ExtMap>emptyList())) {
            idsToFetch.add(memberOf.<String>get(PrincipalRecord.ID));
        }
    }
    while (!idsToFetch.isEmpty()) {
        List<ExtMap> groups = findGroupRecordsByIds(extension, namespace, new ArrayList<String>(idsToFetch), true, false);
        idsToFetch.clear();
        for (ExtMap group : groups) {
            groupsCache.put(group.<String>get(GroupRecord.ID), group);
            for (ExtMap memberOf : group.get(GroupRecord.GROUPS, Collections.<ExtMap>emptyList())) {
                if (!groupsCache.containsKey(memberOf.get(GroupRecord.ID))) {
                    idsToFetch.add(memberOf.<String>get(GroupRecord.ID));
                }
            }
        }
    }
    // After the groups are fetched, the "group membership" tree for the principals should be modified accordingly.
    for (ExtMap principal : principals) {
        List<ExtMap> groups = new ArrayList<>();
        for (ExtMap memberOf : principal.get(PrincipalRecord.GROUPS, Collections.<ExtMap>emptyList())) {
            groups.add(groupsCache.get(memberOf.get(GroupRecord.ID)));
        }
        principal.put(PrincipalRecord.GROUPS, groups);
        constructGroupsMembershipTree(groups, groupsCache);
    }
    return principals;
}
#method_after
public static Collection<ExtMap> fetchPrincipalsByIdsRecursively(final ExtensionProxy extension, final String namespace, final Collection<String> ids) {
    Map<String, ExtMap> groupsCache = new HashMap<>();
    Map<String, Set<String>> idsToFetchPerNamespace = new HashMap<String, Set<String>>();
    Collection<ExtMap> principals = findPrincipalsByIds(extension, namespace, ids, true, false);
    for (ExtMap principal : principals) {
        for (ExtMap memberOf : principal.get(PrincipalRecord.GROUPS, Collections.<ExtMap>emptyList())) {
            addIdToFetch(idsToFetchPerNamespace, memberOf);
        }
    }
    while (!idsToFetchPerNamespace.isEmpty()) {
        List<ExtMap> groups = new ArrayList<>();
        for (Entry<String, Set<String>> entry : idsToFetchPerNamespace.entrySet()) {
            groups.addAll(findGroupRecordsByIds(extension, entry.getKey(), entry.getValue(), true, false));
        }
        idsToFetchPerNamespace.clear();
        for (ExtMap group : groups) {
            groupsCache.put(group.<String>get(GroupRecord.ID), group);
            for (ExtMap memberOf : group.get(GroupRecord.GROUPS, Collections.<ExtMap>emptyList())) {
                if (!groupsCache.containsKey(memberOf.get(GroupRecord.ID))) {
                    addIdToFetch(idsToFetchPerNamespace, memberOf);
                }
            }
        }
    }
    // After the groups are fetched, the "group membership" tree for the principals should be modified accordingly.
    for (ExtMap principal : principals) {
        constructGroupsMembershipTree(principal, PrincipalRecord.GROUPS, groupsCache);
    }
    return principals;
}
#end_block

#method_before
private static void constructGroupsMembershipTree(List<ExtMap> groups, Map<String, ExtMap> groupsCache) {
    for (ExtMap group : groups) {
        List<ExtMap> membersOf = new ArrayList<>();
        for (ExtMap memberOf : group.get(GroupRecord.GROUPS, Collections.<ExtMap>emptyList())) {
            membersOf.add(groupsCache.get(memberOf.get(GroupRecord.ID)));
        }
        group.put(GroupRecord.GROUPS, membersOf);
        constructGroupsMembershipTree(membersOf, groupsCache);
    }
}
#method_after
private static void constructGroupsMembershipTree(ExtMap entity, ExtKey key, Map<String, ExtMap> groupsCache) {
    List<ExtMap> groups = new ArrayList<>();
    for (ExtMap memberOf : entity.get(key, Collections.<ExtMap>emptyList())) {
        constructGroupsMembershipTree(memberOf, GroupRecord.GROUPS, groupsCache);
        groups.add(groupsCache.get(memberOf.get(GroupRecord.ID)));
    }
    entity.put(key, groups);
}
#end_block

#method_before
public static List<ExtMap> queryPrincipalRecords(final ExtensionProxy extension, final String namespace, final ExtMap filter, boolean groupsResolving, boolean groupsResolvingRecursive) {
    ExtMap inputMap = new ExtMap().mput(Authz.InvokeKeys.QUERY_ENTITY, Authz.QueryEntity.PRINCIPAL).mput(Authz.InvokeKeys.QUERY_FLAGS, queryFlagValue(groupsResolving, groupsResolvingRecursive)).mput(Authz.InvokeKeys.QUERY_FILTER, filter).mput(Authz.InvokeKeys.NAMESPACE, namespace);
    return populatePrincipalRecords(extension, namespace, inputMap);
}
#method_after
public static Collection<ExtMap> queryPrincipalRecords(final ExtensionProxy extension, final String namespace, final ExtMap filter, boolean groupsResolving, boolean groupsResolvingRecursive) {
    ExtMap inputMap = new ExtMap().mput(Authz.InvokeKeys.QUERY_ENTITY, Authz.QueryEntity.PRINCIPAL).mput(Authz.InvokeKeys.QUERY_FLAGS, queryFlagValue(groupsResolving, groupsResolvingRecursive)).mput(Authz.InvokeKeys.QUERY_FILTER, filter).mput(Authz.InvokeKeys.NAMESPACE, namespace);
    return populatePrincipalRecords(extension, namespace, inputMap);
}
#end_block

#method_before
public static List<ExtMap> queryGroupRecords(final ExtensionProxy extension, final String namespace, final ExtMap filter, boolean groupsResolving, boolean groupsResolvingRecursive) {
    ExtMap inputMap = new ExtMap().mput(Authz.InvokeKeys.QUERY_ENTITY, Authz.QueryEntity.GROUP).mput(Authz.InvokeKeys.QUERY_FLAGS, queryFlagValue(groupsResolving, groupsResolvingRecursive)).mput(Authz.InvokeKeys.QUERY_FILTER, filter).mput(Authz.InvokeKeys.NAMESPACE, namespace);
    return populateGroups(extension, namespace, inputMap);
}
#method_after
public static Collection<ExtMap> queryGroupRecords(final ExtensionProxy extension, final String namespace, final ExtMap filter, boolean groupsResolving, boolean groupsResolvingRecursive) {
    ExtMap inputMap = new ExtMap().mput(Authz.InvokeKeys.QUERY_ENTITY, Authz.QueryEntity.GROUP).mput(Authz.InvokeKeys.QUERY_FLAGS, queryFlagValue(groupsResolving, groupsResolvingRecursive)).mput(Authz.InvokeKeys.QUERY_FILTER, filter).mput(Authz.InvokeKeys.NAMESPACE, namespace);
    return populateGroups(extension, namespace, inputMap);
}
#end_block

#method_before
public static List<ExtMap> populatePrincipalRecords(final ExtensionProxy extension, final String namespace, final ExtMap input) {
    final List<ExtMap> principalRecords = new ArrayList<>();
    queryImpl(extension, namespace, input, new QueryResultHandler() {

        @Override
        public boolean handle(List<ExtMap> queryResults) {
            boolean result = true;
            for (ExtMap queryResult : queryResults) {
                if (principalRecords.size() < QUERIES_RESULTS_LIMIT) {
                    principalRecords.add(queryResult);
                } else {
                    result = false;
                    break;
                }
            }
            return result;
        }
    });
    return principalRecords;
}
#method_after
public static Collection<ExtMap> populatePrincipalRecords(final ExtensionProxy extension, final String namespace, final ExtMap input) {
    final Collection<ExtMap> principalRecords = new ArrayList<>();
    queryImpl(extension, namespace, input, new QueryResultHandler() {

        @Override
        public boolean handle(Collection<ExtMap> queryResults) {
            boolean result = true;
            for (ExtMap queryResult : queryResults) {
                if (principalRecords.size() < QUERIES_RESULTS_LIMIT) {
                    principalRecords.add(queryResult);
                } else {
                    result = false;
                    break;
                }
            }
            return result;
        }
    });
    return principalRecords;
}
#end_block

#method_before
public static List<ExtMap> populateGroups(final ExtensionProxy extension, final String namespace, final ExtMap input) {
    final List<ExtMap> groups = new ArrayList<>();
    queryImpl(extension, namespace, input, new QueryResultHandler() {

        @Override
        public boolean handle(List<ExtMap> queryResults) {
            boolean result = true;
            for (ExtMap queryResult : queryResults) {
                if (groups.size() < QUERIES_RESULTS_LIMIT) {
                    groups.add(queryResult);
                } else {
                    result = false;
                }
            }
            return result;
        }
    });
    return groups;
}
#method_after
public static Collection<ExtMap> populateGroups(final ExtensionProxy extension, final String namespace, final ExtMap input) {
    final Collection<ExtMap> groups = new ArrayList<>();
    queryImpl(extension, namespace, input, new QueryResultHandler() {

        @Override
        public boolean handle(Collection<ExtMap> queryResults) {
            boolean result = true;
            for (ExtMap queryResult : queryResults) {
                if (groups.size() < QUERIES_RESULTS_LIMIT) {
                    groups.add(queryResult);
                } else {
                    result = false;
                }
            }
            return result;
        }
    });
    return groups;
}
#end_block

#method_before
private static void queryImpl(final ExtensionProxy extension, final String namespace, final ExtMap input, final QueryResultHandler handler) {
    Object opaque = extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.QUERY_OPEN).mput(Authz.InvokeKeys.NAMESPACE, namespace).mput(input)).get(Authz.InvokeKeys.QUERY_OPAQUE);
    List<ExtMap> result = null;
    try {
        do {
            result = extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.QUERY_EXECUTE).mput(Authz.InvokeKeys.QUERY_OPAQUE, opaque).mput(Authz.InvokeKeys.PAGE_SIZE, PAGE_SIZE)).get(Authz.InvokeKeys.QUERY_RESULT);
        } while (result != null && handler.handle(result));
    } finally {
        extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.QUERY_CLOSE).mput(Authz.InvokeKeys.QUERY_OPAQUE, opaque));
    }
}
#method_after
private static void queryImpl(final ExtensionProxy extension, final String namespace, final ExtMap input, final QueryResultHandler handler) {
    Object opaque = extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.QUERY_OPEN).mput(Authz.InvokeKeys.NAMESPACE, namespace).mput(input)).get(Authz.InvokeKeys.QUERY_OPAQUE);
    Collection<ExtMap> result = null;
    try {
        do {
            result = extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.QUERY_EXECUTE).mput(Authz.InvokeKeys.QUERY_OPAQUE, opaque).mput(Authz.InvokeKeys.PAGE_SIZE, PAGE_SIZE)).get(Authz.InvokeKeys.QUERY_RESULT);
        } while (result != null && handler.handle(result));
    } finally {
        extension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.QUERY_CLOSE).mput(Authz.InvokeKeys.QUERY_OPAQUE, opaque));
    }
}
#end_block

#method_before
public static List<ExtMap> findPrincipalsByIds(final ExtensionProxy extension, final String namespace, final List<String> ids, final boolean groupsResolving, final boolean groupsResolvingRecursive) {
    List<ExtMap> results = new ArrayList<>();
    for (List<String> batch : SearchQueryParsingUtils.getIdsBatches(extension.getContext(), ids)) {
        results.addAll(queryPrincipalRecords(extension, namespace, SearchQueryParsingUtils.generateQueryMap(batch, Authz.QueryEntity.PRINCIPAL), groupsResolving, groupsResolvingRecursive));
    }
    return results;
}
#method_after
public static Collection<ExtMap> findPrincipalsByIds(final ExtensionProxy extension, final String namespace, final Collection<String> ids, final boolean groupsResolving, final boolean groupsResolvingRecursive) {
    Collection<ExtMap> results = new ArrayList<>();
    for (Collection<String> batch : SearchQueryParsingUtils.getIdsBatches(extension.getContext(), ids)) {
        results.addAll(queryPrincipalRecords(extension, namespace, SearchQueryParsingUtils.generateQueryMap(batch, Authz.QueryEntity.PRINCIPAL), groupsResolving, groupsResolvingRecursive));
    }
    return results;
}
#end_block

#method_before
public static List<ExtMap> findGroupRecordsByIds(final ExtensionProxy extension, final String namespace, final List<String> ids, final boolean groupsResolving, final boolean groupsResolvingRecursive) {
    List<ExtMap> results = new ArrayList<>();
    for (List<String> batch : SearchQueryParsingUtils.getIdsBatches(extension.getContext(), ids)) {
        results.addAll(queryGroupRecords(extension, namespace, SearchQueryParsingUtils.generateQueryMap(batch, Authz.QueryEntity.GROUP), groupsResolving, groupsResolvingRecursive));
    }
    return results;
}
#method_after
public static Collection<ExtMap> findGroupRecordsByIds(final ExtensionProxy extension, final String namespace, final Collection<String> ids, final boolean groupsResolving, final boolean groupsResolvingRecursive) {
    Collection<ExtMap> results = new ArrayList<>();
    for (Collection<String> batch : SearchQueryParsingUtils.getIdsBatches(extension.getContext(), ids)) {
        results.addAll(queryGroupRecords(extension, namespace, SearchQueryParsingUtils.generateQueryMap(batch, Authz.QueryEntity.GROUP), groupsResolving, groupsResolvingRecursive));
    }
    return results;
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    VolumeStatusColumn statusColumn = new VolumeStatusColumn();
    statusColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(GlusterVolumeConditionFieldAutoCompleter.FIELDS.NAME.toString());
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    clusterColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    volumeTypeColumn.makeSortable(GlusterVolumeConditionFieldAutoCompleter.FIELDS.TYPE.toString());
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<GlusterTaskSupport>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new Column<GlusterVolumeEntity, GlusterVolumeEntity>(new VolumeCapacityCell()) {

        @Override
        public GlusterVolumeEntity getValue(GlusterVolumeEntity object) {
            return object;
        }
    }, constants.volumeCapacity(), // $NON-NLS-1$
    "60px");
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return !(value == null || value.getAsyncTask() == null);
        }
    }), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
    List<ActionButtonDefinition<GlusterVolumeEntity>> volumeProfilingActions = new LinkedList<ActionButtonDefinition<GlusterVolumeEntity>>();
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartVolumeProfilingCommand();
        }
    });
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.volumeProfileDetails()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShowVolumeProfileDetailsCommand();
        }
    });
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopVolumeProfilingCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.volumeProfilingAction(), volumeProfilingActions, CommandLocation.ContextAndToolBar));
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    VolumeStatusColumn statusColumn = new VolumeStatusColumn();
    statusColumn.makeSortable(new Comparator<GlusterVolumeEntity>() {

        @Override
        public int compare(GlusterVolumeEntity o1, GlusterVolumeEntity o2) {
            return GlusterVolumeUtils.getVolumeStatus(o1).ordinal() - GlusterVolumeUtils.getVolumeStatus(o2).ordinal();
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    clusterColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    volumeTypeColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<GlusterTaskSupport>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new Column<GlusterVolumeEntity, GlusterVolumeEntity>(new VolumeCapacityCell()) {

        @Override
        public GlusterVolumeEntity getValue(GlusterVolumeEntity object) {
            return object;
        }
    }, constants.volumeCapacity(), // $NON-NLS-1$
    "60px");
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return !(value == null || value.getAsyncTask() == null);
        }
    }), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
    List<ActionButtonDefinition<GlusterVolumeEntity>> volumeProfilingActions = new LinkedList<ActionButtonDefinition<GlusterVolumeEntity>>();
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartVolumeProfilingCommand();
        }
    });
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.volumeProfileDetails()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShowVolumeProfileDetailsCommand();
        }
    });
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopVolumeProfilingCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.volumeProfilingAction(), volumeProfilingActions, CommandLocation.ContextAndToolBar));
}
#end_block

#method_before
protected ImageResource getStatusImage(VOLUMESTATUS vStatus) {
    // Find the image corresponding to the status of the volume:
    ImageResource statusImage = null;
    switch(vStatus) {
        case DOWN:
            return downImage;
        case UP:
            return upImage;
        case ALLBRICKSDOWN:
            return allBricksDownImage;
        case SOMEBRICKSDOWN:
            return volumeSomeBricksDownImage;
    }
    return statusImage;
}
#method_after
protected ImageResource getStatusImage(VolumeStatus vStatus) {
    // Find the image corresponding to the status of the volume:
    ImageResource statusImage = null;
    switch(vStatus) {
        case DOWN:
            return downImage;
        case UP:
            return upImage;
        case ALL_BRICKS_DOWN:
            return allBricksDownImage;
        case SOME_BRICKS_DOWN:
            return volumeSomeBricksDownImage;
    }
    return statusImage;
}
#end_block

#method_before
private String getToolTip(VOLUMESTATUS status) {
    switch(status) {
        case DOWN:
            return constants.down();
        case UP:
            return constants.up();
        case SOMEBRICKSDOWN:
            return constants.volumeBricksDown();
        case ALLBRICKSDOWN:
            return constants.volumeAllBricksDown();
        default:
            return constants.down();
    }
}
#method_after
private String getToolTip(VolumeStatus status) {
    switch(status) {
        case DOWN:
            return constants.down();
        case UP:
            return constants.up();
        case SOME_BRICKS_DOWN:
            return constants.volumeBricksDown();
        case ALL_BRICKS_DOWN:
            return constants.volumeAllBricksDown();
        default:
            return constants.down();
    }
}
#end_block

#method_before
@Override
public void render(Context context, GlusterVolumeEntity volume, SafeHtmlBuilder sb) {
    // Nothing to render if no volume is provided:
    if (volume == null) {
        return;
    }
    VOLUMESTATUS vStatus = getVolumeStatus(volume);
    ImageResource statusImage = getStatusImage(vStatus);
    String tooltip = getToolTip(vStatus);
    // Generate the HTML for the image:
    SafeHtml statusImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(statusImage).getHTML());
    sb.append(applicationTemplates.statusTemplate(statusImageHtml, tooltip));
}
#method_after
@Override
public void render(Context context, GlusterVolumeEntity volume, SafeHtmlBuilder sb) {
    // Nothing to render if no volume is provided:
    if (volume == null) {
        return;
    }
    VolumeStatus status = GlusterVolumeUtils.getVolumeStatus(volume);
    ImageResource statusImage = getStatusImage(status);
    String tooltip = getToolTip(status);
    // Generate the HTML for the image:
    SafeHtml statusImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(statusImage).getHTML());
    sb.append(applicationTemplates.statusTemplate(statusImageHtml, tooltip));
}
#end_block

#method_before
private DbUser getTargetDbUser() {
    DbUser dbUser = new DbUser();
    dbUser.setLoginName(getSearchString());
    dbUser.setDomain(getProfile().getSelectedItem().toString());
    return dbUser;
}
#method_after
private DbUser getTargetDbUser() {
    DbUser dbUser = new DbUser();
    dbUser.setLoginName(getSearchString());
    dbUser.setDomain(((ProfileEntry) getProfile().getSelectedItem()).getAuthz());
    return dbUser;
}
#end_block

#method_before
public static String getDefaultConfigurationVersion() {
    return _defaultConfigurationVersion;
}
#method_after
public String getDefaultConfigurationVersion() {
    return _defaultConfigurationVersion;
}
#end_block

#method_before
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initCustomPropertiesList();
}
#method_after
public void initCache(LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initCustomPropertiesList();
}
#end_block

#method_before
private static void initCustomPropertiesList() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            customPropertiesList = (Map<Version, Map<String, String>>) returnValue;
        }
    };
    callback.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return (source != null) ? (Map<Version, Map<String, String>>) source : new HashMap<Version, Map<String, String>>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase().withoutRefresh(), callback);
}
#method_after
private void initCustomPropertiesList() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            customPropertiesList = (Map<Version, Map<String, String>>) returnValue;
        }
    };
    callback.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return (source != null) ? (Map<Version, Map<String, String>>) source : new HashMap<Version, Map<String, String>>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase().withoutRefresh(), callback);
}
#end_block

#method_before
public static void initDefaultOSes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            defaultOSes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDefaultOSes), callback);
}
#method_after
public void initDefaultOSes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            defaultOSes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDefaultOSes), callback);
}
#end_block

#method_before
public static Boolean isMigrationSupported(ArchitectureType architecture, Version version) {
    return migrationSupport.get(architecture).get(version);
}
#method_after
public Boolean isMigrationSupported(ArchitectureType architecture, Version version) {
    return migrationSupport.get(architecture).get(version);
}
#end_block

#method_before
public static Boolean isMemorySnapshotSupportedByArchitecture(ArchitectureType architecture, Version version) {
    return memorySnapshotSupport.get(architecture).get(version);
}
#method_after
public Boolean isMemorySnapshotSupportedByArchitecture(ArchitectureType architecture, Version version) {
    return memorySnapshotSupport.get(architecture).get(version);
}
#end_block

#method_before
public static Boolean isSuspendSupportedByArchitecture(ArchitectureType architecture, Version version) {
    return suspendSupport.get(architecture).get(version);
}
#method_after
public Boolean isSuspendSupportedByArchitecture(ArchitectureType architecture, Version version) {
    return suspendSupport.get(architecture).get(version);
}
#end_block

#method_before
private static void initMigrationSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            migrationSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMigrationSupport), callback);
}
#method_after
private void initMigrationSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            migrationSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMigrationSupport), callback);
}
#end_block

#method_before
private static void initMemorySnapshotSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            memorySnapshotSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMemorySnapshotSupport), callback);
}
#method_after
private void initMemorySnapshotSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            memorySnapshotSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMemorySnapshotSupport), callback);
}
#end_block

#method_before
private static void initSuspendSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            suspendSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetSuspendSupport), callback);
}
#method_after
private void initSuspendSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            suspendSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetSuspendSupport), callback);
}
#end_block

#method_before
public static boolean isMemorySnapshotSupported(VM vm) {
    if (vm == null) {
        return false;
    }
    boolean archMemorySnapshotSupported = isMemorySnapshotSupportedByArchitecture(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion());
    return ((Boolean) getConfigValuePreConverted(ConfigurationValues.MemorySnapshotSupported, vm.getVdsGroupCompatibilityVersion().toString())) && archMemorySnapshotSupported;
}
#method_after
public boolean isMemorySnapshotSupported(VM vm) {
    if (vm == null) {
        return false;
    }
    boolean archMemorySnapshotSupported = isMemorySnapshotSupportedByArchitecture(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion());
    return ((Boolean) getConfigValuePreConverted(ConfigurationValues.MemorySnapshotSupported, vm.getVdsGroupCompatibilityVersion().toString())) && archMemorySnapshotSupported;
}
#end_block

#method_before
public static boolean canVmsBePaused(List<VM> items) {
    for (VM vm : items) {
        if (!AsyncDataProvider.isSuspendSupportedByArchitecture(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion())) {
            return false;
        }
    }
    return true;
}
#method_after
public boolean canVmsBePaused(List<VM> items) {
    for (VM vm : items) {
        if (!isSuspendSupportedByArchitecture(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public static void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#method_after
public void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#end_block

#method_before
public static Map<Pair<Integer, Version>, Boolean> getNicHotplugSupportMap() {
    return nicHotplugSupportMap;
}
#method_after
public Map<Pair<Integer, Version>, Boolean> getNicHotplugSupportMap() {
    return nicHotplugSupportMap;
}
#end_block

#method_before
public static Boolean getNicHotplugSupport(Integer osId, Version version) {
    Pair<Integer, Version> pair = new Pair<Integer, Version>(osId, version);
    if (getNicHotplugSupportMap().containsKey(pair)) {
        return getNicHotplugSupportMap().get(pair);
    }
    return false;
}
#method_after
public Boolean getNicHotplugSupport(Integer osId, Version version) {
    Pair<Integer, Version> pair = new Pair<Integer, Version>(osId, version);
    if (getNicHotplugSupportMap().containsKey(pair)) {
        return getNicHotplugSupportMap().get(pair);
    }
    return false;
}
#end_block

#method_before
public static void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#method_after
public void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#end_block

#method_before
public static Map<Pair<Integer, Version>, Set<String>> getDiskHotpluggableInterfacesMap() {
    return diskHotpluggableInterfacesMap;
}
#method_after
public Map<Pair<Integer, Version>, Set<String>> getDiskHotpluggableInterfacesMap() {
    return diskHotpluggableInterfacesMap;
}
#end_block

#method_before
public static Collection<DiskInterface> getDiskHotpluggableInterfaces(Integer osId, Version version) {
    Set<String> diskHotpluggableInterfaces = getDiskHotpluggableInterfacesMap().get(new Pair<Integer, Version>(osId, version));
    if (diskHotpluggableInterfaces == null) {
        return Collections.emptySet();
    }
    Collection<DiskInterface> diskInterfaces = new HashSet<DiskInterface>();
    for (String diskHotpluggableInterface : diskHotpluggableInterfaces) {
        diskInterfaces.add(DiskInterface.valueOf(diskHotpluggableInterface));
    }
    return diskInterfaces;
}
#method_after
public Collection<DiskInterface> getDiskHotpluggableInterfaces(Integer osId, Version version) {
    Set<String> diskHotpluggableInterfaces = getDiskHotpluggableInterfacesMap().get(new Pair<Integer, Version>(osId, version));
    if (diskHotpluggableInterfaces == null) {
        return Collections.emptySet();
    }
    Collection<DiskInterface> diskInterfaces = new HashSet<DiskInterface>();
    for (String diskHotpluggableInterface : diskHotpluggableInterfaces) {
        diskInterfaces.add(DiskInterface.valueOf(diskHotpluggableInterface));
    }
    return diskInterfaces;
}
#end_block

#method_before
public static void getAAAProfilesListViaPublic(AsyncQuery aQuery) {
    convertAAAProfilesResult(aQuery);
    Frontend.getInstance().runPublicQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getAAAProfilesListViaPublic(AsyncQuery aQuery) {
    convertAAAProfilesResult(aQuery);
    Frontend.getInstance().runPublicQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void getIsoDomainByDataCenterId(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                for (StorageDomain domain : storageDomains) {
                    if (domain.getStorageDomainType() == StorageDomainType.ISO) {
                        return domain;
                    }
                }
            }
            return null;
        }
    };
    IdQueryParameters getIsoParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getIsoParams, aQuery);
}
#method_after
public void getIsoDomainByDataCenterId(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                for (StorageDomain domain : storageDomains) {
                    if (domain.getStorageDomainType() == StorageDomainType.ISO) {
                        return domain;
                    }
                }
            }
            return null;
        }
    };
    IdQueryParameters getIsoParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getIsoParams, aQuery);
}
#end_block

#method_before
public static void getExportDomainByDataCenterId(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
            for (StorageDomain domain : storageDomains) {
                if (domain.getStorageDomainType() == StorageDomainType.ImportExport) {
                    return domain;
                }
            }
            return null;
        }
    };
    IdQueryParameters getExportParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getExportParams, aQuery);
}
#method_after
public void getExportDomainByDataCenterId(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
            for (StorageDomain domain : storageDomains) {
                if (domain.getStorageDomainType() == StorageDomainType.ImportExport) {
                    return domain;
                }
            }
            return null;
        }
    };
    IdQueryParameters getExportParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getExportParams, aQuery);
}
#end_block

#method_before
public static void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId) {
    getIrsImageList(aQuery, storagePoolId, false);
}
#method_after
public void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId) {
    getIrsImageList(aQuery, storagePoolId, false);
}
#end_block

#method_before
public static void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId, boolean forceRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
                ArrayList<String> fileNameList = new ArrayList<String>();
                for (RepoImage repoImage : repoList) {
                    fileNameList.add(repoImage.getRepoImageId());
                }
                Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
                return fileNameList;
            }
            return new ArrayList<String>();
        }
    };
    GetImagesListByStoragePoolIdParameters parameters = new GetImagesListByStoragePoolIdParameters(storagePoolId, ImageFileType.ISO);
    parameters.setForceRefresh(forceRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, parameters, aQuery);
}
#method_after
public void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId, boolean forceRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
                ArrayList<String> fileNameList = new ArrayList<String>();
                for (RepoImage repoImage : repoList) {
                    fileNameList.add(repoImage.getRepoImageId());
                }
                Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
                return fileNameList;
            }
            return new ArrayList<String>();
        }
    };
    GetImagesListByStoragePoolIdParameters parameters = new GetImagesListByStoragePoolIdParameters(storagePoolId, ImageFileType.ISO);
    parameters.setForceRefresh(forceRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, parameters, aQuery);
}
#end_block

#method_before
public static void getFloppyImageList(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
                ArrayList<String> fileNameList = new ArrayList<String>();
                for (RepoImage repoImage : repoList) {
                    fileNameList.add(repoImage.getRepoImageId());
                }
                Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
                return fileNameList;
            }
            return new ArrayList<String>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, new GetImagesListByStoragePoolIdParameters(storagePoolId, ImageFileType.Floppy), aQuery);
}
#method_after
public void getFloppyImageList(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
                ArrayList<String> fileNameList = new ArrayList<String>();
                for (RepoImage repoImage : repoList) {
                    fileNameList.add(repoImage.getRepoImageId());
                }
                Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
                return fileNameList;
            }
            return new ArrayList<String>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, new GetImagesListByStoragePoolIdParameters(storagePoolId, ImageFileType.Floppy), aQuery);
}
#end_block

#method_before
public static void isClusterEmpty(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter<Boolean>() {

        @Override
        public Boolean Convert(Object source, AsyncQuery _asyncQuery) {
            return (Boolean) source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsClusterEmpty, new IdQueryParameters(id), aQuery);
}
#method_after
public void isClusterEmpty(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter<Boolean>() {

        @Override
        public Boolean Convert(Object source, AsyncQuery _asyncQuery) {
            return (Boolean) source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsClusterEmpty, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getHostArchitecture(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter<ArchitectureType>() {

        @Override
        public ArchitectureType Convert(Object source, AsyncQuery _asyncQuery) {
            return (ArchitectureType) source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostArchitecture, new IdQueryParameters(id), aQuery);
}
#method_after
public void getHostArchitecture(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter<ArchitectureType>() {

        @Override
        public ArchitectureType Convert(Object source, AsyncQuery _asyncQuery) {
            return (ArchitectureType) source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostArchitecture, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getClusterById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupById, new IdQueryParameters(id), aQuery);
}
#method_after
public void getClusterById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupById, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getClusterListByName(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDSGroup>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Cluster: name=" + name + " sortby name", SearchType.Cluster), aQuery);
}
#method_after
public void getClusterListByName(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDSGroup>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Cluster: name=" + name + " sortby name", SearchType.Cluster), aQuery);
}
#end_block

#method_before
public static void getPoolById(AsyncQuery aQuery, Guid poolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmPoolById, new IdQueryParameters(poolId), aQuery);
}
#method_after
public void getPoolById(AsyncQuery aQuery, Guid poolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmPoolById, new IdQueryParameters(poolId), aQuery);
}
#end_block

#method_before
public static void getVmById(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmByVmId, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getVmById(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmByVmId, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void getVmNextRunConfiguration(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getVmNextRunConfiguration(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void isNextRunConfigurationChanged(VM original, VM updated, AsyncQuery aQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmUpdatesOnNextRunExists, new GetVmUpdatesOnNextRunExistsParameters(original, updated), aQuery);
}
#method_after
public void isNextRunConfigurationChanged(VM original, VM updated, VmManagementParametersBase updateVmParameters, AsyncQuery aQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmUpdatesOnNextRunExists, new GetVmUpdatesOnNextRunExistsParameters(original, updated, updateVmParameters), aQuery);
}
#end_block

#method_before
public static void getDataCenterList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$
    new SearchParameters("DataCenter: sortby name", SearchType.StoragePool), aQuery);
}
#method_after
public void getDataCenterList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$
    new SearchParameters("DataCenter: sortby name", SearchType.StoragePool), aQuery);
}
#end_block

#method_before
public static void getDataCenterByClusterServiceList(AsyncQuery aQuery, boolean supportsVirtService, boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            // sort data centers
            final ArrayList<StoragePool> storagePoolList = (ArrayList<StoragePool>) source;
            Collections.sort(storagePoolList, new NameableComparator());
            return source;
        }
    };
    final GetStoragePoolsByClusterServiceParameters parameters = new GetStoragePoolsByClusterServiceParameters();
    parameters.setSupportsVirtService(supportsVirtService);
    parameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByClusterService, parameters, aQuery);
}
#method_after
public void getDataCenterByClusterServiceList(AsyncQuery aQuery, boolean supportsVirtService, boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            // sort data centers
            final ArrayList<StoragePool> storagePoolList = (ArrayList<StoragePool>) source;
            Collections.sort(storagePoolList, new NameableComparator());
            return source;
        }
    };
    final GetStoragePoolsByClusterServiceParameters parameters = new GetStoragePoolsByClusterServiceParameters();
    parameters.setSupportsVirtService(supportsVirtService);
    parameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByClusterService, parameters, aQuery);
}
#end_block

#method_before
public static void getDataCenterListByName(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("DataCenter: name=" + name + " sortby name", SearchType.StoragePool), aQuery);
}
#method_after
public void getDataCenterListByName(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("DataCenter: name=" + name + " sortby name", SearchType.StoragePool), aQuery);
}
#end_block

#method_before
public static void getSpiceUsbAutoShare(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Boolean) source).booleanValue() : true;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SpiceUsbAutoShare, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getSpiceUsbAutoShare(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Boolean) source).booleanValue() : true;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SpiceUsbAutoShare, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getWANColorDepth(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? WanColorDepth.fromInt(((Integer) source).intValue()) : WanColorDepth.depth16;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANColorDepth, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getWANColorDepth(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? WanColorDepth.fromInt(((Integer) source).intValue()) : WanColorDepth.depth16;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANColorDepth, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getWANDisableEffects(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<WANDisableEffects>();
            }
            List<WANDisableEffects> res = new ArrayList<WANDisableEffects>();
            String fromDb = (String) source;
            for (String value : fromDb.split(",")) {
                // $NON-NLS-1$
                if (value == null) {
                    continue;
                }
                String trimmedValue = value.trim();
                if ("".equals(trimmedValue)) {
                    continue;
                }
                res.add(WANDisableEffects.fromString(trimmedValue));
            }
            return res;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANDisableEffects, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getWANDisableEffects(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<WANDisableEffects>();
            }
            List<WANDisableEffects> res = new ArrayList<WANDisableEffects>();
            String fromDb = (String) source;
            for (String value : fromDb.split(",")) {
                // $NON-NLS-1$
                if (value == null) {
                    continue;
                }
                String trimmedValue = value.trim();
                if ("".equals(trimmedValue)) {
                    continue;
                }
                res.add(WANDisableEffects.fromString(trimmedValue));
            }
            return res;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANDisableEffects, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getMaxVmsInPool(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1000;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVmsInPool, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getMaxVmsInPool(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1000;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVmsInPool, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getMaxNumOfVmSockets(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmSockets);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getMaxNumOfVmSockets(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmSockets);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public static void getMaxNumOfVmCpus(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmCpus);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getMaxNumOfVmCpus(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmCpus);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public static void getMaxNumOfCPUsPerSocket(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfCpuPerSocket);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getMaxNumOfCPUsPerSocket(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfCpuPerSocket);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public static void getClusterList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getClusterList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public static List<VDSGroup> filterByArchitecture(List<VDSGroup> clusters, ArchitectureType targetArchitecture) {
    List<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getArchitecture().equals(targetArchitecture)) {
            filteredClusters.add(cluster);
        }
    }
    return filteredClusters;
}
#method_after
public List<VDSGroup> filterByArchitecture(List<VDSGroup> clusters, ArchitectureType targetArchitecture) {
    List<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getArchitecture().equals(targetArchitecture)) {
            filteredClusters.add(cluster);
        }
    }
    return filteredClusters;
}
#end_block

#method_before
public static List<VDSGroup> filterClustersWithoutArchitecture(List<VDSGroup> clusters) {
    List<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getArchitecture() != ArchitectureType.undefined) {
            filteredClusters.add(cluster);
        }
    }
    return filteredClusters;
}
#method_after
public List<VDSGroup> filterClustersWithoutArchitecture(List<VDSGroup> clusters) {
    List<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getArchitecture() != ArchitectureType.undefined) {
            filteredClusters.add(cluster);
        }
    }
    return filteredClusters;
}
#end_block

#method_before
public static void getClusterByServiceList(AsyncQuery aQuery, Guid dataCenterId, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDSGroup>();
            }
            final ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
            return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getClusterByServiceList(AsyncQuery aQuery, Guid dataCenterId, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDSGroup>();
            }
            final ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
            return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public static void isSoundcardEnabled(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void isSoundcardEnabled(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void isVirtioScsiEnabledForVm(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void isVirtioScsiEnabledForVm(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void getClusterListByService(AsyncQuery aQuery, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = getClusterByServiceList((ArrayList<VDSGroup>) source, supportsVirtService, supportsGlusterService);
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsGroups, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getClusterListByService(AsyncQuery aQuery, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = getClusterByServiceList((ArrayList<VDSGroup>) source, supportsVirtService, supportsGlusterService);
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsGroups, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void getClusterList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsGroups, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getClusterList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsGroups, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void getTemplateDiskList(AsyncQuery aQuery, Guid templateId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<DiskImage>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesDisks, new IdQueryParameters(templateId), aQuery);
}
#method_after
public void getTemplateDiskList(AsyncQuery aQuery, Guid templateId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<DiskImage>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesDisks, new IdQueryParameters(templateId), aQuery);
}
#end_block

#method_before
public static int getRoundedPriority(int priority, int maxPriority) {
    int medium = maxPriority / 2;
    int[] levels = new int[] { 1, medium, maxPriority };
    for (int i = 0; i < levels.length; i++) {
        int lengthToLess = levels[i] - priority;
        int lengthToMore = levels[i + 1] - priority;
        if (lengthToMore < 0) {
            continue;
        }
        return Math.abs(lengthToLess) < lengthToMore ? levels[i] : levels[i + 1];
    }
    return 0;
}
#method_after
public int getRoundedPriority(int priority, int maxPriority) {
    int medium = maxPriority / 2;
    int[] levels = new int[] { 1, medium, maxPriority };
    for (int i = 0; i < levels.length; i++) {
        int lengthToLess = levels[i] - priority;
        int lengthToMore = levels[i + 1] - priority;
        if (lengthToMore < 0) {
            continue;
        }
        return Math.abs(lengthToLess) < lengthToMore ? levels[i] : levels[i + 1];
    }
    return 0;
}
#end_block

#method_before
public static void getTemplateListByDataCenter(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new TemplateConverter();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getTemplateListByDataCenter(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new TemplateConverter();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public static void getTemplateListByStorage(AsyncQuery aQuery, Guid storageId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VmTemplate> list = new ArrayList<VmTemplate>();
            if (source != null) {
                for (VmTemplate template : (ArrayList<VmTemplate>) source) {
                    if (template.getStatus() == VmTemplateStatus.OK) {
                        list.add(template);
                    }
                }
                Collections.sort(list, new NameableComparator());
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesFromStorageDomain, new IdQueryParameters(storageId), aQuery);
}
#method_after
public void getTemplateListByStorage(AsyncQuery aQuery, Guid storageId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VmTemplate> list = new ArrayList<VmTemplate>();
            if (source != null) {
                for (VmTemplate template : (ArrayList<VmTemplate>) source) {
                    if (template.getStatus() == VmTemplateStatus.OK) {
                        list.add(template);
                    }
                }
                Collections.sort(list, new NameableComparator());
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesFromStorageDomain, new IdQueryParameters(storageId), aQuery);
}
#end_block

#method_before
public static ArrayList<VmTemplate> filterTemplatesByArchitecture(List<VmTemplate> list, ArchitectureType architecture) {
    ArrayList<VmTemplate> filteredList = new ArrayList<VmTemplate>();
    for (VmTemplate template : list) {
        if (template.getId().equals(Guid.Empty) || template.getClusterArch().equals(architecture)) {
            filteredList.add(template);
        }
    }
    return filteredList;
}
#method_after
public ArrayList<VmTemplate> filterTemplatesByArchitecture(List<VmTemplate> list, ArchitectureType architecture) {
    ArrayList<VmTemplate> filteredList = new ArrayList<VmTemplate>();
    for (VmTemplate template : list) {
        if (template.getId().equals(Guid.Empty) || template.getClusterArch().equals(architecture)) {
            filteredList.add(template);
        }
    }
    return filteredList;
}
#end_block

#method_before
public static void getNumOfMonitorList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Integer> nums = new ArrayList<Integer>();
            if (source != null) {
                Iterable numEnumerable = (Iterable) source;
                Iterator numIterator = numEnumerable.iterator();
                while (numIterator.hasNext()) {
                    nums.add(Integer.parseInt(numIterator.next().toString()));
                }
            }
            return nums;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.ValidNumOfMonitors, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getNumOfMonitorList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Integer> nums = new ArrayList<Integer>();
            if (source != null) {
                Iterable numEnumerable = (Iterable) source;
                Iterator numIterator = numEnumerable.iterator();
                while (numIterator.hasNext()) {
                    nums.add(Integer.parseInt(numIterator.next().toString()));
                }
            }
            return nums;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.ValidNumOfMonitors, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getStorageDomainList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StorageDomain>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getStorageDomainList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StorageDomain>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public static void getMaxVmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return 100;
            }
            return source;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.VmPriorityMaxValue, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getMaxVmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return 100;
            }
            return source;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.VmPriorityMaxValue, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getHostById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getHostById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getHostListByCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((ArrayList<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$ //$NON-NLS-2$
    SearchParameters(// $NON-NLS-1$ //$NON-NLS-2$
    "Host: cluster = " + clusterName + " sortby name", SearchType.VDS), aQuery);
}
#method_after
public void getHostListByCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((ArrayList<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$ //$NON-NLS-2$
    SearchParameters(// $NON-NLS-1$ //$NON-NLS-2$
    "Host: cluster = " + clusterName + " sortby name", SearchType.VDS), aQuery);
}
#end_block

#method_before
public static void getHostListByDataCenter(AsyncQuery aQuery, Guid spId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((ArrayList<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsByStoragePool, new IdQueryParameters(spId), aQuery);
}
#method_after
public void getHostListByDataCenter(AsyncQuery aQuery, Guid spId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((ArrayList<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsByStoragePool, new IdQueryParameters(spId), aQuery);
}
#end_block

#method_before
public static void getVmDiskList(AsyncQuery aQuery, Guid vmId, boolean isRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return source;
            }
            return new ArrayList<DiskImage>();
        }
    };
    IdQueryParameters params = new IdQueryParameters(vmId);
    params.setRefresh(isRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, params, aQuery);
}
#method_after
public void getVmDiskList(AsyncQuery aQuery, Guid vmId, boolean isRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return source;
            }
            return new ArrayList<DiskImage>();
        }
    };
    IdQueryParameters params = new IdQueryParameters(vmId);
    params.setRefresh(isRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, params, aQuery);
}
#end_block

#method_before
public static HashMap<Integer, String> getOsUniqueOsNames() {
    return uniqueOsNames;
}
#method_after
public HashMap<Integer, String> getOsUniqueOsNames() {
    return uniqueOsNames;
}
#end_block

#method_before
public static void getAAAProfilesList(AsyncQuery aQuery) {
    convertAAAProfilesResult(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getAAAProfilesList(AsyncQuery aQuery) {
    convertAAAProfilesResult(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void getRoleList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Role>) source : new ArrayList<Role>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRoles, new MultilevelAdministrationsQueriesParameters(), aQuery);
}
#method_after
public void getRoleList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Role>) source : new ArrayList<Role>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRoles, new MultilevelAdministrationsQueriesParameters(), aQuery);
}
#end_block

#method_before
public static void getStorageDomainById(AsyncQuery aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (StorageDomain) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainById, new IdQueryParameters(storageDomainId), aQuery);
}
#method_after
public void getStorageDomainById(AsyncQuery aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (StorageDomain) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainById, new IdQueryParameters(storageDomainId), aQuery);
}
#end_block

#method_before
public static VolumeFormat getDiskVolumeFormat(VolumeType volumeType, StorageType storageType) {
    if (storageType.isFileDomain()) {
        return VolumeFormat.RAW;
    } else if (storageType.isBlockDomain()) {
        switch(volumeType) {
            case Sparse:
                return VolumeFormat.COW;
            case Preallocated:
                return VolumeFormat.RAW;
            default:
                return VolumeFormat.Unassigned;
        }
    } else {
        return VolumeFormat.Unassigned;
    }
}
#method_after
public VolumeFormat getDiskVolumeFormat(VolumeType volumeType, StorageType storageType) {
    if (storageType.isFileDomain()) {
        return VolumeFormat.RAW;
    } else if (storageType.isBlockDomain()) {
        switch(volumeType) {
            case Sparse:
                return VolumeFormat.COW;
            case Preallocated:
                return VolumeFormat.RAW;
            default:
                return VolumeFormat.Unassigned;
        }
    } else {
        return VolumeFormat.Unassigned;
    }
}
#end_block

#method_before
public static void getClusterNetworkList(AsyncQuery aQuery, Guid clusterId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return new ArrayList<Network>();
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworksByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getClusterNetworkList(AsyncQuery aQuery, Guid clusterId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return new ArrayList<Network>();
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworksByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
public static void getAllNetworkQos(Guid dcId, AsyncQuery query) {
    query.converterCallback = new IAsyncConverter<List<NetworkQoS>>() {

        @Override
        public List<NetworkQoS> Convert(Object returnValue, AsyncQuery asyncQuery) {
            List<NetworkQoS> qosList = returnValue == null ? new ArrayList<NetworkQoS>() : (List<NetworkQoS>) returnValue;
            qosList.add(0, NetworkQoSModel.EMPTY_QOS);
            return qosList;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, new IdQueryParameters(dcId), query);
}
#method_after
public void getAllNetworkQos(Guid dcId, AsyncQuery query) {
    query.converterCallback = new IAsyncConverter<List<NetworkQoS>>() {

        @Override
        public List<NetworkQoS> Convert(Object returnValue, AsyncQuery asyncQuery) {
            List<NetworkQoS> qosList = returnValue == null ? new ArrayList<NetworkQoS>() : (List<NetworkQoS>) returnValue;
            qosList.add(0, NetworkQoSModel.EMPTY_QOS);
            return qosList;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, new IdQueryParameters(dcId), query);
}
#end_block

#method_before
public static void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId).withoutRefresh(), aQuery);
}
#method_after
public void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void getNetworkLabelsByDataCenterId(Guid dataCenterId, AsyncQuery query) {
    query.converterCallback = new IAsyncConverter<SortedSet<String>>() {

        @Override
        public SortedSet<String> Convert(Object returnValue, AsyncQuery asyncQuery) {
            SortedSet<String> sortedSet = new TreeSet<String>(new LexoNumericComparator());
            sortedSet.addAll((Collection<String>) returnValue);
            return sortedSet;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworkLabelsByDataCenterId, new IdQueryParameters(dataCenterId), query);
}
#method_after
public void getNetworkLabelsByDataCenterId(Guid dataCenterId, AsyncQuery query) {
    query.converterCallback = new IAsyncConverter<SortedSet<String>>() {

        @Override
        public SortedSet<String> Convert(Object returnValue, AsyncQuery asyncQuery) {
            SortedSet<String> sortedSet = new TreeSet<String>(new LexoNumericComparator());
            sortedSet.addAll((Collection<String>) returnValue);
            return sortedSet;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworkLabelsByDataCenterId, new IdQueryParameters(dataCenterId), query);
}
#end_block

#method_before
public static void getWatchdogByVmId(AsyncQuery aQuery, Guid vmId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getWatchdogByVmId(AsyncQuery aQuery, Guid vmId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void getTemplateById(AsyncQuery aQuery, Guid templateId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(templateId), aQuery);
}
#method_after
public void getTemplateById(AsyncQuery aQuery, Guid templateId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(templateId), aQuery);
}
#end_block

#method_before
public static void countAllTemplates(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplateCount, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void countAllTemplates(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplateCount, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void getHostList(AsyncQuery aQuery) {
    getHostListByStatus(aQuery, null);
}
#method_after
public void getHostList(AsyncQuery aQuery) {
    getHostListByStatus(aQuery, null);
}
#end_block

#method_before
public static void getHostListByStatus(AsyncQuery aQuery, VDSStatus status) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((Iterable) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: " + (status == null ? "" : ("status=" + status.name())), SearchType.VDS);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public void getHostListByStatus(AsyncQuery aQuery, VDSStatus status) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((Iterable) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: " + (status == null ? "" : ("status=" + status.name())), SearchType.VDS);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#end_block

#method_before
public static void getHostsForStorageOperation(AsyncQuery aQuery, Guid storagePoolId, boolean localFsOnly) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return source;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsForStorageOperation, new GetHostsForStorageOperationParameters(storagePoolId, localFsOnly), aQuery);
}
#method_after
public void getHostsForStorageOperation(AsyncQuery aQuery, Guid storagePoolId, boolean localFsOnly) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return source;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsForStorageOperation, new GetHostsForStorageOperationParameters(storagePoolId, localFsOnly), aQuery);
}
#end_block

#method_before
public static void getVolumeList(AsyncQuery aQuery, String clusterName) {
    if ((ApplicationModeHelper.getUiMode().getValue() & ApplicationMode.GlusterOnly.getValue()) == 0) {
        aQuery.asyncCallback.onSuccess(aQuery.model, new ArrayList<GlusterVolumeEntity>());
        return;
    }
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<GlusterVolumeEntity> list = (ArrayList<GlusterVolumeEntity>) source;
                return list;
            }
            return new ArrayList<GlusterVolumeEntity>();
        }
    };
    SearchParameters searchParameters;
    searchParameters = // $NON-NLS-1$
    clusterName == null ? // $NON-NLS-1$
    new SearchParameters("Volumes:", SearchType.GlusterVolume) : // $NON-NLS-1$
    new SearchParameters("Volumes: cluster.name=" + clusterName, SearchType.GlusterVolume);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public void getVolumeList(AsyncQuery aQuery, String clusterName) {
    if ((ApplicationModeHelper.getUiMode().getValue() & ApplicationMode.GlusterOnly.getValue()) == 0) {
        aQuery.asyncCallback.onSuccess(aQuery.model, new ArrayList<GlusterVolumeEntity>());
        return;
    }
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<GlusterVolumeEntity> list = (ArrayList<GlusterVolumeEntity>) source;
                return list;
            }
            return new ArrayList<GlusterVolumeEntity>();
        }
    };
    SearchParameters searchParameters;
    searchParameters = // $NON-NLS-1$
    clusterName == null ? // $NON-NLS-1$
    new SearchParameters("Volumes:", SearchType.GlusterVolume) : // $NON-NLS-1$
    new SearchParameters("Volumes: cluster.name=" + clusterName, SearchType.GlusterVolume);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#end_block

#method_before
public static void getGlusterVolumeOptionInfoList(AsyncQuery aQuery, Guid clusterId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeOptionsInfo, new GlusterParameters(clusterId), aQuery);
}
#method_after
public void getGlusterVolumeOptionInfoList(AsyncQuery aQuery, Guid clusterId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeOptionsInfo, new GlusterParameters(clusterId), aQuery);
}
#end_block

#method_before
public static void getHostFingerprint(AsyncQuery aQuery, String hostAddress) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetServerSSHKeyFingerprint, new ServerParameters(hostAddress), aQuery);
}
#method_after
public void getHostFingerprint(AsyncQuery aQuery, String hostAddress) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetServerSSHKeyFingerprint, new ServerParameters(hostAddress), aQuery);
}
#end_block

#method_before
public static void getHostPublicKey(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetServerSSHPublicKey, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getHostPublicKey(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetServerSSHPublicKey, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void getGlusterHosts(AsyncQuery aQuery, String hostAddress, String rootPassword, String fingerprint) {
    GlusterServersQueryParameters parameters = new GlusterServersQueryParameters(hostAddress, rootPassword);
    parameters.setFingerprint(fingerprint);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServersForImport, parameters, aQuery);
}
#method_after
public void getGlusterHosts(AsyncQuery aQuery, String hostAddress, String rootPassword, String fingerprint) {
    GlusterServersQueryParameters parameters = new GlusterServersQueryParameters(hostAddress, rootPassword);
    parameters.setFingerprint(fingerprint);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServersForImport, parameters, aQuery);
}
#end_block

#method_before
public static void getClusterGlusterServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    // Passing empty values for Volume and Brick to get the services of all the volumes/hosts in the cluster
    GlusterVolumeAdvancedDetailsParameters parameters = // $NON-NLS-1$ //$NON-NLS-2$
    new GlusterVolumeAdvancedDetailsParameters(clusterId, null, null, false);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#method_after
public void getClusterGlusterServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    // Passing empty values for Volume and Brick to get the services of all the volumes/hosts in the cluster
    GlusterVolumeAdvancedDetailsParameters parameters = // $NON-NLS-1$ //$NON-NLS-2$
    new GlusterVolumeAdvancedDetailsParameters(clusterId, null, null, false);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#end_block

#method_before
public static void getGlusterVolumeBrickDetails(AsyncQuery aQuery, Guid clusterId, Guid volumeId, Guid brickId) {
    GlusterVolumeAdvancedDetailsParameters parameters = new GlusterVolumeAdvancedDetailsParameters(clusterId, volumeId, brickId, true);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#method_after
public void getGlusterVolumeBrickDetails(AsyncQuery aQuery, Guid clusterId, Guid volumeId, Guid brickId) {
    GlusterVolumeAdvancedDetailsParameters parameters = new GlusterVolumeAdvancedDetailsParameters(clusterId, volumeId, brickId, true);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#end_block

#method_before
public static void getGlusterHostsNewlyAdded(AsyncQuery aQuery, Guid clusterId, boolean isFingerprintRequired) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAddedGlusterServers, new AddedGlusterServersParameters(clusterId, isFingerprintRequired), aQuery);
}
#method_after
public void getGlusterHostsNewlyAdded(AsyncQuery aQuery, Guid clusterId, boolean isFingerprintRequired) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAddedGlusterServers, new AddedGlusterServersParameters(clusterId, isFingerprintRequired), aQuery);
}
#end_block

#method_before
public static void isAnyHostUpInCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null && !((List<?>) source).isEmpty()) {
                return true;
            }
            return false;
        }
    };
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#method_after
public void isAnyHostUpInCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null && !((List<?>) source).isEmpty()) {
                return true;
            }
            return false;
        }
    };
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#end_block

#method_before
public static void getGlusterHooks(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterHookEntity>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHooks, new GlusterParameters(clusterId), aQuery);
}
#method_after
public void getGlusterHooks(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterHookEntity>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHooks, new GlusterParameters(clusterId), aQuery);
}
#end_block

#method_before
public static void getGlusterBricksForServer(AsyncQuery aQuery, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterBrickEntity>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeBricksByServerId, new IdQueryParameters(serverId), aQuery);
}
#method_after
public void getGlusterBricksForServer(AsyncQuery aQuery, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterBrickEntity>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeBricksByServerId, new IdQueryParameters(serverId), aQuery);
}
#end_block

#method_before
public static void getGlusterHook(AsyncQuery aQuery, Guid hookId, boolean includeServerHooks) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookById, new GlusterHookQueryParameters(hookId, includeServerHooks), aQuery);
}
#method_after
public void getGlusterHook(AsyncQuery aQuery, Guid hookId, boolean includeServerHooks) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookById, new GlusterHookQueryParameters(hookId, includeServerHooks), aQuery);
}
#end_block

#method_before
public static void getGlusterHookContent(AsyncQuery aQuery, Guid hookId, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? source : "";
        }
    };
    GlusterHookContentQueryParameters parameters = new GlusterHookContentQueryParameters(hookId);
    parameters.setGlusterServerId(serverId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookContent, parameters, aQuery);
}
#method_after
public void getGlusterHookContent(AsyncQuery aQuery, Guid hookId, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? source : "";
        }
    };
    GlusterHookContentQueryParameters parameters = new GlusterHookContentQueryParameters(hookId);
    parameters.setGlusterServerId(serverId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookContent, parameters, aQuery);
}
#end_block

#method_before
public static void getGlusterSwiftServices(AsyncQuery aQuery, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterServerService>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByServerId, new GlusterServiceQueryParameters(serverId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#method_after
public void getGlusterSwiftServices(AsyncQuery aQuery, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterServerService>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByServerId, new GlusterServiceQueryParameters(serverId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#end_block

#method_before
public static void getClusterGlusterSwiftService(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                List<GlusterClusterService> serviceList = (List<GlusterClusterService>) source;
                if (!serviceList.isEmpty()) {
                    return serviceList.get(0);
                }
                return null;
            } else {
                return source;
            }
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterClusterServiceByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#method_after
public void getClusterGlusterSwiftService(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                List<GlusterClusterService> serviceList = (List<GlusterClusterService>) source;
                if (!serviceList.isEmpty()) {
                    return serviceList.get(0);
                }
                return null;
            } else {
                return source;
            }
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterClusterServiceByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#end_block

#method_before
public static void getGlusterSwiftServerServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterServerService>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#method_after
public void getGlusterSwiftServerServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterServerService>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#end_block

#method_before
public static void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#method_after
public void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#end_block

#method_before
public static void getGlusterVolumeProfilingStatistics(AsyncQuery aQuery, Guid clusterId, Guid volumeId, boolean nfs) {
    aQuery.setHandleFailure(true);
    GlusterVolumeProfileParameters parameters = new GlusterVolumeProfileParameters(clusterId, volumeId, nfs);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeProfileInfo, parameters, aQuery);
}
#method_after
public void getGlusterVolumeProfilingStatistics(AsyncQuery aQuery, Guid clusterId, Guid volumeId, boolean nfs) {
    aQuery.setHandleFailure(true);
    GlusterVolumeProfileParameters parameters = new GlusterVolumeProfileParameters(clusterId, volumeId, nfs);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeProfileInfo, parameters, aQuery);
}
#end_block

#method_before
public static void getGlusterRemoveBricksStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId, List<GlusterBrickEntity> bricks) {
    aQuery.setHandleFailure(true);
    GlusterVolumeRemoveBricksQueriesParameters parameters = new GlusterVolumeRemoveBricksQueriesParameters(clusterId, volumeId, bricks);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRemoveBricksStatus, parameters, aQuery);
}
#method_after
public void getGlusterRemoveBricksStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId, List<GlusterBrickEntity> bricks) {
    aQuery.setHandleFailure(true);
    GlusterVolumeRemoveBricksQueriesParameters parameters = new GlusterVolumeRemoveBricksQueriesParameters(clusterId, volumeId, bricks);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRemoveBricksStatus, parameters, aQuery);
}
#end_block

#method_before
public static void getRpmVersion(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.ProductRPMVersion);
    tempVar.setVersion(getDefaultConfigurationVersion());
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getRpmVersion(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.ProductRPMVersion);
    tempVar.setVersion(getDefaultConfigurationVersion());
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public static void getUserMessageOfTheDayViaPublic(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.UserMessageOfTheDay, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getUserMessageOfTheDayViaPublic(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.UserMessageOfTheDay, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getSearchResultsLimit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 100;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SearchResultsLimit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getSearchResultsLimit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 100;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SearchResultsLimit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static Map<Version, Map<String, String>> getCustomPropertiesList() {
    return customPropertiesList;
}
#method_after
public Map<Version, Map<String, String>> getCustomPropertiesList() {
    return customPropertiesList;
}
#end_block

#method_before
public static void getPermissionsByAdElementId(AsyncQuery aQuery, Guid userId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Permissions>) source : new ArrayList<Permissions>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(userId), aQuery);
}
#method_after
public void getPermissionsByAdElementId(AsyncQuery aQuery, Guid userId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Permissions>) source : new ArrayList<Permissions>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(userId), aQuery);
}
#end_block

#method_before
public static void getRoleActionGroupsByRoleId(AsyncQuery aQuery, Guid roleId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<ActionGroup>) source : new ArrayList<ActionGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetRoleActionGroupsByRoleId, new IdQueryParameters(roleId), aQuery);
}
#method_after
public void getRoleActionGroupsByRoleId(AsyncQuery aQuery, Guid roleId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<ActionGroup>) source : new ArrayList<ActionGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetRoleActionGroupsByRoleId, new IdQueryParameters(roleId), aQuery);
}
#end_block

#method_before
public static void isTemplateNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? !((Boolean) source).booleanValue() : false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmTemlateWithSameNameExist, new NameQueryParameters(name), aQuery);
}
#method_after
public void isTemplateNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? !((Boolean) source).booleanValue() : false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmTemlateWithSameNameExist, new NameQueryParameters(name), aQuery);
}
#end_block

#method_before
public static void isVmNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? !((Boolean) source).booleanValue() : false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmWithSameNameExist, new NameQueryParameters(name), aQuery);
}
#method_after
public void isVmNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? !((Boolean) source).booleanValue() : false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmWithSameNameExist, new NameQueryParameters(name), aQuery);
}
#end_block

#method_before
public static void getDataCentersWithPermittedActionOnClusters(AsyncQuery aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    GetDataCentersWithPermittedActionOnClustersParameters getDataCentersWithPermittedActionOnClustersParameters = new GetDataCentersWithPermittedActionOnClustersParameters();
    getDataCentersWithPermittedActionOnClustersParameters.setActionGroup(actionGroup);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsVirtService(supportsVirtService);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetDataCentersWithPermittedActionOnClusters, getDataCentersWithPermittedActionOnClustersParameters, aQuery);
}
#method_after
public void getDataCentersWithPermittedActionOnClusters(AsyncQuery aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    GetDataCentersWithPermittedActionOnClustersParameters getDataCentersWithPermittedActionOnClustersParameters = new GetDataCentersWithPermittedActionOnClustersParameters();
    getDataCentersWithPermittedActionOnClustersParameters.setActionGroup(actionGroup);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsVirtService(supportsVirtService);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetDataCentersWithPermittedActionOnClusters, getDataCentersWithPermittedActionOnClustersParameters, aQuery);
}
#end_block

#method_before
public static void getClustersWithPermittedAction(AsyncQuery aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
            }
            return new ArrayList<VDSGroup>();
        }
    };
    GetEntitiesWithPermittedActionParameters getEntitiesWithPermittedActionParameters = new GetEntitiesWithPermittedActionParameters();
    getEntitiesWithPermittedActionParameters.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetClustersWithPermittedAction, getEntitiesWithPermittedActionParameters, aQuery);
}
#method_after
public void getClustersWithPermittedAction(AsyncQuery aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
            }
            return new ArrayList<VDSGroup>();
        }
    };
    GetEntitiesWithPermittedActionParameters getEntitiesWithPermittedActionParameters = new GetEntitiesWithPermittedActionParameters();
    getEntitiesWithPermittedActionParameters.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetClustersWithPermittedAction, getEntitiesWithPermittedActionParameters, aQuery);
}
#end_block

#method_before
public static void getAllVmTemplates(AsyncQuery aQuery, final boolean refresh) {
    aQuery.converterCallback = new TemplateConverter();
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setRefresh(refresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmTemplates, params, aQuery);
}
#method_after
public void getAllVmTemplates(AsyncQuery aQuery, final boolean refresh) {
    aQuery.converterCallback = new TemplateConverter();
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setRefresh(refresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmTemplates, params, aQuery);
}
#end_block

#method_before
public static void isUSBEnabledByDefault(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Boolean) source).booleanValue() : false;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.EnableUSBAsDefault, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void isUSBEnabledByDefault(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Boolean) source).booleanValue() : false;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.EnableUSBAsDefault, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getStorageConnectionById(AsyncQuery aQuery, String id, boolean isRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (StorageServerConnections) source : null;
        }
    };
    StorageServerConnectionQueryParametersBase params = new StorageServerConnectionQueryParametersBase(id);
    params.setRefresh(isRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageServerConnectionById, params, aQuery);
}
#method_after
public void getStorageConnectionById(AsyncQuery aQuery, String id, boolean isRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (StorageServerConnections) source : null;
        }
    };
    StorageServerConnectionQueryParametersBase params = new StorageServerConnectionQueryParametersBase(id);
    params.setRefresh(isRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageServerConnectionById, params, aQuery);
}
#end_block

#method_before
public static void getDataCentersByStorageDomain(AsyncQuery aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StoragePool>) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), aQuery);
}
#method_after
public void getDataCentersByStorageDomain(AsyncQuery aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StoragePool>) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), aQuery);
}
#end_block

#method_before
public static void getDataCenterVersions(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Version>();
            } else {
                ArrayList<Version> list = (ArrayList<Version>) source;
                Collections.sort(list);
                return list;
            }
        }
    };
    IdQueryParameters tempVar = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAvailableClusterVersionsByStoragePool, tempVar, aQuery);
}
#method_after
public void getDataCenterVersions(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Version>();
            } else {
                ArrayList<Version> list = (ArrayList<Version>) source;
                Collections.sort(list);
                return list;
            }
        }
    };
    IdQueryParameters tempVar = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAvailableClusterVersionsByStoragePool, tempVar, aQuery);
}
#end_block

#method_before
public static void getDataCenterMaxNameLength(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StoragePoolNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getDataCenterMaxNameLength(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StoragePoolNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getClusterServerMemoryOverCommit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommitForServers, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getClusterServerMemoryOverCommit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommitForServers, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getClusterDesktopMemoryOverCommit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getClusterDesktopMemoryOverCommit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getAllowClusterWithVirtGlusterEnabled(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : Boolean.TRUE;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.AllowClusterWithVirtGlusterEnabled, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getAllowClusterWithVirtGlusterEnabled(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : Boolean.TRUE;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.AllowClusterWithVirtGlusterEnabled, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getCPUList(AsyncQuery aQuery, Version version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<ServerCpu>) source : new ArrayList<ServerCpu>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllServerCpuList, new GetAllServerCpuListParameters(version), aQuery);
}
#method_after
public void getCPUList(AsyncQuery aQuery, Version version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<ServerCpu>) source : new ArrayList<ServerCpu>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllServerCpuList, new GetAllServerCpuListParameters(version), aQuery);
}
#end_block

#method_before
public static void getPmTypeList(AsyncQuery aQuery, Version version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<String> list = new ArrayList<String>();
            if (source != null) {
                // $NON-NLS-1$
                String[] array = ((String) source).split("[,]", -1);
                for (String item : array) {
                    list.add(item);
                }
            }
            return list;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.VdsFenceType);
    tempVar.setVersion(version != null ? version.toString() : getDefaultConfigurationVersion());
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getPmTypeList(AsyncQuery aQuery, Version version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<String> list = new ArrayList<String>();
            if (source != null) {
                // $NON-NLS-1$
                String[] array = ((String) source).split("[,]", -1);
                for (String item : array) {
                    list.add(item);
                }
            }
            return list;
        }
    };
    GetConfigurationValueParameters param = new GetConfigurationValueParameters(ConfigurationValues.VdsFenceType);
    param.setVersion(version != null ? version.toString() : getDefaultConfigurationVersion());
    Frontend.getInstance().runQuery(VdcQueryType.GetFenceConfigurationValue, param, aQuery);
}
#end_block

#method_before
public static void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.getInstance().runQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#method_after
public void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.getInstance().runQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
public static void getNetworkList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworks, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getNetworkList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworks, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public static void getISOStorageDomainList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> allStorageDomains = (ArrayList<StorageDomain>) source;
                ArrayList<StorageDomain> isoStorageDomains = new ArrayList<StorageDomain>();
                for (StorageDomain storageDomain : allStorageDomains) {
                    if (storageDomain.getStorageDomainType() == StorageDomainType.ISO) {
                        isoStorageDomains.add(storageDomain);
                    }
                }
                return isoStorageDomains;
            }
            return new ArrayList<StorageDomain>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Storage:", SearchType.StorageDomain);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#method_after
public void getISOStorageDomainList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> allStorageDomains = (ArrayList<StorageDomain>) source;
                ArrayList<StorageDomain> isoStorageDomains = new ArrayList<StorageDomain>();
                for (StorageDomain storageDomain : allStorageDomains) {
                    if (storageDomain.getStorageDomainType() == StorageDomainType.ISO) {
                        isoStorageDomains.add(storageDomain);
                    }
                }
                return isoStorageDomains;
            }
            return new ArrayList<StorageDomain>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Storage:", SearchType.StorageDomain);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#end_block

#method_before
public static void getStorageDomainList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : new ArrayList<StorageDomain>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Storage:", SearchType.StorageDomain);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#method_after
public void getStorageDomainList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : new ArrayList<StorageDomain>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Storage:", SearchType.StorageDomain);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#end_block

#method_before
public static void getLocalStorageHost(AsyncQuery aQuery, String dataCenterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                for (IVdcQueryable item : (ArrayList<IVdcQueryable>) source) {
                    return item;
                }
            }
            return null;
        }
    };
    // $NON-NLS-1$
    SearchParameters sp = new SearchParameters("hosts: datacenter=" + dataCenterName, SearchType.VDS);
    Frontend.getInstance().runQuery(VdcQueryType.Search, sp, aQuery);
}
#method_after
public void getLocalStorageHost(AsyncQuery aQuery, String dataCenterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                for (IVdcQueryable item : (ArrayList<IVdcQueryable>) source) {
                    return item;
                }
            }
            return null;
        }
    };
    // $NON-NLS-1$
    SearchParameters sp = new SearchParameters("hosts: datacenter=" + dataCenterName, SearchType.VDS);
    Frontend.getInstance().runQuery(VdcQueryType.Search, sp, aQuery);
}
#end_block

#method_before
public static void getStorageDomainsByConnection(AsyncQuery aQuery, Guid storagePoolId, String connectionPath) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : null;
        }
    };
    GetStorageDomainsByConnectionParameters param = new GetStorageDomainsByConnectionParameters();
    param.setConnection(connectionPath);
    if (storagePoolId != null) {
        param.setStoragePoolId(storagePoolId);
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByConnection, param, aQuery);
}
#method_after
public void getStorageDomainsByConnection(AsyncQuery aQuery, Guid storagePoolId, String connectionPath) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : null;
        }
    };
    GetStorageDomainsByConnectionParameters param = new GetStorageDomainsByConnectionParameters();
    param.setConnection(connectionPath);
    if (storagePoolId != null) {
        param.setStoragePoolId(storagePoolId);
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByConnection, param, aQuery);
}
#end_block

#method_before
public static void getExistingStorageDomainList(AsyncQuery aQuery, Guid hostId, StorageDomainType domainType, StorageType storageType, String path) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetExistingStorageDomainList, new GetExistingStorageDomainListParameters(hostId, storageType, domainType, path), aQuery);
}
#method_after
public void getExistingStorageDomainList(AsyncQuery aQuery, Guid hostId, StorageDomainType domainType, StorageType storageType, String path) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetExistingStorageDomainList, new GetExistingStorageDomainListParameters(hostId, storageType, domainType, path), aQuery);
}
#end_block

#method_before
public static void getStorageDomainMaxNameLength(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StorageDomainNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getStorageDomainMaxNameLength(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StorageDomainNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void isStorageDomainNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                return storageDomains.isEmpty();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$
    SearchParameters(// $NON-NLS-1$
    "Storage: name=" + name, SearchType.StorageDomain), aQuery);
}
#method_after
public void isStorageDomainNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                return storageDomains.isEmpty();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$
    SearchParameters(// $NON-NLS-1$
    "Storage: name=" + name, SearchType.StorageDomain), aQuery);
}
#end_block

#method_before
public static void getNetworkConnectivityCheckTimeoutInSeconds(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 120;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.NetworkConnectivityCheckTimeoutInSeconds, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getNetworkConnectivityCheckTimeoutInSeconds(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 120;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.NetworkConnectivityCheckTimeoutInSeconds, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getMaxSpmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    // GetConfigFromCache(
    // new GetConfigurationValueParameters(ConfigurationValues.HighUtilizationForPowerSave,
    // getDefaultConfigurationVersion()),
    // aQuery);
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), 10);
}
#method_after
public void getMaxSpmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    // GetConfigFromCache(
    // new GetConfigurationValueParameters(ConfigurationValues.HighUtilizationForPowerSave,
    // getDefaultConfigurationVersion()),
    // aQuery);
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), 10);
}
#end_block

#method_before
public static void getDefaultSpmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    // GetConfigFromCache(
    // new GetConfigurationValueParameters(ConfigurationValues.HighUtilizationForPowerSave,
    // getDefaultConfigurationVersion()),
    // aQuery);
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), 5);
}
#method_after
public void getDefaultSpmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    // GetConfigFromCache(
    // new GetConfigurationValueParameters(ConfigurationValues.HighUtilizationForPowerSave,
    // getDefaultConfigurationVersion()),
    // aQuery);
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), 5);
}
#end_block

#method_before
public static void getDefaultPmProxyPreferences(AsyncQuery query) {
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.FenceProxyDefaultPreferences, getDefaultConfigurationVersion()), query);
}
#method_after
public void getDefaultPmProxyPreferences(AsyncQuery query) {
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.FenceProxyDefaultPreferences, getDefaultConfigurationVersion()), query);
}
#end_block

#method_before
public static void getRootTag(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                Tags tag = (Tags) source;
                Tags root = new Tags(tag.getdescription(), tag.getparent_id(), tag.getIsReadonly(), tag.gettag_id(), tag.gettag_name());
                if (tag.getChildren() != null) {
                    fillTagsRecursive(root, tag.getChildren());
                }
                return root;
            }
            return new Tags();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetRootTag, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getRootTag(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                Tags tag = (Tags) source;
                Tags root = new Tags(tag.getdescription(), tag.getparent_id(), tag.getIsReadonly(), tag.gettag_id(), tag.gettag_name());
                if (tag.getChildren() != null) {
                    fillTagsRecursive(root, tag.getChildren());
                }
                return root;
            }
            return new Tags();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetRootTag, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
private static void setAttachedTagsConverter(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Tags> ret = new ArrayList<Tags>();
                for (Tags tags : (ArrayList<Tags>) source) {
                    if (tags.gettype() == TagsType.GeneralTag) {
                        ret.add(tags);
                    }
                }
                return ret;
            }
            return new Tags();
        }
    };
}
#method_after
private void setAttachedTagsConverter(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Tags> ret = new ArrayList<Tags>();
                for (Tags tags : (ArrayList<Tags>) source) {
                    if (tags.gettype() == TagsType.GeneralTag) {
                        ret.add(tags);
                    }
                }
                return ret;
            }
            return new Tags();
        }
    };
}
#end_block

#method_before
public static void getAttachedTagsToVm(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVmId, new GetTagsByVmIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToVm(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVmId, new GetTagsByVmIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public static void getAttachedTagsToUser(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserId, new GetTagsByUserIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToUser(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserId, new GetTagsByUserIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public static void getAttachedTagsToUserGroup(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserGroupId, new GetTagsByUserGroupIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToUserGroup(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserGroupId, new GetTagsByUserGroupIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public static void getAttachedTagsToHost(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVdsId, new GetTagsByVdsIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToHost(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVdsId, new GetTagsByVdsIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public static void getoVirtISOsList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<RpmVersion>((ArrayList<RpmVersion>) source) : new ArrayList<RpmVersion>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetoVirtISOs, new VdsIdParametersBase(id), aQuery);
}
#method_after
public void getoVirtISOsList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<RpmVersion>((ArrayList<RpmVersion>) source) : new ArrayList<RpmVersion>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetoVirtISOs, new VdsIdParametersBase(id), aQuery);
}
#end_block

#method_before
public static void getLunsByVgId(AsyncQuery aQuery, String vgId, Guid vdsId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<LUNs>) source : new ArrayList<LUNs>();
        }
    };
    GetLunsByVgIdParameters params = new GetLunsByVgIdParameters(vgId, vdsId);
    Frontend.getInstance().runQuery(VdcQueryType.GetLunsByVgId, params, aQuery);
}
#method_after
public void getLunsByVgId(AsyncQuery aQuery, String vgId, Guid vdsId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<LUNs>) source : new ArrayList<LUNs>();
        }
    };
    GetLunsByVgIdParameters params = new GetLunsByVgIdParameters(vgId, vdsId);
    Frontend.getInstance().runQuery(VdcQueryType.GetLunsByVgId, params, aQuery);
}
#end_block

#method_before
public static void getAllTemplatesFromExportDomain(AsyncQuery aQuery, Guid storagePoolId, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new HashMap<VmTemplate, ArrayList<DiskImage>>();
        }
    };
    GetAllFromExportDomainQueryParameters getAllFromExportDomainQueryParamenters = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    Frontend.getInstance().runQuery(VdcQueryType.GetTemplatesFromExportDomain, getAllFromExportDomainQueryParamenters, aQuery);
}
#method_after
public void getAllTemplatesFromExportDomain(AsyncQuery aQuery, Guid storagePoolId, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new HashMap<VmTemplate, ArrayList<DiskImage>>();
        }
    };
    GetAllFromExportDomainQueryParameters getAllFromExportDomainQueryParamenters = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    Frontend.getInstance().runQuery(VdcQueryType.GetTemplatesFromExportDomain, getAllFromExportDomainQueryParamenters, aQuery);
}
#end_block

#method_before
public static void getUpHostListByCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((ArrayList<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    getUpHostListByCluster(aQuery, clusterName, null);
}
#method_after
public void getUpHostListByCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((ArrayList<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    getUpHostListByCluster(aQuery, clusterName, null);
}
#end_block

#method_before
public static void getUpHostListByCluster(AsyncQuery aQuery, String clusterName, Integer maxCount) {
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: cluster = " + clusterName + " and status = up", SearchType.VDS);
    if (maxCount != null) {
        searchParameters.setMaxCount(maxCount);
    }
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public void getUpHostListByCluster(AsyncQuery aQuery, String clusterName, Integer maxCount) {
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: cluster = " + clusterName + " and status = up", SearchType.VDS);
    if (maxCount != null) {
        searchParameters.setMaxCount(maxCount);
    }
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#end_block

#method_before
public static void getVmNicList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<VmNetworkInterface>((ArrayList<VmNetworkInterface>) source) : new ArrayList<VmNetworkInterface>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmNicList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<VmNetworkInterface>((ArrayList<VmNetworkInterface>) source) : new ArrayList<VmNetworkInterface>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getTemplateNicList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<VmNetworkInterface>((ArrayList<VmNetworkInterface>) source) : new ArrayList<VmNetworkInterface>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetTemplateInterfacesByTemplateId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getTemplateNicList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<VmNetworkInterface>((ArrayList<VmNetworkInterface>) source) : new ArrayList<VmNetworkInterface>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetTemplateInterfacesByTemplateId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getVmSnapshotList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Snapshot>) source : new ArrayList<Snapshot>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmSnapshotsByVmId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmSnapshotList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Snapshot>) source : new ArrayList<Snapshot>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmSnapshotsByVmId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getVmsRunningOnOrMigratingToVds(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VM>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmsRunningOnOrMigratingToVds, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmsRunningOnOrMigratingToVds(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VM>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmsRunningOnOrMigratingToVds, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getVmDiskList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Disk> list = new ArrayList<Disk>();
            if (source != null) {
                Iterable listEnumerable = (Iterable) source;
                Iterator listIterator = listEnumerable.iterator();
                while (listIterator.hasNext()) {
                    list.add((Disk) listIterator.next());
                }
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmDiskList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Disk> list = new ArrayList<Disk>();
            if (source != null) {
                Iterable listEnumerable = (Iterable) source;
                Iterator listIterator = listEnumerable.iterator();
                while (listIterator.hasNext()) {
                    list.add((Disk) listIterator.next());
                }
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getVmList(AsyncQuery aQuery, String poolName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VM> vms = Linq.<VM>cast((ArrayList<IVdcQueryable>) source);
            return vms;
        }
    };
    // $NON-NLS-1$
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("Vms: pool=" + poolName, SearchType.VM), aQuery);
}
#method_after
public void getVmList(AsyncQuery aQuery, String poolName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VM> vms = Linq.<VM>cast((ArrayList<IVdcQueryable>) source);
            return vms;
        }
    };
    // $NON-NLS-1$
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("Vms: pool=" + poolName, SearchType.VM), aQuery);
}
#end_block

#method_before
public static void getVmListByClusterName(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VM> vms = Linq.<VM>cast((ArrayList<IVdcQueryable>) source);
            return vms;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("Vms: cluster=" + clusterName, SearchType.VM), // $NON-NLS-1$
    aQuery);
}
#method_after
public void getVmListByClusterName(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VM> vms = Linq.<VM>cast((ArrayList<IVdcQueryable>) source);
            return vms;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("Vms: cluster=" + clusterName, SearchType.VM), // $NON-NLS-1$
    aQuery);
}
#end_block

#method_before
public static void getDiskList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<DiskImage>) source : new ArrayList<DiskImage>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Disks:", SearchType.Disk);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#method_after
public void getDiskList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<DiskImage>) source : new ArrayList<DiskImage>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Disks:", SearchType.Disk);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#end_block

#method_before
public static void getNextAvailableDiskAliasNameByVMId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNextAvailableDiskAliasNameByVMId, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getNextAvailableDiskAliasNameByVMId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNextAvailableDiskAliasNameByVMId, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void isPoolNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !(Boolean) source;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmPoolWithSameNameExists, new NameQueryParameters(name), aQuery);
}
#method_after
public void isPoolNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !(Boolean) source;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmPoolWithSameNameExists, new NameQueryParameters(name), aQuery);
}
#end_block

#method_before
public static void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId).withoutRefresh(), aQuery);
}
#method_after
public void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void getAllAttachableDisks(AsyncQuery aQuery, Guid storagePoolId, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Disk>) source : new ArrayList<Disk>();
        }
    };
    GetAllAttachableDisks params = new GetAllAttachableDisks(storagePoolId);
    params.setVmId(vmId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllAttachableDisks, params, aQuery);
}
#method_after
public void getAllAttachableDisks(AsyncQuery aQuery, Guid storagePoolId, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Disk>) source : new ArrayList<Disk>();
        }
    };
    GetAllAttachableDisks params = new GetAllAttachableDisks(storagePoolId);
    params.setVmId(vmId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllAttachableDisks, params, aQuery);
}
#end_block

#method_before
public static void getPermittedStorageDomainsByStoragePoolId(AsyncQuery aQuery, Guid dataCenterId, ActionGroup actionGroup) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new java.util.ArrayList<StorageDomain>();
            }
            return source;
        }
    };
    GetPermittedStorageDomainsByStoragePoolIdParameters params = new GetPermittedStorageDomainsByStoragePoolIdParameters();
    params.setStoragePoolId(dataCenterId);
    params.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, params, aQuery);
}
#method_after
public void getPermittedStorageDomainsByStoragePoolId(AsyncQuery aQuery, Guid dataCenterId, ActionGroup actionGroup) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new java.util.ArrayList<StorageDomain>();
            }
            return source;
        }
    };
    GetPermittedStorageDomainsByStoragePoolIdParameters params = new GetPermittedStorageDomainsByStoragePoolIdParameters();
    params.setStoragePoolId(dataCenterId);
    params.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, params, aQuery);
}
#end_block

#method_before
public static void getAllDataCenterNetworks(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworksByDataCenterId, params, aQuery);
}
#method_after
public void getAllDataCenterNetworks(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworksByDataCenterId, params, aQuery);
}
#end_block

#method_before
public static void getStorageConnectionsByDataCenterIdAndStorageType(AsyncQuery aQuery, Guid storagePoolId, StorageType storageType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    GetConnectionsByDataCenterAndStorageTypeParameters params = new GetConnectionsByDataCenterAndStorageTypeParameters(storagePoolId, storageType);
    Frontend.getInstance().runQuery(VdcQueryType.GetConnectionsByDataCenterAndStorageType, params, aQuery);
}
#method_after
public void getStorageConnectionsByDataCenterIdAndStorageType(AsyncQuery aQuery, Guid storagePoolId, StorageType storageType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    GetConnectionsByDataCenterAndStorageTypeParameters params = new GetConnectionsByDataCenterAndStorageTypeParameters(storagePoolId, storageType);
    Frontend.getInstance().runQuery(VdcQueryType.GetConnectionsByDataCenterAndStorageType, params, aQuery);
}
#end_block

#method_before
public static void getRedirectServletReportsPage(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.RedirectServletReportsPage, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getRedirectServletReportsPage(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.RedirectServletReportsPage, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, new VdcQueryParametersBase().withoutRefresh(), aQuery);
    }
}
#method_after
public void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, new VdcQueryParametersBase().withoutRefresh(), aQuery);
    }
}
#end_block

#method_before
private static boolean isCommandCompatible(VdcActionType vdcActionType, Version cluster, Version dc) {
    if (cachedCommandsCompatibilityVersions == null || cluster == null || dc == null) {
        return false;
    }
    CommandVersionsInfo commandVersionsInfo = cachedCommandsCompatibilityVersions.get(vdcActionType);
    if (commandVersionsInfo == null) {
        return false;
    }
    Version clusterCompatibility = commandVersionsInfo.getClusterVersion();
    Version dcCompatibility = commandVersionsInfo.getStoragePoolVersion();
    return (clusterCompatibility.compareTo(cluster) <= 0) && (dcCompatibility.compareTo(dc) <= 0);
}
#method_after
private boolean isCommandCompatible(VdcActionType vdcActionType, Version cluster, Version dc) {
    if (cachedCommandsCompatibilityVersions == null || cluster == null || dc == null) {
        return false;
    }
    CommandVersionsInfo commandVersionsInfo = cachedCommandsCompatibilityVersions.get(vdcActionType);
    if (commandVersionsInfo == null) {
        return false;
    }
    Version clusterCompatibility = commandVersionsInfo.getClusterVersion();
    Version dcCompatibility = commandVersionsInfo.getStoragePoolVersion();
    return (clusterCompatibility.compareTo(cluster) <= 0) && (dcCompatibility.compareTo(dc) <= 0);
}
#end_block

#method_before
public static CommandVersionsInfo getCommandVersionsInfo(VdcActionType vdcActionType) {
    if (cachedCommandsCompatibilityVersions == null) {
        return null;
    }
    return cachedCommandsCompatibilityVersions.get(vdcActionType);
}
#method_after
public CommandVersionsInfo getCommandVersionsInfo(VdcActionType vdcActionType) {
    if (cachedCommandsCompatibilityVersions == null) {
        return null;
    }
    return cachedCommandsCompatibilityVersions.get(vdcActionType);
}
#end_block

#method_before
public static void getManagementNetworkName(AsyncQuery aQuery) {
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.ManagementNetwork, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getManagementNetworkName(AsyncQuery aQuery) {
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.ManagementNetwork, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
private static void cacheConfigValues(AsyncQuery aQuery) {
    getDefaultConfigurationVersion();
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object returnValue, AsyncQuery _asyncQuery) {
            if (returnValue != null) {
                cachedConfigValuesPreConvert.putAll((HashMap<KeyValuePairCompat<ConfigurationValues, String>, Object>) returnValue);
            }
            return cachedConfigValuesPreConvert;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetConfigurationValues, new VdcQueryParametersBase(), aQuery);
}
#method_after
private void cacheConfigValues(AsyncQuery aQuery) {
    getDefaultConfigurationVersion();
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object returnValue, AsyncQuery _asyncQuery) {
            if (returnValue != null) {
                cachedConfigValuesPreConvert.putAll((HashMap<KeyValuePairCompat<ConfigurationValues, String>, Object>) returnValue);
            }
            return cachedConfigValuesPreConvert;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetConfigurationValues, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static Object getConfigValuePreConverted(ConfigurationValues configValue, String version) {
    KeyValuePairCompat<ConfigurationValues, String> key = new KeyValuePairCompat<ConfigurationValues, String>(configValue, version);
    return cachedConfigValuesPreConvert.get(key);
}
#method_after
public Object getConfigValuePreConverted(ConfigurationValues configValue, String version) {
    KeyValuePairCompat<ConfigurationValues, String> key = new KeyValuePairCompat<ConfigurationValues, String>(configValue, version);
    return cachedConfigValuesPreConvert.get(key);
}
#end_block

#method_before
public static Object getConfigValuePreConverted(ConfigurationValues configValue) {
    KeyValuePairCompat<ConfigurationValues, String> key = new KeyValuePairCompat<ConfigurationValues, String>(configValue, getDefaultConfigurationVersion());
    return cachedConfigValuesPreConvert.get(key);
}
#method_after
public Object getConfigValuePreConverted(ConfigurationValues configValue) {
    KeyValuePairCompat<ConfigurationValues, String> key = new KeyValuePairCompat<ConfigurationValues, String>(configValue, getDefaultConfigurationVersion());
    return cachedConfigValuesPreConvert.get(key);
}
#end_block

#method_before
public static Object getConfigValue(ConfigurationValues configValue, String version, IAsyncConverter converter) {
    if (converter == null) {
        return null;
    }
    KeyValuePairCompat<ConfigurationValues, String> key = new KeyValuePairCompat<ConfigurationValues, String>(configValue, version);
    return converter.Convert(cachedConfigValuesPreConvert.get(key), null);
}
#method_after
public Object getConfigValue(ConfigurationValues configValue, String version, IAsyncConverter converter) {
    if (converter == null) {
        return null;
    }
    KeyValuePairCompat<ConfigurationValues, String> key = new KeyValuePairCompat<ConfigurationValues, String>(configValue, version);
    return converter.Convert(cachedConfigValuesPreConvert.get(key), null);
}
#end_block

#method_before
public static void getConfigFromCache(GetConfigurationValueParameters parameters, AsyncQuery aQuery) {
    // cache key
    final KeyValuePairCompat<ConfigurationValues, String> config_key = new KeyValuePairCompat<ConfigurationValues, String>(parameters.getConfigValue(), parameters.getVersion());
    Object returnValue = null;
    if (cachedConfigValues.containsKey(config_key)) {
        // cache hit
        returnValue = cachedConfigValues.get(config_key);
    } else // and call asyncCallback's onSuccess
    if (cachedConfigValuesPreConvert.containsKey(config_key)) {
        returnValue = cachedConfigValuesPreConvert.get(config_key);
        // run converter
        if (aQuery.converterCallback != null) {
            returnValue = aQuery.converterCallback.Convert(returnValue, aQuery);
        }
        if (returnValue != null) {
            cachedConfigValues.put(config_key, returnValue);
        }
    }
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), returnValue);
}
#method_after
public void getConfigFromCache(GetConfigurationValueParameters parameters, AsyncQuery aQuery) {
    // cache key
    final KeyValuePairCompat<ConfigurationValues, String> config_key = new KeyValuePairCompat<ConfigurationValues, String>(parameters.getConfigValue(), parameters.getVersion());
    Object returnValue = null;
    if (cachedConfigValues.containsKey(config_key)) {
        // cache hit
        returnValue = cachedConfigValues.get(config_key);
    } else // and call asyncCallback's onSuccess
    if (cachedConfigValuesPreConvert.containsKey(config_key)) {
        returnValue = cachedConfigValuesPreConvert.get(config_key);
        // run converter
        if (aQuery.converterCallback != null) {
            returnValue = aQuery.converterCallback.Convert(returnValue, aQuery);
        }
        if (returnValue != null) {
            cachedConfigValues.put(config_key, returnValue);
        }
    }
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), returnValue);
}
#end_block

#method_before
public static void getConfigFromCache(ConfigurationValues configValue, String version, AsyncQuery aQuery) {
    GetConfigurationValueParameters parameters = new GetConfigurationValueParameters(configValue, version);
    getConfigFromCache(parameters, aQuery);
}
#method_after
public void getConfigFromCache(ConfigurationValues configValue, String version, AsyncQuery aQuery) {
    GetConfigurationValueParameters parameters = new GetConfigurationValueParameters(configValue, version);
    getConfigFromCache(parameters, aQuery);
}
#end_block

#method_before
public static ArrayList<QuotaEnforcementTypeEnum> getQuotaEnforcmentTypes() {
    return new ArrayList<QuotaEnforcementTypeEnum>(Arrays.asList(new QuotaEnforcementTypeEnum[] { QuotaEnforcementTypeEnum.DISABLED, QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT, QuotaEnforcementTypeEnum.HARD_ENFORCEMENT }));
}
#method_after
public ArrayList<QuotaEnforcementTypeEnum> getQuotaEnforcmentTypes() {
    return new ArrayList<QuotaEnforcementTypeEnum>(Arrays.asList(new QuotaEnforcementTypeEnum[] { QuotaEnforcementTypeEnum.DISABLED, QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT, QuotaEnforcementTypeEnum.HARD_ENFORCEMENT }));
}
#end_block

#method_before
public static void clearCache() {
    cachedConfigValues.clear();
}
#method_after
public void clearCache() {
    cachedConfigValues.clear();
}
#end_block

#method_before
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = returnValue.getReturnValue();
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (ObjectUtils.objectsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (ObjectUtils.objectsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#method_after
public void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = returnValue.getReturnValue();
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (ObjectUtils.objectsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (ObjectUtils.objectsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#end_block

#method_before
private static void getVlanParentInterface(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVlanParent, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#method_after
private void getVlanParentInterface(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVlanParent, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#end_block

#method_before
private static void interfaceHasSiblingVlanInterfaces(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VdsNetworkInterface> siblingVlanInterfaces = (ArrayList<VdsNetworkInterface>) source;
            return !siblingVlanInterfaces.isEmpty();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllSiblingVlanInterfaces, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#method_after
private void interfaceHasSiblingVlanInterfaces(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VdsNetworkInterface> siblingVlanInterfaces = (ArrayList<VdsNetworkInterface>) source;
            return !siblingVlanInterfaces.isEmpty();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllSiblingVlanInterfaces, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#end_block

#method_before
public static void getExternalProviderHostList(AsyncQuery aQuery, Guid providerId, boolean filterOutExistingHosts, String searchFilter) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDS>();
            }
            return source;
        }
    };
    GetHostListFromExternalProviderParameters params = new GetHostListFromExternalProviderParameters();
    params.setFilterOutExistingHosts(filterOutExistingHosts);
    params.setProviderId(providerId);
    params.setSearchFilter(searchFilter);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostListFromExternalProvider, params, aQuery);
}
#method_after
public void getExternalProviderHostList(AsyncQuery aQuery, Guid providerId, boolean filterOutExistingHosts, String searchFilter) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDS>();
            }
            return source;
        }
    };
    GetHostListFromExternalProviderParameters params = new GetHostListFromExternalProviderParameters();
    params.setFilterOutExistingHosts(filterOutExistingHosts);
    params.setProviderId(providerId);
    params.setSearchFilter(searchFilter);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostListFromExternalProvider, params, aQuery);
}
#end_block

#method_before
public static void getExternalProviderDiscoveredHostList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<ExternalDiscoveredHost>();
            }
            return source;
        }
    };
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetDiscoveredHostListFromExternalProvider, params, aQuery);
}
#method_after
public void getExternalProviderDiscoveredHostList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<ExternalDiscoveredHost>();
            }
            return source;
        }
    };
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetDiscoveredHostListFromExternalProvider, params, aQuery);
}
#end_block

#method_before
public static void getExternalProviderHostGroupList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<ExternalHostGroup>();
            }
            return source;
        }
    };
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostGroupsFromExternalProvider, params, aQuery);
}
#method_after
public void getExternalProviderHostGroupList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<ExternalHostGroup>();
            }
            return source;
        }
    };
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostGroupsFromExternalProvider, params, aQuery);
}
#end_block

#method_before
public static void getExternalProviderComputeResourceList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<ExternalComputeResource>();
            }
            return source;
        }
    };
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetComputeResourceFromExternalProvider, params, aQuery);
}
#method_after
public void getExternalProviderComputeResourceList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<ExternalComputeResource>();
            }
            return source;
        }
    };
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetComputeResourceFromExternalProvider, params, aQuery);
}
#end_block

#method_before
public static void getAllProviders(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            Collections.sort((List<Provider>) source, new NameableComparator());
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), aQuery);
}
#method_after
public void getAllProviders(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            Collections.sort((List<Provider>) source, new NameableComparator());
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), aQuery);
}
#end_block

#method_before
public static void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new IAsyncConverter<List<Provider>>() {

        @Override
        public List<Provider> Convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<Provider>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Collection<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#method_after
public void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new IAsyncConverter<List<Provider>>() {

        @Override
        public List<Provider> Convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<Provider>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Collection<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#end_block

#method_before
public static void getAllNetworkProviders(AsyncQuery query) {
    getAllProvidersByProvidedEntity(query, VdcObjectType.Network);
}
#method_after
public void getAllNetworkProviders(AsyncQuery query) {
    getAllProvidersByProvidedEntity(query, VdcObjectType.Network);
}
#end_block

#method_before
public static void getAllProvidersByType(AsyncQuery aQuery, ProviderType providerType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(providerType), aQuery);
}
#method_after
public void getAllProvidersByType(AsyncQuery aQuery, ProviderType providerType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(providerType), aQuery);
}
#end_block

#method_before
public static void getProviderCertificateChain(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChain, new ProviderQueryParameters(provider), aQuery);
}
#method_after
public void getProviderCertificateChain(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChain, new ProviderQueryParameters(provider), aQuery);
}
#end_block

#method_before
private static void getAllChildVlanInterfaces(Guid vdsID, List<VdsNetworkInterface> ifaces, IFrontendMultipleQueryAsyncCallback callback) {
    ArrayList<VdcQueryParametersBase> parametersList = new ArrayList<VdcQueryParametersBase>();
    ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
    for (final VdsNetworkInterface iface : ifaces) {
        queryTypeList.add(VdcQueryType.GetAllChildVlanInterfaces);
        parametersList.add(new InterfaceAndIdQueryParameters(vdsID, iface));
    }
    Frontend.getInstance().runMultipleQueries(queryTypeList, parametersList, callback);
}
#method_after
private void getAllChildVlanInterfaces(Guid vdsID, List<VdsNetworkInterface> ifaces, IFrontendMultipleQueryAsyncCallback callback) {
    ArrayList<VdcQueryParametersBase> parametersList = new ArrayList<VdcQueryParametersBase>();
    ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
    for (final VdsNetworkInterface iface : ifaces) {
        queryTypeList.add(VdcQueryType.GetAllChildVlanInterfaces);
        parametersList.add(new InterfaceAndIdQueryParameters(vdsID, iface));
    }
    Frontend.getInstance().runMultipleQueries(queryTypeList, parametersList, callback);
}
#end_block

#method_before
public static void isSupportBridgesReportByVDSM(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Boolean) source).booleanValue() : true;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.SupportBridgesReportByVDSM);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void isSupportBridgesReportByVDSM(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Boolean) source).booleanValue() : true;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.SupportBridgesReportByVDSM);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public static void fillTagsRecursive(Tags tagToFill, List<Tags> children) {
    ArrayList<Tags> list = new ArrayList<Tags>();
    for (Tags tag : children) {
        // tags child = new tags(tag.description, tag.parent_id, tag.IsReadonly, tag.tag_id, tag.tag_name);
        if (tag.gettype() == TagsType.GeneralTag) {
            list.add(tag);
            if (tag.getChildren() != null) {
                fillTagsRecursive(tag, tag.getChildren());
            }
        }
    }
    tagToFill.setChildren(list);
}
#method_after
public void fillTagsRecursive(Tags tagToFill, List<Tags> children) {
    ArrayList<Tags> list = new ArrayList<Tags>();
    for (Tags tag : children) {
        // tags child = new tags(tag.description, tag.parent_id, tag.IsReadonly, tag.tag_id, tag.tag_name);
        if (tag.gettype() == TagsType.GeneralTag) {
            list.add(tag);
            if (tag.getChildren() != null) {
                fillTagsRecursive(tag, tag.getChildren());
            }
        }
    }
    tagToFill.setChildren(list);
}
#end_block

#method_before
public static ArrayList<EventNotificationEntity> getEventNotificationTypeList() {
    ArrayList<EventNotificationEntity> ret = new ArrayList<EventNotificationEntity>();
    // TODO: We can translate it here too
    for (EventNotificationEntity entity : EventNotificationEntity.values()) {
        if (entity != EventNotificationEntity.UNKNOWN) {
            ret.add(entity);
        }
    }
    return ret;
}
#method_after
public ArrayList<EventNotificationEntity> getEventNotificationTypeList() {
    ArrayList<EventNotificationEntity> ret = new ArrayList<EventNotificationEntity>();
    // TODO: We can translate it here too
    for (EventNotificationEntity entity : EventNotificationEntity.values()) {
        if (entity != EventNotificationEntity.UNKNOWN) {
            ret.add(entity);
        }
    }
    return ret;
}
#end_block

#method_before
public static Map<EventNotificationEntity, HashSet<AuditLogType>> getAvailableNotificationEvents() {
    return VdcEventNotificationUtils.getNotificationEvents();
}
#method_after
public Map<EventNotificationEntity, HashSet<AuditLogType>> getAvailableNotificationEvents() {
    return VdcEventNotificationUtils.getNotificationEvents();
}
#end_block

#method_before
public static void getNicTypeList(final int osId, Version version, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> nics = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<VmInterfaceType> interfaceTypes = new ArrayList<VmInterfaceType>();
            for (String nic : nics) {
                try {
                    interfaceTypes.add(VmInterfaceType.valueOf(nic));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNetworkDevices, osId, version), asyncQuery);
}
#method_after
public void getNicTypeList(final int osId, Version version, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> nics = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<VmInterfaceType> interfaceTypes = new ArrayList<VmInterfaceType>();
            for (String nic : nics) {
                try {
                    interfaceTypes.add(VmInterfaceType.valueOf(nic));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNetworkDevices, osId, version), asyncQuery);
}
#end_block

#method_before
public static VmInterfaceType getDefaultNicType(Collection<VmInterfaceType> items) {
    if (items == null || items.isEmpty()) {
        return null;
    } else if (items.contains(VmInterfaceType.pv)) {
        return VmInterfaceType.pv;
    } else {
        return items.iterator().next();
    }
}
#method_after
public VmInterfaceType getDefaultNicType(Collection<VmInterfaceType> items) {
    if (items == null || items.isEmpty()) {
        return null;
    } else if (items.contains(VmInterfaceType.pv)) {
        return VmInterfaceType.pv;
    } else {
        return items.iterator().next();
    }
}
#end_block

#method_before
public static boolean isVersionMatchStorageType(Version version, boolean isLocalType) {
    return version.compareTo(new Version(3, 0)) >= 0;
}
#method_after
public boolean isVersionMatchStorageType(Version version, boolean isLocalType) {
    return version.compareTo(new Version(3, 0)) >= 0;
}
#end_block

#method_before
public static int getClusterDefaultMemoryOverCommit() {
    return 100;
}
#method_after
public int getClusterDefaultMemoryOverCommit() {
    return 100;
}
#end_block

#method_before
public static boolean getClusterDefaultCountThreadsAsCores() {
    return false;
}
#method_after
public boolean getClusterDefaultCountThreadsAsCores() {
    return false;
}
#end_block

#method_before
public static ArrayList<VolumeType> getVolumeTypeList() {
    return new ArrayList<VolumeType>(Arrays.asList(new VolumeType[] { VolumeType.Preallocated, VolumeType.Sparse }));
}
#method_after
public ArrayList<VolumeType> getVolumeTypeList() {
    return new ArrayList<VolumeType>(Arrays.asList(new VolumeType[] { VolumeType.Preallocated, VolumeType.Sparse }));
}
#end_block

#method_before
public static ArrayList<StorageType> getStorageTypeList() {
    return new ArrayList<StorageType>(Arrays.asList(new StorageType[] { StorageType.ISCSI, StorageType.FCP }));
}
#method_after
public ArrayList<StorageType> getStorageTypeList() {
    return new ArrayList<StorageType>(Arrays.asList(new StorageType[] { StorageType.ISCSI, StorageType.FCP }));
}
#end_block

#method_before
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#method_after
public void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#end_block

#method_before
public static ArrayList<DiskInterface> getDiskInterfaceList() {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI, DiskInterface.SPAPR_VSCSI }));
    return diskInterfaces;
}
#method_after
public ArrayList<DiskInterface> getDiskInterfaceList() {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI, DiskInterface.SPAPR_VSCSI }));
    return diskInterfaces;
}
#end_block

#method_before
public static String getNewNicName(Collection<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#method_after
public String getNewNicName(Collection<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#end_block

#method_before
public static String getComplexValueFromSpiceRedKeysResource(String complexValue) {
    if (StringHelper.isNullOrEmpty(complexValue)) {
        // $NON-NLS-1$
        return "";
    }
    ArrayList<String> values = new ArrayList<String>();
    for (String s : complexValue.split("[+]", -1)) {
        // $NON-NLS-1$
        try {
            String value = SpiceConstantsManager.getInstance().getSpiceRedKeys().getString(// $NON-NLS-1$ //$NON-NLS-2$
            s.replaceAll("-", "_"));
            values.add(value);
        } catch (MissingResourceException e) {
            values.add(s);
        }
    }
    // $NON-NLS-1$
    return StringHelper.join("+", values.toArray(new String[] {}));
}
#method_after
public String getComplexValueFromSpiceRedKeysResource(String complexValue) {
    if (StringHelper.isNullOrEmpty(complexValue)) {
        // $NON-NLS-1$
        return "";
    }
    ArrayList<String> values = new ArrayList<String>();
    for (String s : complexValue.split("[+]", -1)) {
        // $NON-NLS-1$
        try {
            String value = SpiceConstantsManager.getInstance().getSpiceRedKeys().getString(// $NON-NLS-1$ //$NON-NLS-2$
            s.replaceAll("-", "_"));
            values.add(value);
        } catch (MissingResourceException e) {
            values.add(s);
        }
    }
    // $NON-NLS-1$
    return StringHelper.join("+", values.toArray(new String[] {}));
}
#end_block

#method_before
public static Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof DbGroup) {
        return ((DbGroup) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    }
    return Guid.Empty;
}
#method_after
public Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof DbGroup) {
        return ((DbGroup) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    }
    return Guid.Empty;
}
#end_block

#method_before
public static boolean isWindowsOsType(Integer osType) {
    // can be null as a consequence of setItems on ListModel
    if (osType == null) {
        return false;
    }
    return windowsOsIds.contains(osType);
}
#method_after
public boolean isWindowsOsType(Integer osType) {
    // can be null as a consequence of setItems on ListModel
    if (osType == null) {
        return false;
    }
    return windowsOsIds.contains(osType);
}
#end_block

#method_before
public static boolean isLinuxOsType(Integer osId) {
    // can be null as a consequence of setItems on ListModel
    if (osId == null) {
        return false;
    }
    return linuxOsIds.contains(osId);
}
#method_after
public boolean isLinuxOsType(Integer osId) {
    // can be null as a consequence of setItems on ListModel
    if (osId == null) {
        return false;
    }
    return linuxOsIds.contains(osId);
}
#end_block

#method_before
public static void initWindowsOsTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            windowsOsIds = (ArrayList<Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetWindowsOss), callback);
}
#method_after
public void initWindowsOsTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            windowsOsIds = (ArrayList<Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetWindowsOss), callback);
}
#end_block

#method_before
public static void initLinuxOsTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            linuxOsIds = (ArrayList<Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetLinuxOss), callback);
}
#method_after
public void initLinuxOsTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            linuxOsIds = (ArrayList<Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetLinuxOss), callback);
}
#end_block

#method_before
public static void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#method_after
public void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#end_block

#method_before
public static void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#method_after
public void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#end_block

#method_before
private static void initOsIds() {
    osIds = new ArrayList<Integer>(osNames.keySet());
    Collections.sort(osIds, new Comparator<Integer>() {

        @Override
        public int compare(Integer o1, Integer o2) {
            return osNames.get(o1).compareTo(osNames.get(o2));
        }
    });
}
#method_after
private void initOsIds() {
    osIds = new ArrayList<Integer>(osNames.keySet());
    Collections.sort(osIds, new Comparator<Integer>() {

        @Override
        public int compare(Integer o1, Integer o2) {
            return osNames.get(o1).compareTo(osNames.get(o2));
        }
    });
}
#end_block

#method_before
public static void initOsArchitecture() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osArchitectures = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsArchitectures), callback);
}
#method_after
public void initOsArchitecture() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osArchitectures = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsArchitectures), callback);
}
#end_block

#method_before
public static boolean osNameExists(Integer osId) {
    return osNames.keySet().contains(osId);
}
#method_after
public boolean osNameExists(Integer osId) {
    return osNames.keySet().contains(osId);
}
#end_block

#method_before
public static String getOsName(Integer osId) {
    // can be null as a consequence of setItems on ListModel
    if (osId == null) {
        return "";
    }
    return osNames.get(osId);
}
#method_after
public String getOsName(Integer osId) {
    // can be null as a consequence of setItems on ListModel
    if (osId == null) {
        return "";
    }
    return osNames.get(osId);
}
#end_block

#method_before
public static boolean hasSpiceSupport(int osId, Version version) {
    return getDisplayTypes(osId, version).contains(DisplayType.qxl);
}
#method_after
public boolean hasSpiceSupport(int osId, Version version) {
    return getDisplayTypes(osId, version).contains(DisplayType.qxl);
}
#end_block

#method_before
public static List<DisplayType> getDisplayTypes(int osId, Version version) {
    return displayTypes.get(osId).get(version);
}
#method_after
public List<DisplayType> getDisplayTypes(int osId, Version version) {
    return displayTypes.get(osId).get(version);
}
#end_block

#method_before
private static void initDisplayTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            displayTypes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), callback);
}
#method_after
private void initDisplayTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            displayTypes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), callback);
}
#end_block

#method_before
public static List<Integer> getOsIds(ArchitectureType architectureType) {
    List<Integer> osIds = new ArrayList<Integer>();
    for (Entry<Integer, ArchitectureType> entry : osArchitectures.entrySet()) {
        if (entry.getValue() == architectureType) {
            osIds.add(entry.getKey());
        }
    }
    Collections.sort(osIds, new Comparator<Integer>() {

        @Override
        public int compare(Integer o1, Integer o2) {
            return osNames.get(o1).compareTo(osNames.get(o2));
        }
    });
    return osIds;
}
#method_after
public List<Integer> getOsIds(ArchitectureType architectureType) {
    List<Integer> osIds = new ArrayList<Integer>();
    for (Entry<Integer, ArchitectureType> entry : osArchitectures.entrySet()) {
        if (entry.getValue() == architectureType) {
            osIds.add(entry.getKey());
        }
    }
    Collections.sort(osIds, new Comparator<Integer>() {

        @Override
        public int compare(Integer o1, Integer o2) {
            return osNames.get(o1).compareTo(osNames.get(o2));
        }
    });
    return osIds;
}
#end_block

#method_before
public static void getOsMaxRam(int osId, Version version, AsyncQuery asyncQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetMaxOsRam, osId, version), asyncQuery);
}
#method_after
public void getOsMaxRam(int osId, Version version, AsyncQuery asyncQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetMaxOsRam, osId, version), asyncQuery);
}
#end_block

#method_before
public static void getVmWatchdogTypes(int osId, Version version, AsyncQuery asyncQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetVmWatchdogTypes, osId, version), asyncQuery);
}
#method_after
public void getVmWatchdogTypes(int osId, Version version, AsyncQuery asyncQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetVmWatchdogTypes, osId, version), asyncQuery);
}
#end_block

#method_before
public static ArrayList<Map.Entry<String, EntityModel<String>>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel<String>>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel<String>>> list = new ArrayList<Map.Entry<String, EntityModel<String>>>();
    EntityModel<String> entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel<String>>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("custom", entityModel));
    return list;
}
#method_after
public ArrayList<Map.Entry<String, EntityModel<String>>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel<String>>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel<String>>> list = new ArrayList<Map.Entry<String, EntityModel<String>>>();
    EntityModel<String> entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel<String>>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("custom", entityModel));
    return list;
}
#end_block

#method_before
public static String getDefaultBondingOption() {
    // $NON-NLS-1$
    return "mode=802.3ad miimon=150";
}
#method_after
public String getDefaultBondingOption() {
    // $NON-NLS-1$
    return "mode=802.3ad miimon=150";
}
#end_block

#method_before
public static int getMaxVmPriority() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.VmPriorityMaxValue, getDefaultConfigurationVersion());
}
#method_after
public int getMaxVmPriority() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.VmPriorityMaxValue, getDefaultConfigurationVersion());
}
#end_block

#method_before
public static int roundPriority(int priority) {
    int max = getMaxVmPriority();
    int medium = max / 2;
    int[] levels = new int[] { 1, medium, max };
    for (int i = 0; i < levels.length; i++) {
        int lengthToLess = levels[i] - priority;
        int lengthToMore = levels[i + 1] - priority;
        if (lengthToMore < 0) {
            continue;
        }
        return Math.abs(lengthToLess) < lengthToMore ? levels[i] : levels[i + 1];
    }
    return 0;
}
#method_after
public int roundPriority(int priority) {
    int max = getMaxVmPriority();
    int medium = max / 2;
    int[] levels = new int[] { 1, medium, max };
    for (int i = 0; i < levels.length; i++) {
        int lengthToLess = levels[i] - priority;
        int lengthToMore = levels[i + 1] - priority;
        if (lengthToMore < 0) {
            continue;
        }
        return Math.abs(lengthToLess) < lengthToMore ? levels[i] : levels[i + 1];
    }
    return 0;
}
#end_block

#method_before
public static void getVmGuestAgentInterfacesByVmId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VmGuestAgentInterface>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmGuestAgentInterfacesByVmId, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getVmGuestAgentInterfacesByVmId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VmGuestAgentInterface>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmGuestAgentInterfacesByVmId, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void getVnicProfilesByNetworkId(AsyncQuery aQuery, Guid networkId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VnicProfileView>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByNetworkId, new IdQueryParameters(networkId), aQuery);
}
#method_after
public void getVnicProfilesByNetworkId(AsyncQuery aQuery, Guid networkId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VnicProfileView>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByNetworkId, new IdQueryParameters(networkId), aQuery);
}
#end_block

#method_before
public static void getVnicProfilesByDcId(AsyncQuery aQuery, Guid dcId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return new ArrayList<VnicProfileView>();
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByDataCenterId, new IdQueryParameters(dcId), aQuery);
}
#method_after
public void getVnicProfilesByDcId(AsyncQuery aQuery, Guid dcId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return new ArrayList<VnicProfileView>();
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByDataCenterId, new IdQueryParameters(dcId), aQuery);
}
#end_block

#method_before
public static void getNumberOfActiveVmsInCluster(AsyncQuery aQuery, Guid clusterId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return Integer.valueOf(0);
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetNumberOfActiveVmsInVdsGroupByVdsGroupId, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getNumberOfActiveVmsInCluster(AsyncQuery aQuery, Guid clusterId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return Integer.valueOf(0);
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetNumberOfActiveVmsInVdsGroupByVdsGroupId, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
public static void getNumberOfVmsInCluster(AsyncQuery aQuery, Guid clusterId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetNumberOfVmsInVdsGroupByVdsGroupId, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getNumberOfVmsInCluster(AsyncQuery aQuery, Guid clusterId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetNumberOfVmsInVdsGroupByVdsGroupId, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
public static boolean isMixedStorageDomainsSupported(Version version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.MixedDomainTypesInDataCenter, version.toString());
}
#method_after
public boolean isMixedStorageDomainsSupported(Version version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.MixedDomainTypesInDataCenter, version.toString());
}
#end_block

#method_before
private static ArrayList<VDSGroup> getClusterByServiceList(ArrayList<VDSGroup> list, boolean supportsVirtService, boolean supportsGlusterService) {
    final ArrayList<VDSGroup> filteredList = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : list) {
        if ((supportsVirtService && cluster.supportsVirtService()) || (supportsGlusterService && cluster.supportsGlusterService())) {
            filteredList.add(cluster);
        }
    }
    // sort by cluster name
    Collections.sort(filteredList, new NameableComparator());
    return filteredList;
}
#method_after
private ArrayList<VDSGroup> getClusterByServiceList(ArrayList<VDSGroup> list, boolean supportsVirtService, boolean supportsGlusterService) {
    final ArrayList<VDSGroup> filteredList = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : list) {
        if ((supportsVirtService && cluster.supportsVirtService()) || (supportsGlusterService && cluster.supportsGlusterService())) {
            filteredList.add(cluster);
        }
    }
    // sort by cluster name
    Collections.sort(filteredList, new NameableComparator());
    return filteredList;
}
#end_block

#method_before
public static String priorityToString(int value) {
    int roundedPriority = AsyncDataProvider.roundPriority(value);
    if (roundedPriority == 1) {
        return ConstantsManager.getInstance().getConstants().vmLowPriority();
    } else if (roundedPriority == AsyncDataProvider.getMaxVmPriority() / 2) {
        return ConstantsManager.getInstance().getConstants().vmMediumPriority();
    } else if (roundedPriority == AsyncDataProvider.getMaxVmPriority()) {
        return ConstantsManager.getInstance().getConstants().vmHighPriority();
    } else {
        return ConstantsManager.getInstance().getConstants().vmUnknownPriority();
    }
}
#method_after
public String priorityToString(int value) {
    int roundedPriority = roundPriority(value);
    if (roundedPriority == 1) {
        return ConstantsManager.getInstance().getConstants().vmLowPriority();
    } else if (roundedPriority == getMaxVmPriority() / 2) {
        return ConstantsManager.getInstance().getConstants().vmMediumPriority();
    } else if (roundedPriority == getMaxVmPriority()) {
        return ConstantsManager.getInstance().getConstants().vmHighPriority();
    } else {
        return ConstantsManager.getInstance().getConstants().vmUnknownPriority();
    }
}
#end_block

#method_before
public static void getExternalNetworkMap(AsyncQuery aQuery, Guid providerId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new HashMap<Network, Set<Guid>>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllExternalNetworksOnProvider, new IdQueryParameters(providerId), aQuery);
}
#method_after
public void getExternalNetworkMap(AsyncQuery aQuery, Guid providerId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new HashMap<Network, Set<Guid>>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllExternalNetworksOnProvider, new IdQueryParameters(providerId), aQuery);
}
#end_block

#method_before
public static Integer getMaxVmNameLengthWin() {
    Integer maxVmNameLengthWindows = (Integer) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MaxVmNameLengthWindows);
    if (maxVmNameLengthWindows == null) {
        return 15;
    }
    return maxVmNameLengthWindows;
}
#method_after
public Integer getMaxVmNameLengthWin() {
    Integer maxVmNameLengthWindows = (Integer) getConfigValuePreConverted(ConfigurationValues.MaxVmNameLengthWindows);
    if (maxVmNameLengthWindows == null) {
        return 15;
    }
    return maxVmNameLengthWindows;
}
#end_block

#method_before
public static Integer getMaxVmNameLengthNonWin() {
    Integer maxVmNameLengthNonWindows = (Integer) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MaxVmNameLengthNonWindows);
    if (maxVmNameLengthNonWindows == null) {
        return 64;
    }
    return maxVmNameLengthNonWindows;
}
#method_after
public Integer getMaxVmNameLengthNonWin() {
    Integer maxVmNameLengthNonWindows = (Integer) getConfigValuePreConverted(ConfigurationValues.MaxVmNameLengthNonWindows);
    if (maxVmNameLengthNonWindows == null) {
        return 64;
    }
    return maxVmNameLengthNonWindows;
}
#end_block

#method_before
public static int getOptimizeSchedulerForSpeedPendingRequests() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.SpeedOptimizationSchedulingThreshold, getDefaultConfigurationVersion());
}
#method_after
public int getOptimizeSchedulerForSpeedPendingRequests() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.SpeedOptimizationSchedulingThreshold, getDefaultConfigurationVersion());
}
#end_block

#method_before
public static boolean getScheudulingAllowOverbookingSupported() {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.SchedulerAllowOverBooking, getDefaultConfigurationVersion());
}
#method_after
public boolean getScheudulingAllowOverbookingSupported() {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.SchedulerAllowOverBooking, getDefaultConfigurationVersion());
}
#end_block

#method_before
public static int getSchedulerAllowOverbookingPendingRequestsThreshold() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.SchedulerOverBookingThreshold, getDefaultConfigurationVersion());
}
#method_after
public int getSchedulerAllowOverbookingPendingRequestsThreshold() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.SchedulerOverBookingThreshold, getDefaultConfigurationVersion());
}
#end_block

#method_before
public static Integer getDefaultOs(ArchitectureType architectureType) {
    return defaultOSes.get(architectureType);
}
#method_after
public Integer getDefaultOs(ArchitectureType architectureType) {
    return defaultOSes.get(architectureType);
}
#end_block

#method_before
public static boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        // currently on VDSM side reboot is supported only when the guest agent is present and responsive so we need to check for that
        if (!isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion) || StringHelper.isNullOrEmpty(vm.getVmIp())) {
            return false;
        }
    }
    return true;
}
#method_after
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        // currently on VDSM side reboot is supported only when the guest agent is present and responsive so we need to check for that
        if (!isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion) || StringHelper.isNullOrEmpty(vm.getVmIp())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public static boolean isSerialNumberPolicySupported(String version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.SerialNumberPolicySupported, version);
}
#method_after
public boolean isSerialNumberPolicySupported(String version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.SerialNumberPolicySupported, version);
}
#end_block

#method_before
public static boolean isBootMenuSupported(String version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.BootMenuSupported, version);
}
#method_after
public boolean isBootMenuSupported(String version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.BootMenuSupported, version);
}
#end_block

#method_before
public static boolean isSpiceFileTransferToggleSupported(String version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.SpiceFileTransferToggleSupported, version);
}
#method_after
public boolean isSpiceFileTransferToggleSupported(String version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.SpiceFileTransferToggleSupported, version);
}
#end_block

#method_before
public static boolean isSpiceCopyPasteToggleSupported(String version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.SpiceCopyPasteToggleSupported, version);
}
#method_after
public boolean isSpiceCopyPasteToggleSupported(String version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.SpiceCopyPasteToggleSupported, version);
}
#end_block

#method_before
public static List<IStorageModel> getDataStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    NfsStorageModel nfsDataModel = new NfsStorageModel();
    models.add(nfsDataModel);
    PosixStorageModel posixDataModel = new PosixStorageModel();
    models.add(posixDataModel);
    GlusterStorageModel GlusterDataModel = new GlusterStorageModel();
    models.add(GlusterDataModel);
    IscsiStorageModel iscsiDataModel = new IscsiStorageModel();
    iscsiDataModel.setIsGrouppedByTarget(true);
    models.add(iscsiDataModel);
    FcpStorageModel fcpDataModel = new FcpStorageModel();
    models.add(fcpDataModel);
    LocalStorageModel localDataModel = new LocalStorageModel();
    models.add(localDataModel);
    for (IStorageModel model : models) {
        model.setRole(StorageDomainType.Data);
    }
    return models;
}
#method_after
public List<IStorageModel> getDataStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    models.addAll(getFileDataStorageModels());
    models.addAll(getBlockDataStorageModels());
    return models;
}
#end_block

#method_before
public static List<IStorageModel> getIsoStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    NfsStorageModel nfsIsoModel = new NfsStorageModel();
    models.add(nfsIsoModel);
    PosixStorageModel posixIsoModel = new PosixStorageModel();
    models.add(posixIsoModel);
    LocalStorageModel localIsoModel = new LocalStorageModel();
    models.add(localIsoModel);
    for (IStorageModel model : models) {
        model.setRole(StorageDomainType.ISO);
    }
    return models;
}
#method_after
public List<IStorageModel> getIsoStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    NfsStorageModel nfsIsoModel = new NfsStorageModel();
    models.add(nfsIsoModel);
    PosixStorageModel posixIsoModel = new PosixStorageModel();
    models.add(posixIsoModel);
    LocalStorageModel localIsoModel = new LocalStorageModel();
    models.add(localIsoModel);
    addTypeToStorageModels(StorageDomainType.ISO, models);
    return models;
}
#end_block

#method_before
private static void convertAAAProfilesResult(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            List<String> results = new ArrayList<String>();
            for (ProfileEntry profileEntry : source != null ? new ArrayList<ProfileEntry>((ArrayList<ProfileEntry>) source) : new ArrayList<ProfileEntry>()) {
                results.add(profileEntry.getProfile());
            }
            return results;
        }
    };
}
#method_after
private static void convertAAAProfilesResult(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            List<String> results = new ArrayList<String>();
            for (ProfileEntry profileEntry : (Collection<ProfileEntry>) source) {
                results.add(profileEntry.getProfile());
            }
            return results;
        }
    };
}
#end_block

#method_before
private List<DirectoryUser> searchDirectoryUsers() {
    // Parse the query:
    QueryData data = initQueryData(true);
    if (data == null) {
        return Collections.emptyList();
    }
    ExtensionProxy authz = EngineExtensionsManager.getInstance().getExtensionByName(data.getDomain());
    List<DirectoryUser> results = new ArrayList<>();
    for (String namespace : authz.getContext().<List<String>>get(Authz.ContextKeys.AVAILABLE_NAMESPACES)) {
        results.addAll(AuthzUtils.findPrincipalsByQuery(authz, namespace, data.getQuery()));
    }
    return results;
}
#method_after
private List<DirectoryUser> searchDirectoryUsers() {
    // Parse the query:
    QueryData data = initQueryData(true);
    if (data == null) {
        return Collections.emptyList();
    }
    ExtensionProxy authz = EngineExtensionsManager.getInstance().getExtensionByName(data.getDomain());
    List<DirectoryUser> results = new ArrayList<>();
    for (String namespace : authz.getContext().<List<String>>get(Authz.ContextKeys.AVAILABLE_NAMESPACES)) {
        results.addAll(DirectoryUtils.findDirectoryUsersByQuery(authz, namespace, data.getQuery()));
    }
    return results;
}
#end_block

#method_before
private List<DirectoryGroup> searchDirectoryGroups() {
    // Parse the query:
    QueryData data = initQueryData(true);
    if (data == null) {
        return Collections.emptyList();
    }
    ExtensionProxy authz = EngineExtensionsManager.getInstance().getExtensionByName(data.getDomain());
    List<DirectoryGroup> results = new ArrayList<>();
    for (String namespace : authz.getContext().<List<String>>get(Authz.ContextKeys.AVAILABLE_NAMESPACES)) {
        results.addAll(AuthzUtils.findGroupsByQuery(authz, namespace, data.getQuery()));
    }
    return results;
}
#method_after
private List<DirectoryGroup> searchDirectoryGroups() {
    // Parse the query:
    QueryData data = initQueryData(true);
    if (data == null) {
        return Collections.emptyList();
    }
    ExtensionProxy authz = EngineExtensionsManager.getInstance().getExtensionByName(data.getDomain());
    List<DirectoryGroup> results = new ArrayList<>();
    for (String namespace : authz.getContext().<List<String>>get(Authz.ContextKeys.AVAILABLE_NAMESPACES)) {
        results.addAll(DirectoryUtils.findDirectoryGroupsByQuery(authz, namespace, data.getQuery()));
    }
    return results;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<AuthenticationProfile> profiles = AuthenticationProfileRepository.getInstance().getProfiles();
    List<ProfileEntry> names = new ArrayList<>(profiles.size());
    for (AuthenticationProfile profile : profiles) {
        names.add(new ProfileEntry(profile.getName(), AuthzUtils.getName(profile.getAuthz())));
    }
    getQueryReturnValue().setReturnValue(names);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<AuthenticationProfile> profiles = AuthenticationProfileRepository.getInstance().getProfiles();
    List<ProfileEntry> names = new ArrayList<>(profiles.size());
    for (AuthenticationProfile profile : profiles) {
        names.add(new ProfileEntry(profile.getName(), AuthzUtils.getName(profile.getAuthz())));
    }
    Collections.sort(names, new Comparator<ProfileEntry>() {

        @Override
        public int compare(ProfileEntry lhs, ProfileEntry rhs) {
            return lhs.getProfile().compareTo(rhs.getProfile()) != 0 ? lhs.getProfile().compareTo(rhs.getProfile()) : lhs.getAuthz().compareTo(rhs.getAuthz());
        }
    });
    getQueryReturnValue().setReturnValue(names);
}
#end_block

#method_before
private void initListBoxEditors() {
    profileSelection = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return object.toString();
        }
    });
    roleSelection = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Role) object).getname();
        }
    });
}
#method_after
private void initListBoxEditors() {
    profileSelection = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((ProfileEntry) object).toString();
        }
    });
    roleSelection = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Role) object).getname();
        }
    });
}
#end_block

#method_before
protected void populateProfiles(List<String> profiles) {
    getProfile().setItems(profiles);
    getProfile().setSelectedItem(Linq.firstOrDefault(profiles));
}
#method_after
protected void populateProfiles(List<ProfileEntry> profiles) {
    getProfile().setItems(profiles);
    getProfile().setSelectedItem(Linq.firstOrDefault(profiles));
}
#end_block

#method_before
protected void findGroups(String searchString, AsyncQuery query) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("ADGROUP@" + extractAuthorizationProvider((String) getProfile().getSelectedItem()) + ": " + searchString, SearchType.DirectoryGroup), // $NON-NLS-1$ //$NON-NLS-2$
    query);
}
#method_after
protected void findGroups(String searchString, AsyncQuery query) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("ADGROUP@" + ((ProfileEntry) getProfile().getSelectedItem()).getAuthz() + ": " + searchString, SearchType.DirectoryGroup), // $NON-NLS-1$ //$NON-NLS-2$
    query);
}
#end_block

#method_before
protected void findUsers(String searchString, AsyncQuery query) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("ADUSER@" + extractAuthorizationProvider((String) getProfile().getSelectedItem()) + ": " + searchString, SearchType.DirectoryUser), // $NON-NLS-1$ //$NON-NLS-2$
    query);
}
#method_after
protected void findUsers(String searchString, AsyncQuery query) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("ADUSER@" + ((ProfileEntry) getProfile().getSelectedItem()).getAuthz() + ": " + searchString, SearchType.DirectoryUser), // $NON-NLS-1$ //$NON-NLS-2$
    query);
}
#end_block

#method_before
public static List<OvfEntityData> getOvfEntities(byte[] tar, Guid storageDomainId) {
    List<OvfEntityData> ovfEntityDataFromTar = new ArrayList<>();
    InputStream is = new ByteArrayInputStream(tar);
    Map<String, ByteBuffer> filesFromTar;
    try (TarInMemoryExport memoryTar = new TarInMemoryExport(is)) {
        filesFromTar = memoryTar.unTar();
    } catch (IOException e) {
        throw new RuntimeException(String.format("Exception while getting OVFs files from tar file for domain %s", storageDomainId), e);
    }
    for (Entry<String, ByteBuffer> fileEntry : filesFromTar.entrySet()) {
        if (fileEntry.getKey().endsWith(OVF_FILE_EXT)) {
            String ovfData = new String(fileEntry.getValue().array());
            VmEntityType vmType = getVmEntityType(ovfData);
            ArchitectureType archType = null;
            try {
                XmlDocument xmlDocument = new XmlDocument(ovfData);
                archType = getOsSection(xmlDocument);
            } catch (Exception e) {
                log.errorFormat("Could not parse architecture type for VM. Exception : {0}", e);
                continue;
            }
            // Creates an OVF entity data.
            OvfEntityData ovfEntityData = createOvfEntityData(storageDomainId, ovfData, vmType, getEntityName(ovfData), archType, getEntityId(fileEntry.getKey()));
            log.infoFormat("Retrieve OVF Entity from storage domain id {0} for entity ID {1}, entity name {2} and vmType of {3}", storageDomainId, getEntityId(fileEntry.getKey()), getEntityName(ovfData), vmType.name());
            ovfEntityDataFromTar.add(ovfEntityData);
        } else {
            log.infoFormat("Current file name {0} does not indicate OVF extension file, will ignore it", fileEntry.getKey());
        }
    }
    return ovfEntityDataFromTar;
}
#method_after
public static List<OvfEntityData> getOvfEntities(byte[] tar, Guid storageDomainId) {
    List<OvfEntityData> ovfEntityDataFromTar = new ArrayList<>();
    InputStream is = new ByteArrayInputStream(tar);
    log.infoFormat("Start fetching OVF files from tar file");
    Map<String, ByteBuffer> filesFromTar;
    try (TarInMemoryExport memoryTar = new TarInMemoryExport(is)) {
        filesFromTar = memoryTar.unTar();
    } catch (IOException e) {
        throw new RuntimeException(String.format("Exception while getting OVFs files from tar file for domain %s", storageDomainId), e);
    }
    for (Entry<String, ByteBuffer> fileEntry : filesFromTar.entrySet()) {
        if (fileEntry.getKey().endsWith(OVF_FILE_EXT)) {
            String ovfData = new String(fileEntry.getValue().array());
            VmEntityType vmType = getVmEntityType(ovfData);
            ArchitectureType archType = null;
            try {
                XmlDocument xmlDocument = new XmlDocument(ovfData);
                archType = getOsSection(xmlDocument);
            } catch (Exception e) {
                log.errorFormat("Could not parse architecture type for VM. Exception : {0}", e);
                continue;
            }
            // Creates an OVF entity data.
            OvfEntityData ovfEntityData = createOvfEntityData(storageDomainId, ovfData, vmType, getEntityName(ovfData), archType, getEntityId(fileEntry.getKey()));
            log.infoFormat("Retrieve OVF Entity from storage domain ID {0} for entity ID {1}, entity name {2} and VM Type of {3}", storageDomainId, getEntityId(fileEntry.getKey()), getEntityName(ovfData), vmType.name());
            ovfEntityDataFromTar.add(ovfEntityData);
        } else {
            log.infoFormat("File {0} is not an OVF file, will be ignored.", fileEntry.getKey());
        }
    }
    log.infoFormat("Finish to fetch OVF files from tar file. The number of OVF entities are {0}", ovfEntityDataFromTar.size());
    return ovfEntityDataFromTar;
}
#end_block

#method_before
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    List<OvfEntityData> ovfEntitiesFromTar = Collections.emptyList();
    // Get all unregistered disks.
    List<Disk> unregisteredDisks = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(getParameters().getStorageDomainId(), getVds().getStoragePoolId())).getReturnValue();
    if (!unregisteredDisks.isEmpty()) {
        Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(unregisteredDisks);
        DiskImage ovfDisk = ovfDiskAndSize.getFirst();
        if (ovfDisk != null) {
            try {
                VDSReturnValue retrievedByteData = runVdsCommand(VDSCommandType.RetrieveImageData, new ImageHttpAccessVDSCommandParameters(getVdsId(), getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()));
                if (retrievedByteData.getSucceeded()) {
                    ovfEntitiesFromTar = OvfUtils.getOvfEntities((byte[]) retrievedByteData.getReturnValue(), getParameters().getStorageDomainId());
                } else {
                    log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}", ovfDisk.getId());
                    AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
                }
            } catch (RuntimeException e) {
                // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                // a RuntimeException if there is a problem to untar the file.
                log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}. Error: {2}", ovfDisk.getId(), getParameters().getStorageDomainId(), e);
                AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
            }
        }
    } else {
        log.warnFormat("There are no OVF_STORE disks on storage domain id {0}", getParameters().getStorageDomainId());
    }
    return ovfEntitiesFromTar;
}
#method_after
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk() {
    List<OvfEntityData> ovfEntitiesFromTar = Collections.emptyList();
    // Get all unregistered disks.
    List<Disk> unregisteredDisks = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(getParameters().getStorageDomainId(), getVds().getStoragePoolId())).getReturnValue();
    if (!unregisteredDisks.isEmpty()) {
        Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(unregisteredDisks);
        DiskImage ovfDisk = ovfDiskAndSize.getFirst();
        if (ovfDisk != null) {
            try {
                VDSReturnValue retrievedByteData = runVdsCommand(VDSCommandType.RetrieveImageData, new ImageHttpAccessVDSCommandParameters(getVdsId(), getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()));
                if (retrievedByteData.getSucceeded()) {
                    ovfEntitiesFromTar = OvfUtils.getOvfEntities((byte[]) retrievedByteData.getReturnValue(), getParameters().getStorageDomainId());
                } else {
                    log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}", ovfDisk.getId(), getParameters().getStorageDomainId());
                    AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
                }
            } catch (RuntimeException e) {
                // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                // a RuntimeException if there is a problem to untar the file.
                log.errorFormat("Image data could not be retrieved for disk id {0} in storage domain id {1}. Error: {2}", ovfDisk.getId(), getParameters().getStorageDomainId(), e);
                AuditLogDirector.log(this, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
            }
        }
    } else {
        log.warnFormat("There are no OVF_STORE disks on storage domain id {0}", getParameters().getStorageDomainId());
    }
    return ovfEntitiesFromTar;
}
#end_block

#method_before
protected List<Guid> executeHSMGetStorageDomainsList(HSMGetStorageDomainsListVDSCommandParameters parameters) {
    return (ArrayList<Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainsList, parameters).getReturnValue();
}
#method_after
protected List<Guid> executeHSMGetStorageDomainsList(HSMGetStorageDomainsListVDSCommandParameters parameters) {
    return (List<Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainsList, parameters).getReturnValue();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Check that the directory name has been provided:
    String directoryName = getParameters().getDirectory();
    if (directoryName == null) {
        log.error("Can't add user because directory name hasn't been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the identifier of the directory user has been provided:
    String id = getParameters().getId();
    if (id == null) {
        log.errorFormat("Can't add user from directory \"{0}\" because the user identifier hasn't been provided.", directoryName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the directory exists:
    ExtensionProxy authz = EngineExtensionsManager.getInstance().getExtensionByName(directoryName);
    if (authz == null) {
        log.errorFormat("Can't add user with id \"{0}\" because directory \"{1}\" doesn't exist.", id, directoryName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the user is available in the directory (and save the reference to avoid looking it up later when
    // actually adding the user to the database):
    boolean foundUser = false;
    for (String namespace : getParameters().getNamespace() != null ? Arrays.asList(getParameters().getNamespace()) : authz.getContext().<List<String>>get(Authz.ContextKeys.AVAILABLE_NAMESPACES)) {
        principal = AuthzUtils.fetchPrincipalsByIdsRecursively(authz, namespace, Arrays.asList(id)).get(0);
        if (principal != null) {
            foundUser = true;
            break;
        }
    }
    if (!foundUser) {
        log.errorFormat("Can't add user with id \"{0}\" because it doesn't exist in directory \"{1}\".", id, directoryName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Populate information for the audit log:
    addCustomValue("NewUserName", principal.<String>get(PrincipalRecord.NAME));
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    addCustomValue("NewUserName", getParameters().getUserToAdd().getLoginName());
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    DbUserDAO dao = getDbUserDAO();
    // First check if the user is already in the database, if it is we need to update, if not we need to insert:
    DbUser dbUser = dao.getByExternalId(getParameters().getDirectory(), principal.<String>get(PrincipalRecord.ID));
    DbUser mappedDbUser = DirectoryUtils.mapPrincipalRecordToDbUser(getParameters().getDirectory(), principal);
    mappedDbUser.setId(dbUser != null ? dbUser.getId() : Guid.newGuid());
    mappedDbUser.setActive(dbUser != null ? dbUser.isActive() : true);
    DirectoryUtils.syncAndReactivatePrincipal(principal, mappedDbUser, "the user is rectivated as it was added again to the system");
    setActionReturnValue(mappedDbUser.getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    DbUser userToAdd = getParameters().getUserToAdd();
    for (DbUser syncedUser : SyncUsers.sync(Arrays.asList(userToAdd))) {
        if (Guid.isNullOrEmpty(syncedUser.getId())) {
            if (syncedUser.isActive()) {
                DbFacade.getInstance().getDbUserDao().save(syncedUser);
            }
        } else {
            DbFacade.getInstance().getDbUserDao().update(syncedUser);
        }
    }
    DbUser userFromDb = DbFacade.getInstance().getDbUserDao().getByExternalId(userToAdd.getDomain(), userToAdd.getExternalId());
    setActionReturnValue(userFromDb.getId());
    setSucceeded(userFromDb.isActive());
}
#end_block

#method_before
protected boolean isUserCanBeAuthenticated() {
    AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(getParameters().getProfileName());
    if (profile == null) {
        log.errorFormat("Can't login because authentication profile \"{1}\" doesn't exist.", getParameters().getProfileName());
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    ExtensionProxy authnExtension = profile.getAuthn();
    ExtMap authRecord = (ExtMap) getParameters().getAuthRecord();
    int reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS;
    if (getParameters().getAuthType() != null) {
        if (AuthType.NEGOTIATION == getParameters().getAuthType()) {
            reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_NEGOTIATE;
        }
    }
    String loginName = null;
    if (authRecord == null) {
        reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS;
        // Verify that the login name and password have been provided:
        loginName = getParameters().getLoginName();
        if (loginName == null) {
            log.errorFormat("Can't login user because no login name has been provided.");
            addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        String password = getParameters().getPassword();
        if (password == null) {
            log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
            return false;
        }
        if (!isPasswordAuth(authnExtension)) {
            log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profile.getName());
            addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        DbUser curUser = null;
        String curPassword = null;
        SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
        if (StringUtils.isEmpty(getParameters().getSessionId())) {
            curUser = sessionDataContainer.getUser(engineSessionId, false);
            curPassword = sessionDataContainer.getPassword(engineSessionId);
        } else {
            curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
            curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
        }
        // verify that in auto login mode , user is not taken from session.
        if (curUser != null && !StringUtils.isEmpty(curPassword)) {
            loginName = curUser.getLoginName();
            password = curPassword;
        }
        authRecord = authenticate(profile, loginName, password);
    }
    // Perform the actual authentication:
    if (authRecord == null) {
        return false;
    }
    ExtensionProxy mapper = profile.getMapper();
    if (mapper != null) {
        authRecord = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord), true).<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD, authRecord);
    }
    ExtMap principalRecord = AuthzUtils.fetchPrincipalRecord(profile.getAuthz(), authRecord);
    if (principalRecord == null) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", authRecord.<String>get(Authn.AuthRecord.PRINCIPAL), profile.getName());
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        AcctUtils.reportRecords(Acct.ReportReason.PRINCIPAL_NOT_FOUND, loginName, authRecord, null, "Principal record was not found. User name is %1$s", loginName);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    DbUser dbUser = getDbUserDAO().getByExternalId(AuthzUtils.getName(profile.getAuthz()), principalRecord.<String>get(PrincipalRecord.ID));
    if (dbUser == null) {
        dbUser = DirectoryUtils.mapPrincipalRecordToDbUser(AuthzUtils.getName(profile.getAuthz()), principalRecord);
        dbUser.setId(Guid.newGuid());
    }
    DirectoryUtils.syncAndReactivatePrincipal(principalRecord, dbUser, "the user is re-activated as it is used for login");
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        AcctUtils.reportRecords(Acct.ReportReason.PRINCIPAL_LOGIN_NO_PERMISSION, dbUser.getLoginName(), authRecord, principalRecord, "The user %1$s is not authorized to perform login", dbUser.getLoginName());
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    AcctUtils.reportRecords(reportReason, dbUser.getLoginName(), authRecord, principalRecord, "User %1$s which has princnipal name %2$s logged in ", dbUser.getLoginName(), principalRecord.<String>get(Authz.PrincipalRecord.NAME));
    return attachUserToSession(profile, authRecord);
}
#method_after
protected boolean isUserCanBeAuthenticated() {
    AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(getParameters().getProfileName());
    if (profile == null) {
        log.errorFormat("Can't login because authentication profile \"{1}\" doesn't exist.", getParameters().getProfileName());
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    ExtensionProxy authnExtension = profile.getAuthn();
    ExtMap authRecord = (ExtMap) getParameters().getAuthRecord();
    int reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS;
    if (getParameters().getAuthType() != null) {
        if (AuthType.NEGOTIATION == getParameters().getAuthType()) {
            reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_NEGOTIATE;
        }
    }
    String loginName = null;
    if (authRecord == null) {
        reportReason = Acct.ReportReason.PRINCIPAL_LOGIN_CREDENTIALS;
        // Verify that the login name and password have been provided:
        loginName = getParameters().getLoginName();
        if (loginName == null) {
            log.errorFormat("Can't login user because no login name has been provided.");
            addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        String password = getParameters().getPassword();
        if (password == null) {
            log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
            return false;
        }
        if (!isPasswordAuth(authnExtension)) {
            log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profile.getName());
            addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            return false;
        }
        DbUser curUser = null;
        String curPassword = null;
        SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
        if (StringUtils.isEmpty(getParameters().getSessionId())) {
            curUser = sessionDataContainer.getUser(engineSessionId, false);
            curPassword = sessionDataContainer.getPassword(engineSessionId);
        } else {
            curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
            curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
        }
        // verify that in auto login mode , user is not taken from session.
        if (curUser != null && !StringUtils.isEmpty(curPassword)) {
            loginName = curUser.getLoginName();
            password = curPassword;
        }
        authRecord = authenticate(profile, loginName, password);
    }
    // Perform the actual authentication:
    if (authRecord == null) {
        return false;
    }
    ExtensionProxy mapper = profile.getMapper();
    if (mapper != null) {
        authRecord = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord), true).<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD, authRecord);
    }
    ExtMap principalRecord = AuthzUtils.fetchPrincipalRecord(profile.getAuthz(), authRecord);
    if (principalRecord == null) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", authRecord.<String>get(Authn.AuthRecord.PRINCIPAL), profile.getName());
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        AcctUtils.reportRecords(Acct.ReportReason.PRINCIPAL_NOT_FOUND, loginName, authRecord, null, "Principal record was not found. User name is %1$s", loginName);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    DbUser dbUser = getDbUserDAO().getByExternalId(AuthzUtils.getName(profile.getAuthz()), principalRecord.<String>get(PrincipalRecord.ID));
    if (dbUser == null) {
        dbUser = DirectoryUtils.mapPrincipalRecordToDbUser(AuthzUtils.getName(profile.getAuthz()), principalRecord);
        dbUser.setId(Guid.newGuid());
    }
    DirectoryUtils.flatGroups(principalRecord);
    dbUser.setGroupIds(DirectoryUtils.getGroupIdsFromPrincipal(AuthzUtils.getName(profile.getAuthz()), principalRecord));
    if (!dbUser.isActive()) {
        dbUser.setActive(true);
        log.info(String.format("The user %1$s was reactivated as it was found in authz provider %2$s during login attempt.", dbUser.getLoginName(), dbUser.getDomain()));
    }
    getDbUserDAO().saveOrUpdate(dbUser);
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        AcctUtils.reportRecords(Acct.ReportReason.PRINCIPAL_LOGIN_NO_PERMISSION, dbUser.getLoginName(), authRecord, principalRecord, "The user %1$s is not authorized to perform login", dbUser.getLoginName());
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    AcctUtils.reportRecords(reportReason, dbUser.getLoginName(), authRecord, principalRecord, "User %1$s which has princnipal name %2$s logged in ", dbUser.getLoginName(), principalRecord.<String>get(Authz.PrincipalRecord.NAME));
    return attachUserToSession(profile, authRecord);
}
#end_block

#method_before
private String getDirectoryName(Group group) {
    if (group.isSetDomain() && group.getDomain().isSetName()) {
        return group.getDomain().getName();
    } else if (group.isSetDomain() && group.getDomain().isSetId()) {
        List<String> domains = getBackendCollection(String.class, VdcQueryType.GetDomainList, new GetDomainListParameters());
        for (String domain : domains) {
            Guid domainId = new Guid(domain.getBytes(), true);
            if (domainId.toString().equals(group.getDomain().getId())) {
                return domain;
            }
        }
        throw new WebFaultException(null, "Domain: '" + group.getDomain().getId().toString() + "' does not exist.", Response.Status.BAD_REQUEST);
    } else if (group.isSetName() && group.getName().contains("/")) {
        return group.getName().substring(0, group.getName().indexOf("/"));
    }
    return null;
}
#method_after
private String getDirectoryName(Group group) {
    if (group.isSetDomain() && group.getDomain().isSetName()) {
        return group.getDomain().getName();
    } else if (group.isSetDomain() && group.getDomain().isSetId()) {
        List<String> domains = getBackendCollection(String.class, VdcQueryType.GetDomainList, new VdcQueryParametersBase());
        for (String domain : domains) {
            Guid domainId = new Guid(domain.getBytes(), true);
            if (domainId.toString().equals(group.getDomain().getId())) {
                return domain;
            }
        }
        throw new WebFaultException(null, "Domain: '" + group.getDomain().getId().toString() + "' does not exist.", Response.Status.BAD_REQUEST);
    } else if (group.isSetName() && group.getName().contains("/")) {
        return group.getName().substring(0, group.getName().indexOf("/"));
    }
    return null;
}
#end_block

#method_before
protected String getDomain(User user) {
    if (user.isSetDomain() && user.getDomain().isSetName()) {
        return user.getDomain().getName();
    } else if (user.isSetDomain() && user.getDomain().isSetId()) {
        List<String> domains = getBackendCollection(String.class, VdcQueryType.GetDomainList, new GetDomainListParameters());
        for (String domain : domains) {
            Guid domainId = asGuid(domain.getBytes(), true);
            if (domainId.toString().equals(user.getDomain().getId())) {
                return domain;
            }
        }
        throw new WebFaultException(null, "Domain: '" + user.getDomain().getId().toString() + "' does not exist.", Response.Status.BAD_REQUEST);
    } else if (user.isSetUserName() && user.getUserName().contains("@")) {
        return user.getUserName().substring(user.getUserName().indexOf("@") + 1);
    }
    return null;
}
#method_after
protected String getDomain(User user) {
    if (user.isSetDomain() && user.getDomain().isSetName()) {
        return user.getDomain().getName();
    } else if (user.isSetDomain() && user.getDomain().isSetId()) {
        List<String> domains = getBackendCollection(String.class, VdcQueryType.GetDomainList, new VdcQueryParametersBase());
        for (String domain : domains) {
            Guid domainId = asGuid(domain.getBytes(), true);
            if (domainId.toString().equals(user.getDomain().getId())) {
                return domain;
            }
        }
        throw new WebFaultException(null, "Domain: '" + user.getDomain().getId().toString() + "' does not exist.", Response.Status.BAD_REQUEST);
    } else if (user.isSetUserName() && user.getUserName().contains("@")) {
        return user.getUserName().substring(user.getUserName().indexOf("@") + 1);
    }
    return null;
}
#end_block

#method_before
public static void sync(List<DbUser> dbUsers) {
    Map<String, Map<String, Set<String>>> authzToNamespaceToUserIds = new HashMap<>();
    Map<DirectoryEntryKey, DbUser> originalDbUsersMap = new HashMap<>();
    Map<String, List<DbUser>> dbUsersPerAuthz = new HashMap<>();
    // Initialize the entries based on authz in the map
    for (DbUser dbUser : dbUsers) {
        if (Guid.isNullOrEmpty(dbUser.getId())) {
            dbUser.setId(Guid.newGuid());
        }
        MultiValueMapUtils.addToMap(dbUser.getDomain(), dbUser, dbUsersPerAuthz);
        if (!authzToNamespaceToUserIds.containsKey(dbUser.getDomain())) {
            authzToNamespaceToUserIds.put(dbUser.getDomain(), new HashMap<String, Set<String>>());
        }
        MultiValueMapUtils.addToMapOfSets(dbUser.getNamespace(), dbUser.getExternalId(), authzToNamespaceToUserIds.get(dbUser.getDomain()));
        originalDbUsersMap.put(new DirectoryEntryKey(dbUser), dbUser);
    }
    for (Entry<String, Map<String, Set<String>>> entry : authzToNamespaceToUserIds.entrySet()) {
        Map<String, DbUser> activeUsers = new HashMap<>();
        String authz = entry.getKey();
        try {
            ExtensionProxy authzExtension = EngineExtensionsManager.getInstance().getExtensionByName(authz);
            for (Entry<String, Set<String>> userIdsPerNamespace : entry.getValue().entrySet()) {
                for (ExtMap principal : AuthzUtils.fetchPrincipalsByIdsRecursively(authzExtension, userIdsPerNamespace.getKey(), new ArrayList<String>(userIdsPerNamespace.getValue()))) {
                    DirectoryUtils.flatGroups(principal);
                    DbUser dbUser = DirectoryUtils.mapPrincipalRecordToDbUser(authz, principal);
                    dbUser.setGroupIds(DirectoryUtils.getGroupIdsFromPrincipal(authz, principal));
                    activeUsers.put(dbUser.getExternalId(), dbUser);
                }
            }
            for (DbUser dbUser : dbUsersPerAuthz.get(authz)) {
                DbUser activeUser = activeUsers.get(dbUser.getExternalId());
                if (activeUser != null) {
                    if (!activeUser.equals(dbUser)) {
                        activeUser.setId(dbUser.getId());
                        log.info(String.format("The user %1$s from authz extension %2$s got updated since last interval", activeUser.getLoginName(), activeUser.getDomain()));
                        DbFacade.getInstance().getDbUserDao().saveOrUpdate(activeUser);
                    }
                } else {
                    log.info(String.format("The user %1$s from authz extension %2$s could not be found, and will be marked as inactive", dbUser.getLoginName(), dbUser.getDomain()));
                    dbUser.setActive(false);
                    DbFacade.getInstance().getDbUserDao().saveOrUpdate(dbUser);
                }
            }
        } catch (Exception ex) {
            log.error(String.format("Error during user synchronization of extension %1$s. Exception message is %2$s", authz, ex.getMessage()));
            log.debug("", ex);
        }
    }
}
#method_after
public static void sync(List<DbUser> dbUsers) {
    Map<String, Map<String, Set<String>>> authzToNamespaceToUserIds = new HashMap<>();
    Map<DirectoryEntryKey, DbUser> originalDbUsersMap = new HashMap<>();
    Map<String, List<DbUser>> dbUsersPerAuthz = new HashMap<>();
    // Initialize the entries based on authz in the map
    for (DbUser dbUser : dbUsers) {
        MultiValueMapUtils.addToMap(dbUser.getDomain(), dbUser, dbUsersPerAuthz);
        if (!authzToNamespaceToUserIds.containsKey(dbUser.getDomain())) {
            authzToNamespaceToUserIds.put(dbUser.getDomain(), new HashMap<String, Set<String>>());
        }
        MultiValueMapUtils.addToMapOfSets(dbUser.getNamespace(), dbUser.getExternalId(), authzToNamespaceToUserIds.get(dbUser.getDomain()));
        originalDbUsersMap.put(new DirectoryEntryKey(dbUser), dbUser);
    }
    for (Entry<String, Map<String, Set<String>>> entry : authzToNamespaceToUserIds.entrySet()) {
        Map<String, DbUser> activeUsers = new HashMap<>();
        String authz = entry.getKey();
        try {
            ExtensionProxy authzExtension = EngineExtensionsManager.getInstance().getExtensionByName(authz);
            for (Entry<String, Set<String>> userIdsPerNamespace : entry.getValue().entrySet()) {
                for (ExtMap principal : AuthzUtils.fetchPrincipalsByIdsRecursively(authzExtension, userIdsPerNamespace.getKey(), new ArrayList<String>(userIdsPerNamespace.getValue()))) {
                    DirectoryUtils.flatGroups(principal);
                    DbUser dbUser = DirectoryUtils.mapPrincipalRecordToDbUser(authz, principal);
                    dbUser.setGroupIds(DirectoryUtils.getGroupIdsFromPrincipal(authz, principal));
                    activeUsers.put(dbUser.getExternalId(), dbUser);
                }
            }
            for (DbUser dbUser : dbUsersPerAuthz.get(authz)) {
                DbUser activeUser = activeUsers.get(dbUser.getExternalId());
                if (activeUser != null) {
                    if (!activeUser.equals(dbUser)) {
                        activeUser.setId(dbUser.getId());
                        log.info(String.format("The user %1$s from authz extension %2$s got updated since last interval", activeUser.getLoginName(), activeUser.getDomain()));
                        DbFacade.getInstance().getDbUserDao().saveOrUpdate(activeUser);
                    }
                } else {
                    log.info(String.format("The user %1$s from authz extension %2$s could not be found, and will be marked as inactive", dbUser.getLoginName(), dbUser.getDomain()));
                    dbUser.setActive(false);
                    DbFacade.getInstance().getDbUserDao().saveOrUpdate(dbUser);
                }
            }
        } catch (Exception ex) {
            log.error(String.format("Error during user synchronization of extension %1$s. Exception message is %2$s", authz, ex.getMessage()));
            log.debug("", ex);
        }
    }
}
#end_block

#method_before
@Test
public void testAddUser_4() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetDomainList, GetDomainListParameters.class, new String[] {}, new Object[] {}, setUpDomains());
    setUpAddUserExpectations("ADUSER@" + DOMAIN + ": allnames=" + NAMES[0]);
    User model = new User();
    model.setUserName(NAMES[0]);
    Domain domain = new Domain();
    domain.setId(new Guid(DOMAIN.getBytes(), true).toString());
    model.setDomain(domain);
    Response response = collection.add(model);
    verifyAddUser(response);
}
#method_after
@Test
public void testAddUser_4() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetDomainList, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, setUpDomains());
    setUpAddUserExpectations("ADUSER@" + DOMAIN + ": allnames=" + NAMES[0]);
    User model = new User();
    model.setUserName(NAMES[0]);
    Domain domain = new Domain();
    domain.setId(new Guid(DOMAIN.getBytes(), true).toString());
    model.setDomain(domain);
    Response response = collection.add(model);
    verifyAddUser(response);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.DBUser, isCaseSensitiveSearch());
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#method_after
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(applySortOptions(getSearchString()), SearchType.DBUser, isCaseSensitiveSearch());
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // First check if the group is already in the database, if it is we
    // need to update, if not we need to insert:
    DbGroupDAO dao = getAdGroupDAO();
    DbGroup groupToAdd = getParameters().getGroupToAdd();
    DbGroup dbGroup = dao.getByExternalId(groupToAdd.getDomain(), groupToAdd.getExternalId());
    Guid id = Guid.newGuid();
    if (dbGroup == null) {
        groupToAdd.setId(id);
        dao.save(groupToAdd);
    } else {
        groupToAdd.setId(id);
        dao.update(groupToAdd);
    }
    // Return the identifier of the created group:
    setActionReturnValue(groupToAdd.getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // First check if the group is already in the database, if it is we
    // need to update, if not we need to insert:
    DbGroupDAO dao = getAdGroupDAO();
    DbGroup groupToAdd = getParameters().getGroupToAdd();
    DbGroup dbGroup = dao.getByExternalId(groupToAdd.getDomain(), groupToAdd.getExternalId());
    if (dbGroup == null) {
        dao.save(groupToAdd);
    } else {
        dao.update(dbGroup);
    }
    // Return the identifier of the created group:
    setActionReturnValue(groupToAdd.getId());
    setSucceeded(true);
}
#end_block

#method_before
private void onNewTemplate() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null) {
        cancel();
        return;
    }
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate()) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck(this);
    } else {
        model.startProgress(null);
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel vmModel = (UnitVmModel) userPortalListModel.getWindow();
                    vmModel.getName().getInvalidityReasons().clear();
                    vmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    vmModel.getName().setIsValid(false);
                    vmModel.setIsValid(false);
                    stopProgress(target);
                } else {
                    userPortalListModel.postNameUniqueCheck(userPortalListModel);
                }
            }
        }), name);
    }
}
#method_after
private void onNewTemplate() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null) {
        cancel();
        return;
    }
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.validate()) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck(this);
    } else {
        model.startProgress(null);
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel vmModel = (UnitVmModel) userPortalListModel.getWindow();
                    vmModel.getName().getInvalidityReasons().clear();
                    vmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    vmModel.getName().setIsValid(false);
                    vmModel.setIsValid(false);
                    stopProgress(target);
                } else {
                    userPortalListModel.postNameUniqueCheck(userPortalListModel);
                }
            }
        }), name);
    }
}
#end_block

#method_before
private void runOnce() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            RunOnceModel runOnceModel = new UserPortalRunOnceModel((VM) result, UserPortalListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    };
    AsyncDataProvider.getVmById(getVmInitQuery, vm.getId());
}
#method_after
private void runOnce() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            RunOnceModel runOnceModel = new UserPortalRunOnceModel((VM) result, UserPortalListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    };
    AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
}
#end_block

#method_before
private void newInternal() {
    UnitVmModel model = new UnitVmModel(new UserPortalNewVmModelBehavior());
    model.getVmType().setSelectedItem(VmType.Server);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.setCustomPropertiesKeysList(AsyncDataProvider.getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("up_vm_dialog");
    setWindow(model);
    model.initialize(null);
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void newInternal() {
    UnitVmModel model = new UnitVmModel(new UserPortalNewVmModelBehavior());
    model.getVmType().setSelectedItem(VmType.Server);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("up_vm_dialog");
    setWindow(model);
    model.initialize(null);
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void edit() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            editedVm = (VM) result;
            vmInitLoaded(editedVm);
        }
    };
    if (vm.isNextRunConfigurationExists()) {
        AsyncDataProvider.getVmNextRunConfiguration(getVmInitQuery, vm.getId());
    } else {
        AsyncDataProvider.getVmById(getVmInitQuery, vm.getId());
    }
}
#method_after
private void edit() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            editedVm = (VM) result;
            vmInitLoaded(editedVm);
        }
    };
    if (vm.isNextRunConfigurationExists()) {
        AsyncDataProvider.getInstance().getVmNextRunConfiguration(getVmInitQuery, vm.getId());
    } else {
        AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
    }
}
#end_block

#method_before
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new UserPortalExistingVmModelBehavior(vm));
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setCustomPropertiesKeysList(AsyncDataProvider.getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("up_vm_dialog");
    setWindow(model);
    model.initialize(null);
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new UserPortalExistingVmModelBehavior(vm));
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("up_vm_dialog");
    setWindow(model);
    model.initialize(null);
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void changeCD() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        return;
    }
    final VM vm = (VM) selectedItem.getEntity();
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    ArrayList<String> defaultImages = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    model.getIsoImage().setItems(defaultImages);
    model.getIsoImage().setSelectedItem(Linq.firstOrDefault(defaultImages));
    AsyncQuery getImagesQuery = new AsyncQuery();
    getImagesQuery.setModel(this);
    getImagesQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model1, Object result) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) model1;
            AttachCdModel _attachCdModel = (AttachCdModel) userPortalListModel.getWindow();
            List<String> images = (List<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrDefault(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getImagesQuery, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void changeCD() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        return;
    }
    final VM vm = (VM) selectedItem.getEntity();
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    ArrayList<String> defaultImages = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    model.getIsoImage().setItems(defaultImages);
    model.getIsoImage().setSelectedItem(Linq.firstOrDefault(defaultImages));
    AsyncQuery getImagesQuery = new AsyncQuery();
    getImagesQuery.setModel(this);
    getImagesQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model1, Object result) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) model1;
            AttachCdModel _attachCdModel = (AttachCdModel) userPortalListModel.getWindow();
            List<String> images = (List<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrDefault(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    };
    AsyncDataProvider.getInstance().getIrsImageList(getImagesQuery, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (!model.getIsNew() && selectedItem.getEntity() == null) {
        cancel();
        return;
    }
    settempVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem.getEntity()));
    if (!model.validate()) {
        return;
    }
    model.startProgress(null);
    // Check name uniqueness.
    AsyncDataProvider.isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) target;
            boolean isNameUnique = (Boolean) returnValue;
            String newName = model.getName().getEntity();
            String currentName = userPortalListModel.gettempVm().getName();
            if (!isNameUnique && newName.compareToIgnoreCase(currentName) != 0) {
                UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                unitModel.getName().getInvalidityReasons().clear();
                unitModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                unitModel.getName().setIsValid(false);
                unitModel.setIsValid(false);
                unitModel.setIsGeneralTabValid(false);
                stopProgress(target);
            } else {
                userPortalListModel.postVmNameUniqueCheck(userPortalListModel);
            }
        }
    }), model.getName().getEntity());
}
#method_after
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (!model.getIsNew() && selectedItem.getEntity() == null) {
        cancel();
        return;
    }
    settempVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem.getEntity()));
    if (!model.validate()) {
        return;
    }
    model.startProgress(null);
    // Check name uniqueness.
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) target;
            boolean isNameUnique = (Boolean) returnValue;
            String newName = model.getName().getEntity();
            String currentName = userPortalListModel.gettempVm().getName();
            if (!isNameUnique && newName.compareToIgnoreCase(currentName) != 0) {
                UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                unitModel.getName().getInvalidityReasons().clear();
                unitModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                unitModel.getName().setIsValid(false);
                unitModel.setIsValid(false);
                unitModel.setIsGeneralTabValid(false);
                stopProgress(target);
            } else {
                userPortalListModel.postVmNameUniqueCheck(userPortalListModel);
            }
        }
    }), model.getName().getEntity());
}
#end_block

#method_before
public void postVmNameUniqueCheck(final UserPortalListModel userPortalListModel) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        if (gettempVm().getVmtGuid().equals(Guid.Empty)) {
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(gettempVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setMakeCreatorExplicitOwner(true);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            setRngDeviceToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
        } else {
            setstorageDomain(model.getStorageDomain().getSelectedItem());
            if (model.getProvisioning().getEntity()) {
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object result) {
                        UserPortalListModel userPortalListModel1 = (UserPortalListModel) model;
                        final UnitVmModel unitVmModel = (UnitVmModel) userPortalListModel1.getWindow();
                        VM vm = gettempVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vm, unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setMakeCreatorExplicitOwner(true);
                        param.setCopyTemplatePermissions(unitVmModel.getCopyPermissions().getEntity());
                        param.setSoundDeviceEnabled(unitVmModel.getIsSoundcardEnabled().getEntity());
                        param.setConsoleEnabled(unitVmModel.getIsConsoleDeviceEnabled().getEntity());
                        setRngDeviceToParams(unitVmModel, param);
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(unitVmModel, defaultNetworkCreatingManager), this);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, gettempVm().getVmtGuid());
            } else {
                VM vm = gettempVm();
                vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                VmManagementParametersBase param = new VmManagementParametersBase(vm);
                param.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                param.setMakeCreatorExplicitOwner(true);
                param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                setRngDeviceToParams(model, param);
                Frontend.getInstance().runAction(VdcActionType.AddVm, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else {
        final VM selectedItem = (VM) ((UserPortalItemModel) userPortalListModel.getSelectedItem()).getEntity();
        gettempVm().setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.isNextRunConfigurationChanged(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    if (((VdcQueryReturnValue) returnValue).<Boolean>getReturnValue()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == gettempVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != gettempVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("CancelConfirmation", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(userPortalListModel, false);
                    }
                }
            }));
        } else {
            updateExistingVm(userPortalListModel, false);
        }
    }
}
#method_after
public void postVmNameUniqueCheck(final UserPortalListModel userPortalListModel) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        if (gettempVm().getVmtGuid().equals(Guid.Empty)) {
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(gettempVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setMakeCreatorExplicitOwner(true);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            setRngDeviceToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
        } else {
            setstorageDomain(model.getStorageDomain().getSelectedItem());
            if (model.getProvisioning().getEntity()) {
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object result) {
                        UserPortalListModel userPortalListModel1 = (UserPortalListModel) model;
                        final UnitVmModel unitVmModel = (UnitVmModel) userPortalListModel1.getWindow();
                        VM vm = gettempVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vm, unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setMakeCreatorExplicitOwner(true);
                        param.setCopyTemplatePermissions(unitVmModel.getCopyPermissions().getEntity());
                        param.setSoundDeviceEnabled(unitVmModel.getIsSoundcardEnabled().getEntity());
                        param.setConsoleEnabled(unitVmModel.getIsConsoleDeviceEnabled().getEntity());
                        setRngDeviceToParams(unitVmModel, param);
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(unitVmModel, defaultNetworkCreatingManager), this);
                    }
                };
                AsyncDataProvider.getInstance().getTemplateDiskList(_asyncQuery, gettempVm().getVmtGuid());
            } else {
                VM vm = gettempVm();
                vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                VmManagementParametersBase param = new VmManagementParametersBase(vm);
                param.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                param.setMakeCreatorExplicitOwner(true);
                param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                setRngDeviceToParams(model, param);
                Frontend.getInstance().runAction(VdcActionType.AddVm, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else {
        final VM selectedItem = (VM) ((UserPortalItemModel) userPortalListModel.getSelectedItem()).getEntity();
        gettempVm().setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().isNextRunConfigurationChanged(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    if (((VdcQueryReturnValue) returnValue).<Boolean>getReturnValue()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == gettempVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != gettempVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("CancelConfirmation", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(userPortalListModel, false);
                    }
                }
            }));
        } else {
            updateExistingVm(userPortalListModel, false);
        }
    }
}
#end_block

#method_before
private void updateDataCenterWithCluster() {
    UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    final VM vm = (VM) selectedItem.getEntity();
    DataCenterWithCluster selectedDataCenterWithCluster = null;
    for (DataCenterWithCluster candidate : model.getDataCenterWithClustersList().getItems()) {
        if (model.getIsNew()) {
            selectedDataCenterWithCluster = candidate;
            break;
        }
        if (candidate.getDataCenter().getId().equals(vm.getStoragePoolId()) && candidate.getCluster().getId().equals(vm.getVdsGroupId())) {
            selectedDataCenterWithCluster = candidate;
            break;
        }
    }
    if (!model.getIsNew() && selectedDataCenterWithCluster == null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, final Object loadedDataCenter) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) model;
                final UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                AsyncDataProvider.getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object loadedCluster) {
                        DataCenterWithCluster newItem = new DataCenterWithCluster((StoragePool) loadedDataCenter, (VDSGroup) loadedCluster);
                        unitModel.getDataCenterWithClustersList().setItems(Arrays.asList(newItem));
                        unitModel.getDataCenterWithClustersList().setSelectedItem(newItem);
                    }
                }), vm.getVdsGroupId());
            }
        };
        AsyncDataProvider.getDataCenterById(_asyncQuery, vm.getStoragePoolId());
    } else {
        model.getDataCenterWithClustersList().setSelectedItem(selectedDataCenterWithCluster);
    }
    model.getDataCenterWithClustersList().setIsChangable(vm.getStatus() == VMStatus.Down);
}
#method_after
private void updateDataCenterWithCluster() {
    UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    final VM vm = (VM) selectedItem.getEntity();
    DataCenterWithCluster selectedDataCenterWithCluster = null;
    for (DataCenterWithCluster candidate : model.getDataCenterWithClustersList().getItems()) {
        if (model.getIsNew()) {
            selectedDataCenterWithCluster = candidate;
            break;
        }
        if (candidate.getDataCenter().getId().equals(vm.getStoragePoolId()) && candidate.getCluster().getId().equals(vm.getVdsGroupId())) {
            selectedDataCenterWithCluster = candidate;
            break;
        }
    }
    if (!model.getIsNew() && selectedDataCenterWithCluster == null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, final Object loadedDataCenter) {
                UserPortalListModel userPortalListModel = (UserPortalListModel) model;
                final UnitVmModel unitModel = (UnitVmModel) userPortalListModel.getWindow();
                AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object loadedCluster) {
                        DataCenterWithCluster newItem = new DataCenterWithCluster((StoragePool) loadedDataCenter, (VDSGroup) loadedCluster);
                        unitModel.getDataCenterWithClustersList().setItems(Arrays.asList(newItem));
                        unitModel.getDataCenterWithClustersList().setSelectedItem(newItem);
                    }
                }), vm.getVdsGroupId());
            }
        };
        AsyncDataProvider.getInstance().getDataCenterById(_asyncQuery, vm.getStoragePoolId());
    } else {
        model.getDataCenterWithClustersList().setSelectedItem(selectedDataCenterWithCluster);
    }
    model.getDataCenterWithClustersList().setIsChangable(vm.getStatus() == VMStatus.Down);
}
#end_block

#method_before
private void vmModel_Priority_ItemsChanged() {
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.getIsNew()) {
        if (cachedMaxPriority == null) {
            AsyncDataProvider.getMaxVmPriority(new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    cachedMaxPriority = (Integer) returnValue;
                    updatePriority((UnitVmModel) target);
                }
            }, model.getHash()));
        } else {
            updatePriority(model);
        }
    }
}
#method_after
private void vmModel_Priority_ItemsChanged() {
    UnitVmModel model = (UnitVmModel) getWindow();
    if (!model.getIsNew()) {
        if (cachedMaxPriority == null) {
            AsyncDataProvider.getInstance().getMaxVmPriority(new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    cachedMaxPriority = (Integer) returnValue;
                    updatePriority((UnitVmModel) target);
                }
            }, model.getHash()));
        } else {
            updatePriority(model);
        }
    }
}
#end_block

#method_before
private void updatePriority(UnitVmModel model) {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    VM vm = (VM) selectedItem.getEntity();
    int roundPriority = AsyncDataProvider.getRoundedPriority(vm.getPriority(), cachedMaxPriority);
    EntityModel<Integer> priority = null;
    for (EntityModel<Integer> a : model.getPriority().getItems()) {
        int p = a.getEntity();
        if (p == roundPriority) {
            priority = a;
            break;
        }
    }
    ((UnitVmModel) model.getWindow()).getPriority().setSelectedItem(priority);
}
#method_after
private void updatePriority(UnitVmModel model) {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    VM vm = (VM) selectedItem.getEntity();
    int roundPriority = AsyncDataProvider.getInstance().getRoundedPriority(vm.getPriority(), cachedMaxPriority);
    EntityModel<Integer> priority = null;
    for (EntityModel<Integer> a : model.getPriority().getItems()) {
        int p = a.getEntity();
        if (p == roundPriority) {
            priority = a;
            break;
        }
    }
    ((UnitVmModel) model.getWindow()).getPriority().setSelectedItem(priority);
}
#end_block

#method_before
private boolean updateRngDevice() {
    // do not update if this flag is not set
    if (getParameters().isUpdateRngDevice()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
        @SuppressWarnings("unchecked")
        List<VmRngDevice> rngDevs = query.getReturnValue();
        VdcReturnValueBase rngCommandResult = null;
        if (rngDevs.isEmpty()) {
            if (getParameters().getRngDevice() != null) {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                rngCommandResult = getBackend().runInternalAction(VdcActionType.AddRngDevice, params);
            }
        } else {
            if (getParameters().getRngDevice() == null) {
                RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
                rngCommandResult = getBackend().runInternalAction(VdcActionType.RemoveRngDevice, params);
            } else {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
                rngCommandResult = getBackend().runInternalAction(VdcActionType.UpdateRngDevice, params);
            }
        }
        if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean updateRngDevice() {
    // do not update if this flag is not set
    if (getParameters().isUpdateRngDevice()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
        @SuppressWarnings("unchecked")
        List<VmRngDevice> rngDevs = query.getReturnValue();
        VdcReturnValueBase rngCommandResult = null;
        if (rngDevs.isEmpty()) {
            if (getParameters().getRngDevice() != null) {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                rngCommandResult = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
            }
        } else {
            if (getParameters().getRngDevice() == null) {
                RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
                rngCommandResult = runInternalAction(VdcActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
            } else {
                RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
                params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
                rngCommandResult = runInternalAction(VdcActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
            }
        }
        if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void hotSetCpus(int cpuPerSocket) {
    int currentSockets = getVm().getNumOfSockets();
    int newSockets = newVmStatic.getNumOfSockets();
    int currentCpuPerSocket = getVm().getCpuPerSocket();
    // try hotplug only if topology (cpuPerSocket) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && currentSockets != newSockets && currentCpuPerSocket == cpuPerSocket) {
        HotSetNumerOfCpusParameters params = new HotSetNumerOfCpusParameters(newVmStatic, currentSockets < newSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = getBackend().runInternalAction(VdcActionType.HotSetNumberOfCpus, params);
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newSockets : currentSockets);
        auditLogHotSetCpusCandos(params);
    }
}
#method_after
private void hotSetCpus(int cpuPerSocket) {
    int currentSockets = getVm().getNumOfSockets();
    int newSockets = newVmStatic.getNumOfSockets();
    int currentCpuPerSocket = getVm().getCpuPerSocket();
    // try hotplug only if topology (cpuPerSocket) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && currentSockets != newSockets && currentCpuPerSocket == cpuPerSocket) {
        HotSetNumerOfCpusParameters params = new HotSetNumerOfCpusParameters(newVmStatic, currentSockets < newSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newSockets : currentSockets);
        auditLogHotSetCpusCandos(params);
    }
}
#end_block

#method_before
private void updateWatchdog() {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getParameters().getVmId()));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty()) {
            if (getParameters().getWatchdog() == null) {
            // nothing to do, no watchdog and no watchdog to create
            } else {
                WatchdogParameters parameters = new WatchdogParameters();
                parameters.setId(getParameters().getVmId());
                parameters.setAction(getParameters().getWatchdog().getAction());
                parameters.setModel(getParameters().getWatchdog().getModel());
                getBackend().runInternalAction(VdcActionType.AddWatchdog, parameters);
            }
        } else {
            WatchdogParameters watchdogParameters = new WatchdogParameters();
            watchdogParameters.setId(getParameters().getVmId());
            if (getParameters().getWatchdog() == null) {
                // there is a watchdog in the vm, there should not be any, so let's delete
                getBackend().runInternalAction(VdcActionType.RemoveWatchdog, watchdogParameters);
            } else {
                // there is a watchdog in the vm, we have to update.
                watchdogParameters.setAction(getParameters().getWatchdog().getAction());
                watchdogParameters.setModel(getParameters().getWatchdog().getModel());
                getBackend().runInternalAction(VdcActionType.UpdateWatchdog, watchdogParameters);
            }
        }
    }
}
#method_after
private void updateWatchdog() {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getParameters().getVmId()));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty()) {
            if (getParameters().getWatchdog() == null) {
            // nothing to do, no watchdog and no watchdog to create
            } else {
                WatchdogParameters parameters = new WatchdogParameters();
                parameters.setId(getParameters().getVmId());
                parameters.setAction(getParameters().getWatchdog().getAction());
                parameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
            }
        } else {
            WatchdogParameters watchdogParameters = new WatchdogParameters();
            watchdogParameters.setId(getParameters().getVmId());
            if (getParameters().getWatchdog() == null) {
                // there is a watchdog in the vm, there should not be any, so let's delete
                runInternalAction(VdcActionType.RemoveWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            } else {
                // there is a watchdog in the vm, we have to update.
                watchdogParameters.setAction(getParameters().getWatchdog().getAction());
                watchdogParameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.UpdateWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(getVmId(), VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device console");
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(getVmId(), VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device sound");
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(getVmId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName(), getParameters().isVirtioScsiEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device VirtIO-SCSI");
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getcompatibility_version()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(getVmId(), VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device console");
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(getVmId(), VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device sound");
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(getVmId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName(), getParameters().isVirtioScsiEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device VirtIO-SCSI");
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#end_block

#method_before
private void getAttachedTagsToSelectedVMs(TagListModel model) {
    ArrayList<Guid> vmIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    attachedTagsToEntities = new HashMap<Guid, Boolean>();
    allAttachedTags = new ArrayList<Tags>();
    selectedItemsCounter = 0;
    for (Guid id : vmIds) {
        AsyncDataProvider.getAttachedTagsToVm(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                VmListModel vmListModel = (VmListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                vmListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                vmListModel.selectedItemsCounter++;
                if (vmListModel.selectedItemsCounter == vmListModel.getSelectedItems().size()) {
                    postGetAttachedTags(vmListModel, tagListModel);
                }
            }
        }), id);
    }
}
#method_after
private void getAttachedTagsToSelectedVMs(TagListModel model) {
    ArrayList<Guid> vmIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        vmIds.add(vm.getId());
    }
    attachedTagsToEntities = new HashMap<Guid, Boolean>();
    allAttachedTags = new ArrayList<Tags>();
    selectedItemsCounter = 0;
    for (Guid id : vmIds) {
        AsyncDataProvider.getInstance().getAttachedTagsToVm(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                VmListModel vmListModel = (VmListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                vmListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                vmListModel.selectedItemsCounter++;
                if (vmListModel.selectedItemsCounter == vmListModel.getSelectedItems().size()) {
                    postGetAttachedTags(vmListModel, tagListModel);
                }
            }
        }), id);
    }
}
#end_block

#method_before
private void guide() {
    VmGuideModel model = new VmGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVirtualMachineGuideMeTitle());
    model.setHelpTag(HelpTag.new_virtual_machine___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_virtual_machine_-_guide_me");
    if (getGuideContext() == null) {
        VM vm = (VM) getSelectedItem();
        setGuideContext(vm.getId());
    }
    AsyncDataProvider.getVmById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            VmGuideModel model = (VmGuideModel) vmListModel.getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", vmListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
private void guide() {
    VmGuideModel model = new VmGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVirtualMachineGuideMeTitle());
    model.setHelpTag(HelpTag.new_virtual_machine___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_virtual_machine_-_guide_me");
    if (getGuideContext() == null) {
        VM vm = (VM) getSelectedItem();
        setGuideContext(vm.getId());
    }
    AsyncDataProvider.getInstance().getVmById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            VmGuideModel model = (VmGuideModel) vmListModel.getWindow();
            model.setEntity(returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", vmListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(AsyncDataProvider.getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void edit() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            editedVm = (VM) result;
            vmInitLoaded(editedVm);
        }
    };
    if (vm.isNextRunConfigurationExists()) {
        AsyncDataProvider.getVmNextRunConfiguration(getVmInitQuery, vm.getId());
    } else {
        AsyncDataProvider.getVmById(getVmInitQuery, vm.getId());
    }
}
#method_after
private void edit() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            editedVm = (VM) result;
            vmInitLoaded(editedVm);
        }
    };
    if (vm.isNextRunConfigurationExists()) {
        AsyncDataProvider.getInstance().getVmNextRunConfiguration(getVmInitQuery, vm.getId());
    } else {
        AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
    }
}
#end_block

#method_before
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(AsyncDataProvider.getCustomPropertiesList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("OnSave", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
}
#method_after
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(AsyncDataProvider.getInstance().getCustomPropertiesList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("OnSave", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
}
#end_block

#method_before
private void getTemplatesNotPresentOnExportDomain() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    AsyncDataProvider.getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            ArrayList<StoragePool> storagePools = (ArrayList<StoragePool>) returnValue;
            StoragePool storagePool = storagePools.size() > 0 ? storagePools.get(0) : null;
            vmListModel.postGetTemplatesNotPresentOnExportDomain(storagePool);
        }
    }), storageDomainId);
}
#method_after
private void getTemplatesNotPresentOnExportDomain() {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    AsyncDataProvider.getInstance().getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            ArrayList<StoragePool> storagePools = (ArrayList<StoragePool>) returnValue;
            StoragePool storagePool = storagePools.size() > 0 ? storagePools.get(0) : null;
            vmListModel.postGetTemplatesNotPresentOnExportDomain(storagePool);
        }
    }), storageDomainId);
}
#end_block

#method_before
private void postGetTemplatesNotPresentOnExportDomain(StoragePool storagePool) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    if (storagePool != null) {
        AsyncDataProvider.getAllTemplatesFromExportDomain(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                HashMap<VmTemplate, ArrayList<DiskImage>> templatesDiskSet = (HashMap<VmTemplate, ArrayList<DiskImage>>) returnValue;
                HashMap<String, ArrayList<String>> templateDic = new HashMap<String, ArrayList<String>>();
                // check if relevant templates are already there
                for (Object selectedItem : vmListModel.getSelectedItems()) {
                    VM vm = (VM) selectedItem;
                    boolean hasMatch = false;
                    for (VmTemplate a : templatesDiskSet.keySet()) {
                        if (vm.getVmtGuid().equals(a.getId())) {
                            hasMatch = true;
                            break;
                        }
                    }
                    if (!vm.getVmtGuid().equals(Guid.Empty) && !hasMatch) {
                        if (!templateDic.containsKey(vm.getVmtName())) {
                            templateDic.put(vm.getVmtName(), new ArrayList<String>());
                        }
                        templateDic.get(vm.getVmtName()).add(vm.getName());
                    }
                }
                String tempStr;
                ArrayList<String> tempList;
                ArrayList<String> missingTemplates = new ArrayList<String>();
                for (Map.Entry<String, ArrayList<String>> keyValuePair : templateDic.entrySet()) {
                    tempList = keyValuePair.getValue();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    StringBuilder sb = new StringBuilder("Template " + keyValuePair.getKey() + " (for ");
                    int i;
                    for (i = 0; i < tempList.size() - 1; i++) {
                        sb.append(tempList.get(i));
                        // $NON-NLS-1$
                        sb.append(", ");
                    }
                    sb.append(tempList.get(i));
                    // $NON-NLS-1$
                    sb.append(")");
                    missingTemplates.add(sb.toString());
                }
                vmListModel.postExportGetMissingTemplates(missingTemplates);
            }
        }), storagePool.getId(), storageDomainId);
    }
}
#method_after
private void postGetTemplatesNotPresentOnExportDomain(StoragePool storagePool) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    if (storagePool != null) {
        AsyncDataProvider.getInstance().getAllTemplatesFromExportDomain(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                HashMap<VmTemplate, ArrayList<DiskImage>> templatesDiskSet = (HashMap<VmTemplate, ArrayList<DiskImage>>) returnValue;
                HashMap<String, ArrayList<String>> templateDic = new HashMap<String, ArrayList<String>>();
                // check if relevant templates are already there
                for (Object selectedItem : vmListModel.getSelectedItems()) {
                    VM vm = (VM) selectedItem;
                    boolean hasMatch = false;
                    for (VmTemplate a : templatesDiskSet.keySet()) {
                        if (vm.getVmtGuid().equals(a.getId())) {
                            hasMatch = true;
                            break;
                        }
                    }
                    if (!vm.getVmtGuid().equals(Guid.Empty) && !hasMatch) {
                        if (!templateDic.containsKey(vm.getVmtName())) {
                            templateDic.put(vm.getVmtName(), new ArrayList<String>());
                        }
                        templateDic.get(vm.getVmtName()).add(vm.getName());
                    }
                }
                String tempStr;
                ArrayList<String> tempList;
                ArrayList<String> missingTemplates = new ArrayList<String>();
                for (Map.Entry<String, ArrayList<String>> keyValuePair : templateDic.entrySet()) {
                    tempList = keyValuePair.getValue();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    StringBuilder sb = new StringBuilder("Template " + keyValuePair.getKey() + " (for ");
                    int i;
                    for (i = 0; i < tempList.size() - 1; i++) {
                        sb.append(tempList.get(i));
                        // $NON-NLS-1$
                        sb.append(", ");
                    }
                    sb.append(tempList.get(i));
                    // $NON-NLS-1$
                    sb.append(")");
                    missingTemplates.add(sb.toString());
                }
                vmListModel.postExportGetMissingTemplates(missingTemplates);
            }
        }), storagePool.getId(), storageDomainId);
    }
}
#end_block

#method_before
@Override
protected void sendWarningForNonExportableDisks(VM entity) {
    // load VM disks and check if there is one which doesn't allow snapshot
    AsyncDataProvider.getVmDiskList(new AsyncQuery(getWindow(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final ExportVmModel model = (ExportVmModel) target;
            @SuppressWarnings("unchecked")
            final ArrayList<Disk> vmDisks = (ArrayList<Disk>) returnValue;
            VmModelHelper.sendWarningForNonExportableDisks(model, vmDisks, VmModelHelper.WarningType.VM_EXPORT);
        }
    }), entity.getId());
}
#method_after
@Override
protected void sendWarningForNonExportableDisks(VM entity) {
    // load VM disks and check if there is one which doesn't allow snapshot
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(getWindow(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final ExportVmModel model = (ExportVmModel) target;
            @SuppressWarnings("unchecked")
            final ArrayList<Disk> vmDisks = (ArrayList<Disk>) returnValue;
            VmModelHelper.sendWarningForNonExportableDisks(model, vmDisks, VmModelHelper.WarningType.VM_EXPORT);
        }
    }), entity.getId());
}
#end_block

#method_before
private void runOnce() {
    VM vm = (VM) getSelectedItem();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            RunOnceModel runOnceModel = new WebadminRunOnceModel((VM) result, VmListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    };
    AsyncDataProvider.getVmById(getVmInitQuery, vm.getId());
}
#method_after
private void runOnce() {
    VM vm = (VM) getSelectedItem();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            RunOnceModel runOnceModel = new WebadminRunOnceModel((VM) result, VmListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    };
    AsyncDataProvider.getInstance().getVmById(getVmInitQuery, vm.getId());
}
#end_block

#method_before
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name);
    }
}
#method_after
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.getInstance().isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name);
    }
}
#end_block

#method_before
private void migrate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MigrateModel model = new MigrateModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().migrateVirtualMachinesTitle());
    model.setHelpTag(HelpTag.migrate_virtual_machine);
    // $NON-NLS-1$
    model.setHashName("migrate_virtual_machine");
    model.setVmsOnSameCluster(true);
    model.setIsAutoSelect(true);
    model.setVmList(Linq.<VM>cast(getSelectedItems()));
    AsyncDataProvider.getUpHostListByCluster(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            vmListModel.postMigrateGetUpHosts((ArrayList<VDS>) returnValue);
        }
    }), vm.getVdsGroupName());
}
#method_after
private void migrate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MigrateModel model = new MigrateModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().migrateVirtualMachinesTitle());
    model.setHelpTag(HelpTag.migrate_virtual_machine);
    // $NON-NLS-1$
    model.setHashName("migrate_virtual_machine");
    model.setVmsOnSameCluster(true);
    model.setIsAutoSelect(true);
    model.setVmList(Linq.<VM>cast(getSelectedItems()));
    AsyncDataProvider.getInstance().getUpHostListByCluster(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            vmListModel.postMigrateGetUpHosts((ArrayList<VDS>) returnValue);
        }
    }), vm.getVdsGroupName());
}
#end_block

#method_before
private void powerAction(final String actionName, final String title, final String message) {
    Guid clusterId = getClusterIdOfSelectedVms();
    if (clusterId == null) {
        powerAction(actionName, title, message, false);
    } else {
        AsyncDataProvider.getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null) {
                    powerAction(actionName, title, message, cluster.isOptionalReasonRequired());
                }
            }
        }), clusterId);
    }
}
#method_after
private void powerAction(final String actionName, final String title, final String message) {
    Guid clusterId = getClusterIdOfSelectedVms();
    if (clusterId == null) {
        powerAction(actionName, title, message, false);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null) {
                    powerAction(actionName, title, message, cluster.isOptionalReasonRequired());
                }
            }
        }), clusterId);
    }
}
#end_block

#method_before
private void powerAction(String actionName, String title, String message, boolean reasonVisible) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    model.setReasonVisible(reasonVisible);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void powerAction(String actionName, String title, String message, boolean reasonVisible) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    model.setReasonVisible(reasonVisible);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    ArrayList<String> items = new ArrayList<String>();
    boolean stoppingSingleVM = getSelectedItems().size() == 1 && (actionName.equals(SHUTDOWN) || actionName.equals(STOP));
    for (Object item : getSelectedItems()) {
        VM vm = (VM) item;
        items.add(vm.getName());
        // is populated with the current reason so the user can edit it.
        if (stoppingSingleVM && reasonVisible && VMStatus.PoweringDown.equals(vm.getStatus())) {
            model.getReason().setEntity(vm.getStopReason());
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void changeCD() {
    final VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrDefault(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void changeCD() {
    final VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrDefault(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    };
    AsyncDataProvider.getInstance().getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void preSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    final String name = model.getName().getEntity();
    if (model.getIsNew() == false && selectedItem == null) {
        cancel();
        return;
    }
    setcurrentVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem));
    if (!model.validate()) {
        return;
    }
    AsyncDataProvider.isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            if (!(Boolean) returnValue && name.compareToIgnoreCase(getcurrentVm().getName()) != 0) {
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setIsGeneralTabValid(false);
            } else {
                model.getName().getInvalidityReasons().clear();
                model.getName().setIsValid(true);
                model.setIsGeneralTabValid(true);
                onSave();
            }
        }
    }), name);
}
#method_after
private void preSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    final String name = model.getName().getEntity();
    if (model.getIsNew() == false && selectedItem == null) {
        cancel();
        return;
    }
    setcurrentVm(model.getIsNew() ? new VM() : (VM) Cloner.clone(selectedItem));
    if (!model.validate()) {
        return;
    }
    AsyncDataProvider.getInstance().isVmNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            if (!(Boolean) returnValue && name.compareToIgnoreCase(getcurrentVm().getName()) != 0) {
                model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                model.getName().setIsValid(false);
                model.setIsGeneralTabValid(false);
            } else {
                model.getName().getInvalidityReasons().clear();
                model.getName().setIsValid(true);
                model.setIsGeneralTabValid(true);
                onSave();
            }
        }
    }), name);
}
#end_block

#method_before
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        final VM selectedItem = (VM) getSelectedItem();
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        getcurrentVm().setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.isNextRunConfigurationChanged(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    if (((VdcQueryReturnValue) returnValue).<Boolean>getReturnValue()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == getcurrentVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != getcurrentVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("CancelConfirmation", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(false);
                    }
                }
            }));
        } else {
            updateExistingVm(false);
        }
    }
}
#method_after
private void onSave() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        final VM selectedItem = (VM) getSelectedItem();
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        getcurrentVm().setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
        if (selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().isNextRunConfigurationChanged(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object thisModel, Object returnValue) {
                    if (((VdcQueryReturnValue) returnValue).<Boolean>getReturnValue()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == getcurrentVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != getcurrentVm().getNumOfSockets());
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("CancelConfirmation", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(false);
                    }
                }
            }));
        } else {
            updateExistingVm(false);
        }
    }
}
#end_block

#method_before
private void saveNewVm(final UnitVmModel model) {
    if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
        if (model.getProgress() != null) {
            return;
        }
        VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

            @Override
            public void vnicCreated(Guid vmId) {
            // do nothing
            }

            @Override
            public void queryFailed() {
            // do nothing
            }
        });
        model.startProgress(null);
        AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
        parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
        parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
        parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
        parameters.setBalloonEnabled(balloonEnabled(model));
        setVmWatchdogToParams(model, parameters);
        setRngDeviceToParams(model, parameters);
        Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager) {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                getWindow().stopProgress();
                VdcReturnValueBase returnValue = result.getReturnValue();
                if (returnValue != null && returnValue.getSucceeded()) {
                    setWindow(null);
                    setGuideContext(returnValue.getActionReturnValue());
                    updateActionAvailability();
                    getGuideCommand().execute();
                } else {
                    cancel();
                }
                super.executed(result);
            }
        }, this);
    } else {
        if (model.getProgress() != null) {
            return;
        }
        if (model.getProvisioning().getEntity()) {
            model.startProgress(null);
            AsyncQuery _asyncQuery = new AsyncQuery();
            _asyncQuery.setModel(this);
            _asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    VmListModel vmListModel = (VmListModel) model1;
                    UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                    VM vm = vmListModel.getcurrentVm();
                    vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                    AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vm, unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                    param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                    param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                    param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                    param.setBalloonEnabled(balloonEnabled(model));
                    param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                    setRngDeviceToParams(model, param);
                    Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                }
            };
            AsyncDataProvider.getTemplateDiskList(_asyncQuery, getcurrentVm().getVmtGuid());
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VM vm = getcurrentVm();
            vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
            VmManagementParametersBase params = new VmManagementParametersBase(vm);
            params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
            params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            params.setBalloonEnabled(balloonEnabled(model));
            params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
            ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
            parameters.add(params);
            params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            setVmWatchdogToParams(model, params);
            setRngDeviceToParams(model, params);
            Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
        }
    }
}
#method_after
private void saveNewVm(final UnitVmModel model) {
    if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
        if (model.getProgress() != null) {
            return;
        }
        VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

            @Override
            public void vnicCreated(Guid vmId) {
            // do nothing
            }

            @Override
            public void queryFailed() {
            // do nothing
            }
        });
        model.startProgress(null);
        AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
        parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
        parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
        parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
        parameters.setBalloonEnabled(balloonEnabled(model));
        setVmWatchdogToParams(model, parameters);
        setRngDeviceToParams(model, parameters);
        Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager) {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                getWindow().stopProgress();
                VdcReturnValueBase returnValue = result.getReturnValue();
                if (returnValue != null && returnValue.getSucceeded()) {
                    setWindow(null);
                    setGuideContext(returnValue.getActionReturnValue());
                    updateActionAvailability();
                    getGuideCommand().execute();
                } else {
                    cancel();
                }
                super.executed(result);
            }
        }, this);
    } else {
        if (model.getProgress() != null) {
            return;
        }
        if (model.getProvisioning().getEntity()) {
            model.startProgress(null);
            AsyncQuery _asyncQuery = new AsyncQuery();
            _asyncQuery.setModel(this);
            _asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    VmListModel vmListModel = (VmListModel) model1;
                    UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                    VM vm = vmListModel.getcurrentVm();
                    vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                    AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vm, unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                    param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                    param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                    param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                    param.setBalloonEnabled(balloonEnabled(model));
                    param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                    setRngDeviceToParams(model, param);
                    Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                }
            };
            AsyncDataProvider.getInstance().getTemplateDiskList(_asyncQuery, getcurrentVm().getVmtGuid());
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VM vm = getcurrentVm();
            vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
            VmManagementParametersBase params = new VmManagementParametersBase(vm);
            params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
            params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            params.setBalloonEnabled(balloonEnabled(model));
            params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
            ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
            parameters.add(params);
            params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            setVmWatchdogToParams(model, params);
            setRngDeviceToParams(model, params);
            Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
        }
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getCloneVmCommand().setIsExecutionAllowed(items.size() == 1);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.HibernateVm) && AsyncDataProvider.canVmsBePaused(items));
    getShutdownCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#method_after
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getCloneVmCommand().setIsExecutionAllowed(items.size() == 1);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.HibernateVm) && AsyncDataProvider.getInstance().canVmsBePaused(items));
    getShutdownCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.getInstance().isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#end_block

#method_before
public static boolean vmDeviceChanged(Guid vmId, VmDeviceGeneralType deviceType, String device, boolean deviceEnabled) {
    List<VmDevice> vmDevices = dao.getVmDeviceByVmIdTypeAndDevice(vmId, deviceType, device);
    return deviceEnabled == vmDevices.isEmpty();
}
#method_after
public static boolean vmDeviceChanged(Guid vmId, VmDeviceGeneralType deviceType, String device, boolean deviceEnabled) {
    List<VmDevice> vmDevices = device != null ? dao.getVmDeviceByVmIdTypeAndDevice(vmId, deviceType, device) : dao.getVmDeviceByVmIdAndType(vmId, deviceType);
    return deviceEnabled == vmDevices.isEmpty();
}
#end_block

#method_before
public static boolean vmDeviceChanged(Guid vmId, VmDeviceGeneralType deviceType, boolean deviceEnabled) {
    List<VmDevice> vmDevices = dao.getVmDeviceByVmIdAndType(vmId, deviceType);
    return deviceEnabled == vmDevices.isEmpty();
}
#method_after
public static boolean vmDeviceChanged(Guid vmId, VmDeviceGeneralType deviceType, boolean deviceEnabled) {
    return vmDeviceChanged(vmId, deviceType, null, deviceEnabled);
}
#end_block

#method_before
public static String getDefaultConfigurationVersion() {
    return _defaultConfigurationVersion;
}
#method_after
public String getDefaultConfigurationVersion() {
    return _defaultConfigurationVersion;
}
#end_block

#method_before
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initCustomPropertiesList();
}
#method_after
public void initCache(LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initCustomPropertiesList();
}
#end_block

#method_before
private static void initCustomPropertiesList() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            customPropertiesList = (Map<Version, Map<String, String>>) returnValue;
        }
    };
    callback.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return (source != null) ? (Map<Version, Map<String, String>>) source : new HashMap<Version, Map<String, String>>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase().withoutRefresh(), callback);
}
#method_after
private void initCustomPropertiesList() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            customPropertiesList = (Map<Version, Map<String, String>>) returnValue;
        }
    };
    callback.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return (source != null) ? (Map<Version, Map<String, String>>) source : new HashMap<Version, Map<String, String>>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase().withoutRefresh(), callback);
}
#end_block

#method_before
public static void initDefaultOSes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            defaultOSes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDefaultOSes), callback);
}
#method_after
public void initDefaultOSes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            defaultOSes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDefaultOSes), callback);
}
#end_block

#method_before
public static Boolean isMigrationSupported(ArchitectureType architecture, Version version) {
    return migrationSupport.get(architecture).get(version);
}
#method_after
public Boolean isMigrationSupported(ArchitectureType architecture, Version version) {
    return migrationSupport.get(architecture).get(version);
}
#end_block

#method_before
public static Boolean isMemorySnapshotSupportedByArchitecture(ArchitectureType architecture, Version version) {
    return memorySnapshotSupport.get(architecture).get(version);
}
#method_after
public Boolean isMemorySnapshotSupportedByArchitecture(ArchitectureType architecture, Version version) {
    return memorySnapshotSupport.get(architecture).get(version);
}
#end_block

#method_before
public static Boolean isSuspendSupportedByArchitecture(ArchitectureType architecture, Version version) {
    return suspendSupport.get(architecture).get(version);
}
#method_after
public Boolean isSuspendSupportedByArchitecture(ArchitectureType architecture, Version version) {
    return suspendSupport.get(architecture).get(version);
}
#end_block

#method_before
private static void initMigrationSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            migrationSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMigrationSupport), callback);
}
#method_after
private void initMigrationSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            migrationSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMigrationSupport), callback);
}
#end_block

#method_before
private static void initMemorySnapshotSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            memorySnapshotSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMemorySnapshotSupport), callback);
}
#method_after
private void initMemorySnapshotSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            memorySnapshotSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetMemorySnapshotSupport), callback);
}
#end_block

#method_before
private static void initSuspendSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            suspendSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetSuspendSupport), callback);
}
#method_after
private void initSuspendSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            suspendSupport = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetArchitectureCapabilities, new ArchCapabilitiesParameters(ArchCapabilitiesVerb.GetSuspendSupport), callback);
}
#end_block

#method_before
public static boolean isMemorySnapshotSupported(VM vm) {
    if (vm == null) {
        return false;
    }
    boolean archMemorySnapshotSupported = isMemorySnapshotSupportedByArchitecture(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion());
    return ((Boolean) getConfigValuePreConverted(ConfigurationValues.MemorySnapshotSupported, vm.getVdsGroupCompatibilityVersion().toString())) && archMemorySnapshotSupported;
}
#method_after
public boolean isMemorySnapshotSupported(VM vm) {
    if (vm == null) {
        return false;
    }
    boolean archMemorySnapshotSupported = isMemorySnapshotSupportedByArchitecture(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion());
    return ((Boolean) getConfigValuePreConverted(ConfigurationValues.MemorySnapshotSupported, vm.getVdsGroupCompatibilityVersion().toString())) && archMemorySnapshotSupported;
}
#end_block

#method_before
public static boolean canVmsBePaused(List<VM> items) {
    for (VM vm : items) {
        if (!AsyncDataProvider.isSuspendSupportedByArchitecture(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion())) {
            return false;
        }
    }
    return true;
}
#method_after
public boolean canVmsBePaused(List<VM> items) {
    for (VM vm : items) {
        if (!isSuspendSupportedByArchitecture(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public static boolean isLiveMergeSupported(VM vm) {
    return (vm != null && (Boolean) getConfigValuePreConverted(ConfigurationValues.LiveMergeSupported, vm.getVdsGroupCompatibilityVersion().toString()));
}
#method_after
public boolean isLiveMergeSupported(VM vm) {
    return (vm != null && (Boolean) getConfigValuePreConverted(ConfigurationValues.LiveMergeSupported, vm.getVdsGroupCompatibilityVersion().toString()));
}
#end_block

#method_before
public static void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#method_after
public void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#end_block

#method_before
public static Map<Pair<Integer, Version>, Boolean> getNicHotplugSupportMap() {
    return nicHotplugSupportMap;
}
#method_after
public Map<Pair<Integer, Version>, Boolean> getNicHotplugSupportMap() {
    return nicHotplugSupportMap;
}
#end_block

#method_before
public static Boolean getNicHotplugSupport(Integer osId, Version version) {
    Pair<Integer, Version> pair = new Pair<Integer, Version>(osId, version);
    if (getNicHotplugSupportMap().containsKey(pair)) {
        return getNicHotplugSupportMap().get(pair);
    }
    return false;
}
#method_after
public Boolean getNicHotplugSupport(Integer osId, Version version) {
    Pair<Integer, Version> pair = new Pair<Integer, Version>(osId, version);
    if (getNicHotplugSupportMap().containsKey(pair)) {
        return getNicHotplugSupportMap().get(pair);
    }
    return false;
}
#end_block

#method_before
public static void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#method_after
public void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#end_block

#method_before
public static Map<Pair<Integer, Version>, Set<String>> getDiskHotpluggableInterfacesMap() {
    return diskHotpluggableInterfacesMap;
}
#method_after
public Map<Pair<Integer, Version>, Set<String>> getDiskHotpluggableInterfacesMap() {
    return diskHotpluggableInterfacesMap;
}
#end_block

#method_before
public static Collection<DiskInterface> getDiskHotpluggableInterfaces(Integer osId, Version version) {
    Set<String> diskHotpluggableInterfaces = getDiskHotpluggableInterfacesMap().get(new Pair<Integer, Version>(osId, version));
    if (diskHotpluggableInterfaces == null) {
        return Collections.emptySet();
    }
    Collection<DiskInterface> diskInterfaces = new HashSet<DiskInterface>();
    for (String diskHotpluggableInterface : diskHotpluggableInterfaces) {
        diskInterfaces.add(DiskInterface.valueOf(diskHotpluggableInterface));
    }
    return diskInterfaces;
}
#method_after
public Collection<DiskInterface> getDiskHotpluggableInterfaces(Integer osId, Version version) {
    Set<String> diskHotpluggableInterfaces = getDiskHotpluggableInterfacesMap().get(new Pair<Integer, Version>(osId, version));
    if (diskHotpluggableInterfaces == null) {
        return Collections.emptySet();
    }
    Collection<DiskInterface> diskInterfaces = new HashSet<DiskInterface>();
    for (String diskHotpluggableInterface : diskHotpluggableInterfaces) {
        diskInterfaces.add(DiskInterface.valueOf(diskHotpluggableInterface));
    }
    return diskInterfaces;
}
#end_block

#method_before
public static void getAAAProfilesListViaPublic(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<String>((ArrayList<String>) source) : new ArrayList<String>();
        }
    };
    Frontend.getInstance().runPublicQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getAAAProfilesListViaPublic(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<String>((ArrayList<String>) source) : new ArrayList<String>();
        }
    };
    Frontend.getInstance().runPublicQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void getIsoDomainByDataCenterId(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                for (StorageDomain domain : storageDomains) {
                    if (domain.getStorageDomainType() == StorageDomainType.ISO) {
                        return domain;
                    }
                }
            }
            return null;
        }
    };
    IdQueryParameters getIsoParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getIsoParams, aQuery);
}
#method_after
public void getIsoDomainByDataCenterId(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                for (StorageDomain domain : storageDomains) {
                    if (domain.getStorageDomainType() == StorageDomainType.ISO) {
                        return domain;
                    }
                }
            }
            return null;
        }
    };
    IdQueryParameters getIsoParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getIsoParams, aQuery);
}
#end_block

#method_before
public static void getExportDomainByDataCenterId(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
            for (StorageDomain domain : storageDomains) {
                if (domain.getStorageDomainType() == StorageDomainType.ImportExport) {
                    return domain;
                }
            }
            return null;
        }
    };
    IdQueryParameters getExportParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getExportParams, aQuery);
}
#method_after
public void getExportDomainByDataCenterId(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
            for (StorageDomain domain : storageDomains) {
                if (domain.getStorageDomainType() == StorageDomainType.ImportExport) {
                    return domain;
                }
            }
            return null;
        }
    };
    IdQueryParameters getExportParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getExportParams, aQuery);
}
#end_block

#method_before
public static void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId) {
    getIrsImageList(aQuery, storagePoolId, false);
}
#method_after
public void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId) {
    getIrsImageList(aQuery, storagePoolId, false);
}
#end_block

#method_before
public static void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId, boolean forceRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
                ArrayList<String> fileNameList = new ArrayList<String>();
                for (RepoImage repoImage : repoList) {
                    fileNameList.add(repoImage.getRepoImageId());
                }
                Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
                return fileNameList;
            }
            return new ArrayList<String>();
        }
    };
    GetImagesListByStoragePoolIdParameters parameters = new GetImagesListByStoragePoolIdParameters(storagePoolId, ImageFileType.ISO);
    parameters.setForceRefresh(forceRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, parameters, aQuery);
}
#method_after
public void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId, boolean forceRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
                ArrayList<String> fileNameList = new ArrayList<String>();
                for (RepoImage repoImage : repoList) {
                    fileNameList.add(repoImage.getRepoImageId());
                }
                Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
                return fileNameList;
            }
            return new ArrayList<String>();
        }
    };
    GetImagesListByStoragePoolIdParameters parameters = new GetImagesListByStoragePoolIdParameters(storagePoolId, ImageFileType.ISO);
    parameters.setForceRefresh(forceRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, parameters, aQuery);
}
#end_block

#method_before
public static void getFloppyImageList(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
                ArrayList<String> fileNameList = new ArrayList<String>();
                for (RepoImage repoImage : repoList) {
                    fileNameList.add(repoImage.getRepoImageId());
                }
                Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
                return fileNameList;
            }
            return new ArrayList<String>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, new GetImagesListByStoragePoolIdParameters(storagePoolId, ImageFileType.Floppy), aQuery);
}
#method_after
public void getFloppyImageList(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
                ArrayList<String> fileNameList = new ArrayList<String>();
                for (RepoImage repoImage : repoList) {
                    fileNameList.add(repoImage.getRepoImageId());
                }
                Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
                return fileNameList;
            }
            return new ArrayList<String>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, new GetImagesListByStoragePoolIdParameters(storagePoolId, ImageFileType.Floppy), aQuery);
}
#end_block

#method_before
public static void isClusterEmpty(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter<Boolean>() {

        @Override
        public Boolean Convert(Object source, AsyncQuery _asyncQuery) {
            return (Boolean) source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsClusterEmpty, new IdQueryParameters(id), aQuery);
}
#method_after
public void isClusterEmpty(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter<Boolean>() {

        @Override
        public Boolean Convert(Object source, AsyncQuery _asyncQuery) {
            return (Boolean) source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsClusterEmpty, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getHostArchitecture(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter<ArchitectureType>() {

        @Override
        public ArchitectureType Convert(Object source, AsyncQuery _asyncQuery) {
            return (ArchitectureType) source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostArchitecture, new IdQueryParameters(id), aQuery);
}
#method_after
public void getHostArchitecture(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter<ArchitectureType>() {

        @Override
        public ArchitectureType Convert(Object source, AsyncQuery _asyncQuery) {
            return (ArchitectureType) source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostArchitecture, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getClusterById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupById, new IdQueryParameters(id), aQuery);
}
#method_after
public void getClusterById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupById, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getClusterListByName(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDSGroup>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Cluster: name=" + name + " sortby name", SearchType.Cluster), aQuery);
}
#method_after
public void getClusterListByName(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDSGroup>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Cluster: name=" + name + " sortby name", SearchType.Cluster), aQuery);
}
#end_block

#method_before
public static void getPoolById(AsyncQuery aQuery, Guid poolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmPoolById, new IdQueryParameters(poolId), aQuery);
}
#method_after
public void getPoolById(AsyncQuery aQuery, Guid poolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmPoolById, new IdQueryParameters(poolId), aQuery);
}
#end_block

#method_before
public static void getVmById(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmByVmId, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getVmById(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmByVmId, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void getVmNextRunConfiguration(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getVmNextRunConfiguration(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void isNextRunConfigurationChanged(VM original, VM updated, VmManagementParametersBase updateVmParameters, AsyncQuery aQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmUpdatesOnNextRunExists, new GetVmUpdatesOnNextRunExistsParameters(original, updated, updateVmParameters), aQuery);
}
#method_after
public void isNextRunConfigurationChanged(VM original, VM updated, VmManagementParametersBase updateVmParameters, AsyncQuery aQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmUpdatesOnNextRunExists, new GetVmUpdatesOnNextRunExistsParameters(original, updated, updateVmParameters), aQuery);
}
#end_block

#method_before
public static void getDataCenterList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$
    new SearchParameters("DataCenter: sortby name", SearchType.StoragePool), aQuery);
}
#method_after
public void getDataCenterList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$
    new SearchParameters("DataCenter: sortby name", SearchType.StoragePool), aQuery);
}
#end_block

#method_before
public static void getDataCenterByClusterServiceList(AsyncQuery aQuery, boolean supportsVirtService, boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            // sort data centers
            final ArrayList<StoragePool> storagePoolList = (ArrayList<StoragePool>) source;
            Collections.sort(storagePoolList, new NameableComparator());
            return source;
        }
    };
    final GetStoragePoolsByClusterServiceParameters parameters = new GetStoragePoolsByClusterServiceParameters();
    parameters.setSupportsVirtService(supportsVirtService);
    parameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByClusterService, parameters, aQuery);
}
#method_after
public void getDataCenterByClusterServiceList(AsyncQuery aQuery, boolean supportsVirtService, boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            // sort data centers
            final ArrayList<StoragePool> storagePoolList = (ArrayList<StoragePool>) source;
            Collections.sort(storagePoolList, new NameableComparator());
            return source;
        }
    };
    final GetStoragePoolsByClusterServiceParameters parameters = new GetStoragePoolsByClusterServiceParameters();
    parameters.setSupportsVirtService(supportsVirtService);
    parameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByClusterService, parameters, aQuery);
}
#end_block

#method_before
public static void getDataCenterListByName(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("DataCenter: name=" + name + " sortby name", SearchType.StoragePool), aQuery);
}
#method_after
public void getDataCenterListByName(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("DataCenter: name=" + name + " sortby name", SearchType.StoragePool), aQuery);
}
#end_block

#method_before
public static void getSpiceUsbAutoShare(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Boolean) source).booleanValue() : true;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SpiceUsbAutoShare, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getSpiceUsbAutoShare(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Boolean) source).booleanValue() : true;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SpiceUsbAutoShare, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getWANColorDepth(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? WanColorDepth.fromInt(((Integer) source).intValue()) : WanColorDepth.depth16;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANColorDepth, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getWANColorDepth(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? WanColorDepth.fromInt(((Integer) source).intValue()) : WanColorDepth.depth16;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANColorDepth, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getWANDisableEffects(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<WANDisableEffects>();
            }
            List<WANDisableEffects> res = new ArrayList<WANDisableEffects>();
            String fromDb = (String) source;
            for (String value : fromDb.split(",")) {
                // $NON-NLS-1$
                if (value == null) {
                    continue;
                }
                String trimmedValue = value.trim();
                if ("".equals(trimmedValue)) {
                    continue;
                }
                res.add(WANDisableEffects.fromString(trimmedValue));
            }
            return res;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANDisableEffects, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getWANDisableEffects(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<WANDisableEffects>();
            }
            List<WANDisableEffects> res = new ArrayList<WANDisableEffects>();
            String fromDb = (String) source;
            for (String value : fromDb.split(",")) {
                // $NON-NLS-1$
                if (value == null) {
                    continue;
                }
                String trimmedValue = value.trim();
                if ("".equals(trimmedValue)) {
                    continue;
                }
                res.add(WANDisableEffects.fromString(trimmedValue));
            }
            return res;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANDisableEffects, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getMaxVmsInPool(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1000;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVmsInPool, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getMaxVmsInPool(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1000;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVmsInPool, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getMaxNumOfVmSockets(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmSockets);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getMaxNumOfVmSockets(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmSockets);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public static void getMaxNumOfVmCpus(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmCpus);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getMaxNumOfVmCpus(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmCpus);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public static void getMaxNumOfCPUsPerSocket(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfCpuPerSocket);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getMaxNumOfCPUsPerSocket(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfCpuPerSocket);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public static void getClusterList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getClusterList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public static List<VDSGroup> filterByArchitecture(List<VDSGroup> clusters, ArchitectureType targetArchitecture) {
    List<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getArchitecture().equals(targetArchitecture)) {
            filteredClusters.add(cluster);
        }
    }
    return filteredClusters;
}
#method_after
public List<VDSGroup> filterByArchitecture(List<VDSGroup> clusters, ArchitectureType targetArchitecture) {
    List<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getArchitecture().equals(targetArchitecture)) {
            filteredClusters.add(cluster);
        }
    }
    return filteredClusters;
}
#end_block

#method_before
public static List<VDSGroup> filterClustersWithoutArchitecture(List<VDSGroup> clusters) {
    List<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getArchitecture() != ArchitectureType.undefined) {
            filteredClusters.add(cluster);
        }
    }
    return filteredClusters;
}
#method_after
public List<VDSGroup> filterClustersWithoutArchitecture(List<VDSGroup> clusters) {
    List<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getArchitecture() != ArchitectureType.undefined) {
            filteredClusters.add(cluster);
        }
    }
    return filteredClusters;
}
#end_block

#method_before
public static void getClusterByServiceList(AsyncQuery aQuery, Guid dataCenterId, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDSGroup>();
            }
            final ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
            return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getClusterByServiceList(AsyncQuery aQuery, Guid dataCenterId, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDSGroup>();
            }
            final ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
            return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public static void isSoundcardEnabled(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void isSoundcardEnabled(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void isVirtioScsiEnabledForVm(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void isVirtioScsiEnabledForVm(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void getClusterListByService(AsyncQuery aQuery, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = getClusterByServiceList((ArrayList<VDSGroup>) source, supportsVirtService, supportsGlusterService);
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsGroups, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getClusterListByService(AsyncQuery aQuery, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = getClusterByServiceList((ArrayList<VDSGroup>) source, supportsVirtService, supportsGlusterService);
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsGroups, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void getClusterList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsGroups, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getClusterList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsGroups, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void getTemplateDiskList(AsyncQuery aQuery, Guid templateId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<DiskImage>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesDisks, new IdQueryParameters(templateId), aQuery);
}
#method_after
public void getTemplateDiskList(AsyncQuery aQuery, Guid templateId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<DiskImage>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesDisks, new IdQueryParameters(templateId), aQuery);
}
#end_block

#method_before
public static int getRoundedPriority(int priority, int maxPriority) {
    int medium = maxPriority / 2;
    int[] levels = new int[] { 1, medium, maxPriority };
    for (int i = 0; i < levels.length; i++) {
        int lengthToLess = levels[i] - priority;
        int lengthToMore = levels[i + 1] - priority;
        if (lengthToMore < 0) {
            continue;
        }
        return Math.abs(lengthToLess) < lengthToMore ? levels[i] : levels[i + 1];
    }
    return 0;
}
#method_after
public int getRoundedPriority(int priority, int maxPriority) {
    int medium = maxPriority / 2;
    int[] levels = new int[] { 1, medium, maxPriority };
    for (int i = 0; i < levels.length; i++) {
        int lengthToLess = levels[i] - priority;
        int lengthToMore = levels[i + 1] - priority;
        if (lengthToMore < 0) {
            continue;
        }
        return Math.abs(lengthToLess) < lengthToMore ? levels[i] : levels[i + 1];
    }
    return 0;
}
#end_block

#method_before
public static void getTemplateListByDataCenter(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new TemplateConverter();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getTemplateListByDataCenter(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new TemplateConverter();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public static void getTemplateListByStorage(AsyncQuery aQuery, Guid storageId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VmTemplate> list = new ArrayList<VmTemplate>();
            if (source != null) {
                for (VmTemplate template : (ArrayList<VmTemplate>) source) {
                    if (template.getStatus() == VmTemplateStatus.OK) {
                        list.add(template);
                    }
                }
                Collections.sort(list, new NameableComparator());
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesFromStorageDomain, new IdQueryParameters(storageId), aQuery);
}
#method_after
public void getTemplateListByStorage(AsyncQuery aQuery, Guid storageId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VmTemplate> list = new ArrayList<VmTemplate>();
            if (source != null) {
                for (VmTemplate template : (ArrayList<VmTemplate>) source) {
                    if (template.getStatus() == VmTemplateStatus.OK) {
                        list.add(template);
                    }
                }
                Collections.sort(list, new NameableComparator());
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesFromStorageDomain, new IdQueryParameters(storageId), aQuery);
}
#end_block

#method_before
public static ArrayList<VmTemplate> filterTemplatesByArchitecture(List<VmTemplate> list, ArchitectureType architecture) {
    ArrayList<VmTemplate> filteredList = new ArrayList<VmTemplate>();
    for (VmTemplate template : list) {
        if (template.getId().equals(Guid.Empty) || template.getClusterArch().equals(architecture)) {
            filteredList.add(template);
        }
    }
    return filteredList;
}
#method_after
public ArrayList<VmTemplate> filterTemplatesByArchitecture(List<VmTemplate> list, ArchitectureType architecture) {
    ArrayList<VmTemplate> filteredList = new ArrayList<VmTemplate>();
    for (VmTemplate template : list) {
        if (template.getId().equals(Guid.Empty) || template.getClusterArch().equals(architecture)) {
            filteredList.add(template);
        }
    }
    return filteredList;
}
#end_block

#method_before
public static void getNumOfMonitorList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Integer> nums = new ArrayList<Integer>();
            if (source != null) {
                Iterable numEnumerable = (Iterable) source;
                Iterator numIterator = numEnumerable.iterator();
                while (numIterator.hasNext()) {
                    nums.add(Integer.parseInt(numIterator.next().toString()));
                }
            }
            return nums;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.ValidNumOfMonitors, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getNumOfMonitorList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Integer> nums = new ArrayList<Integer>();
            if (source != null) {
                Iterable numEnumerable = (Iterable) source;
                Iterator numIterator = numEnumerable.iterator();
                while (numIterator.hasNext()) {
                    nums.add(Integer.parseInt(numIterator.next().toString()));
                }
            }
            return nums;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.ValidNumOfMonitors, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getStorageDomainList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StorageDomain>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getStorageDomainList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StorageDomain>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public static void getMaxVmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return 100;
            }
            return source;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.VmPriorityMaxValue, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getMaxVmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return 100;
            }
            return source;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.VmPriorityMaxValue, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getHostById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getHostById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getHostListByCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((ArrayList<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$ //$NON-NLS-2$
    SearchParameters(// $NON-NLS-1$ //$NON-NLS-2$
    "Host: cluster = " + clusterName + " sortby name", SearchType.VDS), aQuery);
}
#method_after
public void getHostListByCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((ArrayList<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$ //$NON-NLS-2$
    SearchParameters(// $NON-NLS-1$ //$NON-NLS-2$
    "Host: cluster = " + clusterName + " sortby name", SearchType.VDS), aQuery);
}
#end_block

#method_before
public static void getHostListByDataCenter(AsyncQuery aQuery, Guid spId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((ArrayList<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsByStoragePool, new IdQueryParameters(spId), aQuery);
}
#method_after
public void getHostListByDataCenter(AsyncQuery aQuery, Guid spId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((ArrayList<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsByStoragePool, new IdQueryParameters(spId), aQuery);
}
#end_block

#method_before
public static void getVmDiskList(AsyncQuery aQuery, Guid vmId, boolean isRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return source;
            }
            return new ArrayList<DiskImage>();
        }
    };
    IdQueryParameters params = new IdQueryParameters(vmId);
    params.setRefresh(isRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, params, aQuery);
}
#method_after
public void getVmDiskList(AsyncQuery aQuery, Guid vmId, boolean isRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return source;
            }
            return new ArrayList<DiskImage>();
        }
    };
    IdQueryParameters params = new IdQueryParameters(vmId);
    params.setRefresh(isRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, params, aQuery);
}
#end_block

#method_before
public static HashMap<Integer, String> getOsUniqueOsNames() {
    return uniqueOsNames;
}
#method_after
public HashMap<Integer, String> getOsUniqueOsNames() {
    return uniqueOsNames;
}
#end_block

#method_before
public static void getAAAProfilesList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<String>((ArrayList<String>) source) : new ArrayList<String>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getAAAProfilesList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<String>((ArrayList<String>) source) : new ArrayList<String>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAAAProfileList, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void getRoleList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Role>) source : new ArrayList<Role>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRoles, new MultilevelAdministrationsQueriesParameters(), aQuery);
}
#method_after
public void getRoleList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Role>) source : new ArrayList<Role>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRoles, new MultilevelAdministrationsQueriesParameters(), aQuery);
}
#end_block

#method_before
public static void getStorageDomainById(AsyncQuery aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (StorageDomain) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainById, new IdQueryParameters(storageDomainId), aQuery);
}
#method_after
public void getStorageDomainById(AsyncQuery aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (StorageDomain) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainById, new IdQueryParameters(storageDomainId), aQuery);
}
#end_block

#method_before
public static VolumeFormat getDiskVolumeFormat(VolumeType volumeType, StorageType storageType) {
    if (storageType.isFileDomain()) {
        return VolumeFormat.RAW;
    } else if (storageType.isBlockDomain()) {
        switch(volumeType) {
            case Sparse:
                return VolumeFormat.COW;
            case Preallocated:
                return VolumeFormat.RAW;
            default:
                return VolumeFormat.Unassigned;
        }
    } else {
        return VolumeFormat.Unassigned;
    }
}
#method_after
public VolumeFormat getDiskVolumeFormat(VolumeType volumeType, StorageType storageType) {
    if (storageType.isFileDomain()) {
        return VolumeFormat.RAW;
    } else if (storageType.isBlockDomain()) {
        switch(volumeType) {
            case Sparse:
                return VolumeFormat.COW;
            case Preallocated:
                return VolumeFormat.RAW;
            default:
                return VolumeFormat.Unassigned;
        }
    } else {
        return VolumeFormat.Unassigned;
    }
}
#end_block

#method_before
public static void getClusterNetworkList(AsyncQuery aQuery, Guid clusterId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return new ArrayList<Network>();
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworksByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getClusterNetworkList(AsyncQuery aQuery, Guid clusterId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return new ArrayList<Network>();
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworksByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
public static void getAllNetworkQos(Guid dcId, AsyncQuery query) {
    query.converterCallback = new IAsyncConverter<List<NetworkQoS>>() {

        @Override
        public List<NetworkQoS> Convert(Object returnValue, AsyncQuery asyncQuery) {
            List<NetworkQoS> qosList = returnValue == null ? new ArrayList<NetworkQoS>() : (List<NetworkQoS>) returnValue;
            qosList.add(0, NetworkQoSModel.EMPTY_QOS);
            return qosList;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, new IdQueryParameters(dcId), query);
}
#method_after
public void getAllNetworkQos(Guid dcId, AsyncQuery query) {
    query.converterCallback = new IAsyncConverter<List<NetworkQoS>>() {

        @Override
        public List<NetworkQoS> Convert(Object returnValue, AsyncQuery asyncQuery) {
            List<NetworkQoS> qosList = returnValue == null ? new ArrayList<NetworkQoS>() : (List<NetworkQoS>) returnValue;
            qosList.add(0, NetworkQoSModel.EMPTY_QOS);
            return qosList;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, new IdQueryParameters(dcId), query);
}
#end_block

#method_before
public static void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId).withoutRefresh(), aQuery);
}
#method_after
public void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void getNetworkLabelsByDataCenterId(Guid dataCenterId, AsyncQuery query) {
    query.converterCallback = new IAsyncConverter<SortedSet<String>>() {

        @Override
        public SortedSet<String> Convert(Object returnValue, AsyncQuery asyncQuery) {
            SortedSet<String> sortedSet = new TreeSet<String>(new LexoNumericComparator());
            sortedSet.addAll((Collection<String>) returnValue);
            return sortedSet;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworkLabelsByDataCenterId, new IdQueryParameters(dataCenterId), query);
}
#method_after
public void getNetworkLabelsByDataCenterId(Guid dataCenterId, AsyncQuery query) {
    query.converterCallback = new IAsyncConverter<SortedSet<String>>() {

        @Override
        public SortedSet<String> Convert(Object returnValue, AsyncQuery asyncQuery) {
            SortedSet<String> sortedSet = new TreeSet<String>(new LexoNumericComparator());
            sortedSet.addAll((Collection<String>) returnValue);
            return sortedSet;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworkLabelsByDataCenterId, new IdQueryParameters(dataCenterId), query);
}
#end_block

#method_before
public static void getWatchdogByVmId(AsyncQuery aQuery, Guid vmId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getWatchdogByVmId(AsyncQuery aQuery, Guid vmId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void getTemplateById(AsyncQuery aQuery, Guid templateId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(templateId), aQuery);
}
#method_after
public void getTemplateById(AsyncQuery aQuery, Guid templateId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(templateId), aQuery);
}
#end_block

#method_before
public static void countAllTemplates(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplateCount, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void countAllTemplates(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplateCount, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void getHostList(AsyncQuery aQuery) {
    getHostListByStatus(aQuery, null);
}
#method_after
public void getHostList(AsyncQuery aQuery) {
    getHostListByStatus(aQuery, null);
}
#end_block

#method_before
public static void getHostListByStatus(AsyncQuery aQuery, VDSStatus status) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((Iterable) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: " + (status == null ? "" : ("status=" + status.name())), SearchType.VDS);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public void getHostListByStatus(AsyncQuery aQuery, VDSStatus status) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((Iterable) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: " + (status == null ? "" : ("status=" + status.name())), SearchType.VDS);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#end_block

#method_before
public static void getHostsForStorageOperation(AsyncQuery aQuery, Guid storagePoolId, boolean localFsOnly) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return source;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsForStorageOperation, new GetHostsForStorageOperationParameters(storagePoolId, localFsOnly), aQuery);
}
#method_after
public void getHostsForStorageOperation(AsyncQuery aQuery, Guid storagePoolId, boolean localFsOnly) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return source;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsForStorageOperation, new GetHostsForStorageOperationParameters(storagePoolId, localFsOnly), aQuery);
}
#end_block

#method_before
public static void getVolumeList(AsyncQuery aQuery, String clusterName) {
    if ((ApplicationModeHelper.getUiMode().getValue() & ApplicationMode.GlusterOnly.getValue()) == 0) {
        aQuery.asyncCallback.onSuccess(aQuery.model, new ArrayList<GlusterVolumeEntity>());
        return;
    }
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<GlusterVolumeEntity> list = (ArrayList<GlusterVolumeEntity>) source;
                return list;
            }
            return new ArrayList<GlusterVolumeEntity>();
        }
    };
    SearchParameters searchParameters;
    searchParameters = // $NON-NLS-1$
    clusterName == null ? // $NON-NLS-1$
    new SearchParameters("Volumes:", SearchType.GlusterVolume) : // $NON-NLS-1$
    new SearchParameters("Volumes: cluster.name=" + clusterName, SearchType.GlusterVolume);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public void getVolumeList(AsyncQuery aQuery, String clusterName) {
    if ((ApplicationModeHelper.getUiMode().getValue() & ApplicationMode.GlusterOnly.getValue()) == 0) {
        aQuery.asyncCallback.onSuccess(aQuery.model, new ArrayList<GlusterVolumeEntity>());
        return;
    }
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<GlusterVolumeEntity> list = (ArrayList<GlusterVolumeEntity>) source;
                return list;
            }
            return new ArrayList<GlusterVolumeEntity>();
        }
    };
    SearchParameters searchParameters;
    searchParameters = // $NON-NLS-1$
    clusterName == null ? // $NON-NLS-1$
    new SearchParameters("Volumes:", SearchType.GlusterVolume) : // $NON-NLS-1$
    new SearchParameters("Volumes: cluster.name=" + clusterName, SearchType.GlusterVolume);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#end_block

#method_before
public static void getGlusterVolumeOptionInfoList(AsyncQuery aQuery, Guid clusterId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeOptionsInfo, new GlusterParameters(clusterId), aQuery);
}
#method_after
public void getGlusterVolumeOptionInfoList(AsyncQuery aQuery, Guid clusterId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeOptionsInfo, new GlusterParameters(clusterId), aQuery);
}
#end_block

#method_before
public static void getHostFingerprint(AsyncQuery aQuery, String hostAddress) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetServerSSHKeyFingerprint, new ServerParameters(hostAddress), aQuery);
}
#method_after
public void getHostFingerprint(AsyncQuery aQuery, String hostAddress) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetServerSSHKeyFingerprint, new ServerParameters(hostAddress), aQuery);
}
#end_block

#method_before
public static void getHostPublicKey(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetServerSSHPublicKey, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getHostPublicKey(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetServerSSHPublicKey, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void getGlusterHosts(AsyncQuery aQuery, String hostAddress, String rootPassword, String fingerprint) {
    GlusterServersQueryParameters parameters = new GlusterServersQueryParameters(hostAddress, rootPassword);
    parameters.setFingerprint(fingerprint);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServersForImport, parameters, aQuery);
}
#method_after
public void getGlusterHosts(AsyncQuery aQuery, String hostAddress, String rootPassword, String fingerprint) {
    GlusterServersQueryParameters parameters = new GlusterServersQueryParameters(hostAddress, rootPassword);
    parameters.setFingerprint(fingerprint);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServersForImport, parameters, aQuery);
}
#end_block

#method_before
public static void getClusterGlusterServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    // Passing empty values for Volume and Brick to get the services of all the volumes/hosts in the cluster
    GlusterVolumeAdvancedDetailsParameters parameters = // $NON-NLS-1$ //$NON-NLS-2$
    new GlusterVolumeAdvancedDetailsParameters(clusterId, null, null, false);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#method_after
public void getClusterGlusterServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    // Passing empty values for Volume and Brick to get the services of all the volumes/hosts in the cluster
    GlusterVolumeAdvancedDetailsParameters parameters = // $NON-NLS-1$ //$NON-NLS-2$
    new GlusterVolumeAdvancedDetailsParameters(clusterId, null, null, false);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#end_block

#method_before
public static void getGlusterVolumeBrickDetails(AsyncQuery aQuery, Guid clusterId, Guid volumeId, Guid brickId) {
    GlusterVolumeAdvancedDetailsParameters parameters = new GlusterVolumeAdvancedDetailsParameters(clusterId, volumeId, brickId, true);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#method_after
public void getGlusterVolumeBrickDetails(AsyncQuery aQuery, Guid clusterId, Guid volumeId, Guid brickId) {
    GlusterVolumeAdvancedDetailsParameters parameters = new GlusterVolumeAdvancedDetailsParameters(clusterId, volumeId, brickId, true);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#end_block

#method_before
public static void getGlusterHostsNewlyAdded(AsyncQuery aQuery, Guid clusterId, boolean isFingerprintRequired) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAddedGlusterServers, new AddedGlusterServersParameters(clusterId, isFingerprintRequired), aQuery);
}
#method_after
public void getGlusterHostsNewlyAdded(AsyncQuery aQuery, Guid clusterId, boolean isFingerprintRequired) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAddedGlusterServers, new AddedGlusterServersParameters(clusterId, isFingerprintRequired), aQuery);
}
#end_block

#method_before
public static void isAnyHostUpInCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null && !((List<?>) source).isEmpty()) {
                return true;
            }
            return false;
        }
    };
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#method_after
public void isAnyHostUpInCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null && !((List<?>) source).isEmpty()) {
                return true;
            }
            return false;
        }
    };
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#end_block

#method_before
public static void getGlusterHooks(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterHookEntity>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHooks, new GlusterParameters(clusterId), aQuery);
}
#method_after
public void getGlusterHooks(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterHookEntity>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHooks, new GlusterParameters(clusterId), aQuery);
}
#end_block

#method_before
public static void getGlusterBricksForServer(AsyncQuery aQuery, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterBrickEntity>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeBricksByServerId, new IdQueryParameters(serverId), aQuery);
}
#method_after
public void getGlusterBricksForServer(AsyncQuery aQuery, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterBrickEntity>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeBricksByServerId, new IdQueryParameters(serverId), aQuery);
}
#end_block

#method_before
public static void getGlusterHook(AsyncQuery aQuery, Guid hookId, boolean includeServerHooks) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookById, new GlusterHookQueryParameters(hookId, includeServerHooks), aQuery);
}
#method_after
public void getGlusterHook(AsyncQuery aQuery, Guid hookId, boolean includeServerHooks) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookById, new GlusterHookQueryParameters(hookId, includeServerHooks), aQuery);
}
#end_block

#method_before
public static void getGlusterHookContent(AsyncQuery aQuery, Guid hookId, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? source : "";
        }
    };
    GlusterHookContentQueryParameters parameters = new GlusterHookContentQueryParameters(hookId);
    parameters.setGlusterServerId(serverId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookContent, parameters, aQuery);
}
#method_after
public void getGlusterHookContent(AsyncQuery aQuery, Guid hookId, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? source : "";
        }
    };
    GlusterHookContentQueryParameters parameters = new GlusterHookContentQueryParameters(hookId);
    parameters.setGlusterServerId(serverId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookContent, parameters, aQuery);
}
#end_block

#method_before
public static void getGlusterSwiftServices(AsyncQuery aQuery, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterServerService>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByServerId, new GlusterServiceQueryParameters(serverId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#method_after
public void getGlusterSwiftServices(AsyncQuery aQuery, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterServerService>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByServerId, new GlusterServiceQueryParameters(serverId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#end_block

#method_before
public static void getClusterGlusterSwiftService(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                List<GlusterClusterService> serviceList = (List<GlusterClusterService>) source;
                if (!serviceList.isEmpty()) {
                    return serviceList.get(0);
                }
                return null;
            } else {
                return source;
            }
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterClusterServiceByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#method_after
public void getClusterGlusterSwiftService(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                List<GlusterClusterService> serviceList = (List<GlusterClusterService>) source;
                if (!serviceList.isEmpty()) {
                    return serviceList.get(0);
                }
                return null;
            } else {
                return source;
            }
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterClusterServiceByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#end_block

#method_before
public static void getGlusterSwiftServerServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterServerService>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#method_after
public void getGlusterSwiftServerServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterServerService>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#end_block

#method_before
public static void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#method_after
public void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#end_block

#method_before
public static void getGlusterVolumeProfilingStatistics(AsyncQuery aQuery, Guid clusterId, Guid volumeId, boolean nfs) {
    aQuery.setHandleFailure(true);
    GlusterVolumeProfileParameters parameters = new GlusterVolumeProfileParameters(clusterId, volumeId, nfs);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeProfileInfo, parameters, aQuery);
}
#method_after
public void getGlusterVolumeProfilingStatistics(AsyncQuery aQuery, Guid clusterId, Guid volumeId, boolean nfs) {
    aQuery.setHandleFailure(true);
    GlusterVolumeProfileParameters parameters = new GlusterVolumeProfileParameters(clusterId, volumeId, nfs);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeProfileInfo, parameters, aQuery);
}
#end_block

#method_before
public static void getGlusterRemoveBricksStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId, List<GlusterBrickEntity> bricks) {
    aQuery.setHandleFailure(true);
    GlusterVolumeRemoveBricksQueriesParameters parameters = new GlusterVolumeRemoveBricksQueriesParameters(clusterId, volumeId, bricks);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRemoveBricksStatus, parameters, aQuery);
}
#method_after
public void getGlusterRemoveBricksStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId, List<GlusterBrickEntity> bricks) {
    aQuery.setHandleFailure(true);
    GlusterVolumeRemoveBricksQueriesParameters parameters = new GlusterVolumeRemoveBricksQueriesParameters(clusterId, volumeId, bricks);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRemoveBricksStatus, parameters, aQuery);
}
#end_block

#method_before
public static void getRpmVersion(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.ProductRPMVersion);
    tempVar.setVersion(getDefaultConfigurationVersion());
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getRpmVersion(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.ProductRPMVersion);
    tempVar.setVersion(getDefaultConfigurationVersion());
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public static void getUserMessageOfTheDayViaPublic(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.UserMessageOfTheDay, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getUserMessageOfTheDayViaPublic(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.UserMessageOfTheDay, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getSearchResultsLimit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 100;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SearchResultsLimit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getSearchResultsLimit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 100;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SearchResultsLimit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static Map<Version, Map<String, String>> getCustomPropertiesList() {
    return customPropertiesList;
}
#method_after
public Map<Version, Map<String, String>> getCustomPropertiesList() {
    return customPropertiesList;
}
#end_block

#method_before
public static void getPermissionsByAdElementId(AsyncQuery aQuery, Guid userId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Permissions>) source : new ArrayList<Permissions>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(userId), aQuery);
}
#method_after
public void getPermissionsByAdElementId(AsyncQuery aQuery, Guid userId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Permissions>) source : new ArrayList<Permissions>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(userId), aQuery);
}
#end_block

#method_before
public static void getRoleActionGroupsByRoleId(AsyncQuery aQuery, Guid roleId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<ActionGroup>) source : new ArrayList<ActionGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetRoleActionGroupsByRoleId, new IdQueryParameters(roleId), aQuery);
}
#method_after
public void getRoleActionGroupsByRoleId(AsyncQuery aQuery, Guid roleId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<ActionGroup>) source : new ArrayList<ActionGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetRoleActionGroupsByRoleId, new IdQueryParameters(roleId), aQuery);
}
#end_block

#method_before
public static void isTemplateNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? !((Boolean) source).booleanValue() : false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmTemlateWithSameNameExist, new NameQueryParameters(name), aQuery);
}
#method_after
public void isTemplateNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? !((Boolean) source).booleanValue() : false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmTemlateWithSameNameExist, new NameQueryParameters(name), aQuery);
}
#end_block

#method_before
public static void isVmNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? !((Boolean) source).booleanValue() : false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmWithSameNameExist, new NameQueryParameters(name), aQuery);
}
#method_after
public void isVmNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? !((Boolean) source).booleanValue() : false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmWithSameNameExist, new NameQueryParameters(name), aQuery);
}
#end_block

#method_before
public static void getDataCentersWithPermittedActionOnClusters(AsyncQuery aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    GetDataCentersWithPermittedActionOnClustersParameters getDataCentersWithPermittedActionOnClustersParameters = new GetDataCentersWithPermittedActionOnClustersParameters();
    getDataCentersWithPermittedActionOnClustersParameters.setActionGroup(actionGroup);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsVirtService(supportsVirtService);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetDataCentersWithPermittedActionOnClusters, getDataCentersWithPermittedActionOnClustersParameters, aQuery);
}
#method_after
public void getDataCentersWithPermittedActionOnClusters(AsyncQuery aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    GetDataCentersWithPermittedActionOnClustersParameters getDataCentersWithPermittedActionOnClustersParameters = new GetDataCentersWithPermittedActionOnClustersParameters();
    getDataCentersWithPermittedActionOnClustersParameters.setActionGroup(actionGroup);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsVirtService(supportsVirtService);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetDataCentersWithPermittedActionOnClusters, getDataCentersWithPermittedActionOnClustersParameters, aQuery);
}
#end_block

#method_before
public static void getClustersWithPermittedAction(AsyncQuery aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
            }
            return new ArrayList<VDSGroup>();
        }
    };
    GetEntitiesWithPermittedActionParameters getEntitiesWithPermittedActionParameters = new GetEntitiesWithPermittedActionParameters();
    getEntitiesWithPermittedActionParameters.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetClustersWithPermittedAction, getEntitiesWithPermittedActionParameters, aQuery);
}
#method_after
public void getClustersWithPermittedAction(AsyncQuery aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
            }
            return new ArrayList<VDSGroup>();
        }
    };
    GetEntitiesWithPermittedActionParameters getEntitiesWithPermittedActionParameters = new GetEntitiesWithPermittedActionParameters();
    getEntitiesWithPermittedActionParameters.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetClustersWithPermittedAction, getEntitiesWithPermittedActionParameters, aQuery);
}
#end_block

#method_before
public static void getAllVmTemplates(AsyncQuery aQuery, final boolean refresh) {
    aQuery.converterCallback = new TemplateConverter();
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setRefresh(refresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmTemplates, params, aQuery);
}
#method_after
public void getAllVmTemplates(AsyncQuery aQuery, final boolean refresh) {
    aQuery.converterCallback = new TemplateConverter();
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setRefresh(refresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmTemplates, params, aQuery);
}
#end_block

#method_before
public static void isUSBEnabledByDefault(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Boolean) source).booleanValue() : false;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.EnableUSBAsDefault, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void isUSBEnabledByDefault(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Boolean) source).booleanValue() : false;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.EnableUSBAsDefault, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getStorageConnectionById(AsyncQuery aQuery, String id, boolean isRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (StorageServerConnections) source : null;
        }
    };
    StorageServerConnectionQueryParametersBase params = new StorageServerConnectionQueryParametersBase(id);
    params.setRefresh(isRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageServerConnectionById, params, aQuery);
}
#method_after
public void getStorageConnectionById(AsyncQuery aQuery, String id, boolean isRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (StorageServerConnections) source : null;
        }
    };
    StorageServerConnectionQueryParametersBase params = new StorageServerConnectionQueryParametersBase(id);
    params.setRefresh(isRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageServerConnectionById, params, aQuery);
}
#end_block

#method_before
public static void getDataCentersByStorageDomain(AsyncQuery aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StoragePool>) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), aQuery);
}
#method_after
public void getDataCentersByStorageDomain(AsyncQuery aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StoragePool>) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), aQuery);
}
#end_block

#method_before
public static void getDataCenterVersions(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Version>();
            } else {
                ArrayList<Version> list = (ArrayList<Version>) source;
                Collections.sort(list);
                return list;
            }
        }
    };
    IdQueryParameters tempVar = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAvailableClusterVersionsByStoragePool, tempVar, aQuery);
}
#method_after
public void getDataCenterVersions(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Version>();
            } else {
                ArrayList<Version> list = (ArrayList<Version>) source;
                Collections.sort(list);
                return list;
            }
        }
    };
    IdQueryParameters tempVar = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAvailableClusterVersionsByStoragePool, tempVar, aQuery);
}
#end_block

#method_before
public static void getDataCenterMaxNameLength(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StoragePoolNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getDataCenterMaxNameLength(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StoragePoolNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getClusterServerMemoryOverCommit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommitForServers, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getClusterServerMemoryOverCommit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommitForServers, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getClusterDesktopMemoryOverCommit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getClusterDesktopMemoryOverCommit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getAllowClusterWithVirtGlusterEnabled(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : Boolean.TRUE;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.AllowClusterWithVirtGlusterEnabled, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getAllowClusterWithVirtGlusterEnabled(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : Boolean.TRUE;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.AllowClusterWithVirtGlusterEnabled, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getCPUList(AsyncQuery aQuery, Version version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<ServerCpu>) source : new ArrayList<ServerCpu>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllServerCpuList, new GetAllServerCpuListParameters(version), aQuery);
}
#method_after
public void getCPUList(AsyncQuery aQuery, Version version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<ServerCpu>) source : new ArrayList<ServerCpu>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllServerCpuList, new GetAllServerCpuListParameters(version), aQuery);
}
#end_block

#method_before
public static void getPmTypeList(AsyncQuery aQuery, Version version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<String> list = new ArrayList<String>();
            if (source != null) {
                // $NON-NLS-1$
                String[] array = ((String) source).split("[,]", -1);
                for (String item : array) {
                    list.add(item);
                }
            }
            return list;
        }
    };
    GetConfigurationValueParameters param = new GetConfigurationValueParameters(ConfigurationValues.VdsFenceType);
    param.setVersion(version != null ? version.toString() : getDefaultConfigurationVersion());
    Frontend.getInstance().runQuery(VdcQueryType.GetFenceConfigurationValue, param, aQuery);
}
#method_after
public void getPmTypeList(AsyncQuery aQuery, Version version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<String> list = new ArrayList<String>();
            if (source != null) {
                // $NON-NLS-1$
                String[] array = ((String) source).split("[,]", -1);
                for (String item : array) {
                    list.add(item);
                }
            }
            return list;
        }
    };
    GetConfigurationValueParameters param = new GetConfigurationValueParameters(ConfigurationValues.VdsFenceType);
    param.setVersion(version != null ? version.toString() : getDefaultConfigurationVersion());
    Frontend.getInstance().runQuery(VdcQueryType.GetFenceConfigurationValue, param, aQuery);
}
#end_block

#method_before
public static void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.getInstance().runQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#method_after
public void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.getInstance().runQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
public static void getNetworkList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworks, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getNetworkList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworks, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public static void getISOStorageDomainList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> allStorageDomains = (ArrayList<StorageDomain>) source;
                ArrayList<StorageDomain> isoStorageDomains = new ArrayList<StorageDomain>();
                for (StorageDomain storageDomain : allStorageDomains) {
                    if (storageDomain.getStorageDomainType() == StorageDomainType.ISO) {
                        isoStorageDomains.add(storageDomain);
                    }
                }
                return isoStorageDomains;
            }
            return new ArrayList<StorageDomain>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Storage:", SearchType.StorageDomain);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#method_after
public void getISOStorageDomainList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> allStorageDomains = (ArrayList<StorageDomain>) source;
                ArrayList<StorageDomain> isoStorageDomains = new ArrayList<StorageDomain>();
                for (StorageDomain storageDomain : allStorageDomains) {
                    if (storageDomain.getStorageDomainType() == StorageDomainType.ISO) {
                        isoStorageDomains.add(storageDomain);
                    }
                }
                return isoStorageDomains;
            }
            return new ArrayList<StorageDomain>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Storage:", SearchType.StorageDomain);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#end_block

#method_before
public static void getStorageDomainList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : new ArrayList<StorageDomain>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Storage:", SearchType.StorageDomain);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#method_after
public void getStorageDomainList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : new ArrayList<StorageDomain>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Storage:", SearchType.StorageDomain);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#end_block

#method_before
public static void getLocalStorageHost(AsyncQuery aQuery, String dataCenterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                for (IVdcQueryable item : (ArrayList<IVdcQueryable>) source) {
                    return item;
                }
            }
            return null;
        }
    };
    // $NON-NLS-1$
    SearchParameters sp = new SearchParameters("hosts: datacenter=" + dataCenterName, SearchType.VDS);
    Frontend.getInstance().runQuery(VdcQueryType.Search, sp, aQuery);
}
#method_after
public void getLocalStorageHost(AsyncQuery aQuery, String dataCenterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                for (IVdcQueryable item : (ArrayList<IVdcQueryable>) source) {
                    return item;
                }
            }
            return null;
        }
    };
    // $NON-NLS-1$
    SearchParameters sp = new SearchParameters("hosts: datacenter=" + dataCenterName, SearchType.VDS);
    Frontend.getInstance().runQuery(VdcQueryType.Search, sp, aQuery);
}
#end_block

#method_before
public static void getStorageDomainsByConnection(AsyncQuery aQuery, Guid storagePoolId, String connectionPath) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : null;
        }
    };
    GetStorageDomainsByConnectionParameters param = new GetStorageDomainsByConnectionParameters();
    param.setConnection(connectionPath);
    if (storagePoolId != null) {
        param.setStoragePoolId(storagePoolId);
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByConnection, param, aQuery);
}
#method_after
public void getStorageDomainsByConnection(AsyncQuery aQuery, Guid storagePoolId, String connectionPath) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : null;
        }
    };
    GetStorageDomainsByConnectionParameters param = new GetStorageDomainsByConnectionParameters();
    param.setConnection(connectionPath);
    if (storagePoolId != null) {
        param.setStoragePoolId(storagePoolId);
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByConnection, param, aQuery);
}
#end_block

#method_before
public static void getExistingStorageDomainList(AsyncQuery aQuery, Guid hostId, StorageDomainType domainType, StorageType storageType, String path) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetExistingStorageDomainList, new GetExistingStorageDomainListParameters(hostId, storageType, domainType, path), aQuery);
}
#method_after
public void getExistingStorageDomainList(AsyncQuery aQuery, Guid hostId, StorageDomainType domainType, StorageType storageType, String path) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetExistingStorageDomainList, new GetExistingStorageDomainListParameters(hostId, storageType, domainType, path), aQuery);
}
#end_block

#method_before
public static void getStorageDomainMaxNameLength(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StorageDomainNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getStorageDomainMaxNameLength(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StorageDomainNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void isStorageDomainNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                return storageDomains.isEmpty();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$
    SearchParameters(// $NON-NLS-1$
    "Storage: name=" + name, SearchType.StorageDomain), aQuery);
}
#method_after
public void isStorageDomainNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                return storageDomains.isEmpty();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$
    SearchParameters(// $NON-NLS-1$
    "Storage: name=" + name, SearchType.StorageDomain), aQuery);
}
#end_block

#method_before
public static void getNetworkConnectivityCheckTimeoutInSeconds(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 120;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.NetworkConnectivityCheckTimeoutInSeconds, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getNetworkConnectivityCheckTimeoutInSeconds(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 120;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.NetworkConnectivityCheckTimeoutInSeconds, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getMaxSpmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    // GetConfigFromCache(
    // new GetConfigurationValueParameters(ConfigurationValues.HighUtilizationForPowerSave,
    // getDefaultConfigurationVersion()),
    // aQuery);
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), 10);
}
#method_after
public void getMaxSpmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    // GetConfigFromCache(
    // new GetConfigurationValueParameters(ConfigurationValues.HighUtilizationForPowerSave,
    // getDefaultConfigurationVersion()),
    // aQuery);
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), 10);
}
#end_block

#method_before
public static void getDefaultSpmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    // GetConfigFromCache(
    // new GetConfigurationValueParameters(ConfigurationValues.HighUtilizationForPowerSave,
    // getDefaultConfigurationVersion()),
    // aQuery);
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), 5);
}
#method_after
public void getDefaultSpmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    // GetConfigFromCache(
    // new GetConfigurationValueParameters(ConfigurationValues.HighUtilizationForPowerSave,
    // getDefaultConfigurationVersion()),
    // aQuery);
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), 5);
}
#end_block

#method_before
public static void getDefaultPmProxyPreferences(AsyncQuery query) {
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.FenceProxyDefaultPreferences, getDefaultConfigurationVersion()), query);
}
#method_after
public void getDefaultPmProxyPreferences(AsyncQuery query) {
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.FenceProxyDefaultPreferences, getDefaultConfigurationVersion()), query);
}
#end_block

#method_before
public static void getRootTag(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                Tags tag = (Tags) source;
                Tags root = new Tags(tag.getdescription(), tag.getparent_id(), tag.getIsReadonly(), tag.gettag_id(), tag.gettag_name());
                if (tag.getChildren() != null) {
                    fillTagsRecursive(root, tag.getChildren());
                }
                return root;
            }
            return new Tags();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetRootTag, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getRootTag(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                Tags tag = (Tags) source;
                Tags root = new Tags(tag.getdescription(), tag.getparent_id(), tag.getIsReadonly(), tag.gettag_id(), tag.gettag_name());
                if (tag.getChildren() != null) {
                    fillTagsRecursive(root, tag.getChildren());
                }
                return root;
            }
            return new Tags();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetRootTag, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
private static void setAttachedTagsConverter(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Tags> ret = new ArrayList<Tags>();
                for (Tags tags : (ArrayList<Tags>) source) {
                    if (tags.gettype() == TagsType.GeneralTag) {
                        ret.add(tags);
                    }
                }
                return ret;
            }
            return new Tags();
        }
    };
}
#method_after
private void setAttachedTagsConverter(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Tags> ret = new ArrayList<Tags>();
                for (Tags tags : (ArrayList<Tags>) source) {
                    if (tags.gettype() == TagsType.GeneralTag) {
                        ret.add(tags);
                    }
                }
                return ret;
            }
            return new Tags();
        }
    };
}
#end_block

#method_before
public static void getAttachedTagsToVm(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVmId, new GetTagsByVmIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToVm(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVmId, new GetTagsByVmIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public static void getAttachedTagsToUser(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserId, new GetTagsByUserIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToUser(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserId, new GetTagsByUserIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public static void getAttachedTagsToUserGroup(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserGroupId, new GetTagsByUserGroupIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToUserGroup(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserGroupId, new GetTagsByUserGroupIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public static void getAttachedTagsToHost(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVdsId, new GetTagsByVdsIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToHost(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVdsId, new GetTagsByVdsIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public static void getoVirtISOsList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<RpmVersion>((ArrayList<RpmVersion>) source) : new ArrayList<RpmVersion>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetoVirtISOs, new VdsIdParametersBase(id), aQuery);
}
#method_after
public void getoVirtISOsList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<RpmVersion>((ArrayList<RpmVersion>) source) : new ArrayList<RpmVersion>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetoVirtISOs, new VdsIdParametersBase(id), aQuery);
}
#end_block

#method_before
public static void getLunsByVgId(AsyncQuery aQuery, String vgId, Guid vdsId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<LUNs>) source : new ArrayList<LUNs>();
        }
    };
    GetLunsByVgIdParameters params = new GetLunsByVgIdParameters(vgId, vdsId);
    Frontend.getInstance().runQuery(VdcQueryType.GetLunsByVgId, params, aQuery);
}
#method_after
public void getLunsByVgId(AsyncQuery aQuery, String vgId, Guid vdsId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<LUNs>) source : new ArrayList<LUNs>();
        }
    };
    GetLunsByVgIdParameters params = new GetLunsByVgIdParameters(vgId, vdsId);
    Frontend.getInstance().runQuery(VdcQueryType.GetLunsByVgId, params, aQuery);
}
#end_block

#method_before
public static void getAllTemplatesFromExportDomain(AsyncQuery aQuery, Guid storagePoolId, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new HashMap<VmTemplate, ArrayList<DiskImage>>();
        }
    };
    GetAllFromExportDomainQueryParameters getAllFromExportDomainQueryParamenters = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    Frontend.getInstance().runQuery(VdcQueryType.GetTemplatesFromExportDomain, getAllFromExportDomainQueryParamenters, aQuery);
}
#method_after
public void getAllTemplatesFromExportDomain(AsyncQuery aQuery, Guid storagePoolId, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new HashMap<VmTemplate, ArrayList<DiskImage>>();
        }
    };
    GetAllFromExportDomainQueryParameters getAllFromExportDomainQueryParamenters = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    Frontend.getInstance().runQuery(VdcQueryType.GetTemplatesFromExportDomain, getAllFromExportDomainQueryParamenters, aQuery);
}
#end_block

#method_before
public static void getUpHostListByCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((ArrayList<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    getUpHostListByCluster(aQuery, clusterName, null);
}
#method_after
public void getUpHostListByCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((ArrayList<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    getUpHostListByCluster(aQuery, clusterName, null);
}
#end_block

#method_before
public static void getUpHostListByCluster(AsyncQuery aQuery, String clusterName, Integer maxCount) {
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: cluster = " + clusterName + " and status = up", SearchType.VDS);
    if (maxCount != null) {
        searchParameters.setMaxCount(maxCount);
    }
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public void getUpHostListByCluster(AsyncQuery aQuery, String clusterName, Integer maxCount) {
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: cluster = " + clusterName + " and status = up", SearchType.VDS);
    if (maxCount != null) {
        searchParameters.setMaxCount(maxCount);
    }
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#end_block

#method_before
public static void getVmNicList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<VmNetworkInterface>((ArrayList<VmNetworkInterface>) source) : new ArrayList<VmNetworkInterface>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmNicList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<VmNetworkInterface>((ArrayList<VmNetworkInterface>) source) : new ArrayList<VmNetworkInterface>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getTemplateNicList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<VmNetworkInterface>((ArrayList<VmNetworkInterface>) source) : new ArrayList<VmNetworkInterface>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetTemplateInterfacesByTemplateId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getTemplateNicList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<VmNetworkInterface>((ArrayList<VmNetworkInterface>) source) : new ArrayList<VmNetworkInterface>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetTemplateInterfacesByTemplateId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getVmSnapshotList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Snapshot>) source : new ArrayList<Snapshot>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmSnapshotsByVmId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmSnapshotList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Snapshot>) source : new ArrayList<Snapshot>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmSnapshotsByVmId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getVmsRunningOnOrMigratingToVds(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VM>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmsRunningOnOrMigratingToVds, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmsRunningOnOrMigratingToVds(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VM>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmsRunningOnOrMigratingToVds, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getVmDiskList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Disk> list = new ArrayList<Disk>();
            if (source != null) {
                Iterable listEnumerable = (Iterable) source;
                Iterator listIterator = listEnumerable.iterator();
                while (listIterator.hasNext()) {
                    list.add((Disk) listIterator.next());
                }
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmDiskList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Disk> list = new ArrayList<Disk>();
            if (source != null) {
                Iterable listEnumerable = (Iterable) source;
                Iterator listIterator = listEnumerable.iterator();
                while (listIterator.hasNext()) {
                    list.add((Disk) listIterator.next());
                }
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getVmList(AsyncQuery aQuery, String poolName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VM> vms = Linq.<VM>cast((ArrayList<IVdcQueryable>) source);
            return vms;
        }
    };
    // $NON-NLS-1$
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("Vms: pool=" + poolName, SearchType.VM), aQuery);
}
#method_after
public void getVmList(AsyncQuery aQuery, String poolName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VM> vms = Linq.<VM>cast((ArrayList<IVdcQueryable>) source);
            return vms;
        }
    };
    // $NON-NLS-1$
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("Vms: pool=" + poolName, SearchType.VM), aQuery);
}
#end_block

#method_before
public static void getVmListByClusterName(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VM> vms = Linq.<VM>cast((ArrayList<IVdcQueryable>) source);
            return vms;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("Vms: cluster=" + clusterName, SearchType.VM), // $NON-NLS-1$
    aQuery);
}
#method_after
public void getVmListByClusterName(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VM> vms = Linq.<VM>cast((ArrayList<IVdcQueryable>) source);
            return vms;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("Vms: cluster=" + clusterName, SearchType.VM), // $NON-NLS-1$
    aQuery);
}
#end_block

#method_before
public static void getDiskList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<DiskImage>) source : new ArrayList<DiskImage>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Disks:", SearchType.Disk);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#method_after
public void getDiskList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<DiskImage>) source : new ArrayList<DiskImage>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Disks:", SearchType.Disk);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#end_block

#method_before
public static void getNextAvailableDiskAliasNameByVMId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNextAvailableDiskAliasNameByVMId, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getNextAvailableDiskAliasNameByVMId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNextAvailableDiskAliasNameByVMId, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void isPoolNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !(Boolean) source;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmPoolWithSameNameExists, new NameQueryParameters(name), aQuery);
}
#method_after
public void isPoolNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !(Boolean) source;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmPoolWithSameNameExists, new NameQueryParameters(name), aQuery);
}
#end_block

#method_before
public static void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId).withoutRefresh(), aQuery);
}
#method_after
public void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void getAllAttachableDisks(AsyncQuery aQuery, Guid storagePoolId, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Disk>) source : new ArrayList<Disk>();
        }
    };
    GetAllAttachableDisks params = new GetAllAttachableDisks(storagePoolId);
    params.setVmId(vmId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllAttachableDisks, params, aQuery);
}
#method_after
public void getAllAttachableDisks(AsyncQuery aQuery, Guid storagePoolId, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Disk>) source : new ArrayList<Disk>();
        }
    };
    GetAllAttachableDisks params = new GetAllAttachableDisks(storagePoolId);
    params.setVmId(vmId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllAttachableDisks, params, aQuery);
}
#end_block

#method_before
public static void getPermittedStorageDomainsByStoragePoolId(AsyncQuery aQuery, Guid dataCenterId, ActionGroup actionGroup) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new java.util.ArrayList<StorageDomain>();
            }
            return source;
        }
    };
    GetPermittedStorageDomainsByStoragePoolIdParameters params = new GetPermittedStorageDomainsByStoragePoolIdParameters();
    params.setStoragePoolId(dataCenterId);
    params.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, params, aQuery);
}
#method_after
public void getPermittedStorageDomainsByStoragePoolId(AsyncQuery aQuery, Guid dataCenterId, ActionGroup actionGroup) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new java.util.ArrayList<StorageDomain>();
            }
            return source;
        }
    };
    GetPermittedStorageDomainsByStoragePoolIdParameters params = new GetPermittedStorageDomainsByStoragePoolIdParameters();
    params.setStoragePoolId(dataCenterId);
    params.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, params, aQuery);
}
#end_block

#method_before
public static void getAllDataCenterNetworks(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworksByDataCenterId, params, aQuery);
}
#method_after
public void getAllDataCenterNetworks(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworksByDataCenterId, params, aQuery);
}
#end_block

#method_before
public static void getStorageConnectionsByDataCenterIdAndStorageType(AsyncQuery aQuery, Guid storagePoolId, StorageType storageType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    GetConnectionsByDataCenterAndStorageTypeParameters params = new GetConnectionsByDataCenterAndStorageTypeParameters(storagePoolId, storageType);
    Frontend.getInstance().runQuery(VdcQueryType.GetConnectionsByDataCenterAndStorageType, params, aQuery);
}
#method_after
public void getStorageConnectionsByDataCenterIdAndStorageType(AsyncQuery aQuery, Guid storagePoolId, StorageType storageType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    GetConnectionsByDataCenterAndStorageTypeParameters params = new GetConnectionsByDataCenterAndStorageTypeParameters(storagePoolId, storageType);
    Frontend.getInstance().runQuery(VdcQueryType.GetConnectionsByDataCenterAndStorageType, params, aQuery);
}
#end_block

#method_before
public static void getRedirectServletReportsPage(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.RedirectServletReportsPage, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getRedirectServletReportsPage(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.RedirectServletReportsPage, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, new VdcQueryParametersBase().withoutRefresh(), aQuery);
    }
}
#method_after
public void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, new VdcQueryParametersBase().withoutRefresh(), aQuery);
    }
}
#end_block

#method_before
private static boolean isCommandCompatible(VdcActionType vdcActionType, Version cluster, Version dc) {
    if (cachedCommandsCompatibilityVersions == null || cluster == null || dc == null) {
        return false;
    }
    CommandVersionsInfo commandVersionsInfo = cachedCommandsCompatibilityVersions.get(vdcActionType);
    if (commandVersionsInfo == null) {
        return false;
    }
    Version clusterCompatibility = commandVersionsInfo.getClusterVersion();
    Version dcCompatibility = commandVersionsInfo.getStoragePoolVersion();
    return (clusterCompatibility.compareTo(cluster) <= 0) && (dcCompatibility.compareTo(dc) <= 0);
}
#method_after
private boolean isCommandCompatible(VdcActionType vdcActionType, Version cluster, Version dc) {
    if (cachedCommandsCompatibilityVersions == null || cluster == null || dc == null) {
        return false;
    }
    CommandVersionsInfo commandVersionsInfo = cachedCommandsCompatibilityVersions.get(vdcActionType);
    if (commandVersionsInfo == null) {
        return false;
    }
    Version clusterCompatibility = commandVersionsInfo.getClusterVersion();
    Version dcCompatibility = commandVersionsInfo.getStoragePoolVersion();
    return (clusterCompatibility.compareTo(cluster) <= 0) && (dcCompatibility.compareTo(dc) <= 0);
}
#end_block

#method_before
public static CommandVersionsInfo getCommandVersionsInfo(VdcActionType vdcActionType) {
    if (cachedCommandsCompatibilityVersions == null) {
        return null;
    }
    return cachedCommandsCompatibilityVersions.get(vdcActionType);
}
#method_after
public CommandVersionsInfo getCommandVersionsInfo(VdcActionType vdcActionType) {
    if (cachedCommandsCompatibilityVersions == null) {
        return null;
    }
    return cachedCommandsCompatibilityVersions.get(vdcActionType);
}
#end_block

#method_before
public static void getManagementNetworkName(AsyncQuery aQuery) {
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.ManagementNetwork, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getManagementNetworkName(AsyncQuery aQuery) {
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.ManagementNetwork, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
private static void cacheConfigValues(AsyncQuery aQuery) {
    getDefaultConfigurationVersion();
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object returnValue, AsyncQuery _asyncQuery) {
            if (returnValue != null) {
                cachedConfigValuesPreConvert.putAll((HashMap<KeyValuePairCompat<ConfigurationValues, String>, Object>) returnValue);
            }
            return cachedConfigValuesPreConvert;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetConfigurationValues, new VdcQueryParametersBase(), aQuery);
}
#method_after
private void cacheConfigValues(AsyncQuery aQuery) {
    getDefaultConfigurationVersion();
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object returnValue, AsyncQuery _asyncQuery) {
            if (returnValue != null) {
                cachedConfigValuesPreConvert.putAll((HashMap<KeyValuePairCompat<ConfigurationValues, String>, Object>) returnValue);
            }
            return cachedConfigValuesPreConvert;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetConfigurationValues, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static Object getConfigValuePreConverted(ConfigurationValues configValue, String version) {
    KeyValuePairCompat<ConfigurationValues, String> key = new KeyValuePairCompat<ConfigurationValues, String>(configValue, version);
    return cachedConfigValuesPreConvert.get(key);
}
#method_after
public Object getConfigValuePreConverted(ConfigurationValues configValue, String version) {
    KeyValuePairCompat<ConfigurationValues, String> key = new KeyValuePairCompat<ConfigurationValues, String>(configValue, version);
    return cachedConfigValuesPreConvert.get(key);
}
#end_block

#method_before
public static Object getConfigValuePreConverted(ConfigurationValues configValue) {
    KeyValuePairCompat<ConfigurationValues, String> key = new KeyValuePairCompat<ConfigurationValues, String>(configValue, getDefaultConfigurationVersion());
    return cachedConfigValuesPreConvert.get(key);
}
#method_after
public Object getConfigValuePreConverted(ConfigurationValues configValue) {
    KeyValuePairCompat<ConfigurationValues, String> key = new KeyValuePairCompat<ConfigurationValues, String>(configValue, getDefaultConfigurationVersion());
    return cachedConfigValuesPreConvert.get(key);
}
#end_block

#method_before
public static Object getConfigValue(ConfigurationValues configValue, String version, IAsyncConverter converter) {
    if (converter == null) {
        return null;
    }
    KeyValuePairCompat<ConfigurationValues, String> key = new KeyValuePairCompat<ConfigurationValues, String>(configValue, version);
    return converter.Convert(cachedConfigValuesPreConvert.get(key), null);
}
#method_after
public Object getConfigValue(ConfigurationValues configValue, String version, IAsyncConverter converter) {
    if (converter == null) {
        return null;
    }
    KeyValuePairCompat<ConfigurationValues, String> key = new KeyValuePairCompat<ConfigurationValues, String>(configValue, version);
    return converter.Convert(cachedConfigValuesPreConvert.get(key), null);
}
#end_block

#method_before
public static void getConfigFromCache(GetConfigurationValueParameters parameters, AsyncQuery aQuery) {
    // cache key
    final KeyValuePairCompat<ConfigurationValues, String> config_key = new KeyValuePairCompat<ConfigurationValues, String>(parameters.getConfigValue(), parameters.getVersion());
    Object returnValue = null;
    if (cachedConfigValues.containsKey(config_key)) {
        // cache hit
        returnValue = cachedConfigValues.get(config_key);
    } else // and call asyncCallback's onSuccess
    if (cachedConfigValuesPreConvert.containsKey(config_key)) {
        returnValue = cachedConfigValuesPreConvert.get(config_key);
        // run converter
        if (aQuery.converterCallback != null) {
            returnValue = aQuery.converterCallback.Convert(returnValue, aQuery);
        }
        if (returnValue != null) {
            cachedConfigValues.put(config_key, returnValue);
        }
    }
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), returnValue);
}
#method_after
public void getConfigFromCache(GetConfigurationValueParameters parameters, AsyncQuery aQuery) {
    // cache key
    final KeyValuePairCompat<ConfigurationValues, String> config_key = new KeyValuePairCompat<ConfigurationValues, String>(parameters.getConfigValue(), parameters.getVersion());
    Object returnValue = null;
    if (cachedConfigValues.containsKey(config_key)) {
        // cache hit
        returnValue = cachedConfigValues.get(config_key);
    } else // and call asyncCallback's onSuccess
    if (cachedConfigValuesPreConvert.containsKey(config_key)) {
        returnValue = cachedConfigValuesPreConvert.get(config_key);
        // run converter
        if (aQuery.converterCallback != null) {
            returnValue = aQuery.converterCallback.Convert(returnValue, aQuery);
        }
        if (returnValue != null) {
            cachedConfigValues.put(config_key, returnValue);
        }
    }
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), returnValue);
}
#end_block

#method_before
public static void getConfigFromCache(ConfigurationValues configValue, String version, AsyncQuery aQuery) {
    GetConfigurationValueParameters parameters = new GetConfigurationValueParameters(configValue, version);
    getConfigFromCache(parameters, aQuery);
}
#method_after
public void getConfigFromCache(ConfigurationValues configValue, String version, AsyncQuery aQuery) {
    GetConfigurationValueParameters parameters = new GetConfigurationValueParameters(configValue, version);
    getConfigFromCache(parameters, aQuery);
}
#end_block

#method_before
public static ArrayList<QuotaEnforcementTypeEnum> getQuotaEnforcmentTypes() {
    return new ArrayList<QuotaEnforcementTypeEnum>(Arrays.asList(new QuotaEnforcementTypeEnum[] { QuotaEnforcementTypeEnum.DISABLED, QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT, QuotaEnforcementTypeEnum.HARD_ENFORCEMENT }));
}
#method_after
public ArrayList<QuotaEnforcementTypeEnum> getQuotaEnforcmentTypes() {
    return new ArrayList<QuotaEnforcementTypeEnum>(Arrays.asList(new QuotaEnforcementTypeEnum[] { QuotaEnforcementTypeEnum.DISABLED, QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT, QuotaEnforcementTypeEnum.HARD_ENFORCEMENT }));
}
#end_block

#method_before
public static void clearCache() {
    cachedConfigValues.clear();
}
#method_after
public void clearCache() {
    cachedConfigValues.clear();
}
#end_block

#method_before
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = returnValue.getReturnValue();
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (ObjectUtils.objectsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (ObjectUtils.objectsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#method_after
public void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = returnValue.getReturnValue();
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (ObjectUtils.objectsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (ObjectUtils.objectsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#end_block

#method_before
private static void getVlanParentInterface(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVlanParent, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#method_after
private void getVlanParentInterface(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVlanParent, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#end_block

#method_before
private static void interfaceHasSiblingVlanInterfaces(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VdsNetworkInterface> siblingVlanInterfaces = (ArrayList<VdsNetworkInterface>) source;
            return !siblingVlanInterfaces.isEmpty();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllSiblingVlanInterfaces, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#method_after
private void interfaceHasSiblingVlanInterfaces(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VdsNetworkInterface> siblingVlanInterfaces = (ArrayList<VdsNetworkInterface>) source;
            return !siblingVlanInterfaces.isEmpty();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllSiblingVlanInterfaces, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#end_block

#method_before
public static void getExternalProviderHostList(AsyncQuery aQuery, Guid providerId, boolean filterOutExistingHosts, String searchFilter) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDS>();
            }
            return source;
        }
    };
    GetHostListFromExternalProviderParameters params = new GetHostListFromExternalProviderParameters();
    params.setFilterOutExistingHosts(filterOutExistingHosts);
    params.setProviderId(providerId);
    params.setSearchFilter(searchFilter);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostListFromExternalProvider, params, aQuery);
}
#method_after
public void getExternalProviderHostList(AsyncQuery aQuery, Guid providerId, boolean filterOutExistingHosts, String searchFilter) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDS>();
            }
            return source;
        }
    };
    GetHostListFromExternalProviderParameters params = new GetHostListFromExternalProviderParameters();
    params.setFilterOutExistingHosts(filterOutExistingHosts);
    params.setProviderId(providerId);
    params.setSearchFilter(searchFilter);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostListFromExternalProvider, params, aQuery);
}
#end_block

#method_before
public static void getExternalProviderDiscoveredHostList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<ExternalDiscoveredHost>();
            }
            return source;
        }
    };
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetDiscoveredHostListFromExternalProvider, params, aQuery);
}
#method_after
public void getExternalProviderDiscoveredHostList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<ExternalDiscoveredHost>();
            }
            return source;
        }
    };
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetDiscoveredHostListFromExternalProvider, params, aQuery);
}
#end_block

#method_before
public static void getExternalProviderHostGroupList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<ExternalHostGroup>();
            }
            return source;
        }
    };
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostGroupsFromExternalProvider, params, aQuery);
}
#method_after
public void getExternalProviderHostGroupList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<ExternalHostGroup>();
            }
            return source;
        }
    };
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostGroupsFromExternalProvider, params, aQuery);
}
#end_block

#method_before
public static void getExternalProviderComputeResourceList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<ExternalComputeResource>();
            }
            return source;
        }
    };
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetComputeResourceFromExternalProvider, params, aQuery);
}
#method_after
public void getExternalProviderComputeResourceList(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<ExternalComputeResource>();
            }
            return source;
        }
    };
    ProviderQueryParameters params = new ProviderQueryParameters();
    params.setProvider(provider);
    Frontend.getInstance().runQuery(VdcQueryType.GetComputeResourceFromExternalProvider, params, aQuery);
}
#end_block

#method_before
public static void getAllProviders(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            Collections.sort((List<Provider>) source, new NameableComparator());
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), aQuery);
}
#method_after
public void getAllProviders(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            Collections.sort((List<Provider>) source, new NameableComparator());
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), aQuery);
}
#end_block

#method_before
public static void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new IAsyncConverter<List<Provider>>() {

        @Override
        public List<Provider> Convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<Provider>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Collection<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#method_after
public void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new IAsyncConverter<List<Provider>>() {

        @Override
        public List<Provider> Convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<Provider>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Collection<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#end_block

#method_before
public static void getAllNetworkProviders(AsyncQuery query) {
    getAllProvidersByProvidedEntity(query, VdcObjectType.Network);
}
#method_after
public void getAllNetworkProviders(AsyncQuery query) {
    getAllProvidersByProvidedEntity(query, VdcObjectType.Network);
}
#end_block

#method_before
public static void getAllProvidersByType(AsyncQuery aQuery, ProviderType providerType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(providerType), aQuery);
}
#method_after
public void getAllProvidersByType(AsyncQuery aQuery, ProviderType providerType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(providerType), aQuery);
}
#end_block

#method_before
public static void getProviderCertificateChain(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChain, new ProviderQueryParameters(provider), aQuery);
}
#method_after
public void getProviderCertificateChain(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChain, new ProviderQueryParameters(provider), aQuery);
}
#end_block

#method_before
private static void getAllChildVlanInterfaces(Guid vdsID, List<VdsNetworkInterface> ifaces, IFrontendMultipleQueryAsyncCallback callback) {
    ArrayList<VdcQueryParametersBase> parametersList = new ArrayList<VdcQueryParametersBase>();
    ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
    for (final VdsNetworkInterface iface : ifaces) {
        queryTypeList.add(VdcQueryType.GetAllChildVlanInterfaces);
        parametersList.add(new InterfaceAndIdQueryParameters(vdsID, iface));
    }
    Frontend.getInstance().runMultipleQueries(queryTypeList, parametersList, callback);
}
#method_after
private void getAllChildVlanInterfaces(Guid vdsID, List<VdsNetworkInterface> ifaces, IFrontendMultipleQueryAsyncCallback callback) {
    ArrayList<VdcQueryParametersBase> parametersList = new ArrayList<VdcQueryParametersBase>();
    ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
    for (final VdsNetworkInterface iface : ifaces) {
        queryTypeList.add(VdcQueryType.GetAllChildVlanInterfaces);
        parametersList.add(new InterfaceAndIdQueryParameters(vdsID, iface));
    }
    Frontend.getInstance().runMultipleQueries(queryTypeList, parametersList, callback);
}
#end_block

#method_before
public static void isSupportBridgesReportByVDSM(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Boolean) source).booleanValue() : true;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.SupportBridgesReportByVDSM);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void isSupportBridgesReportByVDSM(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Boolean) source).booleanValue() : true;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.SupportBridgesReportByVDSM);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public static void fillTagsRecursive(Tags tagToFill, List<Tags> children) {
    ArrayList<Tags> list = new ArrayList<Tags>();
    for (Tags tag : children) {
        // tags child = new tags(tag.description, tag.parent_id, tag.IsReadonly, tag.tag_id, tag.tag_name);
        if (tag.gettype() == TagsType.GeneralTag) {
            list.add(tag);
            if (tag.getChildren() != null) {
                fillTagsRecursive(tag, tag.getChildren());
            }
        }
    }
    tagToFill.setChildren(list);
}
#method_after
public void fillTagsRecursive(Tags tagToFill, List<Tags> children) {
    ArrayList<Tags> list = new ArrayList<Tags>();
    for (Tags tag : children) {
        // tags child = new tags(tag.description, tag.parent_id, tag.IsReadonly, tag.tag_id, tag.tag_name);
        if (tag.gettype() == TagsType.GeneralTag) {
            list.add(tag);
            if (tag.getChildren() != null) {
                fillTagsRecursive(tag, tag.getChildren());
            }
        }
    }
    tagToFill.setChildren(list);
}
#end_block

#method_before
public static ArrayList<EventNotificationEntity> getEventNotificationTypeList() {
    ArrayList<EventNotificationEntity> ret = new ArrayList<EventNotificationEntity>();
    // TODO: We can translate it here too
    for (EventNotificationEntity entity : EventNotificationEntity.values()) {
        if (entity != EventNotificationEntity.UNKNOWN) {
            ret.add(entity);
        }
    }
    return ret;
}
#method_after
public ArrayList<EventNotificationEntity> getEventNotificationTypeList() {
    ArrayList<EventNotificationEntity> ret = new ArrayList<EventNotificationEntity>();
    // TODO: We can translate it here too
    for (EventNotificationEntity entity : EventNotificationEntity.values()) {
        if (entity != EventNotificationEntity.UNKNOWN) {
            ret.add(entity);
        }
    }
    return ret;
}
#end_block

#method_before
public static Map<EventNotificationEntity, HashSet<AuditLogType>> getAvailableNotificationEvents() {
    return VdcEventNotificationUtils.getNotificationEvents();
}
#method_after
public Map<EventNotificationEntity, HashSet<AuditLogType>> getAvailableNotificationEvents() {
    return VdcEventNotificationUtils.getNotificationEvents();
}
#end_block

#method_before
public static void getNicTypeList(final int osId, Version version, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> nics = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<VmInterfaceType> interfaceTypes = new ArrayList<VmInterfaceType>();
            for (String nic : nics) {
                try {
                    interfaceTypes.add(VmInterfaceType.valueOf(nic));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNetworkDevices, osId, version), asyncQuery);
}
#method_after
public void getNicTypeList(final int osId, Version version, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> nics = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<VmInterfaceType> interfaceTypes = new ArrayList<VmInterfaceType>();
            for (String nic : nics) {
                try {
                    interfaceTypes.add(VmInterfaceType.valueOf(nic));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNetworkDevices, osId, version), asyncQuery);
}
#end_block

#method_before
public static VmInterfaceType getDefaultNicType(Collection<VmInterfaceType> items) {
    if (items == null || items.isEmpty()) {
        return null;
    } else if (items.contains(VmInterfaceType.pv)) {
        return VmInterfaceType.pv;
    } else {
        return items.iterator().next();
    }
}
#method_after
public VmInterfaceType getDefaultNicType(Collection<VmInterfaceType> items) {
    if (items == null || items.isEmpty()) {
        return null;
    } else if (items.contains(VmInterfaceType.pv)) {
        return VmInterfaceType.pv;
    } else {
        return items.iterator().next();
    }
}
#end_block

#method_before
public static boolean isVersionMatchStorageType(Version version, boolean isLocalType) {
    return version.compareTo(new Version(3, 0)) >= 0;
}
#method_after
public boolean isVersionMatchStorageType(Version version, boolean isLocalType) {
    return version.compareTo(new Version(3, 0)) >= 0;
}
#end_block

#method_before
public static int getClusterDefaultMemoryOverCommit() {
    return 100;
}
#method_after
public int getClusterDefaultMemoryOverCommit() {
    return 100;
}
#end_block

#method_before
public static boolean getClusterDefaultCountThreadsAsCores() {
    return false;
}
#method_after
public boolean getClusterDefaultCountThreadsAsCores() {
    return false;
}
#end_block

#method_before
public static ArrayList<VolumeType> getVolumeTypeList() {
    return new ArrayList<VolumeType>(Arrays.asList(new VolumeType[] { VolumeType.Preallocated, VolumeType.Sparse }));
}
#method_after
public ArrayList<VolumeType> getVolumeTypeList() {
    return new ArrayList<VolumeType>(Arrays.asList(new VolumeType[] { VolumeType.Preallocated, VolumeType.Sparse }));
}
#end_block

#method_before
public static ArrayList<StorageType> getStorageTypeList() {
    return new ArrayList<StorageType>(Arrays.asList(new StorageType[] { StorageType.ISCSI, StorageType.FCP }));
}
#method_after
public ArrayList<StorageType> getStorageTypeList() {
    return new ArrayList<StorageType>(Arrays.asList(new StorageType[] { StorageType.ISCSI, StorageType.FCP }));
}
#end_block

#method_before
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#method_after
public void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#end_block

#method_before
public static ArrayList<DiskInterface> getDiskInterfaceList() {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI, DiskInterface.SPAPR_VSCSI }));
    return diskInterfaces;
}
#method_after
public ArrayList<DiskInterface> getDiskInterfaceList() {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI, DiskInterface.SPAPR_VSCSI }));
    return diskInterfaces;
}
#end_block

#method_before
public static String getNewNicName(Collection<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#method_after
public String getNewNicName(Collection<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#end_block

#method_before
public static String getComplexValueFromSpiceRedKeysResource(String complexValue) {
    if (StringHelper.isNullOrEmpty(complexValue)) {
        // $NON-NLS-1$
        return "";
    }
    ArrayList<String> values = new ArrayList<String>();
    for (String s : complexValue.split("[+]", -1)) {
        // $NON-NLS-1$
        try {
            String value = SpiceConstantsManager.getInstance().getSpiceRedKeys().getString(// $NON-NLS-1$ //$NON-NLS-2$
            s.replaceAll("-", "_"));
            values.add(value);
        } catch (MissingResourceException e) {
            values.add(s);
        }
    }
    // $NON-NLS-1$
    return StringHelper.join("+", values.toArray(new String[] {}));
}
#method_after
public String getComplexValueFromSpiceRedKeysResource(String complexValue) {
    if (StringHelper.isNullOrEmpty(complexValue)) {
        // $NON-NLS-1$
        return "";
    }
    ArrayList<String> values = new ArrayList<String>();
    for (String s : complexValue.split("[+]", -1)) {
        // $NON-NLS-1$
        try {
            String value = SpiceConstantsManager.getInstance().getSpiceRedKeys().getString(// $NON-NLS-1$ //$NON-NLS-2$
            s.replaceAll("-", "_"));
            values.add(value);
        } catch (MissingResourceException e) {
            values.add(s);
        }
    }
    // $NON-NLS-1$
    return StringHelper.join("+", values.toArray(new String[] {}));
}
#end_block

#method_before
public static Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof DbGroup) {
        return ((DbGroup) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    }
    return Guid.Empty;
}
#method_after
public Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof DbGroup) {
        return ((DbGroup) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    }
    return Guid.Empty;
}
#end_block

#method_before
public static boolean isWindowsOsType(Integer osType) {
    // can be null as a consequence of setItems on ListModel
    if (osType == null) {
        return false;
    }
    return windowsOsIds.contains(osType);
}
#method_after
public boolean isWindowsOsType(Integer osType) {
    // can be null as a consequence of setItems on ListModel
    if (osType == null) {
        return false;
    }
    return windowsOsIds.contains(osType);
}
#end_block

#method_before
public static boolean isLinuxOsType(Integer osId) {
    // can be null as a consequence of setItems on ListModel
    if (osId == null) {
        return false;
    }
    return linuxOsIds.contains(osId);
}
#method_after
public boolean isLinuxOsType(Integer osId) {
    // can be null as a consequence of setItems on ListModel
    if (osId == null) {
        return false;
    }
    return linuxOsIds.contains(osId);
}
#end_block

#method_before
public static void initWindowsOsTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            windowsOsIds = (ArrayList<Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetWindowsOss), callback);
}
#method_after
public void initWindowsOsTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            windowsOsIds = (ArrayList<Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetWindowsOss), callback);
}
#end_block

#method_before
public static void initLinuxOsTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            linuxOsIds = (ArrayList<Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetLinuxOss), callback);
}
#method_after
public void initLinuxOsTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            linuxOsIds = (ArrayList<Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetLinuxOss), callback);
}
#end_block

#method_before
public static void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#method_after
public void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#end_block

#method_before
public static void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#method_after
public void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#end_block

#method_before
private static void initOsIds() {
    osIds = new ArrayList<Integer>(osNames.keySet());
    Collections.sort(osIds, new Comparator<Integer>() {

        @Override
        public int compare(Integer o1, Integer o2) {
            return osNames.get(o1).compareTo(osNames.get(o2));
        }
    });
}
#method_after
private void initOsIds() {
    osIds = new ArrayList<Integer>(osNames.keySet());
    Collections.sort(osIds, new Comparator<Integer>() {

        @Override
        public int compare(Integer o1, Integer o2) {
            return osNames.get(o1).compareTo(osNames.get(o2));
        }
    });
}
#end_block

#method_before
public static void initOsArchitecture() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osArchitectures = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsArchitectures), callback);
}
#method_after
public void initOsArchitecture() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osArchitectures = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsArchitectures), callback);
}
#end_block

#method_before
public static boolean osNameExists(Integer osId) {
    return osNames.keySet().contains(osId);
}
#method_after
public boolean osNameExists(Integer osId) {
    return osNames.keySet().contains(osId);
}
#end_block

#method_before
public static String getOsName(Integer osId) {
    // can be null as a consequence of setItems on ListModel
    if (osId == null) {
        return "";
    }
    return osNames.get(osId);
}
#method_after
public String getOsName(Integer osId) {
    // can be null as a consequence of setItems on ListModel
    if (osId == null) {
        return "";
    }
    return osNames.get(osId);
}
#end_block

#method_before
public static boolean hasSpiceSupport(int osId, Version version) {
    return getDisplayTypes(osId, version).contains(DisplayType.qxl);
}
#method_after
public boolean hasSpiceSupport(int osId, Version version) {
    return getDisplayTypes(osId, version).contains(DisplayType.qxl);
}
#end_block

#method_before
public static List<DisplayType> getDisplayTypes(int osId, Version version) {
    return displayTypes.get(osId).get(version);
}
#method_after
public List<DisplayType> getDisplayTypes(int osId, Version version) {
    return displayTypes.get(osId).get(version);
}
#end_block

#method_before
private static void initDisplayTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            displayTypes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), callback);
}
#method_after
private void initDisplayTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            displayTypes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), callback);
}
#end_block

#method_before
public static List<Integer> getOsIds(ArchitectureType architectureType) {
    List<Integer> osIds = new ArrayList<Integer>();
    for (Entry<Integer, ArchitectureType> entry : osArchitectures.entrySet()) {
        if (entry.getValue() == architectureType) {
            osIds.add(entry.getKey());
        }
    }
    Collections.sort(osIds, new Comparator<Integer>() {

        @Override
        public int compare(Integer o1, Integer o2) {
            return osNames.get(o1).compareTo(osNames.get(o2));
        }
    });
    return osIds;
}
#method_after
public List<Integer> getOsIds(ArchitectureType architectureType) {
    List<Integer> osIds = new ArrayList<Integer>();
    for (Entry<Integer, ArchitectureType> entry : osArchitectures.entrySet()) {
        if (entry.getValue() == architectureType) {
            osIds.add(entry.getKey());
        }
    }
    Collections.sort(osIds, new Comparator<Integer>() {

        @Override
        public int compare(Integer o1, Integer o2) {
            return osNames.get(o1).compareTo(osNames.get(o2));
        }
    });
    return osIds;
}
#end_block

#method_before
public static void getOsMaxRam(int osId, Version version, AsyncQuery asyncQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetMaxOsRam, osId, version), asyncQuery);
}
#method_after
public void getOsMaxRam(int osId, Version version, AsyncQuery asyncQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetMaxOsRam, osId, version), asyncQuery);
}
#end_block

#method_before
public static void getVmWatchdogTypes(int osId, Version version, AsyncQuery asyncQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetVmWatchdogTypes, osId, version), asyncQuery);
}
#method_after
public void getVmWatchdogTypes(int osId, Version version, AsyncQuery asyncQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetVmWatchdogTypes, osId, version), asyncQuery);
}
#end_block

#method_before
public static ArrayList<Map.Entry<String, EntityModel<String>>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel<String>>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel<String>>> list = new ArrayList<Map.Entry<String, EntityModel<String>>>();
    EntityModel<String> entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel<String>>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("custom", entityModel));
    return list;
}
#method_after
public ArrayList<Map.Entry<String, EntityModel<String>>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel<String>>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel<String>>> list = new ArrayList<Map.Entry<String, EntityModel<String>>>();
    EntityModel<String> entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel<String>>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("custom", entityModel));
    return list;
}
#end_block

#method_before
public static String getDefaultBondingOption() {
    // $NON-NLS-1$
    return "mode=802.3ad miimon=150";
}
#method_after
public String getDefaultBondingOption() {
    // $NON-NLS-1$
    return "mode=802.3ad miimon=150";
}
#end_block

#method_before
public static int getMaxVmPriority() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.VmPriorityMaxValue, getDefaultConfigurationVersion());
}
#method_after
public int getMaxVmPriority() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.VmPriorityMaxValue, getDefaultConfigurationVersion());
}
#end_block

#method_before
public static int roundPriority(int priority) {
    int max = getMaxVmPriority();
    int medium = max / 2;
    int[] levels = new int[] { 1, medium, max };
    for (int i = 0; i < levels.length; i++) {
        int lengthToLess = levels[i] - priority;
        int lengthToMore = levels[i + 1] - priority;
        if (lengthToMore < 0) {
            continue;
        }
        return Math.abs(lengthToLess) < lengthToMore ? levels[i] : levels[i + 1];
    }
    return 0;
}
#method_after
public int roundPriority(int priority) {
    int max = getMaxVmPriority();
    int medium = max / 2;
    int[] levels = new int[] { 1, medium, max };
    for (int i = 0; i < levels.length; i++) {
        int lengthToLess = levels[i] - priority;
        int lengthToMore = levels[i + 1] - priority;
        if (lengthToMore < 0) {
            continue;
        }
        return Math.abs(lengthToLess) < lengthToMore ? levels[i] : levels[i + 1];
    }
    return 0;
}
#end_block

#method_before
public static void getVmGuestAgentInterfacesByVmId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VmGuestAgentInterface>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmGuestAgentInterfacesByVmId, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getVmGuestAgentInterfacesByVmId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VmGuestAgentInterface>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmGuestAgentInterfacesByVmId, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void getVnicProfilesByNetworkId(AsyncQuery aQuery, Guid networkId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VnicProfileView>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByNetworkId, new IdQueryParameters(networkId), aQuery);
}
#method_after
public void getVnicProfilesByNetworkId(AsyncQuery aQuery, Guid networkId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VnicProfileView>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByNetworkId, new IdQueryParameters(networkId), aQuery);
}
#end_block

#method_before
public static void getVnicProfilesByDcId(AsyncQuery aQuery, Guid dcId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return new ArrayList<VnicProfileView>();
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByDataCenterId, new IdQueryParameters(dcId), aQuery);
}
#method_after
public void getVnicProfilesByDcId(AsyncQuery aQuery, Guid dcId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return new ArrayList<VnicProfileView>();
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByDataCenterId, new IdQueryParameters(dcId), aQuery);
}
#end_block

#method_before
public static void getNumberOfActiveVmsInCluster(AsyncQuery aQuery, Guid clusterId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return Integer.valueOf(0);
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetNumberOfActiveVmsInVdsGroupByVdsGroupId, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getNumberOfActiveVmsInCluster(AsyncQuery aQuery, Guid clusterId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return Integer.valueOf(0);
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetNumberOfActiveVmsInVdsGroupByVdsGroupId, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
public static void getNumberOfVmsInCluster(AsyncQuery aQuery, Guid clusterId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetNumberOfVmsInVdsGroupByVdsGroupId, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getNumberOfVmsInCluster(AsyncQuery aQuery, Guid clusterId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetNumberOfVmsInVdsGroupByVdsGroupId, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
public static boolean isMixedStorageDomainsSupported(Version version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.MixedDomainTypesInDataCenter, version.toString());
}
#method_after
public boolean isMixedStorageDomainsSupported(Version version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.MixedDomainTypesInDataCenter, version.toString());
}
#end_block

#method_before
private static ArrayList<VDSGroup> getClusterByServiceList(ArrayList<VDSGroup> list, boolean supportsVirtService, boolean supportsGlusterService) {
    final ArrayList<VDSGroup> filteredList = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : list) {
        if ((supportsVirtService && cluster.supportsVirtService()) || (supportsGlusterService && cluster.supportsGlusterService())) {
            filteredList.add(cluster);
        }
    }
    // sort by cluster name
    Collections.sort(filteredList, new NameableComparator());
    return filteredList;
}
#method_after
private ArrayList<VDSGroup> getClusterByServiceList(ArrayList<VDSGroup> list, boolean supportsVirtService, boolean supportsGlusterService) {
    final ArrayList<VDSGroup> filteredList = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : list) {
        if ((supportsVirtService && cluster.supportsVirtService()) || (supportsGlusterService && cluster.supportsGlusterService())) {
            filteredList.add(cluster);
        }
    }
    // sort by cluster name
    Collections.sort(filteredList, new NameableComparator());
    return filteredList;
}
#end_block

#method_before
public static String priorityToString(int value) {
    int roundedPriority = AsyncDataProvider.roundPriority(value);
    if (roundedPriority == 1) {
        return ConstantsManager.getInstance().getConstants().vmLowPriority();
    } else if (roundedPriority == AsyncDataProvider.getMaxVmPriority() / 2) {
        return ConstantsManager.getInstance().getConstants().vmMediumPriority();
    } else if (roundedPriority == AsyncDataProvider.getMaxVmPriority()) {
        return ConstantsManager.getInstance().getConstants().vmHighPriority();
    } else {
        return ConstantsManager.getInstance().getConstants().vmUnknownPriority();
    }
}
#method_after
public String priorityToString(int value) {
    int roundedPriority = roundPriority(value);
    if (roundedPriority == 1) {
        return ConstantsManager.getInstance().getConstants().vmLowPriority();
    } else if (roundedPriority == getMaxVmPriority() / 2) {
        return ConstantsManager.getInstance().getConstants().vmMediumPriority();
    } else if (roundedPriority == getMaxVmPriority()) {
        return ConstantsManager.getInstance().getConstants().vmHighPriority();
    } else {
        return ConstantsManager.getInstance().getConstants().vmUnknownPriority();
    }
}
#end_block

#method_before
public static void getExternalNetworkMap(AsyncQuery aQuery, Guid providerId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new HashMap<Network, Set<Guid>>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllExternalNetworksOnProvider, new IdQueryParameters(providerId), aQuery);
}
#method_after
public void getExternalNetworkMap(AsyncQuery aQuery, Guid providerId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new HashMap<Network, Set<Guid>>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllExternalNetworksOnProvider, new IdQueryParameters(providerId), aQuery);
}
#end_block

#method_before
public static Integer getMaxVmNameLengthWin() {
    Integer maxVmNameLengthWindows = (Integer) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MaxVmNameLengthWindows);
    if (maxVmNameLengthWindows == null) {
        return 15;
    }
    return maxVmNameLengthWindows;
}
#method_after
public Integer getMaxVmNameLengthWin() {
    Integer maxVmNameLengthWindows = (Integer) getConfigValuePreConverted(ConfigurationValues.MaxVmNameLengthWindows);
    if (maxVmNameLengthWindows == null) {
        return 15;
    }
    return maxVmNameLengthWindows;
}
#end_block

#method_before
public static Integer getMaxVmNameLengthNonWin() {
    Integer maxVmNameLengthNonWindows = (Integer) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MaxVmNameLengthNonWindows);
    if (maxVmNameLengthNonWindows == null) {
        return 64;
    }
    return maxVmNameLengthNonWindows;
}
#method_after
public Integer getMaxVmNameLengthNonWin() {
    Integer maxVmNameLengthNonWindows = (Integer) getConfigValuePreConverted(ConfigurationValues.MaxVmNameLengthNonWindows);
    if (maxVmNameLengthNonWindows == null) {
        return 64;
    }
    return maxVmNameLengthNonWindows;
}
#end_block

#method_before
public static int getOptimizeSchedulerForSpeedPendingRequests() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.SpeedOptimizationSchedulingThreshold, getDefaultConfigurationVersion());
}
#method_after
public int getOptimizeSchedulerForSpeedPendingRequests() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.SpeedOptimizationSchedulingThreshold, getDefaultConfigurationVersion());
}
#end_block

#method_before
public static boolean getScheudulingAllowOverbookingSupported() {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.SchedulerAllowOverBooking, getDefaultConfigurationVersion());
}
#method_after
public boolean getScheudulingAllowOverbookingSupported() {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.SchedulerAllowOverBooking, getDefaultConfigurationVersion());
}
#end_block

#method_before
public static int getSchedulerAllowOverbookingPendingRequestsThreshold() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.SchedulerOverBookingThreshold, getDefaultConfigurationVersion());
}
#method_after
public int getSchedulerAllowOverbookingPendingRequestsThreshold() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.SchedulerOverBookingThreshold, getDefaultConfigurationVersion());
}
#end_block

#method_before
public static Integer getDefaultOs(ArchitectureType architectureType) {
    return defaultOSes.get(architectureType);
}
#method_after
public Integer getDefaultOs(ArchitectureType architectureType) {
    return defaultOSes.get(architectureType);
}
#end_block

#method_before
public static boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        // currently on VDSM side reboot is supported only when the guest agent is present and responsive so we need to check for that
        if (!isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion) || StringHelper.isNullOrEmpty(vm.getVmIp())) {
            return false;
        }
    }
    return true;
}
#method_after
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        // currently on VDSM side reboot is supported only when the guest agent is present and responsive so we need to check for that
        if (!isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion) || StringHelper.isNullOrEmpty(vm.getVmIp())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public static boolean isSerialNumberPolicySupported(String version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.SerialNumberPolicySupported, version);
}
#method_after
public boolean isSerialNumberPolicySupported(String version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.SerialNumberPolicySupported, version);
}
#end_block

#method_before
public static boolean isBootMenuSupported(String version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.BootMenuSupported, version);
}
#method_after
public boolean isBootMenuSupported(String version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.BootMenuSupported, version);
}
#end_block

#method_before
public static boolean isSpiceFileTransferToggleSupported(String version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.SpiceFileTransferToggleSupported, version);
}
#method_after
public boolean isSpiceFileTransferToggleSupported(String version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.SpiceFileTransferToggleSupported, version);
}
#end_block

#method_before
public static boolean isSpiceCopyPasteToggleSupported(String version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.SpiceCopyPasteToggleSupported, version);
}
#method_after
public boolean isSpiceCopyPasteToggleSupported(String version) {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.SpiceCopyPasteToggleSupported, version);
}
#end_block

#method_before
public static List<IStorageModel> getDataStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    models.addAll(getFileDataStorageModels());
    models.addAll(getBlockDataStorageModels());
    return models;
}
#method_after
public List<IStorageModel> getDataStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    models.addAll(getFileDataStorageModels());
    models.addAll(getBlockDataStorageModels());
    return models;
}
#end_block

#method_before
public static List<IStorageModel> getFileDataStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    NfsStorageModel nfsDataModel = new NfsStorageModel();
    models.add(nfsDataModel);
    PosixStorageModel posixDataModel = new PosixStorageModel();
    models.add(posixDataModel);
    GlusterStorageModel GlusterDataModel = new GlusterStorageModel();
    models.add(GlusterDataModel);
    LocalStorageModel localDataModel = new LocalStorageModel();
    models.add(localDataModel);
    addTypeToStorageModels(StorageDomainType.Data, models);
    return models;
}
#method_after
public List<IStorageModel> getFileDataStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    NfsStorageModel nfsDataModel = new NfsStorageModel();
    models.add(nfsDataModel);
    PosixStorageModel posixDataModel = new PosixStorageModel();
    models.add(posixDataModel);
    GlusterStorageModel GlusterDataModel = new GlusterStorageModel();
    models.add(GlusterDataModel);
    LocalStorageModel localDataModel = new LocalStorageModel();
    models.add(localDataModel);
    addTypeToStorageModels(StorageDomainType.Data, models);
    return models;
}
#end_block

#method_before
public static List<IStorageModel> getBlockDataStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    IscsiStorageModel iscsiDataModel = new IscsiStorageModel();
    iscsiDataModel.setIsGrouppedByTarget(true);
    models.add(iscsiDataModel);
    FcpStorageModel fcpDataModel = new FcpStorageModel();
    models.add(fcpDataModel);
    addTypeToStorageModels(StorageDomainType.Data, models);
    return models;
}
#method_after
public List<IStorageModel> getBlockDataStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    IscsiStorageModel iscsiDataModel = new IscsiStorageModel();
    iscsiDataModel.setIsGrouppedByTarget(true);
    models.add(iscsiDataModel);
    FcpStorageModel fcpDataModel = new FcpStorageModel();
    models.add(fcpDataModel);
    addTypeToStorageModels(StorageDomainType.Data, models);
    return models;
}
#end_block

#method_before
public static List<IStorageModel> getImportBlockDataStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    ImportIscsiStorageModel iscsiDataModel = new ImportIscsiStorageModel();
    models.add(iscsiDataModel);
    ImportFcpStorageModel fcpDataModel = new ImportFcpStorageModel();
    models.add(fcpDataModel);
    addTypeToStorageModels(StorageDomainType.Data, models);
    return models;
}
#method_after
public List<IStorageModel> getImportBlockDataStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    ImportIscsiStorageModel iscsiDataModel = new ImportIscsiStorageModel();
    models.add(iscsiDataModel);
    ImportFcpStorageModel fcpDataModel = new ImportFcpStorageModel();
    models.add(fcpDataModel);
    addTypeToStorageModels(StorageDomainType.Data, models);
    return models;
}
#end_block

#method_before
public static List<IStorageModel> getIsoStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    NfsStorageModel nfsIsoModel = new NfsStorageModel();
    models.add(nfsIsoModel);
    PosixStorageModel posixIsoModel = new PosixStorageModel();
    models.add(posixIsoModel);
    LocalStorageModel localIsoModel = new LocalStorageModel();
    models.add(localIsoModel);
    addTypeToStorageModels(StorageDomainType.ISO, models);
    return models;
}
#method_after
public List<IStorageModel> getIsoStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    NfsStorageModel nfsIsoModel = new NfsStorageModel();
    models.add(nfsIsoModel);
    PosixStorageModel posixIsoModel = new PosixStorageModel();
    models.add(posixIsoModel);
    LocalStorageModel localIsoModel = new LocalStorageModel();
    models.add(localIsoModel);
    addTypeToStorageModels(StorageDomainType.ISO, models);
    return models;
}
#end_block

#method_before
private static void addTypeToStorageModels(StorageDomainType storageDomainType, List<IStorageModel> models) {
    for (IStorageModel model : models) {
        model.setRole(storageDomainType);
    }
}
#method_after
private void addTypeToStorageModels(StorageDomainType storageDomainType, List<IStorageModel> models) {
    for (IStorageModel model : models) {
        model.setRole(storageDomainType);
    }
}
#end_block

#method_before
@Override
public void makeSortable() {
    makeSortable(new Comparator<T>() {

        private LexoNumericComparator lexoNumeric = new LexoNumericComparator();

        @Override
        public int compare(T o1, T o2) {
            String text1 = getValue(o1);
            String text2 = getValue(o2);
            if (text1.equals(text2)) {
                return 0;
            } else if (RxTxRateRenderer.NO_VALUE.equals(text1) || RxTxRateRenderer.NO_VALUE.equals(text2)) {
                return RxTxRateRenderer.NO_VALUE.equals(text1) ? -1 : 1;
            } else if (RxTxRateRenderer.ZERO_VALUE.equals(text1) || RxTxRateRenderer.ZERO_VALUE.equals(text2)) {
                return RxTxRateRenderer.ZERO_VALUE.equals(text1) ? -1 : 1;
            } else if (RxTxRateRenderer.SMALL_VALUE.equals(text1) || RxTxRateRenderer.SMALL_VALUE.equals(text2)) {
                return RxTxRateRenderer.SMALL_VALUE.equals(text1) ? -1 : 1;
            } else {
                return lexoNumeric.compare(text1, text2);
            }
        }
    });
}
#method_after
@Override
public void makeSortable() {
    makeSortable(new Comparator<T>() {

        private LexoNumericComparator lexoNumeric = new LexoNumericComparator();

        @Override
        public int compare(T o1, T o2) {
            String text1 = getValue(o1);
            String text2 = getValue(o2);
            if (text1.equals(text2)) {
                return 0;
            } else if (RxTxRateRenderer.isEmpty(text1) || RxTxRateRenderer.isEmpty(text2)) {
                return RxTxRateRenderer.isEmpty(text1) ? -1 : 1;
            } else if (RxTxRateRenderer.isZero(text1) || RxTxRateRenderer.isZero(text2)) {
                return RxTxRateRenderer.isZero(text1) ? -1 : 1;
            } else if (RxTxRateRenderer.isSmall(text1) || RxTxRateRenderer.isSmall(text2)) {
                return RxTxRateRenderer.isSmall(text1) ? -1 : 1;
            } else {
                return lexoNumeric.compare(text1, text2);
            }
        }
    });
}
#end_block

#method_before
@Test
public void testAuditLogTypeValueUniqueness() {
    BitSet bitset = new BitSet(bitsetSize);
    Set<Integer> nonUniqueValues = new TreeSet<Integer>();
    for (AuditLogType alt : AuditLogType.values()) {
        if (bitset.get(alt.getValue())) {
            nonUniqueValues.add(alt.getValue());
            nonUniqueValues.add(alt.getValue());
            nonUniqueValues.add(alt.getValue());
            nonUniqueValues.add(alt.getValue());
            nonUniqueValues.add(alt.getValue());
        } else {
            bitset.set(alt.getValue());
        }
    }
    assertTrue("AuditLogType contains the following non unique values: " + nonUniqueValues, nonUniqueValues.isEmpty());
}
#method_after
@Test
public void testAuditLogTypeValueUniqueness() {
    BitSet bitset = new BitSet(bitsetSize);
    Set<Integer> nonUniqueValues = new TreeSet<Integer>();
    for (AuditLogType alt : AuditLogType.values()) {
        if (bitset.get(alt.getValue())) {
            nonUniqueValues.add(alt.getValue());
        } else {
            bitset.set(alt.getValue());
        }
    }
    assertTrue("AuditLogType contains the following non unique values: " + nonUniqueValues, nonUniqueValues.isEmpty());
}
#end_block

#method_before
@Test
public void testRunPublicQuery_GetConfigurationValue() {
    // $NON-NLS-1$
    String sessionId = "sessionId";
    VdcQueryType queryType = VdcQueryType.GetConfigurationValue;
    VdcQueryReturnValue returnIntValue = new VdcQueryReturnValue();
    returnIntValue.setSucceeded(true);
    returnIntValue.setReturnValue(Integer.valueOf(255));
    when(mockBackend.runPublicQuery(eq(VdcQueryType.GetConfigurationValue), eq(mockConfigQueryParams))).thenReturn(returnIntValue);
    Object result = testServlet.runPublicQuery(queryType, mockConfigQueryParams, sessionId);
    assertThat(result, is(Integer.class));
    verify(mockConfigQueryParams).setSessionId(sessionId);
    verify(mockConfigQueryParams).setHttpSessionId(sessionId);
    verify(mockConfigQueryParams).setFiltered(testServlet.filterQueries());
    verify(mockBackend).runPublicQuery(queryType, mockConfigQueryParams);
}
#method_after
@Test
public void testRunPublicQuery_GetConfigurationValue() {
    // $NON-NLS-1$
    String sessionId = "sessionId";
    VdcQueryType queryType = VdcQueryType.GetConfigurationValue;
    VdcQueryReturnValue returnIntValue = new VdcQueryReturnValue();
    returnIntValue.setSucceeded(true);
    returnIntValue.setReturnValue(Integer.valueOf(255));
    when(mockBackend.runPublicQuery(eq(VdcQueryType.GetConfigurationValue), eq(mockConfigQueryParams))).thenReturn(returnIntValue);
    Object result = testServlet.runPublicQuery(queryType, mockConfigQueryParams, sessionId);
    assertThat(result, is(instanceOf(Integer.class)));
    verify(mockConfigQueryParams).setSessionId(sessionId);
    verify(mockConfigQueryParams).setHttpSessionId(sessionId);
    verify(mockConfigQueryParams).setFiltered(testServlet.filterQueries());
    verify(mockBackend).runPublicQuery(queryType, mockConfigQueryParams);
}
#end_block

#method_before
void stubGetConfigurationValuePublicQuery() {
    VdcQueryReturnValue returnIntValue = new VdcQueryReturnValue();
    returnIntValue.setSucceeded(true);
    returnIntValue.setReturnValue(Integer.valueOf(255));
    when(mockBackend.runPublicQuery(eq(VdcQueryType.GetConfigurationValue), eq(new GetConfigurationValueParameters(ConfigurationValues.ApplicationMode, ConfigCommon.defaultConfigurationVersion)))).thenReturn(returnIntValue);
    when(mockBackend.runPublicQuery(eq(VdcQueryType.GetConfigurationValue), eq(new GetConfigurationValueParameters(ConfigurationValues.UserSessionTimeOutInterval, ConfigCommon.defaultConfigurationVersion)))).thenReturn(returnIntValue);
    VdcQueryReturnValue returnStringValue = new VdcQueryReturnValue();
    returnStringValue.setSucceeded(true);
    returnStringValue.setReturnValue("");
    when(mockBackend.runPublicQuery(eq(VdcQueryType.GetConfigurationValue), eq(new GetConfigurationValueParameters(ConfigurationValues.UnsupportedDisplayedLocales, ConfigCommon.defaultConfigurationVersion)))).thenReturn(returnStringValue);
    when(mockBackend.runPublicQuery(eq(VdcQueryType.GetConfigurationValue), eq(new GetConfigurationValueParameters(ConfigurationValues.UnsupportedLocalesFilter, ConfigCommon.defaultConfigurationVersion)))).thenReturn(returnStringValue);
}
#method_after
void stubGetConfigurationValuePublicQuery() {
    VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
    returnValue.setSucceeded(true);
    returnValue.setReturnValue(Integer.valueOf(255));
    when(mockBackend.runPublicQuery(eq(VdcQueryType.GetConfigurationValue), isA(GetConfigurationValueParameters.class))).thenReturn(returnValue);
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    request.setAttribute(LOCALE_KEYS, UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys(), UnsupportedLocaleHelper.getLocalesKeys(backend, ConfigurationValues.UnsupportedDisplayedLocales), UnsupportedLocaleHelper.getLocalesKeys(backend, ConfigurationValues.UnsupportedLocalesFilter)));
    String oVirtVersion = backend.runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.ProductRPMVersion, ConfigCommon.defaultConfigurationVersion)).getReturnValue();
    request.setAttribute(VERSION, oVirtVersion != null ? oVirtVersion : "myVersion");
    request.setAttribute(SECTIONS, brandingManager.getWelcomeSections((Locale) request.getAttribute(LocaleFilter.LOCALE)));
    RequestDispatcher dispatcher = request.getRequestDispatcher("/WEB-INF/ovirt-engine.jsp");
    response.setContentType("text/html;charset=UTF-8");
    if (dispatcher != null) {
        dispatcher.include(request, response);
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    request.setAttribute(LOCALE_KEYS, UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys(), UnsupportedLocaleHelper.getLocalesKeys(ConfigValues.UnsupportedLocalesFilterOverrides), UnsupportedLocaleHelper.getLocalesKeys(ConfigValues.UnsupportedLocalesFilter)));
    String oVirtVersion = backend.runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.ProductRPMVersion, ConfigCommon.defaultConfigurationVersion)).getReturnValue();
    request.setAttribute(VERSION, oVirtVersion != null ? oVirtVersion : "myVersion");
    request.setAttribute(SECTIONS, brandingManager.getWelcomeSections((Locale) request.getAttribute(LocaleFilter.LOCALE)));
    RequestDispatcher dispatcher = request.getRequestDispatcher("/WEB-INF/ovirt-engine.jsp");
    response.setContentType("text/html;charset=UTF-8");
    if (dispatcher != null) {
        dispatcher.include(request, response);
    }
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for selector script
    request.setAttribute(MD5Attributes.ATTR_SELECTOR_SCRIPT.getKey(), getSelectorScriptName());
    // Set the messages that need to be replaced.
    request.setAttribute(MD5Attributes.ATTR_MESSAGES.getKey(), getBrandingMessages(getApplicationTypeFromRequest(request), getLocaleFromRequest(request)));
    request.setAttribute(MD5Attributes.ATTR_DISPLAY_LOCALES.getKey(), getLocaleInformation());
    request.setAttribute(MD5Attributes.ATTR_BASE_CONTEXT_PATH.getKey(), getConfiguration(request));
    // Set attribute for userInfo object
    DbUser loggedInUser = getLoggedInUser(request.getSession().getId());
    if (loggedInUser != null) {
        request.setAttribute(MD5Attributes.ATTR_USER_INFO.getKey(), getUserInfoObject(loggedInUser));
    }
    try {
        // Calculate MD5 for use with If-None-Match request header
        String md5sum = getMd5Sum(request);
        if (request.getHeader(IF_NONE_MATCH_HEADER) != null && request.getHeader(IF_NONE_MATCH_HEADER).equals(md5sum)) {
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        } else {
            RequestDispatcher dispatcher = request.getRequestDispatcher(HOST_JSP);
            response.setContentType(UTF_CONTENT_TYPE);
            response.addHeader(ETAG_HEADER, md5sum);
            if (dispatcher != null) {
                dispatcher.include(request, response);
            }
        }
    } catch (NoSuchAlgorithmException ex) {
        throw new ServletException(ex);
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for selector script
    request.setAttribute(MD5Attributes.ATTR_SELECTOR_SCRIPT.getKey(), getSelectorScriptName());
    // Set the messages that need to be replaced.
    request.setAttribute(MD5Attributes.ATTR_MESSAGES.getKey(), getBrandingMessages(getApplicationTypeFromRequest(request), getLocaleFromRequest(request)));
    request.setAttribute(MD5Attributes.ATTR_BASE_CONTEXT_PATH.getKey(), getValueObject(ServletUtils.getBaseContextPath(request)));
    request.setAttribute(MD5Attributes.ATTR_DISPLAY_LOCALES.getKey(), getValueObject(StringUtils.join(UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys(), UnsupportedLocaleHelper.getLocalesKeys(ConfigValues.UnsupportedLocalesFilterOverrides), UnsupportedLocaleHelper.getLocalesKeys(ConfigValues.UnsupportedLocalesFilter)), // $NON-NLS-1$
    ",")));
    // Set attribute for userInfo object
    DbUser loggedInUser = getLoggedInUser(getEngineSessionId(request));
    if (loggedInUser != null) {
        request.setAttribute(MD5Attributes.ATTR_USER_INFO.getKey(), getUserInfoObject(loggedInUser));
        request.setAttribute(MD5Attributes.ATTR_SSO_TOKEN.getKey(), getValueObject(request.getSession().getId()));
    }
    try {
        // Calculate MD5 for use with If-None-Match request header
        String md5sum = getMd5Sum(request);
        if (request.getHeader(IF_NONE_MATCH_HEADER) != null && request.getHeader(IF_NONE_MATCH_HEADER).equals(md5sum)) {
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        } else {
            RequestDispatcher dispatcher = request.getRequestDispatcher(HOST_JSP);
            response.setContentType(UTF_CONTENT_TYPE);
            response.addHeader(ETAG_HEADER, md5sum);
            if (dispatcher != null) {
                dispatcher.include(request, response);
            }
        }
    } catch (NoSuchAlgorithmException ex) {
        throw new ServletException(ex);
    }
}
#end_block

#method_before
private void initLocalizationEditor() {
    localeBox = new ListBox();
    // Add the option to change the locale
    String currentLocale = LocaleInfo.getCurrentLocale().getLocaleName();
    String[] localeNames = LocaleInfo.getAvailableLocaleNames();
    localeNames = LocaleInfoData.getFilteredLocaleNames(Arrays.asList(localeNames), LocaleInfoData.instance().getUnsupportedDisplayLocales(), LocaleInfoData.instance().getUnSupportedLocalesFilter());
    // Populate the locale list box with available locales
    boolean foundDefaultLocale = false;
    for (String localeName : localeNames) {
        if (!DEFAULT_LOCALE.equals(localeName)) {
            String nativeName = LocaleInfo.getLocaleNativeDisplayName(localeName);
            localeBox.addItem(nativeName, localeName);
            if (localeName.equals(currentLocale)) {
                setSelectedLocale(localeBox.getItemCount() - 1);
                foundDefaultLocale = true;
            }
        }
    }
    // When no available locale matches the current locale, select the first available locale
    if (!foundDefaultLocale && localeNames.length > 0) {
        setSelectedLocale(0);
    }
    localeBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            String localeQueryParam = LocaleInfo.getLocaleQueryParam();
            // $NON-NLS-1$ //$NON-NLS-2$
            String localeString = "?" + localeQueryParam + "=" + localeBox.getValue(localeBox.getSelectedIndex());
            // $NON-NLS-1$ //$NON-NLS-2$
            Window.open(FrontendUrlUtils.getCurrentPageURL() + localeString, "_self", "");
        }
    });
}
#method_after
private void initLocalizationEditor() {
    localeBox = new ListBox();
    // Add the option to change the locale
    String currentLocale = LocaleInfo.getCurrentLocale().getLocaleName();
    String[] localeNames = LocaleInfo.getAvailableLocaleNames();
    localeNames = VisibleLocalesInfoData.getFilteredLocaleNames(Arrays.asList(localeNames), VisibleLocalesInfoData.instance().getVisibleList());
    // Populate the locale list box with available locales
    boolean foundDefaultLocale = false;
    for (String localeName : localeNames) {
        if (!DEFAULT_LOCALE.equals(localeName)) {
            String nativeName = LocaleInfo.getLocaleNativeDisplayName(localeName);
            localeBox.addItem(nativeName, localeName);
            if (localeName.equals(currentLocale)) {
                setSelectedLocale(localeBox.getItemCount() - 1);
                foundDefaultLocale = true;
            }
        }
    }
    // When no available locale matches the current locale, select the first available locale
    if (!foundDefaultLocale && localeNames.length > 0) {
        setSelectedLocale(0);
    }
    localeBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            String localeQueryParam = LocaleInfo.getLocaleQueryParam();
            // $NON-NLS-1$ //$NON-NLS-2$
            String localeString = "?" + localeQueryParam + "=" + localeBox.getValue(localeBox.getSelectedIndex());
            // $NON-NLS-1$ //$NON-NLS-2$
            Window.open(FrontendUrlUtils.getCurrentPageURL() + localeString, "_self", "");
        }
    });
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    allLocales = getAllLocales();
    returnValue = new VdcQueryReturnValue();
    when(mockBackend.runPublicQuery(eq(VdcQueryType.GetConfigurationValue), any(GetConfigurationValueParameters.class))).thenReturn(returnValue);
}
#method_after
@Before
public void setUp() throws Exception {
    allLocales = getAllLocales();
    unvalidatedUnsupportedLocales.clear();
}
#end_block

#method_before
@Test
public void testGetDisplayLocales() {
    List<String> displayLocales = new ArrayList<String>();
    List<String> locales = UnsupportedLocaleHelper.getDisplayedLocales(allLocales, displayLocales, null);
    assertNotNull("Result should not be null", locales);
    assertEquals("There should be 8 locales", 8, locales.size());
}
#method_after
@Test
public void testGetDisplayLocales() {
    List<String> displayLocales = new ArrayList<String>();
    List<String> locales = UnsupportedLocaleHelper.getDisplayedLocales(allLocales, displayLocales, new ArrayList<String>());
    assertNotNull("Result should not be null", locales);
    assertEquals("There should be 8 locales", 8, locales.size());
}
#end_block

#method_before
@Test
public void testGetLocalesKeysUnSupported() {
    returnValue.setReturnValue("ko_KR");
    List<String> locales = UnsupportedLocaleHelper.getLocalesKeys(mockBackend, ConfigurationValues.UnsupportedLocalesFilter);
    assertNotNull("Result should not be null", locales);
    assertEquals("There should be 1 locales", 1, locales.size());
    assertEquals("Locale should be ko_KR", "ko_KR", locales.get(0));
}
#method_after
@Test
public void testGetLocalesKeysUnSupported() {
    unvalidatedUnsupportedLocales.add("ko_KR");
    List<String> locales = UnsupportedLocaleHelper.getLocalesKeys(ConfigValues.UnsupportedLocalesFilterOverrides);
    assertNotNull("Result should not be null", locales);
    assertEquals("There should be 1 locales", 1, locales.size());
    assertEquals("Locale should be ko_KR", "ko_KR", locales.get(0));
}
#end_block

#method_before
@Test
public void testGetLocalesKeysWithInvalid() {
    returnValue.setReturnValue("ko_KR, abcdds");
    List<String> locales = UnsupportedLocaleHelper.getLocalesKeys(mockBackend, ConfigurationValues.UnsupportedLocalesFilter);
    assertNotNull("Result should not be null", locales);
    assertEquals("There should be 1 locales", 1, locales.size());
    assertEquals("Locale should be ko_KR", "ko_KR", locales.get(0));
}
#method_after
@Test
public void testGetLocalesKeysWithInvalid() {
    unvalidatedUnsupportedLocales.add("ko_KR");
    unvalidatedUnsupportedLocales.add("abcdds");
    List<String> locales = UnsupportedLocaleHelper.getLocalesKeys(ConfigValues.UnsupportedLocalesFilterOverrides);
    assertNotNull("Result should not be null", locales);
    assertEquals("There should be 1 locales", 1, locales.size());
    assertEquals("Locale should be ko_KR", "ko_KR", locales.get(0));
}
#end_block

#method_before
@Test
public void testGetLocalesKeysDisplayLocalesEmpty() {
    List<String> locales = UnsupportedLocaleHelper.getLocalesKeys(mockBackend, ConfigurationValues.UnsupportedDisplayedLocales);
    assertNotNull("Result should not be null", locales);
    assertEquals("There should be 0 locales", 0, locales.size());
}
#method_after
@Test
public void testGetLocalesKeysDisplayLocalesEmpty() {
    List<String> locales = UnsupportedLocaleHelper.getLocalesKeys(ConfigValues.UnsupportedLocalesFilterOverrides);
    assertNotNull("Result should not be null", locales);
    assertEquals("There should be 0 locales", 0, locales.size());
}
#end_block

#method_before
public static List<String> getDisplayedLocales(List<String> allLocales, List<String> displayLocales, List<String> unsupportedLocales) {
    List<String> result = allLocales;
    if (displayLocales == null) {
        displayLocales = new ArrayList<String>();
    }
    if (unsupportedLocales != null && !unsupportedLocales.isEmpty()) {
        for (String unsupportedLocale : unsupportedLocales) {
            unsupportedLocale = unsupportedLocale.trim();
            if (!displayLocales.contains(unsupportedLocale)) {
                result.remove(unsupportedLocale);
            }
        }
    }
    Collections.sort(result);
    return result;
}
#method_after
public static List<String> getDisplayedLocales(List<String> allLocales, List<String> unsupportedLocalesFilterOverrides, List<String> unsupportedLocalesFilter) {
    List<String> result = new ArrayList<String>(allLocales);
    // Override unsupported locales that we do want to display.
    List<String> unsupportedLocalesTemp = new ArrayList<String>(unsupportedLocalesFilter);
    unsupportedLocalesTemp.removeAll(unsupportedLocalesFilterOverrides);
    // Remove remaining unsupported locales from the result.
    result.removeAll(unsupportedLocalesTemp);
    Collections.sort(result);
    return result;
}
#end_block

#method_before
public static List<String> getLocalesKeys(BackendLocal backend, ConfigurationValues configValues) {
    if (!configValues.equals(ConfigurationValues.UnsupportedLocalesFilter) && !configValues.equals(ConfigurationValues.UnsupportedDisplayedLocales)) {
        // $NON-NLS-1$
        throw new IllegalArgumentException("Passed in config value not related to locales");
    }
    List<String> result = new ArrayList<String>();
    String locales = backend.runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(configValues, ConfigCommon.defaultConfigurationVersion)).getReturnValue();
    if (locales != null && !locales.isEmpty()) {
        // $NON-NLS-1$
        String[] localeKeys = locales.split(",");
        for (String localeKey : localeKeys) {
            try {
                // Check for valid locale.
                org.apache.commons.lang.LocaleUtils.toLocale(localeKey.trim());
                result.add(localeKey.trim());
            } catch (IllegalArgumentException iae) {
            // The locale passed in is not valid, don't add it to the list.
            }
        }
    }
    return result;
}
#method_after
public static List<String> getLocalesKeys(ConfigValues configValues) {
    if (!configValues.equals(ConfigValues.UnsupportedLocalesFilter) && !configValues.equals(ConfigValues.UnsupportedLocalesFilterOverrides)) {
        // $NON-NLS-1$
        throw new IllegalArgumentException("Passed in config value not related to locales");
    }
    List<String> locales = Config.<List<String>>getValue(configValues);
    List<String> result = new ArrayList<String>();
    if (locales != null && !locales.isEmpty()) {
        for (String localeKey : locales) {
            try {
                // Check for valid locale.
                String underScoredLocaleKey = localeKey.replaceAll("-", "_");
                org.apache.commons.lang.LocaleUtils.toLocale(underScoredLocaleKey);
                result.add(underScoredLocaleKey);
            } catch (IllegalArgumentException iae) {
                // The locale passed in is not valid, don't add it to the list.
                // $NON-NLS-1$
                log.info("Invalid locale found in configuration: " + localeKey);
            }
        }
    }
    return result;
}
#end_block

#method_before
@UiHandler({ "basicViewButton", "advancedViewButton" })
void handleViewButtonClick(ClickEvent event) {
    boolean advancedViewEnabled = advancedViewButton.getValue();
    getTable().ensureColumnPresent(AdvancedViewColumns.logTypeColumn, constants.eventIdEvent(), advancedViewEnabled, // $NON-NLS-1$
    "80px");
    AdvancedViewColumns.userColumn.makeSortable(AuditLogConditionFieldAutoCompleter.USER_NAME);
    getTable().ensureColumnPresent(AdvancedViewColumns.userColumn, constants.userEvent(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    AdvancedViewColumns.hostColumn.makeSortable(AuditLogConditionFieldAutoCompleter.EVENT_HOST);
    getTable().ensureColumnPresent(AdvancedViewColumns.hostColumn, constants.hostEvent(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    AdvancedViewColumns.virtualMachineColumn.makeSortable(AuditLogConditionFieldAutoCompleter.EVENT_VM);
    getTable().ensureColumnPresent(AdvancedViewColumns.virtualMachineColumn, constants.vmEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    AdvancedViewColumns.templateColumn.makeSortable(AuditLogConditionFieldAutoCompleter.EVENT_TEMPLATE);
    getTable().ensureColumnPresent(AdvancedViewColumns.templateColumn, constants.templateEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    AdvancedViewColumns.dataCenterColumn.makeSortable(AuditLogConditionFieldAutoCompleter.EVENT_DATACENTER);
    getTable().ensureColumnPresent(AdvancedViewColumns.dataCenterColumn, constants.dcEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    AdvancedViewColumns.storageColumn.makeSortable(AuditLogConditionFieldAutoCompleter.EVENT_STORAGE);
    getTable().ensureColumnPresent(AdvancedViewColumns.storageColumn, constants.storageEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.clusterColumn, constants.clusterEvent(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    AdvancedViewColumns.volumeColumn.makeSortable(AuditLogConditionFieldAutoCompleter.EVENT_VOLUME);
    getTable().ensureColumnPresent(AdvancedViewColumns.volumeColumn, constants.volumeEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly), // $NON-NLS-1$
    "120px");
    AdvancedViewColumns.corrIdColumn.makeSortable(AuditLogConditionFieldAutoCompleter.CORRELATION_ID);
    getTable().ensureColumnPresent(AdvancedViewColumns.corrIdColumn, constants.eventCorrelationId(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    AdvancedViewColumns.originColumn.makeSortable(AuditLogConditionFieldAutoCompleter.ORIGIN);
    getTable().ensureColumnPresent(AdvancedViewColumns.originColumn, constants.eventOrigin(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    AdvancedViewColumns.customEventIdColumn.makeSortable(AuditLogConditionFieldAutoCompleter.CUSTOM_EVENT_ID);
    getTable().ensureColumnPresent(AdvancedViewColumns.customEventIdColumn, constants.eventCustomEventId(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
}
#method_after
@UiHandler({ "basicViewButton", "advancedViewButton" })
void handleViewButtonClick(ClickEvent event) {
    boolean advancedViewEnabled = advancedViewButton.getValue();
    getTable().ensureColumnPresent(AdvancedViewColumns.logTypeColumn, constants.eventIdEvent(), advancedViewEnabled, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnPresent(AdvancedViewColumns.userColumn, constants.userEvent(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.hostColumn, constants.hostEvent(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.virtualMachineColumn, constants.vmEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.templateColumn, constants.templateEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.dataCenterColumn, constants.dcEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.storageColumn, constants.storageEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.clusterColumn, constants.clusterEvent(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.volumeColumn, constants.volumeEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly), // $NON-NLS-1$
    "120px");
    getTable().ensureColumnPresent(AdvancedViewColumns.corrIdColumn, constants.eventCorrelationId(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.originColumn, constants.eventOrigin(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.customEventIdColumn, constants.eventCustomEventId(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
}
#end_block

#method_before
@Override
public int compare(Map<String, String> map1, Map<String, String> map2) {
    return new LexoNumericComparator().compare(map1.get(key), map2.get(key));
}
#method_after
@Override
public int compare(Map<String, String> map1, Map<String, String> map2) {
    return lexoNumericComparator.compare(map1.get(key), map2.get(key));
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    TextColumnWithTooltip<event_subscriber> eventNameColumn = new EnumColumn<event_subscriber, AuditLogType>() {

        @Override
        protected AuditLogType getRawValue(event_subscriber object) {
            return Enum.valueOf(AuditLogType.class, object.getevent_up_name());
        }
    };
    eventNameColumn.makeSortable(new Comparator<event_subscriber>() {

        @Override
        public int compare(event_subscriber o1, event_subscriber o2) {
            return new LexoNumericComparator().compare(o1.getevent_up_name(), o2.getevent_up_name());
        }
    });
    getTable().addColumn(eventNameColumn, constants.eventNameEventNotifier());
    getTable().addActionButton(new WebAdminButtonDefinition<event_subscriber>(constants.manageEventsEventNotifier()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getManageEventsCommand();
        }
    });
}
#method_after
void initTable(ApplicationConstants constants) {
    TextColumnWithTooltip<event_subscriber> eventNameColumn = new EnumColumn<event_subscriber, AuditLogType>() {

        @Override
        protected AuditLogType getRawValue(event_subscriber object) {
            return Enum.valueOf(AuditLogType.class, object.getevent_up_name());
        }
    };
    eventNameColumn.makeSortable(new Comparator<event_subscriber>() {

        private final LexoNumericComparator lexoNumericComparator = new LexoNumericComparator();

        @Override
        public int compare(event_subscriber o1, event_subscriber o2) {
            return lexoNumericComparator.compare(o1.getevent_up_name(), o2.getevent_up_name());
        }
    });
    getTable().addColumn(eventNameColumn, constants.eventNameEventNotifier());
    getTable().addActionButton(new WebAdminButtonDefinition<event_subscriber>(constants.manageEventsEventNotifier()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getManageEventsCommand();
        }
    });
}
#end_block

#method_before
private void initAnchor(String url) {
    // $NON-NLS-1$
    boolean isBrickTabSelected = !(url.contains(";nfsStatistics=true"));
    // $NON-NLS-1$//$NON-NLS-2$
    Anchor profileExport = new Anchor(constants.exportToPdf(), false, url, "_blank");
    if (isBrickTabSelected) {
        brickProfileAnchorContainer.add(profileExport);
    } else {
        nfsProfileAnchorContainer.add(profileExport);
    }
}
#method_after
private void initAnchor(String url, Anchor anchor) {
    anchor.setHref(url);
    anchor.setText(constants.exportToPdf());
    // $NON-NLS-1$
    anchor.setTarget("_blank");
}
#end_block

#method_before
@Override
public void edit(final VolumeProfileStatisticsModel object) {
    driver.edit(object);
    volumeProfileStats.asEditor().edit(object.getCumulativeStatistics());
    nfsServerProfileStats.asEditor().edit(object.getNfsServerProfileStats());
    profileRunTime.setText(object.getProfileRunTime());
    nfsProfileRunTime.setText(object.getNfsProfileRunTime());
    bytesRead.setText(object.getBytesRead());
    nfsBytesRead.setText(object.getNfsBytesRead());
    bytesWritten.setText(object.getBytesWritten());
    nfsBytesWritten.setText(object.getNfsBytesWritten());
    ClickHandler brickTabClickHandler = new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.queryBackend(true);
        }
    };
    brickRefreshIcon.setRefreshIconClickListener(brickTabClickHandler);
    ClickHandler nfsTabClickHandler = new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.queryBackend(false);
        }
    };
    nfsRefreshIcon.setRefreshIconClickListener(nfsTabClickHandler);
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName.equals("brickProfileRunTimeChanged")) {
                // $NON-NLS-1$
                profileRunTime.setText(object.getProfileRunTime());
            }
            if (e.propertyName.equals("brickProfileDataRead")) {
                // $NON-NLS-1$
                bytesRead.setText(object.getBytesRead());
            }
            if (e.propertyName.equals("brickProfileDataWritten")) {
                // $NON-NLS-1$
                bytesWritten.setText(object.getBytesWritten());
            }
            if (e.propertyName.equals("nfsProfileRunTimeChanged")) {
                // $NON-NLS-1$
                nfsProfileRunTime.setText(object.getNfsProfileRunTime());
            }
            if (e.propertyName.equals("nfsProfileDataRead")) {
                // $NON-NLS-1$
                nfsBytesRead.setText(object.getNfsBytesRead());
            }
            if (e.propertyName.equals("nfsProfileDataWritten")) {
                // $NON-NLS-1$
                nfsBytesWritten.setText(object.getNfsBytesWritten());
            }
            if (e.propertyName.equals("statusOfFetchingProfileStats")) {
                // $NON-NLS-1$
                boolean disableErrorLabels = !(object.isSuccessfulProfileStatsFetch());
                if (!disableErrorLabels) {
                    initAnchor(object.getProfileExportUrl());
                }
                bricksErrorLabel.setVisible(disableErrorLabels);
                nfsErrorLabel.setVisible(disableErrorLabels);
            }
        }
    });
}
#method_after
@Override
public void edit(final VolumeProfileStatisticsModel object) {
    driver.edit(object);
    volumeProfileStats.asEditor().edit(object.getCumulativeStatistics());
    nfsServerProfileStats.asEditor().edit(object.getNfsServerProfileStats());
    profileRunTime.setText(object.getProfileRunTime());
    nfsProfileRunTime.setText(object.getNfsProfileRunTime());
    bytesRead.setText(object.getBytesRead());
    nfsBytesRead.setText(object.getNfsBytesRead());
    bytesWritten.setText(object.getBytesWritten());
    nfsBytesWritten.setText(object.getNfsBytesWritten());
    ClickHandler brickTabClickHandler = new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.queryBackend(true);
        }
    };
    brickRefreshIcon.setRefreshIconClickListener(brickTabClickHandler);
    ClickHandler nfsTabClickHandler = new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.queryBackend(false);
        }
    };
    nfsRefreshIcon.setRefreshIconClickListener(nfsTabClickHandler);
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName.equals("brickProfileRunTimeChanged")) {
                // $NON-NLS-1$
                profileRunTime.setText(object.getProfileRunTime());
            }
            if (e.propertyName.equals("brickProfileDataRead")) {
                // $NON-NLS-1$
                bytesRead.setText(object.getBytesRead());
            }
            if (e.propertyName.equals("brickProfileDataWritten")) {
                // $NON-NLS-1$
                bytesWritten.setText(object.getBytesWritten());
            }
            if (e.propertyName.equals("nfsProfileRunTimeChanged")) {
                // $NON-NLS-1$
                nfsProfileRunTime.setText(object.getNfsProfileRunTime());
            }
            if (e.propertyName.equals("nfsProfileDataRead")) {
                // $NON-NLS-1$
                nfsBytesRead.setText(object.getNfsBytesRead());
            }
            if (e.propertyName.equals("nfsProfileDataWritten")) {
                // $NON-NLS-1$
                nfsBytesWritten.setText(object.getNfsBytesWritten());
            }
            if (e.propertyName.equals("statusOfFetchingProfileStats")) {
                // $NON-NLS-1$
                boolean disableErrorLabels = !(object.isSuccessfulProfileStatsFetch());
                if (!disableErrorLabels) {
                    String url = object.getProfileExportUrl();
                    // $NON-NLS-1$
                    boolean isBrickTabSelected = !(url.contains(";nfsStatistics=true"));
                    initAnchor(url, (isBrickTabSelected) ? brickProfileAnchor : nfsProfileAnchor);
                }
                bricksErrorLabel.setVisible(disableErrorLabels);
                nfsErrorLabel.setVisible(disableErrorLabels);
            }
        }
    });
}
#end_block

#method_before
private String formProfileUrl(String clusterId, String volumeId, boolean isBrickProfileSelected) {
    // $NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$
    String url = "/ovirt-engine/api/clusters/" + clusterId + "/glustervolumes/" + volumeId + "/profilestatistics";
    if (!isBrickProfileSelected) {
        // $NON-NLS-1$
        url += ";nfsStatistics=true";
    }
    // $NON-NLS-1$
    return url + ".pdf";
}
#method_after
private String formProfileUrl(String clusterId, String volumeId, boolean isBrickProfileSelected) {
    // $NON-NLS-1$//$NON-NLS-2$
    String apiMatrixParam = ((!isBrickProfileSelected) ? ";nfsStatistics=true" : "");
    // $NON-NLS-1$
    return StringFormat.format("/ovirt-engine/api/clusters/%s/glustervolumes/%s/profilestatistics%s?accept=application/pdf", clusterId, volumeId, apiMatrixParam);
}
#end_block

#method_before
public ValidationResult networkNotUsedByRunningVms() {
    List<VM> runningVms = new ArrayList<>();
    List<VmNetworkInterface> vnics = getDbFacade().getVmNetworkInterfaceDao().getAllForNetwork(network.getId());
    Map<Guid, List<VmNetworkInterface>> vnicsByVmId = Entities.vmInterfacesByVmId(vnics);
    for (VM vm : getVms()) {
        if (vm.isRunningOrPaused()) {
            for (VmNetworkInterface nic : vnicsByVmId.get(vm.getId())) {
                if (VnicNetworkCanBeUpdatedPredicate.getInstance().eval(nic)) {
                    runningVms.add(vm);
                    break;
                }
            }
        }
    }
    return networkNotUsed(runningVms, VdcBllMessages.VAR__ENTITIES__VMS);
}
#method_after
public ValidationResult networkNotUsedByRunningVms() {
    List<VM> runningVms = new ArrayList<>();
    List<VmNetworkInterface> vnics = getDbFacade().getVmNetworkInterfaceDao().getAllForNetwork(network.getId());
    Map<Guid, List<VmNetworkInterface>> vnicsByVmId = Entities.vmInterfacesByVmId(vnics);
    for (VM vm : getVms()) {
        if (vm.isRunningOrPaused()) {
            for (VmNetworkInterface nic : vnicsByVmId.get(vm.getId())) {
                if (VmNetworkCanBeUpdatedPredicate.getInstance().eval(nic)) {
                    runningVms.add(vm);
                    break;
                }
            }
        }
    }
    return networkNotUsed(runningVms, VdcBllMessages.VAR__ENTITIES__VMS);
}
#end_block

#method_before
public List<String> findActiveVmsUsingNetworks(Guid vdsId, List<String> networks) {
    if (networks.isEmpty()) {
        return Collections.emptyList();
    }
    List<VM> runningVms = getVmDAO().getAllRunningForVds(vdsId);
    List<String> vmNames = new ArrayList<String>();
    for (VM vm : runningVms) {
        List<VmNetworkInterface> vmInterfaces = getVmNetworkInterfaceDao().getAllForVm(vm.getId());
        for (VmNetworkInterface vmNic : vmInterfaces) {
            if (VnicNetworkCanBeUpdatedPredicate.getInstance().eval(vmNic) && vmNic.getNetworkName() != null && networks.contains(vmNic.getNetworkName())) {
                vmNames.add(vm.getName());
                break;
            }
        }
    }
    return vmNames;
}
#method_after
public List<String> findActiveVmsUsingNetworks(Guid vdsId, List<String> networks) {
    if (networks.isEmpty()) {
        return Collections.emptyList();
    }
    List<VM> runningVms = getVmDAO().getAllRunningForVds(vdsId);
    List<String> vmNames = new ArrayList<String>();
    for (VM vm : runningVms) {
        List<VmNetworkInterface> vmInterfaces = getVmNetworkInterfaceDao().getAllForVm(vm.getId());
        for (VmNetworkInterface vmNic : vmInterfaces) {
            if (VmNetworkCanBeUpdatedPredicate.getInstance().eval(vmNic) && vmNic.getNetworkName() != null && networks.contains(vmNic.getNetworkName())) {
                vmNames.add(vm.getName());
                break;
            }
        }
    }
    return vmNames;
}
#end_block

#method_before
private void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<AffinityGroup> nameColumn = new TextColumnWithTooltip<AffinityGroup>() {

        @Override
        public String getValue(AffinityGroup object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(AffinityGroupComparator.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameAffinityGroup(), "150px");
    TextColumnWithTooltip<AffinityGroup> descColumn = new TextColumnWithTooltip<AffinityGroup>() {

        @Override
        public String getValue(AffinityGroup object) {
            return object.getDescription();
        }
    };
    descColumn.makeSortable(AffinityGroupComparator.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descColumn, constants.descriptionAffinityGroup(), "150px");
    BooleanColumn<AffinityGroup> polarityColumn = new BooleanColumn<AffinityGroup>(constants.positiveAffinity(), constants.negativeAffinity()) {

        @Override
        protected Boolean getRawValue(AffinityGroup object) {
            return object.isPositive();
        }
    };
    polarityColumn.makeSortable(AffinityGroupComparator.POLARITY);
    // $NON-NLS-1$
    getTable().addColumn(polarityColumn, constants.polarityAffinityGroup(), "100px");
    BooleanColumn<AffinityGroup> enforceColumn = new BooleanColumn<AffinityGroup>(constants.hardEnforcingAffinity(), constants.softEnforcingAffinity()) {

        @Override
        protected Boolean getRawValue(AffinityGroup object) {
            return object.isEnforcing();
        }
    };
    enforceColumn.makeSortable(AffinityGroupComparator.ENFORCING);
    // $NON-NLS-1$
    getTable().addColumn(enforceColumn, constants.enforceAffinityGroup(), "100px");
    getTable().addColumn(new TextColumnWithTooltip<AffinityGroup>() {

        @Override
        public String getValue(AffinityGroup object) {
            // $NON-NLS-1$
            String join = join(getEntityNames(object), ", ");
            if (join.isEmpty()) {
                return constants.noMembersAffinityGroup();
            }
            return join;
        }
    }, constants.membersAffinityGroup(), // $NON-NLS-1$
    "500px");
    getTable().addActionButton(new WebAdminButtonDefinition<AffinityGroup>(constants.newAffinityGroupLabel()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<AffinityGroup>(constants.editAffinityGroupLabel()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<AffinityGroup>(constants.removeAffinityGroupLabel()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
}
#method_after
private void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<AffinityGroup> nameColumn = new TextColumnWithTooltip<AffinityGroup>() {

        @Override
        public String getValue(AffinityGroup object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameAffinityGroup(), "150px");
    TextColumnWithTooltip<AffinityGroup> descColumn = new TextColumnWithTooltip<AffinityGroup>() {

        @Override
        public String getValue(AffinityGroup object) {
            return object.getDescription();
        }
    };
    descColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(descColumn, constants.descriptionAffinityGroup(), "150px");
    BooleanColumn<AffinityGroup> polarityColumn = new BooleanColumn<AffinityGroup>(constants.positiveAffinity(), constants.negativeAffinity()) {

        @Override
        protected Boolean getRawValue(AffinityGroup object) {
            return object.isPositive();
        }
    };
    polarityColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(polarityColumn, constants.polarityAffinityGroup(), "100px");
    BooleanColumn<AffinityGroup> enforceColumn = new BooleanColumn<AffinityGroup>(constants.hardEnforcingAffinity(), constants.softEnforcingAffinity()) {

        @Override
        protected Boolean getRawValue(AffinityGroup object) {
            return object.isEnforcing();
        }
    };
    enforceColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(enforceColumn, constants.enforceAffinityGroup(), "100px");
    TextColumnWithTooltip<AffinityGroup> membersColumn = new TextColumnWithTooltip<AffinityGroup>() {

        @Override
        public String getValue(AffinityGroup object) {
            // $NON-NLS-1$
            String join = join(getEntityNames(object), ", ");
            if (join.isEmpty()) {
                return constants.noMembersAffinityGroup();
            }
            return join;
        }
    };
    membersColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(membersColumn, constants.membersAffinityGroup(), "500px");
    getTable().addActionButton(new WebAdminButtonDefinition<AffinityGroup>(constants.newAffinityGroupLabel()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<AffinityGroup>(constants.editAffinityGroupLabel()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<AffinityGroup>(constants.removeAffinityGroupLabel()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
}
#end_block

#method_before
void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new HostStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VDS> nameColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(VDSComparator.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameClusterHost(), "220px");
    TextColumnWithTooltip<VDS> hostColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getHostName();
        }
    };
    hostColumn.makeSortable(VDSComparator.HOST);
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.hostIpClusterHost(), "220px");
    TextColumnWithTooltip<VDS> statusColumn = new EnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getStatus();
        }
    };
    statusColumn.makeSortable(VDSComparator.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusClusterHost(), "120px");
    if (ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly)) {
        TextColumnWithTooltip<VDS> loadColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                int numOfActiveVMs = object.getVmActive() != null ? object.getVmActive() : 0;
                return ConstantsManager.getInstance().getMessages().numberOfVmsForHostsLoad(numOfActiveVMs);
            }
        };
        loadColumn.makeSortable(VDSComparator.LOAD);
        // $NON-NLS-1$
        getTable().addColumn(loadColumn, constants.loadClusterHost(), "120px");
    }
    if (ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly)) {
        TextColumnWithTooltip<VDS> consoleColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS host) {
                return host.getConsoleAddress() != null ? constants.yes() : constants.no();
            }
        };
        consoleColumn.makeSortable(VDSComparator.CONSOLE_OVERRIDE);
        // $NON-NLS-1$
        getTable().addColumn(consoleColumn, constants.overriddenConsoleAddress(), "220px");
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.updateMomPolicyClusterHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getUpdateMomPolicyCommand();
        }
    });
}
#method_after
void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new HostStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VDS> nameColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameClusterHost(), "220px");
    TextColumnWithTooltip<VDS> hostColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getHostName();
        }
    };
    hostColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.hostIpClusterHost(), "220px");
    TextColumnWithTooltip<VDS> statusColumn = new EnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getStatus();
        }
    };
    statusColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusClusterHost(), "120px");
    if (ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly)) {
        TextColumnWithTooltip<VDS> loadColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                int numOfActiveVMs = object.getVmActive() != null ? object.getVmActive() : 0;
                return ConstantsManager.getInstance().getMessages().numberOfVmsForHostsLoad(numOfActiveVMs);
            }
        };
        loadColumn.makeSortable();
        // $NON-NLS-1$
        getTable().addColumn(loadColumn, constants.loadClusterHost(), "120px");
    }
    if (ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly)) {
        TextColumnWithTooltip<VDS> consoleColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS host) {
                return host.getConsoleAddress() != null ? constants.yes() : constants.no();
            }
        };
        consoleColumn.makeSortable();
        // $NON-NLS-1$
        getTable().addColumn(consoleColumn, constants.overriddenConsoleAddress(), "220px");
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.updateMomPolicyClusterHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getUpdateMomPolicyCommand();
        }
    });
}
#end_block

#method_before
void initTable(final ApplicationConstants constants, final ApplicationTemplates templates) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$ //$NON-NLS-2$
    getTable().addColumn(new NetworkStatusColumn(), "", "20px");
    TextColumnWithTooltip<Network> nameColumn = new TextColumnWithTooltip<Network>() {

        @Override
        public String getValue(Network object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(NetworkComparator.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameNetwork(), "400px");
    TextColumnWithTooltip<Network> statusColumn = new EnumColumn<Network, NetworkStatus>() {

        @Override
        public NetworkStatus getRawValue(Network object) {
            return object.getCluster().getStatus();
        }
    };
    statusColumn.makeSortable(NetworkComparator.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusNetwork(), "100px");
    SafeHtmlWithSafeHtmlTooltipColumn<Network> roleColumn = new SafeHtmlWithSafeHtmlTooltipColumn<Network>() {

        @Override
        public SafeHtml getValue(Network network) {
            List<SafeHtml> images = new LinkedList<SafeHtml>();
            if (network.getCluster() != null) {
                if (network.getCluster().isDisplay()) {
                    images.add(displayImage);
                } else {
                    images.add(emptyImage);
                }
                if (network.getCluster().isMigration()) {
                    images.add(migrationImage);
                } else {
                    images.add(emptyImage);
                }
            }
            return NetworkRoleColumnHelper.getValue(images);
        }

        @Override
        public SafeHtml getTooltip(Network network) {
            Map<SafeHtml, String> imagesToText = new LinkedHashMap<SafeHtml, String>();
            if (network.getCluster() != null) {
                if (network.getCluster().isDisplay()) {
                    imagesToText.put(displayImage, constants.displayItemInfo());
                }
                if (network.getCluster().isMigration()) {
                    imagesToText.put(migrationImage, constants.migrationItemInfo());
                }
            }
            return NetworkRoleColumnHelper.getTooltip(imagesToText);
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(roleColumn, constants.roleNetwork(), "60px");
    TextColumnWithTooltip<Network> descColumn = new TextColumnWithTooltip<Network>() {

        @Override
        public String getValue(Network object) {
            return object.getDescription();
        }
    };
    descColumn.makeSortable(NetworkComparator.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descColumn, constants.descriptionNetwork(), "400px");
    if (ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly)) {
        getTable().addActionButton(new WebAdminButtonDefinition<Network>(constants.addNetworkNetwork()) {

            @Override
            protected UICommand resolveCommand() {
                return getDetailModel().getNewNetworkCommand();
            }
        });
        getTable().addActionButton(new WebAdminButtonDefinition<Network>(constants.assignDetatchNetworksNework()) {

            @Override
            protected UICommand resolveCommand() {
                return getDetailModel().getManageCommand();
            }
        });
        getTable().addActionButton(new WebAdminButtonDefinition<Network>(constants.setAsDisplayNetwork()) {

            @Override
            protected UICommand resolveCommand() {
                return getDetailModel().getSetAsDisplayCommand();
            }
        });
    }
}
#method_after
void initTable(final ApplicationConstants constants, final ApplicationTemplates templates) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$ //$NON-NLS-2$
    getTable().addColumn(new NetworkStatusColumn(), "", "20px");
    TextColumnWithTooltip<Network> nameColumn = new TextColumnWithTooltip<Network>() {

        @Override
        public String getValue(Network object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameNetwork(), "400px");
    TextColumnWithTooltip<Network> statusColumn = new EnumColumn<Network, NetworkStatus>() {

        @Override
        public NetworkStatus getRawValue(Network object) {
            return object.getCluster().getStatus();
        }
    };
    statusColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusNetwork(), "100px");
    SafeHtmlWithSafeHtmlTooltipColumn<Network> roleColumn = new SafeHtmlWithSafeHtmlTooltipColumn<Network>() {

        @Override
        public SafeHtml getValue(Network network) {
            List<SafeHtml> images = new LinkedList<SafeHtml>();
            if (network.getCluster() != null) {
                if (network.getCluster().isDisplay()) {
                    images.add(displayImage);
                } else {
                    images.add(emptyImage);
                }
                if (network.getCluster().isMigration()) {
                    images.add(migrationImage);
                } else {
                    images.add(emptyImage);
                }
            }
            return NetworkRoleColumnHelper.getValue(images);
        }

        @Override
        public SafeHtml getTooltip(Network network) {
            Map<SafeHtml, String> imagesToText = new LinkedHashMap<SafeHtml, String>();
            if (network.getCluster() != null) {
                if (network.getCluster().isDisplay()) {
                    imagesToText.put(displayImage, constants.displayItemInfo());
                }
                if (network.getCluster().isMigration()) {
                    imagesToText.put(migrationImage, constants.migrationItemInfo());
                }
            }
            return NetworkRoleColumnHelper.getTooltip(imagesToText);
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(roleColumn, constants.roleNetwork(), "60px");
    TextColumnWithTooltip<Network> descColumn = new TextColumnWithTooltip<Network>() {

        @Override
        public String getValue(Network object) {
            return object.getDescription();
        }
    };
    descColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(descColumn, constants.descriptionNetwork(), "400px");
    if (ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly)) {
        getTable().addActionButton(new WebAdminButtonDefinition<Network>(constants.addNetworkNetwork()) {

            @Override
            protected UICommand resolveCommand() {
                return getDetailModel().getNewNetworkCommand();
            }
        });
        getTable().addActionButton(new WebAdminButtonDefinition<Network>(constants.assignDetatchNetworksNework()) {

            @Override
            protected UICommand resolveCommand() {
                return getDetailModel().getManageCommand();
            }
        });
        getTable().addActionButton(new WebAdminButtonDefinition<Network>(constants.setAsDisplayNetwork()) {

            @Override
            protected UICommand resolveCommand() {
                return getDetailModel().getSetAsDisplayCommand();
            }
        });
    }
}
#end_block

#method_before
public String getInnerJoin(String searchObj, String crossRefObj) {
    final String[] joinKey = mJoinDictionary.get(StringFormat.format("%1$s.%2$s", searchObj, crossRefObj));
    final String crossRefTable = getRelatedTableName(crossRefObj);
    final String searchObjTable = getRelatedTableName(searchObj);
    return StringFormat.format(" LEFT OUTER JOIN %3$s ON %1$s.%2$s=%3$s.%4$s ", searchObjTable, joinKey[0], crossRefTable, joinKey[1]);
}
#method_after
public String getInnerJoin(String searchObj, String crossRefObj, boolean useTags) {
    final String[] joinKey = mJoinDictionary.get(StringFormat.format("%1$s.%2$s", searchObj, crossRefObj));
    // For joins, the table we join with is always the full view (including the tags)
    final String crossRefTable = getRelatedTableName(crossRefObj, true);
    final String searchObjTable = getRelatedTableName(searchObj, useTags);
    return StringFormat.format(" LEFT OUTER JOIN %3$s ON %1$s.%2$s=%3$s.%4$s ", searchObjTable, joinKey[0], crossRefTable, joinKey[1]);
}
#end_block

#method_before
public String getRelatedTableName(String obj) {
    if (obj == null) {
        return null;
    } else if (getEntitySearchInfo(obj) != null) {
        return getEntitySearchInfo(obj).relatedTableName;
    }
    return null;
}
#method_after
public String getRelatedTableName(String obj, String fieldName) {
    return getRelatedTableName(obj, fieldName == null || fieldName.length() == 0 || fieldName.toLowerCase().equalsIgnoreCase("tag"));
}
#end_block

#method_before
public String getRelatedTableName(String obj) {
    if (obj == null) {
        return null;
    } else if (getEntitySearchInfo(obj) != null) {
        return getEntitySearchInfo(obj).relatedTableName;
    }
    return null;
}
#method_after
private String getRelatedTableName(String obj) {
    if (obj == null) {
        return null;
    } else if (getEntitySearchInfo(obj) != null) {
        return getEntitySearchInfo(obj).relatedTableName;
    }
    return null;
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VmStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VM> nameColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(VMComparator.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "220px");
    // $NON-NLS-1$
    getTable().addColumn(new VmTypeColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VM> statusColumn = new EnumColumn<VM, VMStatus>() {

        @Override
        protected VMStatus getRawValue(VM object) {
            return object.getStatus();
        }
    };
    statusColumn.makeSortable(VMComparator.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusVm(), "220px");
    TextColumnWithTooltip<VM> uptimeColumn = new UptimeColumn<VM>() {

        @Override
        protected Double getRawValue(VM object) {
            return object.getRoundedElapsedTime();
        }
    };
    uptimeColumn.makeSortable(VMComparator.UPTIME);
    // $NON-NLS-1$
    getTable().addColumn(uptimeColumn, constants.uptimeVm(), "220px");
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    VmStatusColumn<VM> statusIconColumn = new VmStatusColumn<VM>();
    statusIconColumn.makeSortable(VmConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusIconColumn, constants.empty(), "30px");
    TextColumnWithTooltip<VM> nameColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(VmConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "220px");
    VmTypeColumn typeColumn = new VmTypeColumn();
    typeColumn.makeSortable(VmConditionFieldAutoCompleter.TYPE);
    // $NON-NLS-1$
    getTable().addColumn(typeColumn, constants.empty(), "30px");
    TextColumnWithTooltip<VM> statusColumn = new EnumColumn<VM, VMStatus>() {

        @Override
        protected VMStatus getRawValue(VM object) {
            return object.getStatus();
        }
    };
    statusColumn.makeSortable(VmConditionFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusVm(), "220px");
    TextColumnWithTooltip<VM> uptimeColumn = new UptimeColumn<VM>() {

        @Override
        protected Double getRawValue(VM object) {
            return object.getRoundedElapsedTime();
        }
    };
    uptimeColumn.makeSortable(VmConditionFieldAutoCompleter.UPTIME);
    // $NON-NLS-1$
    getTable().addColumn(uptimeColumn, constants.uptimeVm(), "220px");
}
#end_block

#method_before
public void guide() {
    ClusterGuideModel model = new ClusterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newClusterGuideMeTitle());
    model.setHelpTag(HelpTag.new_cluster___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_cluster_-_guide_me");
    if (getGuideContext() == null) {
        VDSGroup cluster = (VDSGroup) getSelectedItem();
        setGuideContext(cluster.getId());
    }
    AsyncDataProvider.getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel clusterListModel = (ClusterListModel) target;
            ClusterGuideModel model = (ClusterGuideModel) clusterListModel.getWindow();
            model.setEntity((VDSGroup) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", clusterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
public void guide() {
    ClusterGuideModel model = new ClusterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newClusterGuideMeTitle());
    model.setHelpTag(HelpTag.new_cluster___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_cluster_-_guide_me");
    if (getGuideContext() == null) {
        VDSGroup cluster = (VDSGroup) getSelectedItem();
        setGuideContext(cluster.getId());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel clusterListModel = (ClusterListModel) target;
            ClusterGuideModel model = (ClusterGuideModel) clusterListModel.getWindow();
            model.setEntity((VDSGroup) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", clusterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    ClusterModel clusterModel = new ClusterModel();
    clusterModel.init(false);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().newClusterTitle());
    clusterModel.setHelpTag(HelpTag.new_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("new_cluster");
    clusterModel.setIsNew(true);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterListModel clModel = (ClusterListModel) model;
            ClusterModel cModel = (ClusterModel) clModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            cModel.getDataCenter().setItems(dataCenters);
            // Strict data center as neccessary.
            if (clModel.getSystemTreeSelectedItem() != null && clModel.getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
                StoragePool selectDataCenter = (StoragePool) clModel.getSystemTreeSelectedItem().getEntity();
                cModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(selectDataCenter.getId())));
                cModel.getDataCenter().setIsChangable(false);
            } else {
                cModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnSave", clModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            cModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("Cancel", clModel);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            cModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    ClusterModel clusterModel = new ClusterModel();
    clusterModel.init(false);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().newClusterTitle());
    clusterModel.setHelpTag(HelpTag.new_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("new_cluster");
    clusterModel.setIsNew(true);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterListModel clModel = (ClusterListModel) model;
            ClusterModel cModel = (ClusterModel) clModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            cModel.getDataCenter().setItems(dataCenters);
            // Strict data center as neccessary.
            if (clModel.getSystemTreeSelectedItem() != null && clModel.getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
                SystemTreeItemModel treeSelectedItem = clModel.getSystemTreeSelectedItem();
                SystemTreeItemModel treeSelectedDc = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, treeSelectedItem);
                StoragePool selectDataCenter = (StoragePool) treeSelectedDc.getEntity();
                cModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(selectDataCenter.getId())));
                cModel.getDataCenter().setIsChangable(false);
            } else {
                cModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnSave", clModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            cModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("Cancel", clModel);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            cModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    clusterModel.getEnableOptionalReason().setEntity(cluster.isOptionalReasonRequired());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVolumeList(asyncQuery, cluster.getName());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVmListByClusterName(asyncQuery1, cluster.getName());
            AsyncQuery asyncQuery2 = new AsyncQuery();
            asyncQuery2.setModel(clusterModel);
            asyncQuery2.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VDS> vdsList = (ArrayList<VDS>) result;
                    if (vdsList.size() > 0) {
                        clusterModel.getEnableTrustedService().setIsChangable(false);
                        clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
                    }
                }
            };
            AsyncDataProvider.getHostListByCluster(asyncQuery2, cluster.getName());
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    clusterModel.getEnableOptionalReason().setEntity(cluster.isOptionalReasonRequired());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getInstance().getVolumeList(asyncQuery, cluster.getName());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getInstance().getVmListByClusterName(asyncQuery1, cluster.getName());
            AsyncQuery asyncQuery2 = new AsyncQuery();
            asyncQuery2.setModel(clusterModel);
            asyncQuery2.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VDS> vdsList = (ArrayList<VDS>) result;
                    if (vdsList.size() > 0) {
                        clusterModel.getEnableTrustedService().setIsChangable(false);
                        clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
                    }
                }
            };
            AsyncDataProvider.getInstance().getHostListByCluster(asyncQuery2, cluster.getName());
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onSaveConfirmCpuLevel() {
    ClusterModel model = (ClusterModel) getWindow();
    // cancel confirm window if there is one
    cancelConfirmation();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(model);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            Integer activeVms = (Integer) result;
            ServerCpu vdsCpu = getVdsGroupServerCpu(clusterModel, (VDSGroup) getSelectedItem());
            if (activeVms > 0 && vdsCpu != null && clusterModel.getCPU().getSelectedItem().getLevel() < vdsCpu.getLevel()) {
                cpuLevelConfirmationWindow();
            } else {
                onSaveInternal();
            }
        }
    };
    AsyncDataProvider.getNumberOfActiveVmsInCluster(_asyncQuery, ((VDSGroup) getSelectedItem()).getId());
}
#method_after
private void onSaveConfirmCpuLevel() {
    ClusterModel model = (ClusterModel) getWindow();
    // cancel confirm window if there is one
    cancelConfirmation();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(model);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            Integer activeVms = (Integer) result;
            ServerCpu vdsCpu = getVdsGroupServerCpu(clusterModel, (VDSGroup) getSelectedItem());
            if (activeVms > 0 && vdsCpu != null && clusterModel.getCPU().getSelectedItem().getLevel() < vdsCpu.getLevel()) {
                cpuLevelConfirmationWindow();
            } else {
                onSaveInternal();
            }
        }
    };
    AsyncDataProvider.getInstance().getNumberOfActiveVmsInCluster(_asyncQuery, ((VDSGroup) getSelectedItem()).getId());
}
#end_block

#method_before
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().startProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.setHandleFailure(true);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            getWindow().stopProgress();
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
            if (returnValue == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            } else if (!returnValue.getSucceeded()) {
                clusterModel.setMessage(Frontend.getInstance().getAppErrorsTranslator().translateErrorTextSingle(returnValue.getExceptionString()));
                return;
            }
            Map<String, String> hostMap = returnValue.getReturnValue();
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (// $NON-NLS-1$
            hostMap.containsValue(null) || hostMap.containsValue("")) {
                onGlusterHostsWithoutFingerprint(hostMap, clusterModel);
                return;
            }
            ArrayList<EntityModel<HostDetailModel>> list = new ArrayList<EntityModel<HostDetailModel>>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel<HostDetailModel> entityModel = new EntityModel<HostDetailModel>(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.getGlusterHosts(aQuery, clusterModel.getGlusterHostAddress().getEntity(), clusterModel.getGlusterHostPassword().getEntity(), clusterModel.getGlusterHostFingerprint().getEntity());
}
#method_after
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().startProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.setHandleFailure(true);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            getWindow().stopProgress();
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
            if (returnValue == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            } else if (!returnValue.getSucceeded()) {
                clusterModel.setMessage(Frontend.getInstance().getAppErrorsTranslator().translateErrorTextSingle(returnValue.getExceptionString()));
                return;
            }
            Map<String, String> hostMap = returnValue.getReturnValue();
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (// $NON-NLS-1$
            hostMap.containsValue(null) || hostMap.containsValue("")) {
                onGlusterHostsWithoutFingerprint(hostMap, clusterModel);
                return;
            }
            ArrayList<EntityModel<HostDetailModel>> list = new ArrayList<EntityModel<HostDetailModel>>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel<HostDetailModel> entityModel = new EntityModel<HostDetailModel>(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.getInstance().getGlusterHosts(aQuery, clusterModel.getGlusterHostAddress().getEntity(), clusterModel.getGlusterHostPassword().getEntity(), clusterModel.getGlusterHostFingerprint().getEntity());
}
#end_block

#method_before
@Override
public IConditionValueAutoCompleter getFieldValueAutoCompleter(String fieldName) {
    IConditionValueAutoCompleter retval = null;
    if ("ARCHITECTURE".equals(fieldName)) {
        retval = new EnumValueAutoCompleter(ArchitectureType.class);
    }
    return retval;
}
#method_after
@Override
public IConditionValueAutoCompleter getFieldValueAutoCompleter(String fieldName) {
    IConditionValueAutoCompleter retval = null;
    if (ARCHITECTURE.equals(fieldName)) {
        retval = new EnumValueAutoCompleter(ArchitectureType.class);
    }
    return retval;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<AuthenticationProfile> profiles = AuthenticationProfileRepository.getInstance().getProfiles();
    List<String> names = new ArrayList<>(profiles.size());
    for (AuthenticationProfile profile : profiles) {
        names.add(profile.getName());
    }
    // Sort it so that the internal profile is always the last:
    sort(names, new LoginDomainComparator(Config.<String>getValue(ConfigValues.AdminDomain)));
    getQueryReturnValue().setReturnValue(names);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<AuthenticationProfile> profiles = AuthenticationProfileRepository.getInstance().getProfiles();
    List<String> names = new ArrayList<>(profiles.size());
    for (AuthenticationProfile profile : profiles) {
        names.add(profile.getName());
    }
    Collections.sort(names);
    getQueryReturnValue().setReturnValue(names);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    // Get the list of authentication profile names:
    List<ExtensionProxy> extensions = getExtensionsManager().getExtensionsByService(Authz.class.getName());
    List<String> names = new ArrayList<>(extensions.size());
    for (ExtensionProxy extension : extensions) {
        names.add(AuthzUtils.getName(extension));
    }
    if (getParameters().getFilterInternalDomain()) {
        names.remove(INTERNAL);
    }
    sort(names);
    // Return the sorted list:
    getQueryReturnValue().setReturnValue(names);
}
#method_after
@Override
protected void executeQueryCommand() {
    // Get the list of authentication profile names:
    List<ExtensionProxy> extensions = getExtensionsManager().getExtensionsByService(Authz.class.getName());
    List<String> names = new ArrayList<>(extensions.size());
    for (ExtensionProxy extension : extensions) {
        names.add(AuthzUtils.getName(extension));
    }
    sort(names);
    // Return the sorted list:
    getQueryReturnValue().setReturnValue(names);
}
#end_block

#method_before
@Override
protected void buildVmVirtioSerial() {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSERIAL.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        struct.put(VdsProperties.Device, VdsProperties.VirtioSerial);
        struct.put(VdsProperties.Index, Integer.toString(0));
        addAddress(vmDevice, struct);
        addDevice(struct, vmDevice, null);
    }
}
#method_after
@Override
protected void buildVmVirtioSerial() {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSERIAL.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        struct.put(VdsProperties.Device, VdsProperties.VirtioSerial);
        addAddress(vmDevice, struct);
        addDevice(struct, vmDevice, null);
    }
}
#end_block

