918
#method_before
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error("Failure to refresh Vds runtime info. Incorrect vdsm version for cluster", cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            _vds.setStatus(VDSStatus.Error);
            _saveVdsDynamic = true;
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#method_after
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintenance = _vds.getStatus() == VDSStatus.Up || _vds.getStatus() == VDSStatus.PreparingForMaintenance || _vds.getStatus() == VDSStatus.Error || _vds.getStatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintenance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getStatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintenance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    } catch (ClassCastException cce) {
        // This should occur only if the vdsm API is not the same as the cluster API (version mismatch)
        log.error(String.format("Failure to refresh Vds %s runtime info. Incorrect vdsm version for cluster %s", _vds.getName(), _vds.getVdsGroupName()), cce);
        if (_vds.getStatus() != VDSStatus.PreparingForMaintenance && _vds.getStatus() != VDSStatus.Maintenance) {
            ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(_vds.getId(), VDSStatus.Error));
        }
    } catch (Throwable t) {
        log.error("Failure to refresh Vds runtime info", t);
        throw t;
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
/**
 * Test the following where each word should be the completion for the earlier portion Vms : Events =
 */
public void testVMCompletion() {
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = null;
    res = chkr.getCompletion("");
    assertTrue("Vms", contains(res, "Vms"));
    res = chkr.getCompletion("V");
    assertTrue("Vms2", contains(res, "Vms"));
    res = chkr.getCompletion("Vms");
    assertTrue(":", contains(res, ":"));
    res = chkr.getCompletion("Vms : ");
    assertTrue("Events", contains(res, "Events"));
    res = chkr.getCompletion("Vms : Events");
    assertTrue("=", contains(res, "="));
}
#method_after
@Test
public void testVMCompletion() {
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = null;
    res = chkr.getCompletion("");
    assertTrue("Vms", contains(res, "Vms"));
    res = chkr.getCompletion("V");
    assertTrue("Vms2", contains(res, "Vms"));
    res = chkr.getCompletion("Vms");
    assertTrue(":", contains(res, ":"));
    res = chkr.getCompletion("Vms : ");
    assertTrue("Events", contains(res, "Events"));
    res = chkr.getCompletion("Vms : Events");
    assertTrue("=", contains(res, "="));
}
#end_block

#method_before
public void testHostCompletion() {
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = null;
    res = chkr.getCompletion("");
    assertTrue("Hosts", contains(res, "Hosts"));
    res = chkr.getCompletion("H");
    assertTrue("Hots2", contains(res, "Hosts"));
    res = chkr.getCompletion("Host");
    assertTrue(":", contains(res, ":"));
    res = chkr.getCompletion("Host : ");
    assertTrue("sortby", contains(res, "sortby"));
    res = chkr.getCompletion("Host : sortby");
    assertTrue("migrating_vms", contains(res, "migrating_vms"));
    res = chkr.getCompletion("Host : sortby migrating_vms");
    assertTrue("asc", contains(res, "asc"));
}
#method_after
@Test
public void testHostCompletion() {
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = null;
    res = chkr.getCompletion("");
    assertTrue("Hosts", contains(res, "Hosts"));
    res = chkr.getCompletion("H");
    assertTrue("Hots2", contains(res, "Hosts"));
    res = chkr.getCompletion("Host");
    assertTrue(":", contains(res, ":"));
    res = chkr.getCompletion("Host : ");
    assertTrue("sortby", contains(res, "sortby"));
    res = chkr.getCompletion("Host : sortby");
    assertTrue("migrating_vms", contains(res, "migrating_vms"));
    res = chkr.getCompletion("Host : sortby migrating_vms");
    assertTrue("asc", contains(res, "asc"));
}
#end_block

#method_before
public void testGetPagPhrase() {
    mcr.mockConfigValue(ConfigValues.DBPagingType, "wrongPageType");
    mcr.mockConfigValue(ConfigValues.DBPagingSyntax, "wrongPageSyntax");
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = new SyntaxContainer("");
    res.setMaxCount(0);
    // check wrong config values
    assertTrue(chkr.getPagePhrase(res, "1") == "");
    mcr.mockConfigValue(ConfigValues.DBPagingType, "Range");
    mcr.mockConfigValue(ConfigValues.DBPagingSyntax, " WHERE RowNum BETWEEN %1$s AND %2$s");
    // check valid config values
    assertTrue(chkr.getPagePhrase(res, "1") != "");
}
#method_after
@Test
public void testGetPagPhrase() {
    mcr.mockConfigValue(ConfigValues.DBPagingType, "wrongPageType");
    mcr.mockConfigValue(ConfigValues.DBPagingSyntax, "wrongPageSyntax");
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = new SyntaxContainer("");
    res.setMaxCount(0);
    // check wrong config values
    assertTrue(chkr.getPagePhrase(res, "1") == "");
    mcr.mockConfigValue(ConfigValues.DBPagingType, "Range");
    mcr.mockConfigValue(ConfigValues.DBPagingSyntax, " WHERE RowNum BETWEEN %1$s AND %2$s");
    // check valid config values
    assertTrue(chkr.getPagePhrase(res, "1") != "");
}
#end_block

#method_before
@Test
public void testAlerts() {
    SyntaxChecker chkr = new SyntaxChecker(100);
    ISyntaxChecker curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker("foo");
    SyntaxContainer res = curSyntaxChecker.analyzeSyntaxState("Events: severity=error", true);
    String query = chkr.generateQueryFromSyntaxContainer(res, true);
    Assert.assertEquals("SELECT * FROM (SELECT audit_log.audit_log_id FROM  audit_log   WHERE  audit_log.severity = '2'  and (not deleted)  ORDER BY audit_log_id DESC ) as T1 OFFSET (1 -1) LIMIT 0", query);
}
#method_after
@Test
public void testAlerts() {
    SyntaxChecker chkr = new SyntaxChecker(100);
    ISyntaxChecker curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker("foo");
    SyntaxContainer res = curSyntaxChecker.analyzeSyntaxState("Events: severity=error", true);
    String query = chkr.generateQueryFromSyntaxContainer(res, true);
    Assert.assertEquals("SELECT * FROM (SELECT audit_log.* FROM  audit_log   WHERE  audit_log.severity = '2'  and (not deleted)  ORDER BY audit_log_id DESC ) as T1 OFFSET (1 -1) LIMIT 0", query);
}
#end_block

#method_before
private String generateSqlFromSyntaxContainer(SyntaxContainer syntax, boolean isSafe) {
    String retval = "";
    if (syntax.getvalid()) {
        ListIterator<SyntaxObject> objIter = syntax.listIterator(0);
        IConditionFieldAutoCompleter conditionFieldAC;
        LinkedList<String> whereBuilder = new LinkedList<String>();
        String searchObjStr = syntax.getSearchObjectStr();
        String sortByPhrase = "";
        String fromStatement = "";
        String pageNumber = "";
        while (objIter.hasNext()) {
            SyntaxObject obj = objIter.next();
            switch(obj.getType()) {
                case SEARCH_OBJECT:
                    fromStatement = generateFromStatement(syntax);
                    break;
                case OR:
                case AND:
                    whereBuilder.addLast(obj.getBody());
                    break;
                case CONDITION_VALUE:
                    whereBuilder.addLast(generateConditionStatment(obj, syntax.listIterator(objIter.previousIndex()), searchObjStr, syntax.getCaseSensitive(), isSafe));
                    break;
                case SORTBY:
                    break;
                case PAGE_VALUE:
                    pageNumber = obj.getBody();
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                    sortByPhrase = StringFormat.format(" ORDER BY %1$s", conditionFieldAC.getSortableDbField(obj.getBody()));
                    break;
                case SORT_DIRECTION:
                    // Forcing any sorting using DESC to show NULL values last (NULLS FIRST is the default)
                    String direction = (obj.getBody().equalsIgnoreCase("desc")) ? "DESC NULLS LAST" : obj.getBody();
                    sortByPhrase = StringFormat.format("%1$s %2$s", sortByPhrase, direction);
                    break;
                default:
                    break;
            }
        }
        // implying precedence rules
        String[] lookFor = { "AND", "OR" };
        for (int idx = 0; idx < lookFor.length; idx++) {
            boolean found = true;
            while (found) {
                found = false;
                ListIterator<String> iter = whereBuilder.listIterator(0);
                while (iter.hasNext()) {
                    String queryPart = iter.next();
                    if (lookFor[idx].equals(queryPart)) {
                        iter.remove();
                        String nextPart = iter.next();
                        iter.remove();
                        String prevPart = iter.previous();
                        iter.set(StringFormat.format("( %1$s %2$s %3$s )", prevPart, queryPart, nextPart));
                        found = true;
                        break;
                    }
                }
            }
        }
        // adding WHERE if required and All implicit AND
        StringBuilder wherePhrase = new StringBuilder();
        if (whereBuilder.size() > 0) {
            wherePhrase.append(" WHERE ");
            ListIterator<String> iter = whereBuilder.listIterator(0);
            while (iter.hasNext()) {
                String queryPart = iter.next();
                wherePhrase.append(queryPart);
                if (iter.hasNext()) {
                    wherePhrase.append(" AND ");
                }
            }
        }
        // adding the sorting part if required
        if ("".equals(sortByPhrase)) {
            sortByPhrase = " ORDER BY " + mSearchObjectAC.getDefaultSort(searchObjStr);
        }
        // adding the paging phrase
        String pagePhrase = getPagePhrase(syntax, pageNumber);
        String primeryKey = mSearchObjectAC.getPrimeryKeyName(searchObjStr);
        String tableName = mSearchObjectAC.getRelatedTableName(searchObjStr);
        String tableNameWithOutTags = mSearchObjectAC.getRelatedTableNameWithOutTags(searchObjStr);
        String innerQuery = StringFormat.format("SELECT %1$s.%2$s FROM %3$s %4$s", tableName, primeryKey, fromStatement, wherePhrase);
        // adding a secondary default sort by entity name
        StringBuilder sortExpr = new StringBuilder();
        sortExpr.append(sortByPhrase);
        if (sortByPhrase.indexOf(mSearchObjectAC.getDefaultSort(searchObjStr)) < 0) {
            sortExpr.append(",");
            sortExpr.append(mSearchObjectAC.getDefaultSort(searchObjStr));
        }
        // only audit log search supports the SearchFrom which enables getting records starting from a certain
        // audit_log_id, this is done to make search queries from the client more efficient and eliminate the client
        // from registering to such queries and comparing last data with previous.
        String inQuery = "";
        if (primeryKey.equals("audit_log_id")) {
            if (wherePhrase.length() == 0) {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom());
            } else if (whereBuilder.size() == 1 && wherePhrase.toString().contains("severity")) {
                inQuery = innerQuery + " and (not deleted";
            } else {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and %2$s IN (%4$s) and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom(), innerQuery);
            }
        } else if (primeryKey.equals("vmt_guid") && wherePhrase.length() == 0) {
            inQuery = StringFormat.format("(SELECT * FROM %1$s ", tableNameWithOutTags);
        } else if (primeryKey.equals("vmt_guid") && wherePhrase.length() > 0 && wherePhrase.toString().contains("storage_pool_name") && whereBuilder.size() == 1) {
            inQuery = StringFormat.format("(SELECT * FROM %1$s %2$s", tableNameWithOutTags, wherePhrase.toString().replace(tableName, tableNameWithOutTags));
        } else {
            inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s IN (%3$s)", tableNameWithOutTags, primeryKey, innerQuery);
        }
        retval = StringFormat.format(Config.<String>getValue(ConfigValues.DBSearchTemplate), sortExpr.toString(), inQuery, pagePhrase);
        // Check for sql injection if query is not safe
        if (!isSafe) {
            if (sqlInjectionChecker.hasSqlInjection(retval)) {
                throw new SqlInjectionException();
            }
        }
        log.trace("Search: " + retval);
    }
    return retval;
}
#method_after
private String generateSqlFromSyntaxContainer(SyntaxContainer syntax, boolean isSafe) {
    String retval = "";
    if (syntax.getvalid()) {
        ListIterator<SyntaxObject> objIter = syntax.listIterator(0);
        IConditionFieldAutoCompleter conditionFieldAC;
        LinkedList<String> whereBuilder = new LinkedList<String>();
        String searchObjStr = syntax.getSearchObjectStr();
        String sortByPhrase = "";
        String fromStatement = "";
        String pageNumber = "";
        while (objIter.hasNext()) {
            SyntaxObject obj = objIter.next();
            switch(obj.getType()) {
                case SEARCH_OBJECT:
                    fromStatement = generateFromStatement(syntax);
                    break;
                case OR:
                case AND:
                    whereBuilder.addLast(obj.getBody());
                    break;
                case CONDITION_VALUE:
                    whereBuilder.addLast(generateConditionStatment(obj, syntax.listIterator(objIter.previousIndex()), searchObjStr, syntax.getCaseSensitive(), isSafe));
                    break;
                case SORTBY:
                    break;
                case PAGE_VALUE:
                    pageNumber = obj.getBody();
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                    sortByPhrase = StringFormat.format(" ORDER BY %1$s", conditionFieldAC.getSortableDbField(obj.getBody()));
                    break;
                case SORT_DIRECTION:
                    // Forcing any sorting using DESC to show NULL values last (NULLS FIRST is the default)
                    String direction = (obj.getBody().equalsIgnoreCase("desc")) ? "DESC NULLS LAST" : obj.getBody();
                    sortByPhrase = StringFormat.format("%1$s %2$s", sortByPhrase, direction);
                    break;
                default:
                    break;
            }
        }
        // implying precedence rules
        String[] lookFor = { "AND", "OR" };
        for (int idx = 0; idx < lookFor.length; idx++) {
            boolean found = true;
            while (found) {
                found = false;
                ListIterator<String> iter = whereBuilder.listIterator(0);
                while (iter.hasNext()) {
                    String queryPart = iter.next();
                    if (lookFor[idx].equals(queryPart)) {
                        iter.remove();
                        String nextPart = iter.next();
                        iter.remove();
                        String prevPart = iter.previous();
                        iter.set(StringFormat.format("( %1$s %2$s %3$s )", prevPart, queryPart, nextPart));
                        found = true;
                        break;
                    }
                }
            }
        }
        // adding WHERE if required and All implicit AND
        StringBuilder wherePhrase = new StringBuilder();
        if (whereBuilder.size() > 0) {
            wherePhrase.append(" WHERE ");
            ListIterator<String> iter = whereBuilder.listIterator(0);
            while (iter.hasNext()) {
                String queryPart = iter.next();
                wherePhrase.append(queryPart);
                if (iter.hasNext()) {
                    wherePhrase.append(" AND ");
                }
            }
        }
        // adding the sorting part if required
        if ("".equals(sortByPhrase)) {
            sortByPhrase = " ORDER BY " + mSearchObjectAC.getDefaultSort(searchObjStr);
        }
        // adding the paging phrase
        String pagePhrase = getPagePhrase(syntax, pageNumber);
        String primeryKey = mSearchObjectAC.getPrimeryKeyName(searchObjStr);
        String tableName = mSearchObjectAC.getRelatedTableName(searchObjStr);
        String tableNameWithOutTags = mSearchObjectAC.getRelatedTableNameWithOutTags(searchObjStr);
        String innerQuery = StringFormat.format("SELECT %1$s.%2$s FROM %3$s %4$s", tableName, primeryKey, fromStatement, wherePhrase);
        // adding a secondary default sort by entity name
        StringBuilder sortExpr = new StringBuilder();
        sortExpr.append(sortByPhrase);
        if (sortByPhrase.indexOf(mSearchObjectAC.getDefaultSort(searchObjStr)) < 0) {
            sortExpr.append(",");
            sortExpr.append(mSearchObjectAC.getDefaultSort(searchObjStr));
        }
        // TODO: The database configuration PostgresSearchTemplate has an extra closing braces. Hence our
        // queries in this code have an extra opening one. Fix it in a future patch.
        // only audit log search supports the SearchFrom which enables getting records starting from a certain
        // audit_log_id, this is done to make search queries from the client more efficient and eliminate the client
        // from registering to such queries and comparing last data with previous.
        String inQuery = "";
        if (primeryKey.equals("audit_log_id")) {
            if (wherePhrase.length() == 0) {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom());
            } else if (whereBuilder.size() == 1 && wherePhrase.toString().contains("severity")) {
                inQuery = StringFormat.format("SELECT %1$s.* FROM %2$s %3$s and (not deleted", tableName, fromStatement, wherePhrase);
            } else {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and %2$s IN (%4$s) and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom(), innerQuery);
            }
        } else if (primeryKey.equals("vmt_guid") && wherePhrase.length() == 0) {
            inQuery = StringFormat.format("(SELECT * FROM %1$s ", tableNameWithOutTags);
        } else if (primeryKey.equals("vmt_guid") && wherePhrase.length() > 0 && wherePhrase.toString().contains("storage_pool_name") && whereBuilder.size() == 1) {
            inQuery = StringFormat.format("(SELECT * FROM %1$s %2$s", tableNameWithOutTags, wherePhrase.toString().replace(tableName, tableNameWithOutTags));
        } else {
            inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s IN (%3$s)", tableNameWithOutTags, primeryKey, innerQuery);
        }
        retval = StringFormat.format(Config.<String>getValue(ConfigValues.DBSearchTemplate), sortExpr.toString(), inQuery, pagePhrase);
        // Check for sql injection if query is not safe
        if (!isSafe) {
            if (sqlInjectionChecker.hasSqlInjection(retval)) {
                throw new SqlInjectionException();
            }
        }
        log.trace("Search: " + retval);
    }
    return retval;
}
#end_block

#method_before
/**
 * Test the following where each word should be the completion for the earlier portion Vms : Events =
 */
public void testVMCompletion() {
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = null;
    res = chkr.getCompletion("");
    assertTrue("Vms", contains(res, "Vms"));
    res = chkr.getCompletion("V");
    assertTrue("Vms2", contains(res, "Vms"));
    res = chkr.getCompletion("Vms");
    assertTrue(":", contains(res, ":"));
    res = chkr.getCompletion("Vms : ");
    assertTrue("Events", contains(res, "Events"));
    res = chkr.getCompletion("Vms : Events");
    assertTrue("=", contains(res, "="));
}
#method_after
@Test
public void testVMCompletion() {
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = null;
    res = chkr.getCompletion("");
    assertTrue("Vms", contains(res, "Vms"));
    res = chkr.getCompletion("V");
    assertTrue("Vms2", contains(res, "Vms"));
    res = chkr.getCompletion("Vms");
    assertTrue(":", contains(res, ":"));
    res = chkr.getCompletion("Vms : ");
    assertTrue("Events", contains(res, "Events"));
    res = chkr.getCompletion("Vms : Events");
    assertTrue("=", contains(res, "="));
}
#end_block

#method_before
public void testHostCompletion() {
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = null;
    res = chkr.getCompletion("");
    assertTrue("Hosts", contains(res, "Hosts"));
    res = chkr.getCompletion("H");
    assertTrue("Hots2", contains(res, "Hosts"));
    res = chkr.getCompletion("Host");
    assertTrue(":", contains(res, ":"));
    res = chkr.getCompletion("Host : ");
    assertTrue("sortby", contains(res, "sortby"));
    res = chkr.getCompletion("Host : sortby");
    assertTrue("migrating_vms", contains(res, "migrating_vms"));
    res = chkr.getCompletion("Host : sortby migrating_vms");
    assertTrue("asc", contains(res, "asc"));
}
#method_after
@Test
public void testHostCompletion() {
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = null;
    res = chkr.getCompletion("");
    assertTrue("Hosts", contains(res, "Hosts"));
    res = chkr.getCompletion("H");
    assertTrue("Hots2", contains(res, "Hosts"));
    res = chkr.getCompletion("Host");
    assertTrue(":", contains(res, ":"));
    res = chkr.getCompletion("Host : ");
    assertTrue("sortby", contains(res, "sortby"));
    res = chkr.getCompletion("Host : sortby");
    assertTrue("migrating_vms", contains(res, "migrating_vms"));
    res = chkr.getCompletion("Host : sortby migrating_vms");
    assertTrue("asc", contains(res, "asc"));
}
#end_block

#method_before
public void testGetPagPhrase() {
    mcr.mockConfigValue(ConfigValues.DBPagingType, "wrongPageType");
    mcr.mockConfigValue(ConfigValues.DBPagingSyntax, "wrongPageSyntax");
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = new SyntaxContainer("");
    res.setMaxCount(0);
    // check wrong config values
    assertTrue(chkr.getPagePhrase(res, "1") == "");
    mcr.mockConfigValue(ConfigValues.DBPagingType, "Range");
    mcr.mockConfigValue(ConfigValues.DBPagingSyntax, " WHERE RowNum BETWEEN %1$s AND %2$s");
    // check valid config values
    assertTrue(chkr.getPagePhrase(res, "1") != "");
}
#method_after
@Test
public void testGetPagPhrase() {
    mcr.mockConfigValue(ConfigValues.DBPagingType, "wrongPageType");
    mcr.mockConfigValue(ConfigValues.DBPagingSyntax, "wrongPageSyntax");
    SyntaxChecker chkr = new SyntaxChecker(20);
    SyntaxContainer res = new SyntaxContainer("");
    res.setMaxCount(0);
    // check wrong config values
    assertTrue(chkr.getPagePhrase(res, "1") == "");
    mcr.mockConfigValue(ConfigValues.DBPagingType, "Range");
    mcr.mockConfigValue(ConfigValues.DBPagingSyntax, " WHERE RowNum BETWEEN %1$s AND %2$s");
    // check valid config values
    assertTrue(chkr.getPagePhrase(res, "1") != "");
}
#end_block

#method_before
@Test
public void testAlerts() {
    SyntaxChecker chkr = new SyntaxChecker(100);
    ISyntaxChecker curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker("foo");
    SyntaxContainer res = curSyntaxChecker.analyzeSyntaxState("Events: severity=error", true);
    String query = chkr.generateQueryFromSyntaxContainer(res, true);
    Assert.assertEquals("SELECT * FROM (SELECT audit_log.audit_log_id FROM  audit_log   WHERE  audit_log.severity = '2'  and (not deleted)  ORDER BY audit_log_id DESC ) as T1 OFFSET (1 -1) LIMIT 0", query);
}
#method_after
@Test
public void testAlerts() {
    SyntaxChecker chkr = new SyntaxChecker(100);
    ISyntaxChecker curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker("foo");
    SyntaxContainer res = curSyntaxChecker.analyzeSyntaxState("Events: severity=error", true);
    String query = chkr.generateQueryFromSyntaxContainer(res, true);
    Assert.assertEquals("SELECT * FROM (SELECT audit_log.* FROM  audit_log   WHERE  audit_log.severity = '2'  and (not deleted)  ORDER BY audit_log_id DESC ) as T1 OFFSET (1 -1) LIMIT 0", query);
}
#end_block

#method_before
private String generateSqlFromSyntaxContainer(SyntaxContainer syntax, boolean isSafe) {
    String retval = "";
    if (syntax.getvalid()) {
        ListIterator<SyntaxObject> objIter = syntax.listIterator(0);
        IConditionFieldAutoCompleter conditionFieldAC;
        LinkedList<String> whereBuilder = new LinkedList<String>();
        String searchObjStr = syntax.getSearchObjectStr();
        String sortByPhrase = "";
        String fromStatement = "";
        String pageNumber = "";
        while (objIter.hasNext()) {
            SyntaxObject obj = objIter.next();
            switch(obj.getType()) {
                case SEARCH_OBJECT:
                    fromStatement = generateFromStatement(syntax);
                    break;
                case OR:
                case AND:
                    whereBuilder.addLast(obj.getBody());
                    break;
                case CONDITION_VALUE:
                    whereBuilder.addLast(generateConditionStatment(obj, syntax.listIterator(objIter.previousIndex()), searchObjStr, syntax.getCaseSensitive(), isSafe));
                    break;
                case SORTBY:
                    break;
                case PAGE_VALUE:
                    pageNumber = obj.getBody();
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                    sortByPhrase = StringFormat.format(" ORDER BY %1$s", conditionFieldAC.getSortableDbField(obj.getBody()));
                    break;
                case SORT_DIRECTION:
                    // Forcing any sorting using DESC to show NULL values last (NULLS FIRST is the default)
                    String direction = (obj.getBody().equalsIgnoreCase("desc")) ? "DESC NULLS LAST" : obj.getBody();
                    sortByPhrase = StringFormat.format("%1$s %2$s", sortByPhrase, direction);
                    break;
                default:
                    break;
            }
        }
        // implying precedence rules
        String[] lookFor = { "AND", "OR" };
        for (int idx = 0; idx < lookFor.length; idx++) {
            boolean found = true;
            while (found) {
                found = false;
                ListIterator<String> iter = whereBuilder.listIterator(0);
                while (iter.hasNext()) {
                    String queryPart = iter.next();
                    if (lookFor[idx].equals(queryPart)) {
                        iter.remove();
                        String nextPart = iter.next();
                        iter.remove();
                        String prevPart = iter.previous();
                        iter.set(StringFormat.format("( %1$s %2$s %3$s )", prevPart, queryPart, nextPart));
                        found = true;
                        break;
                    }
                }
            }
        }
        // adding WHERE if required and All implicit AND
        StringBuilder wherePhrase = new StringBuilder();
        if (whereBuilder.size() > 0) {
            wherePhrase.append(" WHERE ");
            ListIterator<String> iter = whereBuilder.listIterator(0);
            while (iter.hasNext()) {
                String queryPart = iter.next();
                wherePhrase.append(queryPart);
                if (iter.hasNext()) {
                    wherePhrase.append(" AND ");
                }
            }
        }
        // adding the sorting part if required
        if ("".equals(sortByPhrase)) {
            sortByPhrase = " ORDER BY " + mSearchObjectAC.getDefaultSort(searchObjStr);
        }
        // adding the paging phrase
        String pagePhrase = getPagePhrase(syntax, pageNumber);
        String primeryKey = mSearchObjectAC.getPrimeryKeyName(searchObjStr);
        String tableName = mSearchObjectAC.getRelatedTableName(searchObjStr);
        String tableNameWithOutTags = mSearchObjectAC.getRelatedTableNameWithOutTags(searchObjStr);
        String innerQuery = StringFormat.format("SELECT %1$s.%2$s FROM %3$s %4$s", tableName, primeryKey, fromStatement, wherePhrase);
        // adding a secondary default sort by entity name
        StringBuilder sortExpr = new StringBuilder();
        sortExpr.append(sortByPhrase);
        if (sortByPhrase.indexOf(mSearchObjectAC.getDefaultSort(searchObjStr)) < 0) {
            sortExpr.append(",");
            sortExpr.append(mSearchObjectAC.getDefaultSort(searchObjStr));
        }
        // only audit log search supports the SearchFrom which enables getting records starting from a certain
        // audit_log_id, this is done to make search queries from the client more efficient and eliminate the client
        // from registering to such queries and comparing last data with previous.
        String inQuery = "";
        if (primeryKey.equals("audit_log_id")) {
            if (wherePhrase.length() == 0) {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom());
            } else if (whereBuilder.size() == 1 && wherePhrase.toString().contains("severity")) {
                inQuery = innerQuery + " and (not deleted";
            } else {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and %2$s IN (%4$s) and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom(), innerQuery);
            }
        } else if (primeryKey.equals("vmt_guid") && wherePhrase.length() > 0 && wherePhrase.toString().contains("storage_pool_name") && whereBuilder.size() == 1) {
            inQuery = StringFormat.format("(SELECT * FROM %1$s %2$s", tableNameWithOutTags, wherePhrase.toString().replace(tableName, tableNameWithOutTags));
        } else {
            inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s IN (%3$s)", tableNameWithOutTags, primeryKey, innerQuery);
        }
        retval = StringFormat.format(Config.<String>getValue(ConfigValues.DBSearchTemplate), sortExpr.toString(), inQuery, pagePhrase);
        // Check for sql injection if query is not safe
        if (!isSafe) {
            if (sqlInjectionChecker.hasSqlInjection(retval)) {
                throw new SqlInjectionException();
            }
        }
        log.trace("Search: " + retval);
    }
    return retval;
}
#method_after
private String generateSqlFromSyntaxContainer(SyntaxContainer syntax, boolean isSafe) {
    String retval = "";
    if (syntax.getvalid()) {
        ListIterator<SyntaxObject> objIter = syntax.listIterator(0);
        IConditionFieldAutoCompleter conditionFieldAC;
        LinkedList<String> whereBuilder = new LinkedList<String>();
        String searchObjStr = syntax.getSearchObjectStr();
        String sortByPhrase = "";
        String fromStatement = "";
        String pageNumber = "";
        while (objIter.hasNext()) {
            SyntaxObject obj = objIter.next();
            switch(obj.getType()) {
                case SEARCH_OBJECT:
                    fromStatement = generateFromStatement(syntax);
                    break;
                case OR:
                case AND:
                    whereBuilder.addLast(obj.getBody());
                    break;
                case CONDITION_VALUE:
                    whereBuilder.addLast(generateConditionStatment(obj, syntax.listIterator(objIter.previousIndex()), searchObjStr, syntax.getCaseSensitive(), isSafe));
                    break;
                case SORTBY:
                    break;
                case PAGE_VALUE:
                    pageNumber = obj.getBody();
                    break;
                case SORT_FIELD:
                    conditionFieldAC = mSearchObjectAC.getFieldAutoCompleter(searchObjStr);
                    sortByPhrase = StringFormat.format(" ORDER BY %1$s", conditionFieldAC.getSortableDbField(obj.getBody()));
                    break;
                case SORT_DIRECTION:
                    // Forcing any sorting using DESC to show NULL values last (NULLS FIRST is the default)
                    String direction = (obj.getBody().equalsIgnoreCase("desc")) ? "DESC NULLS LAST" : obj.getBody();
                    sortByPhrase = StringFormat.format("%1$s %2$s", sortByPhrase, direction);
                    break;
                default:
                    break;
            }
        }
        // implying precedence rules
        String[] lookFor = { "AND", "OR" };
        for (int idx = 0; idx < lookFor.length; idx++) {
            boolean found = true;
            while (found) {
                found = false;
                ListIterator<String> iter = whereBuilder.listIterator(0);
                while (iter.hasNext()) {
                    String queryPart = iter.next();
                    if (lookFor[idx].equals(queryPart)) {
                        iter.remove();
                        String nextPart = iter.next();
                        iter.remove();
                        String prevPart = iter.previous();
                        iter.set(StringFormat.format("( %1$s %2$s %3$s )", prevPart, queryPart, nextPart));
                        found = true;
                        break;
                    }
                }
            }
        }
        // adding WHERE if required and All implicit AND
        StringBuilder wherePhrase = new StringBuilder();
        if (whereBuilder.size() > 0) {
            wherePhrase.append(" WHERE ");
            ListIterator<String> iter = whereBuilder.listIterator(0);
            while (iter.hasNext()) {
                String queryPart = iter.next();
                wherePhrase.append(queryPart);
                if (iter.hasNext()) {
                    wherePhrase.append(" AND ");
                }
            }
        }
        // adding the sorting part if required
        if ("".equals(sortByPhrase)) {
            sortByPhrase = " ORDER BY " + mSearchObjectAC.getDefaultSort(searchObjStr);
        }
        // adding the paging phrase
        String pagePhrase = getPagePhrase(syntax, pageNumber);
        String primeryKey = mSearchObjectAC.getPrimeryKeyName(searchObjStr);
        String tableName = mSearchObjectAC.getRelatedTableName(searchObjStr);
        String tableNameWithOutTags = mSearchObjectAC.getRelatedTableNameWithOutTags(searchObjStr);
        String innerQuery = StringFormat.format("SELECT %1$s.%2$s FROM %3$s %4$s", tableName, primeryKey, fromStatement, wherePhrase);
        // adding a secondary default sort by entity name
        StringBuilder sortExpr = new StringBuilder();
        sortExpr.append(sortByPhrase);
        if (sortByPhrase.indexOf(mSearchObjectAC.getDefaultSort(searchObjStr)) < 0) {
            sortExpr.append(",");
            sortExpr.append(mSearchObjectAC.getDefaultSort(searchObjStr));
        }
        // TODO: The database configuration PostgresSearchTemplate has an extra closing braces. Hence our
        // queries in this code have an extra opening one. Fix it in a future patch.
        // only audit log search supports the SearchFrom which enables getting records starting from a certain
        // audit_log_id, this is done to make search queries from the client more efficient and eliminate the client
        // from registering to such queries and comparing last data with previous.
        String inQuery = "";
        if (primeryKey.equals("audit_log_id")) {
            if (wherePhrase.length() == 0) {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom());
            } else if (whereBuilder.size() == 1 && wherePhrase.toString().contains("severity")) {
                inQuery = StringFormat.format("SELECT %1$s.* FROM %2$s %3$s and (not deleted", tableName, fromStatement, wherePhrase);
            } else {
                inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s > %3$s and %2$s IN (%4$s) and not deleted", tableNameWithOutTags, primeryKey, syntax.getSearchFrom(), innerQuery);
            }
        } else if (primeryKey.equals("vmt_guid") && wherePhrase.length() > 0 && wherePhrase.toString().contains("storage_pool_name") && whereBuilder.size() == 1) {
            inQuery = StringFormat.format("(SELECT * FROM %1$s %2$s", tableNameWithOutTags, wherePhrase.toString().replace(tableName, tableNameWithOutTags));
        } else {
            inQuery = StringFormat.format("SELECT * FROM %1$s WHERE ( %2$s IN (%3$s)", tableNameWithOutTags, primeryKey, innerQuery);
        }
        retval = StringFormat.format(Config.<String>getValue(ConfigValues.DBSearchTemplate), sortExpr.toString(), inQuery, pagePhrase);
        // Check for sql injection if query is not safe
        if (!isSafe) {
            if (sqlInjectionChecker.hasSqlInjection(retval)) {
                throw new SqlInjectionException();
            }
        }
        log.trace("Search: " + retval);
    }
    return retval;
}
#end_block

#method_before
public final String consoleClientResourcesUrl() {
    String url = getString(DynamicMessageKey.CONSOLE_CLIENT_RESOURCES_URL);
    boolean isAbsolute = url.contains("://");
    return isAbsolute ? url : // $NON-NLS-1$
    Window.Location.getProtocol() + "//" + Window.Location.getHost() + "/" + BaseContextPathData.getInstance().getRelativePath() + // $NON-NLS-1$
    url;
}
#method_after
public final String consoleClientResourcesUrl() {
    String url = getString(DynamicMessageKey.CONSOLE_CLIENT_RESOURCES_URL);
    boolean isAbsolute = UriUtils.extractScheme(url) != null;
    return isAbsolute ? url : // $NON-NLS-1$
    "/" + BaseContextPathData.getInstance().getRelativePath() + url;
}
#end_block

#method_before
@Override
public void oSType_SelectedItemChanged() {
    int osType = getModel().getOSType().getSelectedItem();
    updateVirtioScsiEnabled(vm.getId(), osType);
}
#method_after
@Override
public void oSType_SelectedItemChanged() {
    Integer osType = getModel().getOSType().getSelectedItem();
    if (osType != null) {
        updateVirtioScsiEnabled(vm.getId(), osType);
    }
}
#end_block

#method_before
protected void updateVirtioScsiEnabled(final Guid vmId, int osId) {
    VDSGroup cluster = getModel().getSelectedCluster();
    Version clusterVersion = cluster != null ? cluster.getcompatibility_version() : null;
    AsyncDataProvider.getDiskInterfaceList(osId, clusterVersion, new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<DiskInterface> diskInterfaces = (ArrayList<DiskInterface>) returnValue;
            boolean isOsSupportVirtioScsi = diskInterfaces.contains(DiskInterface.VirtIO_SCSI);
            getModel().getIsVirtioScsiEnabled().setIsChangable(isOsSupportVirtioScsi);
            if (!isOsSupportVirtioScsi) {
                getModel().getIsVirtioScsiEnabled().setEntity(false);
                getModel().getIsVirtioScsiEnabled().setChangeProhibitionReason(constants.cannotEnableVirtioScsiForOs());
            } else {
                if (Guid.isNullOrEmpty(vmId)) {
                    VDSGroup cluster = getModel().getSelectedCluster();
                    boolean isVirtioScsiEnabled = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VirtIoScsiEnabled, cluster.getcompatibility_version().getValue());
                    getModel().getIsVirtioScsiEnabled().setEntity(isVirtioScsiEnabled);
                } else {
                    AsyncDataProvider.isVirtioScsiEnabledForVm(new AsyncQuery(getModel(), new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            getModel().getIsVirtioScsiEnabled().setEntity((Boolean) returnValue);
                        }
                    }), vmId);
                }
            }
        }
    }));
}
#method_after
protected void updateVirtioScsiEnabled(final Guid vmId, int osId) {
    final VDSGroup cluster = getModel().getSelectedCluster();
    if (cluster == null) {
        return;
    }
    AsyncDataProvider.getDiskInterfaceList(osId, cluster.getcompatibility_version(), new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<DiskInterface> diskInterfaces = (ArrayList<DiskInterface>) returnValue;
            boolean isOsSupportVirtioScsi = diskInterfaces.contains(DiskInterface.VirtIO_SCSI);
            getModel().getIsVirtioScsiEnabled().setIsChangable(isOsSupportVirtioScsi);
            if (!isOsSupportVirtioScsi) {
                getModel().getIsVirtioScsiEnabled().setEntity(false);
                getModel().getIsVirtioScsiEnabled().setChangeProhibitionReason(constants.cannotEnableVirtioScsiForOs());
            } else {
                if (Guid.isNullOrEmpty(vmId)) {
                    boolean isVirtioScsiEnabled = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VirtIoScsiEnabled, cluster.getcompatibility_version().getValue());
                    getModel().getIsVirtioScsiEnabled().setEntity(isVirtioScsiEnabled);
                } else {
                    AsyncDataProvider.isVirtioScsiEnabledForVm(new AsyncQuery(getModel(), new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            getModel().getIsVirtioScsiEnabled().setEntity((Boolean) returnValue);
                        }
                    }), vmId);
                }
            }
        }
    }));
}
#end_block

#method_before
@Override
public void oSType_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    int osType = getModel().getOSType().getSelectedItem();
    if (template != null) {
        updateVirtioScsiEnabled(template.getId(), osType);
    }
}
#method_after
@Override
public void oSType_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    Integer osType = getModel().getOSType().getSelectedItem();
    if (template != null && osType != null) {
        updateVirtioScsiEnabled(template.getId(), osType);
    }
}
#end_block

#method_before
@Override
public void oSType_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    int osType = getModel().getOSType().getSelectedItem();
    if (template != null) {
        updateVirtioScsiEnabled(template.getId(), osType);
    }
}
#method_after
@Override
public void oSType_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    Integer osType = getModel().getOSType().getSelectedItem();
    if (template != null && osType != null) {
        updateVirtioScsiEnabled(template.getId(), osType);
    }
}
#end_block

#method_before
@Override
public void updateIfNeeded(VdsDynamic vdsDynamic) {
    VdsDynamic dbData = get(vdsDynamic.getId());
    if (!dbData.equals(vdsDynamic)) {
        update(vdsDynamic);
    } else {
        log.info("Ignored an unneeded update of VdsDynamic");
    }
}
#method_after
@Override
public void updateIfNeeded(VdsDynamic vdsDynamic) {
    VdsDynamic dbData = get(vdsDynamic.getId());
    if (!dbData.equals(vdsDynamic)) {
        update(vdsDynamic);
    } else {
        log.debug("Ignored an unneeded update of VdsDynamic");
    }
}
#end_block

#method_before
public static void main(String[] args) {
    initLogging();
    ManageDomains util;
    try {
        ManageDomainsArguments mdArgs = new ManageDomainsArguments();
        mdArgs.parse(args);
        if (mdArgs.contains(ARG_HELP)) {
            mdArgs.printHelp();
        } else {
            util = new ManageDomains(mdArgs);
            // it's existence is checked during the parser validation
            util.init();
            util.createConfigurationProvider();
            util.runCommand();
        }
    } catch (ManageDomainsResult e) {
        exitOnError(e);
    }
    System.out.println(ManageDomainsResultEnum.OK.getDetailedMessage());
    System.exit(ManageDomainsResultEnum.OK.getExitCode());
}
#method_after
public static void main(String[] args) {
    initLogging();
    ManageDomains util;
    try {
        ManageDomainsArguments mdArgs = new ManageDomainsArguments();
        mdArgs.parse(args);
        if (mdArgs.contains(ARG_HELP)) {
            mdArgs.printHelp();
            System.exit(0);
        } else {
            util = new ManageDomains(mdArgs);
            // it's existence is checked during the parser validation
            util.init();
            util.createConfigurationProvider();
            util.runCommand();
        }
    } catch (ManageDomainsResult e) {
        exitOnError(e);
    }
    System.out.println(ManageDomainsResultEnum.OK.getDetailedMessage());
    System.exit(ManageDomainsResultEnum.OK.getExitCode());
}
#end_block

#method_before
private void createConfigurationProvider() throws ManageDomainsResult {
    String engineConfigProperties = createTempPropFile();
    try {
        String engineConfigExecutable = utilityConfiguration.getEngineConfigExecutablePath();
        String adUserName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserName);
        String domainName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.DomainName);
        String ldapSecurityAuthentication = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPSecurityAuthentication);
        String adUserPassword = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserPassword);
        String adUserId = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserId);
        String ldapServers = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LdapServers);
        String ldapProviderTypes = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPProviderTypes);
        String ldapPort = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPServerPort);
        if (ldapPort == null) {
            ldapPort = DEFAULT_LDAP_SERVER_PORT;
        }
        String changePasswordUrl = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.ChangePasswordUrl);
        if (changePasswordUrl == null) {
            changePasswordUrl = "";
        }
        configurationProvider = new ConfigurationProvider(adUserName, adUserPassword, domainName, ldapSecurityAuthentication, ldapServers, adUserId, ldapProviderTypes, utilityConfiguration.getEngineConfigExecutablePath(), engineConfigProperties, ldapPort, changePasswordUrl);
    } catch (Throwable e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CURRENT_CONFIGURATION, e.getMessage());
    }
}
#method_after
private void createConfigurationProvider() throws ManageDomainsResult {
    String engineConfigProperties = createTempPropFile();
    try {
        String engineConfigExecutable = utilityConfiguration.getEngineConfigExecutablePath();
        String adUserName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserName);
        String domainName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.DomainName);
        String ldapSecurityAuthentication = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPSecurityAuthentication);
        String adUserPassword = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserPassword);
        String adUserId = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserId);
        String ldapServers = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LdapServers);
        String ldapProviderTypes = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPProviderTypes);
        String ldapPort = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPServerPort);
        if (ldapPort == null) {
            ldapPort = DEFAULT_LDAP_SERVER_PORT;
        }
        String changePasswordUrl = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.ChangePasswordMsg);
        if (changePasswordUrl == null) {
            changePasswordUrl = "";
        }
        configurationProvider = new ConfigurationProvider(adUserName, adUserPassword, domainName, ldapSecurityAuthentication, ldapServers, adUserId, ldapProviderTypes, utilityConfiguration.getEngineConfigExecutablePath(), engineConfigProperties, ldapPort, changePasswordUrl);
    } catch (Throwable e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CURRENT_CONFIGURATION, e.getMessage());
    }
}
#end_block

#method_before
private String getPasswordInput() throws ManageDomainsResult {
    String pass = null;
    if (args.contains(ARG_PASSWORD_FILE)) {
        try {
            pass = readPasswordFile(args.get(ARG_PASSWORD_FILE));
        } catch (Exception e) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_READING_PASSWORD_FILE, e.getMessage());
        }
        if (pass == null) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.EMPTY_PASSWORD_FILE);
        }
    } else {
        pass = readPasswordInteractively();
    }
    validatePassword(pass);
    return pass;
}
#method_after
private String getPasswordInput() throws ManageDomainsResult {
    String pass = null;
    if (args.contains(ARG_PASSWORD_FILE)) {
        try {
            pass = readPasswordFile(args.get(ARG_PASSWORD_FILE));
        } catch (Exception e) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_READING_PASSWORD_FILE, e.getMessage());
        }
        if (pass == null) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.EMPTY_PASSWORD_FILE);
        }
    } else {
        pass = readInteractively("Enter password:", true);
    }
    validatePassword(pass);
    return pass;
}
#end_block

#method_before
public void addDomain() throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    String domainName = args.get(ARG_DOMAIN);
    String userName = args.get(ARG_USER);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    List<String> ldapServers = getLdapServers(domainName);
    validateKdcServers(authMode, domainName);
    domainNameEntry.setValueForDomain(domainName, null);
    String changePasswordUrlStr = args.get(ARG_CHANGE_PASSWORD_URL);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordUrl);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    LdapProviderType ldapProviderType = args.getLdapProvider();
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, getPasswordInput());
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    if (args.contains(ARG_CHANGE_PASSWORD_URL)) {
        changePasswordUrlEntry.setValueForDomain(domainName, changePasswordUrlStr);
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry, changePasswordUrlEntry);
    printSuccessMessage(domainName, "added");
}
#method_after
public void addDomain() throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    String domainName = args.get(ARG_DOMAIN);
    String userName = args.get(ARG_USER);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    List<String> ldapServers = getLdapServers(domainName);
    validateKdcServers(authMode, domainName);
    domainNameEntry.setValueForDomain(domainName, null);
    String changePasswordUrlStr = null;
    try {
        changePasswordUrlStr = getChangePasswordMsg();
    } catch (UnsupportedEncodingException e) {
        log.error("Error in encoding the change password message. ", e);
    }
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    LdapProviderType ldapProviderType = args.getLdapProvider();
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, getPasswordInput());
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    if (args.contains(ARG_CHANGE_PASSWORD_MSG)) {
        changePasswordUrlEntry.setValueForDomain(domainName, changePasswordUrlStr);
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry, changePasswordUrlEntry);
    printSuccessMessage(domainName, "added");
}
#end_block

#method_before
public void editDomain() throws ManageDomainsResult {
    System.out.println("editting domain");
    String authMode;
    String domainName = args.get(ARG_DOMAIN);
    authMode = getDomainAuthMode(domainName);
    validateKdcServers(authMode, domainName);
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    String userName = args.get(ARG_USER);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLdapProviderTypeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordUrl);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(currentLdapProviderTypeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePaswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    String password = getPasswordInput();
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    List<String> ldapServers = getLdapServers(domainName);
    if (args.contains(ARG_LDAP_SERVERS)) {
        setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    }
    LdapProviderType ldapProviderType = null;
    if (args.contains(ARG_PROVIDER)) {
        ldapProviderType = args.getLdapProvider();
    }
    if (ldapProviderType != null) {
        ldapProviderTypeEntry.setValueForDomain(domainName, ldapProviderType.name());
    }
    if (args.contains(ARG_CHANGE_PASSWORD_URL)) {
        changePaswordUrlEntry.setValueForDomain(domainName, args.get(ARG_CHANGE_PASSWORD_URL));
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypeEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry, changePaswordUrlEntry);
    printSuccessMessage(domainName, "edited");
}
#method_after
public void editDomain() throws ManageDomainsResult {
    String authMode;
    String domainName = args.get(ARG_DOMAIN);
    authMode = getDomainAuthMode(domainName);
    validateKdcServers(authMode, domainName);
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    String userName = args.get(ARG_USER);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLdapProviderTypeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(currentLdapProviderTypeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePaswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    String password = getPasswordInput();
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    List<String> ldapServers = getLdapServers(domainName);
    if (args.contains(ARG_LDAP_SERVERS)) {
        setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    }
    LdapProviderType ldapProviderType = null;
    if (args.contains(ARG_PROVIDER)) {
        ldapProviderType = args.getLdapProvider();
    }
    if (ldapProviderType != null) {
        ldapProviderTypeEntry.setValueForDomain(domainName, ldapProviderType.name());
    }
    if (args.contains(ARG_CHANGE_PASSWORD_MSG)) {
        try {
            changePaswordUrlEntry.setValueForDomain(domainName, getChangePasswordMsg());
        } catch (UnsupportedEncodingException e) {
            log.error("Error in encoding the change password message. ", e);
        }
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypeEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry, changePaswordUrlEntry);
    printSuccessMessage(domainName, "edited");
}
#end_block

#method_before
private void setConfigurationEntries(DomainsConfigurationEntry domainNameEntry, DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adPasswordEntry, DomainsConfigurationEntry authModeEntry, DomainsConfigurationEntry ldapServersEntry, DomainsConfigurationEntry adUserIdEntry, DomainsConfigurationEntry ldapProviderTypeEntry, DomainsConfigurationEntry changePasswordUrlEntry) throws ManageDomainsResult {
    // Update the configuration
    configurationProvider.setConfigValue(ConfigValues.AdUserName, adUserNameEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserPassword, adPasswordEntry, false);
    configurationProvider.setConfigValue(ConfigValues.LdapServers, ldapServersEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserId, adUserIdEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPSecurityAuthentication, authModeEntry);
    configurationProvider.setConfigValue(ConfigValues.DomainName, domainNameEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPProviderTypes, ldapProviderTypeEntry);
    if (args.contains(ARG_CHANGE_PASSWORD_URL)) {
        configurationProvider.setConfigValue(ConfigValues.ChangePasswordUrl, changePasswordUrlEntry);
    }
}
#method_after
private void setConfigurationEntries(DomainsConfigurationEntry domainNameEntry, DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adPasswordEntry, DomainsConfigurationEntry authModeEntry, DomainsConfigurationEntry ldapServersEntry, DomainsConfigurationEntry adUserIdEntry, DomainsConfigurationEntry ldapProviderTypeEntry, DomainsConfigurationEntry changePasswordUrlEntry) throws ManageDomainsResult {
    // Update the configuration
    configurationProvider.setConfigValue(ConfigValues.AdUserName, adUserNameEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserPassword, adPasswordEntry, false);
    configurationProvider.setConfigValue(ConfigValues.LdapServers, ldapServersEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserId, adUserIdEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPSecurityAuthentication, authModeEntry);
    configurationProvider.setConfigValue(ConfigValues.DomainName, domainNameEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPProviderTypes, ldapProviderTypeEntry);
    if (args.contains(ARG_CHANGE_PASSWORD_MSG)) {
        configurationProvider.setConfigValue(ConfigValues.ChangePasswordMsg, changePasswordUrlEntry);
    }
}
#end_block

#method_before
public void deleteDomain() throws ManageDomainsResult {
    String domainName = args.get(ARG_DOMAIN).toLowerCase();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    // the force delete option should remove with no confirmation/warning
    if (domainNameEntry.getDomainNames().size() == 1 && !args.contains(ARG_FORCE_DELETE)) {
        System.out.println(String.format(WARNING_ABOUT_TO_DELETE_LAST_DOMAIN, domainName));
    }
    if (!args.contains(ARG_FORCE_DELETE) && !confirmDeleteDomain(domainName)) {
        return;
    }
    domainNameEntry.removeValueForDomain(domainName);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserId = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String ldapProviderType = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String changePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordUrl);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserId, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(ldapProviderType, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(changePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.removeValueForDomain(domainName);
    adUserIdEntry.removeValueForDomain(domainName);
    adUserPasswordEntry.removeValueForDomain(domainName);
    authModeEntry.removeValueForDomain(domainName);
    ldapServersEntry.removeValueForDomain(domainName);
    ldapProviderTypeEntry.removeValueForDomain(domainName);
    changePasswordUrlEntry.removeValueForDomain(domainName);
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry, changePasswordUrlEntry);
    System.out.println(String.format(DELETE_DOMAIN_SUCCESS, domainName));
}
#method_after
public void deleteDomain() throws ManageDomainsResult {
    String domainName = args.get(ARG_DOMAIN).toLowerCase();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    // the force delete option should remove with no confirmation/warning
    if (domainNameEntry.getDomainNames().size() == 1 && !args.contains(ARG_FORCE)) {
        System.out.println(String.format(WARNING_ABOUT_TO_DELETE_LAST_DOMAIN, domainName));
    }
    if (!args.contains(ARG_FORCE) && !confirmDeleteDomain(domainName)) {
        return;
    }
    domainNameEntry.removeValueForDomain(domainName);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserId = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String ldapProviderType = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String changePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserId, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(ldapProviderType, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(changePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.removeValueForDomain(domainName);
    adUserIdEntry.removeValueForDomain(domainName);
    adUserPasswordEntry.removeValueForDomain(domainName);
    authModeEntry.removeValueForDomain(domainName);
    ldapServersEntry.removeValueForDomain(domainName);
    ldapProviderTypeEntry.removeValueForDomain(domainName);
    changePasswordUrlEntry.removeValueForDomain(domainName);
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry, changePasswordUrlEntry);
    System.out.println(String.format(DELETE_DOMAIN_SUCCESS, domainName));
}
#end_block

#method_before
private String createTempPropFile() throws ManageDomainsResult {
    File propFile = null;
    try {
        propFile = File.createTempFile("engine-config", "properties");
        propFile.deleteOnExit();
    } catch (IOException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.ERROR_CREATING_PROPERTIES_FILE, ex.getMessage());
    }
    try (FileWriter fw = new FileWriter(propFile)) {
        fw.write(new StringBuilder().append(ConfigValues.AdUserName.name()).append("=\n").append(ConfigValues.AdUserPassword.name()).append(".type=CompositePassword\n").append(ConfigValues.LDAPSecurityAuthentication.name()).append("=\n").append(ConfigValues.DomainName.name()).append("=\n").append(ConfigValues.AdUserId.name()).append("=\n").append(ConfigValues.LdapServers.name()).append("=\n").append(ConfigValues.LDAPProviderTypes.name()).append("=\n").append(ConfigValues.LDAPServerPort.name()).append("=\n").append(ConfigValues.ChangePasswordUrl.name()).append("=\n").toString());
        fw.flush();
    } catch (IOException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.ERROR_CREATING_PROPERTIES_FILE, ex.getMessage());
    }
    return propFile.getAbsolutePath();
}
#method_after
private String createTempPropFile() throws ManageDomainsResult {
    File propFile = null;
    try {
        propFile = File.createTempFile("engine-config", "properties");
        propFile.deleteOnExit();
    } catch (IOException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.ERROR_CREATING_PROPERTIES_FILE, ex.getMessage());
    }
    try (FileWriter fw = new FileWriter(propFile)) {
        fw.write(new StringBuilder().append(ConfigValues.AdUserName.name()).append("=\n").append(ConfigValues.AdUserPassword.name()).append(".type=CompositePassword\n").append(ConfigValues.LDAPSecurityAuthentication.name()).append("=\n").append(ConfigValues.DomainName.name()).append("=\n").append(ConfigValues.AdUserId.name()).append("=\n").append(ConfigValues.LdapServers.name()).append("=\n").append(ConfigValues.LDAPProviderTypes.name()).append("=\n").append(ConfigValues.LDAPServerPort.name()).append("=\n").append(ConfigValues.ChangePasswordMsg.name()).append("=\n").toString());
        fw.flush();
    } catch (IOException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.ERROR_CREATING_PROPERTIES_FILE, ex.getMessage());
    }
    return propFile.getAbsolutePath();
}
#end_block

#method_before
public void parse(String[] args) throws ManageDomainsResult {
    if (args.length < 1 || "--help".equals(args[0])) {
        // print help
        argMap.put(ARG_HELP, null);
        return;
    }
    if (!isValidAction(args[0])) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, args[0]);
    }
    String action = args[0];
    argMap.put(ARG_ACTION, action);
    Map<String, String> parsed;
    if (args.length > 1) {
        // entered more args then just action
        try {
            ExtendedCliParser parser = new ExtendedCliParser();
            parsed = parser.parse(Arrays.copyOfRange(args, 1, args.length));
        } catch (IllegalArgumentException ex) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT, ex.getMessage());
        }
    } else {
        parsed = Collections.<String, String>emptyMap();
    }
    if (!parsed.isEmpty()) {
        if (parsed.containsKey(ARG_HELP)) {
            // print help
            argMap.put(ARG_HELP, null);
            return;
        }
        // config file can be entered for all actions
        moveArgsValues(parsed, ARG_CONFIG_FILE);
        checkRequiredArgsValue(ARG_CONFIG_FILE);
        if (ACTION_ADD.equals(action)) {
            moveArgsValues(parsed, ARG_DOMAIN, ARG_PROVIDER, ARG_USER, ARG_PASSWORD_FILE, ARG_LDAP_SERVERS, ARG_ADD_PERMISSIONS, ARG_CHANGE_PASSWORD_URL);
            checkRequiredArgs(ARG_DOMAIN, ARG_PROVIDER, ARG_USER);
            checkRequiredArgsValue(ARG_DOMAIN, ARG_PROVIDER, ARG_USER, ARG_PASSWORD_FILE, ARG_CHANGE_PASSWORD_URL);
        } else if (ACTION_EDIT.equals(action)) {
            moveArgsValues(parsed, ARG_DOMAIN, ARG_PROVIDER, ARG_USER, ARG_PASSWORD_FILE, ARG_LDAP_SERVERS, ARG_ADD_PERMISSIONS, ARG_CHANGE_PASSWORD_URL);
            checkRequiredArgs(ARG_DOMAIN);
            checkRequiredArgsValue(ARG_DOMAIN, ARG_PROVIDER, ARG_USER, ARG_PASSWORD_FILE, ARG_CHANGE_PASSWORD_URL);
        } else if (ACTION_DELETE.equals(action)) {
            moveArgsValues(parsed, ARG_DOMAIN, ARG_FORCE_DELETE);
            checkRequiredArgs(ARG_DOMAIN);
            checkRequiredArgsValue(ARG_DOMAIN);
        } else if (ACTION_VALIDATE.equals(action)) {
            moveArgsValues(parsed, ARG_REPORT);
        }
        validateChangePasswordUrl();
        convertProvider();
        validateProvider();
    }
    // set default config file if user one was not entered
    if (!contains(ARG_CONFIG_FILE)) {
        argMap.put(ARG_CONFIG_FILE, getDefaultConfigPath());
    }
    // check if some args are left, they are invalid for action
    if (!parsed.isEmpty()) {
        StringBuilder sb = new StringBuilder();
        for (String arg : parsed.keySet()) {
            sb.append(arg);
            sb.append(",");
        }
        sb.deleteCharAt(sb.length() - 1);
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_ACTION, sb.toString(), action);
    }
}
#method_after
public void parse(String[] args) throws ManageDomainsResult {
    if (args.length < 1 || ARG_HELP.equals(args[0])) {
        // print help
        argMap = new HashMap<>();
        argMap.put(ARG_HELP, null);
        return;
    }
    if (!isValidAction(args[0])) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, args[0]);
    }
    if (args.length > 1) {
        // entered more args than just action, parse them
        try {
            ExtendedCliParser parser = initParser();
            argMap = parser.parse(args, 1, args.length);
        } catch (IllegalArgumentException ex) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.ARGUMENT_PARSING_ERROR, ex.getMessage());
        }
    } else {
        argMap = new HashMap<>();
    }
    argMap.put(ARG_ACTION, args[0]);
    // check that all required args are present
    for (String arg : getRequiredArgs(get(ARG_ACTION))) {
        if (!argMap.containsKey(arg)) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.ARGUMENT_IS_REQUIRED, arg);
        }
    }
    convertProvider();
    validateProvider();
    // set default config file if user one was not entered
    if (!contains(ARG_CONFIG_FILE)) {
        argMap.put(ARG_CONFIG_FILE, getDefaultConfigPath());
    }
}
#end_block

#method_before
private void validateProvider() throws ManageDomainsResult {
    if (contains(ARG_PROVIDER)) {
        try {
            LdapProviderType.valueOfIgnoreCase(get(ARG_PROVIDER));
        } catch (IllegalArgumentException | NullPointerException ex) {
            StringBuilder sb = new StringBuilder().append(PROV_AD).append(", ").append(PROV_IPA).append(", ").append(PROV_RHDS).append(", ").append(PROV_ITDS).append(", ").append(PROV_OLDAP);
            throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT, "Invalid provider, valid providers are ", sb.toString());
        }
    }
}
#method_after
private void validateProvider() throws ManageDomainsResult {
    if (contains(ARG_PROVIDER)) {
        try {
            LdapProviderType.valueOfIgnoreCase(get(ARG_PROVIDER));
        } catch (IllegalArgumentException | NullPointerException ex) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_VALUE, String.format("Invalid provider, valid providers are %s", StringUtils.join(new String[] { PROV_AD, PROV_IPA, PROV_RHDS, PROV_ITDS, PROV_OLDAP }, ", ")));
        }
    }
}
#end_block

#method_before
public Map<String, String> parse(String[] args, int from, int to) {
    if (args == null) {
        throw new IllegalArgumentException("Argumens array cannot be null");
    }
    Map<String, String> result = new HashMap<>();
    // parse arguments
    for (int i = from; i < to; ) {
        if (args[i] == null) {
            // just to be sure
            i++;
            continue;
        }
        String name = null;
        String value = null;
        if (isGnuLongArg(args[i])) {
            // parse GNU long argument
            name = parseGnuLongArgName(args[i]);
            value = parseGnuLongArgValue(args[i]);
        } else if (isPosixArg(args[i])) {
            // parse POSIX argument
            name = args[i];
            if (i + 1 < args.length) {
                if (!isPosixArg(args[i + 1]) && !isGnuLongArg(args[i + 1])) {
                    // argument has a value
                    value = args[i + 1];
                    i++;
                }
            }
        } else {
            // invalid argument format
            throw new IllegalArgumentException(String.format("Invalid argument format '%s'!", args[i]));
        }
        Argument arg = argMap.get(name);
        if (arg == null) {
            throw new IllegalArgumentException(String.format("Unknown argument '%s'!", name));
        }
        if (arg.isValueRequied() && StringUtils.isBlank(value)) {
            throw new IllegalArgumentException(String.format("Argument '%s' requires value!", name));
        }
        result.put(arg.getDestination(), value);
        i++;
    }
    return result;
}
#method_after
public Map<String, String> parse(String[] args, int from, int to) {
    if (args == null) {
        throw new IllegalArgumentException("Argumens array cannot be null");
    }
    Map<String, String> result = new HashMap<>();
    // parse arguments
    for (int i = from; i < to; ) {
        if (args[i] == null) {
            // just to be sure
            i++;
            continue;
        }
        String name = null;
        String value = null;
        if (isLongArg(args[i])) {
            // parse long argument
            name = parseLongArgName(args[i]);
            value = parseLongArgValue(args[i]);
        } else if (isShortArg(args[i])) {
            // parse short argument
            name = args[i];
            if (i + 1 < args.length) {
                if (!isShortArg(args[i + 1]) && !isLongArg(args[i + 1])) {
                    // argument has a value
                    value = args[i + 1];
                    i++;
                }
            }
        } else {
            // invalid argument format
            throw new IllegalArgumentException(String.format("Invalid argument format '%s'!", args[i]));
        }
        Argument arg = argMap.get(name);
        if (arg == null) {
            throw new IllegalArgumentException(String.format("Unknown argument '%s'!", name));
        }
        if (arg.isValueRequied() && StringUtils.isBlank(value)) {
            throw new IllegalArgumentException(String.format("Argument '%s' requires value!", name));
        }
        result.put(arg.getDestination(), value);
        i++;
    }
    return result;
}
#end_block

#method_before
@Test
public void parseArgsInRange() {
    Map<String, String> results;
    ExtendedCliParser parser = new ExtendedCliParser();
    String argName1 = "--help";
    String argName2 = "-f";
    String argName3 = "--output";
    String argValue3 = "/dev/null";
    String argName4 = "-u";
    String argValue4 = "root";
    final String[] args = { argName1, argName2, argName3 + GNU_LONG_VALUE_SEP + argValue3, argName4, argValue4 };
    parser.addArg(new ArgumentBuilder().shortName(argName2).build());
    parser.addArg(new ArgumentBuilder().longName(argName3).build());
    results = parser.parse(args, 1, 3);
    assertNotNull(results);
    assertFalse(results.isEmpty());
    assertTrue(results.containsKey(argName2));
    assertTrue(results.containsKey(argName3));
    assertEquals(argValue3, results.get(argName3));
}
#method_after
@Test
public void parseArgsInRange() {
    Map<String, String> results;
    ExtendedCliParser parser = new ExtendedCliParser();
    String argName1 = "--help";
    String argName2 = "-f";
    String argName3 = "--output";
    String argValue3 = "/dev/null";
    String argName4 = "-u";
    String argValue4 = "root";
    final String[] args = { argName1, argName2, argName3 + VALUE_SEP_LONG + argValue3, argName4, argValue4 };
    parser.addArg(new ArgumentBuilder().shortName(argName2).build());
    parser.addArg(new ArgumentBuilder().longName(argName3).build());
    results = parser.parse(args, 1, 3);
    assertNotNull(results);
    assertFalse(results.isEmpty());
    assertTrue(results.containsKey(argName2));
    assertTrue(results.containsKey(argName3));
    assertEquals(argValue3, results.get(argName3));
}
#end_block

#method_before
@Mapping(from = PowerManagement.class, to = VdsStatic.class)
public static VdsStatic map(PowerManagement model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    entity.setManagementIp(getManagementIp(model, entity));
    entity.setPmType(getManagementType(model, entity));
    entity.setPmUser(getManagementUser(model, entity));
    entity.setPmPassword(getManagementPassword(model, entity));
    entity.setPmOptions(getManagementOptions(model, entity));
    if (model.isSetEnabled()) {
        entity.setPmEnabled(model.isEnabled());
    }
    if (model.isSetPmProxies()) {
        String delim = "";
        StringBuilder builder = new StringBuilder();
        for (PmProxy pmProxy : model.getPmProxies().getPmProxy()) {
            builder.append(delim);
            builder.append(pmProxy.getType());
            delim = ",";
        }
        entity.setPmProxyPreferences(builder.toString());
    }
    if (model.isSetAgents()) {
        // Currently only Primary/Secondary agents are supported
        int order = 1;
        for (Agent agent : model.getAgents().getAgents()) {
            if (agent.isSetOrder()) {
                order = agent.getOrder();
            }
            if (order == 1) {
                // Primary
                // in case that order is not defined, secondary will still be defined correctly.
                order++;
            } else if (order == 2) {
                // Secondary
                if (agent.isSetType()) {
                    entity.setPmSecondaryType(agent.getType());
                }
                if (agent.isSetAddress()) {
                    entity.setPmSecondaryIp(agent.getAddress());
                }
                if (agent.isSetUsername()) {
                    entity.setPmSecondaryUser(agent.getUsername());
                }
                if (agent.isSetPassword()) {
                    entity.setPmSecondaryPassword(agent.getPassword());
                }
                if (agent.isSetOptions()) {
                    entity.setPmSecondaryOptions(map(agent.getOptions(), null));
                }
                if (agent.isSetConcurrent()) {
                    entity.setPmSecondaryConcurrent(agent.isConcurrent());
                }
            }
        }
    }
    return entity;
}
#method_after
@Mapping(from = PowerManagement.class, to = VdsStatic.class)
public static VdsStatic map(PowerManagement model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    entity.setManagementIp(getManagementIp(model, entity));
    entity.setPmType(getManagementType(model, entity));
    entity.setPmUser(getManagementUser(model, entity));
    entity.setPmPassword(getManagementPassword(model, entity));
    entity.setPmOptions(getManagementOptions(model, entity));
    if (model.isSetEnabled()) {
        entity.setPmEnabled(model.isEnabled());
    }
    if (model.isSetAutomaticPmEnabled()) {
        entity.setDisablePowerManagementPolicy(!model.isAutomaticPmEnabled());
    }
    if (model.isSetPmProxies()) {
        String delim = "";
        StringBuilder builder = new StringBuilder();
        for (PmProxy pmProxy : model.getPmProxies().getPmProxy()) {
            builder.append(delim);
            builder.append(pmProxy.getType());
            delim = ",";
        }
        entity.setPmProxyPreferences(builder.toString());
    }
    if (model.isSetAgents()) {
        // Currently only Primary/Secondary agents are supported
        int order = 1;
        for (Agent agent : model.getAgents().getAgents()) {
            if (agent.isSetOrder()) {
                order = agent.getOrder();
            }
            if (order == 1) {
                // Primary
                // in case that order is not defined, secondary will still be defined correctly.
                order++;
            } else if (order == 2) {
                // Secondary
                if (agent.isSetType()) {
                    entity.setPmSecondaryType(agent.getType());
                }
                if (agent.isSetAddress()) {
                    entity.setPmSecondaryIp(agent.getAddress());
                }
                if (agent.isSetUsername()) {
                    entity.setPmSecondaryUser(agent.getUsername());
                }
                if (agent.isSetPassword()) {
                    entity.setPmSecondaryPassword(agent.getPassword());
                }
                if (agent.isSetOptions()) {
                    entity.setPmSecondaryOptions(map(agent.getOptions(), null));
                }
                if (agent.isSetConcurrent()) {
                    entity.setPmSecondaryConcurrent(agent.isConcurrent());
                }
            }
        }
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = PowerManagement.class)
public static PowerManagement map(VDS entity, PowerManagement template) {
    PowerManagement model = template != null ? template : new PowerManagement();
    model.setType(entity.getPmType());
    model.setEnabled(entity.getpm_enabled());
    model.setAddress(entity.getManagementIp());
    model.setUsername(entity.getPmUser());
    if (entity.getPmOptionsMap() != null) {
        model.setOptions(map(entity.getPmOptionsMap(), null));
    }
    if (entity.getPmProxyPreferences() != null) {
        PmProxies pmProxies = new PmProxies();
        String[] proxies = StringUtils.split(entity.getPmProxyPreferences(), ",");
        for (String proxy : proxies) {
            PmProxy pmProxy = new PmProxy();
            pmProxy.setType(proxy);
            pmProxies.getPmProxy().add(pmProxy);
        }
        model.setPmProxies(pmProxies);
    }
    if (entity.getpm_enabled()) {
        // Set Primary Agent
        Agent agent = new Agent();
        if (!StringUtils.isEmpty(entity.getManagementIp())) {
            agent.setType(entity.getPmType());
            agent.setAddress(entity.getManagementIp());
            agent.setUsername(entity.getPmUser());
            if (entity.getPmOptionsMap() != null) {
                agent.setOptions(map(entity.getPmOptionsMap(), null));
            }
            agent.setOrder(1);
            model.setAgents(new Agents());
            model.getAgents().getAgents().add(agent);
        }
        // Set Secondary Agent
        if (!StringUtils.isEmpty(entity.getPmSecondaryIp())) {
            boolean concurrent = entity.isPmSecondaryConcurrent();
            // When a second agent exists, 'concurrent' field is relevant for both agents, so here we
            // set it retroactively in the first agent.
            model.getAgents().getAgents().get(0).setConcurrent(concurrent);
            agent = new Agent();
            agent.setType(entity.getPmSecondaryType());
            agent.setAddress(entity.getPmSecondaryIp());
            agent.setUsername(entity.getPmSecondaryUser());
            if (entity.getPmOptionsMap() != null) {
                agent.setOptions(map(entity.getPmSecondaryOptionsMap(), null));
            }
            agent.setOrder(2);
            agent.setConcurrent(concurrent);
            model.getAgents().getAgents().add(agent);
        }
    }
    return model;
}
#method_after
@Mapping(from = VDS.class, to = PowerManagement.class)
public static PowerManagement map(VDS entity, PowerManagement template) {
    PowerManagement model = template != null ? template : new PowerManagement();
    model.setType(entity.getPmType());
    model.setEnabled(entity.getpm_enabled());
    model.setAddress(entity.getManagementIp());
    model.setUsername(entity.getPmUser());
    model.setAutomaticPmEnabled(!entity.isDisablePowerManagementPolicy());
    if (entity.getPmOptionsMap() != null) {
        model.setOptions(map(entity.getPmOptionsMap(), null));
    }
    if (entity.getPmProxyPreferences() != null) {
        PmProxies pmProxies = new PmProxies();
        String[] proxies = StringUtils.split(entity.getPmProxyPreferences(), ",");
        for (String proxy : proxies) {
            PmProxy pmProxy = new PmProxy();
            pmProxy.setType(proxy);
            pmProxies.getPmProxy().add(pmProxy);
        }
        model.setPmProxies(pmProxies);
    }
    if (entity.getpm_enabled()) {
        // Set Primary Agent
        Agent agent = new Agent();
        if (!StringUtils.isEmpty(entity.getManagementIp())) {
            agent.setType(entity.getPmType());
            agent.setAddress(entity.getManagementIp());
            agent.setUsername(entity.getPmUser());
            if (entity.getPmOptionsMap() != null) {
                agent.setOptions(map(entity.getPmOptionsMap(), null));
            }
            agent.setOrder(1);
            model.setAgents(new Agents());
            model.getAgents().getAgents().add(agent);
        }
        // Set Secondary Agent
        if (!StringUtils.isEmpty(entity.getPmSecondaryIp())) {
            boolean concurrent = entity.isPmSecondaryConcurrent();
            // When a second agent exists, 'concurrent' field is relevant for both agents, so here we
            // set it retroactively in the first agent.
            model.getAgents().getAgents().get(0).setConcurrent(concurrent);
            agent = new Agent();
            agent.setType(entity.getPmSecondaryType());
            agent.setAddress(entity.getPmSecondaryIp());
            agent.setUsername(entity.getPmSecondaryUser());
            if (entity.getPmOptionsMap() != null) {
                agent.setOptions(map(entity.getPmSecondaryOptionsMap(), null));
            }
            agent.setOrder(2);
            agent.setConcurrent(concurrent);
            model.getAgents().getAgents().add(agent);
        }
    }
    return model;
}
#end_block

#method_before
public static void main(String[] args) {
    initLogging();
    ManageDomains util;
    util = new ManageDomains();
    CLIParser parser = new CLIParser(args);
    String configFilePath = CONF_FILE_PATH;
    if (parser.hasArg(Arguments.configFile.name())) {
        configFilePath = parser.getArg(Arguments.configFile.name());
    }
    if (parser.hasArg(Arguments.report.name())) {
        util.reportAllErrors = true;
    }
    if (parser.hasArg(Arguments.addPermissions.name())) {
        util.addPermissions = true;
    }
    try {
        // it's existence is checked during the parser validation
        String engineConfigProperties = parser.getArg(Arguments.propertiesFile.name());
        util.init(configFilePath);
        util.validate(parser);
        util.createConfigurationProvider(engineConfigProperties);
        util.runCommand(parser);
    } catch (ManageDomainsResult e) {
        exitOnError(e);
    }
    System.out.println(ManageDomainsResultEnum.OK.getDetailedMessage());
    System.exit(ManageDomainsResultEnum.OK.getExitCode());
}
#method_after
public static void main(String[] args) {
    initLogging();
    ManageDomains util;
    util = new ManageDomains();
    CLIParser parser = new CLIParser(args);
    String configFilePath = CONF_FILE_PATH;
    if (parser.hasArg(Arguments.configFile.name())) {
        configFilePath = parser.getArg(Arguments.configFile.name());
    }
    if (parser.hasArg(Arguments.report.name())) {
        util.reportAllErrors = true;
    }
    if (parser.hasArg(Arguments.addPermissions.name())) {
        util.addPermissions = true;
    }
    if (parser.hasArg(Arguments.changePasswordUrl.name())) {
        util.changePasswordUrl = true;
    }
    try {
        // it's existence is checked during the parser validation
        String engineConfigProperties = parser.getArg(Arguments.propertiesFile.name());
        util.init(configFilePath);
        util.validate(parser);
        util.createConfigurationProvider(engineConfigProperties);
        util.runCommand(parser);
    } catch (ManageDomainsResult e) {
        exitOnError(e);
    }
    System.out.println(ManageDomainsResultEnum.OK.getDetailedMessage());
    System.exit(ManageDomainsResultEnum.OK.getExitCode());
}
#end_block

#method_before
protected String getChangePasswordUrl(CLIParser parser) throws ManageDomainsResult {
    String changePasswordUrl = parser.getArg(Arguments.changePasswordUrl.name());
    if (StringUtils.isEmpty(changePasswordUrl)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_COMMAND, "Password change URL must not be empty");
    }
    try {
        URL url = new URL(changePasswordUrl);
    } catch (MalformedURLException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_COMMAND, "The provided string for Password change URL is not a valid URL");
    }
    return changePasswordUrl;
}
#method_after
protected String getChangePasswordUrl(CLIParser parser) throws ManageDomainsResult {
    if (!changePasswordUrl) {
        return null;
    }
    String changePasswordUrl = parser.getArg(Arguments.changePasswordUrl.name());
    if (StringUtils.isEmpty(changePasswordUrl)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_COMMAND, "Password change URL must not be empty");
    }
    try {
        URL url = new URL(changePasswordUrl);
        log.debug("Validated that " + url + " is in correct format");
    } catch (MalformedURLException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_COMMAND, "The provided string for Password change URL is not a valid URL");
    }
    return changePasswordUrl;
}
#end_block

#method_before
public void addDomain(CLIParser parser) throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    String domainName = parser.getArg(Arguments.domain.toString()).toLowerCase();
    String userName = parser.getArg(Arguments.user.toString());
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    List<String> ldapServers = getLdapServers(parser, domainName);
    validateKdcServers(authMode, domainName);
    domainNameEntry.setValueForDomain(domainName, null);
    String changePasswordUrl = getChangePasswordUrl(parser);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordUrl);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    LdapProviderType ldapProviderType = getLdapProviderType(parser);
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, getPasswordInput(parser));
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    changePasswordUrlEntry.setValueForDomain(domainName, changePasswordUrl);
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry, changePasswordUrlEntry);
    printSuccessMessage(domainName, "added");
}
#method_after
public void addDomain(CLIParser parser) throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    String domainName = parser.getArg(Arguments.domain.toString()).toLowerCase();
    String userName = parser.getArg(Arguments.user.toString());
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    List<String> ldapServers = getLdapServers(parser, domainName);
    validateKdcServers(authMode, domainName);
    domainNameEntry.setValueForDomain(domainName, null);
    String changePasswordUrlStr = getChangePasswordUrl(parser);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordUrl);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    LdapProviderType ldapProviderType = getLdapProviderType(parser);
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, getPasswordInput(parser));
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    if (changePasswordUrl) {
        changePasswordUrlEntry.setValueForDomain(domainName, changePasswordUrlStr);
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry, changePasswordUrlEntry);
    printSuccessMessage(domainName, "added");
}
#end_block

#method_before
public void editDomain(CLIParser parser) throws ManageDomainsResult {
    String authMode;
    String domainName = parser.getArg(Arguments.domain.toString()).toLowerCase();
    authMode = getDomainAuthMode(domainName);
    validateKdcServers(authMode, domainName);
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    String userName = parser.getArg(Arguments.user.toString());
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLdapProviderTypeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordUrl);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(currentLdapProviderTypeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePaswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    String password = getPasswordInput(parser);
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    List<String> ldapServers = getLdapServers(parser, domainName);
    if (parser.hasArg(Arguments.ldapServers.name())) {
        setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    }
    LdapProviderType ldapProviderType = getLdapProviderType(parser);
    if (ldapProviderType != null) {
        ldapProviderTypeEntry.setValueForDomain(domainName, ldapProviderType.name());
    }
    if (parser.hasArg(Arguments.changePasswordUrl.name())) {
        changePaswordUrlEntry.setValueForDomain(domainName, getChangePasswordUrl(parser));
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypeEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry, changePaswordUrlEntry);
    printSuccessMessage(domainName, "edited");
}
#method_after
public void editDomain(CLIParser parser) throws ManageDomainsResult {
    System.out.println("editting domain");
    String authMode;
    String domainName = parser.getArg(Arguments.domain.toString()).toLowerCase();
    authMode = getDomainAuthMode(domainName);
    validateKdcServers(authMode, domainName);
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    String userName = parser.getArg(Arguments.user.toString());
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLdapProviderTypeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordUrl);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(currentLdapProviderTypeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePaswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    String password = getPasswordInput(parser);
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    List<String> ldapServers = getLdapServers(parser, domainName);
    if (parser.hasArg(Arguments.ldapServers.name())) {
        setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    }
    LdapProviderType ldapProviderType = getLdapProviderType(parser);
    if (ldapProviderType != null) {
        ldapProviderTypeEntry.setValueForDomain(domainName, ldapProviderType.name());
    }
    if (parser.hasArg(Arguments.changePasswordUrl.name())) {
        changePaswordUrlEntry.setValueForDomain(domainName, getChangePasswordUrl(parser));
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypeEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry, changePaswordUrlEntry);
    printSuccessMessage(domainName, "edited");
}
#end_block

#method_before
private void setConfigurationEntries(DomainsConfigurationEntry domainNameEntry, DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adPasswordEntry, DomainsConfigurationEntry authModeEntry, DomainsConfigurationEntry ldapServersEntry, DomainsConfigurationEntry adUserIdEntry, DomainsConfigurationEntry ldapProviderTypeEntry, DomainsConfigurationEntry changePasswordUrlEntry) throws ManageDomainsResult {
    // Update the configuration
    configurationProvider.setConfigValue(ConfigValues.AdUserName, adUserNameEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserPassword, adPasswordEntry, false);
    configurationProvider.setConfigValue(ConfigValues.LdapServers, ldapServersEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserId, adUserIdEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPSecurityAuthentication, authModeEntry);
    configurationProvider.setConfigValue(ConfigValues.DomainName, domainNameEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPProviderTypes, ldapProviderTypeEntry);
    configurationProvider.setConfigValue(ConfigValues.ChangePasswordUrl, changePasswordUrlEntry);
}
#method_after
private void setConfigurationEntries(DomainsConfigurationEntry domainNameEntry, DomainsConfigurationEntry adUserNameEntry, DomainsConfigurationEntry adPasswordEntry, DomainsConfigurationEntry authModeEntry, DomainsConfigurationEntry ldapServersEntry, DomainsConfigurationEntry adUserIdEntry, DomainsConfigurationEntry ldapProviderTypeEntry, DomainsConfigurationEntry changePasswordUrlEntry) throws ManageDomainsResult {
    // Update the configuration
    configurationProvider.setConfigValue(ConfigValues.AdUserName, adUserNameEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserPassword, adPasswordEntry, false);
    configurationProvider.setConfigValue(ConfigValues.LdapServers, ldapServersEntry);
    configurationProvider.setConfigValue(ConfigValues.AdUserId, adUserIdEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPSecurityAuthentication, authModeEntry);
    configurationProvider.setConfigValue(ConfigValues.DomainName, domainNameEntry);
    configurationProvider.setConfigValue(ConfigValues.LDAPProviderTypes, ldapProviderTypeEntry);
    if (changePasswordUrl) {
        configurationProvider.setConfigValue(ConfigValues.ChangePasswordUrl, changePasswordUrlEntry);
    }
}
#end_block

#method_before
@Test
public void canDoActionInvalidDestinationAndSourceDomainOfDifferentStorageSubtypes() {
    createParameters();
    StorageDomain srcStorageDomain = initStorageDomain(srcStorageId);
    srcStorageDomain.setStatus(StorageDomainStatus.Active);
    srcStorageDomain.setStorageType(StorageType.ISCSI);
    StorageDomain dstStorageDomain = initStorageDomain(dstStorageId);
    dstStorageDomain.setStatus(StorageDomainStatus.Active);
    srcStorageDomain.setStorageType(StorageType.NFS);
    initDiskImage(diskImageGroupId, diskImageId);
    initVm(VMStatus.Up, Guid.newGuid(), diskImageGroupId);
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DESTINATION_AND_SOURCE_STORAGE_SUB_TYPES_DIFFERENT.toString()));
}
#method_after
private void canDoActionInvalidDestinationAndSourceDomainOfDifferentStorageSubtypes(StorageType sourceType, StorageType destType, boolean shouldSucceed) {
    createParameters();
    StorageDomain srcStorageDomain = initStorageDomain(srcStorageId);
    srcStorageDomain.setStatus(StorageDomainStatus.Active);
    srcStorageDomain.setStorageType(sourceType);
    StorageDomain dstStorageDomain = initStorageDomain(dstStorageId);
    dstStorageDomain.setStatus(StorageDomainStatus.Active);
    dstStorageDomain.setStorageType(destType);
    initDiskImage(diskImageGroupId, diskImageId);
    initVm(VMStatus.Up, Guid.newGuid(), diskImageGroupId);
    assertEquals(command.canDoAction(), shouldSucceed);
    if (!shouldSucceed) {
        assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DESTINATION_AND_SOURCE_STORAGE_SUB_TYPES_DIFFERENT.toString()));
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    setStoragePoolId(getVm().getStoragePoolId());
    if (!isValidParametersList() || !checkImagesStatus() || !isValidSpaceRequirements() || !performVmRelatedChecks()) {
        return false;
    }
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        StorageDomain sourceDomain = getImageSourceDomain(parameters.getImageId());
        StorageDomain destDomain = getStorageDomainById(parameters.getStorageDomainId(), getStoragePoolId());
        getReturnValue().setCanDoAction(isDiskNotShareable(parameters.getImageId()) && isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(parameters.getImageId()) && isTemplateInDestStorageDomain(parameters.getImageId(), parameters.getStorageDomainId()) && validateSourceStorageDomain(sourceDomain) && validateDestStorage(destDomain) && validateDestStorageAndSourceStorageOfSameTypes(destDomain, sourceDomain));
        if (!getReturnValue().getCanDoAction()) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    setStoragePoolId(getVm().getStoragePoolId());
    if (!isValidParametersList() || !checkImagesStatus() || !isValidSpaceRequirements() || !performVmRelatedChecks()) {
        return false;
    }
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        getReturnValue().setCanDoAction(isDiskNotShareable(parameters.getImageId()) && isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(parameters.getImageId()) && isTemplateInDestStorageDomain(parameters.getImageId(), parameters.getStorageDomainId()) && performStorageDomainsChecks(parameters));
        if (!getReturnValue().getCanDoAction()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void clearAsyncTasksWithOutVdsmId() {
    if (getReturnValue().getTaskPlaceHolderIdList().size() > 0) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Void runInTransaction() {
                for (final Guid asyncTaskId : getReturnValue().getTaskPlaceHolderIdList()) {
                    AsyncTasks task = getAsyncTaskDao().get(asyncTaskId);
                    if (task != null && Guid.isNullOrEmpty(task.getVdsmTaskId())) {
                        AsyncTaskManager.removeTaskFromDbByTaskId(task.getTaskId());
                    }
                }
                return null;
            }
        });
    }
}
#method_after
private void clearAsyncTasksWithOutVdsmId() {
    if (!getReturnValue().getTaskPlaceHolderIdList().isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (Guid asyncTaskId : getReturnValue().getTaskPlaceHolderIdList()) {
                    AsyncTasks task = getAsyncTaskDao().get(asyncTaskId);
                    if (task != null && Guid.isNullOrEmpty(task.getVdsmTaskId())) {
                        AsyncTaskManager.removeTaskFromDbByTaskId(task.getTaskId());
                    }
                }
                return null;
            }
        });
    }
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeCapacityColumn(), constants.volumeCapacity(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<GlusterTaskSupport>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return !(value == null || value.getAsyncTask() == null);
        }
    }), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<GlusterTaskSupport>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new Column<GlusterVolumeEntity, GlusterVolumeEntity>(new VolumeCapacityCell()) {

        @Override
        public GlusterVolumeEntity getValue(GlusterVolumeEntity object) {
            return object;
        }
    }, constants.volumeCapacity(), // $NON-NLS-1$
    "60px");
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return !(value == null || value.getAsyncTask() == null);
        }
    }), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
}
#end_block

#method_before
public static int parseIntegerToShort(String value) {
    BigInteger result = DatatypeConverter.parseInteger(value);
    if (result.longValue() > Short.MAX_VALUE) {
        throw new InvalidValueException("Value " + value + " greater than Short.MAX_VALUE");
    }
    return result.intValue();
}
#method_after
public static int parseIntegerToShort(String value) {
    BigInteger result = DatatypeConverter.parseInteger(value);
    if (result.longValue() > Short.MAX_VALUE) {
        throw new InvalidValueException("Value " + value + " greater than maximum " + Short.MAX_VALUE);
    }
    return result.intValue();
}
#end_block

#method_before
public static int parseIntegerToInt(String value) {
    BigInteger result = DatatypeConverter.parseInteger(value);
    if (result.longValue() > Integer.MAX_VALUE) {
        throw new InvalidValueException("Value " + value + " greater than Integer.MAX_VALUE");
    }
    return result.intValue();
}
#method_after
public static int parseIntegerToInt(String value) {
    BigInteger result = DatatypeConverter.parseInteger(value);
    if (result.longValue() > Integer.MAX_VALUE) {
        throw new InvalidValueException("Value " + value + " greater than maximum " + Integer.MAX_VALUE);
    }
    return result.intValue();
}
#end_block

#method_before
@Override
public javax.ws.rs.core.Response toResponse(InvalidValueException e) {
    Fault fault = new Fault();
    fault.setReason("Invalid Value");
    fault.setDetail(e.getMessage());
    return Response.status(Response.Status.BAD_REQUEST).entity(fault).build();
}
#method_after
@Override
public Response toResponse(InvalidValueException e) {
    Fault fault = new Fault();
    fault.setReason("Invalid Value");
    fault.setDetail(e.getMessage());
    return Response.status(Response.Status.BAD_REQUEST).entity(fault).build();
}
#end_block

#method_before
@Override
public Object readFrom(Class<Object> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException {
    if (entityStream == null) {
        return null;
    }
    try {
        JAXBContext ctx = getFinder(mediaType).findCacheContext(mediaType, annotations, type);
        Unmarshaller unmarshaller = ctx.createUnmarshaller();
        AbstractJAXBProvider.decorateUnmarshaller(type, annotations, mediaType, unmarshaller);
        unmarshaller.setEventHandler(errorhandler);
        Object parsedObj = unmarshaller.unmarshal(entityStream);
        if (parsedObj instanceof JAXBElement) {
            return ((JAXBElement) parsedObj).getValue();
        }
        return parsedObj;
    } catch (JAXBException e) {
        if (e.getLinkedException().getCause() instanceof InvalidValueException) {
            throw (InvalidValueException) e.getLinkedException().getCause();
        }
        throw new JAXBMarshalException(e);
    }
}
#method_after
@Override
public Object readFrom(Class<Object> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException {
    if (entityStream == null) {
        return null;
    }
    try {
        JAXBContext ctx = findJAXBContext(type, annotations, mediaType, true);
        Unmarshaller unmarshaller = ctx.createUnmarshaller();
        AbstractJAXBProvider.decorateUnmarshaller(type, annotations, mediaType, unmarshaller);
        unmarshaller.setEventHandler(errorhandler);
        Object parsedObj = unmarshaller.unmarshal(entityStream);
        if (parsedObj instanceof JAXBElement) {
            return ((JAXBElement) parsedObj).getValue();
        }
        return parsedObj;
    } catch (JAXBException e) {
        if (e.getLinkedException().getCause() instanceof InvalidValueException) {
            throw (InvalidValueException) e.getLinkedException().getCause();
        }
        throw new JAXBMarshalException(e);
    }
}
#end_block

#method_before
protected void updateMigrationForLocalSD() {
    boolean isLocalSD = getModel().getSelectedDataCenter() != null && StorageType.LOCALFS.equals(getModel().getSelectedDataCenter().getStorageType());
    if (isLocalSD) {
        getModel().getIsAutoAssign().setEntity(false);
        getModel().getMigrationMode().setSelectedItem(MigrationSupport.PINNED_TO_HOST);
    }
    getModel().getIsAutoAssign().setIsChangable(!isLocalSD);
    getModel().getMigrationMode().setIsChangable(!isLocalSD);
    getModel().getDefaultHost().setIsChangable(!isLocalSD);
}
#method_after
protected void updateMigrationForLocalSD() {
    boolean isLocalSD = getModel().getSelectedDataCenter() != null && getModel().getSelectedDataCenter().isLocal();
    if (isLocalSD) {
        getModel().getIsAutoAssign().setEntity(false);
        getModel().getMigrationMode().setSelectedItem(MigrationSupport.PINNED_TO_HOST);
    }
    getModel().getIsAutoAssign().setIsChangable(!isLocalSD);
    getModel().getMigrationMode().setIsChangable(!isLocalSD);
    getModel().getDefaultHost().setIsChangable(!isLocalSD);
}
#end_block

#method_before
protected void setupTemplate(VM vm, ListModel model) {
    AsyncDataProvider.getTemplateById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            VmTemplate template = (VmTemplate) returnValue;
            model.getTemplate().setItems(new ArrayList<VmTemplate>(Arrays.asList(new VmTemplate[] { template })));
            model.getTemplate().setSelectedItem(template);
            model.getTemplate().setIsChangable(false);
            postInitTemplate();
        }
    }, getModel().getHash()), vm.getVmtGuid());
}
#method_after
protected void setupTemplate(Guid templateId, final boolean useLatest) {
    AsyncDataProvider.getTemplateById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            VmTemplate template = (VmTemplate) returnValue;
            if (useLatest) {
                template = createLatestTemplate(template);
            }
            setupBaseTemplate(template.getBaseTemplateId());
            model.getTemplate().setItems(Collections.singletonList(template));
            model.getTemplate().setSelectedItem(template);
            model.getTemplate().setIsChangable(false);
            if (!template.getId().equals(Guid.Empty)) {
                getModel().getVmInitModel().init(template);
            }
        }
    }, getModel().getHash()), templateId);
}
#end_block

#method_before
protected void updateCpuPinningVisibility() {
    if (getModel().getSelectedCluster() != null) {
        VDSGroup cluster = getModel().getSelectedCluster();
        String compatibilityVersion = cluster.getcompatibility_version().toString();
        boolean isLocalSD = getModel().getSelectedDataCenter() != null && StorageType.LOCALFS.equals(getModel().getSelectedDataCenter().getStorageType());
        // cpu pinning is available on Local SD with no consideration for auto assign value
        boolean hasCpuPinning = Boolean.FALSE.equals(getModel().getIsAutoAssign().getEntity()) || isLocalSD;
        if (Boolean.FALSE.equals(AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.CpuPinningEnabled, compatibilityVersion))) {
            hasCpuPinning = false;
        } else if (Boolean.FALSE.equals(AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.CpuPinMigrationEnabled, AsyncDataProvider.getDefaultConfigurationVersion())) && isVmMigratable() && !isLocalSD) {
            hasCpuPinning = false;
        }
        if (!hasCpuPinning) {
            if (isLocalSD) {
                getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailableLocalStorage());
            } else {
                getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailable());
            }
            getModel().getCpuPinning().setEntity("");
        }
        getModel().getCpuPinning().setIsChangable(hasCpuPinning);
    }
}
#method_after
protected void updateCpuPinningVisibility() {
    if (getModel().getSelectedCluster() != null) {
        VDSGroup cluster = getModel().getSelectedCluster();
        String compatibilityVersion = cluster.getcompatibility_version().toString();
        boolean isLocalSD = getModel().getSelectedDataCenter() != null && getModel().getSelectedDataCenter().isLocal();
        // cpu pinning is available on Local SD with no consideration for auto assign value
        boolean hasCpuPinning = Boolean.FALSE.equals(getModel().getIsAutoAssign().getEntity()) || isLocalSD;
        if (Boolean.FALSE.equals(AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.CpuPinningEnabled, compatibilityVersion))) {
            hasCpuPinning = false;
        } else if (Boolean.FALSE.equals(AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.CpuPinMigrationEnabled, AsyncDataProvider.getDefaultConfigurationVersion())) && isVmMigratable() && !isLocalSD) {
            hasCpuPinning = false;
        }
        if (!hasCpuPinning) {
            if (isLocalSD) {
                getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailableLocalStorage());
            } else {
                getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailable());
            }
            getModel().getCpuPinning().setEntity("");
        }
        getModel().getCpuPinning().setIsChangable(hasCpuPinning);
    }
}
#end_block

#method_before
public void totalCpuCoresChanged() {
    int totalCpuCores = getTotalCpuCores();
    int coresPerSocket = extractIntFromListModel(getModel().getCoresPerSocket());
    int numOfSockets = extractIntFromListModel(getModel().getNumOfSockets());
    // if incorrect value put - e.g. not an integer
    getModel().getCoresPerSocket().setIsChangable(totalCpuCores != 0);
    getModel().getNumOfSockets().setIsChangable(totalCpuCores != 0);
    if (totalCpuCores == 0) {
        return;
    }
    // if has not been yet inited, init to 1
    if (numOfSockets == 0 || coresPerSocket == 0) {
        initListToOne(getModel().getCoresPerSocket());
        initListToOne(getModel().getNumOfSockets());
        coresPerSocket = 1;
        numOfSockets = 1;
    }
    List<Integer> coresPerSocets = findIndependentPossibleValues(maxCpusPerSocket);
    List<Integer> sockets = findIndependentPossibleValues(maxNumOfSockets);
    getModel().getCoresPerSocket().setItems(filterPossibleValues(coresPerSocets, sockets));
    getModel().getNumOfSockets().setItems(filterPossibleValues(sockets, coresPerSocets));
    // and always try to set the max possible totalcpuCores
    if (totalCpuCores <= maxNumOfSockets) {
        getModel().getCoresPerSocket().setSelectedItem(1);
        getModel().getNumOfSockets().setSelectedItem(totalCpuCores);
    } else {
        // we need to compose it from more cores on the available sockets
        composeCoresAndSocketsWhenDontFitInto(totalCpuCores);
    }
    boolean isNumOfVcpusCorrect = isNumOfSocketsCorrect(totalCpuCores);
    getModel().getCoresPerSocket().setIsChangable(isNumOfVcpusCorrect);
    getModel().getNumOfSockets().setIsChangable(isNumOfVcpusCorrect);
}
#method_after
public void totalCpuCoresChanged() {
    int totalCpuCores = getTotalCpuCores();
    int coresPerSocket = extractIntFromListModel(getModel().getCoresPerSocket());
    int numOfSockets = extractIntFromListModel(getModel().getNumOfSockets());
    // if incorrect value put - e.g. not an integer
    getModel().getCoresPerSocket().setIsChangable(totalCpuCores != 0);
    getModel().getNumOfSockets().setIsChangable(totalCpuCores != 0);
    if (totalCpuCores == 0) {
        return;
    }
    // if has not been yet inited, init to 1
    if (numOfSockets == 0 || coresPerSocket == 0) {
        initListToOne(getModel().getCoresPerSocket());
        initListToOne(getModel().getNumOfSockets());
    }
    List<Integer> coresPerSocets = findIndependentPossibleValues(maxCpusPerSocket);
    List<Integer> sockets = findIndependentPossibleValues(maxNumOfSockets);
    getModel().getCoresPerSocket().setItems(filterPossibleValues(coresPerSocets, sockets));
    getModel().getNumOfSockets().setItems(filterPossibleValues(sockets, coresPerSocets));
    // and always try to set the max possible totalcpuCores
    if (totalCpuCores <= maxNumOfSockets) {
        getModel().getCoresPerSocket().setSelectedItem(1);
        getModel().getNumOfSockets().setSelectedItem(totalCpuCores);
    } else {
        // we need to compose it from more cores on the available sockets
        composeCoresAndSocketsWhenDontFitInto(totalCpuCores);
    }
    boolean isNumOfVcpusCorrect = isNumOfSocketsCorrect(totalCpuCores);
    getModel().getCoresPerSocket().setIsChangable(isNumOfVcpusCorrect);
    getModel().getNumOfSockets().setIsChangable(isNumOfVcpusCorrect);
}
#end_block

#method_before
private void composeCoresAndSocketsWhenDontFitInto(int totalCpuCores) {
    List<Integer> possibleSockets = findIndependentPossibleValues(maxNumOfSockets);
    List<Integer> possibleCoresPerSocket = findIndependentPossibleValues(maxCpusPerSocket);
    // the more sockets I can use, the better
    Collections.reverse(possibleSockets);
    for (Integer socket : possibleSockets) {
        for (Integer coresPerSocket : possibleCoresPerSocket) {
            if (socket * coresPerSocket == totalCpuCores) {
                getModel().getCoresPerSocket().setSelectedItem(coresPerSocket);
                getModel().getNumOfSockets().setSelectedItem(socket);
                return;
            }
        }
    }
}
#method_after
protected void composeCoresAndSocketsWhenDontFitInto(int totalCpuCores) {
    List<Integer> possibleSockets = findIndependentPossibleValues(maxNumOfSockets);
    List<Integer> possibleCoresPerSocket = findIndependentPossibleValues(maxCpusPerSocket);
    // the more sockets I can use, the better
    Collections.reverse(possibleSockets);
    for (Integer socket : possibleSockets) {
        for (Integer coresPerSocket : possibleCoresPerSocket) {
            if (socket * coresPerSocket == totalCpuCores) {
                getModel().getCoresPerSocket().setSelectedItem(coresPerSocket);
                getModel().getNumOfSockets().setSelectedItem(socket);
                return;
            }
        }
    }
}
#end_block

#method_before
private int extractIntFromListModel(ListModel model) {
    return model.getSelectedItem() != null ? Integer.parseInt(model.getSelectedItem().toString()) : 0;
}
#method_after
protected int extractIntFromListModel(ListModel model) {
    return model.getSelectedItem() != null ? Integer.parseInt(model.getSelectedItem().toString()) : 0;
}
#end_block

#method_before
private List<Integer> findIndependentPossibleValues(int max) {
    List<Integer> res = new ArrayList<Integer>();
    int totalCPUCores = getTotalCpuCores();
    for (int i = 1; i <= Math.min(totalCPUCores, max); i++) {
        if (totalCPUCores % i == 0) {
            res.add(i);
        }
    }
    return res;
}
#method_after
protected List<Integer> findIndependentPossibleValues(int max) {
    List<Integer> res = new ArrayList<Integer>();
    int totalCPUCores = getTotalCpuCores();
    for (int i = 1; i <= Math.min(totalCPUCores, max); i++) {
        if (totalCPUCores % i == 0) {
            res.add(i);
        }
    }
    return res;
}
#end_block

#method_before
private List<Integer> filterPossibleValues(List<Integer> candidates, List<Integer> others) {
    List<Integer> res = new ArrayList<Integer>();
    int currentCpusCores = getTotalCpuCores();
    for (Integer candidate : candidates) {
        for (Integer other : others) {
            if (candidate * other == currentCpusCores) {
                res.add(candidate);
                break;
            }
        }
    }
    return res;
}
#method_after
protected List<Integer> filterPossibleValues(List<Integer> candidates, List<Integer> others) {
    List<Integer> res = new ArrayList<Integer>();
    int currentCpusCores = getTotalCpuCores();
    for (Integer candidate : candidates) {
        for (Integer other : others) {
            if (candidate * other == currentCpusCores) {
                res.add(candidate);
                break;
            }
        }
    }
    return res;
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getVmType().setIsChangable(true);
    AsyncDataProvider.getDataCenterByClusterServiceList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final ArrayList<StoragePool> dataCenters = new ArrayList<StoragePool>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (!dataCenters.isEmpty()) {
                AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        model.setDataCentersAndClusters(model, dataCenters, (List<VDSGroup>) returnValue, null);
                        initCdImage();
                    }
                }, getModel().getHash()), true, false);
            } else {
                getModel().disableEditing(ConstantsManager.getInstance().getConstants().notAvailableWithNoUpDC());
            }
        }
    }, getModel().getHash()), true, false);
    initPriority(0);
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getVmType().setIsChangable(true);
    AsyncDataProvider.getDataCenterByClusterServiceList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final ArrayList<StoragePool> dataCenters = new ArrayList<StoragePool>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (!dataCenters.isEmpty()) {
                AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        List<VDSGroup> clusterList = (List<VDSGroup>) returnValue;
                        List<VDSGroup> filteredClusterList = AsyncDataProvider.filterClustersWithoutArchitecture(clusterList);
                        model.setDataCentersAndClusters(model, dataCenters, filteredClusterList, null);
                        initCdImage();
                    }
                }, getModel().getHash()), true, false);
            } else {
                getModel().disableEditing(ConstantsManager.getInstance().getConstants().notAvailableWithNoUpDC());
            }
        }
    }, getModel().getHash()), true, false);
    initPriority(0);
    getModel().getVmInitModel().init(null);
}
#end_block

#method_before
@Override
public void template_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    if (template != null) {
        // If this a blank template, use the proper value for the default OS
        if (template.getId().equals(Guid.Empty)) {
            List<Integer> osIds = (List<Integer>) getModel().getOSType().getItems();
            if (!osIds.isEmpty()) {
                getModel().getOSType().setSelectedItem(Collections.min(osIds));
            }
        } else {
            getModel().getOSType().setSelectedItem(template.getOsId());
        }
        getModel().getTotalCPUCores().setEntity(Integer.toString(template.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(template.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(template.getNumOfMonitors());
        getModel().getIsSingleQxlEnabled().setEntity(template.getSingleQxlPci());
        getModel().getDomain().setSelectedItem(template.getDomain());
        getModel().getMemSize().setEntity(template.getMemSizeMb());
        getModel().setBootSequence(template.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(template.isAutoStartup());
        updateHostPinning(template.getMigrationSupport());
        doChangeDefautlHost(template.getDedicatedVmForVds());
        getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
        getModel().selectSsoMethod(template.getSsoMethod());
        getModel().getIsStateless().setEntity(template.isStateless());
        boolean hasCd = !StringHelper.isNullOrEmpty(template.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(template.getIsoPath());
        }
        updateConsoleDevice(template.getId());
        updateVirtioScsiEnabled(template.getId(), template.getOsId());
        updateTimeZone(template.getTimeZone());
        // Update domain list
        updateDomain();
        // Update display protocol selected item
        EntityModel<DisplayType> displayProtocol = null;
        boolean isFirst = true;
        for (EntityModel<DisplayType> item : getModel().getDisplayProtocol().getItems()) {
            if (isFirst) {
                displayProtocol = item;
                isFirst = false;
            }
            DisplayType dt = item.getEntity();
            if (dt == template.getDefaultDisplayType()) {
                displayProtocol = item;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        getModel().getUsbPolicy().setSelectedItem(template.getUsbPolicy());
        getModel().getVncKeyboardLayout().setSelectedItem(template.getVncKeyboardLayout());
        getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(template.getKernelUrl());
        getModel().getKernel_parameters().setEntity(template.getKernelParams());
        getModel().getInitrd_path().setEntity(template.getInitrdUrl());
        if (!template.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().getProvisioning().setIsChangable(true);
            getModel().getVmType().setSelectedItem(template.getVmType());
            getModel().setIsBlankTemplate(false);
            getModel().getCopyPermissions().setIsAvailable(true);
            getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
            initDisks();
            initSoundCard(template.getId());
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().getProvisioning().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().getCopyPermissions().setIsAvailable(false);
            getModel().setDisks(null);
        }
        initPriority(template.getPriority());
        initStorageDomains();
        // use min. allocated memory from the template, if specified
        if (template.getMinAllocatedMem() == 0) {
            updateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(template.getMinAllocatedMem());
        }
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
        updateNetworkInterfacesByTemplate(template);
    }
}
#method_after
@Override
public void template_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    if (template != null) {
        // If this a blank template, use the proper value for the default OS
        if (template.getId().equals(Guid.Empty)) {
            Integer osId = AsyncDataProvider.getDefaultOs(getModel().getSelectedCluster().getArchitecture());
            if (osId != null) {
                setSelectedOSById(osId.intValue());
            }
        } else {
            setSelectedOSById(template.getOsId());
        }
        getModel().getTotalCPUCores().setEntity(Integer.toString(template.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(template.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(template.getNumOfMonitors());
        getModel().getIsSingleQxlEnabled().setEntity(template.getSingleQxlPci());
        getModel().getMemSize().setEntity(template.getMemSizeMb());
        getModel().setBootSequence(template.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(template.isAutoStartup());
        updateHostPinning(template.getMigrationSupport());
        doChangeDefautlHost(template.getDedicatedVmForVds());
        getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
        getModel().selectSsoMethod(template.getSsoMethod());
        getModel().setSelectedMigrationDowntime(template.getMigrationDowntime());
        getModel().getIsStateless().setEntity(template.isStateless());
        boolean hasCd = !StringHelper.isNullOrEmpty(template.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(template.getIsoPath());
        }
        updateConsoleDevice(template.getId());
        updateVirtioScsiEnabled(template.getId(), template.getOsId());
        updateTimeZone(template.getTimeZone());
        // Update domain list
        updateDomain();
        // Update display protocol selected item
        EntityModel<DisplayType> displayProtocol = null;
        boolean isFirst = true;
        for (EntityModel<DisplayType> item : getModel().getDisplayProtocol().getItems()) {
            if (isFirst) {
                displayProtocol = item;
                isFirst = false;
            }
            DisplayType dt = item.getEntity();
            if (dt == template.getDefaultDisplayType()) {
                displayProtocol = item;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        getModel().getUsbPolicy().setSelectedItem(template.getUsbPolicy());
        getModel().getVncKeyboardLayout().setSelectedItem(template.getVncKeyboardLayout());
        getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(template.getKernelUrl());
        getModel().getKernel_parameters().setEntity(template.getKernelParams());
        getModel().getInitrd_path().setEntity(template.getInitrdUrl());
        if (!template.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().getProvisioning().setIsChangable(true);
            getModel().getVmType().setSelectedItem(template.getVmType());
            getModel().setIsBlankTemplate(false);
            getModel().getCopyPermissions().setIsAvailable(true);
            getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
            initDisks();
            initSoundCard(template.getId());
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().getProvisioning().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().getCopyPermissions().setIsAvailable(false);
            getModel().setDisks(null);
        }
        initPriority(template.getPriority());
        initStorageDomains();
        // use min. allocated memory from the template, if specified
        if (template.getMinAllocatedMem() == 0) {
            updateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(template.getMinAllocatedMem());
        }
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
        updateNetworkInterfacesByTemplate(template);
        getModel().getVmInitModel().init(template);
        getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
    }
}
#end_block

#method_before
private void updateTemplate() {
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    // Filter according to system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        StorageDomain storage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        AsyncDataProvider.getTemplateListByDataCenter(new AsyncQuery(new Object[] { this, storage }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target1, Object returnValue1) {
                Object[] array1 = (Object[]) target1;
                NewVmModelBehavior behavior1 = (NewVmModelBehavior) array1[0];
                StorageDomain storage1 = (StorageDomain) array1[1];
                AsyncDataProvider.getTemplateListByStorage(new AsyncQuery(new Object[] { behavior1, returnValue1 }, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target2, Object returnValue2) {
                        Object[] array2 = (Object[]) target2;
                        NewVmModelBehavior behavior2 = (NewVmModelBehavior) array2[0];
                        ArrayList<VmTemplate> templatesByDataCenter = (ArrayList<VmTemplate>) array2[1];
                        ArrayList<VmTemplate> templatesByStorage = (ArrayList<VmTemplate>) returnValue2;
                        VmTemplate blankTemplate = Linq.firstOrDefault(templatesByDataCenter, new Linq.TemplatePredicate(Guid.Empty));
                        if (blankTemplate != null) {
                            templatesByStorage.add(0, blankTemplate);
                        }
                        behavior2.postInitTemplate((ArrayList<VmTemplate>) returnValue2);
                    }
                }), storage1.getId());
            }
        }, getModel().getHash()), dataCenter.getId());
    } else {
        AsyncDataProvider.getTemplateListByDataCenter(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                NewVmModelBehavior behavior = (NewVmModelBehavior) target;
                behavior.postInitTemplate((ArrayList<VmTemplate>) returnValue);
            }
        }, getModel().getHash()), dataCenter.getId());
    }
}
#method_after
private void updateTemplate() {
    final DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getModel().getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    // Filter according to system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        StorageDomain storage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        AsyncDataProvider.getTemplateListByDataCenter(new AsyncQuery(new Object[] { this, storage }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target1, Object returnValue1) {
                Object[] array1 = (Object[]) target1;
                NewVmModelBehavior behavior1 = (NewVmModelBehavior) array1[0];
                StorageDomain storage1 = (StorageDomain) array1[1];
                AsyncDataProvider.getTemplateListByStorage(new AsyncQuery(new Object[] { behavior1, returnValue1 }, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target2, Object returnValue2) {
                        Object[] array2 = (Object[]) target2;
                        NewVmModelBehavior behavior2 = (NewVmModelBehavior) array2[0];
                        List<VmTemplate> templatesByDataCenter = (List<VmTemplate>) array2[1];
                        List<VmTemplate> templatesByStorage = (List<VmTemplate>) returnValue2;
                        VmTemplate blankTemplate = Linq.firstOrDefault(templatesByDataCenter, new Linq.TemplatePredicate(Guid.Empty));
                        if (blankTemplate != null) {
                            templatesByStorage.add(0, blankTemplate);
                        }
                        List<VmTemplate> templateList = AsyncDataProvider.filterTemplatesByArchitecture(templatesByStorage, dataCenterWithCluster.getCluster().getArchitecture());
                        behavior2.postInitTemplate(templateList);
                    }
                }), storage1.getId());
            }
        }, getModel().getHash()), dataCenter.getId());
    } else {
        AsyncDataProvider.getTemplateListByDataCenter(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                NewVmModelBehavior behavior = (NewVmModelBehavior) target;
                List<VmTemplate> templates = (List<VmTemplate>) returnValue;
                behavior.postInitTemplate(AsyncDataProvider.filterTemplatesByArchitecture(templates, dataCenterWithCluster.getCluster().getArchitecture()));
            }
        }, getModel().getHash()), dataCenter.getId());
    }
}
#end_block

#method_before
private void postInitTemplate(ArrayList<VmTemplate> templates) {
    // If there was some template selected before, try select it again.
    VmTemplate oldTemplate = getModel().getTemplate().getSelectedItem();
    getModel().getTemplate().setItems(templates);
    getModel().getTemplate().setSelectedItem(Linq.firstOrDefault(templates, oldTemplate != null ? new Linq.TemplatePredicate(oldTemplate.getId()) : new Linq.TemplatePredicate(Guid.Empty)));
    updateIsDisksAvailable();
}
#method_after
private void postInitTemplate(List<VmTemplate> templates) {
    List<VmTemplate> baseTemplates = filterNotBaseTemplates(templates);
    // If there was some template selected before, try select it again.
    VmTemplate prevBaseTemplate = getModel().getBaseTemplate().getSelectedItem();
    getModel().getBaseTemplate().setItems(baseTemplates);
    getModel().getBaseTemplate().setSelectedItem(Linq.firstOrDefault(baseTemplates, new Linq.TemplatePredicate(prevBaseTemplate != null ? prevBaseTemplate.getId() : Guid.Empty)));
    updateIsDisksAvailable();
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getTemplate().setIsChangable(false);
    getModel().getProvisioning().setIsChangable(false);
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getVmType().setIsChangable(true);
    if (template.getStoragePoolId() != null && !template.getStoragePoolId().equals(Guid.Empty)) {
        AsyncDataProvider.getDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                final StoragePool dataCenter = (StoragePool) returnValue;
                AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
                        ArrayList<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
                        // filter clusters supporting virt service only
                        for (VDSGroup cluster : clusters) {
                            if (cluster.supportsVirtService()) {
                                filteredClusters.add(cluster);
                            }
                        }
                        model.setDataCentersAndClusters(model, new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCenter })), filteredClusters, template.getVdsGroupId());
                        AsyncDataProvider.isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                                initTemplate();
                                initCdImage();
                            }
                        }), template.getId());
                    }
                }, getModel().getHash()), true, false);
            }
        }, getModel().getHash()), template.getStoragePoolId());
    }
    AsyncDataProvider.getWatchdogByVmId(new AsyncQuery(this.getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            for (VmWatchdog watchdog : watchdogs) {
                model.getWatchdogAction().setSelectedItem(watchdog.getAction().name().toLowerCase());
                model.getWatchdogModel().setSelectedItem(watchdog.getModel().name());
            }
        }
    }), template.getId());
    getModel().getMigrationMode().setSelectedItem(template.getMigrationSupport());
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getTemplate().setIsChangable(false);
    getModel().getBaseTemplate().setIsChangable(false);
    getModel().getProvisioning().setIsChangable(false);
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getVmType().setIsChangable(true);
    if (template.getStoragePoolId() != null && !template.getStoragePoolId().equals(Guid.Empty)) {
        AsyncDataProvider.getDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                final StoragePool dataCenter = (StoragePool) returnValue;
                AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
                        ArrayList<VDSGroup> clustersSupportingVirt = new ArrayList<VDSGroup>();
                        // filter clusters supporting virt service only
                        for (VDSGroup cluster : clusters) {
                            if (cluster.supportsVirtService()) {
                                clustersSupportingVirt.add(cluster);
                            }
                        }
                        List<VDSGroup> filteredClusters = AsyncDataProvider.filterByArchitecture(clustersSupportingVirt, template.getClusterArch());
                        model.setDataCentersAndClusters(model, new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCenter })), filteredClusters, template.getVdsGroupId());
                        AsyncDataProvider.isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                                initTemplate();
                                initCdImage();
                            }
                        }), template.getId());
                    }
                }, getModel().getHash()), true, false);
            }
        }, getModel().getHash()), template.getStoragePoolId());
    }
    AsyncDataProvider.getWatchdogByVmId(new AsyncQuery(this.getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            for (VmWatchdog watchdog : watchdogs) {
                model.getWatchdogAction().setSelectedItem(watchdog.getAction().name().toLowerCase());
                model.getWatchdogModel().setSelectedItem(watchdog.getModel().name());
            }
        }
    }), template.getId());
    getModel().getMigrationMode().setSelectedItem(template.getMigrationSupport());
    setupBaseTemplate(template.getBaseTemplateId());
}
#end_block

#method_before
private void initTemplate() {
    // Update model state according to VM properties.
    getModel().getName().setEntity(this.template.getName());
    getModel().getDescription().setEntity(this.template.getDescription());
    getModel().getComment().setEntity(this.template.getComment());
    getModel().getMinAllocatedMemory().setEntity(this.template.getMinAllocatedMem());
    getModel().getMinAllocatedMemory().setIsChangable(false);
    getModel().getMemSize().setEntity(this.template.getMemSizeMb());
    getModel().getOSType().setSelectedItem(this.template.getOsId());
    getModel().getDomain().setSelectedItem(this.template.getDomain());
    getModel().getUsbPolicy().setSelectedItem(this.template.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(this.template.getNumOfMonitors());
    getModel().getAllowConsoleReconnect().setEntity(this.template.isAllowConsoleReconnect());
    getModel().setBootSequence(this.template.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(this.template.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(this.template.getNumOfCpus()));
    getModel().getNumOfSockets().setSelectedItem(this.template.getNumOfSockets());
    getModel().getIsStateless().setEntity(this.template.isStateless());
    getModel().getIsRunAndPause().setEntity(this.template.isRunAndPause());
    getModel().getIsDeleteProtected().setEntity(this.template.isDeleteProtected());
    getModel().selectSsoMethod(this.template.getSsoMethod());
    getModel().getIsSmartcardEnabled().setEntity(this.template.isSmartcardEnabled());
    getModel().getVncKeyboardLayout().setSelectedItem(this.template.getVncKeyboardLayout());
    getModel().getKernel_parameters().setEntity(this.template.getKernelParams());
    getModel().getKernel_path().setEntity(this.template.getKernelUrl());
    getModel().getInitrd_path().setEntity(this.template.getInitrdUrl());
    getModel().getIsSingleQxlEnabled().setEntity(this.template.getSingleQxlPci());
    updateTimeZone(template.getTimeZone());
    // Update domain list
    updateDomain();
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == this.template.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    updateConsoleDevice(template.getId());
    initPriority(this.template.getPriority());
}
#method_after
private void initTemplate() {
    // Update model state according to VM properties.
    getModel().getName().setEntity(template.getName());
    getModel().getDescription().setEntity(template.getDescription());
    getModel().getComment().setEntity(template.getComment());
    getModel().getMinAllocatedMemory().setEntity(template.getMinAllocatedMem());
    getModel().getMinAllocatedMemory().setIsChangable(false);
    getModel().getMemSize().setEntity(template.getMemSizeMb());
    getModel().getOSType().setSelectedItem(template.getOsId());
    getModel().getUsbPolicy().setSelectedItem(template.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(template.getNumOfMonitors());
    getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
    getModel().setBootSequence(template.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(template.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(template.getNumOfCpus()));
    getModel().getNumOfSockets().setSelectedItem(template.getNumOfSockets());
    getModel().getIsStateless().setEntity(template.isStateless());
    getModel().getIsRunAndPause().setEntity(template.isRunAndPause());
    getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
    getModel().selectSsoMethod(template.getSsoMethod());
    getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
    getModel().getVncKeyboardLayout().setSelectedItem(template.getVncKeyboardLayout());
    getModel().setSelectedMigrationDowntime(template.getMigrationDowntime());
    getModel().getKernel_parameters().setEntity(template.getKernelParams());
    getModel().getKernel_path().setEntity(template.getKernelUrl());
    getModel().getInitrd_path().setEntity(template.getInitrdUrl());
    getModel().getIsSingleQxlEnabled().setEntity(template.getSingleQxlPci());
    updateTimeZone(template.getTimeZone());
    // Update domain list
    updateDomain();
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == template.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    updateConsoleDevice(template.getId());
    getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
    getModel().getVmInitModel().init(template);
    initPriority(template.getPriority());
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getTemplate().setIsChangable(false);
    getModel().getVmType().setIsChangable(true);
    getModel().getCopyPermissions().setIsAvailable(true);
    DisksAllocationModel disksAllocationModel = getModel().getDisksAllocationModel();
    disksAllocationModel.setIsAliasChangable(true);
    AsyncDataProvider.getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final StoragePool dataCenter = (StoragePool) returnValue;
            if (dataCenter == null) {
                disableNewTemplateModel(ConstantsManager.getInstance().getConstants().dataCenterIsNotAccessibleMsg());
            } else {
                AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
                        model.setDataCentersAndClusters(model, Arrays.asList(dataCenter), clusters, vm.getVdsGroupId());
                        initTemplate();
                    }
                }, getModel().getHash()), true, false);
                AsyncDataProvider.isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                    }
                }, getModel().getHash()), vm.getId());
            }
        }
    }, getModel().getHash()), vm.getStoragePoolId());
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmInitEnabled().setEntity(vm.getVmInit() != null);
    getModel().getVmInitModel().init(vm.getStaticData());
    getModel().getTemplate().setIsChangable(false);
    getModel().getVmType().setIsChangable(true);
    getModel().getCopyPermissions().setIsAvailable(true);
    DisksAllocationModel disksAllocationModel = getModel().getDisksAllocationModel();
    disksAllocationModel.setIsAliasChangable(true);
    AsyncDataProvider.getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final StoragePool dataCenter = (StoragePool) returnValue;
            if (dataCenter == null) {
                disableNewTemplateModel(ConstantsManager.getInstance().getConstants().dataCenterIsNotAccessibleMsg());
            } else {
                AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
                        List<VDSGroup> filteredClusters = AsyncDataProvider.filterByArchitecture(clusters, vm.getClusterArch());
                        model.setDataCentersAndClusters(model, Arrays.asList(dataCenter), filteredClusters, vm.getVdsGroupId());
                        initTemplate();
                    }
                }, getModel().getHash()), true, false);
                AsyncDataProvider.isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                    }
                }, getModel().getHash()), vm.getId());
            }
        }
    }, getModel().getHash()), vm.getStoragePoolId());
}
#end_block

#method_before
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateQuotaByCluster(null, null);
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
    updateOSValues();
}
#method_after
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateQuotaByCluster(null, null);
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
    updateOSValues();
    updateTemplate();
}
#end_block

#method_before
private void initTemplate() {
    // Update model state according to VM properties.
    getModel().getMemSize().setEntity(this.vm.getVmMemSizeMb());
    getModel().getMinAllocatedMemory().setEntity(this.vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(this.vm.getVmOsId());
    getModel().getDomain().setSelectedItem(this.vm.getVmDomain());
    getModel().getNumOfMonitors().setSelectedItem(this.vm.getNumOfMonitors());
    getModel().getAllowConsoleReconnect().setEntity(this.vm.getAllowConsoleReconnect());
    getModel().setBootSequence(this.vm.getDefaultBootSequence());
    getModel().getTotalCPUCores().setEntity(Integer.toString(this.vm.getNumOfCpus()));
    getModel().getNumOfSockets().setSelectedItem(this.vm.getNumOfSockets());
    getModel().getIsStateless().setEntity(this.vm.isStateless());
    getModel().getIsRunAndPause().setEntity(this.vm.isRunAndPause());
    getModel().getIsDeleteProtected().setEntity(this.vm.isDeleteProtected());
    getModel().selectSsoMethod(this.vm.getSsoMethod());
    updateSelectedCdImage(this.vm.getStaticData());
    updateTimeZone(this.vm.getTimeZone());
    updateConsoleDevice(this.vm.getId());
    // Update domain list
    updateDomain();
    getModel().getStorageDomain().setIsChangable(true);
    getModel().getProvisioning().setIsAvailable(false);
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == this.vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    getModel().getUsbPolicy().setSelectedItem(this.vm.getUsbPolicy());
    getModel().getIsSmartcardEnabled().setEntity(this.vm.isSmartcardEnabled());
    getModel().getVncKeyboardLayout().setSelectedItem(this.vm.getVncKeyboardLayout());
    initPriority(this.vm.getPriority());
}
#method_after
private void initTemplate() {
    // Update model state according to VM properties.
    getModel().getMemSize().setEntity(this.vm.getVmMemSizeMb());
    getModel().getMinAllocatedMemory().setEntity(this.vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(this.vm.getVmOsId());
    getModel().getNumOfMonitors().setSelectedItem(this.vm.getNumOfMonitors());
    getModel().getAllowConsoleReconnect().setEntity(this.vm.getAllowConsoleReconnect());
    getModel().setBootSequence(this.vm.getDefaultBootSequence());
    getModel().getTotalCPUCores().setEntity(Integer.toString(this.vm.getNumOfCpus()));
    getModel().getNumOfSockets().setSelectedItem(this.vm.getNumOfSockets());
    getModel().getIsStateless().setEntity(this.vm.isStateless());
    getModel().getIsRunAndPause().setEntity(this.vm.isRunAndPause());
    getModel().getIsDeleteProtected().setEntity(this.vm.isDeleteProtected());
    getModel().selectSsoMethod(this.vm.getSsoMethod());
    updateSelectedCdImage(this.vm.getStaticData());
    updateTimeZone(this.vm.getTimeZone());
    updateConsoleDevice(this.vm.getId());
    // Update domain list
    updateDomain();
    getModel().getStorageDomain().setIsChangable(true);
    getModel().getProvisioning().setIsAvailable(false);
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == this.vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    getModel().getUsbPolicy().setSelectedItem(this.vm.getUsbPolicy());
    getModel().getIsSmartcardEnabled().setEntity(this.vm.isSmartcardEnabled());
    getModel().getVncKeyboardLayout().setSelectedItem(this.vm.getDefaultVncKeyboardLayout());
    getModel().setSelectedMigrationDowntime(this.vm.getMigrationDowntime());
    initPriority(this.vm.getPriority());
}
#end_block

#method_before
protected void postDataCentersLoaded(final List<StoragePool> dataCenters) {
    AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            model.setDataCentersAndClusters(model, dataCenters, (List<VDSGroup>) returnValue, null);
            initCdImage();
            getPoolModelBehaviorInitializedEvent().raise(this, EventArgs.Empty);
        }
    }, getModel().getHash()), true, false);
}
#method_after
protected void postDataCentersLoaded(final List<StoragePool> dataCenters) {
    AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
            List<VDSGroup> filteredClusters = filterClusters(clusters);
            model.setDataCentersAndClusters(model, dataCenters, filteredClusters, null);
            initCdImage();
            getPoolModelBehaviorInitializedEvent().raise(this, EventArgs.EMPTY);
        }
    }, getModel().getHash()), true, false);
}
#end_block

#method_before
protected void setupWindowModelFrom(VmBase vmBase) {
    if (vmBase != null) {
        updateQuotaByCluster(vmBase.getQuotaId(), vmBase.getQuotaName());
        // Copy VM parameters from template.
        getModel().getOSType().setSelectedItem(vmBase.getOsId());
        getModel().getTotalCPUCores().setEntity(Integer.toString(vmBase.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(vmBase.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(vmBase.getNumOfMonitors());
        getModel().getIsSingleQxlEnabled().setEntity(vmBase.getSingleQxlPci());
        getModel().getDomain().setSelectedItem(vmBase.getDomain());
        getModel().getMemSize().setEntity(vmBase.getMemSizeMb());
        getModel().setBootSequence(vmBase.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(vmBase.isAutoStartup());
        getModel().getIsDeleteProtected().setEntity(vmBase.isDeleteProtected());
        getModel().selectSsoMethod(vmBase.getSsoMethod());
        getModel().getIsRunAndPause().setEntity(false);
        boolean hasCd = !StringHelper.isNullOrEmpty(vmBase.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(vmBase.getIsoPath());
        }
        updateTimeZone(vmBase.getTimeZone());
        updateConsoleDevice(vmBase.getId());
        updateVirtioScsiEnabled(vmBase.getId(), vmBase.getOsId());
        // Update domain list
        updateDomain();
        // Update display protocol selected item
        EntityModel<DisplayType> displayProtocol = null;
        boolean isFirst = true;
        for (EntityModel<DisplayType> item : getModel().getDisplayProtocol().getItems()) {
            if (isFirst) {
                displayProtocol = item;
                isFirst = false;
            }
            DisplayType dt = item.getEntity();
            if (dt == extractDisplayType(vmBase)) {
                displayProtocol = item;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        getModel().getUsbPolicy().setSelectedItem(vmBase.getUsbPolicy());
        getModel().getVncKeyboardLayout().setSelectedItem(vmBase.getVncKeyboardLayout());
        getModel().getIsSmartcardEnabled().setEntity(vmBase.isSmartcardEnabled());
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(vmBase.getKernelUrl());
        getModel().getKernel_parameters().setEntity(vmBase.getKernelParams());
        getModel().getInitrd_path().setEntity(vmBase.getInitrdUrl());
        if (!vmBase.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            initDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        getModel().getProvisioning().setEntity(false);
        initPriority(vmBase.getPriority());
        initStorageDomains();
        // use min. allocated memory from the template, if specified
        if (vmBase.getMinAllocatedMem() == 0) {
            updateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(vmBase.getMinAllocatedMem());
        }
        initSoundCard(vmBase.getId());
        getModel().getAllowConsoleReconnect().setEntity(vmBase.isAllowConsoleReconnect());
    }
}
#method_after
protected void setupWindowModelFrom(VmBase vmBase) {
    if (vmBase != null) {
        updateQuotaByCluster(vmBase.getQuotaId(), vmBase.getQuotaName());
        // Copy VM parameters from template.
        getModel().getOSType().setSelectedItem(vmBase.getOsId());
        getModel().getTotalCPUCores().setEntity(Integer.toString(vmBase.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(vmBase.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(vmBase.getNumOfMonitors());
        getModel().getIsSingleQxlEnabled().setEntity(vmBase.getSingleQxlPci());
        getModel().getMemSize().setEntity(vmBase.getMemSizeMb());
        getModel().setBootSequence(vmBase.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(vmBase.isAutoStartup());
        getModel().getIsDeleteProtected().setEntity(vmBase.isDeleteProtected());
        getModel().selectSsoMethod(vmBase.getSsoMethod());
        getModel().getIsRunAndPause().setEntity(false);
        boolean hasCd = !StringHelper.isNullOrEmpty(vmBase.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(vmBase.getIsoPath());
        }
        updateTimeZone(vmBase.getTimeZone());
        updateConsoleDevice(vmBase.getId());
        updateVirtioScsiEnabled(vmBase.getId(), vmBase.getOsId());
        // Update domain list
        updateDomain();
        // Update display protocol selected item
        EntityModel<DisplayType> displayProtocol = null;
        boolean isFirst = true;
        for (EntityModel<DisplayType> item : getModel().getDisplayProtocol().getItems()) {
            if (isFirst) {
                displayProtocol = item;
                isFirst = false;
            }
            DisplayType dt = item.getEntity();
            if (dt == extractDisplayType(vmBase)) {
                displayProtocol = item;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        getModel().getUsbPolicy().setSelectedItem(vmBase.getUsbPolicy());
        getModel().getVncKeyboardLayout().setSelectedItem(vmBase.getVncKeyboardLayout());
        getModel().getIsSmartcardEnabled().setEntity(vmBase.isSmartcardEnabled());
        getModel().setSelectedMigrationDowntime(vmBase.getMigrationDowntime());
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(vmBase.getKernelUrl());
        getModel().getKernel_parameters().setEntity(vmBase.getKernelParams());
        getModel().getInitrd_path().setEntity(vmBase.getInitrdUrl());
        if (!vmBase.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            initDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        getModel().getProvisioning().setEntity(false);
        initPriority(vmBase.getPriority());
        initStorageDomains();
        // use min. allocated memory from the template, if specified
        if (vmBase.getMinAllocatedMem() == 0) {
            updateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(vmBase.getMinAllocatedMem());
        }
        initSoundCard(vmBase.getId());
        getModel().getAllowConsoleReconnect().setEntity(vmBase.isAllowConsoleReconnect());
        getModel().getVmInitModel().init(vmBase);
        getModel().getVmInitEnabled().setEntity(vmBase.getVmInit() != null);
    }
}
#end_block

#method_before
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateDefaultHost();
    updateCustomPropertySheet();
    updateMinAllocatedMemory();
    updateNumOfSockets();
    updateOSValues();
    if (getModel().getTemplate().getSelectedItem() != null) {
        VmTemplate template = getModel().getTemplate().getSelectedItem();
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
    }
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
    updateTemplate();
}
#method_after
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateDefaultHost();
    updateCustomPropertySheet();
    updateMinAllocatedMemory();
    updateNumOfSockets();
    updateOSValues();
    if (getModel().getTemplate().getSelectedItem() != null) {
        VmTemplate template = getModel().getTemplate().getSelectedItem();
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
    }
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        getDomain().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        getDomain().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && StringHelper.stringsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && StringHelper.stringsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            updateDisplayProtocol();
            initUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        }
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && StringHelper.stringsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && StringHelper.stringsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            initUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        }
    }
}
#end_block

#method_before
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
    updateWatchdogModels(osType);
}
#method_after
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
    updateWatchdogModels(osType);
    vmInitEnabledChanged();
}
#end_block

#method_before
protected void setupDataCenterWithClusters(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    Map<Guid, List<VDSGroup>> dataCenterToCluster = new HashMap<Guid, List<VDSGroup>>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getStoragePoolId() == null) {
            continue;
        }
        if (!dataCenterToCluster.containsKey(cluster.getStoragePoolId())) {
            dataCenterToCluster.put(cluster.getStoragePoolId(), new ArrayList<VDSGroup>());
        }
        dataCenterToCluster.get(cluster.getStoragePoolId()).add(cluster);
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (StoragePool dataCenter : dataCenters) {
        for (VDSGroup cluster : dataCenterToCluster.get(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#method_after
protected void setupDataCenterWithClusters(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    Map<Guid, List<VDSGroup>> dataCenterToCluster = new HashMap<Guid, List<VDSGroup>>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getStoragePoolId() == null) {
            continue;
        }
        if (!dataCenterToCluster.containsKey(cluster.getStoragePoolId())) {
            dataCenterToCluster.put(cluster.getStoragePoolId(), new ArrayList<VDSGroup>());
        }
        dataCenterToCluster.get(cluster.getStoragePoolId()).add(cluster);
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (StoragePool dataCenter : dataCenters) {
        if (dataCenterToCluster.containsKey(dataCenter.getId())) {
            for (VDSGroup cluster : dataCenterToCluster.get(dataCenter.getId())) {
                dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
            }
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#end_block

#method_before
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.setModel(this);
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                validateMemorySize(getMemSize(), (Integer) ((VdcQueryReturnValue) returnValue).getReturnValue(), _minMemSize);
                if (!(((UnitVmModel) model).getBehavior() instanceof TemplateVmModelBehavior)) {
                    // Minimum 'Physical Memory Guaranteed' is 1MB
                    validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
                }
            }
        };
        if (getSelectedCluster() != null) {
            AsyncDataProvider.getOsMaxRam(osType, getSelectedCluster().getcompatibility_version(), asyncQuery);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behaviorValid && customPropertySheetValid && getQuota().getIsValid();
}
#method_after
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.setModel(this);
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                validateMemorySize(getMemSize(), (Integer) ((VdcQueryReturnValue) returnValue).getReturnValue(), _minMemSize);
                if (!(((UnitVmModel) model).getBehavior() instanceof TemplateVmModelBehavior)) {
                    // Minimum 'Physical Memory Guaranteed' is 1MB
                    validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
                }
            }
        };
        if (getSelectedCluster() != null) {
            AsyncDataProvider.getOsMaxRam(osType, getSelectedCluster().getcompatibility_version(), asyncQuery);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behaviorValid && customPropertySheetValid && getQuota().getIsValid() && getMigrationDowntime().getIsValid();
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmType().setIsChangable(true);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    AsyncQuery getVmNicsQuery = new AsyncQuery();
    getVmNicsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            networkInerfaces = (List<VmNetworkInterface>) result;
            postNetworkInterfacesLoaded();
        }
    };
    AsyncDataProvider.getVmNicList(getVmNicsQuery, vm.getId());
    AsyncDataProvider.getWatchdogByVmId(new AsyncQuery(this.getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            VdcQueryReturnValue val = (VdcQueryReturnValue) returnValue;
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = val.getReturnValue();
            for (VmWatchdog watchdog : watchdogs) {
                model.getWatchdogAction().setSelectedItem(watchdog.getAction() == null ? null : watchdog.getAction().name().toLowerCase());
                model.getWatchdogModel().setSelectedItem(watchdog.getModel() == null ? "" : watchdog.getModel().name());
            }
        }
    }), vm.getId());
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmInitEnabled().setEntity(getVm().getVmInit() != null);
    getModel().getVmInitModel().init(getVm().getStaticData());
    getModel().getVmType().setIsChangable(true);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    AsyncQuery getVmNicsQuery = new AsyncQuery();
    getVmNicsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            networkInerfaces = (List<VmNetworkInterface>) result;
            postNetworkInterfacesLoaded();
        }
    };
    AsyncDataProvider.getVmNicList(getVmNicsQuery, vm.getId());
    AsyncDataProvider.getWatchdogByVmId(new AsyncQuery(this.getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            VdcQueryReturnValue val = (VdcQueryReturnValue) returnValue;
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = val.getReturnValue();
            for (VmWatchdog watchdog : watchdogs) {
                model.getWatchdogAction().setSelectedItem(watchdog.getAction() == null ? null : watchdog.getAction().name().toLowerCase());
                model.getWatchdogModel().setSelectedItem(watchdog.getModel() == null ? "" : watchdog.getModel().name());
            }
        }
    }), vm.getId());
}
#end_block

#method_before
protected void initClusters(final List<StoragePool> dataCenters) {
    AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            model.setDataCentersAndClusters(model, dataCenters, (List<VDSGroup>) returnValue, vm.getVdsGroupId());
            initTemplate();
            initCdImage();
            initSoundCard(vm.getId());
        }
    }, getModel().getHash()), true, false);
}
#method_after
protected void initClusters(final List<StoragePool> dataCenters) {
    AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
            List<VDSGroup> filteredClusters = AsyncDataProvider.filterByArchitecture(clusters, vm.getClusterArch());
            model.setDataCentersAndClusters(model, dataCenters, filteredClusters, vm.getVdsGroupId());
            initTemplate();
            initCdImage();
            initSoundCard(vm.getId());
        }
    }, getModel().getHash()), true, false);
}
#end_block

#method_before
@Override
public void template_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    getModel().getName().setEntity(vm.getName());
    getModel().getDescription().setEntity(vm.getVmDescription());
    getModel().getComment().setEntity(vm.getComment());
    getModel().getMemSize().setEntity(vm.getVmMemSizeMb());
    getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(vm.getVmOsId());
    getModel().getDomain().setSelectedItem(vm.getVmDomain());
    getModel().getUsbPolicy().setSelectedItem(vm.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(vm.getNumOfMonitors());
    getModel().getIsSingleQxlEnabled().setEntity(vm.getSingleQxlPci());
    getModel().getAllowConsoleReconnect().setEntity(vm.getAllowConsoleReconnect());
    getModel().setBootSequence(vm.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(vm.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(vm.getNumOfCpus()));
    getModel().getTotalCPUCores().setIsChangable(!vm.isRunning());
    getModel().getIsStateless().setEntity(vm.isStateless());
    getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsRunAndPause().setEntity(vm.isRunAndPause());
    getModel().getIsRunAndPause().setIsChangable(!vm.isRunning());
    getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    getModel().getIsDeleteProtected().setEntity(vm.isDeleteProtected());
    getModel().selectSsoMethod(vm.getSsoMethod());
    getModel().getNumOfSockets().setSelectedItem(vm.getNumOfSockets());
    getModel().getNumOfSockets().setIsChangable(!vm.isRunning());
    getModel().getCoresPerSocket().setIsChangable(!vm.isRunning());
    getModel().getKernel_parameters().setEntity(vm.getKernelParams());
    getModel().getKernel_path().setEntity(vm.getKernelUrl());
    getModel().getInitrd_path().setEntity(vm.getInitrdUrl());
    getModel().getCustomProperties().setEntity(vm.getCustomProperties());
    getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
    getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
    updateCpuSharesSelection();
    Frontend.getInstance().runQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            @SuppressWarnings("unchecked")
            List<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (watchdogs.isEmpty()) {
                getModel().getWatchdogAction().setSelectedItem(null);
                getModel().getWatchdogModel().setSelectedItem(null);
            } else {
                VmWatchdog vmWatchdog = watchdogs.get(0);
                getModel().getWatchdogAction().setSelectedItem(vmWatchdog.getAction() == null ? null : vmWatchdog.getAction().name().toLowerCase());
                getModel().getWatchdogModel().setSelectedItem(vmWatchdog.getModel() == null ? "" : vmWatchdog.getModel().name());
            }
        }
    }));
    updateConsoleDevice(getVm().getId());
    updateVirtioScsiEnabled(getVm().getId(), getVm().getVmOsId());
    getModel().getVncKeyboardLayout().setSelectedItem(vm.getVncKeyboardLayout());
    Frontend.getInstance().runQuery(VdcQueryType.IsBalloonEnabled, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            getModel().getMemoryBalloonDeviceEnabled().setEntity((Boolean) ((VdcQueryReturnValue) returnValue).getReturnValue());
        }
    }));
    if (vm.isInitialized()) {
        UIConstants constants = ConstantsManager.getInstance().getConstants();
        getModel().getTimeZone().setChangeProhibitionReason(constants.timeZoneCannotBeChangedAfterVMInit());
        getModel().getTimeZone().setIsChangable(false);
    }
    updateTimeZone(vm.getTimeZone());
    // Update domain list
    updateDomain();
    updateHostPinning(vm.getMigrationSupport());
    getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    getModel().getCpuPinning().setEntity(vm.getCpuPinning());
    initPriority(vm.getPriority());
}
#method_after
@Override
public void template_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    getModel().getName().setEntity(vm.getName());
    getModel().getDescription().setEntity(vm.getVmDescription());
    getModel().getComment().setEntity(vm.getComment());
    getModel().getMemSize().setEntity(vm.getVmMemSizeMb());
    getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(vm.getVmOsId());
    getModel().getUsbPolicy().setSelectedItem(vm.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(vm.getNumOfMonitors());
    getModel().getIsSingleQxlEnabled().setEntity(vm.getSingleQxlPci());
    getModel().getAllowConsoleReconnect().setEntity(vm.getAllowConsoleReconnect());
    getModel().setBootSequence(vm.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(vm.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(vm.getNumOfCpus()));
    getModel().getTotalCPUCores().setIsChangable(!vm.isRunning());
    getModel().getIsStateless().setEntity(vm.isStateless());
    getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsRunAndPause().setEntity(vm.isRunAndPause());
    getModel().getIsRunAndPause().setIsChangable(!vm.isRunning());
    getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    getModel().getIsDeleteProtected().setEntity(vm.isDeleteProtected());
    getModel().selectSsoMethod(vm.getSsoMethod());
    getModel().getNumOfSockets().setSelectedItem(vm.getNumOfSockets());
    getModel().getNumOfSockets().setIsChangable(isHotSetCpuSupported() || !vm.isRunning());
    getModel().getCoresPerSocket().setIsChangable(!vm.isRunning());
    getModel().getKernel_parameters().setEntity(vm.getKernelParams());
    getModel().getKernel_path().setEntity(vm.getKernelUrl());
    getModel().getInitrd_path().setEntity(vm.getInitrdUrl());
    getModel().getCustomProperties().setEntity(vm.getCustomProperties());
    getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
    getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
    updateCpuSharesSelection();
    Frontend.getInstance().runQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            @SuppressWarnings("unchecked")
            List<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (watchdogs.isEmpty()) {
                getModel().getWatchdogAction().setSelectedItem(null);
                getModel().getWatchdogModel().setSelectedItem(null);
            } else {
                VmWatchdog vmWatchdog = watchdogs.get(0);
                getModel().getWatchdogAction().setSelectedItem(vmWatchdog.getAction() == null ? null : vmWatchdog.getAction().name().toLowerCase());
                getModel().getWatchdogModel().setSelectedItem(vmWatchdog.getModel() == null ? "" : vmWatchdog.getModel().name());
            }
        }
    }));
    updateConsoleDevice(getVm().getId());
    updateVirtioScsiEnabled(getVm().getId(), getVm().getVmOsId());
    getModel().getVncKeyboardLayout().setSelectedItem(vm.getDefaultVncKeyboardLayout());
    Frontend.getInstance().runQuery(VdcQueryType.IsBalloonEnabled, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            getModel().getMemoryBalloonDeviceEnabled().setEntity((Boolean) ((VdcQueryReturnValue) returnValue).getReturnValue());
        }
    }));
    if (vm.isInitialized()) {
        UIConstants constants = ConstantsManager.getInstance().getConstants();
        getModel().getTimeZone().setChangeProhibitionReason(constants.timeZoneCannotBeChangedAfterVMInit());
        getModel().getTimeZone().setIsChangable(false);
    }
    updateTimeZone(vm.getTimeZone());
    // Update domain list
    updateDomain();
    updateHostPinning(vm.getMigrationSupport());
    getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    getModel().getCpuPinning().setEntity(vm.getCpuPinning());
    initPriority(vm.getPriority());
    getModel().setSelectedMigrationDowntime(vm.getMigrationDowntime());
    if (isHotSetCpuSupported()) {
        // cancel related events while fetching data
        getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
        getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
        getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
        AsyncDataProvider.getHostById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                ExistingVmModelBehavior existingVmModelBehavior = (ExistingVmModelBehavior) model;
                runningOnHost = (VDS) returnValue;
                hostCpu = calculateHostCpus();
                existingVmModelBehavior.updateNumOfSockets();
            }
        }), vm.getRunOnVds());
    }
}
#end_block

#method_before
public void initTemplate() {
    setupTemplate(vm, getModel().getTemplate());
}
#method_after
protected void initTemplate() {
    setupTemplate(vm.getVmtGuid(), vm.isUseLatestVersion());
}
#end_block

#method_before
public static void init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class };
    osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames));
    for (Pair<EditableField, String> pair : BaseHandler.extractAnnotatedFields(EditableField.class, (inspectedClassNames))) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond());
    }
    for (Pair<EditableOnVm, String> pair : BaseHandler.extractAnnotatedFields(EditableOnVm.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond());
    }
    for (Pair<EditableOnVmStatusField, String> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond());
    }
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.StopVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.ShutdownVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RemoveVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.VmLogon);
}
#method_after
public static void init() {
    Class<?>[] inspectedClassNames = new Class<?>[] { VmBase.class, VM.class, VmStatic.class, VmDynamic.class };
    osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(inspectedClassNames));
    for (Pair<EditableField, String> pair : BaseHandler.extractAnnotatedFields(EditableField.class, (inspectedClassNames))) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond());
    }
    for (Pair<EditableOnVm, String> pair : BaseHandler.extractAnnotatedFields(EditableOnVm.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddPermittedFields(pair.getSecond());
    }
    for (Pair<EditableOnVmStatusField, String> pair : BaseHandler.extractAnnotatedFields(EditableOnVmStatusField.class, inspectedClassNames)) {
        mUpdateVmsStatic.AddField(Arrays.asList(pair.getFirst().statuses()), pair.getSecond());
    }
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.VmLogon);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.StopVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.ShutdownVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RemoveVm);
    COMMANDS_ALLOWED_ON_EXTERNAL_VMS.add(VdcActionType.RebootVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.MigrateVmToServer);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.InternalMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.CancelMigrateVm);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.SetVmTicket);
    COMMANDS_ALLOWED_ON_HOSTED_ENGINE.add(VdcActionType.VmLogon);
}
#end_block

#method_before
public static boolean isOsTypeSupportedForVirtioScsi(int osId, Version clusterVersion, List<String> reasons) {
    boolean result = VmValidationUtils.isOsSupportedForVirtIoScsi(osId, clusterVersion);
    if (!result) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_IS_DOES_NOT_SUPPORT_VIRTIO_SCSI.toString());
    }
    return result;
}
#method_after
public static boolean isOsTypeSupportedForVirtioScsi(int osId, Version clusterVersion, List<String> reasons) {
    boolean result = VmValidationUtils.isDiskInterfaceSupportedByOs(osId, clusterVersion, DiskInterface.VirtIO_SCSI);
    if (!result) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI.name());
    }
    return result;
}
#end_block

#method_before
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVm().getOs(), getVdsGroup().getcompatibility_version(), getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    if (getInstanceType() == null) {
                        addVmPayload();
                        updateSmartCardDevices();
                        addVmWatchdog();
                    }
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                addVmInit();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    if (getInstanceType() == null) {
                        addVmPayload();
                        updateSmartCardDevices();
                        addVmWatchdog();
                    }
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), false);
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), false);
}
#end_block

#method_before
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNic iface : getVmInterfaces()) {
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#method_after
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    tempVar.setLastStopTime(new Date());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#end_block

#method_before
protected boolean isVirtioScsiEnabled() {
    Boolean virtioScsiEnabled = getParameters().isVirtioScsiEnabled();
    boolean isOsSupportedForVirtIoScsi = VmValidationUtils.isOsSupportedForVirtIoScsi(getParameters().getVm().getOs(), getVdsGroup().getcompatibility_version());
    return virtioScsiEnabled != null ? virtioScsiEnabled : FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version()) && isOsSupportedForVirtIoScsi;
}
#method_after
protected boolean isVirtioScsiEnabled() {
    Boolean virtioScsiEnabled = getParameters().isVirtioScsiEnabled();
    boolean isOsSupportedForVirtIoScsi = VmValidationUtils.isDiskInterfaceSupportedByOs(getParameters().getVm().getOs(), getVdsGroup().getcompatibility_version(), DiskInterface.VirtIO_SCSI);
    return virtioScsiEnabled != null ? virtioScsiEnabled : FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version()) && isOsSupportedForVirtIoScsi;
}
#end_block

#method_before
private void updateVmObject() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setDefaultBootSequence(instanceType.getDefaultBootSequence());
        vmStatic.setDefaultDisplayType(instanceType.getDefaultDisplayType());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        // use sound card only if instance type has it
        getParameters().setSoundDeviceEnabled(!getVmDeviceDao().getVmDeviceByVmIdAndType(instanceType.getId(), VmDeviceGeneralType.SOUND).isEmpty());
        // set vm interface source id to be the instance type, vm interface are taken from it
        vmInterfacesSourceId = instanceType.getId();
    }
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
}
#method_after
private void updateVmObject() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setDefaultBootSequence(instanceType.getDefaultBootSequence());
        vmStatic.setDefaultDisplayType(instanceType.getDefaultDisplayType());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        // use sound card only if instance type has it
        getParameters().setSoundDeviceEnabled(!getVmDeviceDao().getVmDeviceByVmIdAndType(instanceType.getId(), VmDeviceGeneralType.SOUND).isEmpty());
        // set vm interface source id to be the instance type, vm interface are taken from it
        vmInterfacesSourceId = instanceType.getId();
    }
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    // Choose a proper default display type according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() != OsRepository.AUTO_SELECT_OS && getParameters().getVmStaticData().getDefaultDisplayType() == null) {
        DisplayType defaultDisplayType = osRepository.getDisplayTypes(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version()).get(0);
        getParameters().getVmStaticData().setDefaultDisplayType(defaultDisplayType);
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    VmStatic newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    UpdateVmNetworks();
    getVmStaticDAO().update(newVmStatic);
    updateVmPayload();
    VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
    updateWatchdog();
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    UpdateVmNetworks();
    hotSetCpus();
    getVmStaticDAO().update(newVmStatic);
    updateVmPayload();
    VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
    updateWatchdog();
    checkTrustedService();
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        addCanDoActionMessage("$device console");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        addCanDoActionMessage("$device sound");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, getParameters().isVirtioScsiEnabled())) {
        addCanDoActionMessage("$device VirtIO-SCSI");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        addCanDoActionMessage("$device console");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        addCanDoActionMessage("$device sound");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName(), getParameters().isVirtioScsiEnabled())) {
        addCanDoActionMessage("$device VirtIO-SCSI");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    return true;
}
#end_block

#method_before
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), getParameters().isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
private boolean vmDeviceChanged(VmDeviceGeneralType deviceType, boolean deviceEnabled) {
    List<VmDevice> vmDevices = getVmDeviceDao().getVmDeviceByVmIdAndType(getParameters().getVmId(), deviceType);
    return deviceEnabled == vmDevices.isEmpty();
}
#method_after
private boolean vmDeviceChanged(VmDeviceGeneralType deviceType, String device, boolean deviceEnabled) {
    List<VmDevice> vmDevices = getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(getParameters().getVmId(), deviceType, device);
    return deviceEnabled == vmDevices.isEmpty();
}
#end_block

#method_before
protected boolean hasWatchdog() {
    return getParameters().getWatchdog() != null ? true : VmDeviceUtils.hasWatchdog(getVmId());
}
#method_after
protected boolean hasWatchdog() {
    return getParameters().getWatchdog() != null;
}
#end_block

#method_before
@Before
public void setUp() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    when(osRepository.getMinimumRam(0, Version.v3_0)).thenReturn(0);
    when(osRepository.getMinimumRam(0, null)).thenReturn(0);
    when(osRepository.getMaximumRam(0, Version.v3_0)).thenReturn(256);
    when(osRepository.getMaximumRam(0, null)).thenReturn(256);
    when(osRepository.isWindows(0)).thenReturn(false);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setId(Guid.newGuid());
    group.setcompatibility_version(Version.v3_0);
    vm.setVdsGroupId(group.getId());
    vmStatic.setVdsGroupId(group.getId());
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
}
#method_after
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    Map<Integer, Map<Version, List<DisplayType>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<DisplayType>>());
    displayTypeMap.get(osId).put(version, Arrays.asList(DisplayType.qxl));
    when(osRepository.getDisplayTypes()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setcpu_name("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setcompatibility_version(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
}
#end_block

#method_before
@Test
public void testCannotUpdateOSNotSupportVirtioScsi() {
    prepareVmToPassCanDoAction();
    group.setcompatibility_version(Version.v3_3);
    when(command.isVirtioScsiEnabledForVm(any(Guid.class))).thenReturn(true);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO")));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_IS_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#method_after
public void testCannotUpdateOSNotSupportVirtioScsi() {
    prepareVmToPassCanDoAction();
    group.setcompatibility_version(Version.v3_3);
    when(command.isVirtioScsiEnabledForVm(any(Guid.class))).thenReturn(true);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO")));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#end_block

#method_before
@Test
public void create10GBVmWith11GbAvailableAndA5GbBuffer() throws Exception {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd = createVmFromTemplateCommand(vm);
    mockOsRepository();
    mockStorageDomainDAOGetForStoragePool();
    mockVmTemplateDAOReturnVmTemplate();
    mockDiskImageDAOGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockConfigSizeDefaults();
    mockStorageDomainDaoGetAllStoragesForPool(AVAILABLE_SPACE_GB);
    mockUninterestingMethods(cmd);
    assertFalse("If the disk is too big, canDoAction should fail", cmd.canDoAction());
    assertTrue("canDoAction failed for the wrong reason", cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN.toString()));
}
#method_after
@Test
public void create10GBVmWith11GbAvailableAndA5GbBuffer() throws Exception {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd = createVmFromTemplateCommand(vm);
    mockOsRepository();
    mockStorageDomainDAOGetForStoragePool();
    mockVdsGroupDAOReturnVdsGroup();
    mockVmTemplateDAOReturnVmTemplate();
    mockDiskImageDAOGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockConfigSizeDefaults();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(AVAILABLE_SPACE_GB);
    mockUninterestingMethods(cmd);
    assertFalse("If the disk is too big, canDoAction should fail", cmd.canDoAction());
    assertTrue("canDoAction failed for the wrong reason", cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN.toString()));
}
#end_block

#method_before
@Test
public void canAddVmWithVirtioScsiControllerNotSupportedOs() {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd = createVmFromTemplateCommand(vm);
    mockOsRepository();
    mockStorageDomainDAOGetForStoragePool();
    mockVmTemplateDAOReturnVmTemplate();
    mockDiskImageDAOGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockConfigSizeDefaults();
    mockStorageDomainDaoGetAllStoragesForPool(20);
    mockUninterestingMethods(cmd);
    doReturn(true).when(cmd).checkCpuSockets();
    doReturn(createVdsGroup()).when(cmd).getVdsGroup();
    cmd.getParameters().setVirtioScsiEnabled(true);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO")));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_IS_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#method_after
@Test
public void canAddVmWithVirtioScsiControllerNotSupportedOs() {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd = createVmFromTemplateCommand(vm);
    VDSGroup vdsGroup = createVdsGroup();
    mockOsRepository();
    mockStorageDomainDAOGetForStoragePool();
    mockVmTemplateDAOReturnVmTemplate();
    mockDiskImageDAOGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockConfigSizeDefaults();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(20);
    mockUninterestingMethods(cmd);
    mockDisplayTypes(vm.getOs(), vdsGroup.getcompatibility_version());
    doReturn(true).when(cmd).checkCpuSockets();
    doReturn(vdsGroup).when(cmd).getVdsGroup();
    cmd.getParameters().setVirtioScsiEnabled(true);
    when(osRepository.getArchitectureFromOS(any(Integer.class))).thenReturn(ArchitectureType.x86_64);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO")));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#end_block

#method_before
private VDSGroup createVdsGroup() {
    if (vdsGroup == null) {
        vdsGroup = new VDSGroup();
        vdsGroup.setcompatibility_version(Version.v3_3);
    }
    return vdsGroup;
}
#method_after
private VDSGroup createVdsGroup() {
    if (vdsGroup == null) {
        vdsGroup = new VDSGroup();
        vdsGroup.setvds_group_id(Guid.newGuid());
        vdsGroup.setcompatibility_version(Version.v3_3);
        vdsGroup.setcpu_name("Intel Conroe Family");
        vdsGroup.setArchitecture(ArchitectureType.x86_64);
    }
    return vdsGroup;
}
#end_block

#method_before
private void removeMemoryVolumes(String memoryVolume, Guid vmId) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryVolume, vmId), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes: {0}", memoryVolume);
    }
}
#method_after
private void removeMemoryVolumes(String memoryVolume, Guid vmId) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(memoryVolume, vmId));
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes: {0}", memoryVolume);
    }
}
#end_block

#method_before
private void removeMemoryVolumesOfSnapshot(Snapshot snapshot) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(snapshot.getMemoryVolume(), getVmId()), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes of snapshot {0} ({1})", snapshot.getDescription(), snapshot.getId());
    }
}
#method_after
private void removeMemoryVolumesOfSnapshot(Snapshot snapshot) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.RemoveMemoryVolumes, new RemoveMemoryVolumesParameters(snapshot.getMemoryVolume(), getVmId()));
    if (!retVal.getSucceeded()) {
        log.errorFormat("Failed to remove memory volumes of snapshot {0} ({1})", snapshot.getDescription(), snapshot.getId());
    }
}
#end_block

#method_before
@Override
protected boolean isMemoryStateRemovable(String memoryVolume) {
    if (memoryVolume.isEmpty()) {
        return false;
    }
    // is removed from the DB (because it is transactive command)
    return enclosingCommand.getParameters().getParentCommand() == VdcActionType.RemoveVm ? getSnapshotDao().getNumOfSnapshotsByMemory(memoryVolume) == 0 : getSnapshotDao().getNumOfSnapshotsByMemory(memoryVolume) == 1;
}
#method_after
@Override
protected boolean isMemoryStateRemovable(String memoryVolume) {
    if (memoryVolume.isEmpty()) {
        return false;
    }
    int numOfSnapshotsUsingThisMemory = getSnapshotDao().getNumOfSnapshotsByMemory(memoryVolume);
    return numOfSnapshotsUsingThisMemory == (removeOnlyIfNotUsedAtAll ? 0 : 1);
}
#end_block

#method_before
protected boolean removeMemoryVolumes(Set<String> memoryVolumes) {
    boolean result = true;
    for (String memoryVols : memoryVolumes) {
        result &= removeMemoryVolume(memoryVols);
    }
    return result;
}
#method_after
protected boolean removeMemoryVolumes(Set<String> memoryVolumes) {
    boolean allVolumesRemovedSucessfully = true;
    for (String memoryVols : memoryVolumes) {
        allVolumesRemovedSucessfully &= removeMemoryVolume(memoryVols);
    }
    return allVolumesRemovedSucessfully;
}
#end_block

#method_before
private void removeMemoryVolumes() {
    for (String memoryState : memoryStates) {
        VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.RemoveMemoryVolumes, buildRemoveMemoryVolumesParameters(memoryState, getVmId()), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!retVal.getSucceeded()) {
            log.errorFormat("Failed to remove memory volumes whie removing vm {0} (volumes: {1})", getVmId(), memoryState);
        }
    }
}
#method_after
private void removeMemoryVolumes() {
    for (String memoryState : memoryStates) {
        VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.RemoveMemoryVolumes, buildRemoveMemoryVolumesParameters(memoryState, getVmId()));
        if (!retVal.getSucceeded()) {
            log.errorFormat("Failed to remove memory volumes whie removing vm {0} (volumes: {1})", getVmId(), memoryState);
        }
    }
}
#end_block

#method_before
private RemoveMemoryVolumesParameters buildRemoveMemoryVolumesParameters(String memoryState, Guid vmId) {
    RemoveMemoryVolumesParameters parameters = new RemoveMemoryVolumesParameters(memoryState, getVmId());
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEntityInfo(getParameters().getEntityInfo());
    return parameters;
}
#method_after
private RemoveMemoryVolumesParameters buildRemoveMemoryVolumesParameters(String memoryState, Guid vmId) {
    RemoveMemoryVolumesParameters parameters = new RemoveMemoryVolumesParameters(memoryState, getVmId());
    parameters.setRemoveOnlyIfNotUsedAtAll(true);
    return parameters;
}
#end_block

#method_before
public String getVmHost() {
    String vmHost = this.vmDynamic.getVmHost();
    if (!StringHelper.isNullOrEmpty(this.getVmIp())) {
        this.vmDynamic.setVmHost(getVmIp());
    } else {
        String vmDomain = getVmDomain();
        // vmHost and vmDomain.
        if (StringHelper.isNullOrEmpty(vmHost)) {
            vmHost = StringHelper.isNullOrEmpty(vmDomain) ? getName() : getName() + "." + vmDomain;
            this.vmDynamic.setVmHost(vmHost);
        } else if (!StringHelper.isNullOrEmpty(vmDomain) && !vmHost.endsWith(vmDomain)) {
            this.vmDynamic.setVmHost(vmHost + "." + vmDomain);
        }
    }
    return this.vmDynamic.getVmHost();
}
#method_after
public String getVmHost() {
    String vmDomain = (getVmInit() != null) ? getVmInit().getDomain() : null;
    String vmHost = this.vmDynamic.getVmHost();
    if (!StringHelper.isNullOrEmpty(this.getVmIp())) {
        this.vmDynamic.setVmHost(getVmIp());
    } else {
        // vmHost and vmDomain.
        if (StringHelper.isNullOrEmpty(vmHost)) {
            vmHost = StringHelper.isNullOrEmpty(vmDomain) ? getName() : getName() + "." + vmDomain;
            this.vmDynamic.setVmHost(vmHost);
        } else if (!StringHelper.isNullOrEmpty(vmDomain) && !vmHost.endsWith(vmDomain)) {
            this.vmDynamic.setVmHost(vmHost + "." + vmDomain);
        }
    }
    return this.vmDynamic.getVmHost();
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((acpiEnabled == null) ? 0 : acpiEnabled.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + bootSequence.hashCode();
    result = prime * result + ((clientIp == null) ? 0 : clientIp.hashCode());
    result = prime * result + ((display == null) ? 0 : display.hashCode());
    result = prime * result + ((displayIp == null) ? 0 : displayIp.hashCode());
    result = prime * result + ((displaySecurePort == null) ? 0 : displaySecurePort.hashCode());
    result = prime * result + displayType.hashCode();
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((consoleCurUserName == null) ? 0 : consoleCurUserName.hashCode());
    result = prime * result + ((guestCurUserName == null) ? 0 : guestCurUserName.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guestLastLoginTime == null) ? 0 : guestLastLoginTime.hashCode());
    result = prime * result + ((guestLastLogoutTime == null) ? 0 : guestLastLogoutTime.hashCode());
    result = prime * result + ((guestOs == null) ? 0 : guestOs.hashCode());
    result = prime * result + ((guestRequestedMemory == null) ? 0 : guestRequestedMemory.hashCode());
    result = prime * result + ((hibernationVolHandle == null) ? 0 : hibernationVolHandle.hashCode());
    result = prime * result + ((kvmEnable == null) ? 0 : kvmEnable.hashCode());
    result = prime * result + ((lastVdsRunOn == null) ? 0 : lastVdsRunOn.hashCode());
    result = prime * result + ((disks == null) ? 0 : disks.hashCode());
    result = prime * result + ((mExitMessage == null) ? 0 : mExitMessage.hashCode());
    result = prime * result + exitStatus.hashCode();
    result = prime * result + (win2kHackEnabled ? 1231 : 1237);
    result = prime * result + ((migratingToVds == null) ? 0 : migratingToVds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((runOnVds == null) ? 0 : runOnVds.hashCode());
    result = prime * result + session.hashCode();
    result = prime * result + status.hashCode();
    result = prime * result + ((utcDiff == null) ? 0 : utcDiff.hashCode());
    result = prime * result + ((vmHost == null) ? 0 : vmHost.hashCode());
    result = prime * result + ((vmIp == null) ? 0 : vmIp.hashCode());
    result = prime * result + ((vmFQDN == null) ? 0 : vmFQDN.hashCode());
    result = prime * result + ((lastStartTime == null) ? 0 : lastStartTime.hashCode());
    result = prime * result + ((lastStopTime == null) ? 0 : lastStopTime.hashCode());
    result = prime * result + ((vmPid == null) ? 0 : vmPid.hashCode());
    result = prime * result + (lastWatchdogEvent == null ? 0 : lastWatchdogEvent.hashCode());
    result = prime * result + (lastWatchdogAction == null ? 0 : lastWatchdogAction.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (currentCd == null ? 0 : currentCd.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((acpiEnabled == null) ? 0 : acpiEnabled.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + bootSequence.hashCode();
    result = prime * result + ((clientIp == null) ? 0 : clientIp.hashCode());
    result = prime * result + ((display == null) ? 0 : display.hashCode());
    result = prime * result + ((displayIp == null) ? 0 : displayIp.hashCode());
    result = prime * result + ((displaySecurePort == null) ? 0 : displaySecurePort.hashCode());
    result = prime * result + displayType.hashCode();
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((consoleCurrentUserName == null) ? 0 : consoleCurrentUserName.hashCode());
    result = prime * result + ((guestCurUserName == null) ? 0 : guestCurUserName.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guestLastLoginTime == null) ? 0 : guestLastLoginTime.hashCode());
    result = prime * result + ((guestLastLogoutTime == null) ? 0 : guestLastLogoutTime.hashCode());
    result = prime * result + ((guestOs == null) ? 0 : guestOs.hashCode());
    result = prime * result + ((guestRequestedMemory == null) ? 0 : guestRequestedMemory.hashCode());
    result = prime * result + ((hibernationVolHandle == null) ? 0 : hibernationVolHandle.hashCode());
    result = prime * result + ((kvmEnable == null) ? 0 : kvmEnable.hashCode());
    result = prime * result + ((lastVdsRunOn == null) ? 0 : lastVdsRunOn.hashCode());
    result = prime * result + ((disks == null) ? 0 : disks.hashCode());
    result = prime * result + ((exitMessage == null) ? 0 : exitMessage.hashCode());
    result = prime * result + exitStatus.hashCode();
    result = prime * result + (win2kHackEnabled ? 1231 : 1237);
    result = prime * result + ((migratingToVds == null) ? 0 : migratingToVds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((runOnVds == null) ? 0 : runOnVds.hashCode());
    result = prime * result + session.hashCode();
    result = prime * result + status.hashCode();
    result = prime * result + ((utcDiff == null) ? 0 : utcDiff.hashCode());
    result = prime * result + ((vmHost == null) ? 0 : vmHost.hashCode());
    result = prime * result + ((vmIp == null) ? 0 : vmIp.hashCode());
    result = prime * result + ((vmFQDN == null) ? 0 : vmFQDN.hashCode());
    result = prime * result + ((lastStartTime == null) ? 0 : lastStartTime.hashCode());
    result = prime * result + ((lastStopTime == null) ? 0 : lastStopTime.hashCode());
    result = prime * result + ((vmPid == null) ? 0 : vmPid.hashCode());
    result = prime * result + (lastWatchdogEvent == null ? 0 : lastWatchdogEvent.hashCode());
    result = prime * result + (lastWatchdogAction == null ? 0 : lastWatchdogAction.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (currentCd == null ? 0 : currentCd.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(acpiEnabled, other.acpiEnabled) && ObjectUtils.objectsEqual(appList, other.appList) && bootSequence == other.bootSequence && ObjectUtils.objectsEqual(clientIp, other.clientIp) && ObjectUtils.objectsEqual(display, other.display) && ObjectUtils.objectsEqual(displayIp, other.displayIp) && ObjectUtils.objectsEqual(displaySecurePort, other.displaySecurePort) && displayType == other.displayType && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(consoleCurUserName, other.consoleCurUserName) && ObjectUtils.objectsEqual(guestCurUserName, other.guestCurUserName) && ObjectUtils.objectsEqual(consoleUserId, other.consoleUserId) && ObjectUtils.objectsEqual(guestLastLoginTime, other.guestLastLoginTime) && ObjectUtils.objectsEqual(guestLastLogoutTime, other.guestLastLogoutTime) && ObjectUtils.objectsEqual(guestOs, other.guestOs) && ObjectUtils.objectsEqual(guestRequestedMemory, other.guestRequestedMemory) && ObjectUtils.objectsEqual(hibernationVolHandle, other.hibernationVolHandle) && ObjectUtils.objectsEqual(kvmEnable, other.kvmEnable) && ObjectUtils.objectsEqual(lastVdsRunOn, other.lastVdsRunOn) && ObjectUtils.objectsEqual(disks, other.disks) && ObjectUtils.objectsEqual(mExitMessage, other.mExitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && ObjectUtils.objectsEqual(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && ObjectUtils.objectsEqual(runOnVds, other.runOnVds) && session == other.session && status == other.status && ObjectUtils.objectsEqual(utcDiff, other.utcDiff) && ObjectUtils.objectsEqual(vmHost, other.vmHost) && ObjectUtils.objectsEqual(vmIp, other.vmIp) && ObjectUtils.objectsEqual(vmFQDN, other.vmFQDN) && ObjectUtils.objectsEqual(lastStartTime, other.lastStartTime) && ObjectUtils.objectsEqual(lastStopTime, other.lastStopTime) && ObjectUtils.objectsEqual(vmPid, other.vmPid) && ObjectUtils.objectsEqual(lastWatchdogEvent, other.lastWatchdogEvent) && ObjectUtils.objectsEqual(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(currentCd, other.currentCd));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(acpiEnabled, other.acpiEnabled) && ObjectUtils.objectsEqual(appList, other.appList) && bootSequence == other.bootSequence && ObjectUtils.objectsEqual(clientIp, other.clientIp) && ObjectUtils.objectsEqual(display, other.display) && ObjectUtils.objectsEqual(displayIp, other.displayIp) && ObjectUtils.objectsEqual(displaySecurePort, other.displaySecurePort) && displayType == other.displayType && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(consoleCurrentUserName, other.consoleCurrentUserName) && ObjectUtils.objectsEqual(guestCurUserName, other.guestCurUserName) && ObjectUtils.objectsEqual(consoleUserId, other.consoleUserId) && ObjectUtils.objectsEqual(guestLastLoginTime, other.guestLastLoginTime) && ObjectUtils.objectsEqual(guestLastLogoutTime, other.guestLastLogoutTime) && ObjectUtils.objectsEqual(guestOs, other.guestOs) && ObjectUtils.objectsEqual(guestRequestedMemory, other.guestRequestedMemory) && ObjectUtils.objectsEqual(hibernationVolHandle, other.hibernationVolHandle) && ObjectUtils.objectsEqual(kvmEnable, other.kvmEnable) && ObjectUtils.objectsEqual(lastVdsRunOn, other.lastVdsRunOn) && ObjectUtils.objectsEqual(disks, other.disks) && ObjectUtils.objectsEqual(exitMessage, other.exitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && ObjectUtils.objectsEqual(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && ObjectUtils.objectsEqual(runOnVds, other.runOnVds) && session == other.session && status == other.status && ObjectUtils.objectsEqual(utcDiff, other.utcDiff) && ObjectUtils.objectsEqual(vmHost, other.vmHost) && ObjectUtils.objectsEqual(vmIp, other.vmIp) && ObjectUtils.objectsEqual(vmFQDN, other.vmFQDN) && ObjectUtils.objectsEqual(lastStartTime, other.lastStartTime) && ObjectUtils.objectsEqual(lastStopTime, other.lastStopTime) && ObjectUtils.objectsEqual(vmPid, other.vmPid) && ObjectUtils.objectsEqual(lastWatchdogEvent, other.lastWatchdogEvent) && ObjectUtils.objectsEqual(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(currentCd, other.currentCd));
}
#end_block

#method_before
public String getExitMessage() {
    return mExitMessage;
}
#method_after
public String getExitMessage() {
    return exitMessage;
}
#end_block

#method_before
public void setExitMessage(String value) {
    mExitMessage = value;
}
#method_after
public void setExitMessage(String value) {
    exitMessage = value;
}
#end_block

#method_before
public String getConsoleCurrentUserName() {
    return consoleCurUserName;
}
#method_after
public String getConsoleCurrentUserName() {
    return consoleCurrentUserName;
}
#end_block

#method_before
public void setConsoleCurrentUserName(String consoleCurUserName) {
    this.consoleCurUserName = consoleCurUserName;
}
#method_after
public void setConsoleCurrentUserName(String consoleCurUserName) {
    this.consoleCurrentUserName = consoleCurUserName;
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setDefaultVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    entity.setCurrentCd(rs.getString("current_cd"));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setDefaultVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == VmStaticDAODbFacadeImpl.USE_LATEST_VERSION_NUMBER_INDICATOR);
    entity.setCurrentCd(rs.getString("current_cd"));
    return entity;
}
#end_block

#method_before
@Override
public CdRom get() {
    if (QueryHelper.hasMatrixParam(getUriInfo(), CURRENT_CONSTRAINT_PARAMETER)) {
        VM vm = collection.lookupEntity(guid);
        if (vm == null) {
            return notFound();
        }
        // if the CD has changed during the run of VM
        if (vm.getCurrentCd() != null) {
            // change the iso path so the result of 'map' will contain current cd instead of the
            // persistent configuration
            vm.setIsoPath(vm.getCurrentCd());
        }
        return addLinks(populate(map(vm), vm));
    } else {
        return super.get();
    }
}
#method_after
@Override
public CdRom get() {
    final boolean getCurrent = QueryHelper.hasMatrixParam(getUriInfo(), CURRENT_CONSTRAINT_PARAMETER) && !"false".equalsIgnoreCase(QueryHelper.getMatrixConstraint(getUriInfo(), CURRENT_CONSTRAINT_PARAMETER));
    if (getCurrent) {
        VM vm = collection.lookupEntity(guid);
        if (vm == null) {
            return notFound();
        }
        // if the CD has changed during the run of VM
        if (vm.getCurrentCd() != null) {
            // change the iso path so the result of 'map' will contain current cd instead of the
            // persistent configuration
            vm.setIsoPath(vm.getCurrentCd());
        }
        return addLinks(populate(map(vm), vm));
    } else {
        return super.get();
    }
}
#end_block

#method_before
public static StoragePool buildStoragePool(Map<String, Object> xmlRpcStruct) {
    StoragePool sPool = new StoragePool();
    if (xmlRpcStruct.containsKey("type")) {
        sPool.setStorageType(StorageType.valueOf(xmlRpcStruct.get("type").toString()));
    }
    sPool.setName(AssignStringValue(xmlRpcStruct, "name"));
    Integer masterVersion = AssignIntValue(xmlRpcStruct, "master_ver");
    if (masterVersion != null) {
        sPool.setmaster_domain_version(masterVersion);
    }
    return sPool;
}
#method_after
public static StoragePool buildStoragePool(Map<String, Object> xmlRpcStruct) {
    StoragePool sPool = new StoragePool();
    if (xmlRpcStruct.containsKey("type")) {
        sPool.setIsLocal(StorageType.valueOf(xmlRpcStruct.get("type").toString()).isLocal());
    }
    sPool.setName(AssignStringValue(xmlRpcStruct, "name"));
    Integer masterVersion = AssignIntValue(xmlRpcStruct, "master_ver");
    if (masterVersion != null) {
        sPool.setmaster_domain_version(masterVersion);
    }
    return sPool;
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getDomain(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), true);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    // if for some reason template doesn't have images, remove it now and not in end action
    final boolean hasImages = imageTemplates.size() > 0;
    if (hasImages) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                if (removeVmTemplateImages()) {
                    setSucceeded(true);
                }
                return null;
            }
        });
    } else {
        HandleEndAction();
    }
}
#method_after
@Override
protected void executeCommand() {
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    // if for some reason template doesn't have images, remove it now and not in end action
    final boolean hasImages = imageTemplates.size() > 0;
    if (hasImages) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                if (removeVmTemplateImages()) {
                    VmHandler.removeVmInitFromDB(getVmTemplate());
                    setSucceeded(true);
                }
                return null;
            }
        });
    } else {
        HandleEndAction();
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + cpuPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + osId;
    result = prime * result + memSizeMb;
    result = prime * result + niceLevel;
    result = prime * result + cpuShares;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((dedicatedVmForVds == null) ? 0 : dedicatedVmForVds.hashCode());
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((tunnelMigration == null) ? 0 : tunnelMigration.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((createdByUserId == null) ? 0 : createdByUserId.hashCode());
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + ((migrationDowntime == null) ? 0 : migrationDowntime.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + cpuPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + osId;
    result = prime * result + memSizeMb;
    result = prime * result + niceLevel;
    result = prime * result + cpuShares;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((dedicatedVmForVds == null) ? 0 : dedicatedVmForVds.hashCode());
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((tunnelMigration == null) ? 0 : tunnelMigration.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((createdByUserId == null) ? 0 : createdByUserId.hashCode());
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + ((migrationDowntime == null) ? 0 : migrationDowntime.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && ObjectUtils.objectsEqual(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && ObjectUtils.objectsEqual(description, other.description) && ObjectUtils.objectsEqual(domain, other.domain) && failBack == other.failBack && ObjectUtils.objectsEqual(initrdUrl, other.initrdUrl) && ObjectUtils.objectsEqual(isoPath, other.isoPath) && ObjectUtils.objectsEqual(kernelParams, other.kernelParams) && ObjectUtils.objectsEqual(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && ObjectUtils.objectsEqual(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && ObjectUtils.objectsEqual(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && ObjectUtils.objectsEqual(dedicatedVmForVds, other.dedicatedVmForVds) && migrationSupport == other.migrationSupport && ObjectUtils.objectsEqual(tunnelMigration, other.tunnelMigration) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && ObjectUtils.objectsEqual(migrationDowntime, other.migrationDowntime));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && ObjectUtils.objectsEqual(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && ObjectUtils.objectsEqual(description, other.description) && failBack == other.failBack && ObjectUtils.objectsEqual(initrdUrl, other.initrdUrl) && ObjectUtils.objectsEqual(isoPath, other.isoPath) && ObjectUtils.objectsEqual(kernelParams, other.kernelParams) && ObjectUtils.objectsEqual(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && ObjectUtils.objectsEqual(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && ObjectUtils.objectsEqual(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && ObjectUtils.objectsEqual(dedicatedVmForVds, other.dedicatedVmForVds) && migrationSupport == other.migrationSupport && ObjectUtils.objectsEqual(tunnelMigration, other.tunnelMigration) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && ObjectUtils.objectsEqual(migrationDowntime, other.migrationDowntime));
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setDefaultVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == VmStaticDAODbFacadeImpl.USE_LATEST_VERSION_NUMBER_INDICATOR);
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setDefaultVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == VmStaticDAODbFacadeImpl.USE_LATEST_VERSION_NUMBER_INDICATOR);
    return entity;
}
#end_block

#method_before
private MapSqlParameterSource getFullParameterSource(VmStatic vm) {
    return getIdParamterSource(vm.getId()).addValue("description", vm.getDescription()).addValue("free_text_comment", vm.getComment()).addValue("mem_size_mb", vm.getMemSizeMb()).addValue("os", vm.getOsId()).addValue("vds_group_id", vm.getVdsGroupId()).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("domain", vm.getDomain()).addValue("creation_date", vm.getCreationDate()).addValue("num_of_monitors", vm.getNumOfMonitors()).addValue("single_qxl_pci", vm.getSingleQxlPci()).addValue("is_initialized", vm.isInitialized()).addValue("num_of_sockets", vm.getNumOfSockets()).addValue("cpu_per_socket", vm.getCpuPerSocket()).addValue("usb_policy", vm.getUsbPolicy()).addValue("time_zone", vm.getTimeZone()).addValue("auto_startup", vm.isAutoStartup()).addValue("is_stateless", vm.isStateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("sso_method", vm.getSsoMethod().toString()).addValue("dedicated_vm_for_vds", vm.getDedicatedVmForVds()).addValue("fail_back", vm.isFailBack()).addValue("vm_type", vm.getVmType()).addValue("nice_level", vm.getNiceLevel()).addValue("cpu_shares", vm.getCpuShares()).addValue("default_boot_sequence", vm.getDefaultBootSequence()).addValue("default_display_type", vm.getDefaultDisplayType()).addValue("priority", vm.getPriority()).addValue("iso_path", vm.getIsoPath()).addValue("origin", vm.getOrigin()).addValue("initrd_url", vm.getInitrdUrl()).addValue("kernel_url", vm.getKernelUrl()).addValue("kernel_params", vm.getKernelParams()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.isAllowConsoleReconnect()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("tunnel_migration", vm.getTunnelMigration()).addValue("vnc_keyboard_layout", vm.getVncKeyboardLayout()).addValue("is_run_and_pause", vm.isRunAndPause()).addValue("created_by_user_id", vm.getCreatedByUserId()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId()).addValue("original_template_name", vm.getOriginalTemplateName()).addValue("original_template_id", vm.getOriginalTemplateGuid()).addValue("migration_downtime", vm.getMigrationDowntime()).addValue("template_version_number", vm.isUseLatestVersion() ? USE_LATEST_VERSION_NUMBER_INDICATOR : DONT_USE_LATEST_VERSION_NUMBER_INDICATOR);
}
#method_after
private MapSqlParameterSource getFullParameterSource(VmStatic vm) {
    return getIdParamterSource(vm.getId()).addValue("description", vm.getDescription()).addValue("free_text_comment", vm.getComment()).addValue("mem_size_mb", vm.getMemSizeMb()).addValue("os", vm.getOsId()).addValue("vds_group_id", vm.getVdsGroupId()).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("creation_date", vm.getCreationDate()).addValue("num_of_monitors", vm.getNumOfMonitors()).addValue("single_qxl_pci", vm.getSingleQxlPci()).addValue("is_initialized", vm.isInitialized()).addValue("num_of_sockets", vm.getNumOfSockets()).addValue("cpu_per_socket", vm.getCpuPerSocket()).addValue("usb_policy", vm.getUsbPolicy()).addValue("time_zone", vm.getTimeZone()).addValue("auto_startup", vm.isAutoStartup()).addValue("is_stateless", vm.isStateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("sso_method", vm.getSsoMethod().toString()).addValue("dedicated_vm_for_vds", vm.getDedicatedVmForVds()).addValue("fail_back", vm.isFailBack()).addValue("vm_type", vm.getVmType()).addValue("nice_level", vm.getNiceLevel()).addValue("cpu_shares", vm.getCpuShares()).addValue("default_boot_sequence", vm.getDefaultBootSequence()).addValue("default_display_type", vm.getDefaultDisplayType()).addValue("priority", vm.getPriority()).addValue("iso_path", vm.getIsoPath()).addValue("origin", vm.getOrigin()).addValue("initrd_url", vm.getInitrdUrl()).addValue("kernel_url", vm.getKernelUrl()).addValue("kernel_params", vm.getKernelParams()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.isAllowConsoleReconnect()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("tunnel_migration", vm.getTunnelMigration()).addValue("vnc_keyboard_layout", vm.getVncKeyboardLayout()).addValue("is_run_and_pause", vm.isRunAndPause()).addValue("created_by_user_id", vm.getCreatedByUserId()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId()).addValue("original_template_name", vm.getOriginalTemplateName()).addValue("original_template_id", vm.getOriginalTemplateGuid()).addValue("migration_downtime", vm.getMigrationDowntime()).addValue("template_version_number", vm.isUseLatestVersion() ? USE_LATEST_VERSION_NUMBER_INDICATOR : DONT_USE_LATEST_VERSION_NUMBER_INDICATOR);
}
#end_block

#method_before
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setName(rs.getString("vm_name"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == USE_LATEST_VERSION_NUMBER_INDICATOR);
    return entity;
}
#method_after
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setName(rs.getString("vm_name"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == USE_LATEST_VERSION_NUMBER_INDICATOR);
    return entity;
}
#end_block

#method_before
private void beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintenance) {
    if (_vdsManager.getbeforeFirstRefresh()) {
        boolean flagsChanged = false;
        final AtomicBoolean processHardwareCapsNeededTemp = new AtomicBoolean();
        _vdsManager.refreshCapabilities(processHardwareCapsNeededTemp, _vds);
        flagsChanged = processHardwareCapsNeededTemp.get();
        _vdsManager.setbeforeFirstRefresh(false);
        refreshedCapabilities = true;
        _saveVdsDynamic = true;
        // change the _cpuFlagsChanged flag only if it was false,
        // because get capabilities is called twice on a new server in same
        // loop!
        processHardwareCapsNeeded = (processHardwareCapsNeeded) ? processHardwareCapsNeeded : flagsChanged;
    } else if (isVdsUpOrGoingToMaintenance || _vds.getStatus() == VDSStatus.Error) {
        return;
    }
    // show status UP in audit only when InitVdsOnUpCommand finished successfully
    if (_vds.getStatus() != VDSStatus.Up) {
        AuditLogableBase logable = new AuditLogableBase(_vds.getId());
        logable.addCustomValue("VdsStatus", _vds.getStatus().toString());
        auditLog(logable, AuditLogType.VDS_DETECTED);
    }
}
#method_after
private void beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintenance) {
    if (_vdsManager.getbeforeFirstRefresh()) {
        boolean flagsChanged = false;
        final AtomicBoolean processHardwareCapsNeededTemp = new AtomicBoolean();
        _vdsManager.refreshCapabilities(processHardwareCapsNeededTemp, _vds);
        flagsChanged = processHardwareCapsNeededTemp.get();
        _vdsManager.setbeforeFirstRefresh(false);
        refreshedCapabilities = true;
        _saveVdsDynamic = true;
        // change the _cpuFlagsChanged flag only if it was false,
        // because get capabilities is called twice on a new server in same
        // loop!
        processHardwareCapsNeeded = (processHardwareCapsNeeded) ? processHardwareCapsNeeded : flagsChanged;
    } else if (isVdsUpOrGoingToMaintenance || _vds.getStatus() == VDSStatus.Error) {
        return;
    }
    // show status UP in audit only when InitVdsOnUpCommand finished successfully
    if (_vds.getStatus() != VDSStatus.Up) {
        AuditLogableBase logable = new AuditLogableBase(_vds.getId());
        logable.addCustomValue("HostStatus", _vds.getStatus().toString());
        auditLog(logable, AuditLogType.VDS_DETECTED);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSGroup vdsGroup = getVdsGroup();
    boolean initSucceeded = true;
    if (vdsGroup.supportsTrustedService()) {
        initSucceeded = initTrustedService();
    }
    if (initSucceeded && vdsGroup.supportsVirtService()) {
        initSucceeded = initVirtResources();
    }
    if (initSucceeded && vdsGroup.supportsGlusterService()) {
        initSucceeded = initGlusterHost();
    }
    setSucceeded(initSucceeded);
    if (getSucceeded()) {
        AuditLogableBase logable = new AuditLogableBase(getVds().getId());
        logable.addCustomValue("VdsStatus", getVds().getStatus().toString());
        AuditLogDirector.log(logable, AuditLogType.VDS_DETECTED);
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSGroup vdsGroup = getVdsGroup();
    boolean initSucceeded = true;
    /* Host is UP, re-set the policy controlled power management flag */
    getVds().setPowerManagementControlledByPolicy(true);
    DbFacade.getInstance().getVdsDynamicDao().updateVdsDynamicPowerManagementPolicyFlag(getVds().getId(), getVds().isPowerManagementControlledByPolicy());
    if (vdsGroup.supportsTrustedService()) {
        initSucceeded = initTrustedService();
    }
    if (initSucceeded && vdsGroup.supportsVirtService()) {
        initSucceeded = initVirtResources();
    }
    if (initSucceeded && vdsGroup.supportsGlusterService()) {
        initSucceeded = initGlusterHost();
    }
    setSucceeded(initSucceeded);
    if (getSucceeded()) {
        AuditLogableBase logable = new AuditLogableBase(getVds().getId());
        logable.addCustomValue("HostStatus", getVds().getStatus().toString());
        AuditLogDirector.log(logable, AuditLogType.VDS_DETECTED);
    }
}
#end_block

#method_before
private VDSReturnValue runUpdateMomPolicy(final VDSGroup cluster, final VDS vds) {
    VDSReturnValue returnValue = new VDSReturnValue();
    if (cluster.getcompatibility_version().compareTo(Version.v3_3) >= 0) {
        try {
            returnValue = runVdsCommand(VDSCommandType.SetMOMPolicyParameters, new MomPolicyVDSParameters(vds, cluster.isEnableBallooning()));
        } catch (VdcBLLException e) {
            log.errorFormat("Could not update MoM policy on host {0}", vds.getName());
            returnValue.setSucceeded(false);
        }
    }
    return returnValue;
}
#method_after
private VDSReturnValue runUpdateMomPolicy(final VDSGroup cluster, final VDS vds) {
    VDSReturnValue returnValue = new VDSReturnValue();
    if (cluster.getcompatibility_version().compareTo(Version.v3_3) >= 0) {
        try {
            returnValue = runVdsCommand(VDSCommandType.SetMOMPolicyParameters, new MomPolicyVDSParameters(vds, cluster.isEnableBallooning(), cluster.isEnableKsm()));
        } catch (VdcBLLException e) {
            log.errorFormat("Could not update MoM policy on host {0}", vds.getName());
            returnValue.setSucceeded(false);
        }
    }
    return returnValue;
}
#end_block

#method_before
private boolean initGlusterPeerProcess() {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVds().getVdsGroupId())) {
        glusterPeerListSucceeded = true;
        glusterPeerProbeSucceeded = true;
        Map<String, String> customLogValues = new HashMap<String, String>();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS vds : vdsList) {
                if (!getVdsId().equals(vds.getId())) {
                    upServer = vds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!hostExists(glusterServers, getVds())) {
                    if (!glusterPeerProbe(upServer.getId(), getVds().getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + getVds().getHostName());
                        setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                    int retries = 0;
                    while (retries < MAX_RETRIES_GLUSTER_PROBE_STATUS) {
                        // though gluster peer probe succeeds, it takes some time for the host to be
                        // listed as a peer. Return success only when the host is acknowledged as peer
                        // from another upServer.
                        VDS newUpServer = getNewUpServer(upServer);
                        if (newUpServer == null) {
                            // there's no other up server. so there's no issue with peer status results
                            return true;
                        }
                        List<GlusterServerInfo> newGlusterServers = getGlusterPeers(newUpServer.getId());
                        if (!hostExists(newGlusterServers, getVds())) {
                            log.infoFormat("Failed to find host {0} in gluster peer list from {1} on attempt {2}", getVds(), newUpServer, ++retries);
                            // if num of attempts done
                            if (retries == MAX_RETRIES_GLUSTER_PROBE_STATUS) {
                                customLogValues.put("Command", "gluster peer status " + getVds().getHostName());
                                setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                                return false;
                            }
                            try {
                                // give time for gluster peer probe to propogate to servers.
                                Thread.sleep(1000);
                            } catch (Exception e) {
                                log.error(e.getMessage());
                                break;
                            }
                        } else {
                            return true;
                        }
                    }
                }
            }
        }
        return true;
    }
}
#method_after
private boolean initGlusterPeerProcess() {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVds().getVdsGroupId())) {
        glusterPeerListSucceeded = true;
        glusterPeerProbeSucceeded = true;
        Map<String, String> customLogValues = new HashMap<String, String>();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS vds : vdsList) {
                if (!getVdsId().equals(vds.getId())) {
                    upServer = vds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!getGlusterUtil().isHostExists(glusterServers, getVds())) {
                    if (!glusterPeerProbe(upServer.getId(), getVds().getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + getVds().getHostName());
                        setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                    int retries = 0;
                    while (retries < MAX_RETRIES_GLUSTER_PROBE_STATUS) {
                        // though gluster peer probe succeeds, it takes some time for the host to be
                        // listed as a peer. Return success only when the host is acknowledged as peer
                        // from another upServer.
                        VDS newUpServer = getNewUpServer(upServer);
                        if (newUpServer == null) {
                            // there's no other up server. so there's no issue with peer status results
                            return true;
                        }
                        List<GlusterServerInfo> newGlusterServers = getGlusterPeers(newUpServer.getId());
                        if (!getGlusterUtil().isHostExists(newGlusterServers, getVds())) {
                            log.infoFormat("Failed to find host {0} in gluster peer list from {1} on attempt {2}", getVds(), newUpServer, ++retries);
                            // if num of attempts done
                            if (retries == MAX_RETRIES_GLUSTER_PROBE_STATUS) {
                                customLogValues.put("Command", "gluster peer status " + getVds().getHostName());
                                setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                                return false;
                            }
                            try {
                                // give time for gluster peer probe to propogate to servers.
                                Thread.sleep(1000);
                            } catch (Exception e) {
                                log.error(e.getMessage());
                                break;
                            }
                        } else {
                            return true;
                        }
                    }
                }
            }
        }
        return true;
    }
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    vm.setUseLatestVersion(instance.isUseLatestVersion());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    vm.setUseLatestVersion(instance.isUseLatestVersion());
    return vm;
}
#end_block

#method_before
private static StoragePool cloneStorage_pool(StoragePool instance) {
    StoragePool obj = new StoragePool();
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setStorageType(instance.getStorageType());
    obj.setStatus(instance.getStatus());
    obj.setmaster_domain_version(instance.getmaster_domain_version());
    obj.setLVER(instance.getLVER());
    obj.setrecovery_mode(instance.getrecovery_mode());
    obj.setspm_vds_id(instance.getspm_vds_id());
    obj.setcompatibility_version(instance.getcompatibility_version());
    return obj;
}
#method_after
private static StoragePool cloneStorage_pool(StoragePool instance) {
    StoragePool obj = new StoragePool();
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setIsLocal(instance.isLocal());
    obj.setStatus(instance.getStatus());
    obj.setmaster_domain_version(instance.getmaster_domain_version());
    obj.setLVER(instance.getLVER());
    obj.setrecovery_mode(instance.getrecovery_mode());
    obj.setspm_vds_id(instance.getspm_vds_id());
    obj.setcompatibility_version(instance.getcompatibility_version());
    return obj;
}
#end_block

#method_before
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setDomain(instance.getDomain());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    obj.setTemplateVersionNumber(instance.getTemplateVersionNumber());
    obj.setBaseTemplateId(instance.getBaseTemplateId());
    obj.setTemplateVersionName(instance.getTemplateVersionName());
    return obj;
}
#method_after
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    obj.setTemplateVersionNumber(instance.getTemplateVersionNumber());
    obj.setBaseTemplateId(instance.getBaseTemplateId());
    obj.setTemplateVersionName(instance.getTemplateVersionName());
    return obj;
}
#end_block

#method_before
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setDomain(instance.getDomain());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setDiskSize(instance.getDiskSize());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    obj.setUseLatestVersion(instance.isUseLatestVersion());
    return obj;
}
#method_after
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setDiskSize(instance.getDiskSize());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    obj.setUseLatestVersion(instance.isUseLatestVersion());
    return obj;
}
#end_block

#method_before
private MapSqlParameterSource getFullParameterSource(VmStatic vm) {
    return getIdParamterSource(vm.getId()).addValue("description", vm.getDescription()).addValue("free_text_comment", vm.getComment()).addValue("mem_size_mb", vm.getMemSizeMb()).addValue("os", vm.getOsId()).addValue("vds_group_id", vm.getVdsGroupId()).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("domain", vm.getDomain()).addValue("creation_date", vm.getCreationDate()).addValue("num_of_monitors", vm.getNumOfMonitors()).addValue("single_qxl_pci", vm.getSingleQxlPci()).addValue("is_initialized", vm.isInitialized()).addValue("num_of_sockets", vm.getNumOfSockets()).addValue("cpu_per_socket", vm.getCpuPerSocket()).addValue("usb_policy", vm.getUsbPolicy()).addValue("time_zone", vm.getTimeZone()).addValue("auto_startup", vm.isAutoStartup()).addValue("is_stateless", vm.isStateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("sso_method", vm.getSsoMethod().toString()).addValue("dedicated_vm_for_vds", vm.getDedicatedVmForVds()).addValue("fail_back", vm.isFailBack()).addValue("vm_type", vm.getVmType()).addValue("nice_level", vm.getNiceLevel()).addValue("cpu_shares", vm.getCpuShares()).addValue("default_boot_sequence", vm.getDefaultBootSequence()).addValue("default_display_type", vm.getDefaultDisplayType()).addValue("priority", vm.getPriority()).addValue("iso_path", vm.getIsoPath()).addValue("origin", vm.getOrigin()).addValue("initrd_url", vm.getInitrdUrl()).addValue("kernel_url", vm.getKernelUrl()).addValue("kernel_params", vm.getKernelParams()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.isAllowConsoleReconnect()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("tunnel_migration", vm.getTunnelMigration()).addValue("vnc_keyboard_layout", vm.getVncKeyboardLayout()).addValue("is_run_and_pause", vm.isRunAndPause()).addValue("created_by_user_id", vm.getCreatedByUserId()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId()).addValue("original_template_name", vm.getOriginalTemplateName()).addValue("original_template_id", vm.getOriginalTemplateGuid()).addValue("migration_downtime", vm.getMigrationDowntime()).addValue("template_version_number", vm.isUseLatestVersion() ? USE_LATEST_VERSION_NUMBER_INDICATOR : DONT_USE_LATEST_VERSION_NUMBER_INDICATOR);
}
#method_after
private MapSqlParameterSource getFullParameterSource(VmStatic vm) {
    return getIdParamterSource(vm.getId()).addValue("description", vm.getDescription()).addValue("free_text_comment", vm.getComment()).addValue("mem_size_mb", vm.getMemSizeMb()).addValue("os", vm.getOsId()).addValue("vds_group_id", vm.getVdsGroupId()).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("creation_date", vm.getCreationDate()).addValue("num_of_monitors", vm.getNumOfMonitors()).addValue("single_qxl_pci", vm.getSingleQxlPci()).addValue("is_initialized", vm.isInitialized()).addValue("num_of_sockets", vm.getNumOfSockets()).addValue("cpu_per_socket", vm.getCpuPerSocket()).addValue("usb_policy", vm.getUsbPolicy()).addValue("time_zone", vm.getTimeZone()).addValue("auto_startup", vm.isAutoStartup()).addValue("is_stateless", vm.isStateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("sso_method", vm.getSsoMethod().toString()).addValue("dedicated_vm_for_vds", vm.getDedicatedVmForVds()).addValue("fail_back", vm.isFailBack()).addValue("vm_type", vm.getVmType()).addValue("nice_level", vm.getNiceLevel()).addValue("cpu_shares", vm.getCpuShares()).addValue("default_boot_sequence", vm.getDefaultBootSequence()).addValue("default_display_type", vm.getDefaultDisplayType()).addValue("priority", vm.getPriority()).addValue("iso_path", vm.getIsoPath()).addValue("origin", vm.getOrigin()).addValue("initrd_url", vm.getInitrdUrl()).addValue("kernel_url", vm.getKernelUrl()).addValue("kernel_params", vm.getKernelParams()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.isAllowConsoleReconnect()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("tunnel_migration", vm.getTunnelMigration()).addValue("vnc_keyboard_layout", vm.getVncKeyboardLayout()).addValue("is_run_and_pause", vm.isRunAndPause()).addValue("created_by_user_id", vm.getCreatedByUserId()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId()).addValue("original_template_name", vm.getOriginalTemplateName()).addValue("original_template_id", vm.getOriginalTemplateGuid()).addValue("migration_downtime", vm.getMigrationDowntime()).addValue("template_version_number", vm.isUseLatestVersion() ? USE_LATEST_VERSION_NUMBER_INDICATOR : DONT_USE_LATEST_VERSION_NUMBER_INDICATOR);
}
#end_block

#method_before
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setName(rs.getString("vm_name"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == USE_LATEST_VERSION_NUMBER_INDICATOR);
    return entity;
}
#method_after
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setName(rs.getString("vm_name"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == USE_LATEST_VERSION_NUMBER_INDICATOR);
    return entity;
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getDomain(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getVmTemplateId(), getParameters().getTemplateVersionName()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getVmTemplateId(), getParameters().getTemplateVersionName()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), true);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
public String getVmHost() {
    String vmHost = this.vmDynamic.getVmHost();
    if (!StringHelper.isNullOrEmpty(this.getVmIp())) {
        this.vmDynamic.setVmHost(getVmIp());
    } else {
        String vmDomain = getVmDomain();
        // vmHost and vmDomain.
        if (StringHelper.isNullOrEmpty(vmHost)) {
            vmHost = StringHelper.isNullOrEmpty(vmDomain) ? getName() : getName() + "." + vmDomain;
            this.vmDynamic.setVmHost(vmHost);
        } else if (!StringHelper.isNullOrEmpty(vmDomain) && !vmHost.endsWith(vmDomain)) {
            this.vmDynamic.setVmHost(vmHost + "." + vmDomain);
        }
    }
    return this.vmDynamic.getVmHost();
}
#method_after
public String getVmHost() {
    String vmHost = this.vmDynamic.getVmHost();
    if (!StringHelper.isNullOrEmpty(this.getVmIp())) {
        this.vmDynamic.setVmHost(getVmIp());
    } else if (getVmInit() != null) {
        String vmDomain = getVmInit().getDomain();
        // vmHost and vmDomain.
        if (StringHelper.isNullOrEmpty(vmHost)) {
            vmHost = StringHelper.isNullOrEmpty(vmDomain) ? getName() : getName() + "." + vmDomain;
            this.vmDynamic.setVmHost(vmHost);
        } else if (!StringHelper.isNullOrEmpty(vmDomain) && !vmHost.endsWith(vmDomain)) {
            this.vmDynamic.setVmHost(vmHost + "." + vmDomain);
        }
    }
    return this.vmDynamic.getVmHost();
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("free_text_comment", template.getComment()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOsId()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("domain", template.getDomain()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("single_qxl_pci", template.getSingleQxlPci()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("cpu_shares", template.getCpuShares()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("sso_method", template.getSsoMethod().toString()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("created_by_user_id", template.getCreatedByUserId()).addValue("template_type", template.getTemplateType().name()).addValue("migration_downtime", template.getMigrationDowntime()).addValue("base_template_id", template.getBaseTemplateId()).addValue("template_version_name", template.getTemplateVersionName());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("free_text_comment", template.getComment()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOsId()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("single_qxl_pci", template.getSingleQxlPci()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("cpu_shares", template.getCpuShares()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("sso_method", template.getSsoMethod().toString()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("created_by_user_id", template.getCreatedByUserId()).addValue("template_type", template.getTemplateType().name()).addValue("migration_downtime", template.getMigrationDowntime()).addValue("base_template_id", template.getBaseTemplateId()).addValue("template_version_name", template.getTemplateVersionName());
}
#end_block

#method_before
@Override
public VmTemplate mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmTemplate entity = new VmTemplate();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setChildCount(rs.getInt("child_count"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setName(rs.getString("name"));
    entity.setOsId(rs.getInt("os"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setStatus(VmTemplateStatus.forValue(rs.getInt("status")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDisabled(rs.getBoolean("is_disabled"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setTemplateType(VmEntityType.valueOf(rs.getString("entity_type")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setBaseTemplateId(getGuidDefaultEmpty(rs, "base_template_id"));
    entity.setTemplateVersionNumber(rs.getInt("template_version_number"));
    entity.setTemplateVersionName(rs.getString("template_version_name"));
    return entity;
}
#method_after
@Override
public VmTemplate mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmTemplate entity = new VmTemplate();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setChildCount(rs.getInt("child_count"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setName(rs.getString("name"));
    entity.setOsId(rs.getInt("os"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setStatus(VmTemplateStatus.forValue(rs.getInt("status")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDisabled(rs.getBoolean("is_disabled"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setTemplateType(VmEntityType.valueOf(rs.getString("entity_type")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setBaseTemplateId(getGuidDefaultEmpty(rs, "base_template_id"));
    entity.setTemplateVersionNumber(rs.getInt("template_version_number"));
    entity.setTemplateVersionName(rs.getString("template_version_name"));
    return entity;
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setDefaultVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == VmStaticDAODbFacadeImpl.USE_LATEST_VERSION_NUMBER_INDICATOR);
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setDefaultVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == VmStaticDAODbFacadeImpl.USE_LATEST_VERSION_NUMBER_INDICATOR);
    return entity;
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    return vm;
}
#end_block

#method_before
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setDomain(instance.getDomain());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    return obj;
}
#method_after
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    return obj;
}
#end_block

#method_before
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setDomain(instance.getDomain());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setDiskSize(instance.getDiskSize());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    return obj;
}
#method_after
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setDiskSize(instance.getDiskSize());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    return obj;
}
#end_block

#method_before
private HttpURLConnection createURLConnection() throws IOException, NoSuchAlgorithmException, CertificateException, KeyStoreException, KeyManagementException {
    logger.debug(String.format("createURLConnection: getSessionUserGetSessionUserServletURL=%s, sslInsecure=%s, sslNoHostVerification=%s, sslTrustStoreType=%s, sslTrustStorePath=%s, sslProtocol=%s", getSessionUserGetSessionUserServletURL, sslInsecure, sslNoHostVerification, sslTrustStoreType, sslTrustStorePath, sslProtocol));
    URL url = new URL(getSessionUserGetSessionUserServletURL);
    HttpURLConnection servletConnection = (HttpURLConnection) url.openConnection();
    if ("https".equals(url.getProtocol())) {
        TrustManager[] trustManagers;
        if (sslInsecure) {
            trustManagers = new TrustManager[] { new X509TrustManager() {

                @Override
                public void checkClientTrusted(X509Certificate[] certs, String authType) throws CertificateException {
                }

                @Override
                public void checkServerTrusted(X509Certificate[] certs, String authType) throws CertificateException {
                }

                @Override
                public X509Certificate[] getAcceptedIssuers() {
                    return new X509Certificate[] {};
                }
            } };
        } else {
            if (sslTrustStorePassword == null || sslTrustStorePath == null) {
                throw new RuntimeException("The Supplied URL is secured, however no trust store path or password were supplied.");
            }
            KeyStore trustStore = KeyStore.getInstance(sslTrustStoreType);
            trustStore.load(new FileInputStream(sslTrustStorePath), sslTrustStorePassword.toCharArray());
            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            trustManagerFactory.init(trustStore);
            trustManagers = trustManagerFactory.getTrustManagers();
        }
        SSLContext ctx = SSLContext.getInstance(sslProtocol);
        ctx.init(null, trustManagers, null);
        HttpsURLConnection httpsConnection = (HttpsURLConnection) servletConnection;
        httpsConnection.setSSLSocketFactory(ctx.getSocketFactory());
        if (sslNoHostVerification || sslInsecure) {
            httpsConnection.setHostnameVerifier(new HostnameVerifier() {

                @Override
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }
            });
        }
    }
    servletConnection.setRequestMethod("POST");
    servletConnection.setDoOutput(true);
    servletConnection.setDoInput(true);
    servletConnection.setReadTimeout(10000);
    servletConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
    return servletConnection;
}
#method_after
private HttpURLConnection createURLConnection() throws IOException {
    logger.debug(String.format("createURLConnection: getSessionUserGetSessionUserServletURL=%s, sslInsecure=%s, sslNoHostVerification=%s, sslTrustStoreType=%s, sslTrustStorePath=%s, sslProtocol=%s", getSessionUserGetSessionUserServletURL, sslInsecure, sslNoHostVerification, sslTrustStoreType, sslTrustStorePath, sslProtocol));
    HttpURLConnection servletConnection = (HttpURLConnection) getSessionUserGetSessionUserServletURL.openConnection();
    if ("https".equals(getSessionUserGetSessionUserServletURL.getProtocol())) {
        HttpsURLConnection httpsConnection = (HttpsURLConnection) servletConnection;
        httpsConnection.setSSLSocketFactory(sslctx.getSocketFactory());
        if (sslInsecure || sslNoHostVerification) {
            httpsConnection.setHostnameVerifier(new HostnameVerifier() {

                @Override
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }
            });
        }
    }
    servletConnection.setRequestMethod("POST");
    servletConnection.setDoOutput(true);
    servletConnection.setDoInput(true);
    servletConnection.setReadTimeout(10000);
    servletConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
    return servletConnection;
}
#end_block

#method_before
public void setGetSessionUserServletURL(String getSessionUserGetSessionUserServletURL) {
    this.getSessionUserGetSessionUserServletURL = getSessionUserGetSessionUserServletURL;
}
#method_after
public void setGetSessionUserServletURL(String getSessionUserGetSessionUserServletURL) throws MalformedURLException {
    this.getSessionUserGetSessionUserServletURL = new URL(getSessionUserGetSessionUserServletURL);
}
#end_block

#method_before
private HttpURLConnection createURLConnection() throws IOException, NoSuchAlgorithmException, CertificateException, KeyStoreException, KeyManagementException {
    logger.debug(String.format("createURLConnection: servletURL=%s, sslIgnoreCertErrors=%s, sslIgnoreHostVerification=%s, trustStorePath=%s", servletURL, sslIgnoreCertErrors, sslIgnoreHostVerification, trustStorePath));
    URL url = new URL(servletURL);
    HttpURLConnection servletConnection = (HttpURLConnection) url.openConnection();
    if ("https".equals(url.getProtocol())) {
        TrustManager[] trustManagers;
        if (sslIgnoreCertErrors) {
            trustManagers = new TrustManager[] { new X509TrustManager() {

                @Override
                public void checkClientTrusted(X509Certificate[] certs, String authType) throws CertificateException {
                }

                @Override
                public void checkServerTrusted(X509Certificate[] certs, String authType) throws CertificateException {
                }

                @Override
                public X509Certificate[] getAcceptedIssuers() {
                    return new X509Certificate[] {};
                }
            } };
        } else {
            if (trustStorePassword == null || trustStorePath == null) {
                throw new RuntimeException("The Supplied URL is secured, however no trust store path or password were supplied.");
            }
            KeyStore trustStore = KeyStore.getInstance(trustStoreType);
            trustStore.load(new FileInputStream(trustStorePath), trustStorePassword.toCharArray());
            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            trustManagerFactory.init(trustStore);
            trustManagers = trustManagerFactory.getTrustManagers();
        }
        SSLContext ctx = SSLContext.getInstance(sslProtocol);
        ctx.init(null, trustManagers, null);
        HttpsURLConnection httpsConnection = (HttpsURLConnection) servletConnection;
        httpsConnection.setSSLSocketFactory(ctx.getSocketFactory());
        if (sslIgnoreHostVerification) {
            httpsConnection.setHostnameVerifier(new HostnameVerifier() {

                @Override
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }
            });
        }
    }
    servletConnection.setRequestMethod("POST");
    servletConnection.setDoOutput(true);
    servletConnection.setDoInput(true);
    servletConnection.setReadTimeout(10000);
    servletConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
    return servletConnection;
}
#method_after
private HttpURLConnection createURLConnection() throws MalformedURLException, IOException, ProtocolException {
    logger.debug(String.format("createURLConnection: servletURL=%s, sslIgnoreCertErrors=%s, sslIgnoreHostVerification=%s, trustStorePath=%s", servletURL, sslIgnoreCertErrors, sslIgnoreHostVerification, trustStorePath));
    URL url = new URL(servletURL);
    HttpURLConnection servletConnection = (HttpURLConnection) url.openConnection();
    if ("https".equals(url.getProtocol())) {
        HttpsURLConnection httpsConnection = (HttpsURLConnection) servletConnection;
        httpsConnection.setSSLSocketFactory(sslctx.getSocketFactory());
        if (sslIgnoreHostVerification) {
            httpsConnection.setHostnameVerifier(new HostnameVerifier() {

                @Override
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }
            });
        }
    }
    servletConnection.setRequestMethod("POST");
    servletConnection.setDoOutput(true);
    servletConnection.setDoInput(true);
    servletConnection.setReadTimeout(10000);
    servletConnection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
    return servletConnection;
}
#end_block

#method_before
@Override
public void clearErrorMessage() {
    setErrorMessage(null);
}
#method_after
@Override
public void clearErrorMessage() {
    setErrorMessageHtml(null);
}
#end_block

#method_before
@Override
protected void writeGeneralData() {
    super.writeGeneralData();
    _writer.WriteStartElement("Name");
    _writer.WriteRaw(_vmTemplate.getName());
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateId");
    _writer.WriteRaw(_vmTemplate.getId().toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Origin");
    _writer.WriteRaw(_vmTemplate.getOrigin() == null ? "" : String.valueOf(_vmTemplate.getOrigin().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("default_display_type");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getDefaultDisplayType().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsDisabled");
    _writer.WriteRaw(String.valueOf(_vmTemplate.isDisabled()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TrustedService");
    _writer.WriteRaw(String.valueOf(_vmTemplate.isTrustedService()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateType");
    _writer.WriteRaw(_vmTemplate.getTemplateType().name());
    _writer.WriteEndElement();
    if (_vmTemplate.getBaseTemplateId() != null) {
        _writer.WriteStartElement("BaseTemplateId");
        _writer.WriteRaw(_vmTemplate.getBaseTemplateId().toString());
        _writer.WriteEndElement();
    }
}
#method_after
@Override
protected void writeGeneralData() {
    super.writeGeneralData();
    _writer.WriteStartElement("Name");
    _writer.WriteRaw(_vmTemplate.getName());
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateId");
    _writer.WriteRaw(_vmTemplate.getId().toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Origin");
    _writer.WriteRaw(_vmTemplate.getOrigin() == null ? "" : String.valueOf(_vmTemplate.getOrigin().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("default_display_type");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getDefaultDisplayType().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsDisabled");
    _writer.WriteRaw(String.valueOf(_vmTemplate.isDisabled()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TrustedService");
    _writer.WriteRaw(String.valueOf(_vmTemplate.isTrustedService()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateType");
    _writer.WriteRaw(_vmTemplate.getTemplateType().name());
    _writer.WriteEndElement();
    if (_vmTemplate.getBaseTemplateId() != null) {
        _writer.WriteStartElement("BaseTemplateId");
        _writer.WriteRaw(_vmTemplate.getBaseTemplateId().toString());
        _writer.WriteEndElement();
    }
    if (_vmTemplate.getTemplateVersionName() != null) {
        _writer.WriteStartElement("TemplateVersionName");
        _writer.WriteRaw(_vmTemplate.getTemplateVersionName());
        _writer.WriteEndElement();
    }
}
#end_block

#method_before
protected void writeGeneralData() {
    _writer.WriteStartElement("Description");
    _writer.WriteRaw(vmBase.getDescription());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Domain");
    _writer.WriteRaw(vmBase.getDomain());
    _writer.WriteEndElement();
    _writer.WriteStartElement("CreationDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(vmBase.getCreationDate()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("ExportDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(new Date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("DeleteProtected");
    _writer.WriteRaw(String.valueOf(vmBase.isDeleteProtected()));
    _writer.WriteEndElement();
    if (vmBase.getSsoMethod() != null) {
        _writer.WriteStartElement("SsoMethod");
        _writer.WriteRaw(vmBase.getSsoMethod().toString());
        _writer.WriteEndElement();
    }
    _writer.WriteStartElement("IsSmartcardEnabled");
    _writer.WriteRaw(String.valueOf(vmBase.isSmartcardEnabled()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TimeZone");
    _writer.WriteRaw(vmBase.getTimeZone());
    _writer.WriteEndElement();
    _writer.WriteStartElement("default_boot_sequence");
    _writer.WriteRaw(String.valueOf(vmBase.getDefaultBootSequence().getValue()));
    _writer.WriteEndElement();
    if (!StringUtils.isBlank(vmBase.getInitrdUrl())) {
        _writer.WriteStartElement("initrd_url");
        _writer.WriteRaw(vmBase.getInitrdUrl());
        _writer.WriteEndElement();
    }
    if (!StringUtils.isBlank(vmBase.getKernelUrl())) {
        _writer.WriteStartElement("kernel_url");
        _writer.WriteRaw(vmBase.getKernelUrl());
        _writer.WriteEndElement();
    }
    if (!StringUtils.isBlank(vmBase.getKernelParams())) {
        _writer.WriteStartElement("kernel_params");
        _writer.WriteRaw(vmBase.getKernelParams());
        _writer.WriteEndElement();
    }
    _writer.WriteStartElement("Generation");
    _writer.WriteRaw(String.valueOf(vmBase.getDbGeneration()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("VmType");
    _writer.WriteRaw(String.valueOf(vmBase.getVmType().getValue()));
    _writer.WriteEndElement();
    if (vmBase.getTunnelMigration() != null) {
        _writer.WriteStartElement("TunnelMigration");
        _writer.WriteRaw(String.valueOf(vmBase.getTunnelMigration()));
        _writer.WriteEndElement();
    }
    if (vmBase.getVncKeyboardLayout() != null) {
        _writer.WriteStartElement("VncKeyboardLayout");
        _writer.WriteRaw(vmBase.getVncKeyboardLayout());
        _writer.WriteEndElement();
    }
    _writer.WriteStartElement("MinAllocatedMem");
    _writer.WriteRaw(String.valueOf(vmBase.getMinAllocatedMem()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsStateless");
    _writer.WriteRaw(String.valueOf(vmBase.isStateless()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsRunAndPause");
    _writer.WriteRaw(String.valueOf(vmBase.isRunAndPause()));
    _writer.WriteEndElement();
    if (vmBase.getCreatedByUserId() != null) {
        _writer.WriteStartElement("CreatedByUserId");
        _writer.WriteRaw(String.valueOf(vmBase.getCreatedByUserId()));
        _writer.WriteEndElement();
    }
    if (vmBase.getTemplateVersion() != null) {
        _writer.WriteStartElement("templateVersion");
        _writer.WriteRaw(String.valueOf(vmBase.getTemplateVersion()));
        _writer.WriteEndElement();
    }
}
#method_after
protected void writeGeneralData() {
    _writer.WriteStartElement("Description");
    _writer.WriteRaw(vmBase.getDescription());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Domain");
    _writer.WriteRaw(vmBase.getDomain());
    _writer.WriteEndElement();
    _writer.WriteStartElement("CreationDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(vmBase.getCreationDate()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("ExportDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(new Date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("DeleteProtected");
    _writer.WriteRaw(String.valueOf(vmBase.isDeleteProtected()));
    _writer.WriteEndElement();
    if (vmBase.getSsoMethod() != null) {
        _writer.WriteStartElement("SsoMethod");
        _writer.WriteRaw(vmBase.getSsoMethod().toString());
        _writer.WriteEndElement();
    }
    _writer.WriteStartElement("IsSmartcardEnabled");
    _writer.WriteRaw(String.valueOf(vmBase.isSmartcardEnabled()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TimeZone");
    _writer.WriteRaw(vmBase.getTimeZone());
    _writer.WriteEndElement();
    _writer.WriteStartElement("default_boot_sequence");
    _writer.WriteRaw(String.valueOf(vmBase.getDefaultBootSequence().getValue()));
    _writer.WriteEndElement();
    if (!StringUtils.isBlank(vmBase.getInitrdUrl())) {
        _writer.WriteStartElement("initrd_url");
        _writer.WriteRaw(vmBase.getInitrdUrl());
        _writer.WriteEndElement();
    }
    if (!StringUtils.isBlank(vmBase.getKernelUrl())) {
        _writer.WriteStartElement("kernel_url");
        _writer.WriteRaw(vmBase.getKernelUrl());
        _writer.WriteEndElement();
    }
    if (!StringUtils.isBlank(vmBase.getKernelParams())) {
        _writer.WriteStartElement("kernel_params");
        _writer.WriteRaw(vmBase.getKernelParams());
        _writer.WriteEndElement();
    }
    _writer.WriteStartElement("Generation");
    _writer.WriteRaw(String.valueOf(vmBase.getDbGeneration()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("VmType");
    _writer.WriteRaw(String.valueOf(vmBase.getVmType().getValue()));
    _writer.WriteEndElement();
    if (vmBase.getTunnelMigration() != null) {
        _writer.WriteStartElement("TunnelMigration");
        _writer.WriteRaw(String.valueOf(vmBase.getTunnelMigration()));
        _writer.WriteEndElement();
    }
    if (vmBase.getVncKeyboardLayout() != null) {
        _writer.WriteStartElement("VncKeyboardLayout");
        _writer.WriteRaw(vmBase.getVncKeyboardLayout());
        _writer.WriteEndElement();
    }
    _writer.WriteStartElement("MinAllocatedMem");
    _writer.WriteRaw(String.valueOf(vmBase.getMinAllocatedMem()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsStateless");
    _writer.WriteRaw(String.valueOf(vmBase.isStateless()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsRunAndPause");
    _writer.WriteRaw(String.valueOf(vmBase.isRunAndPause()));
    _writer.WriteEndElement();
    if (vmBase.getCreatedByUserId() != null) {
        _writer.WriteStartElement("CreatedByUserId");
        _writer.WriteRaw(String.valueOf(vmBase.getCreatedByUserId()));
        _writer.WriteEndElement();
    }
    if (vmBase.getTemplateVersionNumber() != null) {
        _writer.WriteStartElement("templateVersionNumber");
        _writer.WriteRaw(String.valueOf(vmBase.getTemplateVersionNumber()));
        _writer.WriteEndElement();
    }
}
#end_block

#method_before
@Override
protected void readGeneralData(XmlNode content) {
    // General Vm
    XmlNode node = content.SelectSingleNode("Name");
    if (node != null) {
        _vmTemplate.setName(node.innerText);
        name = _vmTemplate.getName();
    }
    node = content.SelectSingleNode("TemplateId");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vmTemplate.setId(new Guid(node.innerText));
        }
    }
    node = content.SelectSingleNode("IsDisabled");
    if (node != null) {
        _vmTemplate.setDisabled(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode("TrustedService");
    if (node != null) {
        _vmTemplate.setTrustedService(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode("TemplateType");
    if (node != null) {
        _vmTemplate.setTemplateType(VmEntityType.valueOf(node.innerText));
    }
    // in case template version is missing, we assume its version 1
    if (_vmTemplate.getTemplateVersion() == null) {
        _vmTemplate.setTemplateVersion(1);
    } else {
        // TODO: what if base template is not in the engine db? block import in canDoAction?
        node = content.SelectSingleNode("BaseTemplateId");
        if (node != null) {
            _vmTemplate.setBaseTemplateId(Guid.createGuidFromString(node.innerText));
        }
    }
}
#method_after
@Override
protected void readGeneralData(XmlNode content) {
    // General Vm
    XmlNode node = content.SelectSingleNode("Name");
    if (node != null) {
        _vmTemplate.setName(node.innerText);
        name = _vmTemplate.getName();
    }
    node = content.SelectSingleNode("TemplateId");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vmTemplate.setId(new Guid(node.innerText));
        }
    }
    node = content.SelectSingleNode("IsDisabled");
    if (node != null) {
        _vmTemplate.setDisabled(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode("TrustedService");
    if (node != null) {
        _vmTemplate.setTrustedService(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode("TemplateType");
    if (node != null) {
        _vmTemplate.setTemplateType(VmEntityType.valueOf(node.innerText));
    }
    // in case template version is missing, we assume its version 1
    if (_vmTemplate.getTemplateVersionNumber() == null) {
        _vmTemplate.setTemplateVersionNumber(1);
    } else {
        // TODO: what if base template is not in the engine db? block import in canDoAction?
        node = content.SelectSingleNode("BaseTemplateId");
        if (node != null) {
            _vmTemplate.setBaseTemplateId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = content.SelectSingleNode("TemplateVersionName");
    if (node != null) {
        _vmTemplate.setTemplateVersionName(node.innerText);
    }
}
#end_block

#method_before
protected void readGeneralData() {
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node;
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    node = content.SelectSingleNode("Description");
    if (node != null) {
        vmBase.setDescription(node.innerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        vmBase.setDomain(node.innerText);
    }
    node = content.SelectSingleNode("CreationDate");
    if (node != null) {
        Date creationDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (creationDate != null) {
            vmBase.setCreationDate(creationDate);
        }
    }
    node = content.SelectSingleNode("ExportDate");
    if (node != null) {
        Date exportDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setTimeZone(node.innerText);
        }
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setInitrdUrl(node.innerText);
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelUrl(node.innerText);
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelParams(node.innerText);
        }
    }
    node = content.SelectSingleNode("Generation");
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.innerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = content.SelectSingleNode(getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            defaultDisplayType = DisplayType.forValue(Integer.parseInt(node.innerText));
            vmBase.setDefaultDisplayType(defaultDisplayType);
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || !FeatureSupported.singleQxlPci(new Version(getVersion()))) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    node = content.SelectSingleNode("Origin");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setOrigin(OriginType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVmType(VmType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode("IsSmartcardEnabled");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("DeleteProtected");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("SsoMethod");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSsoMethod(SsoMethod.fromString(node.innerText));
        }
    }
    node = content.SelectSingleNode("TunnelMigration");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTunnelMigration(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("VncKeyboardLayout");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVncKeyboardLayout(node.innerText);
        }
    }
    node = content.SelectSingleNode("MinAllocatedMem");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMinAllocatedMem(Integer.parseInt(node.innerText));
        }
    }
    node = content.SelectSingleNode("IsStateless");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setStateless(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("IsRunAndPause");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setRunAndPause(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("CreatedByUserId");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCreatedByUserId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = content.SelectSingleNode("templateVersion");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTemplateVersion(Integer.parseInt(node.innerText));
        }
    }
    readGeneralData(content);
}
#method_after
protected void readGeneralData() {
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node;
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    node = content.SelectSingleNode("Description");
    if (node != null) {
        vmBase.setDescription(node.innerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        vmBase.setDomain(node.innerText);
    }
    node = content.SelectSingleNode("CreationDate");
    if (node != null) {
        Date creationDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (creationDate != null) {
            vmBase.setCreationDate(creationDate);
        }
    }
    node = content.SelectSingleNode("ExportDate");
    if (node != null) {
        Date exportDate = OvfParser.UtcDateStringToLocaDate(node.innerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setTimeZone(node.innerText);
        }
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setInitrdUrl(node.innerText);
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelUrl(node.innerText);
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelParams(node.innerText);
        }
    }
    node = content.SelectSingleNode("Generation");
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.innerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = content.SelectSingleNode(getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            defaultDisplayType = DisplayType.forValue(Integer.parseInt(node.innerText));
            vmBase.setDefaultDisplayType(defaultDisplayType);
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || !FeatureSupported.singleQxlPci(new Version(getVersion()))) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    node = content.SelectSingleNode("Origin");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setOrigin(OriginType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVmType(VmType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = content.SelectSingleNode("IsSmartcardEnabled");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("DeleteProtected");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("SsoMethod");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSsoMethod(SsoMethod.fromString(node.innerText));
        }
    }
    node = content.SelectSingleNode("TunnelMigration");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTunnelMigration(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("VncKeyboardLayout");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVncKeyboardLayout(node.innerText);
        }
    }
    node = content.SelectSingleNode("MinAllocatedMem");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMinAllocatedMem(Integer.parseInt(node.innerText));
        }
    }
    node = content.SelectSingleNode("IsStateless");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setStateless(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("IsRunAndPause");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setRunAndPause(Boolean.parseBoolean(node.innerText));
        }
    }
    node = content.SelectSingleNode("CreatedByUserId");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCreatedByUserId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = content.SelectSingleNode("templateVersionNumber");
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTemplateVersionNumber(Integer.parseInt(node.innerText));
        }
    }
    readGeneralData(content);
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("free_text_comment", template.getComment()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOsId()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("domain", template.getDomain()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("single_qxl_pci", template.getSingleQxlPci()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("cpu_shares", template.getCpuShares()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("sso_method", template.getSsoMethod().toString()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("created_by_user_id", template.getCreatedByUserId()).addValue("template_type", template.getTemplateType().name()).addValue("base_template_id", template.getBaseTemplateId());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("free_text_comment", template.getComment()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOsId()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("domain", template.getDomain()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("single_qxl_pci", template.getSingleQxlPci()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("cpu_shares", template.getCpuShares()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("sso_method", template.getSsoMethod().toString()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("created_by_user_id", template.getCreatedByUserId()).addValue("template_type", template.getTemplateType().name()).addValue("base_template_id", template.getBaseTemplateId()).addValue("template_version_name", template.getTemplateVersionName());
}
#end_block

#method_before
@Override
public VmTemplate mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmTemplate entity = new VmTemplate();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setChildCount(rs.getInt("child_count"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setName(rs.getString("name"));
    entity.setOsId(rs.getInt("os"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setStatus(VmTemplateStatus.forValue(rs.getInt("status")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDisabled(rs.getBoolean("is_disabled"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setTemplateType(VmEntityType.valueOf(rs.getString("entity_type")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setBaseTemplateId(getGuidDefaultEmpty(rs, "base_template_id"));
    return entity;
}
#method_after
@Override
public VmTemplate mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmTemplate entity = new VmTemplate();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setChildCount(rs.getInt("child_count"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setName(rs.getString("name"));
    entity.setOsId(rs.getInt("os"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setStatus(VmTemplateStatus.forValue(rs.getInt("status")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDisabled(rs.getBoolean("is_disabled"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setTemplateType(VmEntityType.valueOf(rs.getString("entity_type")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setBaseTemplateId(getGuidDefaultEmpty(rs, "base_template_id"));
    entity.setTemplateVersionName(rs.getString("template_version_name"));
    return entity;
}
#end_block

#method_before
private VM mockVm() {
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    vm.setVmtGuid(vmTemplateId);
    vm.setStaticData(getVmStatic());
    vm.setClusterArch(ArchitectureType.x86_64);
    vm.setTemplateVersion(1);
    return vm;
}
#method_after
private VM mockVm() {
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    vm.setVmtGuid(vmTemplateId);
    vm.setStaticData(getVmStatic());
    vm.setClusterArch(ArchitectureType.x86_64);
    vm.setTemplateVersionNumber(1);
    return vm;
}
#end_block

#method_before
private VmStatic getVmStatic() {
    VmStatic vmStatic = new VmStatic();
    vmStatic.setOsId(OsRepository.DEFAULT_OS);
    vmStatic.setMemSizeMb(300);
    vmStatic.setStateless(false);
    vmStatic.setVmtGuid(vmTemplateId);
    return vmStatic;
}
#method_after
private VmStatic getVmStatic() {
    VmStatic vmStatic = new VmStatic();
    vmStatic.setOsId(OsRepository.DEFAULT_X86_OS);
    vmStatic.setMemSizeMb(300);
    vmStatic.setStateless(false);
    vmStatic.setVmtGuid(vmTemplateId);
    return vmStatic;
}
#end_block

#method_before
protected Map<Guid, VmDevice> getVmInterfaceDevices() {
    List<VmDevice> vmInterfaceDevicesList = getVmDeviceDao().getVmDeviceByVmIdAndType(vmInterfacesSourceId, VmDeviceGeneralType.INTERFACE);
    Map<Guid, VmDevice> vmInterfaceDevices = new HashMap();
    for (VmDevice device : vmInterfaceDevicesList) {
        vmInterfaceDevices.put(device.getDeviceId(), device);
    }
    return vmInterfaceDevices;
}
#method_after
protected Map<Guid, VmDevice> getVmInterfaceDevices() {
    List<VmDevice> vmInterfaceDevicesList = getVmDeviceDao().getVmDeviceByVmIdAndType(vmInterfacesSourceId, VmDeviceGeneralType.INTERFACE);
    Map<Guid, VmDevice> vmInterfaceDevices = new HashMap<>();
    for (VmDevice device : vmInterfaceDevicesList) {
        vmInterfaceDevices.put(device.getDeviceId(), device);
    }
    return vmInterfaceDevices;
}
#end_block

#method_before
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), getParameters().isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVm().getOs(), getVdsGroup().getcompatibility_version(), getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return true;
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), false);
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), false);
}
#end_block

#method_before
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    // to have to correct version
    if (vmStatic.getTemplateVersion() != null) {
        vmStatic.setTemplateVersion(getVmTemplate().getTemplateVersion());
    }
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>getValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getVdsGroupId()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    vmStatic.setOriginalTemplateGuid(vmStatic.getVmtGuid());
    vmStatic.setOriginalTemplateName(getVmTemplate().getName());
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#method_after
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    // to have to correct version, otherwise set null
    if (Boolean.TRUE.equals(getParameters().getUseLatestVersion())) {
        vmStatic.setTemplateVersionNumber(null);
    } else {
        vmStatic.setTemplateVersionNumber(getVmTemplate().getTemplateVersionNumber());
    }
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>getValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getVdsGroupId()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    vmStatic.setOriginalTemplateGuid(vmStatic.getVmtGuid());
    vmStatic.setOriginalTemplateName(getVmTemplate().getName());
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#end_block

#method_before
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#method_after
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    tempVar.setLastStopTime(new Date());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#end_block

#method_before
private void updateVmObject() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setDefaultBootSequence(instanceType.getDefaultBootSequence());
        vmStatic.setDefaultDisplayType(instanceType.getDefaultDisplayType());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        // use sound card only if instance type has it
        getParameters().setSoundDeviceEnabled(!getVmDeviceDao().getVmDeviceByVmIdAndType(instanceType.getId(), VmDeviceGeneralType.SOUND).isEmpty());
        // set vm interface source id to be the instance type, vm interface are taken from it
        vmInterfacesSourceId = instanceType.getId();
    }
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
}
#method_after
private void updateVmObject() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setDefaultBootSequence(instanceType.getDefaultBootSequence());
        vmStatic.setDefaultDisplayType(instanceType.getDefaultDisplayType());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        // use sound card only if instance type has it
        getParameters().setSoundDeviceEnabled(!getVmDeviceDao().getVmDeviceByVmIdAndType(instanceType.getId(), VmDeviceGeneralType.SOUND).isEmpty());
        // set vm interface source id to be the instance type, vm interface are taken from it
        vmInterfacesSourceId = instanceType.getId();
    }
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getVdsGroup().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getVdsGroup().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    // Choose a proper default display type according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() != OsRepository.AUTO_SELECT_OS && getParameters().getVmStaticData().getDefaultDisplayType() == null) {
        DisplayType defaultDisplayType = osRepository.getDisplayTypes(getParameters().getVmStaticData().getOsId(), getVdsGroup().getcompatibility_version()).get(0);
        getParameters().getVmStaticData().setDefaultDisplayType(defaultDisplayType);
    }
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setTemplateVersionNumber(instance.getTemplateVersionNumber());
    return vm;
}
#end_block

#method_before
private static Object cloneVDS(VDS instance) {
    VDS obj = new VDS();
    obj.setHostName(instance.getHostName());
    obj.setSshKeyFingerprint(instance.getSshKeyFingerprint());
    obj.setSshPort(instance.getSshPort());
    obj.setSshUsername(instance.getSshUsername());
    obj.setManagementIp(instance.getManagementIp());
    obj.setPmUser(instance.getPmUser());
    obj.setPmPassword(instance.getPmPassword());
    obj.setPmType(instance.getPmType());
    obj.setPmOptionsMap(instance.getPmOptionsMap());
    obj.setPmSecondaryIp(instance.getManagementIp());
    obj.setPmSecondaryUser(instance.getPmUser());
    obj.setPmSecondaryPassword(instance.getPmPassword());
    obj.setPmSecondaryType(instance.getPmType());
    obj.setPmSecondaryOptionsMap(instance.getPmOptionsMap());
    obj.setpm_enabled(instance.getpm_enabled());
    obj.setPmSecondaryConcurrent(instance.isPmSecondaryConcurrent());
    obj.setPort(instance.getPort());
    obj.setServerSslEnabled(instance.isServerSslEnabled());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setVdsName(instance.getName());
    obj.setVdsStrength(instance.getVdsStrength());
    obj.setVdsType(instance.getVdsType());
    obj.setUniqueId(instance.getUniqueId());
    obj.setVdsSpmPriority(instance.getVdsSpmPriority());
    return obj;
}
#method_after
private static Object cloneVDS(VDS instance) {
    VDS obj = new VDS();
    obj.setHostName(instance.getHostName());
    obj.setSshKeyFingerprint(instance.getSshKeyFingerprint());
    obj.setSshPort(instance.getSshPort());
    obj.setSshUsername(instance.getSshUsername());
    obj.setManagementIp(instance.getManagementIp());
    obj.setPmUser(instance.getPmUser());
    obj.setPmPassword(instance.getPmPassword());
    obj.setPmType(instance.getPmType());
    obj.setPmOptionsMap(instance.getPmOptionsMap());
    obj.setPmSecondaryIp(instance.getManagementIp());
    obj.setPmSecondaryUser(instance.getPmUser());
    obj.setPmSecondaryPassword(instance.getPmPassword());
    obj.setPmSecondaryType(instance.getPmType());
    obj.setPmSecondaryOptionsMap(instance.getPmOptionsMap());
    obj.setpm_enabled(instance.getpm_enabled());
    obj.setPmSecondaryConcurrent(instance.isPmSecondaryConcurrent());
    obj.setDisablePowerManagementPolicy(instance.isDisablePowerManagementPolicy());
    obj.setPort(instance.getPort());
    obj.setServerSslEnabled(instance.isServerSslEnabled());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setVdsName(instance.getName());
    obj.setVdsStrength(instance.getVdsStrength());
    obj.setVdsType(instance.getVdsType());
    obj.setUniqueId(instance.getUniqueId());
    obj.setVdsSpmPriority(instance.getVdsSpmPriority());
    return obj;
}
#end_block

#method_before
private static NetworkCluster cloneNetworkCluster(NetworkCluster instance) {
    NetworkCluster obj = new NetworkCluster();
    obj.setStatus(instance.getStatus());
    obj.setDisplay(instance.isDisplay());
    obj.setRequired(instance.isRequired());
    obj.setMigration(instance.isMigration());
    return obj;
}
#method_after
private static NetworkCluster cloneNetworkCluster(NetworkCluster instance) {
    NetworkCluster obj = new NetworkCluster();
    obj.setId(instance.getId());
    obj.setStatus(instance.getStatus());
    obj.setDisplay(instance.isDisplay());
    obj.setRequired(instance.isRequired());
    obj.setMigration(instance.isMigration());
    return obj;
}
#end_block

#method_before
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setDomain(instance.getDomain());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    obj.setBaseTemplateId(instance.getBaseTemplateId());
    obj.setTemplateVersionName(instance.getTemplateVersionName());
    return obj;
}
#method_after
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setDomain(instance.getDomain());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    obj.setTemplateVersionNumber(instance.getTemplateVersionNumber());
    obj.setBaseTemplateId(instance.getBaseTemplateId());
    obj.setTemplateVersionName(instance.getTemplateVersionName());
    return obj;
}
#end_block

#method_before
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setDomain(instance.getDomain());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setDiskSize(instance.getDiskSize());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    return obj;
}
#method_after
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setDomain(instance.getDomain());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setDiskSize(instance.getDiskSize());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    obj.setTemplateVersionNumber(instance.getTemplateVersionNumber());
    return obj;
}
#end_block

#method_before
private MapSqlParameterSource getFullParameterSource(VmStatic vm) {
    return getIdParamterSource(vm.getId()).addValue("description", vm.getDescription()).addValue("free_text_comment", vm.getComment()).addValue("mem_size_mb", vm.getMemSizeMb()).addValue("os", vm.getOsId()).addValue("vds_group_id", vm.getVdsGroupId()).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("domain", vm.getDomain()).addValue("creation_date", vm.getCreationDate()).addValue("num_of_monitors", vm.getNumOfMonitors()).addValue("single_qxl_pci", vm.getSingleQxlPci()).addValue("is_initialized", vm.isInitialized()).addValue("num_of_sockets", vm.getNumOfSockets()).addValue("cpu_per_socket", vm.getCpuPerSocket()).addValue("usb_policy", vm.getUsbPolicy()).addValue("time_zone", vm.getTimeZone()).addValue("auto_startup", vm.isAutoStartup()).addValue("is_stateless", vm.isStateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("sso_method", vm.getSsoMethod().toString()).addValue("dedicated_vm_for_vds", vm.getDedicatedVmForVds()).addValue("fail_back", vm.isFailBack()).addValue("vm_type", vm.getVmType()).addValue("nice_level", vm.getNiceLevel()).addValue("cpu_shares", vm.getCpuShares()).addValue("default_boot_sequence", vm.getDefaultBootSequence()).addValue("default_display_type", vm.getDefaultDisplayType()).addValue("priority", vm.getPriority()).addValue("iso_path", vm.getIsoPath()).addValue("origin", vm.getOrigin()).addValue("initrd_url", vm.getInitrdUrl()).addValue("kernel_url", vm.getKernelUrl()).addValue("kernel_params", vm.getKernelParams()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.isAllowConsoleReconnect()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("tunnel_migration", vm.getTunnelMigration()).addValue("vnc_keyboard_layout", vm.getVncKeyboardLayout()).addValue("is_run_and_pause", vm.isRunAndPause()).addValue("created_by_user_id", vm.getCreatedByUserId()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId()).addValue("original_template_name", vm.getOriginalTemplateName()).addValue("original_template_id", vm.getOriginalTemplateGuid()).addValue("template_version", vm.getTemplateVersion());
}
#method_after
private MapSqlParameterSource getFullParameterSource(VmStatic vm) {
    return getIdParamterSource(vm.getId()).addValue("description", vm.getDescription()).addValue("free_text_comment", vm.getComment()).addValue("mem_size_mb", vm.getMemSizeMb()).addValue("os", vm.getOsId()).addValue("vds_group_id", vm.getVdsGroupId()).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("domain", vm.getDomain()).addValue("creation_date", vm.getCreationDate()).addValue("num_of_monitors", vm.getNumOfMonitors()).addValue("single_qxl_pci", vm.getSingleQxlPci()).addValue("is_initialized", vm.isInitialized()).addValue("num_of_sockets", vm.getNumOfSockets()).addValue("cpu_per_socket", vm.getCpuPerSocket()).addValue("usb_policy", vm.getUsbPolicy()).addValue("time_zone", vm.getTimeZone()).addValue("auto_startup", vm.isAutoStartup()).addValue("is_stateless", vm.isStateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("sso_method", vm.getSsoMethod().toString()).addValue("dedicated_vm_for_vds", vm.getDedicatedVmForVds()).addValue("fail_back", vm.isFailBack()).addValue("vm_type", vm.getVmType()).addValue("nice_level", vm.getNiceLevel()).addValue("cpu_shares", vm.getCpuShares()).addValue("default_boot_sequence", vm.getDefaultBootSequence()).addValue("default_display_type", vm.getDefaultDisplayType()).addValue("priority", vm.getPriority()).addValue("iso_path", vm.getIsoPath()).addValue("origin", vm.getOrigin()).addValue("initrd_url", vm.getInitrdUrl()).addValue("kernel_url", vm.getKernelUrl()).addValue("kernel_params", vm.getKernelParams()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.isAllowConsoleReconnect()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("tunnel_migration", vm.getTunnelMigration()).addValue("vnc_keyboard_layout", vm.getVncKeyboardLayout()).addValue("is_run_and_pause", vm.isRunAndPause()).addValue("created_by_user_id", vm.getCreatedByUserId()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId()).addValue("original_template_name", vm.getOriginalTemplateName()).addValue("original_template_id", vm.getOriginalTemplateGuid()).addValue("template_version_number", vm.getTemplateVersionNumber());
}
#end_block

#method_before
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setOsId(rs.getInt("os"));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setPriority(rs.getInt("priority"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setCreatedByUserId(Guid.createGuidFromString(rs.getString("created_by_user_id")));
    entity.setTemplateVersion(rs.getInt("template_version"));
}
#method_after
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setOsId(rs.getInt("os"));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setPriority(rs.getInt("priority"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setCreatedByUserId(Guid.createGuidFromString(rs.getString("created_by_user_id")));
    entity.setTemplateVersionNumber(rs.getInt("template_version_number"));
}
#end_block

#method_before
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getDisplay());
    setDisplaySecurePort(vm.getDisplaySecurePort());
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setDisplayType(vm.getDisplayType());
    setDisplayIp(vm.getDisplayIp());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    if (SimpleDependecyInjector.getInstance().get(OsRepository.class).isLinux(getVmOsId())) {
        setUtcDiff(vm.getUtcDiff());
    }
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#method_after
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getDisplay());
    setDisplaySecurePort(vm.getDisplaySecurePort());
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setDisplayType(vm.getDisplayType());
    getDynamicData().setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setDisplayIp(vm.getDisplayIp());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    if (SimpleDependecyInjector.getInstance().get(OsRepository.class).isLinux(getVmOsId())) {
        setUtcDiff(vm.getUtcDiff());
    }
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    entity.setTemplateVersion((Integer) rs.getObject("template_version"));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setDefaultVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    entity.setTemplateVersionNumber((Integer) rs.getObject("template_version_number"));
    return entity;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (getParameters().getBaseTemplateId() == null) {
        getParameters().setbaseTemplateId(getVmTemplateId());
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), false);
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), false);
            }
            setSucceeded(true);
            return null;
        }
    });
    VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (getParameters().getBaseTemplateId() == null) {
        getParameters().setBaseTemplateId(getVmTemplateId());
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), false);
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getVm().isBalloonEnabled(), false);
            }
            setSucceeded(true);
            return null;
        }
    });
    VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    if (getParameters().getBaseTemplateId() != null) {
        VmTemplate baseTemplate = getVmTemplateDAO().get(getParameters().getBaseTemplateId());
        if (baseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!baseTemplate.getBaseTemplateId().equals(baseTemplate.getId())) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    if (getParameters().getBaseTemplateId() != null) {
        VmTemplate userSelectedBaseTemplate = getVmTemplateDAO().get(getParameters().getBaseTemplateId());
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.getBaseTemplateId().equals(userSelectedBaseTemplate.getId())) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getDomain(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getBaseTemplateId()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getDomain(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#end_block

#method_before
@Test
public void testPosixDcAndMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_1);
    storagePool.setIsLocal(false);
    assertTrue(validator.isDcMatchingPosixCompatiblityVersion().isValid());
}
#method_after
@Test
public void testPosixDcAndMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_1);
    storagePool.setIsLocal(false);
    assertTrue(validator.isPosixSupportedInDC().isValid());
}
#end_block

#method_before
@Test
public void testPosixDcAndNotMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_0);
    storagePool.setIsLocal(false);
    ValidationResult result = validator.isDcMatchingPosixCompatiblityVersion();
    assertFalse(result.isValid());
    assertMessage(result, VdcBllMessages.DATA_CENTER_POSIX_STORAGE_NOT_SUPPORTED_IN_CURRENT_VERSION);
}
#method_after
@Test
public void testPosixDcAndNotMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_0);
    storagePool.setIsLocal(false);
    ValidationResult result = validator.isPosixSupportedInDC();
    assertFalse(result.isValid());
    assertMessage(result, VdcBllMessages.DATA_CENTER_POSIX_STORAGE_NOT_SUPPORTED_IN_CURRENT_VERSION);
}
#end_block

#method_before
@Test
public void testGlusterDcAndMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_3);
    storagePool.setIsLocal(false);
    assertTrue(validator.isDcMatchingGlusterCompatiblityVersion().isValid());
}
#method_after
@Test
public void testGlusterDcAndMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_3);
    storagePool.setIsLocal(false);
    assertTrue(validator.isGlusterSupportedInDC().isValid());
}
#end_block

#method_before
@Test
public void testGlusterDcAndNotMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_1);
    storagePool.setIsLocal(false);
    ValidationResult result = validator.isDcMatchingGlusterCompatiblityVersion();
    assertFalse(result.isValid());
    assertMessage(result, VdcBllMessages.DATA_CENTER_GLUSTER_STORAGE_NOT_SUPPORTED_IN_CURRENT_VERSION);
}
#method_after
@Test
public void testGlusterDcAndNotMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_1);
    storagePool.setIsLocal(false);
    ValidationResult result = validator.isGlusterSupportedInDC();
    assertFalse(result.isValid());
    assertMessage(result, VdcBllMessages.DATA_CENTER_GLUSTER_STORAGE_NOT_SUPPORTED_IN_CURRENT_VERSION);
}
#end_block

#method_before
@Test
public void testLocalDcAndMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_0);
    storagePool.setIsLocal(true);
    assertTrue(validator.isDcMatchingPosixCompatiblityVersion().isValid());
}
#method_after
@Test
public void testLocalDcAndMatchingCompatiblityVersion() {
    storagePool.setcompatibility_version(Version.v3_0);
    storagePool.setIsLocal(true);
    assertTrue(validator.isPosixSupportedInDC().isValid());
}
#end_block

#method_before
private void updateScanAlignmentEnabled() {
    if (getSelectedItem() == null) {
        setIsScanAlignmentEnabled(false);
        return;
    }
    final VM vm = getEntity();
    AsyncDataProvider.getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            VmDiskListModel model = (VmDiskListModel) target;
            StoragePool dataCenter = (StoragePool) returnValue;
            Version minClusterVersion = vm.getVdsGroupCompatibilityVersion();
            Version minDcVersion = dataCenter.getcompatibility_version();
            AsyncDataProvider.isCommandCompatible(new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    VmDiskListModel model = (VmDiskListModel) target;
                    boolean isCommandCompatible = (Boolean) returnValue;
                    if (!isCommandCompatible || model.getSelectedItem() == null) {
                        model.setIsScanAlignmentEnabled(false);
                        return;
                    }
                    if (((Disk) model.getSelectedItem()).getDiskStorageType() == DiskStorageType.LUN) {
                        model.setIsScanAlignmentEnabled(true);
                        return;
                    }
                    DiskImage diskImage = (DiskImage) getSelectedItem();
                    AsyncDataProvider.getStorageDomainById(new AsyncQuery(model, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object target, Object returnValue) {
                            VmDiskListModel model = (VmDiskListModel) target;
                            model.setIsScanAlignmentEnabled(((StorageDomain) returnValue).getStorageType().isBlockDomain());
                        }
                    }), diskImage.getStorageIds().get(0));
                }
            }), VdcActionType.GetDiskAlignment, minClusterVersion, minDcVersion);
        }
    }), vm.getStoragePoolId());
}
#method_after
private void updateScanAlignmentEnabled() {
    if (getSelectedItem() == null) {
        setIsScanAlignmentEnabled(false);
        return;
    }
    setIsScanAlignmentEnabled((getSelectedItem() instanceof LunDisk || isDiskOnBlockDevice((Disk) getSelectedItem())));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateQuotaCache();
    if (_oldStoragePool.getStatus() == StoragePoolStatus.Up && getMasterDomain() != null) {
        if (!StringUtils.equals(_oldStoragePool.getName(), getStoragePool().getName())) {
            runVdsCommand(VDSCommandType.SetStoragePoolDescription, new SetStoragePoolDescriptionVDSCommandParameters(getStoragePool().getId(), getStoragePool().getName()));
        }
    }
    copyUnchangedStoragePoolProperties(getStoragePool(), _oldStoragePool);
    getStoragePoolDAO().updatePartial(getStoragePool());
    updateStoragePoolFormatType();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    updateQuotaCache();
    if (_oldStoragePool.getStatus() == StoragePoolStatus.Up) {
        if (!StringUtils.equals(_oldStoragePool.getName(), getStoragePool().getName())) {
            runVdsCommand(VDSCommandType.SetStoragePoolDescription, new SetStoragePoolDescriptionVDSCommandParameters(getStoragePool().getId(), getStoragePool().getName()));
        }
    }
    copyUnchangedStoragePoolProperties(getStoragePool(), _oldStoragePool);
    getStoragePoolDAO().updatePartial(getStoragePool());
    updateStoragePoolFormatType();
    setSucceeded(true);
}
#end_block

#method_before
private void updateStoragePoolFormatType() {
    final StoragePool storagePool = getStoragePool();
    final Guid spId = storagePool.getId();
    final Version spVersion = storagePool.getcompatibility_version();
    final Version oldSpVersion = _oldStoragePool.getcompatibility_version();
    if (oldSpVersion.equals(spVersion)) {
        return;
    }
    final StorageFormatType targetFormat = VersionStorageFormatUtil.getPreferredForVersion(spVersion, getMasterDomain() == null ? null : getMasterDomain().getStorageType());
    storagePool.setStoragePoolFormatType(targetFormat);
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getStoragePoolDAO().updatePartial(storagePool);
            if (getMasterDomain() != null) {
                updateMemberDomainsFormat(targetFormat);
            }
            return null;
        }
    });
    if (_oldStoragePool.getStatus() == StoragePoolStatus.Up && getMasterDomain() != null) {
        try {
            // No need to worry about "reupgrading" as VDSM will silently ignore
            // the request.
            runVdsCommand(VDSCommandType.UpgradeStoragePool, new UpgradeStoragePoolVDSCommandParameters(spId, targetFormat));
        } catch (VdcBLLException e) {
            log.warnFormat("Upgrade procees of Storage Pool {0} has encountered a problem due to following reason: {1}", spId, e.getMessage());
            AuditLogDirector.log(this, AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS);
        }
    }
}
#method_after
private void updateStoragePoolFormatType() {
    final StoragePool storagePool = getStoragePool();
    final Guid spId = storagePool.getId();
    final Version spVersion = storagePool.getcompatibility_version();
    final Version oldSpVersion = _oldStoragePool.getcompatibility_version();
    if (oldSpVersion.equals(spVersion)) {
        return;
    }
    final StorageFormatType targetFormat = VersionStorageFormatUtil.getPreferredForVersion(spVersion, getMasterDomain() == null ? null : getMasterDomain().getStorageType());
    storagePool.setStoragePoolFormatType(targetFormat);
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getStoragePoolDAO().updatePartial(storagePool);
            updateMemberDomainsFormat(targetFormat);
            return null;
        }
    });
    if (_oldStoragePool.getStatus() == StoragePoolStatus.Up) {
        try {
            // No need to worry about "reupgrading" as VDSM will silently ignore
            // the request.
            runVdsCommand(VDSCommandType.UpgradeStoragePool, new UpgradeStoragePoolVDSCommandParameters(spId, targetFormat));
        } catch (VdcBLLException e) {
            log.warnFormat("Upgrade procees of Storage Pool {0} has encountered a problem due to following reason: {1}", spId, e.getMessage());
            AuditLogDirector.log(this, AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS);
        }
    }
}
#end_block

#method_before
private static StoragePool createNewStoragePool() {
    StoragePool pool = createBasicPool();
    pool.setcompatibility_version(VERSION_1_1);
    return pool;
}
#method_after
private static StoragePool createNewStoragePool() {
    StoragePool pool = createBasicPool();
    pool.setIsLocal(false);
    pool.setcompatibility_version(VERSION_1_1);
    return pool;
}
#end_block

#method_before
public static StoragePool buildStoragePool(Map<String, Object> xmlRpcStruct) {
    StoragePool sPool = new StoragePool();
    sPool.setName(AssignStringValue(xmlRpcStruct, "name"));
    Integer masterVersion = AssignIntValue(xmlRpcStruct, "master_ver");
    if (masterVersion != null) {
        sPool.setmaster_domain_version(masterVersion);
    }
    return sPool;
}
#method_after
public static StoragePool buildStoragePool(Map<String, Object> xmlRpcStruct) {
    StoragePool sPool = new StoragePool();
    if (xmlRpcStruct.containsKey("type")) {
        sPool.setIsLocal(StorageType.valueOf(xmlRpcStruct.get("type").toString()).isLocal());
    }
    sPool.setName(AssignStringValue(xmlRpcStruct, "name"));
    Integer masterVersion = AssignIntValue(xmlRpcStruct, "master_ver");
    if (masterVersion != null) {
        sPool.setmaster_domain_version(masterVersion);
    }
    return sPool;
}
#end_block

#method_before
protected boolean isStorageDomainTypeCorrect(StorageDomain storageDomain) {
    return storageDomain.isLocal() == getStoragePool().isLocal();
}
#method_after
protected boolean isStorageDomainTypeCorrect(StorageDomain storageDomain) {
    if (storageDomain.isLocal() != getStoragePool().isLocal()) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_ATTACH_STORAGE_DOMAIN_STORAGE_TYPE_NOT_MATCH);
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean checkDomainCanBeAttached(StorageDomain storageDomain) {
    return checkStorageDomainType(storageDomain) && isStorageDomainFormatCorrectForPool(storageDomain, getStoragePool()) && checkStorageDomainSharedStatusNotLocked(storageDomain) && ((storageDomain.getStorageDomainType() == StorageDomainType.ISO || storageDomain.getStorageDomainType() == StorageDomainType.ImportExport) || isStorageDomainNotInPool(storageDomain)) && isStorageDomainTypeCorrect(storageDomain) && isStorageDomainTypeCompatibleWithPool(storageDomain) && (isMixedTypesAllowedOnPool() || !isStoragePoolContainsOtherTypes(storageDomain));
}
#method_after
protected boolean checkDomainCanBeAttached(StorageDomain storageDomain) {
    if (!validateAmountOfIsoAndExportDomainsInDC(storageDomain)) {
        return false;
    }
    if (!isStorageDomainFormatCorrectForDC(storageDomain, getStoragePool())) {
        return false;
    }
    if (!checkStorageDomainSharedStatusNotLocked(storageDomain)) {
        return false;
    }
    if (!(isStorageDomainOfTypeIsoOrExport(storageDomain) || isStorageDomainNotInPool(storageDomain))) {
        return false;
    }
    if (!isStorageDomainTypeCorrect(storageDomain)) {
        return false;
    }
    if (!isStorageDomainCompatibleWithDC(storageDomain)) {
        return false;
    }
    if (!isMixedTypesAllowedInDC() && isMixedTypeDC(storageDomain)) {
        return false;
    }
    return true;
}
#end_block

#method_before
public boolean isLocal() {
    return isLocal;
}
#method_after
public boolean isLocal() {
    return local;
}
#end_block

#method_before
public void setIsLocal(boolean isLocal) {
    this.isLocal = isLocal;
}
#method_after
public void setIsLocal(boolean isLocal) {
    this.local = isLocal;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((LVER == null) ? 0 : LVER.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((comment == null) ? 0 : comment.hashCode());
    result = prime * result + ((compatibilityVersion == null) ? 0 : compatibilityVersion.hashCode());
    result = prime * result + masterDomainVersion;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((recovery_mode == null) ? 0 : recovery_mode.hashCode());
    result = prime * result + ((spmVdsId == null) ? 0 : spmVdsId.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + ((storagePoolFormatType == null) ? 0 : storagePoolFormatType.hashCode());
    result = prime * result + ((quotaEnforcementType == null) ? 0 : quotaEnforcementType.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((LVER == null) ? 0 : LVER.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((comment == null) ? 0 : comment.hashCode());
    result = prime * result + ((compatibilityVersion == null) ? 0 : compatibilityVersion.hashCode());
    result = prime * result + masterDomainVersion;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((recovery_mode == null) ? 0 : recovery_mode.hashCode());
    result = prime * result + ((spmVdsId == null) ? 0 : spmVdsId.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + (local ? 1231 : 1237);
    result = prime * result + ((storagePoolFormatType == null) ? 0 : storagePoolFormatType.hashCode());
    result = prime * result + ((quotaEnforcementType == null) ? 0 : quotaEnforcementType.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    StoragePool other = (StoragePool) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(LVER, other.LVER) && ObjectUtils.objectsEqual(description, other.description) && ObjectUtils.objectsEqual(comment, other.comment) && ObjectUtils.objectsEqual(getcompatibility_version(), other.getcompatibility_version()) && masterDomainVersion == other.masterDomainVersion && ObjectUtils.objectsEqual(name, other.name) && recovery_mode == other.recovery_mode && ObjectUtils.objectsEqual(spmVdsId, other.spmVdsId) && status == other.status && ObjectUtils.objectsEqual(storagePoolFormatType, other.storagePoolFormatType) && quotaEnforcementType == other.quotaEnforcementType);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    StoragePool other = (StoragePool) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(LVER, other.LVER) && ObjectUtils.objectsEqual(description, other.description) && ObjectUtils.objectsEqual(comment, other.comment) && ObjectUtils.objectsEqual(getcompatibility_version(), other.getcompatibility_version()) && masterDomainVersion == other.masterDomainVersion && ObjectUtils.objectsEqual(name, other.name) && recovery_mode == other.recovery_mode && ObjectUtils.objectsEqual(spmVdsId, other.spmVdsId) && status == other.status && local == other.local && ObjectUtils.objectsEqual(storagePoolFormatType, other.storagePoolFormatType) && quotaEnforcementType == other.quotaEnforcementType);
}
#end_block

#method_before
@Override
protected DataCenter postPopulate(DataCenter model) {
    model.setLocal(new Random().nextBoolean());
    model.setStorageFormat(MappingTestHelper.shuffle(StorageFormat.class).value());
    return model;
}
#method_after
@Override
protected DataCenter postPopulate(DataCenter model) {
    model.setStorageFormat(MappingTestHelper.shuffle(StorageFormat.class).value());
    return model;
}
#end_block

#method_before
public boolean isLocal() {
    return getStorageType() == StorageType.LOCALFS;
}
#method_after
public boolean isLocal() {
    return getStorageType().isLocal();
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new DataCenterStorageListModel());
    list.add(new DataCenterNetworkListModel());
    list.add(new DataCenterClusterListModel());
    quotaListModel = new DataCenterQuotaListModel();
    quotaListModel.setIsAvailable(false);
    list.add(quotaListModel);
    list.add(new DataCenterNetworkQoSListModel());
    list.add(new PermissionListModel());
    list.add(new DataCenterEventListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new DataCenterStorageListModel());
    iscsiBondListModel = new DataCenterIscsiBondListModel();
    list.add(iscsiBondListModel);
    list.add(new DataCenterNetworkListModel());
    list.add(new DataCenterClusterListModel());
    quotaListModel = new DataCenterQuotaListModel();
    quotaListModel.setIsAvailable(false);
    list.add(quotaListModel);
    list.add(new DataCenterNetworkQoSListModel());
    list.add(new PermissionListModel());
    list.add(new DataCenterEventListModel());
    setDetailModels(list);
}
#end_block

#method_before
public void onSave() {
    final DataCenterModel dcModel = (DataCenterModel) getWindow();
    if (!dcModel.validate()) {
        return;
    }
    if ((dcModel.getIsNew() || dcModel.getEntity() == null) && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        promptNoQuotaInDCMessage();
    } else if (!dcModel.getIsNew() && getSelectedItem() != null && !dcModel.getVersion().getSelectedItem().equals(((StoragePool) getSelectedItem()).getcompatibility_version())) {
        final ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDataCenterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_data_center_compatibility_version");
        final StoragePool sp = (StoragePool) getSelectedItem();
        startProgress(null);
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object ReturnValue) {
                List<StorageDomain> storages = (List<StorageDomain>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                StorageDomain storage = null;
                for (StorageDomain sd : storages) {
                    if (sd.getStorageDomainType() == StorageDomainType.Master || sd.getStorageDomainType() == StorageDomainType.Data) {
                        storage = sd;
                    }
                }
                StorageFormatType newFormat = null;
                StorageFormatType oldFormat = null;
                if (storage != null) {
                    newFormat = VersionStorageFormatUtil.getPreferredForVersion(dcModel.getVersion().getSelectedItem(), storage.getStorageType());
                    oldFormat = VersionStorageFormatUtil.getPreferredForVersion(sp.getcompatibility_version(), storage.getStorageType());
                }
                if (newFormat == oldFormat) {
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionMsg());
                } else {
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionWithUpgradeMsg());
                }
                ((DataCenterListModel) model).stopProgress();
            }
        };
        IdQueryParameters params = new IdQueryParameters(sp.getId());
        Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, params, _asyncQuery);
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveInternal", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        confirmModel.getCommands().add(tempVar2);
    } else if (getSelectedItem() != null && ((StoragePool) getSelectedItem()).getQuotaEnforcementType() != QuotaEnforcementTypeEnum.HARD_ENFORCEMENT && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        checkForQuotaInDC(dcModel.getEntity(), this);
    } else {
        onSaveInternal();
    }
}
#method_after
public void onSave() {
    final DataCenterModel dcModel = (DataCenterModel) getWindow();
    if (!dcModel.validate()) {
        return;
    }
    if ((dcModel.getIsNew() || dcModel.getEntity() == null) && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        promptNoQuotaInDCMessage();
    } else if (!dcModel.getIsNew() && getSelectedItem() != null && !dcModel.getVersion().getSelectedItem().equals(((StoragePool) getSelectedItem()).getcompatibility_version())) {
        final ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDataCenterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_data_center_compatibility_version");
        final StoragePool sp = (StoragePool) getSelectedItem();
        startProgress(null);
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object ReturnValue) {
                List<StorageDomain> storages = (List<StorageDomain>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                StorageDomain storage = null;
                for (StorageDomain sd : storages) {
                    if (sd.getStorageDomainType().isDataDomain()) {
                        storage = sd;
                    }
                }
                StorageFormatType newFormat = null;
                StorageFormatType oldFormat = null;
                if (storage != null) {
                    newFormat = VersionStorageFormatUtil.getPreferredForVersion(dcModel.getVersion().getSelectedItem(), storage.getStorageType());
                    oldFormat = VersionStorageFormatUtil.getPreferredForVersion(sp.getcompatibility_version(), storage.getStorageType());
                }
                if (newFormat == oldFormat) {
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionMsg());
                } else {
                    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionWithUpgradeMsg());
                }
                ((DataCenterListModel) model).stopProgress();
            }
        };
        IdQueryParameters params = new IdQueryParameters(sp.getId());
        Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, params, _asyncQuery);
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveInternal", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        confirmModel.getCommands().add(tempVar2);
    } else if (getSelectedItem() != null && ((StoragePool) getSelectedItem()).getQuotaEnforcementType() != QuotaEnforcementTypeEnum.HARD_ENFORCEMENT && dcModel.getQuotaEnforceTypeListModel().getSelectedItem() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        checkForQuotaInDC(dcModel.getEntity(), this);
    } else {
        onSaveInternal();
    }
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    if (getSelectedItem() != null && ((StoragePool) getSelectedItem()).getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        quotaListModel.setIsAvailable(true);
    } else {
        quotaListModel.setIsAvailable(false);
    }
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    if (getSelectedItem() != null) {
        StoragePool storagePool = (StoragePool) getSelectedItem();
        quotaListModel.setIsAvailable(storagePool.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED);
        updateIscsiBondListAvailability(storagePool);
    }
}
#end_block

#method_before
@Override
public void save(StoragePool pool) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", pool.getdescription()).addValue("free_text_comment", pool.getComment()).addValue("id", pool.getId()).addValue("is_local", pool.isLocal()).addValue("name", pool.getName()).addValue("status", pool.getStatus()).addValue("master_domain_version", pool.getmaster_domain_version()).addValue("spm_vds_id", pool.getspm_vds_id()).addValue("quota_enforcement_type", pool.getQuotaEnforcementType()).addValue("compatibility_version", pool.getcompatibility_version());
    getCallsHandler().executeModification("Insertstorage_pool", parameterSource);
}
#method_after
@Override
public void save(StoragePool pool) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", pool.getdescription()).addValue("free_text_comment", pool.getComment()).addValue("id", pool.getId()).addValue("name", pool.getName()).addValue("is_local", pool.isLocal()).addValue("status", pool.getStatus()).addValue("master_domain_version", pool.getmaster_domain_version()).addValue("spm_vds_id", pool.getspm_vds_id()).addValue("quota_enforcement_type", pool.getQuotaEnforcementType()).addValue("compatibility_version", pool.getcompatibility_version());
    getCallsHandler().executeModification("Insertstorage_pool", parameterSource);
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    return vm;
}
#end_block

#method_before
private static StoragePool cloneStorage_pool(StoragePool instance) {
    StoragePool obj = new StoragePool();
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setStatus(instance.getStatus());
    obj.setmaster_domain_version(instance.getmaster_domain_version());
    obj.setLVER(instance.getLVER());
    obj.setrecovery_mode(instance.getrecovery_mode());
    obj.setspm_vds_id(instance.getspm_vds_id());
    obj.setcompatibility_version(instance.getcompatibility_version());
    return obj;
}
#method_after
private static StoragePool cloneStorage_pool(StoragePool instance) {
    StoragePool obj = new StoragePool();
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setIsLocal(instance.isLocal());
    obj.setStatus(instance.getStatus());
    obj.setmaster_domain_version(instance.getmaster_domain_version());
    obj.setLVER(instance.getLVER());
    obj.setrecovery_mode(instance.getrecovery_mode());
    obj.setspm_vds_id(instance.getspm_vds_id());
    obj.setcompatibility_version(instance.getcompatibility_version());
    return obj;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    StoragePoolValidator storagePoolValidator = new StoragePoolValidator(getStoragePool());
    if (result && !(isStoragePoolUnique(getStoragePool().getName()))) {
        result = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
    } else if (!checkStoragePoolNameLengthValid()) {
        result = false;
    } else if (!VersionSupport.checkVersionSupported(getStoragePool().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    if (result && !(isStoragePoolUnique(getStoragePool().getName()))) {
        result = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NAME_ALREADY_EXIST);
    } else if (!checkStoragePoolNameLengthValid()) {
        result = false;
    } else if (!VersionSupport.checkVersionSupported(getStoragePool().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    return result;
}
#end_block

#method_before
public static boolean isVersionMatchStorageType(Version version, boolean isLocalType) {
    if (isLocalType) {
        return version.compareTo(new Version(3, 0)) >= 0;
    } else {
        return version.compareTo(new Version(3, 0)) >= 0;
    }
}
#method_after
public static boolean isVersionMatchStorageType(Version version, boolean isLocalType) {
    return version.compareTo(new Version(3, 0)) >= 0;
}
#end_block

#method_before
public static Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    }
    return Guid.Empty;
}
#method_after
public static Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof DbGroup) {
        return ((DbGroup) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    }
    return Guid.Empty;
}
#end_block

#method_before
private static void initSeverities() {
    initDefaultSeverities();
    initProviderSeverities();
    initNetworkSeverities();
    initImportExportSeverities();
    initEngineSeverities();
    initVMsPoolSeverities();
    initBookmarkSeverities();
    initVMSeverities();
    initQuotaSeverities();
    initQoSSeverities();
    initTagSeverities();
    initClusterSeverities();
    initMLASeverities();
    initHostSeverities();
    initStorageSeverities();
    initTaskSeverities();
    initGlusterSeverities();
    initDwhSeverities();
    initConfigSeverities();
    initUserAccountSeverities();
    initCommonSeverities();
    initClusterPolicySeverities();
    initExtrnalEvents();
    initMomPoliciesSeverities();
}
#method_after
private static void initSeverities() {
    initDefaultSeverities();
    initProviderSeverities();
    initNetworkSeverities();
    initImportExportSeverities();
    initEngineSeverities();
    initVMsPoolSeverities();
    initBookmarkSeverities();
    initVMSeverities();
    initQuotaSeverities();
    initQoSSeverities();
    initTagSeverities();
    initClusterSeverities();
    initMLASeverities();
    initHostSeverities();
    initStorageSeverities();
    initTaskSeverities();
    initGlusterSeverities();
    initDwhSeverities();
    initConfigSeverities();
    initUserAccountSeverities();
    initCommonSeverities();
    initClusterPolicySeverities();
    initExtrnalEvents();
    initMomPoliciesSeverities();
    initPmPolicySeverities();
    initIscsiBondSeverities();
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOT_SET_NUMBER_OF_CPUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXCEEDED_MAXIMUM_NUM_OF_RESTART_HA_VM_ATTEMPTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_CONSOLE_CONNECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CONSOLE_DISCONNECTED, AuditLogSeverity.NORMAL);
}
#method_after
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REBOOT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REBOOT_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXCEEDED_MAXIMUM_NUM_OF_RESTART_HA_VM_ATTEMPTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_CONSOLE_CONNECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CONSOLE_DISCONNECTED, AuditLogSeverity.NORMAL);
}
#end_block

#method_before
private static void initClusterSeverities() {
    severities.put(AuditLogType.USER_ADD_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_UPDATE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_UPDATE_VDS_GROUP_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_CLUSTER_DEFAULT_HOST_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
}
#method_after
private static void initClusterSeverities() {
    severities.put(AuditLogType.USER_ADD_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_UPDATE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_UPDATE_VDS_GROUP_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_CLUSTER_DEFAULT_HOST_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CLUSTER_ALERT_HA_RESERVATION, AuditLogSeverity.ALERT);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity glusterVolume = getGlusterVolume();
    if (!glusterVolume.isOnline()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_SHOULD_BE_STARTED);
    }
    return true;
}
#end_block

#method_before
@Test
public void testGetCapacityInfo() {
    GlusterVolumeEntity volume = dao.getById(EXISTING_VOL_DIST_ID);
    assertNotNull("volume capacity info is not available", volume.getCapacityDetails());
    assertTrue(volume.getCapacityDetails().getTotalSize() == 50000);
    assertTrue(volume.getCapacityDetails().getUsedSize() == 5000);
    assertTrue(volume.getCapacityDetails().getFreeSize() == 45000);
    assertNotNull(volume.getCapacityDetails().getUpdatedAt());
}
#method_after
@Test
public void testGetCapacityInfo() throws ParseException {
    GlusterVolumeEntity volume = dao.getById(EXISTING_VOL_DIST_ID);
    assertNotNull("volume capacity info is not available", volume.getAdvancedDetails());
    assertTrue(volume.getAdvancedDetails().getCapacityInfo().getTotalSize() == 100000);
    assertTrue(volume.getAdvancedDetails().getCapacityInfo().getUsedSize() == 60000);
    assertTrue(volume.getAdvancedDetails().getCapacityInfo().getFreeSize() == 40000);
    assertTrue(EXPECTED_DATE_FORMAT.parse(volume.getAdvancedDetails().getUpdatedAt().toString()).equals(EXPECTED_DATE_FORMAT.parse("2014-01-21 18:12:33")));
}
#end_block

#method_before
private void fetchRelatedEntities(GlusterVolumeEntity volume) {
    if (volume != null) {
        volume.setOptions(dbFacade.getGlusterOptionDao().getOptionsOfVolume(volume.getId()));
        volume.setAccessProtocols(new HashSet<AccessProtocol>(getAccessProtocolsOfVolume(volume.getId())));
        volume.setTransportTypes(new HashSet<TransportType>(getTransportTypesOfVolume(volume.getId())));
        volume.setCapacityDetails(fetchCapacityDatails(volume.getId()));
        GlusterAsyncTask asyncTask = getAsyncTaskOfVolume(volume.getId());
        if (asyncTask != null) {
            volume.setAsyncTask(asyncTask);
        }
        List<GlusterBrickEntity> bricks = dbFacade.getGlusterBrickDao().getBricksOfVolume(volume.getId());
        if (volume.getAsyncTask() != null && volume.getAsyncTask().getTaskId() != null) {
            for (GlusterBrickEntity brick : bricks) {
                if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volume.getAsyncTask().getTaskId())) {
                    brick.setAsyncTask(volume.getAsyncTask());
                }
            }
        }
        volume.setBricks(bricks);
    }
}
#method_after
private void fetchRelatedEntities(GlusterVolumeEntity volume) {
    if (volume != null) {
        volume.setOptions(dbFacade.getGlusterOptionDao().getOptionsOfVolume(volume.getId()));
        volume.setAccessProtocols(new HashSet<AccessProtocol>(getAccessProtocolsOfVolume(volume.getId())));
        volume.setTransportTypes(new HashSet<TransportType>(getTransportTypesOfVolume(volume.getId())));
        GlusterVolumeAdvancedDetails advancedDetails = fetchAdvancedDatails(volume.getId());
        if (advancedDetails != null) {
            volume.setAdvancedDetails(advancedDetails);
        }
        GlusterAsyncTask asyncTask = getAsyncTaskOfVolume(volume.getId());
        if (asyncTask != null) {
            volume.setAsyncTask(asyncTask);
        }
        List<GlusterBrickEntity> bricks = dbFacade.getGlusterBrickDao().getBricksOfVolume(volume.getId());
        if (volume.getAsyncTask() != null && volume.getAsyncTask().getTaskId() != null) {
            for (GlusterBrickEntity brick : bricks) {
                if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volume.getAsyncTask().getTaskId())) {
                    brick.setAsyncTask(volume.getAsyncTask());
                }
            }
        }
        volume.setBricks(bricks);
    }
}
#end_block

#method_before
@Override
public void updateVolumeCapacityInfo(GlusterVolumeSizeInfo volumeCapacityInfo) {
    getCallsHandler().executeModification("UpdateGlusterVolumeCapacityInfo", getCustomMapSqlParameterSource().addValue("id", volumeCapacityInfo.getVolumeId()).addValue("total_space", volumeCapacityInfo.getTotalSize()).addValue("used_space", volumeCapacityInfo.getUsedSize()).addValue("free_space", volumeCapacityInfo.getFreeSize()));
}
#method_after
@Override
public void updateVolumeCapacityInfo(GlusterVolumeSizeInfo volumeCapacityInfo) {
    getCallsHandler().executeModification("UpdateGlusterVolumeDetails", createCapacityInfoParas(volumeCapacityInfo));
}
#end_block

#method_before
private Map<Guid, GlusterVolumeEntity> fetchVolumes(VDS upServer, List<VDS> existingServers) {
    Map<Guid, GlusterVolumeEntity> fetchedVolumes = null;
    while (fetchedVolumes == null && existingServers.size() > 0) {
        fetchedVolumes = fetchVolumes(upServer);
        if (fetchedVolumes == null) {
            // Couldn't fetch volumes from the up server. Mark it as non-operational
            logUtil.logServerMessage(upServer, AuditLogType.GLUSTER_VOLUME_INFO_FAILED);
            setNonOperational(upServer);
            existingServers.remove(upServer);
            upServer = getNewUpServer(existingServers, upServer);
        }
    }
    if (fetchedVolumes != null && !fetchedVolumes.isEmpty()) {
        fetchVolumeCapacityInfo(fetchedVolumes, upServer);
    }
    return fetchedVolumes;
}
#method_after
private Map<Guid, GlusterVolumeEntity> fetchVolumes(VDS upServer, List<VDS> existingServers) {
    Map<Guid, GlusterVolumeEntity> fetchedVolumes = null;
    while (fetchedVolumes == null && existingServers.size() > 0) {
        fetchedVolumes = fetchVolumes(upServer);
        if (fetchedVolumes == null) {
            // Couldn't fetch volumes from the up server. Mark it as non-operational
            logUtil.logServerMessage(upServer, AuditLogType.GLUSTER_VOLUME_INFO_FAILED);
            setNonOperational(upServer);
            existingServers.remove(upServer);
            upServer = getNewUpServer(existingServers, upServer);
        }
    }
    return fetchedVolumes;
}
#end_block

#method_before
private void updateVolume(GlusterVolumeEntity existingVolume, GlusterVolumeEntity fetchedVolume) {
    updateVolumeProperties(existingVolume, fetchedVolume);
    updateVolumeCapacityInfo(existingVolume, fetchedVolume);
    updateBricks(existingVolume, fetchedVolume);
    updateOptions(existingVolume, fetchedVolume);
    updateTransportTypes(existingVolume, fetchedVolume);
}
#method_after
private void updateVolume(GlusterVolumeEntity existingVolume, GlusterVolumeEntity fetchedVolume) {
    updateVolumeProperties(existingVolume, fetchedVolume);
    updateBricks(existingVolume, fetchedVolume);
    updateOptions(existingVolume, fetchedVolume);
    updateTransportTypes(existingVolume, fetchedVolume);
}
#end_block

#method_before
private void refreshClusterHeavyWeightData(VDSGroup cluster) {
    VDS upServer = getClusterUtils().getRandomUpServer(cluster.getId());
    if (upServer == null) {
        log.debugFormat("No server UP in cluster {0}. Can't refresh it's data at this point.", cluster.getName());
        return;
    }
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(cluster.getId())) {
        log.debugFormat("Refreshing brick statuses for volume {0} of cluster {1}", volume.getName(), cluster.getName());
        // brick statuses can be fetched only for started volumes
        if (volume.isOnline()) {
            acquireLock(cluster.getId());
            try {
                refreshBrickStatuses(upServer, volume);
            } catch (Exception e) {
                log.errorFormat("Error while refreshing brick statuses for volume {0} of cluster {1}", volume.getName(), cluster.getName(), e);
            } finally {
                releaseLock(cluster.getId());
            }
        }
    }
}
#method_after
private void refreshClusterHeavyWeightData(VDSGroup cluster) {
    VDS upServer = getClusterUtils().getRandomUpServer(cluster.getId());
    if (upServer == null) {
        log.debugFormat("No server UP in cluster {0}. Can't refresh it's data at this point.", cluster.getName());
        return;
    }
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(cluster.getId())) {
        log.debugFormat("Refreshing brick statuses for volume {0} of cluster {1}", volume.getName(), cluster.getName());
        // brick statuses can be fetched only for started volumes
        if (volume.isOnline()) {
            acquireLock(cluster.getId());
            try {
                refreshVolumeDetails(upServer, volume);
            } catch (Exception e) {
                log.errorFormat("Error while refreshing brick statuses for volume {0} of cluster {1}", volume.getName(), cluster.getName(), e);
            } finally {
                releaseLock(cluster.getId());
            }
        }
    }
}
#end_block

#method_before
protected GlusterVolumeAdvancedDetails getVolumeAdvancedDetails(VDS upServer, Guid clusterId, String volumeName) {
    VDSReturnValue result = runVdsCommand(VDSCommandType.GetGlusterVolumeAdvancedDetails, new GlusterVolumeAdvancedDetailsVDSParameters(upServer.getId(), clusterId, volumeName, null, false));
    return result.getSucceeded() ? (GlusterVolumeAdvancedDetails) result.getReturnValue() : null;
}
#method_after
protected GlusterVolumeAdvancedDetails getVolumeAdvancedDetails(VDS upServer, Guid clusterId, String volumeName) {
    VDSReturnValue result = runVdsCommand(VDSCommandType.GetGlusterVolumeAdvancedDetails, new GlusterVolumeAdvancedDetailsVDSParameters(upServer.getId(), clusterId, volumeName, null, false, true));
    return result.getSucceeded() ? (GlusterVolumeAdvancedDetails) result.getReturnValue() : null;
}
#end_block

#method_before
private GlusterVolumeEntity createDistVol(String volName, Guid volId) {
    GlusterVolumeEntity vol = createVolume(volName, volId);
    vol.addBrick(createBrick(volId, existingServer1, DIST_BRICK_D1));
    vol.addBrick(createBrick(volId, existingServer1, DIST_BRICK_D2));
    existingVolumes.add(vol);
    return vol;
}
#method_after
private GlusterVolumeEntity createDistVol(String volName, Guid volId) {
    GlusterVolumeEntity vol = createVolume(volName, volId);
    vol.getAdvancedDetails().setCapacityInfo(getCapacityInfo(volId));
    vol.addBrick(createBrick(volId, existingServer1, DIST_BRICK_D1));
    vol.addBrick(createBrick(volId, existingServer1, DIST_BRICK_D2));
    existingVolumes.add(vol);
    return vol;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void setupMocks() throws Exception {
    logUtil = Mockito.spy(GlusterAuditLogUtil.getInstance());
    glusterManager = Mockito.spy(GlusterSyncJob.getInstance());
    glusterManager.setLogUtil(logUtil);
    mockDaos();
    doReturn(clusterUtils).when(glusterManager).getClusterUtils();
    doReturn(existingServer1).when(clusterUtils).getUpServer(any(Guid.class));
    doReturn(existingServer1).when(clusterUtils).getRandomUpServer(any(Guid.class));
    doNothing().when(logUtil).logServerMessage(any(VDS.class), any(AuditLogType.class));
    doNothing().when(logUtil).logVolumeMessage(any(GlusterVolumeEntity.class), any(AuditLogType.class));
    doNothing().when(logUtil).logAuditMessage(any(Guid.class), any(GlusterVolumeEntity.class), any(VDS.class), any(AuditLogType.class), any(HashMap.class));
    doReturn(getFetchedServersList()).when(glusterManager).fetchServers(any(VDS.class));
    doReturn(getFetchedVolumesList()).when(glusterManager).fetchVolumes(any(VDS.class));
    doReturn(getVolumeAdvancedDetails(existingDistVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingDistVol.getName());
    doReturn(getVolumeAdvancedDetails(existingReplVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingReplVol.getName());
    doReturn(new VDSReturnValue()).when(glusterManager).runVdsCommand(eq(VDSCommandType.RemoveVds), argThat(isRemovedServer()));
    doReturn(getVolumeCapacityInfo()).when(glusterManager).runVdsCommand(eq(VDSCommandType.GetGlusterVolumeSizeInfo), any(GlusterVolumeVDSParameters.class));
    doNothing().when(glusterManager).acquireLock(CLUSTER_ID);
    doNothing().when(glusterManager).releaseLock(CLUSTER_ID);
    doReturn(glusterUtil).when(glusterManager).getGlusterUtil();
}
#method_after
@SuppressWarnings("unchecked")
private void setupMocks() throws Exception {
    logUtil = Mockito.spy(GlusterAuditLogUtil.getInstance());
    glusterManager = Mockito.spy(GlusterSyncJob.getInstance());
    glusterManager.setLogUtil(logUtil);
    mockDaos();
    doReturn(clusterUtils).when(glusterManager).getClusterUtils();
    doReturn(existingServer1).when(clusterUtils).getUpServer(any(Guid.class));
    doReturn(existingServer1).when(clusterUtils).getRandomUpServer(any(Guid.class));
    doNothing().when(logUtil).logServerMessage(any(VDS.class), any(AuditLogType.class));
    doNothing().when(logUtil).logVolumeMessage(any(GlusterVolumeEntity.class), any(AuditLogType.class));
    doNothing().when(logUtil).logAuditMessage(any(Guid.class), any(GlusterVolumeEntity.class), any(VDS.class), any(AuditLogType.class), any(HashMap.class));
    doReturn(getFetchedServersList()).when(glusterManager).fetchServers(any(VDS.class));
    doReturn(getFetchedVolumesList()).when(glusterManager).fetchVolumes(any(VDS.class));
    doReturn(getVolumeAdvancedDetails(existingDistVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingDistVol.getName());
    doReturn(getVolumeAdvancedDetails(existingReplVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingReplVol.getName());
    doReturn(new VDSReturnValue()).when(glusterManager).runVdsCommand(eq(VDSCommandType.RemoveVds), argThat(isRemovedServer()));
    doNothing().when(glusterManager).acquireLock(CLUSTER_ID);
    doNothing().when(glusterManager).releaseLock(CLUSTER_ID);
    doReturn(glusterUtil).when(glusterManager).getGlusterUtil();
}
#end_block

#method_before
private void verifyMocksForLightWeight() {
    InOrder inOrder = inOrder(clusterDao, vdsDao, clusterUtils, glusterManager, vdsStatisticsDao, vdsDynamicDao, vdsStaticDao, volumeDao, brickDao, optionDao);
    // all clusters fetched from db
    inOrder.verify(clusterDao, times(1)).getAll();
    // get servers of the cluster from db
    inOrder.verify(vdsDao, times(1)).getAllForVdsGroup(CLUSTER_ID);
    // get the UP server from cluster
    inOrder.verify(clusterUtils, times(1)).getUpServer(CLUSTER_ID);
    // acquire lock on the cluster
    inOrder.verify(glusterManager, times(1)).acquireLock(CLUSTER_ID);
    // servers are fetched from glusterfs
    inOrder.verify(glusterManager, times(1)).fetchServers(existingServer1);
    // detached server SERVER_ID_3 is deleted from DB
    inOrder.verify(vdsStatisticsDao, times(1)).remove(SERVER_ID_3);
    inOrder.verify(vdsDynamicDao, times(1)).remove(SERVER_ID_3);
    inOrder.verify(vdsStaticDao, times(1)).remove(SERVER_ID_3);
    // detached server SERVER_ID_3 is removed from resource manager
    inOrder.verify(glusterManager, times(1)).runVdsCommand(eq(VDSCommandType.RemoveVds), any(RemoveVdsVDSCommandParameters.class));
    // release lock on the cluster
    inOrder.verify(glusterManager, times(1)).releaseLock(CLUSTER_ID);
    // acquire lock on the cluster for next operation (refresh volumes)
    inOrder.verify(glusterManager, times(1)).acquireLock(CLUSTER_ID);
    // volumes are fetched from glusterfs
    inOrder.verify(glusterManager, times(1)).fetchVolumes(any(VDS.class));
    // get volumes by cluster id to identify those that need to be removed
    inOrder.verify(volumeDao, times(1)).getByClusterId(CLUSTER_ID);
    // remove deleted volumes
    inOrder.verify(volumeDao, times(1)).removeAll(argThat(areRemovedVolumes()));
    // create new volume
    inOrder.verify(volumeDao, times(1)).save(newVolume);
    // // update volume capacity info
    // inOrder.verify(volumeDao, times(1))
    // .updateVolumeCapacityInfo((GlusterVolumeSizeInfo) getVolumeCapacityInfo().getReturnValue());
    // remove detached bricks
    inOrder.verify(brickDao, times(1)).removeAll(argThat(containsRemovedBricks()));
    // add new bricks
    inOrder.verify(brickDao, times(2)).save(argThat(isAddedBrick()));
    // add new options
    Map<String, GlusterVolumeOptionEntity> newOptions = new HashMap<String, GlusterVolumeOptionEntity>();
    newOptions.put(OPTION_AUTH_REJECT, existingReplVol.getOption(OPTION_AUTH_REJECT));
    List<GlusterVolumeOptionEntity> list1 = new ArrayList<GlusterVolumeOptionEntity>(newOptions.values());
    Collections.sort(list1);
    inOrder.verify(optionDao, times(1)).saveAll(list1);
    // update modified options
    Map<String, GlusterVolumeOptionEntity> existingOptions = new HashMap<String, GlusterVolumeOptionEntity>();
    existingReplVol.getOption(OPTION_NFS_DISABLE).setValue(OPTION_VALUE_ON);
    existingOptions.put(OPTION_NFS_DISABLE, existingReplVol.getOption(OPTION_NFS_DISABLE));
    List<GlusterVolumeOptionEntity> list = new ArrayList<GlusterVolumeOptionEntity>(existingOptions.values());
    Collections.sort(list);
    inOrder.verify(optionDao, times(1)).updateAll("UpdateGlusterVolumeOption", list);
    // delete removed options
    inOrder.verify(optionDao, times(1)).removeAll(argThat(areRemovedOptions()));
    // release lock on the cluster
    inOrder.verify(glusterManager, times(1)).releaseLock(CLUSTER_ID);
}
#method_after
private void verifyMocksForLightWeight() {
    InOrder inOrder = inOrder(clusterDao, vdsDao, clusterUtils, glusterManager, vdsStatisticsDao, vdsDynamicDao, vdsStaticDao, volumeDao, brickDao, optionDao);
    // all clusters fetched from db
    inOrder.verify(clusterDao, times(1)).getAll();
    // get servers of the cluster from db
    inOrder.verify(vdsDao, times(1)).getAllForVdsGroup(CLUSTER_ID);
    // get the UP server from cluster
    inOrder.verify(clusterUtils, times(1)).getUpServer(CLUSTER_ID);
    // acquire lock on the cluster
    inOrder.verify(glusterManager, times(1)).acquireLock(CLUSTER_ID);
    // servers are fetched from glusterfs
    inOrder.verify(glusterManager, times(1)).fetchServers(existingServer1);
    // detached server SERVER_ID_3 is deleted from DB
    inOrder.verify(vdsStatisticsDao, times(1)).remove(SERVER_ID_3);
    inOrder.verify(vdsDynamicDao, times(1)).remove(SERVER_ID_3);
    inOrder.verify(vdsStaticDao, times(1)).remove(SERVER_ID_3);
    // detached server SERVER_ID_3 is removed from resource manager
    inOrder.verify(glusterManager, times(1)).runVdsCommand(eq(VDSCommandType.RemoveVds), any(RemoveVdsVDSCommandParameters.class));
    // release lock on the cluster
    inOrder.verify(glusterManager, times(1)).releaseLock(CLUSTER_ID);
    // acquire lock on the cluster for next operation (refresh volumes)
    inOrder.verify(glusterManager, times(1)).acquireLock(CLUSTER_ID);
    // volumes are fetched from glusterfs
    inOrder.verify(glusterManager, times(1)).fetchVolumes(any(VDS.class));
    // get volumes by cluster id to identify those that need to be removed
    inOrder.verify(volumeDao, times(1)).getByClusterId(CLUSTER_ID);
    // remove deleted volumes
    inOrder.verify(volumeDao, times(1)).removeAll(argThat(areRemovedVolumes()));
    // create new volume
    inOrder.verify(volumeDao, times(1)).save(newVolume);
    // remove detached bricks
    inOrder.verify(brickDao, times(1)).removeAll(argThat(containsRemovedBricks()));
    // add new bricks
    inOrder.verify(brickDao, times(2)).save(argThat(isAddedBrick()));
    // add new options
    Map<String, GlusterVolumeOptionEntity> newOptions = new HashMap<String, GlusterVolumeOptionEntity>();
    newOptions.put(OPTION_AUTH_REJECT, existingReplVol.getOption(OPTION_AUTH_REJECT));
    List<GlusterVolumeOptionEntity> list1 = new ArrayList<GlusterVolumeOptionEntity>(newOptions.values());
    Collections.sort(list1);
    inOrder.verify(optionDao, times(1)).saveAll(list1);
    // update modified options
    Map<String, GlusterVolumeOptionEntity> existingOptions = new HashMap<String, GlusterVolumeOptionEntity>();
    existingReplVol.getOption(OPTION_NFS_DISABLE).setValue(OPTION_VALUE_ON);
    existingOptions.put(OPTION_NFS_DISABLE, existingReplVol.getOption(OPTION_NFS_DISABLE));
    List<GlusterVolumeOptionEntity> list = new ArrayList<GlusterVolumeOptionEntity>(existingOptions.values());
    Collections.sort(list);
    inOrder.verify(optionDao, times(1)).updateAll("UpdateGlusterVolumeOption", list);
    // delete removed options
    inOrder.verify(optionDao, times(1)).removeAll(argThat(areRemovedOptions()));
    // release lock on the cluster
    inOrder.verify(glusterManager, times(1)).releaseLock(CLUSTER_ID);
}
#end_block

#method_before
private void mockDaos() {
    doReturn(volumeDao).when(glusterManager).getVolumeDao();
    doReturn(brickDao).when(glusterManager).getBrickDao();
    doReturn(optionDao).when(glusterManager).getOptionDao();
    doReturn(vdsDao).when(glusterManager).getVdsDao();
    doReturn(vdsStatisticsDao).when(glusterManager).getVdsStatisticsDao();
    doReturn(vdsStaticDao).when(glusterManager).getVdsStaticDao();
    doReturn(vdsDynamicDao).when(glusterManager).getVdsDynamicDao();
    doReturn(clusterDao).when(glusterManager).getClusterDao();
    doReturn(interfaceDao).when(glusterManager).getInterfaceDao();
    doReturn(glusterServerDao).when(glusterManager).getGlusterServerDao();
    doReturn(Collections.singletonList(existingCluster)).when(clusterDao).getAll();
    doReturn(existingServers).when(vdsDao).getAllForVdsGroup(CLUSTER_ID);
    doReturn(existingDistVol).when(volumeDao).getById(EXISTING_VOL_DIST_ID);
    doReturn(existingReplVol).when(volumeDao).getById(EXISTING_VOL_REPL_ID);
    doReturn(null).when(volumeDao).getById(NEW_VOL_ID);
    doNothing().when(volumeDao).save(newVolume);
    doNothing().when(volumeDao).updateVolumeCapacityInfo((GlusterVolumeSizeInfo) getVolumeCapacityInfo().getReturnValue());
    doNothing().when(brickDao).removeAll(argThat(containsRemovedBricks()));
    doNothing().when(brickDao).save(argThat(isAddedBrick()));
    doNothing().when(optionDao).updateVolumeOption(argThat(isUpdatedOptionId()), eq(OPTION_VALUE_ON));
    doNothing().when(optionDao).save(argThat(isNewOption()));
    doNothing().when(optionDao).removeAll(argThat(areRemovedOptions()));
    doReturn(existingVolumes).when(volumeDao).getByClusterId(CLUSTER_ID);
    doNothing().when(volumeDao).removeAll(argThat(areRemovedVolumes()));
    doNothing().when(brickDao).updateBrickStatuses(argThat(hasBricksWithChangedStatus()));
    doNothing().when(optionDao).saveAll(argThat(areAddedOptions()));
}
#method_after
private void mockDaos() {
    doReturn(volumeDao).when(glusterManager).getVolumeDao();
    doReturn(brickDao).when(glusterManager).getBrickDao();
    doReturn(optionDao).when(glusterManager).getOptionDao();
    doReturn(vdsDao).when(glusterManager).getVdsDao();
    doReturn(vdsStatisticsDao).when(glusterManager).getVdsStatisticsDao();
    doReturn(vdsStaticDao).when(glusterManager).getVdsStaticDao();
    doReturn(vdsDynamicDao).when(glusterManager).getVdsDynamicDao();
    doReturn(clusterDao).when(glusterManager).getClusterDao();
    doReturn(interfaceDao).when(glusterManager).getInterfaceDao();
    doReturn(glusterServerDao).when(glusterManager).getGlusterServerDao();
    doReturn(Collections.singletonList(existingCluster)).when(clusterDao).getAll();
    doReturn(existingServers).when(vdsDao).getAllForVdsGroup(CLUSTER_ID);
    doReturn(existingDistVol).when(volumeDao).getById(EXISTING_VOL_DIST_ID);
    doReturn(existingReplVol).when(volumeDao).getById(EXISTING_VOL_REPL_ID);
    doReturn(null).when(volumeDao).getById(NEW_VOL_ID);
    doNothing().when(volumeDao).save(newVolume);
    doNothing().when(brickDao).removeAll(argThat(containsRemovedBricks()));
    doNothing().when(brickDao).save(argThat(isAddedBrick()));
    doNothing().when(optionDao).updateVolumeOption(argThat(isUpdatedOptionId()), eq(OPTION_VALUE_ON));
    doNothing().when(optionDao).save(argThat(isNewOption()));
    doNothing().when(optionDao).removeAll(argThat(areRemovedOptions()));
    doReturn(existingVolumes).when(volumeDao).getByClusterId(CLUSTER_ID);
    doNothing().when(volumeDao).removeAll(argThat(areRemovedVolumes()));
    doNothing().when(brickDao).updateBrickStatuses(argThat(hasBricksWithChangedStatus()));
    doNothing().when(optionDao).saveAll(argThat(areAddedOptions()));
}
#end_block

#method_before
private GlusterVolumeAdvancedDetails getVolumeAdvancedDetails(GlusterVolumeEntity volume) {
    GlusterVolumeAdvancedDetails volDetails = new GlusterVolumeAdvancedDetails();
    List<BrickDetails> brickDetailsList = new ArrayList<BrickDetails>();
    for (GlusterBrickEntity brick : volume.getBricks()) {
        BrickDetails brickDetails = new BrickDetails();
        BrickProperties properties = new BrickProperties();
        properties.setBrickId(brick.getId());
        brickDetails.setBrickProperties(properties);
        properties.setStatus(brick.getStatus());
        if (volume == existingReplVol) {
            if (brick.getServerId().equals(SERVER_ID_1) && (brick.getBrickDirectory().equals(REPL_BRICK_R1D1) || brick.getBrickDirectory().equals(REPL_BRICK_R2D1))) {
                properties.setStatus(GlusterStatus.DOWN);
                bricksWithChangedStatus.add(brick);
            }
        }
        brickDetailsList.add(brickDetails);
    }
    volDetails.setBrickDetails(brickDetailsList);
    return volDetails;
}
#method_after
private GlusterVolumeAdvancedDetails getVolumeAdvancedDetails(GlusterVolumeEntity volume) {
    GlusterVolumeAdvancedDetails volDetails = new GlusterVolumeAdvancedDetails();
    GlusterVolumeSizeInfo capacityInfo = new GlusterVolumeSizeInfo();
    capacityInfo.setVolumeId(volume.getId());
    capacityInfo.setTotalSize(600000L);
    capacityInfo.setFreeSize(200000L);
    capacityInfo.setUsedSize(400000L);
    volDetails.setCapacityInfo(capacityInfo);
    List<BrickDetails> brickDetailsList = new ArrayList<BrickDetails>();
    for (GlusterBrickEntity brick : volume.getBricks()) {
        BrickDetails brickDetails = new BrickDetails();
        BrickProperties properties = new BrickProperties();
        properties.setBrickId(brick.getId());
        brickDetails.setBrickProperties(properties);
        properties.setStatus(brick.getStatus());
        if (volume == existingReplVol) {
            if (brick.getServerId().equals(SERVER_ID_1) && (brick.getBrickDirectory().equals(REPL_BRICK_R1D1) || brick.getBrickDirectory().equals(REPL_BRICK_R2D1))) {
                properties.setStatus(GlusterStatus.DOWN);
                bricksWithChangedStatus.add(brick);
            }
        }
        brickDetailsList.add(brickDetails);
    }
    volDetails.setBrickDetails(brickDetailsList);
    return volDetails;
}
#end_block

#method_before
private void verifyMocksForHeavyWeight() {
    InOrder inOrder = inOrder(clusterDao, clusterUtils, volumeDao, glusterManager, brickDao);
    // all clusters fetched from db
    inOrder.verify(clusterDao, times(1)).getAll();
    VerificationMode mode = times(1);
    if (existingCluster.getcompatibility_version() == Version.v3_1) {
        // nothing else should happen if the cluster has compatibility level 3.1
        mode = Mockito.never();
    }
    // get the UP server from cluster
    inOrder.verify(clusterUtils, mode).getRandomUpServer(CLUSTER_ID);
    // get volumes of the cluster
    inOrder.verify(volumeDao, mode).getByClusterId(CLUSTER_ID);
    // acquire lock on the cluster
    inOrder.verify(glusterManager, mode).acquireLock(CLUSTER_ID);
    // get volume advance details
    inOrder.verify(glusterManager, mode).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingDistVol.getName());
    // release lock on the cluster
    inOrder.verify(glusterManager, mode).releaseLock(CLUSTER_ID);
    // acquire lock on the cluster for repl volume
    inOrder.verify(glusterManager, mode).acquireLock(CLUSTER_ID);
    // get volume advance details of repl volume
    inOrder.verify(glusterManager, mode).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingReplVol.getName());
    // update brick status
    inOrder.verify(brickDao, mode).updateBrickStatuses(argThat(hasBricksWithChangedStatus()));
    // release lock on the cluster
    inOrder.verify(glusterManager, mode).releaseLock(CLUSTER_ID);
}
#method_after
private void verifyMocksForHeavyWeight() {
    InOrder inOrder = inOrder(clusterDao, clusterUtils, volumeDao, glusterManager, brickDao);
    // all clusters fetched from db
    inOrder.verify(clusterDao, times(1)).getAll();
    VerificationMode mode = times(1);
    if (existingCluster.getcompatibility_version() == Version.v3_1) {
        // nothing else should happen if the cluster has compatibility level 3.1
        mode = Mockito.never();
    }
    // get the UP server from cluster
    inOrder.verify(clusterUtils, mode).getRandomUpServer(CLUSTER_ID);
    // get volumes of the cluster
    inOrder.verify(volumeDao, mode).getByClusterId(CLUSTER_ID);
    // acquire lock on the cluster
    inOrder.verify(glusterManager, mode).acquireLock(CLUSTER_ID);
    // get volume advance details
    inOrder.verify(glusterManager, mode).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingDistVol.getName());
    // Update capacity info
    inOrder.verify(volumeDao, mode).updateVolumeCapacityInfo(getVolumeAdvancedDetails(existingDistVol).getCapacityInfo());
    // release lock on the cluster
    inOrder.verify(glusterManager, mode).releaseLock(CLUSTER_ID);
    // acquire lock on the cluster for repl volume
    inOrder.verify(glusterManager, mode).acquireLock(CLUSTER_ID);
    // get volume advance details of repl volume
    inOrder.verify(glusterManager, mode).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingReplVol.getName());
    // Add Capacity Info
    inOrder.verify(volumeDao, mode).addVolumeCapacityInfo(getVolumeAdvancedDetails(existingReplVol).getCapacityInfo());
    // Add Capacity Info
    inOrder.verify(brickDao, mode).addBrickProperties(any(List.class));
    // update brick status
    inOrder.verify(brickDao, mode).updateBrickStatuses(argThat(hasBricksWithChangedStatus()));
    // release lock on the cluster
    inOrder.verify(glusterManager, mode).releaseLock(CLUSTER_ID);
}
#end_block

#method_before
@Override
public List<Statistic> getStatistics(GlusterVolumeEntity entity) {
    GlusterVolumeSizeInfo sizeInfo = entity.getCapacityDetails();
    if (sizeInfo == null) {
        return new ArrayList<Statistic>();
    }
    return asList(setDatum(clone(MEM_TOTAL_SIZE), sizeInfo.getTotalSize() * Mb), setDatum(clone(MEM_FREE_SIZE), sizeInfo.getFreeSize() * Mb), setDatum(clone(MEM_USED_SIZE), sizeInfo.getUsedSize() * Mb));
}
#method_after
@Override
public List<Statistic> getStatistics(GlusterVolumeEntity entity) {
    GlusterVolumeSizeInfo sizeInfo = entity.getAdvancedDetails().getCapacityInfo();
    if (sizeInfo == null) {
        return new ArrayList<Statistic>();
    }
    return asList(setDatum(clone(MEM_TOTAL_SIZE), sizeInfo.getTotalSize()), setDatum(clone(MEM_FREE_SIZE), sizeInfo.getFreeSize()), setDatum(clone(MEM_USED_SIZE), sizeInfo.getUsedSize()));
}
#end_block

#method_before
@Override
public Statistic adopt(Statistic statistic) {
    statistic.setGlusterVolume(clone(parent));
    return statistic;
}
#method_after
@Override
public Statistic adopt(Statistic statistic) {
    statistic.setGlusterVolume(parent);
    return statistic;
}
#end_block

#method_before
@Override
@Path("statistics")
public StatisticsResource getStatisticsResource() {
    EntityIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetGlusterVolumeById, IdQueryParameters.class) {

        @Override
        public GlusterVolumeEntity lookupEntity(Guid id) throws BackendFailureException {
            GlusterVolumeEntity volumeEntity = getEntity(GlusterVolumeEntity.class, VdcQueryType.GetGlusterVolumeById, new IdQueryParameters(id), null, true);
            List<Guid> guids = new ArrayList<>();
            guids.add(volumeEntity.getId());
            List<GlusterVolumeSizeInfo> sizeInfos = runQuery(VdcQueryType.GetGlusterVolumeSizeInfo, new GlusterVolumeCapacityQueryParameters(volumeEntity.getClusterId(), guids)).getReturnValue();
            if (sizeInfos != null && sizeInfos.size() > 0) {
                volumeEntity.setCapacityDetails(sizeInfos.get(0));
            }
            return volumeEntity;
        }
    };
    VolumeStatisticalQuery query = new VolumeStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<GlusterVolume, GlusterVolumeEntity>(GlusterVolumeEntity.class, guid, query));
}
#method_after
@Override
@Path("statistics")
public StatisticsResource getStatisticsResource() {
    EntityIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetGlusterVolumeById, IdQueryParameters.class);
    VolumeStatisticalQuery query = new VolumeStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<GlusterVolume, GlusterVolumeEntity>(entityType, guid, query));
}
#end_block

#method_before
public void copyDetailsFrom(GlusterVolumeAdvancedDetails volumeAdvancedDetails) {
    for (BrickDetails newBrickDetails : volumeAdvancedDetails.getBrickDetails()) {
        Guid newBrickId = newBrickDetails.getBrickProperties().getBrickId();
        if (newBrickId != null) {
            for (BrickDetails brickDetails : getBrickDetails()) {
                if (newBrickId.equals(brickDetails.getBrickProperties().getBrickId())) {
                    copyBrickProperties(newBrickDetails.getBrickProperties(), brickDetails.getBrickProperties());
                    break;
                }
            }
        }
    }
}
#method_after
public void copyDetailsFrom(GlusterVolumeAdvancedDetails volumeAdvancedDetails) {
    setCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
    for (BrickDetails newBrickDetails : volumeAdvancedDetails.getBrickDetails()) {
        Guid newBrickId = newBrickDetails.getBrickProperties().getBrickId();
        if (newBrickId != null) {
            for (BrickDetails brickDetails : getBrickDetails()) {
                if (newBrickId.equals(brickDetails.getBrickProperties().getBrickId())) {
                    copyBrickProperties(newBrickDetails.getBrickProperties(), brickDetails.getBrickProperties());
                    break;
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((capacityInfo == null) ? 0 : capacityInfo.hashCode());
    result = prime * result + ((serviceInfo == null) ? 0 : serviceInfo.hashCode());
    result = prime * result + ((volumeId == null) ? 0 : volumeId.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((capacityInfo == null) ? 0 : capacityInfo.hashCode());
    result = prime * result + ((serviceInfo == null) ? 0 : serviceInfo.hashCode());
    result = prime * result + ((brickDetails == null) ? 0 : brickDetails.hashCode());
    result = prime * result + ((volumeId == null) ? 0 : volumeId.hashCode());
    result = prime * result + ((updatedAt == null) ? 0 : updatedAt.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    GlusterVolumeAdvancedDetails other = (GlusterVolumeAdvancedDetails) obj;
    if (capacityInfo == null) {
        if (other.capacityInfo != null)
            return false;
    } else if (!capacityInfo.equals(other.capacityInfo))
        return false;
    if (serviceInfo == null) {
        if (other.serviceInfo != null)
            return false;
    } else if (!serviceInfo.equals(other.serviceInfo))
        return false;
    if (volumeId == null) {
        if (other.volumeId != null)
            return false;
    } else if (!volumeId.equals(other.volumeId))
        return false;
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterVolumeAdvancedDetails)) {
        return false;
    }
    if (this == obj)
        return true;
    GlusterVolumeAdvancedDetails otherVolumeAdvancedDetails = (GlusterVolumeAdvancedDetails) obj;
    if (!ObjectUtils.objectsEqual(capacityInfo, otherVolumeAdvancedDetails.getCapacityInfo())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(brickDetails, otherVolumeAdvancedDetails.getBrickDetails())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(serviceInfo, otherVolumeAdvancedDetails.getServiceInfo())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(updatedAt, otherVolumeAdvancedDetails.getUpdatedAt())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(volumeId, otherVolumeAdvancedDetails.getVolumeId())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((volumeId == null) ? 0 : volumeId.hashCode());
    result = prime * result + ((totalSize == null) ? 0 : totalSize.hashCode());
    result = prime * result + ((freeSize == null) ? 0 : freeSize.hashCode());
    result = prime * result + ((usedSize == null) ? 0 : usedSize.hashCode());
    result = prime * result + ((updatedAt == null) ? 0 : updatedAt.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((volumeId == null) ? 0 : volumeId.hashCode());
    result = prime * result + ((totalSize == null) ? 0 : totalSize.hashCode());
    result = prime * result + ((freeSize == null) ? 0 : freeSize.hashCode());
    result = prime * result + ((usedSize == null) ? 0 : usedSize.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterVolumeSizeInfo)) {
        return false;
    }
    GlusterVolumeSizeInfo sizeInfo = (GlusterVolumeSizeInfo) obj;
    if (!ObjectUtils.objectsEqual(volumeId, sizeInfo.getVolumeId())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(updatedAt, sizeInfo.getUpdatedAt())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(totalSize, sizeInfo.getTotalSize())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(freeSize, sizeInfo.getFreeSize())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(usedSize, sizeInfo.getUsedSize())) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterVolumeSizeInfo)) {
        return false;
    }
    GlusterVolumeSizeInfo sizeInfo = (GlusterVolumeSizeInfo) obj;
    if (!ObjectUtils.objectsEqual(volumeId, sizeInfo.getVolumeId())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(totalSize, sizeInfo.getTotalSize())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(freeSize, sizeInfo.getFreeSize())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(usedSize, sizeInfo.getUsedSize())) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void _threadMain() {
    boolean error = false;
    try {
        String line;
        while (_incoming != null && (line = _incoming.readLine()) != null) {
            log.infoFormat("update from host {0}: {1}", _vds.getHostName(), line);
            error = _messages.postOldXmlFormat(line) || error;
        }
        if (error) {
            throw new RuntimeException("Upgrade failed, please refer to logs for further information");
        }
    } catch (Exception e) {
        _failException = e;
        log.error("Error during upgrade", e);
        _control.disconnect();
    }
}
#method_after
private void _threadMain() {
    boolean error = false;
    try {
        String line;
        while (_incoming != null && (line = _incoming.readLine()) != null) {
            log.infoFormat("update from host {0}: {1}", _vds.getHostName(), line);
            error = _messages.postOldXmlFormat(line) || error;
        }
        if (error) {
            throw new RuntimeException("Upgrade failed, please refer to logs for further information");
        }
    } catch (Exception e) {
        _failException = e;
        log.error("Error during upgrade", e);
        try {
            _control.close();
        } catch (IOException ee) {
            log.error("Error during close", ee);
        }
    }
}
#end_block

#method_before
@Override
protected void finalize() {
    close();
}
#method_after
@Override
protected void finalize() {
    try {
        close();
    } catch (IOException e) {
        log.error("Exception during finalize", e);
    }
}
#end_block

#method_before
public void close() {
    stop();
    if (_dialog != null) {
        _dialog.disconnect();
        _dialog = null;
    }
}
#method_after
public void close() throws IOException {
    stop();
    if (_dialog != null) {
        _dialog.close();
        _dialog = null;
    }
}
#end_block

#method_before
public void execute() throws Exception {
    try {
        _setVdsStatus(VDSStatus.Installing);
        _dialog.useDefaultKeyPair();
        _dialog.setHost(_vds.getHostName());
        _dialog.connect();
        _messages.post(InstallerMessages.Severity.INFO, String.format("Connected to host %1$s with SSH key fingerprint: %2$s", _vds.getHostName(), _dialog.getHostFingerprint()));
        _dialog.authenticate();
        _messages.post(InstallerMessages.Severity.INFO, String.format("Sending file %1$s to %2$s", _iso, _uploadPath));
        /*
             * Create the directory where
             * file is stored, in the past
             * it was done by vdsm, then vdsm-reg
             * well, as we use hard coded path
             * we can as well do this, until we
             * have proper node upgrade script
             * that can take the image from stdin.
             */
        _dialog.executeCommand(new SSHDialog.Sink() {

            @Override
            public void setControl(SSHDialog.Control control) {
            }

            @Override
            public void setStreams(InputStream incoming, OutputStream outgoing) {
            }

            @Override
            public void start() {
            }

            @Override
            public void stop() {
            }
        }, String.format("mkdir -p '%1$s'", new File(_uploadPath).getParent()), null);
        if (_failException != null) {
            throw _failException;
        }
        _dialog.sendFile(_iso, _uploadPath);
        _messages.post(InstallerMessages.Severity.INFO, String.format("Executing %1$s", _upgradeScriptName));
        _dialog.executeCommand(this, _upgradeScriptName, null);
        if (_failException != null) {
            throw _failException;
        }
        _setVdsStatus(VDSStatus.Reboot);
    } catch (TimeLimitExceededException e) {
        log.errorFormat("Timeout during node {0} upgrade", _vds.getHostName(), e);
        _messages.post(InstallerMessages.Severity.ERROR, "Processing stopped due to timeout");
        _setVdsStatus(VDSStatus.InstallFailed);
        throw e;
    } catch (Exception e) {
        log.errorFormat("Error during node {0} upgrade", _vds.getHostName(), e);
        _setVdsStatus(VDSStatus.InstallFailed);
        if (_failException == null) {
            throw e;
        } else {
            log.errorFormat("Error during node {0} upgrade, prefering first exception", _vds.getHostName(), _failException);
            throw _failException;
        }
    }
}
#method_after
public void execute() throws Exception {
    try {
        _dialog.setVds(_vds);
        _dialog.connect();
        _dialog.useDefaultKeyPair();
        _messages.post(InstallerMessages.Severity.INFO, String.format("Connected to host %1$s with SSH key fingerprint: %2$s", _vds.getHostName(), _dialog.getHostFingerprint()));
        _dialog.authenticate();
        String dest = Config.<String>getValue(ConfigValues.oVirtUploadPath);
        _messages.post(InstallerMessages.Severity.INFO, String.format("Sending file %1$s to %2$s", _iso, dest));
        /*
             * Create the directory where
             * file is stored, in the past
             * it was done by vdsm, then vdsm-reg
             * well, as we use hard coded path
             * we can as well do this, until we
             * have proper node upgrade script
             * that can take the image from stdin.
             */
        _dialog.executeCommand(new SSHDialog.Sink() {

            @Override
            public void setControl(SSHDialog.Control control) {
            }

            @Override
            public void setStreams(InputStream incoming, OutputStream outgoing) {
            }

            @Override
            public void start() {
            }

            @Override
            public void stop() {
            }
        }, String.format("mkdir -p '%1$s'", new File(dest).getParent()), null);
        if (_failException != null) {
            throw _failException;
        }
        _dialog.sendFile(_iso.getAbsolutePath(), dest);
        String command = Config.<String>getValue(ConfigValues.oVirtUpgradeScriptName);
        _messages.post(InstallerMessages.Severity.INFO, String.format("Executing %1$s", command));
        _dialog.executeCommand(this, command, null);
        if (_failException != null) {
            throw _failException;
        }
        _deployStatus = DeployStatus.Reboot;
    } catch (TimeLimitExceededException e) {
        log.errorFormat("Timeout during node {0} upgrade", _vds.getHostName(), e);
        _messages.post(InstallerMessages.Severity.ERROR, "Processing stopped due to timeout");
        throw e;
    } catch (Exception e) {
        log.errorFormat("Error during node {0} upgrade", _vds.getHostName(), e);
        if (_failException == null) {
            throw e;
        } else {
            log.errorFormat("Error during node {0} upgrade, prefering first exception", _vds.getHostName(), _failException);
            throw _failException;
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    OVirtNodeInfo Info = new OVirtNodeInfo();
    _uploadPath = Info.getUploadPath();
    _upgradeScriptName = Info.getUpgradeScriptName();
    if (getVdsId() == null || getVdsId().equals(Guid.Empty)) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        retValue = false;
    } else if (getVds() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
        retValue = false;
    } else if (isOvirtReInstallOrUpgrade()) {
        String isoFile = getParameters().getoVirtIsoFile();
        // Block re-install on non-operational Host
        if (getVds().getStatus() == VDSStatus.NonOperational) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_STATUS_ILLEGAL);
            retValue = false;
        }
        if (!isIsoFileValid(isoFile, Info)) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
            retValue = false;
        } else {
            RpmVersion ovirtHostOsVersion = VdsHandler.getOvirtHostOsVersion(getVds());
            if (ovirtHostOsVersion != null && !isIsoVersionCompatible(ovirtHostOsVersion, isoFile, Info)) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_UPGRADE_BETWEEN_MAJOR_VERSION);
                addCanDoActionMessage(String.format("$IsoVersion %1$s", ovirtHostOsVersion.getMajor()));
                retValue = false;
            }
        }
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsId() == null || getVdsId().equals(Guid.Empty)) {
        return failCanDoAction(VdcBllMessages.VDS_INVALID_SERVER_ID);
    }
    if (getVds() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
    }
    if (isOvirtReInstallOrUpgrade()) {
        // Block re-install on non-operational Host
        if (getVds().getStatus() == VDSStatus.NonOperational) {
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_INSTALL_STATUS_ILLEGAL);
        }
        File iso = resolveISO(getParameters().getoVirtIsoFile());
        if (iso == null) {
            return failCanDoAction(VdcBllMessages.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
        }
        RpmVersion ovirtHostOsVersion = VdsHandler.getOvirtHostOsVersion(getVds());
        if (!isISOCompatible(iso, ovirtHostOsVersion)) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_UPGRADE_BETWEEN_MAJOR_VERSION);
            addCanDoActionMessage(String.format("$IsoVersion %1$s", ovirtHostOsVersion.getMajor()));
            return false;
        }
        _iso = iso;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVds() != null && isOvirtReInstallOrUpgrade()) {
        OVirtNodeUpgrade upgrade = null;
        try {
            T parameters = getParameters();
            upgrade = new OVirtNodeUpgrade(getVds(), _isoFullPath, _uploadPath, _upgradeScriptName);
            upgrade.setCorrelationId(getCorrelationId());
            log.infoFormat("Execute upgrade host {0}, {1}", getVds().getId(), getVds().getName());
            upgrade.execute();
            log.infoFormat("After upgrade host {0}, {1}: success", getVds().getId(), getVds().getName());
            setSucceeded(true);
            if (getVds().getStatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getName(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            addCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (upgrade != null) {
                upgrade.close();
            }
        }
        return;
    }
    if (getVds() != null) {
        VdsDeploy installer = null;
        try {
            log.infoFormat("Before Installation host {0}, {1}", getVds().getId(), getVds().getName());
            T parameters = getParameters();
            installer = new VdsDeploy(getVds());
            installer.setCorrelationId(getCorrelationId());
            installer.setReboot(parameters.isRebootAfterInstallation());
            switch(getVds().getVdsType()) {
                case VDS:
                    installer.setUser("root");
                    installer.setPassword(parameters.getRootPassword());
                    installer.setFirewall(parameters.getOverrideFirewall());
                    break;
                case oVirtNode:
                    if (parameters.getOverrideFirewall()) {
                        log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getName(), getVds().getVdsType().name());
                    }
                    installer.setUser("root");
                    installer.useDefaultKeyPair();
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getVdsType()));
            }
            installer.execute();
            if (getVds().getStatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
            log.infoFormat("After Installation host {0}, {1}", getVds().getName(), getVds().getVdsType().name());
            setSucceeded(true);
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getName(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            addCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (installer != null) {
                installer.close();
            }
        }
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVds() == null) {
        return;
    }
    if (isOvirtReInstallOrUpgrade()) {
        upgradeNode();
    } else {
        installHost();
    }
}
#end_block

#method_before
private boolean isOvirtReInstallOrUpgrade() {
    return getParameters().getIsReinstallOrUpgrade() && getVds().getVdsType() == VDSType.oVirtNode;
}
#method_after
private boolean isOvirtReInstallOrUpgrade() {
    return (getParameters().getIsReinstallOrUpgrade() && getVds().getVdsType() == VDSType.oVirtNode);
}
#end_block

#method_before
protected String getErrorMessage(String msg) {
    return (StringUtils.isEmpty(msg) ? GENERIC_ERROR : msg);
}
#method_after
protected String getErrorMessage(String msg) {
    return StringUtils.isEmpty(msg) ? GENERIC_ERROR : msg;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    OVirtNodeInfo Info = new OVirtNodeInfo();
    RpmVersion vdsOsVersion = getOvirtOsVersion();
    List<RpmVersion> availableISOsList = new ArrayList<RpmVersion>();
    List<String> reposUpgrade = new ArrayList<String>();
    String[] tempRepo = Info.getISOsPath().split(Info.getInfoDelimiter());
    for (int i = 0; i < tempRepo.length; i++) reposUpgrade.add(tempRepo[i]);
    for (String repo : reposUpgrade) {
        File directory = new File(repo);
        log.infoFormat("ISO Path: {0}", repo);
        if (directory.isDirectory()) {
            List<String> listOfIsoFiles = getListOfIsoFiles(directory, Info);
            log.infoFormat("List of ISOs: {0}", listOfIsoFiles);
            if (!listOfIsoFiles.isEmpty()) {
                File[] ovirtVersionFiles = filterOvirtFiles(directory, isoVersionPattern);
                for (File versionFile : ovirtVersionFiles) {
                    try {
                        IsoData isoData = new IsoData();
                        isoData.setVersion(readIsoVersion(versionFile));
                        String isoVersionText = isoData.getVersion();
                        isoData.setVdsmCompitibilityVersion(readVdsmCompatibiltyVersion((versionFile.getAbsolutePath().replace(OVIRT_ISO_VERSION_PREFIX, OVIRT_ISO_VDSM_COMPATIBILITY_PREFIX))));
                        if (StringUtils.isBlank(isoVersionText)) {
                            log.infoFormat("Iso version file {0} is empty.", versionFile.getAbsolutePath());
                            continue;
                        }
                        String[] versionParts = isoVersionText.split(",");
                        if (versionParts.length < 2) {
                            log.infoFormat("Iso version file {0} contains invalid content. Excpected: <major-version>,<release> format.", versionFile.getAbsolutePath());
                            continue;
                        }
                        String majorVersionStr = versionParts[0];
                        String releaseStr = versionParts[1];
                        String isoFileName = getIsoFileNameByVersion(listOfIsoFiles, majorVersionStr, releaseStr);
                        if (isoFileName == null) {
                            log.infoFormat("Iso version file {0} has no matching iso file searched by version parts: {1} and {2}.", versionFile.getAbsolutePath(), majorVersionStr, releaseStr);
                            continue;
                        }
                        RpmVersion isoVersion = parseIsoFileVersion(isoFileName, majorVersionStr, Info);
                        boolean shouldAdd = false;
                        if (isoVersion != null && isIsoVersionSupported(isoVersion, Info)) {
                            if (isoData.getVdsmCompatibilityVersion() != null) {
                                shouldAdd = isIsoCompatibleForUpgradeByClusterVersion(isoData);
                            } else if (vdsOsVersion != null) {
                                if (VdsHandler.isIsoVersionCompatibleForUpgrade(vdsOsVersion, isoVersion)) {
                                    shouldAdd = true;
                                }
                            } else {
                                shouldAdd = true;
                            }
                        }
                        if (shouldAdd) {
                            availableISOsList.add(isoVersion);
                        }
                    } catch (RuntimeException e) {
                        log.errorFormat("Failed to parse ovirt iso version {0} with error {1}", versionFile.getAbsolutePath(), ExceptionUtils.getMessage(e));
                    }
                }
            }
        } else {
            log.errorFormat("ovirt ISOs directory not found. Search in: {0}", directory.getPath());
        }
    }
    log.infoFormat("availableISOsList {0}", availableISOsList);
    Collections.sort(availableISOsList);
    getQueryReturnValue().setReturnValue(availableISOsList);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<RpmVersion> availableISOsList = new ArrayList<RpmVersion>();
    VDS vds = getVdsByVdsId(getParameters().getVdsId());
    if (vds == null) {
        getQueryReturnValue().setReturnValue(availableISOsList);
        return;
    }
    RpmVersion vdsOsVersion = VdsHandler.getOvirtHostOsVersion(vds);
    String nodeOS = vds.getHostOs();
    for (OVirtNodeInfo.Entry info : OVirtNodeInfo.getInstance().get()) {
        log.debugFormat("nodeOS [{0}] | osPattern [{1}] | minimumVersion [{2}]", nodeOS, info.osPattern, info.minimumVersion);
        Matcher matcher = info.osPattern.matcher(nodeOS);
        if (matcher.matches() && info.path.isDirectory()) {
            log.debugFormat("Looking for list of ISOs in [{0}], regex [{1}]", info.path, info.isoPattern);
            for (File file : info.path.listFiles()) {
                matcher = info.isoPattern.matcher(file.getName());
                if (matcher.matches()) {
                    log.debugFormat("ISO Found [{0}]", file);
                    String version = matcher.group(1);
                    log.debugFormat("ISO Version [{0}]", version);
                    File versionFile = new File(info.path, String.format("version-%s.txt", version));
                    log.debugFormat("versionFile [{0}]", versionFile);
                    // Setting IsoData Class to get further [version] and [vdsm compatibility version] data
                    IsoData isoData = new IsoData();
                    isoData.setVersion(readIsoVersion(versionFile));
                    String isoVersionText = isoData.getVersion();
                    isoData.setVdsmCompitibilityVersion(readVdsmCompatibiltyVersion((versionFile.getAbsolutePath().replace(OVIRT_ISO_VERSION_PREFIX, OVIRT_ISO_VDSM_COMPATIBILITY_PREFIX))));
                    if (StringUtils.isEmpty(isoVersionText)) {
                        log.debugFormat("Iso version file {0} is empty.", versionFile.getAbsolutePath());
                        continue;
                    }
                    String[] versionParts = isoVersionText.split(",");
                    if (versionParts.length < 2) {
                        log.debugFormat("Iso version file {0} contains invalid content. Expected: <major-version>,<release> format.", versionFile.getAbsolutePath());
                        continue;
                    }
                    RpmVersion isoVersion = new RpmVersion(file.getName());
                    if (isoData.getVdsmCompatibilityVersion() != null && isIsoCompatibleForUpgradeByClusterVersion(isoData) || vdsOsVersion != null && VdsHandler.isIsoVersionCompatibleForUpgrade(vdsOsVersion, isoVersion)) {
                        availableISOsList.add(isoVersion);
                    }
                }
            }
        }
    }
    Collections.sort(availableISOsList);
    getQueryReturnValue().setReturnValue(availableISOsList);
}
#end_block

#method_before
private boolean isNewerVersion(Version isoClusterVersion) {
    VDS vds = getVdsByVdsId(getParameters().getVdsId());
    Version vdsClusterVersion = vds.getVdsGroupCompatibilityVersion();
    return (vdsClusterVersion.getMajor() == isoClusterVersion.getMajor() && vdsClusterVersion.getMinor() <= isoClusterVersion.getMinor());
}
#method_after
private boolean isNewerVersion(Version isoClusterVersion) {
    VDS vds = getVdsByVdsId(getParameters().getVdsId());
    Version vdsClusterVersion = vds.getVdsGroupCompatibilityVersion();
    log.debugFormat("vdsClusterVersion {0} isoClusterVersion {1}", vdsClusterVersion, isoClusterVersion);
    return (vdsClusterVersion.getMajor() == isoClusterVersion.getMajor() && vdsClusterVersion.getMinor() <= isoClusterVersion.getMinor());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getStorageDomain().setStorageFormat(VersionStorageFormatUtil.getPreferredForVersion(getStoragePool().getcompatibility_version(), getStoragePool().getStorageType()));
    super.executeCommand();
    if (getSucceeded()) {
        VdcReturnValueBase returnValue = Backend.getInstance().runInternalAction(VdcActionType.AttachStorageDomainToPool, new StorageDomainPoolParametersBase(getStorageDomain().getId(), getStoragePool().getId()));
        if (!returnValue.getSucceeded()) {
            getReturnValue().setSucceeded(false);
            getReturnValue().setFault(returnValue.getFault());
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    getStorageDomain().setStorageFormat(VersionStorageFormatUtil.getPreferredForVersion(getStoragePool().getcompatibility_version(), getStorageDomain().getStorageType()));
    super.executeCommand();
    if (getSucceeded()) {
        VdcReturnValueBase returnValue = Backend.getInstance().runInternalAction(VdcActionType.AttachStorageDomainToPool, new StorageDomainPoolParametersBase(getStorageDomain().getId(), getStoragePool().getId()));
        if (!returnValue.getSucceeded()) {
            getReturnValue().setSucceeded(false);
            getReturnValue().setFault(returnValue.getFault());
        }
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected boolean runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type, LUNs lun, Guid storagePoolId) {
    boolean isSuccess = true;
    List<StorageServerConnections> list = (lun == null) ? DbFacade.getInstance().getStorageServerConnectionDao().getAllForVolumeGroup(storageDomain.getStorage()) : lun.getLunConnections();
    if (list.size() != 0) {
        if (VDSCommandType.forValue(type) == VDSCommandType.DisconnectStorageServer) {
            list = filterConnectionsUsedByOthers(list, storageDomain.getStorage(), lun != null ? lun.getLUN_id() : "");
        } else if (VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            list = updateInitiators(list, vdsId);
        }
        Guid poolId = storagePoolId;
        if (storageDomain != null && storageDomain.getStoragePoolId() != null) {
            poolId = storageDomain.getStoragePoolId();
        }
        VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.forValue(type), new StorageServerConnectionManagementVDSParameters(vdsId, poolId, StorageType.ISCSI, list));
        isSuccess = returnValue.getSucceeded();
        if (isSuccess && VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            isSuccess = isConnectSucceeded((Map<String, String>) returnValue.getReturnValue(), list);
            if (isSuccess && storageDomain != null) {
                // Synchronize LUN details comprising the storage domain with the DB
                StorageDomainParametersBase parameters = new StorageDomainParametersBase(storageDomain.getId());
                parameters.setVdsId(vdsId);
                Backend.getInstance().runInternalAction(VdcActionType.SyncLunsInfoForIscsiStorageDomain, parameters);
            }
        }
    }
    return isSuccess;
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected boolean runConnectionStorageToDomain(StorageDomain storageDomain, Guid vdsId, int type, LUNs lun, Guid storagePoolId) {
    boolean isSuccess = true;
    List<StorageServerConnections> list = (lun == null) ? DbFacade.getInstance().getStorageServerConnectionDao().getAllForVolumeGroup(storageDomain.getStorage()) : lun.getLunConnections();
    if (list.size() != 0) {
        if (VDSCommandType.forValue(type) == VDSCommandType.DisconnectStorageServer) {
            list = filterConnectionsUsedByOthers(list, storageDomain.getStorage(), lun != null ? lun.getLUN_id() : "");
        } else if (VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            list = updateIfaces(list, vdsId);
        }
        Guid poolId = storagePoolId;
        if (storageDomain != null && storageDomain.getStoragePoolId() != null) {
            poolId = storageDomain.getStoragePoolId();
        }
        VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.forValue(type), new StorageServerConnectionManagementVDSParameters(vdsId, poolId, StorageType.ISCSI, list));
        isSuccess = returnValue.getSucceeded();
        if (isSuccess && VDSCommandType.forValue(type) == VDSCommandType.ConnectStorageServer) {
            isSuccess = isConnectSucceeded((Map<String, String>) returnValue.getReturnValue(), list);
            if (isSuccess && storageDomain != null) {
                // Synchronize LUN details comprising the storage domain with the DB
                StorageDomainParametersBase parameters = new StorageDomainParametersBase(storageDomain.getId());
                parameters.setVdsId(vdsId);
                Backend.getInstance().runInternalAction(VdcActionType.SyncLunsInfoForIscsiStorageDomain, parameters);
            }
        }
    }
    return isSuccess;
}
#end_block

#method_before
public static Map<String, String> createStructFromConnection(final StorageServerConnections connection, final StoragePool storagePool) {
    // for information, see _connectionDict2ConnectionInfo in vdsm/storage/hsm.py
    DefaultValueMap con = new DefaultValueMap();
    con.put("id", connection.getid(), Guid.Empty.toString());
    con.put("connection", connection.getconnection(), "");
    con.put("portal", connection.getportal(), "");
    con.put("port", connection.getport(), "");
    con.put("iqn", connection.getiqn(), "");
    con.put("user", connection.getuser_name(), "");
    con.put("password", connection.getpassword(), "");
    con.putIfNotEmpty("initiatorName", connection.getInitiatorName());
    // through vds which has no storage pool
    if (storagePool == null || Config.<Boolean>getValue(ConfigValues.AdvancedNFSOptionsEnabled, storagePool.getcompatibility_version().getValue())) {
        // For mnt_options, vfs_type, and protocol_version - if they are null
        // or empty we should not send a key with an empty value
        con.putIfNotEmpty("mnt_options", connection.getMountOptions());
        con.putIfNotEmpty("vfs_type", connection.getVfsType());
        if (connection.getNfsVersion() != null) {
            con.put("protocol_version", connection.getNfsVersion().getValue());
        }
        con.putIfNotEmpty("timeout", connection.getNfsTimeo());
        con.putIfNotEmpty("retrans", connection.getNfsRetrans());
    }
    return con;
}
#method_after
public static Map<String, String> createStructFromConnection(final StorageServerConnections connection, final StoragePool storagePool) {
    // for information, see _connectionDict2ConnectionInfo in vdsm/storage/hsm.py
    DefaultValueMap con = new DefaultValueMap();
    con.put("id", connection.getid(), Guid.Empty.toString());
    con.put("connection", connection.getconnection(), "");
    con.put("portal", connection.getportal(), "");
    con.put("port", connection.getport(), "");
    con.put("iqn", connection.getiqn(), "");
    con.put("user", connection.getuser_name(), "");
    con.put("password", connection.getpassword(), "");
    con.putIfNotEmpty("initiatorName", connection.getIface());
    // through vds which has no storage pool
    if (storagePool == null || Config.<Boolean>getValue(ConfigValues.AdvancedNFSOptionsEnabled, storagePool.getcompatibility_version().getValue())) {
        // For mnt_options, vfs_type, and protocol_version - if they are null
        // or empty we should not send a key with an empty value
        con.putIfNotEmpty("mnt_options", connection.getMountOptions());
        con.putIfNotEmpty("vfs_type", connection.getVfsType());
        if (connection.getNfsVersion() != null) {
            con.put("protocol_version", connection.getNfsVersion().getValue());
        }
        con.putIfNotEmpty("timeout", connection.getNfsTimeo());
        con.putIfNotEmpty("retrans", connection.getNfsRetrans());
    }
    return con;
}
#end_block

#method_before
protected Pair<Boolean, Integer> connectHostToStorage() {
    List<StorageServerConnections> connections = Arrays.asList(getConnection());
    if (getConnection().getstorage_type() == StorageType.ISCSI) {
        connections = ISCSIStorageHelper.updateInitiators(connections, getVds().getId());
    }
    Map<String, String> result = (HashMap<String, String>) runVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(getVds().getId(), Guid.Empty, getConnection().getstorage_type(), connections)).getReturnValue();
    return new Pair<>(StorageHelperDirector.getInstance().getItem(getConnection().getstorage_type()).isConnectSucceeded(result, connections), Integer.parseInt(result.values().iterator().next()));
}
#method_after
protected Pair<Boolean, Integer> connectHostToStorage() {
    List<StorageServerConnections> connections = Arrays.asList(getConnection());
    if (getConnection().getstorage_type() == StorageType.ISCSI) {
        connections = ISCSIStorageHelper.updateIfaces(connections, getVds().getId());
    }
    Map<String, String> result = (HashMap<String, String>) runVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(getVds().getId(), Guid.Empty, getConnection().getstorage_type(), connections)).getReturnValue();
    return new Pair<>(StorageHelperDirector.getInstance().getItem(getConnection().getstorage_type()).isConnectSucceeded(result, connections), Integer.parseInt(result.values().iterator().next()));
}
#end_block

#method_before
private boolean connectStorageServer(StorageType type, List<StorageServerConnections> connections) {
    boolean connectSucceeded = true;
    if (connections != null && connections.size() > 0) {
        if (type == StorageType.ISCSI) {
            connections = ISCSIStorageHelper.updateInitiators(connections, getVds().getId());
        }
        Map<String, String> retValues = (HashMap<String, String>) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(getVds().getId(), getStoragePool().getId(), type, connections)).getReturnValue();
        connectSucceeded = StorageHelperDirector.getInstance().getItem(type).isConnectSucceeded(retValues, connections);
        log.infoFormat("Host {0} storage connection was {1} ", getVds().getName(), connectSucceeded ? "succeeded" : "failed");
    }
    return connectSucceeded;
}
#method_after
private boolean connectStorageServer(StorageType type, List<StorageServerConnections> connections) {
    boolean connectSucceeded = true;
    if (connections != null && connections.size() > 0) {
        if (type == StorageType.ISCSI) {
            connections = ISCSIStorageHelper.updateIfaces(connections, getVds().getId());
        }
        Map<String, String> retValues = (HashMap<String, String>) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ConnectStorageServer, new StorageServerConnectionManagementVDSParameters(getVds().getId(), getStoragePool().getId(), type, connections)).getReturnValue();
        connectSucceeded = StorageHelperDirector.getInstance().getItem(type).isConnectSucceeded(retValues, connections);
        log.infoFormat("Host {0} storage connection was {1} ", getVds().getName(), connectSucceeded ? "succeeded" : "failed");
    }
    return connectSucceeded;
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("{ id: ");
    sb.append(this.getid());
    sb.append(", connection: ");
    sb.append(this.getconnection());
    sb.append(", iqn: ");
    sb.append(this.getiqn());
    sb.append(", vfsType: ");
    sb.append(this.getVfsType());
    sb.append(", mountOptions: ");
    sb.append(this.getMountOptions());
    sb.append(", nfsVersion: ");
    sb.append(this.getNfsVersion());
    sb.append(", nfsRetrans: ");
    sb.append(this.getNfsRetrans());
    sb.append(", nfsTimeo: ");
    sb.append(this.getNfsTimeo());
    if (getInitiatorName() != null) {
        sb.append(", initiatorName: ");
        sb.append(this.getInitiatorName());
    }
    sb.append(" };");
    return sb.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("{ id: ");
    sb.append(this.getid());
    sb.append(", connection: ");
    sb.append(this.getconnection());
    sb.append(", iqn: ");
    sb.append(this.getiqn());
    sb.append(", vfsType: ");
    sb.append(this.getVfsType());
    sb.append(", mountOptions: ");
    sb.append(this.getMountOptions());
    sb.append(", nfsVersion: ");
    sb.append(this.getNfsVersion());
    sb.append(", nfsRetrans: ");
    sb.append(this.getNfsRetrans());
    sb.append(", nfsTimeo: ");
    sb.append(this.getNfsTimeo());
    if (getIface() != null) {
        sb.append(", iface: ");
        sb.append(this.getIface());
    }
    sb.append(" };");
    return sb.toString();
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new DataCenterStorageListModel());
    iscsiBondListModel = new DataCenterIscsiBondListModel();
    list.add(iscsiBondListModel);
    list.add(new DataCenterNetworkListModel());
    list.add(new DataCenterClusterListModel());
    quotaListModel = new DataCenterQuotaListModel();
    quotaListModel.setIsAvailable(false);
    list.add(quotaListModel);
    list.add(new DataCenterNetworkQoSListModel());
    list.add(new PermissionListModel());
    list.add(new DataCenterEventListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new DataCenterStorageListModel());
    iscsiBundleListModel = new DataCenterIscsiBundleListModel();
    list.add(iscsiBundleListModel);
    list.add(new DataCenterNetworkListModel());
    list.add(new DataCenterClusterListModel());
    quotaListModel = new DataCenterQuotaListModel();
    quotaListModel.setIsAvailable(false);
    list.add(quotaListModel);
    list.add(new DataCenterNetworkQoSListModel());
    list.add(new PermissionListModel());
    list.add(new DataCenterEventListModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    if (getSelectedItem() != null) {
        StoragePool storagePool = (StoragePool) getSelectedItem();
        quotaListModel.setIsAvailable(storagePool.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED);
        iscsiBondListModel.setIsAvailable(storagePool.getStorageType() == StorageType.ISCSI);
    }
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    if (getSelectedItem() != null) {
        StoragePool storagePool = (StoragePool) getSelectedItem();
        quotaListModel.setIsAvailable(storagePool.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED);
        iscsiBundleListModel.setIsAvailable(storagePool.getStorageType() == StorageType.ISCSI);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    bindPresenterWidget(IscsiBondRemovePopupPresenterWidget.class, IscsiBondRemovePopupPresenterWidget.ViewDef.class, IscsiBondRemovePopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBundlePresenter.class, SubTabDataCenterIscsiBundlePresenter.ViewDef.class, SubTabDataCenterIscsiBundleView.class, SubTabDataCenterIscsiBundlePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    // ISCSI Bundle
    bindPresenterWidget(IscsiBundlePopupPresenterWidget.class, IscsiBundlePopupPresenterWidget.ViewDef.class, IscsiBundlePopupView.class);
    bindPresenterWidget(IscsiBundleRemovePopupPresenterWidget.class, IscsiBundleRemovePopupPresenterWidget.ViewDef.class, IscsiBundleRemovePopupView.class);
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
}
#end_block

#method_before
public static void getAllDataCenterNetworks(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworksByDataCenterId, params, aQuery);
}
#method_after
public static void getAllDataCenterNetworks(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    StorageDomainAndPoolQueryParameters params = new StorageDomainAndPoolQueryParameters(null, storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworksByStoragePoolId, params, aQuery);
}
#end_block

#method_before
private void configureNetworksOnHosts(Map<Guid, List<Network>> networksByHost, Map<Guid, Map<String, VdsNetworkInterface>> labelsToNicsByHost) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    for (Guid hostId : networksByHost.keySet()) {
        AddNetworksByLabelParametersBuilder builder = new AddNetworksByLabelParametersBuilder();
        builder.buildParameters(hostId, networksByHost.get(hostId), labelsToNicsByHost.get(hostId));
    }
    getBackend().runInternalMultipleActions(VdcActionType.PersistentSetupNetworks, parameters);
}
#method_after
private void configureNetworksOnHosts(Map<Guid, List<Network>> networksByHost, Map<Guid, Map<String, VdsNetworkInterface>> labelsToNicsByHost) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    for (Guid hostId : networksByHost.keySet()) {
        AddNetworksByLabelParametersBuilder builder = new AddNetworksByLabelParametersBuilder();
        parameters.add(builder.buildParameters(hostId, networksByHost.get(hostId), labelsToNicsByHost.get(hostId)));
    }
    getBackend().runInternalMultipleActions(VdcActionType.PersistentSetupNetworks, parameters);
}
#end_block

#method_before
protected void runCommands() {
    List<AttachNetworkToVdsGroupParameter> params = new ArrayList<>();
    Set<Guid> networkIds = new HashSet<>();
    for (CommandBase<?> command : getCommands()) {
        if (command.getReturnValue().getCanDoAction()) {
            AttachNetworkToVdsGroupParameter parameters = (AttachNetworkToVdsGroupParameter) command.getParameters();
            params.add(parameters);
            Network network = DbFacade.getInstance().getNetworkDao().get(parameters.getNetworkCluster().getNetworkId());
            if (NetworkUtils.isConfiguredByLabel(network)) {
                networkIds.add(network.getId());
            }
        }
    }
    // attaching a single network to multiple clusters can be executed using {@code AttachNetworkToVdsGroupCommand}
    if (networkIds.size() <= 1) {
        super.runCommands();
    }
    // multiple networks can be either attached or detached from a single cluster
    if (!params.isEmpty()) {
        Backend.getInstance().runInternalAction(getActionType(), new ClusterNetworksParameters(params.get(0).getVdsGroupId(), params));
    }
}
#method_after
protected void runCommands() {
    List<AttachNetworkToVdsGroupParameter> params = new ArrayList<>();
    Set<Guid> networkIds = new HashSet<>();
    for (CommandBase<?> command : getCommands()) {
        if (command.getReturnValue().getCanDoAction()) {
            AttachNetworkToVdsGroupParameter parameters = (AttachNetworkToVdsGroupParameter) command.getParameters();
            params.add(parameters);
            Network network = DbFacade.getInstance().getNetworkDao().get(parameters.getNetworkCluster().getNetworkId());
            if (NetworkUtils.isConfiguredByLabel(network)) {
                networkIds.add(network.getId());
            }
        }
    }
    // managing a single network on multiple clusters can be executed using the regular runner
    if (networkIds.size() <= 1) {
        super.runCommands();
        return;
    }
    // multiple networks can be either attached or detached from a single cluster
    if (!params.isEmpty()) {
        Backend.getInstance().runInternalAction(VdcActionType.AttachNetworksToCluster, new ClusterNetworksParameters(params.get(0).getVdsGroupId(), params));
    }
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Windows Sysprep
    domainEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<EntityModel<DisplayType>>(new NullSafeRenderer<EntityModel<DisplayType>>() {

        @Override
        public String renderNullSafe(EntityModel<DisplayType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new AbstractRenderer<String>() {

        final String globalLayout = (String) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayout);

        @Override
        public String render(String object) {
            if (object == null) {
                return messages.globalVncKeyboardLayoutCaption(globalLayout);
            } else {
                return object;
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Windows Sysprep
    domainEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<EntityModel<DisplayType>>(new NullSafeRenderer<EntityModel<DisplayType>>() {

        @Override
        public String renderNullSafe(EntityModel<DisplayType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages));
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    domainEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    domainEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
@Override
public void template_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    getModel().getName().setEntity(vm.getName());
    getModel().getDescription().setEntity(vm.getVmDescription());
    getModel().getComment().setEntity(vm.getComment());
    getModel().getMemSize().setEntity(vm.getVmMemSizeMb());
    getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(vm.getVmOsId());
    getModel().getDomain().setSelectedItem(vm.getVmDomain());
    getModel().getUsbPolicy().setSelectedItem(vm.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(vm.getNumOfMonitors());
    getModel().getIsSingleQxlEnabled().setEntity(vm.getSingleQxlPci());
    getModel().getAllowConsoleReconnect().setEntity(vm.getAllowConsoleReconnect());
    getModel().setBootSequence(vm.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(vm.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(vm.getNumOfCpus()));
    getModel().getTotalCPUCores().setIsChangable(isHotPlugCpuSupported());
    getModel().getIsStateless().setEntity(vm.isStateless());
    getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsRunAndPause().setEntity(vm.isRunAndPause());
    getModel().getIsRunAndPause().setIsChangable(!vm.isRunning());
    getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    getModel().getIsDeleteProtected().setEntity(vm.isDeleteProtected());
    getModel().selectSsoMethod(vm.getSsoMethod());
    getModel().getNumOfSockets().setSelectedItem(vm.getNumOfSockets());
    getModel().getNumOfSockets().setIsChangable(isHotPlugCpuSupported());
    getModel().getCoresPerSocket().setIsChangable(!vm.isRunning());
    getModel().getKernel_parameters().setEntity(vm.getKernelParams());
    getModel().getKernel_path().setEntity(vm.getKernelUrl());
    getModel().getInitrd_path().setEntity(vm.getInitrdUrl());
    getModel().getCustomProperties().setEntity(vm.getCustomProperties());
    getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
    getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
    updateCpuSharesSelection();
    Frontend.getInstance().runQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            @SuppressWarnings("unchecked")
            List<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (watchdogs.isEmpty()) {
                getModel().getWatchdogAction().setSelectedItem(null);
                getModel().getWatchdogModel().setSelectedItem(null);
            } else {
                VmWatchdog vmWatchdog = watchdogs.get(0);
                getModel().getWatchdogAction().setSelectedItem(vmWatchdog.getAction() == null ? null : vmWatchdog.getAction().name().toLowerCase());
                getModel().getWatchdogModel().setSelectedItem(vmWatchdog.getModel() == null ? "" : vmWatchdog.getModel().name());
            }
        }
    }));
    updateConsoleDevice(getVm().getId());
    updateVirtioScsiEnabled(getVm().getId());
    getModel().getVncKeyboardLayout().setSelectedItem(vm.getVncKeyboardLayout());
    Frontend.getInstance().runQuery(VdcQueryType.IsBalloonEnabled, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            getModel().getMemoryBalloonDeviceEnabled().setEntity((Boolean) ((VdcQueryReturnValue) returnValue).getReturnValue());
        }
    }));
    if (vm.isInitialized()) {
        UIConstants constants = ConstantsManager.getInstance().getConstants();
        getModel().getTimeZone().setChangeProhibitionReason(constants.timeZoneCannotBeChangedAfterVMInit());
        getModel().getTimeZone().setIsChangable(false);
    }
    updateTimeZone(vm.getTimeZone());
    // Update domain list
    updateDomain();
    updateHostPinning(vm.getMigrationSupport());
    getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    getModel().getCpuPinning().setEntity(vm.getCpuPinning());
    initPriority(vm.getPriority());
}
#method_after
@Override
public void template_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    getModel().getName().setEntity(vm.getName());
    getModel().getDescription().setEntity(vm.getVmDescription());
    getModel().getComment().setEntity(vm.getComment());
    getModel().getMemSize().setEntity(vm.getVmMemSizeMb());
    getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(vm.getVmOsId());
    getModel().getDomain().setSelectedItem(vm.getVmDomain());
    getModel().getUsbPolicy().setSelectedItem(vm.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(vm.getNumOfMonitors());
    getModel().getIsSingleQxlEnabled().setEntity(vm.getSingleQxlPci());
    getModel().getAllowConsoleReconnect().setEntity(vm.getAllowConsoleReconnect());
    getModel().setBootSequence(vm.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(vm.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(vm.getNumOfCpus()));
    getModel().getTotalCPUCores().setIsChangable(!vm.isRunning());
    getModel().getIsStateless().setEntity(vm.isStateless());
    getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsRunAndPause().setEntity(vm.isRunAndPause());
    getModel().getIsRunAndPause().setIsChangable(!vm.isRunning());
    getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    getModel().getIsDeleteProtected().setEntity(vm.isDeleteProtected());
    getModel().selectSsoMethod(vm.getSsoMethod());
    getModel().getNumOfSockets().setSelectedItem(vm.getNumOfSockets());
    getModel().getNumOfSockets().setIsChangable(isHotSetCpuSupported() || !vm.isRunning());
    getModel().getCoresPerSocket().setIsChangable(!vm.isRunning());
    getModel().getKernel_parameters().setEntity(vm.getKernelParams());
    getModel().getKernel_path().setEntity(vm.getKernelUrl());
    getModel().getInitrd_path().setEntity(vm.getInitrdUrl());
    getModel().getCustomProperties().setEntity(vm.getCustomProperties());
    getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
    getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
    updateCpuSharesSelection();
    Frontend.getInstance().runQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            @SuppressWarnings("unchecked")
            List<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (watchdogs.isEmpty()) {
                getModel().getWatchdogAction().setSelectedItem(null);
                getModel().getWatchdogModel().setSelectedItem(null);
            } else {
                VmWatchdog vmWatchdog = watchdogs.get(0);
                getModel().getWatchdogAction().setSelectedItem(vmWatchdog.getAction() == null ? null : vmWatchdog.getAction().name().toLowerCase());
                getModel().getWatchdogModel().setSelectedItem(vmWatchdog.getModel() == null ? "" : vmWatchdog.getModel().name());
            }
        }
    }));
    updateConsoleDevice(getVm().getId());
    updateVirtioScsiEnabled(getVm().getId());
    getModel().getVncKeyboardLayout().setSelectedItem(vm.getDefaultVncKeyboardLayout());
    Frontend.getInstance().runQuery(VdcQueryType.IsBalloonEnabled, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            getModel().getMemoryBalloonDeviceEnabled().setEntity((Boolean) ((VdcQueryReturnValue) returnValue).getReturnValue());
        }
    }));
    if (vm.isInitialized()) {
        UIConstants constants = ConstantsManager.getInstance().getConstants();
        getModel().getTimeZone().setChangeProhibitionReason(constants.timeZoneCannotBeChangedAfterVMInit());
        getModel().getTimeZone().setIsChangable(false);
    }
    updateTimeZone(vm.getTimeZone());
    // Update domain list
    updateDomain();
    updateHostPinning(vm.getMigrationSupport());
    getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    getModel().getCpuPinning().setEntity(vm.getCpuPinning());
    initPriority(vm.getPriority());
    getModel().setSelectedMigrationDowntime(vm.getMigrationDowntime());
    if (isHotSetCpuSupported()) {
        // cancel related events while fetching data
        getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
        getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
        getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
        AsyncDataProvider.getHostById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                ExistingVmModelBehavior existingVmModelBehavior = (ExistingVmModelBehavior) model;
                runningOnHost = (VDS) returnValue;
                hostCpu = calculateHostCpus();
                existingVmModelBehavior.updateNumOfSockets();
            }
        }), vm.getRunOnVds());
    }
}
#end_block

#method_before
@Override
public void numOfSocketChanged() {
    // changing the architecture is not allowed. the number of sockets is used as the num
    // of virtual cpu to plug/unplug to the VM
    Integer selectedItem = getModel().getNumOfSockets().getSelectedItem();
    Integer selectedItem1 = getModel().getCoresPerSocket().getSelectedItem();
    getModel().getTotalCPUCores().setEntity(Integer.toString(selectedItem * selectedItem1));
}
#method_after
@Override
public void numOfSocketChanged() {
    if (isHotSetCpuSupported()) {
        int numOfSockets = extractIntFromListModel(getModel().getNumOfSockets());
        int coresPerSocket = vm.getCpuPerSocket();
        getModel().getTotalCPUCores().setEntity(Integer.toString(numOfSockets * coresPerSocket));
    } else {
        super.numOfSocketChanged();
    }
}
#end_block

#method_before
private static void initSeverities() {
    initDefaultSeverities();
    initProviderSeverities();
    initNetworkSeverities();
    initImportExportSeverities();
    initEngineSeverities();
    initVMsPoolSeverities();
    initBookmarkSeverities();
    initVMSeverities();
    initQuotaSeverities();
    initQoSSeverities();
    initTagSeverities();
    initClusterSeverities();
    initMLASeverities();
    initHostSeverities();
    initStorageSeverities();
    initTaskSeverities();
    initGlusterSeverities();
    initDwhSeverities();
    initConfigSeverities();
    initUserAccountSeverities();
    initCommonSeverities();
    initClusterPolicySeverities();
    initExtrnalEvents();
}
#method_after
private static void initSeverities() {
    initDefaultSeverities();
    initProviderSeverities();
    initNetworkSeverities();
    initImportExportSeverities();
    initEngineSeverities();
    initVMsPoolSeverities();
    initBookmarkSeverities();
    initVMSeverities();
    initQuotaSeverities();
    initQoSSeverities();
    initTagSeverities();
    initClusterSeverities();
    initMLASeverities();
    initHostSeverities();
    initStorageSeverities();
    initTaskSeverities();
    initGlusterSeverities();
    initDwhSeverities();
    initConfigSeverities();
    initUserAccountSeverities();
    initCommonSeverities();
    initClusterPolicySeverities();
    initExtrnalEvents();
    initMomPoliciesSeverities();
    initPmPolicySeverities();
}
#end_block

#method_before
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STATUS_CHANGE_FAILED_DUE_TO_STOP_SPM_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#method_after
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ARCHITECTURE_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STATUS_CHANGE_FAILED_DUE_TO_STOP_SPM_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SET_NUMBER_OF_CPUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.FAILED_SET_NUMBER_OF_CPUS, AuditLogSeverity.ERROR);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOT_SET_NUMBER_OF_CPUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXCEEDED_MAXIMUM_NUM_OF_RESTART_HA_VM_ATTEMPTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_CONSOLE_CONNECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CONSOLE_DISCONNECTED, AuditLogSeverity.NORMAL);
}
#method_after
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REBOOT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REBOOT_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXCEEDED_MAXIMUM_NUM_OF_RESTART_HA_VM_ATTEMPTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_CONSOLE_CONNECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CONSOLE_DISCONNECTED, AuditLogSeverity.NORMAL);
}
#end_block

#method_before
private static void initClusterSeverities() {
    severities.put(AuditLogType.USER_ADD_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_UPDATE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_UPDATE_VDS_GROUP_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_CLUSTER_DEFAULT_HOST_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
}
#method_after
private static void initClusterSeverities() {
    severities.put(AuditLogType.USER_ADD_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_UPDATE_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_UPDATE_VDS_GROUP_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_CLUSTER_DEFAULT_HOST_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CLUSTER_ALERT_HA_RESERVATION, AuditLogSeverity.ALERT);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + cpuPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + osId;
    result = prime * result + memSizeMb;
    result = prime * result + niceLevel;
    result = prime * result + cpuShares;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((dedicatedVmForVds == null) ? 0 : dedicatedVmForVds.hashCode());
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((tunnelMigration == null) ? 0 : tunnelMigration.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((createdByUserId == null) ? 0 : createdByUserId.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + cpuPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + osId;
    result = prime * result + memSizeMb;
    result = prime * result + niceLevel;
    result = prime * result + cpuShares;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((dedicatedVmForVds == null) ? 0 : dedicatedVmForVds.hashCode());
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((tunnelMigration == null) ? 0 : tunnelMigration.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((createdByUserId == null) ? 0 : createdByUserId.hashCode());
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + ((migrationDowntime == null) ? 0 : migrationDowntime.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && ObjectUtils.objectsEqual(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && ObjectUtils.objectsEqual(description, other.description) && ObjectUtils.objectsEqual(domain, other.domain) && failBack == other.failBack && ObjectUtils.objectsEqual(initrdUrl, other.initrdUrl) && ObjectUtils.objectsEqual(isoPath, other.isoPath) && ObjectUtils.objectsEqual(kernelParams, other.kernelParams) && ObjectUtils.objectsEqual(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && ObjectUtils.objectsEqual(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && ObjectUtils.objectsEqual(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && ObjectUtils.objectsEqual(dedicatedVmForVds, other.dedicatedVmForVds) && migrationSupport == other.migrationSupport && ObjectUtils.objectsEqual(tunnelMigration, other.tunnelMigration) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && ObjectUtils.objectsEqual(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && ObjectUtils.objectsEqual(description, other.description) && ObjectUtils.objectsEqual(domain, other.domain) && failBack == other.failBack && ObjectUtils.objectsEqual(initrdUrl, other.initrdUrl) && ObjectUtils.objectsEqual(isoPath, other.isoPath) && ObjectUtils.objectsEqual(kernelParams, other.kernelParams) && ObjectUtils.objectsEqual(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && ObjectUtils.objectsEqual(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && ObjectUtils.objectsEqual(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && ObjectUtils.objectsEqual(dedicatedVmForVds, other.dedicatedVmForVds) && migrationSupport == other.migrationSupport && ObjectUtils.objectsEqual(tunnelMigration, other.tunnelMigration) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && ObjectUtils.objectsEqual(migrationDowntime, other.migrationDowntime));
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    VmStatic newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    UpdateVmNetworks();
    getVmStaticDAO().update(newVmStatic);
    updateVmPayload();
    VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
    updateWatchdog();
    checkTrustedService();
    hotPlugUnplugCpus();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getcompatibility_version());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    UpdateVmNetworks();
    hotSetCpus();
    getVmStaticDAO().update(newVmStatic);
    updateVmPayload();
    VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
    updateWatchdog();
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        addCanDoActionMessage("$device console");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        addCanDoActionMessage("$device sound");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, getParameters().isVirtioScsiEnabled())) {
        addCanDoActionMessage("$device VirtIO-SCSI");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        addCanDoActionMessage("$device console");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        addCanDoActionMessage("$device sound");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName(), getParameters().isVirtioScsiEnabled())) {
        addCanDoActionMessage("$device VirtIO-SCSI");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    return true;
}
#end_block

#method_before
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), getParameters().isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
private boolean vmDeviceChanged(VmDeviceGeneralType deviceType, boolean deviceEnabled) {
    List<VmDevice> vmDevices = getVmDeviceDao().getVmDeviceByVmIdAndType(getParameters().getVmId(), deviceType);
    return deviceEnabled == vmDevices.isEmpty();
}
#method_after
private boolean vmDeviceChanged(VmDeviceGeneralType deviceType, String device, boolean deviceEnabled) {
    List<VmDevice> vmDevices = getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(getParameters().getVmId(), deviceType, device);
    return deviceEnabled == vmDevices.isEmpty();
}
#end_block

#method_before
protected boolean hasWatchdog() {
    return getParameters().getWatchdog() != null ? true : VmDeviceUtils.hasWatchdog(getVmId());
}
#method_after
protected boolean hasWatchdog() {
    return getParameters().getWatchdog() != null;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc shutdown(String vmId, String timeout, String message) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.shutdown(vmId, timeout, message);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc shutdown(String vmId, String timeout, String message, boolean reboot) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.shutdown(vmId, timeout, message, reboot);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "incomplete-switch" })
private GlusterVolumeEntity getVolume(Map<String, Object> map) {
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setClusterId(clusterId);
    volume.setId(Guid.createGuidFromStringDefaultEmpty((String) map.get(UUID)));
    volume.setName((String) map.get(VOLUME_NAME));
    volume.setVolumeType((String) map.get(VOLUME_TYPE));
    if (volume.getVolumeType() != null) {
        if (volume.getVolumeType().isReplicatedType()) {
            volume.setReplicaCount(Integer.valueOf((String) map.get(REPLICA_COUNT)));
        }
        if (volume.getVolumeType().isStripedType()) {
            volume.setStripeCount(Integer.valueOf((String) map.get(STRIPE_COUNT)));
        }
    }
    for (Object transportType : (Object[]) map.get(TRANSPORT_TYPE)) {
        volume.addTransportType(TransportType.valueOf((String) transportType));
    }
    String volStatus = (String) map.get(VOLUME_STATUS);
    if (volStatus.toUpperCase().equals(VOLUME_STATUS_ONLINE)) {
        volume.setStatus(GlusterStatus.UP);
    } else {
        volume.setStatus(GlusterStatus.DOWN);
    }
    try {
        if (map.get(BRICKS_INFO) != null) {
            volume.setBricks(getBricks(volume.getId(), (Object[]) map.get(BRICKS_INFO), true));
        } else {
            volume.setBricks(getBricks(volume.getId(), (Object[]) map.get(BRICKS), false));
        }
    } catch (Exception e) {
        log.errorFormat("Could not populate bricks of volume {0} on cluster {1}.", volume.getName(), clusterId, e);
    }
    volume.setOptions(getOptions((Map<String, Object>) map.get(OPTIONS)));
    return volume;
}
#method_after
@SuppressWarnings({ "unchecked", "incomplete-switch" })
private GlusterVolumeEntity getVolume(Map<String, Object> map) {
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setClusterId(clusterId);
    volume.setId(Guid.createGuidFromStringDefaultEmpty((String) map.get(UUID)));
    volume.setName((String) map.get(VOLUME_NAME));
    volume.setVolumeType((String) map.get(VOLUME_TYPE));
    if (volume.getVolumeType() != null) {
        if (volume.getVolumeType().isReplicatedType()) {
            volume.setReplicaCount(Integer.valueOf((String) map.get(REPLICA_COUNT)));
        }
        if (volume.getVolumeType().isStripedType()) {
            volume.setStripeCount(Integer.valueOf((String) map.get(STRIPE_COUNT)));
        }
    }
    for (Object transportType : (Object[]) map.get(TRANSPORT_TYPE)) {
        volume.addTransportType(TransportType.valueOf((String) transportType));
    }
    String volStatus = (String) map.get(VOLUME_STATUS);
    if (volStatus.toUpperCase().equals(VOLUME_STATUS_ONLINE)) {
        volume.setStatus(GlusterStatus.UP);
    } else {
        volume.setStatus(GlusterStatus.DOWN);
    }
    try {
        if (map.get(BRICKS_INFO) != null && ((Object[]) map.get(BRICKS_INFO)).length > 0) {
            volume.setBricks(getBricks(volume.getId(), (Object[]) map.get(BRICKS_INFO), true));
        } else {
            volume.setBricks(getBricks(volume.getId(), (Object[]) map.get(BRICKS), false));
        }
    } catch (Exception e) {
        log.errorFormat("Could not populate bricks of volume {0} on cluster {1}.", volume.getName(), clusterId, e);
    }
    volume.setOptions(getOptions((Map<String, Object>) map.get(OPTIONS)));
    return volume;
}
#end_block

#method_before
private GlusterBrickEntity getBrick(Guid clusterId, Guid volumeId, String brickInfo, int brickOrder) {
    String[] brickParts = brickInfo.split(":", -1);
    if (brickParts.length != 2) {
        throw new RuntimeException("Invalid brick representation [" + brickInfo + "]");
    }
    String hostnameOrIp = brickParts[0];
    String brickDir = brickParts[1];
    VdsStatic server = dbUtils.getServer(clusterId, hostnameOrIp);
    if (server == null) {
        log.errorFormat("Could not add brick {0} to volume {1} - server {2} not found in cluster {3}", brickInfo, volumeId, hostnameOrIp, clusterId);
        return null;
    }
    return getBrickEntity(clusterId, volumeId, brickOrder, server, brickDir);
}
#method_after
private GlusterBrickEntity getBrick(Guid clusterId, Guid volumeId, String brickInfo, int brickOrder) {
    String[] brickParts = brickInfo.split(":", -1);
    if (brickParts.length != 2) {
        throw new RuntimeException("Invalid brick representation [" + brickInfo + "]");
    }
    String hostnameOrIp = brickParts[0];
    String brickDir = brickParts[1];
    VdsStatic server = dbUtils.getServer(clusterId, hostnameOrIp);
    if (server == null) {
        log.warnFormat("Could not add brick {0} to volume {1} - server {2} not found in cluster {3}", brickInfo, volumeId, hostnameOrIp, clusterId);
        return null;
    }
    return getBrickEntity(clusterId, volumeId, brickOrder, server, brickDir);
}
#end_block

#method_before
private GlusterBrickEntity getBrick(Guid clusterId, Guid volumeId, Map<String, Object> brickInfoMap, int brickOrder) {
    String brickName = (String) brickInfoMap.get(NAME);
    String[] brickParts = brickName.split(":", -1);
    if (brickParts.length != 2) {
        throw new RuntimeException("Invalid brick representation [" + brickName + "]");
    }
    String hostUuid = (String) brickInfoMap.get(UUID);
    String brickDir = brickParts[1];
    GlusterServer glusterServer = dbUtils.getServerByUuid(Guid.createGuidFromString(hostUuid));
    if (glusterServer == null) {
        log.errorFormat("Could not add brick {0} to volume {1} - server uuid {2} not found in cluster {3}", brickName, volumeId, hostUuid, clusterId);
        return null;
    }
    VdsStatic server = DbFacade.getInstance().getVdsStaticDao().get(glusterServer.getId());
    return getBrickEntity(clusterId, volumeId, brickOrder, server, brickDir);
}
#method_after
private GlusterBrickEntity getBrick(Guid clusterId, Guid volumeId, Map<String, Object> brickInfoMap, int brickOrder) {
    String brickName = (String) brickInfoMap.get(NAME);
    String[] brickParts = brickName.split(":", -1);
    if (brickParts.length != 2) {
        throw new RuntimeException("Invalid brick representation [" + brickName + "]");
    }
    String hostUuid = (String) brickInfoMap.get(HOST_UUID);
    String brickDir = brickParts[1];
    GlusterServer glusterServer = dbUtils.getServerByUuid(Guid.createGuidFromString(hostUuid));
    if (glusterServer == null) {
        log.warnFormat("Could not add brick {0} to volume {1} - server uuid {2} not found in cluster {3}", brickName, volumeId, hostUuid, clusterId);
        return null;
    }
    VdsStatic server = DbFacade.getInstance().getVdsStaticDao().get(glusterServer.getId());
    return getBrickEntity(clusterId, volumeId, brickOrder, server, brickDir);
}
#end_block

#method_before
@Mapping(from = Cluster.class, to = VDSGroup.class)
public static VDSGroup map(Cluster model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCpu() && model.getCpu().isSetId()) {
        entity.setcpu_name(model.getCpu().getId());
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setArchitecture(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setcompatibility_version(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    if (model.isSetSchedulingPolicy()) {
        entity = map(model.getSchedulingPolicy(), entity);
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetTrustedService()) {
        entity.setTrustedService(model.isTrustedService());
    }
    if (model.isSetHaReservation()) {
        entity.setHaReservation(model.isHaReservation());
    }
    if (model.isSetBallooningEnabled()) {
        entity.setEnableBallooning(model.isBallooningEnabled());
    }
    if (model.isSetKsmEnabled()) {
        entity.setEnableKsm(model.isKsmEnabled());
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    return entity;
}
#method_after
@Mapping(from = Cluster.class, to = VDSGroup.class)
public static VDSGroup map(Cluster model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCpu() && model.getCpu().isSetId()) {
        entity.setcpu_name(model.getCpu().getId());
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setArchitecture(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setcompatibility_version(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    if (model.isSetSchedulingPolicy()) {
        entity = map(model.getSchedulingPolicy(), entity);
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetTrustedService()) {
        entity.setTrustedService(model.isTrustedService());
    }
    if (model.isSetHaReservation()) {
        entity.setHaReservation(model.isHaReservation());
    }
    if (model.isSetBallooningEnabled()) {
        entity.setEnableBallooning(model.isBallooningEnabled());
    }
    if (model.isSetKsm() && model.getKsm().isSetEnabled()) {
        entity.setEnableKsm(model.getKsm().isEnabled());
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDSGroup.class, to = Cluster.class)
public static Cluster map(VDSGroup entity, Cluster template) {
    Cluster model = template != null ? template : new Cluster();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getdescription());
    model.setComment(entity.getComment());
    if (entity.getcpu_name() != null) {
        CPU cpu = new CPU();
        cpu.setId(entity.getcpu_name());
        cpu.setArchitecture(CPUMapper.map(entity.getArchitecture(), null));
        model.setCpu(cpu);
    }
    if (entity.getStoragePoolId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getStoragePoolId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getcompatibility_version() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getcompatibility_version().getMajor());
        model.getVersion().setMinor(entity.getcompatibility_version().getMinor());
    }
    model.setMemoryPolicy(map(entity, (MemoryPolicy) null));
    model.setSchedulingPolicy(map(entity, (SchedulingPolicy) null));
    model.setErrorHandling(map(entity.getMigrateOnError(), (ErrorHandling) null));
    model.setVirtService(entity.supportsVirtService());
    model.setGlusterService(entity.supportsGlusterService());
    model.setThreadsAsCores(entity.getCountThreadsAsCores());
    model.setTunnelMigration(entity.isTunnelMigration());
    model.setTrustedService(entity.supportsTrustedService());
    model.setHaReservation(entity.supportsHaReservation());
    model.setBallooningEnabled(entity.isEnableBallooning());
    model.setKsmEnabled(entity.isEnableKsm());
    if (StringUtils.isNotBlank(entity.getSpiceProxy())) {
        Display display = new Display();
        display.setProxy(entity.getSpiceProxy());
        model.setDisplay(display);
    }
    return model;
}
#method_after
@Mapping(from = VDSGroup.class, to = Cluster.class)
public static Cluster map(VDSGroup entity, Cluster template) {
    Cluster model = template != null ? template : new Cluster();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getdescription());
    model.setComment(entity.getComment());
    if (entity.getcpu_name() != null) {
        CPU cpu = new CPU();
        cpu.setId(entity.getcpu_name());
        cpu.setArchitecture(CPUMapper.map(entity.getArchitecture(), null));
        model.setCpu(cpu);
    }
    if (entity.getStoragePoolId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getStoragePoolId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getcompatibility_version() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getcompatibility_version().getMajor());
        model.getVersion().setMinor(entity.getcompatibility_version().getMinor());
    }
    model.setMemoryPolicy(map(entity, (MemoryPolicy) null));
    model.setSchedulingPolicy(map(entity, (SchedulingPolicy) null));
    model.setErrorHandling(map(entity.getMigrateOnError(), (ErrorHandling) null));
    model.setVirtService(entity.supportsVirtService());
    model.setGlusterService(entity.supportsGlusterService());
    model.setThreadsAsCores(entity.getCountThreadsAsCores());
    model.setTunnelMigration(entity.isTunnelMigration());
    model.setTrustedService(entity.supportsTrustedService());
    model.setHaReservation(entity.supportsHaReservation());
    model.setBallooningEnabled(entity.isEnableBallooning());
    model.setKsm(new KSM());
    model.getKsm().setEnabled(entity.isEnableKsm());
    if (StringUtils.isNotBlank(entity.getSpiceProxy())) {
        Display display = new Display();
        display.setProxy(entity.getSpiceProxy());
        model.setDisplay(display);
    }
    return model;
}
#end_block

#method_before
@Override
protected void verify(Cluster model, Cluster transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertNotNull(transform.getCpu());
    assertEquals(model.getCpu().getId(), transform.getCpu().getId());
    assertNotNull(transform.getDataCenter());
    assertEquals(model.getDataCenter().getId(), transform.getDataCenter().getId());
    assertNotNull(transform.getSchedulingPolicy());
    assertEquals(model.getSchedulingPolicy().getPolicy(), transform.getSchedulingPolicy().getPolicy());
    assertEquals(model.getErrorHandling().getOnError(), transform.getErrorHandling().getOnError());
    assertNotNull(transform.getMemoryPolicy());
    assertNotNull(transform.getMemoryPolicy().getTransparentHugepages());
    assertEquals(transform.getMemoryPolicy().getTransparentHugepages().isEnabled(), transform.getMemoryPolicy().getTransparentHugepages().isEnabled());
    assertEquals(model.isVirtService(), transform.isVirtService());
    assertEquals(model.isGlusterService(), transform.isGlusterService());
    assertEquals(model.isTunnelMigration(), transform.isTunnelMigration());
    assertEquals(model.isTrustedService(), transform.isTrustedService());
    assertEquals(model.isBallooningEnabled(), transform.isBallooningEnabled());
    assertEquals(model.isKsmEnabled(), transform.isKsmEnabled());
    assertEquals(model.getDisplay().getProxy(), transform.getDisplay().getProxy());
}
#method_after
@Override
protected void verify(Cluster model, Cluster transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertNotNull(transform.getCpu());
    assertEquals(model.getCpu().getId(), transform.getCpu().getId());
    assertNotNull(transform.getDataCenter());
    assertEquals(model.getDataCenter().getId(), transform.getDataCenter().getId());
    assertNotNull(transform.getSchedulingPolicy());
    assertEquals(model.getSchedulingPolicy().getPolicy(), transform.getSchedulingPolicy().getPolicy());
    assertEquals(model.getErrorHandling().getOnError(), transform.getErrorHandling().getOnError());
    assertNotNull(transform.getMemoryPolicy());
    assertNotNull(transform.getMemoryPolicy().getTransparentHugepages());
    assertEquals(transform.getMemoryPolicy().getTransparentHugepages().isEnabled(), transform.getMemoryPolicy().getTransparentHugepages().isEnabled());
    assertEquals(model.isVirtService(), transform.isVirtService());
    assertEquals(model.isGlusterService(), transform.isGlusterService());
    assertEquals(model.isTunnelMigration(), transform.isTunnelMigration());
    assertEquals(model.isTrustedService(), transform.isTrustedService());
    assertEquals(model.isBallooningEnabled(), transform.isBallooningEnabled());
    assertEquals(model.getKsm().isEnabled(), transform.getKsm().isEnabled());
    assertEquals(model.getDisplay().getProxy(), transform.getDisplay().getProxy());
}
#end_block

#method_before
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setdescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()) || version.compareTo(Version.v3_4) < 0);
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setdescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    getEnableKsm().setIsChangable(version.compareTo(Version.v3_4) >= 0);
}
#method_after
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso()) {
        staticVm.setSsoMethod(SsoUtils.fromRestToBackend(vm.getSso()));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setDomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso() && vm.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(vm.getSso(), null));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setDomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    if (entity.getSsoMethod() != null) {
        model.setSso(SsoUtils.fromBackendToRest(entity.getSsoMethod()));
    }
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    return model;
}
#end_block

#method_before
@Mapping(from = VM.class, to = RunVmOnceParams.class)
public static RunVmOnceParams map(VM vm, RunVmOnceParams template) {
    RunVmOnceParams params = template != null ? template : new RunVmOnceParams();
    if (vm.isSetStateless() && vm.isStateless()) {
        params.setRunAsStateless(true);
    }
    if (vm.isSetDisplay() && vm.getDisplay().isSetType()) {
        DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
        if (displayType != null) {
            params.setUseVnc(displayType == DisplayType.VNC);
        }
    }
    if (vm.isSetOs() && vm.getOs().getBoot().size() > 0) {
        params.setBootSequence(map(vm.getOs().getBoot(), null));
    }
    if (vm.isSetCdroms() && vm.getCdroms().isSetCdRoms()) {
        String file = vm.getCdroms().getCdRoms().get(0).getFile().getId();
        if (file != null) {
            params.setDiskPath(file);
        }
    }
    if (vm.isSetFloppies() && vm.getFloppies().isSetFloppies()) {
        String file = vm.getFloppies().getFloppies().get(0).getFile().getId();
        if (file != null) {
            params.setFloppyPath(file);
        }
    }
    if (vm.isSetCustomProperties()) {
        params.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            params.setBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            params.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            params.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            params.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        params.setSysPrepDomainName(vm.getDomain().getName());
        if (vm.getDomain().isSetUser()) {
            if (vm.getDomain().getUser().isSetUserName()) {
                params.setSysPrepUserName(vm.getDomain().getUser().getUserName());
            }
            if (vm.getDomain().getUser().isSetPassword()) {
                params.setSysPrepPassword(vm.getDomain().getUser().getPassword());
            }
        }
    }
    if (vm.isSetCpuShares()) {
        params.setCpuShares(vm.getCpuShares());
    }
    return params;
}
#method_after
@Mapping(from = VM.class, to = RunVmOnceParams.class)
public static RunVmOnceParams map(VM vm, RunVmOnceParams template) {
    RunVmOnceParams params = template != null ? template : new RunVmOnceParams();
    if (vm.isSetStateless() && vm.isStateless()) {
        params.setRunAsStateless(true);
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                params.setUseVnc(displayType == DisplayType.VNC);
            }
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String vncKeyboardLayout = vm.getDisplay().getKeyboardLayout();
            params.setVncKeyboardLayout(vncKeyboardLayout);
        }
    }
    if (vm.isSetOs() && vm.getOs().getBoot().size() > 0) {
        params.setBootSequence(map(vm.getOs().getBoot(), null));
    }
    if (vm.isSetCdroms() && vm.getCdroms().isSetCdRoms()) {
        String file = vm.getCdroms().getCdRoms().get(0).getFile().getId();
        if (file != null) {
            params.setDiskPath(file);
        }
    }
    if (vm.isSetFloppies() && vm.getFloppies().isSetFloppies()) {
        String file = vm.getFloppies().getFloppies().get(0).getFile().getId();
        if (file != null) {
            params.setFloppyPath(file);
        }
    }
    if (vm.isSetCustomProperties()) {
        params.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            params.setBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            params.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            params.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            params.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        params.setSysPrepDomainName(vm.getDomain().getName());
        if (vm.getDomain().isSetUser()) {
            if (vm.getDomain().getUser().isSetUserName()) {
                params.setSysPrepUserName(vm.getDomain().getUser().getUserName());
            }
            if (vm.getDomain().getUser().isSetPassword()) {
                params.setSysPrepPassword(vm.getDomain().getUser().getPassword());
            }
        }
    }
    if (vm.isSetCpuShares()) {
        params.setCpuShares(vm.getCpuShares());
    }
    return params;
}
#end_block

#method_before
@Mapping(from = Template.class, to = VmTemplate.class)
public static VmTemplate map(Template model, VmTemplate incoming) {
    VmTemplate entity = incoming != null ? incoming : new VmTemplate();
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        entity.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso()) {
        entity.setSsoMethod(SsoUtils.fromRestToBackend(model.getSso()));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        entity.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        entity.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setClusterArch(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetCpuShares()) {
        entity.setCpuShares(model.getCpuShares());
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            entity.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                entity.setDefaultDisplayType(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            entity.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            entity.setVncKeyboardLayout(layout);
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        entity.setDomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        String timezone = model.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        entity.setTimeZone(timezone);
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    return entity;
}
#method_after
@Mapping(from = Template.class, to = VmTemplate.class)
public static VmTemplate map(Template model, VmTemplate incoming) {
    VmTemplate entity = incoming != null ? incoming : new VmTemplate();
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        entity.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        entity.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        entity.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        entity.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setClusterArch(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetCpuShares()) {
        entity.setCpuShares(model.getCpuShares());
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            entity.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                entity.setDefaultDisplayType(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            entity.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            entity.setVncKeyboardLayout(layout);
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        entity.setDomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        String timezone = model.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        entity.setTimeZone(timezone);
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = Template.class, to = VmStatic.class)
public static VmStatic map(Template model, VmStatic incoming) {
    VmStatic staticVm = incoming != null ? incoming : new VmStatic();
    if (model.isSetName()) {
        staticVm.setName(model.getName());
    }
    if (model.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        staticVm.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        staticVm.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            staticVm.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            staticVm.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        staticVm.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso()) {
        staticVm.setSsoMethod(SsoUtils.fromRestToBackend(model.getSso()));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            staticVm.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        staticVm.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        staticVm.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            staticVm.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            staticVm.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetCpuShares()) {
        staticVm.setCpuShares(model.getCpuShares());
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            staticVm.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            staticVm.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            staticVm.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        staticVm.setDomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        staticVm.setTimeZone(model.getTimezone());
    }
    if (model.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(model.isTunnelMigration());
    }
    return staticVm;
}
#method_after
@Mapping(from = Template.class, to = VmStatic.class)
public static VmStatic map(Template model, VmStatic incoming) {
    VmStatic staticVm = incoming != null ? incoming : new VmStatic();
    if (model.isSetName()) {
        staticVm.setName(model.getName());
    }
    if (model.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        staticVm.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        staticVm.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            staticVm.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            staticVm.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        staticVm.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            staticVm.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        staticVm.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        staticVm.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            staticVm.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            staticVm.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetCpuShares()) {
        staticVm.setCpuShares(model.getCpuShares());
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            staticVm.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            staticVm.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            staticVm.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        staticVm.setDomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        staticVm.setTimeZone(model.getTimezone());
    }
    if (model.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(model.isTunnelMigration());
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = Template.class)
public static Template map(VmTemplate entity, Template incoming) {
    Template model = incoming != null ? incoming : new Template();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoUtils.fromBackendToRest(entity.getSsoMethod()));
    if (entity.getVmType() != null) {
        model.setType(VmMapper.map(entity.getVmType(), null));
    }
    if (entity.getOrigin() != null) {
        model.setOrigin(VmMapper.map(entity.getOrigin(), null));
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
    }
    if (entity.getDefaultBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getOsId()));
        if (entity.getDefaultBootSequence() != null) {
            for (Boot boot : VmMapper.map(entity.getDefaultBootSequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    model.setCpu(new CPU());
    model.getCpu().setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    if (entity.getDefaultDisplayType() != null) {
        model.setDisplay(new Display());
        model.getDisplay().setType(VmMapper.map(entity.getDefaultDisplayType(), null));
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.isAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getVncKeyboardLayout());
    }
    if (entity.getClusterArch() != null) {
        model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    }
    if (entity.getCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getCreationDate(), null));
    }
    if (entity.getDomain() != null && !entity.getDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getDomain());
        model.setDomain(domain);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    model.setTimezone(entity.getTimeZone());
    model.setTunnelMigration(entity.getTunnelMigration());
    return model;
}
#method_after
@Mapping(from = VmTemplate.class, to = Template.class)
public static Template map(VmTemplate entity, Template incoming) {
    Template model = incoming != null ? incoming : new Template();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    if (entity.getVmType() != null) {
        model.setType(VmMapper.map(entity.getVmType(), null));
    }
    if (entity.getOrigin() != null) {
        model.setOrigin(VmMapper.map(entity.getOrigin(), null));
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
    }
    if (entity.getDefaultBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getOsId()));
        if (entity.getDefaultBootSequence() != null) {
            for (Boot boot : VmMapper.map(entity.getDefaultBootSequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    model.setCpu(new CPU());
    model.getCpu().setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    if (entity.getDefaultDisplayType() != null) {
        model.setDisplay(new Display());
        model.getDisplay().setType(VmMapper.map(entity.getDefaultDisplayType(), null));
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.isAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getVncKeyboardLayout());
    }
    if (entity.getClusterArch() != null) {
        model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    }
    if (entity.getCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getCreationDate(), null));
    }
    if (entity.getDomain() != null && !entity.getDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getDomain());
        model.setDomain(domain);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    model.setTimezone(entity.getTimeZone());
    model.setTunnelMigration(entity.getTunnelMigration());
    return model;
}
#end_block

#method_before
void initTable(ApplicationResources resources, ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VmStatusColumn<VM>(), constants.empty(), "30px");
    // $NON-NLS-1$
    getTable().addColumn(new VmTypeColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VM> nameColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "120px");
    TextColumnWithTooltip<VM> hostColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getRunOnVdsName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.hostVm(), "120px");
    TextColumnWithTooltip<VM> ipColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmIp();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(ipColumn, constants.ipVm(), "120px");
    TextColumnWithTooltip<VM> fqdnColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmFQDN();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(fqdnColumn, constants.fqdn(), "120px");
    TextColumnWithTooltip<VM> clusterColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVm(), "120px");
    TextColumnWithTooltip<VM> dcColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getStoragePoolName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcVm(), "120px");
    PercentColumn<VM> memoryColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageMemPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "60px");
    PercentColumn<VM> cpuColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageCpuPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuVm(), "60px");
    PercentColumn<VM> networkColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageNetworkPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(networkColumn, constants.networkVm(), "60px");
    TextColumnWithTooltip<VM> displayColumn = new EnumColumn<VM, DisplayType>() {

        @Override
        protected DisplayType getRawValue(VM object) {
            return object.getDisplayType();
        }

        @Override
        public String getValue(VM object) {
            if ((object.getStatus() == VMStatus.Down) || (object.getStatus() == VMStatus.ImageLocked))
                // $NON-NLS-1$
                return "";
            else
                return renderer.render(getRawValue(object));
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(displayColumn, constants.displayVm(), "80px");
    TextColumnWithTooltip<VM> statusColumn = new EnumColumn<VM, VMStatus>() {

        @Override
        public VMStatus getRawValue(VM object) {
            switch(object.getStatus()) {
                case PreparingForHibernate:
                    return VMStatus.SavingState;
                default:
                    return object.getStatus();
            }
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusVm(), "80px");
    TextColumnWithTooltip<VM> uptimeColumn = new UptimeColumn<VM>() {

        @Override
        public Double getRawValue(VM object) {
            return object.getRoundedElapsedTime();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(uptimeColumn, constants.uptimeVm(), "120px");
    // $NON-NLS-1$
    getTable().addColumn(new CommentColumn<VM>(), constants.commentLabel(), "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVmCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunOnceCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.runVm(), resources.runVmImage(), resources.runVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.suspendVm(), resources.suspendVmImage(), resources.suspendVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getPauseCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.shutDownVm(), resources.stopVmImage(), resources.stopVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShutdownCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.powerOffVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.rebootVm(), resources.rebootImage(), resources.rebootDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRebootCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.consoleVm(), resources.consoleImage(), resources.consoleDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConsoleConnectCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(commonConstants.consoleOptions(), // $NON-NLS-1$
    CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditConsoleCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.migrateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cancelMigrationVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCancelMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewTemplateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.exportVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getExportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.createSnapshotVM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateSnapshotCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cheangeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getChangeCdCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.assignTagsVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VM>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("VM", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VM>(constants.showReportVm(), resourceSubActions));
        }
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.guideMeVm(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
}
#method_after
void initTable(ApplicationResources resources, ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VmStatusColumn<VM>(), constants.empty(), "30px");
    // $NON-NLS-1$
    getTable().addColumn(new VmTypeColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VM> nameColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "120px");
    CommentColumn<VM> commentColumn = new CommentColumn<VM>();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(commentColumn, commentColumn.getHeaderHtml(), "30px");
    TextColumnWithTooltip<VM> hostColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getRunOnVdsName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.hostVm(), "120px");
    TextColumnWithTooltip<VM> ipColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmIp();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(ipColumn, constants.ipVm(), "120px");
    TextColumnWithTooltip<VM> fqdnColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmFQDN();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(fqdnColumn, constants.fqdn(), "120px");
    TextColumnWithTooltip<VM> clusterColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVm(), "120px");
    TextColumnWithTooltip<VM> dcColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getStoragePoolName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcVm(), "120px");
    PercentColumn<VM> memoryColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageMemPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "60px");
    PercentColumn<VM> cpuColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageCpuPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuVm(), "60px");
    PercentColumn<VM> networkColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageNetworkPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(networkColumn, constants.networkVm(), "60px");
    TextColumnWithTooltip<VM> displayColumn = new EnumColumn<VM, DisplayType>() {

        @Override
        protected DisplayType getRawValue(VM object) {
            return object.getDisplayType();
        }

        @Override
        public String getValue(VM object) {
            if ((object.getStatus() == VMStatus.Down) || (object.getStatus() == VMStatus.ImageLocked))
                // $NON-NLS-1$
                return "";
            else
                return renderer.render(getRawValue(object));
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(displayColumn, constants.displayVm(), "80px");
    TextColumnWithTooltip<VM> statusColumn = new EnumColumn<VM, VMStatus>() {

        @Override
        public VMStatus getRawValue(VM object) {
            switch(object.getStatus()) {
                case PreparingForHibernate:
                    return VMStatus.SavingState;
                default:
                    return object.getStatus();
            }
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusVm(), "80px");
    TextColumnWithTooltip<VM> uptimeColumn = new UptimeColumn<VM>() {

        @Override
        public Double getRawValue(VM object) {
            return object.getRoundedElapsedTime();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(uptimeColumn, constants.uptimeVm(), "120px");
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVmCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunOnceCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.runVm(), resources.runVmImage(), resources.runVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.suspendVm(), resources.suspendVmImage(), resources.suspendVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getPauseCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.shutDownVm(), resources.stopVmImage(), resources.stopVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShutdownCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.powerOffVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.rebootVm(), resources.rebootImage(), resources.rebootDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRebootCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.consoleVm(), resources.consoleImage(), resources.consoleDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConsoleConnectCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(commonConstants.consoleOptions(), // $NON-NLS-1$
    CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditConsoleCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.migrateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cancelMigrationVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCancelMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewTemplateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.exportVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getExportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.createSnapshotVM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateSnapshotCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cheangeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getChangeCdCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.assignTagsVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VM>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("VM", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VM>(constants.showReportVm(), resourceSubActions));
        }
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.guideMeVm(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
}
#end_block

#method_before
@Override
public void entityPropertyChanged(PropertyChangedEventArgs e) {
    updateProperties();
    if (// $NON-NLS-1$
    e.PropertyName.equals("status")) {
        updateActionAvailability();
    }
}
#method_after
@Override
public void entityPropertyChanged(PropertyChangedEventArgs e) {
    updateProperties();
    if (// $NON-NLS-1$
    e.propertyName.equals("status")) {
        updateActionAvailability();
    }
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new VmGeneralModel());
    list.add(new VmInterfaceListModel());
    VmDiskListModel diskListModel = new VmDiskListModel();
    diskListModel.setSystemTreeContext(this);
    list.add(diskListModel);
    list.add(new VmSnapshotListModel());
    list.add(new VmEventListModel());
    list.add(new VmAppListModel());
    list.add(new PermissionListModel());
    list.add(new VmSessionsModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new VmGeneralModel());
    list.add(new VmInterfaceListModel());
    VmDiskListModel diskListModel = new VmDiskListModel();
    diskListModel.setSystemTreeContext(this);
    list.add(diskListModel);
    list.add(new VmSnapshotListModel());
    list.add(new VmEventListModel());
    list.add(new VmAppListModel());
    list.add(new PermissionListModel());
    list.add(new VmAffinityGroupListModel());
    list.add(new VmSessionsModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
public void setItems(Iterable value) {
    consoleModelsCache.updateCache(value);
    super.setItems(value);
}
#method_after
@Override
public void setItems(Iterable value) {
    consoleModelsCache.updateVmCache(value);
    super.setItems(value);
}
#end_block

#method_before
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForVm(((VM) getSelectedItem()));
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForEntity(getSelectedItem());
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void createSnapshot() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.setValidateByVmSnapshots(true);
    model.initialize();
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    // $NON-NLS-1$
    UICommand closeCommand = new UICommand("Cancel", this);
    closeCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.setCloseCommand(closeCommand);
}
#method_after
private void createSnapshot() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.setValidateByVmSnapshots(true);
    model.initialize();
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
}
#end_block

#method_before
public void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    tempVar.setVmType(model.getVmType().getSelectedItem());
    if (model.getQuota().getSelectedItem() != null) {
        tempVar.setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    tempVar.setVmOs(model.getOSType().getSelectedItem());
    tempVar.setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    tempVar.setSingleQxlPci(model.getIsSingleQxlEnabled().getEntity());
    tempVar.setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    // $NON-NLS-1$
    tempVar.setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : "");
    tempVar.setVmMemSizeMb(model.getMemSize().getEntity());
    tempVar.setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    tempVar.setVdsGroupId(model.getSelectedCluster().getId());
    tempVar.setTimeZone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? (model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    tempVar.setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    tempVar.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    tempVar.setStateless(model.getIsStateless().getEntity());
    tempVar.setRunAndPause(model.getIsRunAndPause().getEntity());
    tempVar.setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    tempVar.setDeleteProtected(model.getIsDeleteProtected().getEntity());
    tempVar.setSsoMethod(model.extractSelectedSsoMethod());
    tempVar.setDefaultBootSequence(model.getBootSequence());
    tempVar.setAutoStartup(model.getIsHighlyAvailable().getEntity());
    // $NON-NLS-1$
    tempVar.setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : "");
    tempVar.setUsbPolicy(vm.getUsbPolicy());
    tempVar.setInitrdUrl(vm.getInitrdUrl());
    tempVar.setKernelUrl(vm.getKernelUrl());
    tempVar.setKernelParams(vm.getKernelParams());
    tempVar.setDedicatedVmForVds(vm.getDedicatedVmForVds());
    tempVar.setMigrationSupport(vm.getMigrationSupport());
    tempVar.setVncKeyboardLayout(vm.getVncKeyboardLayout());
    VM newvm = tempVar;
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    newvm.setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    newvm.setPriority(prioritySelectedItem.getEntity());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newvm, model.getName().getEntity(), model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse(model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions(model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#method_after
public void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    tempVar.setVmType(model.getVmType().getSelectedItem());
    if (model.getQuota().getSelectedItem() != null) {
        tempVar.setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    tempVar.setVmOs(model.getOSType().getSelectedItem());
    tempVar.setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    tempVar.setSingleQxlPci(model.getIsSingleQxlEnabled().getEntity());
    tempVar.setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    // $NON-NLS-1$
    tempVar.setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : "");
    tempVar.setVmMemSizeMb(model.getMemSize().getEntity());
    tempVar.setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    tempVar.setVdsGroupId(model.getSelectedCluster().getId());
    tempVar.setTimeZone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? (model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    tempVar.setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    tempVar.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    tempVar.setStateless(model.getIsStateless().getEntity());
    tempVar.setRunAndPause(model.getIsRunAndPause().getEntity());
    tempVar.setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    tempVar.setDeleteProtected(model.getIsDeleteProtected().getEntity());
    tempVar.setSsoMethod(model.extractSelectedSsoMethod());
    tempVar.setDefaultBootSequence(model.getBootSequence());
    tempVar.setAutoStartup(model.getIsHighlyAvailable().getEntity());
    // $NON-NLS-1$
    tempVar.setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : "");
    tempVar.setUsbPolicy(vm.getUsbPolicy());
    tempVar.setInitrdUrl(vm.getInitrdUrl());
    tempVar.setKernelUrl(vm.getKernelUrl());
    tempVar.setKernelParams(vm.getKernelParams());
    tempVar.setDedicatedVmForVds(vm.getDedicatedVmForVds());
    tempVar.setMigrationSupport(vm.getMigrationSupport());
    tempVar.setDefaultVncKeyboardLayout(vm.getDefaultVncKeyboardLayout());
    VM newvm = tempVar;
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    newvm.setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    newvm.setPriority(prioritySelectedItem.getEntity());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newvm, model.getName().getEntity(), model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse(model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions(model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#end_block

#method_before
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    String name = model.getName().getEntity();
    // Save changes.
    VmTemplate template = model.getTemplate().getSelectedItem();
    getcurrentVm().setVmType(model.getVmType().getSelectedItem());
    getcurrentVm().setVmtGuid(template.getId());
    getcurrentVm().setName(name);
    if (model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    getcurrentVm().setVmOs(model.getOSType().getSelectedItem());
    getcurrentVm().setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setSingleQxlPci(model.getIsSingleQxlEnabled().getEntity());
    getcurrentVm().setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    getcurrentVm().setVmDescription(model.getDescription().getEntity());
    getcurrentVm().setComment(model.getComment().getEntity());
    getcurrentVm().setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setVmMemSizeMb(model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = model.getSelectedCluster().getId();
    getcurrentVm().setVdsGroupId(newClusterID);
    getcurrentVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? model.getTimeZone().getSelectedItem().getTimeZoneKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setUsbPolicy(model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setStateless(model.getIsStateless().getEntity());
    getcurrentVm().setRunAndPause(model.getIsRunAndPause().getEntity());
    getcurrentVm().setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    getcurrentVm().setDeleteProtected(model.getIsDeleteProtected().getEntity());
    getcurrentVm().setSsoMethod(model.extractSelectedSsoMethod());
    getcurrentVm().setDefaultBootSequence(model.getBootSequence());
    getcurrentVm().setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setAutoStartup(model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setInitrdUrl(model.getInitrd_path().getEntity());
    getcurrentVm().setKernelUrl(model.getKernel_path().getEntity());
    getcurrentVm().setKernelParams(model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomPropertySheet().serialize());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    getcurrentVm().setPriority(prioritySelectedItem.getEntity());
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    getcurrentVm().setVncKeyboardLayout(model.getVncKeyboardLayout().getSelectedItem());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    if (model.getIsAutoAssign().getEntity()) {
        getcurrentVm().setDedicatedVmForVds(null);
    } else {
        VDS defaultHost = model.getDefaultHost().getSelectedItem();
        getcurrentVm().setDedicatedVmForVds(defaultHost.getId());
    }
    getcurrentVm().setMigrationSupport(model.getMigrationMode().getSelectedItem());
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                    getWindow().stopProgress();
                    cancel();
                    setGuideContext(vmId);
                    updateActionAvailability();
                    getGuideCommand().execute();
                }

                @Override
                public void queryFailed() {
                    getWindow().stopProgress();
                    cancel();
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager), this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if (model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vmListModel.getcurrentVm(), unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, template.getId());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VmManagementParametersBase params = new VmManagementParametersBase(getcurrentVm());
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vmListModel.getcurrentVm());
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vmListModel.getcurrentVm().getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#method_after
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    String name = model.getName().getEntity();
    // Save changes.
    VmTemplate template = model.getTemplate().getSelectedItem();
    getcurrentVm().setVmType(model.getVmType().getSelectedItem());
    getcurrentVm().setVmtGuid(template.getId());
    getcurrentVm().setName(name);
    if (model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    getcurrentVm().setVmOs(model.getOSType().getSelectedItem());
    getcurrentVm().setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setSingleQxlPci(model.getIsSingleQxlEnabled().getEntity());
    getcurrentVm().setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    getcurrentVm().setVmDescription(model.getDescription().getEntity());
    getcurrentVm().setComment(model.getComment().getEntity());
    getcurrentVm().setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setVmMemSizeMb(model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = model.getSelectedCluster().getId();
    getcurrentVm().setVdsGroupId(newClusterID);
    getcurrentVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? model.getTimeZone().getSelectedItem().getTimeZoneKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setUsbPolicy(model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setStateless(model.getIsStateless().getEntity());
    getcurrentVm().setRunAndPause(model.getIsRunAndPause().getEntity());
    getcurrentVm().setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    getcurrentVm().setDeleteProtected(model.getIsDeleteProtected().getEntity());
    getcurrentVm().setSsoMethod(model.extractSelectedSsoMethod());
    getcurrentVm().setDefaultBootSequence(model.getBootSequence());
    getcurrentVm().setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setAutoStartup(model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setInitrdUrl(model.getInitrd_path().getEntity());
    getcurrentVm().setKernelUrl(model.getKernel_path().getEntity());
    getcurrentVm().setKernelParams(model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomPropertySheet().serialize());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    getcurrentVm().setPriority(prioritySelectedItem.getEntity());
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    getcurrentVm().setDefaultVncKeyboardLayout(model.getVncKeyboardLayout().getSelectedItem());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    if (model.getIsAutoAssign().getEntity()) {
        getcurrentVm().setDedicatedVmForVds(null);
    } else {
        VDS defaultHost = model.getDefaultHost().getSelectedItem();
        getcurrentVm().setDedicatedVmForVds(defaultHost.getId());
    }
    getcurrentVm().setMigrationSupport(model.getMigrationMode().getSelectedItem());
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                    getWindow().stopProgress();
                    cancel();
                    setGuideContext(vmId);
                    updateActionAvailability();
                    getGuideCommand().execute();
                }

                @Override
                public void queryFailed() {
                    getWindow().stopProgress();
                    cancel();
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager), this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if (model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vmListModel.getcurrentVm(), unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, template.getId());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VmManagementParametersBase params = new VmManagementParametersBase(getcurrentVm());
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vmListModel.getcurrentVm());
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vmListModel.getcurrentVm().getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#end_block

#method_before
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.PropertyName.equals("status")) {
        // $NON-NLS-1$
        updateActionAvailability();
    }
}
#method_after
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.propertyName.equals("status")) {
        // $NON-NLS-1$
        updateActionAvailability();
    }
}
#end_block

#method_before
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consoleModelsCache.getVmConsolesForVm(vm).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItem() == null ? null : getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consoleModelsCache.getVmConsolesForEntity(vm).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consoleModelsCache.getVmConsolesForVm(vm).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#method_after
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consoleModelsCache.getVmConsolesForEntity(vm).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#end_block

#method_before
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.Empty);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
}
#end_block

#method_before
public static Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    }
    return Guid.Empty;
}
#method_after
public static Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof DbGroup) {
        return ((DbGroup) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    }
    return Guid.Empty;
}
#end_block

#method_before
public static boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        // right now we check if the vmIp is set because for some reason vm.getHasAgent() returns false even when GA is present
        if (!isCommandCompatible(VdcActionType.RebootVm, version, version) || StringHelper.isNullOrEmpty(vm.getVmIp())) {
            return false;
        }
    }
    return true;
}
#method_after
public static boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        // currently on VDSM side reboot is supported only when the guest agent is present and responsive so we need to check for that
        if (!isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion) || StringHelper.isNullOrEmpty(vm.getVmIp())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void perform() {
    log.infoFormat("Sending reboot command for VM {0}.", getVm().getName());
    final VDSReturnValue returnValue = runVdsCommand(VDSCommandType.RebootVm, new VdsAndVmIDVDSParametersBase(getVdsId(), getVmId()));
    setActionReturnValue(returnValue.getReturnValue());
    setSucceeded(returnValue.getSucceeded());
}
#method_after
@Override
protected void perform() {
    final VDSReturnValue returnValue = runVdsCommand(VDSCommandType.RebootVm, new VdsAndVmIDVDSParametersBase(getVdsId(), getVmId()));
    setActionReturnValue(returnValue.getReturnValue());
    setSucceeded(returnValue.getSucceeded());
}
#end_block

#method_before
protected boolean isUserCanBeAuthenticated() {
    // Check if the user is already logged in:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(false);
    if (dbUser != null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
        return false;
    }
    // Verify that the login name and password have been provided:
    String loginName = getParameters().getLoginName();
    if (loginName == null) {
        log.error("Can't login user because no login name has been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    String password = getParameters().getPassword();
    if (password == null) {
        log.error("Can't login user \"{}\" because no password has been provided.", loginName);
        return false;
    }
    // Check that the authentication profile name has been provided:
    String profileName = getParameters().getProfileName();
    if (profileName == null) {
        log.error("Can't login user \"{}\" because no authentication profile name has been provided.", loginName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authentication profile exists:
    AuthenticationProfile profile = AuthenticationProfileManager.getInstance().getProfile(profileName);
    if (profile == null) {
        log.error("Can't login user \"{}\" because authentication profile \"{}\" doesn't exist.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authenticator provided by the profile supports password authentication:
    Authenticator authenticator = profile.getAuthenticator();
    if (!(authenticator instanceof PasswordAuthenticator)) {
        log.error("Can't login user \"{}\" because the authentication profile \"{}\" doesn't support password " + "authentication.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    PasswordAuthenticator passwordAuthenticator = (PasswordAuthenticator) authenticator;
    // Perform the actual authentication:
    boolean authenticated = passwordAuthenticator.authenticate(loginName, password.toCharArray());
    if (!authenticated) {
        log.info("Can't login user \"{}\" with authentication profile \"{}\" because the authentication failed.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the user exists in the directory associated to the authentication profile:
    Directory directory = profile.getDirectory();
    DirectoryUser directoryUser = directory.findUser(loginName);
    if (directoryUser == null) {
        log.info("Can't login user \"{}\" with authentication profile \"{}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    dbUser = getDbUserDAO().getByExternalId(directory.getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        getDbUserDAO().save(dbUser);
    }
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    // Add the user password to the session, as it will be needed later
    // when trying to log on to virtual machines:
    SessionDataContainer.getInstance().setPassword(password);
    return true;
}
#method_after
protected boolean isUserCanBeAuthenticated() {
    // Check if the user is already logged in:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(false);
    if (dbUser != null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
        return false;
    }
    // Verify that the login name and password have been provided:
    String loginName = getParameters().getLoginName();
    if (loginName == null) {
        log.errorFormat("Can't login user because no login name has been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    String password = getParameters().getPassword();
    if (password == null) {
        log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
        return false;
    }
    // Check that the authentication profile name has been provided:
    String profileName = getParameters().getProfileName();
    if (profileName == null) {
        log.errorFormat("Can't login user \"{0}\" because no authentication profile name has been provided.", loginName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authentication profile exists:
    AuthenticationProfile profile = AuthenticationProfileManager.getInstance().getProfile(profileName);
    if (profile == null) {
        log.errorFormat("Can't login user \"{0}\" because authentication profile \"{1}\" doesn't exist.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authenticator provided by the profile supports password authentication:
    Authenticator authenticator = profile.getAuthenticator();
    if (!(authenticator instanceof PasswordAuthenticator)) {
        log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    PasswordAuthenticator passwordAuthenticator = (PasswordAuthenticator) authenticator;
    // Perform the actual authentication:
    AuthenticationResult<?> result = passwordAuthenticator.authenticate(loginName, password);
    if (!result.isSuccessful()) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the authentication failed.", loginName, profileName);
        for (VdcBllMessages msg : result.resolveMessage()) {
            addCanDoActionMessage(msg);
        }
        return false;
    }
    // Check that the user exists in the directory associated to the authentication profile:
    Directory directory = profile.getDirectory();
    DirectoryUser directoryUser = directory.findUser(loginName);
    if (directoryUser == null) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    dbUser = getDbUserDAO().getByExternalId(directory.getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        getDbUserDAO().save(dbUser);
    }
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    // Add the user password to the session, as it will be needed later
    // when trying to log on to virtual machines:
    SessionDataContainer.getInstance().setPassword(password);
    return true;
}
#end_block

#method_before
@Override
protected boolean isUserAuthorizedToRunAction() {
    return true;
}
#method_after
@Override
protected boolean isUserAuthorizedToRunAction() {
    if (log.isDebugEnabled()) {
        log.debug("IsUserAutorizedToRunAction: login - no permission check");
    }
    return true;
}
#end_block

#method_before
private void updateUserData() {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
        // XXX: Will look at this later.
        // DbFacade.getInstance().updateLastAdminCheckStatus(dbUser.getId());
        }
    });
}
#method_after
private void updateUserData() {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
        // TODO: Will look at this later.
        // DbFacade.getInstance().updateLastAdminCheckStatus(dbUser.getId());
        }
    });
}
#end_block

#method_before
@Override
public boolean validate(Principal principal, String sessionId) {
    if (principal == null) {
        return loginFailureNoAuthType();
    }
    if (principal.getDomain() == null) {
        return loginFailure(principal, NO_DOMAIN);
    }
    LoginUserParameters params = new LoginUserParameters(principal.getDomain(), principal.getUser(), principal.getSecret());
    params.setActionType(VdcActionType.LoginUser);
    sessionHelper.setSessionId(sessionId);
    VdcReturnValueBase ret = backend.Login(sessionHelper.sessionize(params));
    if (ret.getCanDoAction() && ret.getSucceeded()) {
        return loginSuccess(principal, ret);
    } else {
        return loginFailure(principal, reasons(ret));
    }
}
#method_after
@Override
public boolean validate(Principal principal, String sessionId) {
    if (principal == null) {
        return loginFailureNoAuthType();
    }
    if (principal.getDomain() == null) {
        return loginFailure(principal, NO_DOMAIN);
    }
    LoginUserParameters params = new LoginUserParameters(principal.getDomain(), principal.getUser(), principal.getSecret());
    params.setActionType(VdcActionType.LoginUser);
    sessionHelper.setSessionId(sessionId);
    VdcReturnValueBase ret = backend.login(sessionHelper.sessionize(params));
    if (ret.getCanDoAction() && ret.getSucceeded()) {
        return loginSuccess(principal, ret);
    } else {
        return loginFailure(principal, reasons(ret));
    }
}
#end_block

#method_before
@Override
public Principal validate(String sessionId) {
    Principal principal = null;
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setSessionId(sessionId);
    VdcQueryReturnValue queryReturnValue = backend.RunPublicQuery(VdcQueryType.ValidateSession, params);
    if (queryReturnValue != null) {
        DbUser user = queryReturnValue.getReturnValue();
        if (user != null) {
            principal = new Principal(user.getLoginName(), null, user.getDomain());
            sessionHelper.setSessionId(sessionId);
            current.set(user);
        }
    }
    if (principal != null) {
        validateSessionSucceeded(queryReturnValue);
    } else {
        validateSessionFailed(queryReturnValue);
    }
    return principal;
}
#method_after
@Override
public Principal validate(String sessionId) {
    Principal principal = null;
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setSessionId(sessionId);
    VdcQueryReturnValue queryReturnValue = backend.runPublicQuery(VdcQueryType.ValidateSession, params);
    if (queryReturnValue != null) {
        DbUser user = queryReturnValue.getReturnValue();
        if (user != null) {
            principal = new Principal(user.getLoginName(), null, user.getDomain());
            sessionHelper.setSessionId(sessionId);
            current.set(user);
        }
    }
    if (principal != null) {
        validateSessionSucceeded(queryReturnValue);
    } else {
        validateSessionFailed(queryReturnValue);
    }
    return principal;
}
#end_block

#method_before
private ApplicationMode getApplicationMode() {
    VdcQueryReturnValue result = backend.RunPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.ApplicationMode, ConfigCommon.defaultConfigurationVersion));
    ApplicationMode appMode = null;
    if (result.getSucceeded()) {
        appMode = ApplicationMode.from((Integer) result.getReturnValue());
    } else {
        appMode = ApplicationMode.AllModes;
    }
    return appMode;
}
#method_after
private ApplicationMode getApplicationMode() {
    VdcQueryReturnValue result = backend.runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.ApplicationMode, ConfigCommon.defaultConfigurationVersion));
    ApplicationMode appMode = null;
    if (result.getSucceeded()) {
        appMode = ApplicationMode.from((Integer) result.getReturnValue());
    } else {
        appMode = ApplicationMode.AllModes;
    }
    return appMode;
}
#end_block

#method_before
private void validateSessionSucceeded(VdcQueryReturnValue ret) {
    LOG.debugFormat(VALIDATE_SESSION_SUCCESS);
    // cache user in Current so that it will be available
    // for logoff action on postProcess() traversal
    current.set(ret.getReturnValue());
}
#method_after
private void validateSessionSucceeded(VdcQueryReturnValue ret) {
    LOG.debugFormat(VALIDATE_SESSION_SUCCESS);
    // cache user in Current so that it will be available
    // for logoff action on postProcess() traversal
    current.set(ret.getReturnValue());
    current.set(getApplicationMode());
}
#end_block

#method_before
@Override
public void postProcess(ServerResponse response) {
    HttpSession httpSession = getCurrentSession(false);
    if (!current.get(MetaData.class).hasKey("async") || (!(Boolean.TRUE.equals((Boolean) current.get(MetaData.class).get("async"))))) {
        DbUser user = current.get(DbUser.class);
        if (user != null) {
            if (!persistentSession) {
                backend.Logoff(sessionHelper.sessionize(new LogoutUserParameters(user.getId())));
                if (httpSession != null) {
                    httpSession.invalidate();
                }
            } else if (httpSession != null && httpSession.isNew()) {
                response.getMetadata().add(SessionUtils.JSESSIONID_HEADER, httpSession.getId());
            }
        }
    }
    sessionHelper.clean();
}
#method_after
@Override
public void postProcess(ServerResponse response) {
    HttpSession httpSession = getCurrentSession(false);
    if (!current.get(MetaData.class).hasKey("async") || (!(Boolean.TRUE.equals((Boolean) current.get(MetaData.class).get("async"))))) {
        DbUser user = current.get(DbUser.class);
        if (user != null) {
            if (!persistentSession) {
                backend.logoff(sessionHelper.sessionize(new LogoutUserParameters(user.getId())));
                if (httpSession != null) {
                    httpSession.invalidate();
                }
            } else if (httpSession != null && httpSession.isNew()) {
                response.getMetadata().add(SessionUtils.JSESSIONID_HEADER, httpSession.getId());
            }
        }
    }
    sessionHelper.clean();
}
#end_block

#method_before
public void setMemberOf(List<String> memberOf) {
    this.memberOf = memberOf;
}
#method_after
public void setMemberOf(Set<String> memberOf) {
    this.memberOf = memberOf;
}
#end_block

#method_before
public List<String> getMemberOf() {
    return memberOf;
}
#method_after
public Set<String> getMemberOf() {
    return memberOf;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((externalId == null) ? 0 : externalId.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((distinguishedName == null) ? 0 : distinguishedName.hashCode());
    result = prime * result + ((memberOf == null) ? 0 : memberOf.hashCode());
    result = prime * result + status;
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((externalId == null) ? 0 : externalId.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((distinguishedName == null) ? 0 : distinguishedName.hashCode());
    result = prime * result + ((memberOf == null) ? 0 : memberOf.hashCode());
    result = prime * result + (active ? 1231 : 1237);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DbGroup other = (DbGroup) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(externalId, other.externalId) && ObjectUtils.objectsEqual(domain, other.domain) && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(distinguishedName, other.distinguishedName) && ObjectUtils.objectsEqual(memberOf, other.memberOf) && status == other.status);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DbGroup other = (DbGroup) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(externalId, other.externalId) && ObjectUtils.objectsEqual(domain, other.domain) && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(distinguishedName, other.distinguishedName) && ObjectUtils.objectsEqual(memberOf, other.memberOf) && active == other.active);
}
#end_block

#method_before
@Mapping(from = DbUser.class, to = User.class)
public static User map(DbUser entity, User template) {
    User model = template != null ? template : new User();
    model.setExternalId(entity.getExternalId().getBytes());
    model.setName(entity.getFirstName());
    model.setUserName(entity.getLoginName());
    model.setId(entity.getId().toString());
    model.setLastName(entity.getLastName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroupNames() != null && entity.getGroupNames().trim().length() > 0) {
        model.setGroups(new Groups());
        for (String name : entity.getGroupNames().split(",")) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = DbUser.class, to = User.class)
public static User map(DbUser entity, User template) {
    User model = template != null ? template : new User();
    model.setExternalId(entity.getExternalId().toHex());
    model.setName(entity.getFirstName());
    model.setUserName(entity.getLoginName());
    model.setId(entity.getId().toString());
    model.setLastName(entity.getLastName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroupNames() != null && entity.getGroupNames().trim().length() > 0) {
        model.setGroups(new Groups());
        for (String name : entity.getGroupNames().split(",")) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = DirectoryUser.class, to = User.class)
public static User map(DirectoryUser entity, User template) {
    User model = template != null ? template : new User();
    model.setExternalId(entity.getId().getBytes());
    model.setName(entity.getFirstName());
    model.setUserName(entity.getName());
    model.setId(Hex.encodeHexString(entity.getId().getBytes()));
    model.setLastName(entity.getLastName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroups() != null) {
        model.setGroups(new Groups());
        for (DirectoryGroup directoryGroup : entity.getGroups()) {
            Group group = new Group();
            group.setName(directoryGroup.getName());
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDirectory().getName())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDirectory().getName().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = DirectoryUser.class, to = User.class)
public static User map(DirectoryUser entity, User template) {
    User model = template != null ? template : new User();
    model.setName(entity.getFirstName());
    model.setExternalId(entity.getId().toString());
    model.setUserName(entity.getName());
    model.setId(entity.getId().toHex());
    model.setLastName(entity.getLastName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroups() != null) {
        model.setGroups(new Groups());
        for (DirectoryGroup directoryGroup : entity.getGroups()) {
            Group group = new Group();
            group.setName(directoryGroup.getName());
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDirectory().getName())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDirectory().getName().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Override
protected void syncSearch() {
    // allow only a single user lookup at a time
    if ((Boolean) getSearchInProgress().getEntity()) {
        return;
    }
    getSearchInProgress().setEntity(true);
    super.syncSearch();
    // var exclude = ExcludeItems != null ? ExcludeItems.Cast<DbUser>() : new List<DbUser>();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            setusers(new ArrayList<EntityModel>());
            addUsersToModel(queryReturnValue, getExcludeUsers());
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findUsers(// $NON-NLS-1$
    "allnames=" + // $NON-NLS-1$
    (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
    _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            HashSet<Guid> excludeUsers = new HashSet<Guid>();
            if (adElementListModel.getExcludeItems() != null) {
                for (Object item : adElementListModel.getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getId());
                }
            }
            adElementListModel.setgroups(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                DirectoryGroup a = (DirectoryGroup) item;
                if (!excludeUsers.contains(a.getId())) {
                    // XXX: This should use DbGroup and not DbUser.
                    DbUser tempVar3 = new DbUser();
                    tempVar3.setExternalId(a.getId());
                    tempVar3.setFirstName(a.getName());
                    // $NON-NLS-1$
                    tempVar3.setLastName("");
                    // $NON-NLS-1$
                    tempVar3.setLoginName("");
                    tempVar3.setDomain(a.getDirectory().getName());
                    DbUser user = tempVar3;
                    EntityModel tempVar4 = new EntityModel();
                    tempVar4.setEntity(user);
                    adElementListModel.getgroups().add(tempVar4);
                }
            }
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findGroups(// $NON-NLS-1$ //$NON-NLS-2$
    "name=" + (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
}
#method_after
@Override
protected void syncSearch() {
    // allow only a single user lookup at a time
    if ((Boolean) getSearchInProgress().getEntity()) {
        return;
    }
    getSearchInProgress().setEntity(true);
    super.syncSearch();
    // var exclude = ExcludeItems != null ? ExcludeItems.Cast<DbUser>() : new List<DbUser>();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            setusers(new ArrayList<EntityModel>());
            addUsersToModel(queryReturnValue, getExcludeUsers());
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findUsers(// $NON-NLS-1$
    "allnames=" + // $NON-NLS-1$
    (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
    _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            HashSet<ExternalId> excludeUsers = new HashSet<ExternalId>();
            if (adElementListModel.getExcludeItems() != null) {
                for (Object item : adElementListModel.getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getExternalId());
                }
            }
            adElementListModel.setgroups(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                DirectoryGroup a = (DirectoryGroup) item;
                if (!excludeUsers.contains(a.getId())) {
                    // XXX: This should use DbGroup and not DbUser.
                    DbUser tempVar3 = new DbUser();
                    tempVar3.setExternalId(a.getId());
                    tempVar3.setFirstName(a.getName());
                    // $NON-NLS-1$
                    tempVar3.setLastName("");
                    // $NON-NLS-1$
                    tempVar3.setLoginName("");
                    tempVar3.setDomain(a.getDirectory().getName());
                    DbUser user = tempVar3;
                    EntityModel tempVar4 = new EntityModel();
                    tempVar4.setEntity(user);
                    adElementListModel.getgroups().add(tempVar4);
                }
            }
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findGroups(// $NON-NLS-1$ //$NON-NLS-2$
    "name=" + (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
}
#end_block

#method_before
protected void addUsersToModel(VdcQueryReturnValue returnValue, Set<ExternalId> excludeUsers) {
    for (IVdcQueryable item : (ArrayList<IVdcQueryable>) returnValue.getReturnValue()) {
        DirectoryUser a = (DirectoryUser) item;
        if (!excludeUsers.contains(a.getId())) {
            EntityModel tempVar2 = new EntityModel();
            tempVar2.setEntity(new DbUser(a));
            getusers().add(tempVar2);
        }
    }
}
#method_after
protected void addUsersToModel(VdcQueryReturnValue returnValue, Set<ExternalId> excludeUsers) {
    for (IVdcQueryable item : (List<IVdcQueryable>) returnValue.getReturnValue()) {
        DirectoryUser a = (DirectoryUser) item;
        if (!excludeUsers.contains(a.getId())) {
            EntityModel tempVar2 = new EntityModel();
            tempVar2.setEntity(new DbUser(a));
            getusers().add(tempVar2);
        }
    }
}
#end_block

#method_before
protected void findGroups(String searchString, AsyncQuery query) {
    // $NON-NLS-1$ //$NON-NLS-2$
    Frontend.RunQuery(VdcQueryType.Search, new SearchParameters("ADGROUP@" + getDomain().getSelectedItem() + ": " + searchString, SearchType.DirectoryGroup), query);
}
#method_after
protected void findGroups(String searchString, AsyncQuery query) {
    // $NON-NLS-1$ //$NON-NLS-2$
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("ADGROUP@" + getDomain().getSelectedItem() + ": " + searchString, SearchType.DirectoryGroup), query);
}
#end_block

#method_before
protected void findUsers(String searchString, AsyncQuery query) {
    // $NON-NLS-1$ //$NON-NLS-2$
    Frontend.RunQuery(VdcQueryType.Search, new SearchParameters("ADUSER@" + getDomain().getSelectedItem() + ": " + searchString, SearchType.DirectoryUser), query);
}
#method_after
protected void findUsers(String searchString, AsyncQuery query) {
    // $NON-NLS-1$ //$NON-NLS-2$
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("ADUSER@" + getDomain().getSelectedItem() + ": " + searchString, SearchType.DirectoryUser), query);
}
#end_block

#method_before
private boolean handleQueryError(VdcQueryReturnValue returnValue, AdElementListModel model) {
    model.setMessage(null);
    if (!returnValue.getSucceeded()) {
        model.setMessage(Frontend.getAppErrorsTranslator().TranslateErrorTextSingle(returnValue.getExceptionString()));
        getSearchInProgress().setEntity(false);
        return true;
    }
    return false;
}
#method_after
private boolean handleQueryError(VdcQueryReturnValue returnValue, AdElementListModel model) {
    model.setMessage(null);
    if (!returnValue.getSucceeded()) {
        model.setMessage(Frontend.getInstance().getAppErrorsTranslator().translateErrorTextSingle(returnValue.getExceptionString()));
        getSearchInProgress().setEntity(false);
        return true;
    }
    return false;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
public static DbUser initUser(String sessionId, String domain, ExternalId id) {
    DbUser dbUser = DbFacade.getInstance().getDbUserDao().getByExternalId(domain, id);
    if (dbUser == null) {
        Directory directory = DirectoryManager.getInstance().getDirectory(domain);
        if (directory == null) {
            throw new VdcBLLException(VdcBllErrors.USER_FAILED_POPULATE_DATA);
        }
        DirectoryUser directoryUser = directory.findUser(id);
        if (directoryUser == null) {
            throw new VdcBLLException(VdcBllErrors.USER_FAILED_POPULATE_DATA);
        }
        dbUser = new DbUser(directoryUser);
        DbFacade.getInstance().getDbUserDao().save(dbUser);
    }
    return dbUser;
}
#method_after
@SuppressWarnings("deprecation")
public static DbUser initUser(String sessionId, String directoryName, ExternalId id) {
    DbUser dbUser = DbFacade.getInstance().getDbUserDao().getByExternalId(directoryName, id);
    if (dbUser == null) {
        Directory directory = DirectoryManager.getInstance().getDirectory(directoryName);
        if (directory == null) {
            throw new VdcBLLException(VdcBllErrors.USER_FAILED_POPULATE_DATA);
        }
        DirectoryUser directoryUser = directory.findUser(id);
        if (directoryUser == null) {
            throw new VdcBLLException(VdcBllErrors.USER_FAILED_POPULATE_DATA);
        }
        dbUser = new DbUser(directoryUser);
        DbFacade.getInstance().getDbUserDao().save(dbUser);
    }
    return dbUser;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Check that the directory name has been provided:
    String directoryName = getParameters().getDirectory();
    if (directoryName == null) {
        log.error("Can't add user because directory name hasn't been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the idientifier of the directory user has been provided:
    ExternalId id = getParameters().getId();
    if (id == null) {
        log.error("Can't add user from directory \"{}\" because the user identifier hasn't been provided.", directoryName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the directory exists:
    Directory directory = DirectoryManager.getInstance().getDirectory(directoryName);
    if (directory == null) {
        log.error("Can't add user with id \"{}\" because directory \"{}\" doesn't exist.", id, directoryName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the user is available in the directory (and save the reference to avoid looking it up later when
    // actually adding the user to the database):
    directoryUser = directory.findUser(id);
    if (directoryUser == null) {
        log.error("Can't add user with id \"{}\" because it doesn't exist in directory \"{}\".", id, directoryName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Populate information for the audit log:
    addCustomValue("NewUserName", directoryUser.getName());
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Check that the directory name has been provided:
    String directoryName = getParameters().getDirectory();
    if (directoryName == null) {
        log.error("Can't add user because directory name hasn't been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the identifier of the directory user has been provided:
    ExternalId id = getParameters().getId();
    if (id == null) {
        log.errorFormat("Can't add user from directory \"{0}\" because the user identifier hasn't been provided.", directoryName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the directory exists:
    Directory directory = DirectoryManager.getInstance().getDirectory(directoryName);
    if (directory == null) {
        log.errorFormat("Can't add user with id \"{0}\" because directory \"{1}\" doesn't exist.", id, directoryName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the user is available in the directory (and save the reference to avoid looking it up later when
    // actually adding the user to the database):
    directoryUser = directory.findUser(id);
    if (directoryUser == null) {
        log.errorFormat("Can't add user with id \"{0}\" because it doesn't exist in directory \"{1}\".", id, directoryName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Populate information for the audit log:
    addCustomValue("NewUserName", directoryUser.getName());
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // First check if the user is already in the database, if it is we need to update, if not we need to insert:
    DbUserDAO dao = getDbUserDAO();
    DbUser dbUser = dao.getByExternalId(directoryUser.getDirectory().getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        dao.save(dbUser);
    } else {
        Guid id = dbUser.getId();
        dbUser = new DbUser(directoryUser);
        dbUser.setId(id);
        dao.update(dbUser);
    }
    // Return the identifier of the created user:
    setActionReturnValue(dbUser.getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    DbUserDAO dao = getDbUserDAO();
    // First check if the user is already in the database, if it is we need to update, if not we need to insert:
    DbUser dbUser = dao.getByExternalId(directoryUser.getDirectory().getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        dao.save(dbUser);
    } else {
        Guid id = dbUser.getId();
        dbUser = new DbUser(directoryUser);
        dbUser.setId(id);
        dao.update(dbUser);
    }
    // Return the identifier of the created user:
    setActionReturnValue(dbUser.getId());
    setSucceeded(true);
}
#end_block

#method_before
@Mapping(from = DbGroup.class, to = Group.class)
public static Group map(DbGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setExternalId(entity.getExternalId().getBytes());
    model.setName(entity.getName());
    model.setId(entity.getId().toString());
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = DbGroup.class, to = Group.class)
public static Group map(DbGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setExternalId(entity.getExternalId().toHex());
    model.setName(entity.getName());
    model.setId(entity.getId().toString());
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = DirectoryGroup.class, to = Group.class)
public static Group map(DirectoryGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setExternalId(entity.getId().getBytes());
    model.setName(entity.getName());
    model.setId(Hex.encodeHexString(entity.getId().getBytes()));
    if (!StringUtils.isEmpty(entity.getDirectory().getName())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDirectory().getName().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = DirectoryGroup.class, to = Group.class)
public static Group map(DirectoryGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setName(entity.getName());
    model.setId(entity.getId().toHex());
    model.setExternalId(entity.getId().toString());
    if (!StringUtils.isEmpty(entity.getDirectory().getName())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDirectory().getName().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
private void setUpProfileMock(String name) {
    Directory directoryMock = mock(Directory.class);
    doReturn(name).when(directoryMock).getName();
    DirectoryManager.getInstance().registerDirectory(directoryMock);
    Authenticator authenticatorMock = mock(Authenticator.class);
    doReturn(name).when(authenticatorMock).getName();
    AuthenticatorManager.getInstance().registerAuthenticator(authenticatorMock);
    AuthenticationProfile profileMock = mock(AuthenticationProfile.class);
    doReturn(name).when(profileMock).getName();
    doReturn(directoryMock).when(profileMock).getDirectory();
    doReturn(authenticatorMock).when(profileMock).getAuthenticator();
    AuthenticationProfileManager.getInstance().registerProfile(profileMock);
}
#method_after
private void setUpProfileMock(String name) {
    Directory directoryMock = mock(Directory.class);
    doReturn(name).when(directoryMock).getName();
    DirectoryManager.getInstance().registerDirectory(name, directoryMock);
    Authenticator authenticatorMock = mock(Authenticator.class);
    AuthenticatorManager.getInstance().registerAuthenticator(name, authenticatorMock);
    AuthenticationProfile profileMock = mock(AuthenticationProfile.class);
    doReturn(name).when(profileMock).getName();
    doReturn(directoryMock).when(profileMock).getDirectory();
    doReturn(authenticatorMock).when(profileMock).getAuthenticator();
    AuthenticationProfileManager.getInstance().registerProfile(name, profileMock);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    final String domain = getParameters().getDomain();
    final ExternalId id = getParameters().getId();
    final Directory directory = DirectoryManager.getInstance().getDirectory(domain);
    final DirectoryGroup group = directory.findGroup(id);
    getQueryReturnValue().setReturnValue(group);
}
#method_after
@Override
protected void executeQueryCommand() {
    final String directoryName = getParameters().getDomain();
    final ExternalId id = getParameters().getId();
    final Directory directory = DirectoryManager.getInstance().getDirectory(directoryName);
    final DirectoryGroup group = directory.findGroup(id);
    getQueryReturnValue().setReturnValue(group);
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    // Load authentication profiles:
    File etcDir = EngineLocalConfig.getInstance().getEtcDir();
    File authDir = new File(etcDir, "auth.d");
    if (authDir.exists() && authDir.isDirectory()) {
        AuthenticationProfileManager.getInstance().loadConfiguration(authDir);
    }
    // If no authentication profiles have been configured then create one for each of the old style domains:
    if (AuthenticationProfileManager.getInstance().getProfiles().isEmpty()) {
        for (String domain : LdapBrokerUtils.getDomainsList()) {
            Authenticator authenticator = new ProvisionalAuthenticator(domain);
            AuthenticatorManager.getInstance().registerAuthenticator(authenticator);
            Directory directory = new ProvisionalDirectory(domain);
            DirectoryManager.getInstance().registerDirectory(directory);
            AuthenticationProfile profile = new AuthenticationProfile(domain, authenticator, directory);
            AuthenticationProfileManager.getInstance().registerProfile(profile);
        }
    }
    AsyncTaskManager.getInstance().InitAsyncTaskManager();
    ResourceManager.getInstance().init();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

        @Override
        public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
            MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
            parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
            Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
        }
    });
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.Init();
    GlusterJobsManager.init();
    ExternalTrustStoreInitializer.init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
    }
    try {
        log.info("Init device custom properties utilities");
        DevicePropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of device custom properties failed.", e);
    }
    SchedulingManager.getInstance().init();
    new DwhHeartBeat().init();
}
#method_after
@Override
@PostConstruct
public void create() {
    // Create authentication profiles for all the domains that exist in the database:
    for (String domain : LdapBrokerUtils.getDomainsList()) {
        LdapBroker broker = LdapFactory.getInstance(domain);
        Authenticator authenticator = new ProvisionalAuthenticator(domain, broker);
        Directory directory = new ProvisionalDirectory(domain, broker);
        AuthenticationProfile profile = new AuthenticationProfile(domain, authenticator, directory);
        AuthenticatorManager.getInstance().registerAuthenticator(domain, authenticator);
        DirectoryManager.getInstance().registerDirectory(domain, directory);
        AuthenticationProfileManager.getInstance().registerProfile(domain, profile);
    }
    AsyncTaskManager.getInstance().initAsyncTaskManager();
    ResourceManager.getInstance().init();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

        @Override
        public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
            MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
            parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
            Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
        }
    });
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.init();
    GlusterJobsManager.init();
    ExternalTrustStoreInitializer.init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
    }
    try {
        log.info("Init device custom properties utilities");
        DevicePropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of device custom properties failed.", e);
    }
    SchedulingManager.getInstance().init();
    new DwhHeartBeat().init();
}
#end_block

#method_before
@Override
protected void verifyModel(User model, int index) {
    assertEquals(GUIDS[index].toString(), model.getId());
    assertArrayEquals(EXTERNAL_IDS[index].getBytes(), model.getExternalId());
    assertEquals(NAMES[index], model.getUserName());
    assertNotNull(model.getDomain());
    assertEquals(new Guid(DOMAIN.getBytes(), true).toString(), model.getDomain().getId());
    assertTrue(model.isSetGroups());
    assertEquals(PARSED_GROUPS.length, model.getGroups().getGroups().size());
    for (int i = 0; i < PARSED_GROUPS.length; i++) {
        Group group = model.getGroups().getGroups().get(i);
        assertEquals(PARSED_GROUPS[i], group.getName());
    }
    verifyLinks(model);
}
#method_after
@Override
protected void verifyModel(User model, int index) {
    assertEquals(GUIDS[index].toString(), model.getId());
    assertEquals(EXTERNAL_IDS[index].toHex(), model.getExternalId());
    assertEquals(NAMES[index], model.getUserName());
    assertNotNull(model.getDomain());
    assertEquals(new Guid(DOMAIN.getBytes(), true).toString(), model.getDomain().getId());
    assertTrue(model.isSetGroups());
    assertEquals(PARSED_GROUPS.length, model.getGroups().getGroups().size());
    for (int i = 0; i < PARSED_GROUPS.length; i++) {
        Group group = model.getGroups().getGroups().get(i);
        assertEquals(PARSED_GROUPS[i], group.getName());
    }
    verifyLinks(model);
}
#end_block

#method_before
public String getVdcObjectName() {
    permissions perms = getParameters().getPermission();
    return getDbFacade().getEntityNameByIdAndType(perms.getObjectId(), perms.getObjectType());
}
#method_after
public String getVdcObjectName() {
    Permissions perms = getParameters().getPermission();
    return getDbFacade().getEntityNameByIdAndType(perms.getObjectId(), perms.getObjectType());
}
#end_block

#method_before
protected boolean isSystemSuperUser() {
    permissions superUserPermission = getPermissionDAO().getForRoleAndAdElementAndObjectWithGroupCheck(PredefinedRoles.SUPER_USER.getId(), getCurrentUser().getId(), MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID);
    return superUserPermission != null;
}
#method_after
protected boolean isSystemSuperUser() {
    Permissions superUserPermission = getPermissionDAO().getForRoleAndAdElementAndObjectWithGroupCheck(PredefinedRoles.SUPER_USER.getId(), getCurrentUser().getId(), MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID);
    return superUserPermission != null;
}
#end_block

#method_before
// TODO - this code is shared with addPermissionCommand - check if
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissions permission = getParameters().getPermission();
    permissionList.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    return permissionList;
}
#method_after
// TODO - this code is shared with addPermissionCommand - check if
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    Permissions permission = getParameters().getPermission();
    permissionList.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    return permissionList;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    String domain = getParameters().getDirectory();
    ExternalId id = getParameters().getId();
    Directory directory = DirectoryManager.getInstance().getDirectory(domain);
    directoryGroup = directory.findGroup(id);
    if (directoryGroup == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    addCustomValue("NewUserName", directoryGroup.getName());
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    String directoryName = getParameters().getDirectory();
    ExternalId id = getParameters().getId();
    Directory directory = DirectoryManager.getInstance().getDirectory(directoryName);
    directoryGroup = directory.findGroup(id);
    if (directoryGroup == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    addCustomValue("NewUserName", directoryGroup.getName());
    return true;
}
#end_block

#method_before
@Override
public Response add(Group group) {
    validateParameters(group, "name");
    if (!isNameContainsDomain(group)) {
        validateParameters(group, "domain.id|name");
    }
    String domain = getDomain(group);
    DirectoryGroup directoryGroup = getEntity(DirectoryGroup.class, SearchType.DirectoryGroup, getDirectoryGroupSearchPattern(group.getName(), domain));
    if (directoryGroup == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such group: " + group.getName() + " in domain " + domain).build();
    }
    DirectoryIdParameters parameters = new DirectoryIdParameters();
    parameters.setDirectory(directoryGroup.getDirectory().getName());
    parameters.setId(directoryGroup.getId());
    QueryIdResolver<Guid> resolver = new QueryIdResolver<>(VdcQueryType.GetDbGroupById, IdQueryParameters.class);
    return performCreate(VdcActionType.AddGroup, parameters, resolver, BaseResource.class);
}
#method_after
@Override
public Response add(Group group) {
    validateParameters(group, "name");
    if (!isNameContainsDomain(group)) {
        validateParameters(group, "domain.id|name");
    }
    String directoryName = getDirectoryName(group);
    DirectoryGroup directoryGroup = findDirectoryGroup(directoryName, group);
    if (directoryGroup == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such group: " + group.getName() + " in directory " + directoryName).build();
    }
    DirectoryIdParameters parameters = new DirectoryIdParameters();
    parameters.setDirectory(directoryName);
    parameters.setId(directoryGroup.getId());
    QueryIdResolver<Guid> resolver = new QueryIdResolver<>(VdcQueryType.GetDbGroupById, IdQueryParameters.class);
    return performCreate(VdcActionType.AddGroup, parameters, resolver, BaseResource.class);
}
#end_block

#method_before
@Override
public SyntaxContainer analyzeSyntaxState(String searchText, boolean final2) {
    SyntaxContainer retval = new SyntaxContainer(searchText);
    IConditionFieldAutoCompleter AdConditionFieldAC;
    if (searchText.toUpperCase().contains("ADUSER")) {
        AdConditionFieldAC = new AdUserConditionFieldAutoCompleter();
    } else {
        AdConditionFieldAC = new AdGroupConditionFieldAutoCompleter();
    }
    IAutoCompleter conditionRelationAC;
    char[] searchCharArr = searchText.toCharArray();
    boolean betweenDoubleQuotes = false;
    int curStartPos = 0;
    String curConditionField = "";
    for (int idx = 0; idx < searchCharArr.length; idx++) {
        SyntaxObjectType curState = retval.getState();
        char curChar = searchCharArr[idx];
        if ((curChar == ' ') && (curState != SyntaxObjectType.CONDITION_RELATION)) {
            curStartPos += 1;
            continue;
        }
        String strRealObj = searchText.substring(curStartPos, idx + 1);
        String nextObject = strRealObj.toUpperCase();
        switch(curState) {
            case BEGIN:
                // we have found a search-object
                if (!mSearchObjectAC.validate(nextObject)) {
                    if (!mSearchObjectAC.validateCompletion(nextObject)) {
                        // ERROR INVALID-SEARCH OBJECT
                        retval.setErr(SyntaxError.INVALID_SEARCH_OBJECT, curStartPos, idx - curStartPos + 1);
                        return retval;
                    }
                } else {
                    if (// Check that this
                    searchCharArr.length >= idx + 2) // maybe a plural
                    {
                        // Validate that the next character is an 's'
                        if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    retval.addSyntaxObject(SyntaxObjectType.SEARCH_OBJECT, nextObject, curStartPos, idx + 1);
                    retval.setvalid(true);
                    curStartPos = idx + 1;
                }
                break;
            case SEARCH_OBJECT:
                if (!mColonAC.validate(nextObject)) {
                    if (!mColonAC.validateCompletion(nextObject)) {
                        retval.setErr(SyntaxError.COLON_NOT_NEXT_TO_SEARCH_OBJECT, curStartPos, idx + 1);
                        return retval;
                    }
                } else {
                    retval.addSyntaxObject(SyntaxObjectType.COLON, nextObject, idx, idx + 1);
                    curStartPos = idx + 1;
                    retval.setvalid(true);
                }
                break;
            case COLON:
            case CONDITION_VALUE:
                if (AdConditionFieldAC.validate(nextObject)) {
                    retval.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curConditionField = nextObject;
                    curStartPos = idx + 1;
                } else if (// &&
                !AdConditionFieldAC.validateCompletion(nextObject)) // (!mSortbyAC.validateCompletion(nextObject)))
                {
                    retval.setErr(SyntaxError.INVALID_CONDITION_FILED, curStartPos, idx + 1);
                    return retval;
                }
                retval.setvalid(false);
                break;
            case CONDITION_FIELD:
                conditionRelationAC = AdConditionFieldAC.getFieldRelationshipAutoCompleter(curConditionField);
                if (conditionRelationAC == null) {
                    retval.setErr(SyntaxError.CONDITION_CANT_CREATE_RRELATIONS_AC, curStartPos, idx + 1);
                    return retval;
                }
                if (idx + 1 < searchCharArr.length) {
                    String tryNextObj = searchText.substring(curStartPos, idx + 2).toUpperCase();
                    if (conditionRelationAC.validate(tryNextObj)) {
                        break;
                    }
                }
                if (!conditionRelationAC.validate(nextObject)) {
                    if (!conditionRelationAC.validateCompletion(nextObject)) {
                        retval.setErr(SyntaxError.INVALID_CONDITION_RELATION, curStartPos, idx + 1);
                        return retval;
                    }
                } else {
                    retval.addSyntaxObject(SyntaxObjectType.CONDITION_RELATION, nextObject, curStartPos, idx + 1);
                }
                curStartPos = idx + 1;
                retval.setvalid(false);
                break;
            case CONDITION_RELATION:
                boolean addObjFlag = false;
                if (curChar == '"') {
                    betweenDoubleQuotes = (!betweenDoubleQuotes);
                    if (betweenDoubleQuotes) {
                        if (!mFirstDQRegexp.IsMatch(strRealObj)) {
                            retval.setErr(SyntaxError.INVALID_CONDITION_VALUE, curStartPos, idx + 1);
                            return retval;
                        }
                    } else {
                        strRealObj = StringHelper.trim(strRealObj, new char[] { '\"' });
                        addObjFlag = true;
                    }
                }
                // searchObject and no space is predicted !!
                if (final2) {
                    if (((curChar == ' ') || (idx + 1 == searchCharArr.length)) && (betweenDoubleQuotes == false) && (addObjFlag == false)) {
                        strRealObj = strRealObj.trim();
                        if (mNonSpaceRegexp.IsMatch(strRealObj)) {
                            addObjFlag = true;
                        } else {
                            curStartPos = idx + 1;
                        }
                    }
                } else {
                    if ((curChar == ' ') && (betweenDoubleQuotes == false) && (addObjFlag == false)) {
                        strRealObj = strRealObj.trim();
                        if (mNonSpaceRegexp.IsMatch(strRealObj)) {
                            addObjFlag = true;
                        } else {
                            curStartPos = idx + 1;
                        }
                    }
                }
                if (addObjFlag) {
                    if (!AdConditionFieldAC.validateFieldValue(curConditionField, strRealObj)) {
                        retval.setErr(SyntaxError.INVALID_CONDITION_VALUE, curStartPos, idx);
                        return retval;
                    } else {
                        retval.addSyntaxObject(SyntaxObjectType.CONDITION_VALUE, strRealObj, curStartPos, idx + 1);
                        curConditionField = "";
                    }
                    curStartPos = idx + 1;
                    retval.setvalid(true);
                }
                break;
            default:
                retval.setErr(SyntaxError.UNIDENTIFIED_STATE, curStartPos, idx);
                return retval;
        }
    }
    return retval;
}
#method_after
@Override
public SyntaxContainer analyzeSyntaxState(String searchText, boolean final2) {
    SyntaxContainer retval = new SyntaxContainer(searchText);
    IConditionFieldAutoCompleter AdConditionFieldAC;
    if (searchText.toUpperCase().contains("ADUSER")) {
        AdConditionFieldAC = new AdUserConditionFieldAutoCompleter();
    } else {
        AdConditionFieldAC = new AdGroupConditionFieldAutoCompleter();
    }
    IAutoCompleter conditionRelationAC;
    char[] searchCharArr = searchText.toCharArray();
    boolean betweenDoubleQuotes = false;
    int curStartPos = 0;
    String curConditionField = "";
    for (int idx = 0; idx < searchCharArr.length; idx++) {
        SyntaxObjectType curState = retval.getState();
        char curChar = searchCharArr[idx];
        if ((curChar == ' ') && (curState != SyntaxObjectType.CONDITION_RELATION)) {
            curStartPos += 1;
            continue;
        }
        String strRealObj = searchText.substring(curStartPos, idx + 1);
        String nextObject = strRealObj.toUpperCase();
        switch(curState) {
            case BEGIN:
                // we have found a search-object
                if (!mSearchObjectAC.validate(nextObject)) {
                    if (!mSearchObjectAC.validateCompletion(nextObject)) {
                        // ERROR INVALID-SEARCH OBJECT
                        retval.setErr(SyntaxError.INVALID_SEARCH_OBJECT, curStartPos, idx - curStartPos + 1);
                        return retval;
                    }
                } else {
                    if (searchCharArr.length >= idx + 2) {
                        // Validate that the next character is an 's'
                        if (mPluralAC.validate(searchText.substring(idx + 1, idx + 1 + 1))) {
                            // Then just move things along.
                            idx++;
                            StringBuilder sb = new StringBuilder(nextObject);
                            sb.append('S');
                            nextObject = sb.toString();
                        }
                    }
                    retval.addSyntaxObject(SyntaxObjectType.SEARCH_OBJECT, nextObject, curStartPos, idx + 1);
                    retval.setvalid(true);
                    curStartPos = idx + 1;
                }
                break;
            case SEARCH_OBJECT:
                if (!mColonAC.validate(nextObject)) {
                    if (!mColonAC.validateCompletion(nextObject)) {
                        retval.setErr(SyntaxError.COLON_NOT_NEXT_TO_SEARCH_OBJECT, curStartPos, idx + 1);
                        return retval;
                    }
                } else {
                    retval.addSyntaxObject(SyntaxObjectType.COLON, nextObject, idx, idx + 1);
                    curStartPos = idx + 1;
                    retval.setvalid(true);
                }
                break;
            case COLON:
            case CONDITION_VALUE:
                if (AdConditionFieldAC.validate(nextObject)) {
                    retval.addSyntaxObject(SyntaxObjectType.CONDITION_FIELD, nextObject, curStartPos, idx + 1);
                    curConditionField = nextObject;
                    curStartPos = idx + 1;
                } else if (// &&
                !AdConditionFieldAC.validateCompletion(nextObject)) // (!mSortbyAC.validateCompletion(nextObject)))
                {
                    retval.setErr(SyntaxError.INVALID_CONDITION_FILED, curStartPos, idx + 1);
                    return retval;
                }
                retval.setvalid(false);
                break;
            case CONDITION_FIELD:
                conditionRelationAC = AdConditionFieldAC.getFieldRelationshipAutoCompleter(curConditionField);
                if (conditionRelationAC == null) {
                    retval.setErr(SyntaxError.CONDITION_CANT_CREATE_RRELATIONS_AC, curStartPos, idx + 1);
                    return retval;
                }
                if (idx + 1 < searchCharArr.length) {
                    String tryNextObj = searchText.substring(curStartPos, idx + 2).toUpperCase();
                    if (conditionRelationAC.validate(tryNextObj)) {
                        break;
                    }
                }
                if (!conditionRelationAC.validate(nextObject)) {
                    if (!conditionRelationAC.validateCompletion(nextObject)) {
                        retval.setErr(SyntaxError.INVALID_CONDITION_RELATION, curStartPos, idx + 1);
                        return retval;
                    }
                } else {
                    retval.addSyntaxObject(SyntaxObjectType.CONDITION_RELATION, nextObject, curStartPos, idx + 1);
                }
                curStartPos = idx + 1;
                retval.setvalid(false);
                break;
            case CONDITION_RELATION:
                boolean addObjFlag = false;
                if (curChar == '"') {
                    betweenDoubleQuotes = (!betweenDoubleQuotes);
                    if (betweenDoubleQuotes) {
                        if (!mFirstDQRegexp.IsMatch(strRealObj)) {
                            retval.setErr(SyntaxError.INVALID_CONDITION_VALUE, curStartPos, idx + 1);
                            return retval;
                        }
                    } else {
                        strRealObj = StringHelper.trim(strRealObj, new char[] { '\"' });
                        addObjFlag = true;
                    }
                }
                // searchObject and no space is predicted !!
                if (final2) {
                    if (((curChar == ' ') || (idx + 1 == searchCharArr.length)) && (betweenDoubleQuotes == false) && (addObjFlag == false)) {
                        strRealObj = strRealObj.trim();
                        if (mNonSpaceRegexp.IsMatch(strRealObj)) {
                            addObjFlag = true;
                        } else {
                            curStartPos = idx + 1;
                        }
                    }
                } else {
                    if ((curChar == ' ') && (betweenDoubleQuotes == false) && (addObjFlag == false)) {
                        strRealObj = strRealObj.trim();
                        if (mNonSpaceRegexp.IsMatch(strRealObj)) {
                            addObjFlag = true;
                        } else {
                            curStartPos = idx + 1;
                        }
                    }
                }
                if (addObjFlag) {
                    if (!AdConditionFieldAC.validateFieldValue(curConditionField, strRealObj)) {
                        retval.setErr(SyntaxError.INVALID_CONDITION_VALUE, curStartPos, idx);
                        return retval;
                    } else {
                        retval.addSyntaxObject(SyntaxObjectType.CONDITION_VALUE, strRealObj, curStartPos, idx + 1);
                        curConditionField = "";
                    }
                    curStartPos = idx + 1;
                    retval.setvalid(true);
                }
                break;
            default:
                retval.setErr(SyntaxError.UNIDENTIFIED_STATE, curStartPos, idx);
                return retval;
        }
    }
    return retval;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    String domain = getParameters().getDomain();
    ExternalId id = getParameters().getId();
    Directory directory = DirectoryManager.getInstance().getDirectory(domain);
    DirectoryUser user = directory.findUser(id);
    getQueryReturnValue().setReturnValue(user);
}
#method_after
@Override
protected void executeQueryCommand() {
    String directoryName = getParameters().getDomain();
    ExternalId id = getParameters().getId();
    Directory directory = DirectoryManager.getInstance().getDirectory(directoryName);
    DirectoryUser user = directory.findUser(id);
    getQueryReturnValue().setReturnValue(user);
}
#end_block

#method_before
public void init() {
    if (!initialized) {
        log.info("Start initializing " + getClass().getSimpleName());
        int mRefreshRate = Config.<Integer>GetValue(ConfigValues.UserRefreshRate);
        jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "refreshAllUsers", new Class[] {}, new Object[] {}, 0, mRefreshRate, TimeUnit.SECONDS);
        initialized = true;
        log.info("Finished initializing " + getClass().getSimpleName());
    }
}
#method_after
public void init() {
    if (!initialized) {
        log.info("Start initializing " + getClass().getSimpleName());
        int mRefreshRate = Config.<Integer>getValue(ConfigValues.UserRefreshRate);
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "refreshAllUsers", new Class[] {}, new Object[] {}, 0, mRefreshRate, TimeUnit.SECONDS);
        initialized = true;
        log.info("Finished initializing " + getClass().getSimpleName());
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("refreshAllUsers")
private void refreshAllUsers() {
    // We will need the DAO:
    DbUserDAO dao = DbFacade.getInstance().getDbUserDao();
    // Retrieve all the users from the database:
    List<DbUser> dbUsers = dao.getAll();
    // Classify the users by directory:
    Map<Directory, List<DbUser>> index = new HashMap<>();
    for (DbUser dbUser : dbUsers) {
        Directory key = DirectoryManager.getInstance().getDirectory(dbUser.getDomain());
        List<DbUser> value = index.get(key);
        if (value == null) {
            value = new ArrayList<DbUser>();
            index.put(key, value);
        }
        value.add(dbUser);
    }
    // Refresh the users for each directory:
    List<DbUser> updates = new ArrayList<>();
    for (Map.Entry<Directory, List<DbUser>> entry : index.entrySet()) {
        List<DbUser> refreshed = refreshUsers(entry.getValue(), entry.getKey());
        updates.addAll(refreshed);
    }
    // have support for that yet):
    for (DbUser dbUser : updates) {
        dao.update(dbUser);
    }
}
#method_after
@OnTimerMethodAnnotation("refreshAllUsers")
public void refreshAllUsers() {
    // We will need the DAO:
    DbUserDAO dao = DbFacade.getInstance().getDbUserDao();
    // Retrieve all the users from the database:
    List<DbUser> dbUsers = dao.getAll();
    List<DbGroup> dbGroups = DbFacade.getInstance().getDbGroupDao().getAll();
    for (DbGroup group : dbGroups) {
        groupsMap.put(group.getExternalId(), group);
    }
    // Classify the users by directory. Note that the resulting map may have an entry with a null key, that
    // corresponds to the users whose directory has been removed from the configuration.
    Map<Directory, List<DbUser>> index = new HashMap<>();
    for (DbUser dbUser : dbUsers) {
        Directory key = DirectoryManager.getInstance().getDirectory(dbUser.getDomain());
        List<DbUser> value = index.get(key);
        if (value == null) {
            value = new ArrayList<DbUser>();
            index.put(key, value);
        }
        value.add(dbUser);
    }
    // Refresh the users for each directory:
    List<DbUser> updates = new ArrayList<>();
    for (Map.Entry<Directory, List<DbUser>> entry : index.entrySet()) {
        List<DbUser> refreshed = refreshUsers(entry.getValue(), entry.getKey());
        updates.addAll(refreshed);
    }
    // have support for that yet):
    for (DbUser dbUser : updates) {
        dao.update(dbUser);
    }
}
#end_block

#method_before
private List<DbUser> refreshUsers(List<DbUser> dbUsers, Directory directory) {
    // Find all the users in the directory using a batch operation to improve performance:
    List<ExternalId> ids = new ArrayList<>(dbUsers.size());
    for (DbUser dbUser : dbUsers) {
        ids.add(dbUser.getExternalId());
    }
    List<DirectoryUser> directoryUsers = directory.findUsers(ids);
    // Build a map of users indexed by directory id to simplify the next step where we want to find the directory
    // user corresponding to each database user:
    Map<ExternalId, DirectoryUser> index = new HashMap<>();
    for (DirectoryUser directoryUser : directoryUsers) {
        index.put(directoryUser.getId(), directoryUser);
    }
    // For each database user refresh it using the corresponding directory user and collect those users that need to
    // be updated:
    List<DbUser> refreshed = new ArrayList<>();
    for (DbUser dbUser : dbUsers) {
        DirectoryUser directoryUser = index.get(dbUser.getId());
        dbUser = refreshUser(dbUser, directoryUser);
        if (dbUser != null) {
            refreshed.add(dbUser);
        }
    }
    return refreshed;
}
#method_after
private List<DbUser> refreshUsers(List<DbUser> dbUsers, Directory directory) {
    // Find all the users in the directory using a batch operation to improve performance:
    List<ExternalId> ids = new ArrayList<>(dbUsers.size());
    for (DbUser dbUser : dbUsers) {
        ids.add(dbUser.getExternalId());
    }
    List<DirectoryUser> directoryUsers = null;
    if (directory != null) {
        directoryUsers = directory.findUsers(ids);
    } else {
        directoryUsers = Collections.emptyList();
    }
    // Build a map of users indexed by directory id to simplify the next step where we want to find the directory
    // user corresponding to each database user:
    Map<ExternalId, DirectoryUser> index = new HashMap<>();
    for (DirectoryUser directoryUser : directoryUsers) {
        index.put(directoryUser.getId(), directoryUser);
    }
    // For each database user refresh it using the corresponding directory user and collect those users that need to
    // be updated:
    List<DbUser> refreshed = new ArrayList<>();
    for (DbUser dbUser : dbUsers) {
        DirectoryUser directoryUser = index.get(dbUser.getExternalId());
        dbUser = refreshUser(dbUser, directoryUser);
        if (dbUser != null) {
            refreshed.add(dbUser);
        }
    }
    return refreshed;
}
#end_block

#method_before
private DbUser refreshUser(DbUser dbUser, DirectoryUser directoryUser) {
    // available (if it isn't marked already):
    if (directoryUser == null) {
        if (dbUser.getStatus() != 0) {
            log.warn("User \"{}\" will be marked as unvailable as it wasn't found in directory \"{}\".", directoryUser.getName(), directoryUser.getDirectory().getName());
            dbUser.setStatus(DirectoryEntryStatus.UNAVAILABLE.getValue());
            DbFacade.getInstance().getDbUserDao().update(dbUser);
        }
        return dbUser;
    }
    // This flag indicates if there are any differences and thus if the database update should actuall be performed:
    boolean update = false;
    // If the user was marked as not available in the database then mark it as available:
    if (dbUser.getStatus() == 0) {
        log.info("User \"{}\" will be marked as available as it was found in directory \"{}\".", directoryUser.getName(), directoryUser.getDirectory().getName());
        dbUser.setStatus(DirectoryEntryStatus.AVAILABLE.getValue());
        update = true;
    }
    // the flag that indicates that the database needs to be updated:
    if (!StringUtils.equals(dbUser.getFirstName(), directoryUser.getName())) {
        dbUser.setFirstName(directoryUser.getName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getLastName(), directoryUser.getLastName())) {
        dbUser.setLastName(directoryUser.getLastName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getDomain(), directoryUser.getDirectory().getName())) {
        dbUser.setDomain(directoryUser.getDirectory().getName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getLoginName(), directoryUser.getName())) {
        dbUser.setLoginName(directoryUser.getName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getDepartment(), directoryUser.getDepartment())) {
        dbUser.setDepartment(directoryUser.getDepartment());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getRole(), directoryUser.getTitle())) {
        dbUser.setRole(directoryUser.getTitle());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getEmail(), directoryUser.getEmail())) {
        dbUser.setEmail(directoryUser.getEmail());
        update = true;
    }
    // Compare the new list of group names and identifiers:
    StringBuilder groupNamesBuffer = new StringBuilder();
    StringBuilder groupIdsBuffer = new StringBuilder();
    boolean first = true;
    for (DirectoryGroup directoryGruop : directoryUser.getGroups()) {
        if (!first) {
            groupNamesBuffer.append(',');
            groupIdsBuffer.append(',');
        }
        groupNamesBuffer.append(directoryGruop.getName());
        groupIdsBuffer.append(directoryGruop.getId());
    }
    String groupNames = groupNamesBuffer.toString();
    String groupIds = groupIdsBuffer.toString();
    if (!StringUtils.equals(dbUser.getGroupNames(), groupNames)) {
        dbUser.setGroupNames(groupNames);
        update = true;
    }
    if (!StringUtils.equals(dbUser.getGroupIds(), groupIds)) {
        dbUser.setGroupIds(groupIds);
        update = true;
    }
    return update ? dbUser : null;
}
#method_after
private DbUser refreshUser(DbUser dbUser, DirectoryUser directoryUser) {
    // if it isn't marked already:
    if (directoryUser == null) {
        if (dbUser.isActive()) {
            log.warnFormat("User \"{0}\" will be marked as not active as it wasn't found in the directory \"{1}\".", dbUser.getLoginName(), dbUser.getDomain());
            dbUser.setActive(false);
        }
        return dbUser;
    }
    // This flag indicates if there are any differences and thus if the database update should actually be
    // performed:
    boolean update = false;
    // If the user was marked as not active in the database then mark it as active:
    if (!dbUser.isActive()) {
        log.infoFormat("User \"{0}\" will be marked as active as it was found in directory \"{1}\".", dbUser.getLoginName(), dbUser.getDomain());
        dbUser.setActive(true);
        update = true;
    }
    // the flag that indicates that the database needs to be updated:
    if (!StringUtils.equals(dbUser.getFirstName(), directoryUser.getName())) {
        dbUser.setFirstName(directoryUser.getName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getLastName(), directoryUser.getLastName())) {
        dbUser.setLastName(directoryUser.getLastName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getDomain(), directoryUser.getDirectory().getName())) {
        dbUser.setDomain(directoryUser.getDirectory().getName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getLoginName(), directoryUser.getName())) {
        dbUser.setLoginName(directoryUser.getName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getDepartment(), directoryUser.getDepartment())) {
        dbUser.setDepartment(directoryUser.getDepartment());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getRole(), directoryUser.getTitle())) {
        dbUser.setRole(directoryUser.getTitle());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getEmail(), directoryUser.getEmail())) {
        dbUser.setEmail(directoryUser.getEmail());
        update = true;
    }
    // Compare the new list of group names and identifiers:
    StringBuilder groupNamesBuffer = new StringBuilder();
    StringBuilder groupIdsBuffer = new StringBuilder();
    boolean first = true;
    for (DirectoryGroup directoryGroup : directoryUser.getGroups()) {
        DbGroup dbGroup = groupsMap.get(directoryGroup.getId());
        if (!first) {
            groupNamesBuffer.append(',');
            groupIdsBuffer.append(dbGroup.getId());
        }
        groupNamesBuffer.append(directoryGroup.getName());
        groupIdsBuffer.append(directoryGroup.getId());
        first = false;
    }
    String groupNames = groupNamesBuffer.toString();
    String groupIds = groupIdsBuffer.toString();
    if (!StringUtils.equals(dbUser.getGroupNames(), groupNames)) {
        dbUser.setGroupNames(groupNames);
        update = true;
    }
    if (!StringUtils.equals(dbUser.getGroupIds(), groupIds)) {
        dbUser.setGroupIds(groupIds);
        update = true;
    }
    return update ? dbUser : null;
}
#end_block

#method_before
private List<VmTemplate> searchVMTemplates() {
    return genericSearch(getDbFacade().getVmTemplateDao(), true, new Filter<VmTemplate>() {

        @Override
        public List<VmTemplate> filter(final List<VmTemplate> data) {
            for (IVdcQueryable vmt_helper : data) {
                VmTemplate vmt = (VmTemplate) vmt_helper;
                VmTemplateHandler.UpdateDisksFromDb(vmt);
            }
            return data;
        }
    });
}
#method_after
private List<VmTemplate> searchVMTemplates() {
    return genericSearch(getDbFacade().getVmTemplateDao(), true, new Filter<VmTemplate>() {

        @Override
        public List<VmTemplate> filter(final List<VmTemplate> data) {
            for (IVdcQueryable vmt_helper : data) {
                VmTemplate vmt = (VmTemplate) vmt_helper;
                VmTemplateHandler.updateDisksFromDb(vmt);
            }
            return data;
        }
    });
}
#end_block

#method_before
private QueryData initQueryData(boolean useCache) {
    QueryData data = null;
    boolean isExistsValue = false;
    boolean IsFromYesterday = false;
    boolean isSafe = false;
    String searchKey = "";
    try {
        String searchText = getParameters().getSearchPattern();
        // find if this is a trivial search expression (like 'Vms:' etc).
        isSafe = SearchObjects.isSafeExpression(searchText);
        if (useCache) {
            // first lets check the cache of queries.
            searchKey = String.format("%1$s,%2$s,%3$s", searchText, getParameters().getMaxCount(), getParameters().getCaseSensitive());
            data = mQueriesCache.get(searchKey);
            isExistsValue = (data != null);
            if (isExistsValue) {
                TimeSpan span = DateTime.getNow().Subtract(data.getDate());
                if (span.Days >= 1) {
                    IsFromYesterday = true;
                }
            }
        }
        // search text.
        if (!isExistsValue || IsFromYesterday) {
            log.debugFormat("ResourceManager::searchBusinessObjects(''{0}'') - entered", searchText);
            String queryDomain = null;
            ISyntaxChecker curSyntaxChecker;
            String[] splitted = searchText.split("[:@ ]");
            final String objectName = splitted[0].toUpperCase();
            if ((SearchObjects.AD_USER_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_USER_PLU_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_PLU_OBJ_NAME.equals(objectName))) {
                if (searchText.indexOf('@') > 0 && splitted.length > 1) {
                    queryDomain = splitted[1];
                    searchText = searchText.substring(0, searchText.indexOf('@')) + searchText.substring(searchText.indexOf(':'));
                } else {
                    queryDomain = getDefaultDomain();
                }
                curSyntaxChecker = SyntaxCheckerFactory.CreateADSyntaxChecker(Config.<String>GetValue(ConfigValues.AuthenticationMethod));
            } else {
                curSyntaxChecker = SyntaxCheckerFactory.CreateBackendSyntaxChecker(Config.<String>GetValue(ConfigValues.AuthenticationMethod));
            }
            SyntaxContainer searchObj = curSyntaxChecker.analyzeSyntaxState(searchText, true);
            // set the case-sensitive flag
            searchObj.setCaseSensitive(getParameters().getCaseSensitive());
            searchObj.setMaxCount(getParameters().getMaxCount() == -1 ? Config.<Integer>GetValue(ConfigValues.SearchResultsLimit) : getParameters().getMaxCount());
            // setting FromSearch value
            searchObj.setSearchFrom(getParameters().getSearchFrom());
            if (searchObj.getError() != SyntaxError.NO_ERROR) {
                log.warnFormat("ResourceManager::searchBusinessObjects - erroneous search text - ''{0}''", searchText);
                int startPos = searchObj.getErrorStartPos();
                int endPos = searchObj.getErrorEndPos();
                int length = endPos - startPos;
                String error = (length > 0 && ((startPos + 1 + length) < searchText.length()) && (endPos + 1 < searchText.length())) ? searchText.substring(0, startPos) + "$" + searchText.substring(startPos + 1, startPos + 1 + length) + "$" + searchText.substring(endPos + 1) : searchObj.getError().toString();
                getQueryReturnValue().setExceptionString(error);
                return null;
            }
            if (searchObj.getvalid() != true) {
                log.warnFormat("ResourceManager::searchBusinessObjects - Invalid search text - ''{0}''", searchText);
                return null;
            }
            // An expression is considered safe if matches a trivial search.
            data = new QueryData(curSyntaxChecker.generateQueryFromSyntaxContainer(searchObj, isSafe), searchObj.getSearchObjectStr(), new Date(), queryDomain);
            // query from scratch.
            if (!containsStaticInValues(data.getQuery()))
                mQueriesCache.put(searchKey, data);
        }
    } catch (SearchEngineIllegalCharacterException e) {
        log.error("Search expression can not end with ESCAPE character:" + getParameters().getSearchPattern());
        data = null;
    } catch (SqlInjectionException e) {
        log.error("Sql Injection in search: " + getParameters().getSearchPattern());
        data = null;
    } catch (RuntimeException ex) {
        log.warn("Illegal search: " + getParameters().getSearchPattern(), ex);
        data = null;
    }
    return data;
}
#method_after
private QueryData initQueryData(boolean useCache) {
    QueryData data = null;
    boolean isExistsValue = false;
    boolean IsFromYesterday = false;
    boolean isSafe = false;
    String searchKey = "";
    try {
        String searchText = getParameters().getSearchPattern();
        // find if this is a trivial search expression (like 'Vms:' etc).
        isSafe = SearchObjects.isSafeExpression(searchText);
        if (useCache) {
            // first lets check the cache of queries.
            searchKey = String.format("%1$s,%2$s,%3$s", searchText, getParameters().getMaxCount(), getParameters().getCaseSensitive());
            data = mQueriesCache.get(searchKey);
            isExistsValue = (data != null);
            if (isExistsValue) {
                TimeSpan span = DateTime.getNow().subtract(new Date(data.getDate()));
                if (span.Days >= 1) {
                    IsFromYesterday = true;
                }
            }
        }
        // search text.
        if (!isExistsValue || IsFromYesterday) {
            log.debugFormat("ResourceManager::searchBusinessObjects(''{0}'') - entered", searchText);
            String queryDomain = null;
            ISyntaxChecker curSyntaxChecker;
            String[] splitted = searchText.split("[:@ ]");
            final String objectName = splitted[0].toUpperCase();
            if ((SearchObjects.AD_USER_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_USER_PLU_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_OBJ_NAME.equals(objectName)) || (SearchObjects.AD_GROUP_PLU_OBJ_NAME.equals(objectName))) {
                if (searchText.indexOf('@') > 0 && splitted.length > 1) {
                    queryDomain = splitted[1];
                    searchText = searchText.substring(0, searchText.indexOf('@')) + searchText.substring(searchText.indexOf(':'));
                } else {
                    queryDomain = getDefaultDomain();
                }
                curSyntaxChecker = SyntaxCheckerFactory.createADSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            } else {
                curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker(Config.<String>getValue(ConfigValues.AuthenticationMethod));
            }
            SyntaxContainer searchObj = curSyntaxChecker.analyzeSyntaxState(searchText, true);
            // set the case-sensitive flag
            searchObj.setCaseSensitive(getParameters().getCaseSensitive());
            searchObj.setMaxCount(getParameters().getMaxCount() == -1 ? Integer.MAX_VALUE : getParameters().getMaxCount());
            // setting FromSearch value
            searchObj.setSearchFrom(getParameters().getSearchFrom());
            if (searchObj.getError() != SyntaxError.NO_ERROR) {
                log.warnFormat("ResourceManager::searchBusinessObjects - erroneous search text - ''{0}''", searchText);
                int startPos = searchObj.getErrorStartPos();
                int endPos = searchObj.getErrorEndPos();
                int length = endPos - startPos;
                String error = (length > 0 && ((startPos + 1 + length) < searchText.length()) && (endPos + 1 < searchText.length())) ? searchText.substring(0, startPos) + "$" + searchText.substring(startPos + 1, startPos + 1 + length) + "$" + searchText.substring(endPos + 1) : searchObj.getError().toString();
                getQueryReturnValue().setExceptionString(error);
                return null;
            }
            if (searchObj.getvalid() != true) {
                log.warnFormat("ResourceManager::searchBusinessObjects - Invalid search text - ''{0}''", searchText);
                return null;
            }
            // An expression is considered safe if matches a trivial search.
            data = new QueryData(curSyntaxChecker.generateQueryFromSyntaxContainer(searchObj, isSafe), DateTime.getNow().getTime(), queryDomain);
            // query from scratch.
            if (!containsStaticInValues(data.getQuery()))
                mQueriesCache.put(searchKey, data);
        }
    } catch (SearchEngineIllegalCharacterException e) {
        log.error("Search expression can not end with ESCAPE character:" + getParameters().getSearchPattern());
        data = null;
    } catch (SqlInjectionException e) {
        log.error("Sql Injection in search: " + getParameters().getSearchPattern());
        data = null;
    } catch (RuntimeException ex) {
        log.warn("Illegal search: " + getParameters().getSearchPattern(), ex);
        data = null;
    }
    return data;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((externalId == null) ? 0 : externalId.hashCode());
    result = prime * result + ((department == null) ? 0 : department.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + ((email == null) ? 0 : email.hashCode());
    result = prime * result + ((groupNames == null) ? 0 : groupNames.hashCode());
    result = prime * result + (isAdmin ? 1231 : 1237);
    result = prime * result + ((firstName == null) ? 0 : firstName.hashCode());
    result = prime * result + ((note == null) ? 0 : note.hashCode());
    result = prime * result + ((role == null) ? 0 : role.hashCode());
    result = prime * result + status;
    result = prime * result + ((lastName == null) ? 0 : lastName.hashCode());
    result = prime * result + ((loginName == null) ? 0 : loginName.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((externalId == null) ? 0 : externalId.hashCode());
    result = prime * result + ((department == null) ? 0 : department.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + ((email == null) ? 0 : email.hashCode());
    result = prime * result + ((groupNames == null) ? 0 : groupNames.hashCode());
    result = prime * result + (isAdmin ? 1231 : 1237);
    result = prime * result + ((firstName == null) ? 0 : firstName.hashCode());
    result = prime * result + ((note == null) ? 0 : note.hashCode());
    result = prime * result + ((role == null) ? 0 : role.hashCode());
    result = prime * result + (active ? 1231 : 1237);
    result = prime * result + ((lastName == null) ? 0 : lastName.hashCode());
    result = prime * result + ((loginName == null) ? 0 : loginName.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DbUser other = (DbUser) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(externalId, other.externalId) && ObjectUtils.objectsEqual(department, other.department) && ObjectUtils.objectsEqual(domain, other.domain) && ObjectUtils.objectsEqual(email, other.email) && ObjectUtils.objectsEqual(groupNames, other.groupNames) && isAdmin == other.isAdmin && ObjectUtils.objectsEqual(firstName, other.firstName) && ObjectUtils.objectsEqual(note, other.note) && ObjectUtils.objectsEqual(role, other.role) && status == other.status && ObjectUtils.objectsEqual(lastName, other.lastName) && ObjectUtils.objectsEqual(loginName, other.loginName));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DbUser other = (DbUser) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(externalId, other.externalId) && ObjectUtils.objectsEqual(department, other.department) && ObjectUtils.objectsEqual(domain, other.domain) && ObjectUtils.objectsEqual(email, other.email) && ObjectUtils.objectsEqual(groupNames, other.groupNames) && isAdmin == other.isAdmin && ObjectUtils.objectsEqual(firstName, other.firstName) && ObjectUtils.objectsEqual(note, other.note) && ObjectUtils.objectsEqual(role, other.role) && active == other.active && ObjectUtils.objectsEqual(lastName, other.lastName) && ObjectUtils.objectsEqual(loginName, other.loginName));
}
#end_block

#method_before
@Override
protected void verifyModel(Group model, int index) {
    assertEquals(GUIDS[index].toString(), model.getId());
    assertArrayEquals(EXTERNAL_IDS[index].getBytes(), model.getExternalId());
    assertEquals(GROUP_NAMES[index], model.getName());
    assertNotNull(model.getDomain());
    assertEquals(new Guid(DOMAIN.getBytes(), true).toString(), model.getDomain().getId());
    verifyLinks(model);
}
#method_after
@Override
protected void verifyModel(Group model, int index) {
    assertEquals(GUIDS[index].toString(), model.getId());
    assertEquals(EXTERNAL_IDS[index].toHex(), model.getExternalId());
    assertEquals(GROUP_NAMES[index], model.getName());
    assertNotNull(model.getDomain());
    assertEquals(new Guid(DOMAIN.getBytes(), true).toString(), model.getDomain().getId());
    verifyLinks(model);
}
#end_block

#method_before
@Override
protected void verifyModel(Group model, int index) {
    assertArrayEquals(EXTERNAL_IDS[index].getBytes(), model.getExternalId());
    assertEquals(NAMES[index], model.getName());
}
#method_after
@Override
protected void verifyModel(Group model, int index) {
    assertEquals(EXTERNAL_IDS[index].toHex(), model.getExternalId());
    assertEquals(NAMES[index], model.getName());
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    // Get the name of the internal domain:
    String internal = Config.<String>GetValue(ConfigValues.AdminDomain);
    // Get the list of authentication profile names:
    List<AuthenticationProfile> profiles = AuthenticationProfileManager.getInstance().getProfiles();
    List<String> names = new ArrayList<>(profiles.size());
    for (AuthenticationProfile profile : profiles) {
        names.add(profile.getName());
    }
    if (getParameters().getFilterInternalDomain()) {
        names.remove(internal);
    }
    // Sort it so that the internal profile is always the last:
    sort(names, new LoginDomainComparator(internal));
    // Return the sorted list:
    getQueryReturnValue().setReturnValue(names);
}
#method_after
@Override
protected void executeQueryCommand() {
    // Get the name of the internal domain:
    String internal = Config.<String>getValue(ConfigValues.AdminDomain);
    // Get the list of authentication profile names:
    List<AuthenticationProfile> profiles = AuthenticationProfileManager.getInstance().getProfiles();
    List<String> names = new ArrayList<>(profiles.size());
    for (AuthenticationProfile profile : profiles) {
        names.add(profile.getName());
    }
    if (getParameters().getFilterInternalDomain()) {
        names.remove(internal);
    }
    // Sort it so that the internal profile is always the last:
    sort(names, new LoginDomainComparator(internal));
    // Return the sorted list:
    getQueryReturnValue().setReturnValue(names);
}
#end_block

#method_before
@Override
protected void verifyModel(User model, int index) {
    assertArrayEquals(EXTERNAL_IDS[index].getBytes(), model.getExternalId());
    assertEquals(NAMES[index], model.getUserName());
}
#method_after
@Override
protected void verifyModel(User model, int index) {
    assertEquals(EXTERNAL_IDS[index].toHex(), model.getExternalId());
    assertEquals(NAMES[index], model.getUserName());
}
#end_block

#method_before
@Before
public void setUp() {
    initMocks(this);
    doReturn(DIRECTORY).when(authenticatorMock).getName();
    AuthenticatorManager.getInstance().registerAuthenticator(authenticatorMock);
    doReturn(DIRECTORY).when(directoryMock).getName();
    DirectoryManager.getInstance().registerDirectory(directoryMock);
    doReturn(DIRECTORY).when(profileMock).getName();
    doReturn(authenticatorMock).when(profileMock).getAuthenticator();
    doReturn(directoryMock).when(profileMock).getDirectory();
    AuthenticationProfileManager.getInstance().registerProfile(profileMock);
}
#method_after
@Before
public void setUp() {
    initMocks(this);
    AuthenticatorManager.getInstance().registerAuthenticator(NAME, authenticatorMock);
    doReturn(NAME).when(directoryMock).getName();
    DirectoryManager.getInstance().registerDirectory(NAME, directoryMock);
    doReturn(NAME).when(profileMock).getName();
    doReturn(authenticatorMock).when(profileMock).getAuthenticator();
    doReturn(directoryMock).when(profileMock).getDirectory();
    AuthenticationProfileManager.getInstance().registerProfile(NAME, profileMock);
}
#end_block

#method_before
protected DirectoryGroup getAdGroup() {
    if (mGroup == null && !getGroupId().equals(Guid.Empty)) {
        DbGroup dbGroup = DbFacade.getInstance().getDbGroupDao().get(getGroupId());
        Directory directory = DirectoryManager.getInstance().getDirectory(dbGroup.getDomain());
        // XXX: Should check for null directory.
        mGroup = directory.findGroup(dbGroup.getExternalId());
    }
    return mGroup;
}
#method_after
protected DirectoryGroup getAdGroup() {
    if (mGroup == null && !getGroupId().equals(Guid.Empty)) {
        DbGroup dbGroup = DbFacade.getInstance().getDbGroupDao().get(getGroupId());
        Directory directory = DirectoryManager.getInstance().getDirectory(dbGroup.getDomain());
        mGroup = directory.findGroup(dbGroup.getExternalId());
    }
    return mGroup;
}
#end_block

#method_before
private Principal setUpLoginExpectations(boolean canDo, boolean success) {
    VdcReturnValueBase result = control.createMock(VdcReturnValueBase.class);
    Principal principal = new Principal(USER, SECRET, DOMAIN);
    expect(backend.Login((LoginUserParameters) eqActionParams(LoginUserParameters.class, new String[] { "LoginName", "Password", "ProfileName", "ActionType", "SessionId" }, new Object[] { USER, SECRET, DOMAIN, VdcActionType.LoginUser, session.getSessionId() }))).andReturn(result);
    expect(result.getCanDoAction()).andReturn(canDo);
    expect(result.getSucceeded()).andReturn(success).anyTimes();
    DbUser user = control.createMock(DbUser.class);
    if (canDo && success) {
        expect(result.getActionReturnValue()).andReturn(user);
        VdcQueryReturnValue appModeResult = new VdcQueryReturnValue();
        appModeResult.setReturnValue(255);
        appModeResult.setSucceeded(true);
        expect(backend.RunPublicQuery(eq(VdcQueryType.GetConfigurationValue), eqQueryParams(GetConfigurationValueParameters.class, new String[] { "ConfigValue" }, new Object[] { ConfigurationValues.ApplicationMode }))).andReturn(appModeResult);
        current.set(user);
        EasyMock.expectLastCall();
    }
    control.replay();
    return principal;
}
#method_after
private Principal setUpLoginExpectations(boolean canDo, boolean success) {
    VdcReturnValueBase result = control.createMock(VdcReturnValueBase.class);
    Principal principal = new Principal(USER, SECRET, DOMAIN);
    expect(backend.login((LoginUserParameters) eqActionParams(LoginUserParameters.class, new String[] { "LoginName", "Password", "ProfileName", "ActionType", "SessionId" }, new Object[] { USER, SECRET, DOMAIN, VdcActionType.LoginUser, session.getSessionId() }))).andReturn(result);
    expect(result.getCanDoAction()).andReturn(canDo);
    expect(result.getSucceeded()).andReturn(success).anyTimes();
    DbUser user = control.createMock(DbUser.class);
    if (canDo && success) {
        expect(result.getActionReturnValue()).andReturn(user);
        VdcQueryReturnValue appModeResult = new VdcQueryReturnValue();
        appModeResult.setReturnValue(255);
        appModeResult.setSucceeded(true);
        expect(backend.runPublicQuery(eq(VdcQueryType.GetConfigurationValue), eqQueryParams(GetConfigurationValueParameters.class, new String[] { "ConfigValue" }, new Object[] { ConfigurationValues.ApplicationMode }))).andReturn(appModeResult);
        current.set(user);
        EasyMock.expectLastCall();
    }
    control.replay();
    return principal;
}
#end_block

#method_before
private Principal setUpValidateSession(boolean success) {
    VdcQueryReturnValue queryReturnValue = control.createMock(VdcQueryReturnValue.class);
    Principal principal = new Principal(USER, SECRET, DOMAIN);
    DbUser user = control.createMock(DbUser.class);
    expect(backend.RunPublicQuery(eq(VdcQueryType.ValidateSession), eqQueryParams(VdcQueryParametersBase.class, new String[] { "SessionId" }, new Object[] { sessionId }))).andReturn(queryReturnValue);
    expect(queryReturnValue.getSucceeded()).andReturn(success).anyTimes();
    if (success) {
        expect(queryReturnValue.getReturnValue()).andReturn(user);
        current.set(user);
        EasyMock.expectLastCall();
    }
    control.replay();
    return principal;
}
#method_after
private Principal setUpValidateSession(boolean success) {
    VdcQueryReturnValue queryReturnValue = control.createMock(VdcQueryReturnValue.class);
    Principal principal = new Principal(USER, SECRET, DOMAIN);
    DbUser user = control.createMock(DbUser.class);
    expect(backend.runPublicQuery(eq(VdcQueryType.ValidateSession), eqQueryParams(VdcQueryParametersBase.class, new String[] { "SessionId" }, new Object[] { sessionId }))).andReturn(queryReturnValue);
    expect(queryReturnValue.getSucceeded()).andReturn(success).anyTimes();
    if (success) {
        expect(queryReturnValue.getReturnValue()).andReturn(user);
        VdcQueryReturnValue appModeResult = new VdcQueryReturnValue();
        appModeResult.setReturnValue(255);
        appModeResult.setSucceeded(true);
        expect(backend.runPublicQuery(eq(VdcQueryType.GetConfigurationValue), eqQueryParams(GetConfigurationValueParameters.class, new String[] { "ConfigValue" }, new Object[] { ConfigurationValues.ApplicationMode }))).andReturn(appModeResult);
        current.set(user);
        EasyMock.expectLastCall();
    }
    control.replay();
    return principal;
}
#end_block

#method_before
private ServerResponse setUpLogoutExpectations() {
    VdcReturnValueBase result = control.createMock(VdcReturnValueBase.class);
    DbUser user = control.createMock(DbUser.class);
    expect(current.get(DbUser.class)).andReturn(user);
    expect(user.getId()).andReturn(GUID);
    expect(backend.Logoff((LogoutUserParameters) eqActionParams(LogoutUserParameters.class, new String[] { "UserId", "SessionId" }, new Object[] { GUID, session.getSessionId() }))).andReturn(result);
    ServerResponse response = control.createMock(ServerResponse.class);
    control.replay();
    return response;
}
#method_after
private ServerResponse setUpLogoutExpectations() {
    VdcReturnValueBase result = control.createMock(VdcReturnValueBase.class);
    DbUser user = control.createMock(DbUser.class);
    expect(current.get(DbUser.class)).andReturn(user);
    expect(user.getId()).andReturn(GUID);
    expect(backend.logoff((LogoutUserParameters) eqActionParams(LogoutUserParameters.class, new String[] { "UserId", "SessionId" }, new Object[] { GUID, session.getSessionId() }))).andReturn(result);
    ServerResponse response = control.createMock(ServerResponse.class);
    control.replay();
    return response;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    permissions perm = getParameters().getPermission();
    if (perm == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_PERMISSION_NOT_SENT);
        return false;
    }
    Role role = getRoleDao().get(perm.getrole_id());
    Guid adElementId = perm.getad_element_id();
    if (role == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_INVALID_ROLE_ID);
        return false;
    }
    if (perm.getObjectType() == null || getVdcObjectName() == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_INVALID_OBJECT_ID);
        return false;
    }
    // give permission
    if (getParameters().getUser() == null && getParameters().getGroup() == null && getDbUserDAO().get(adElementId) == null && getAdGroupDAO().get(adElementId) == null) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.USER_MUST_EXIST_IN_DB.toString());
        return false;
    }
    // only system super user can give permissions with admin roles
    if (!isSystemSuperUser() && role.getType() == RoleType.ADMIN) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_ONLY_SYSTEM_SUPER_USER_CAN_GIVE_ADMIN_ROLES);
        return false;
    }
    // don't allow adding permissions to vms from pool externally
    if (!isInternalExecution() && perm.getObjectType() == VdcObjectType.VM) {
        VM vm = getVmDAO().get(perm.getObjectId());
        if (vm != null && vm.getVmPoolId() != null) {
            addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_VM_IN_POOL);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    Permissions perm = getParameters().getPermission();
    if (perm == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_PERMISSION_NOT_SENT);
        return false;
    }
    Role role = getRoleDao().get(perm.getrole_id());
    Guid adElementId = perm.getad_element_id();
    if (role == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_INVALID_ROLE_ID);
        return false;
    }
    if (perm.getObjectType() == null || getVdcObjectName() == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_INVALID_OBJECT_ID);
        return false;
    }
    // give permission
    if (getParameters().getUser() == null && getParameters().getGroup() == null && getDbUserDAO().get(adElementId) == null && getAdGroupDAO().get(adElementId) == null) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.USER_MUST_EXIST_IN_DB.toString());
        return false;
    }
    // only system super user can give permissions with admin roles
    if (!isSystemSuperUser() && role.getType() == RoleType.ADMIN) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_ONLY_SYSTEM_SUPER_USER_CAN_GIVE_ADMIN_ROLES);
        return false;
    }
    // don't allow adding permissions to vms from pool externally
    if (!isInternalExecution() && perm.getObjectType() == VdcObjectType.VM) {
        VM vm = getVmDAO().get(perm.getObjectId());
        if (vm != null && vm.getVmPoolId() != null) {
            addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_VM_IN_POOL);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Get the parameters:
    T parameters = getParameters();
    // The user or group given in the parameters may haven't been added to
    // the database yet, this will be the case if they don't have an
    // internal identifier, if this is the case then they need to be
    // added to the database now, before the permission:
    final DbUser user = parameters.getUser();
    if (user != null && user.getId() == null) {
        user.setId(Guid.newGuid());
        getDbUserDAO().save(user);
    }
    final DbGroup group = parameters.getGroup();
    if (group != null && group.getId() == null) {
        group.setId(Guid.newGuid());
        getAdGroupDAO().save(group);
    }
    // The identifier of the owner of the permission can come from the
    // parameters directly or from the user/group objects:
    Guid ownerId = parameters.getPermission().getad_element_id();
    if (ownerId == null) {
        if (user != null) {
            ownerId = user.getId();
        }
        if (ownerId == null) {
            if (group != null) {
                ownerId = group.getId();
            }
        }
    }
    final permissions paramPermission = parameters.getPermission();
    permissions permission = getPermissionDAO().getForRoleAndAdElementAndObject(paramPermission.getrole_id(), ownerId, paramPermission.getObjectId());
    if (permission == null) {
        paramPermission.setId(Guid.newGuid());
        paramPermission.setad_element_id(ownerId);
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getPermissionDAO().save(paramPermission);
                getCompensationContext().snapshotNewEntity(paramPermission);
                getCompensationContext().stateChanged();
                return null;
            }
        });
        permission = paramPermission;
    }
    getReturnValue().setActionReturnValue(permission.getId());
    if (user != null) {
        updateAdminStatus(permission);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // Get the parameters:
    T parameters = getParameters();
    // The user or group given in the parameters may haven't been added to
    // the database yet, this will be the case if they don't have an
    // internal identifier, if this is the case then they need to be
    // added to the database now, before the permission:
    final DbUser user = parameters.getUser();
    if (user != null && user.getId() == null) {
        user.setId(Guid.newGuid());
        getDbUserDAO().save(user);
    }
    final DbGroup group = parameters.getGroup();
    if (group != null && group.getId() == null) {
        group.setId(Guid.newGuid());
        getAdGroupDAO().save(group);
    }
    // The identifier of the owner of the permission can come from the parameters directly or from the user/group
    // objects:
    Guid ownerId = parameters.getPermission().getad_element_id();
    if (ownerId == null) {
        if (user != null) {
            ownerId = user.getId();
        }
        if (ownerId == null) {
            if (group != null) {
                ownerId = group.getId();
            }
        }
    }
    final Permissions paramPermission = parameters.getPermission();
    Permissions permission = getPermissionDAO().getForRoleAndAdElementAndObject(paramPermission.getrole_id(), ownerId, paramPermission.getObjectId());
    if (permission == null) {
        paramPermission.setId(Guid.newGuid());
        paramPermission.setad_element_id(ownerId);
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getPermissionDAO().save(paramPermission);
                getCompensationContext().snapshotNewEntity(paramPermission);
                getCompensationContext().stateChanged();
                return null;
            }
        });
        permission = paramPermission;
    }
    getReturnValue().setActionReturnValue(permission.getId());
    if (user != null) {
        updateAdminStatus(permission);
    }
    setSucceeded(true);
}
#end_block

#method_before
private void updateAdminStatus(permissions perm) {
    // if the role of the permission is of type admin update the user
    // lastAdminCheckStatus to true
    Role role = getRoleDao().get(perm.getrole_id());
    if (role.getType() == RoleType.ADMIN) {
        MultiLevelAdministrationHandler.setIsAdminGUIFlag(perm.getad_element_id(), true);
    }
}
#method_after
private void updateAdminStatus(Permissions perm) {
    // if the role of the permission is of type admin update the user
    // lastAdminCheckStatus to true
    Role role = getRoleDao().get(perm.getrole_id());
    if (role.getType() == RoleType.ADMIN) {
        MultiLevelAdministrationHandler.setIsAdminGUIFlag(perm.getad_element_id(), true);
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    permissions permission = getParameters().getPermission();
    List<PermissionSubject> permissionsSubject = new ArrayList<>();
    permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    initUserAndGroupData();
    // user from the directory service
    if (getParameters().getUser() != null && dbUser == null) {
        permissionsSubject.add(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, VdcActionType.AddUser.getActionGroup()));
    }
    return permissionsSubject;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    Permissions permission = getParameters().getPermission();
    List<PermissionSubject> permissionsSubject = new ArrayList<>();
    permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    initUserAndGroupData();
    // user from the directory service
    if (getParameters().getUser() != null && dbUser == null) {
        permissionsSubject.add(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, VdcActionType.AddUser.getActionGroup()));
    }
    return permissionsSubject;
}
#end_block

#method_before
@Override
public VdcQueryReturnValue RunQuery(VdcQueryType search, VdcQueryParametersBase searchParameters) {
    // $NON-NLS-1$
    log.debug("Server: RunQuery invoked!");
    debugQuery(search, searchParameters);
    searchParameters.setSessionId(getSessionId());
    return getBackend().RunQuery(search, searchParameters);
}
#method_after
@Override
public VdcQueryReturnValue RunQuery(VdcQueryType search, VdcQueryParametersBase searchParameters) {
    // $NON-NLS-1$
    log.debug("Server: RunQuery invoked!");
    debugQuery(search, searchParameters);
    searchParameters.setSessionId(getSessionId());
    return getBackend().runQuery(search, searchParameters);
}
#end_block

#method_before
@Override
public VdcQueryReturnValue RunPublicQuery(VdcQueryType queryType, VdcQueryParametersBase params) {
    // $NON-NLS-1$
    log.debug("Server: RunPublicQuery invoked! " + queryType);
    debugQuery(queryType, params);
    return getBackend().RunPublicQuery(queryType, params);
}
#method_after
@Override
public VdcQueryReturnValue RunPublicQuery(VdcQueryType queryType, VdcQueryParametersBase params) {
    // $NON-NLS-1$
    log.debug("Server: runPublicQuery invoked! " + queryType);
    debugQuery(queryType, params);
    return getBackend().runPublicQuery(queryType, params);
}
#end_block

#method_before
@Override
public ArrayList<VdcReturnValueBase> RunMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> multipleParams, boolean isRunOnlyIfAllCanDoPass) {
    // $NON-NLS-1$ //$NON-NLS-2$
    log.debug("Server: RunMultipleAction invoked! [amount of actions: " + multipleParams.size() + "]");
    for (VdcActionParametersBase params : multipleParams) {
        params.setSessionId(getSessionId());
    }
    ArrayList<VdcReturnValueBase> returnValues = getBackend().RunMultipleActions(actionType, multipleParams, isRunOnlyIfAllCanDoPass);
    return returnValues;
}
#method_after
@Override
public ArrayList<VdcReturnValueBase> RunMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> multipleParams, boolean isRunOnlyIfAllCanDoPass) {
    // $NON-NLS-1$ //$NON-NLS-2$
    log.debug("Server: RunMultipleAction invoked! [amount of actions: " + multipleParams.size() + "]");
    for (VdcActionParametersBase params : multipleParams) {
        params.setSessionId(getSessionId());
    }
    ArrayList<VdcReturnValueBase> returnValues = getBackend().runMultipleActions(actionType, multipleParams, isRunOnlyIfAllCanDoPass);
    return returnValues;
}
#end_block

#method_before
@Override
public VdcReturnValueBase RunAction(VdcActionType actionType, VdcActionParametersBase params) {
    // $NON-NLS-1$
    log.debug("Server: RunAction invoked!");
    debugAction(actionType, params);
    params.setSessionId(getSessionId());
    if (noBackend) {
        VdcReturnValueBase rValue = new VdcReturnValueBase();
        rValue.setSucceeded(true);
        return rValue;
    }
    return getBackend().RunAction(actionType, params);
}
#method_after
@Override
public VdcReturnValueBase RunAction(VdcActionType actionType, VdcActionParametersBase params) {
    // $NON-NLS-1$
    log.debug("Server: RunAction invoked!");
    debugAction(actionType, params);
    params.setSessionId(getSessionId());
    if (noBackend) {
        VdcReturnValueBase rValue = new VdcReturnValueBase();
        rValue.setSucceeded(true);
        return rValue;
    }
    return getBackend().runAction(actionType, params);
}
#end_block

#method_before
@Override
public VdcReturnValueBase logOff(DbUser userToLogoff) {
    LogoutUserParameters params = new LogoutUserParameters(userToLogoff.getId());
    params.setSessionId(getSessionId());
    VdcReturnValueBase returnValue = getBackend().Logoff(params);
    return returnValue;
}
#method_after
@Override
public VdcReturnValueBase logOff(DbUser userToLogoff) {
    LogoutUserParameters params = new LogoutUserParameters(userToLogoff.getId());
    params.setSessionId(getSessionId());
    VdcReturnValueBase returnValue = getBackend().logoff(params);
    return returnValue;
}
#end_block

#method_before
@Override
public VdcReturnValueBase Login(String userName, String password, String domain) {
    LoginUserParameters params = new LoginUserParameters(domain, userName, password);
    params.setSessionId(getSessionId());
    params.setActionType(VdcActionType.LoginAdminUser);
    VdcReturnValueBase returnValue = getBackend().Login(params);
    return returnValue;
}
#method_after
@Override
public VdcReturnValueBase Login(String userName, String password, String profileName, VdcActionType loginType) {
    LoginUserParameters params = new LoginUserParameters(profileName, userName, password);
    params.setSessionId(getSessionId());
    params.setActionType(loginType);
    VdcReturnValueBase returnValue = getBackend().login(params);
    return returnValue;
}
#end_block

#method_before
@Override
public boolean authenticate(String name, char[] password) {
    return true;
}
#method_after
@Override
public AuthenticationResult<?> authenticate(String name, String password) {
    return new NopAuthenticationResult();
}
#end_block

#method_before
@Override
public Directory create(File file, Configuration config) {
    // Get the name of the directory:
    String name = config.getInheritedString(NAME_PARAMETER);
    if (name == null) {
        log.error("The configuration file \"{}\" doesn't contain the name of the directory.", file.getAbsolutePath());
        return null;
    }
    // We are good, create the directory:
    return new NopDirectory(name);
}
#method_after
@Override
public Directory create(Configuration config) throws ConfigurationException {
    // Get the name of the directory:
    String name = config.getInheritedString(NAME_PARAMETER);
    if (name == null) {
        throw new ConfigurationException("The configuration file \"" + config.getFile().getAbsolutePath() + "\" doesn't contain the name of " + "the directory.");
    }
    // We are good, create the directory:
    return new NopDirectory(name);
}
#end_block

#method_before
@Override
public DirectoryUser findUser(String name) {
    ExternalId id = new ExternalId(name.getBytes());
    return new DirectoryUser(this, id, name);
}
#method_after
@Override
public DirectoryUser findUser(String name) {
    ExternalId id = null;
    try {
        id = new ExternalId(name.getBytes("UTF-8"));
    } catch (UnsupportedEncodingException e) {
        return null;
    }
    return new DirectoryUser(this, id, name);
}
#end_block

#method_before
@Override
public DirectoryUser findUser(ExternalId id) {
    String name = new String(id.getBytes());
    return new DirectoryUser(this, id, name);
}
#method_after
@Override
public DirectoryUser findUser(ExternalId id) {
    String name = null;
    try {
        name = new String(id.getBytes(), "UTF-8");
    } catch (UnsupportedEncodingException e) {
        return null;
    }
    return new DirectoryUser(this, id, name);
}
#end_block

#method_before
@Override
public Authenticator create(File file, Configuration config) {
    // Get the name of the authenticator:
    String name = config.getInheritedString(NAME_PARAMETER);
    if (name == null) {
        log.error("The configuration file \"{}\" doesn't contain the name of the authenticator.", file.getAbsolutePath());
        return null;
    }
    // We are good, create the authenticator:
    return new NopAuthenticator(name);
}
#method_after
@Override
public Authenticator create(Configuration config) throws ConfigurationException {
    return new NopAuthenticator();
}
#end_block

#method_before
@SuppressWarnings("deprecation")
public static DbUser initUser(String sessionId, String domain, Guid id) {
    DbUser dbUser = DbFacade.getInstance().getDbUserDao().get(id);
    if (dbUser == null) {
        LdapUser adUser = (LdapUser) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(sessionId, domain, id)).getReturnValue();
        if (adUser == null) {
            throw new VdcBLLException(VdcBllErrors.USER_FAILED_POPULATE_DATA);
        }
        dbUser = new DbUser(adUser);
        DbFacade.getInstance().getDbUserDao().save(dbUser);
    }
    return dbUser;
}
#method_after
@SuppressWarnings("deprecation")
public static DbUser initUser(String sessionId, String domain, Guid id) {
    DbUser dbUser = DbFacade.getInstance().getDbUserDao().get(id);
    if (dbUser == null) {
        LdapUser adUser = (LdapUser) LdapFactory.getInstance(domain).runAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(sessionId, domain, id)).getReturnValue();
        if (adUser == null) {
            throw new VdcBLLException(VdcBllErrors.USER_FAILED_POPULATE_DATA);
        }
        dbUser = new DbUser(adUser);
        DbFacade.getInstance().getDbUserDao().save(dbUser);
    }
    return dbUser;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    String directory = getParameters().getDirectory();
    Guid id = getParameters().getId();
    directoryGroup = (LdapGroup) LdapFactory.getInstance(directory).RunAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(directory, id)).getReturnValue();
    if (directoryGroup == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    addCustomValue("NewUserName", directoryGroup.getname());
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    String directory = getParameters().getDirectory();
    Guid id = getParameters().getId();
    directoryGroup = (LdapGroup) LdapFactory.getInstance(directory).runAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(directory, id)).getReturnValue();
    if (directoryGroup == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    addCustomValue("NewUserName", directoryGroup.getname());
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Get the identifier of the user to be removed from the parameters:
    Guid id = getParameters().getId();
    // Delete all the permissions of the user:
    for (permissions permission : DbFacade.getInstance().getPermissionDao().getAllDirectPermissionsForAdElement(id)) {
        PermissionsOperationsParameters tempVar = new PermissionsOperationsParameters(permission);
        tempVar.setShouldBeLogged(false);
        Backend.getInstance().runInternalAction(VdcActionType.RemovePermission, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    }
    // Delete the user itself:
    getDbUserDAO().remove(id);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // Get the identifier of the user to be removed from the parameters:
    Guid id = getParameters().getId();
    // TODO: This should be done without invoking the command to avoid the overhead.
    for (Permissions permission : DbFacade.getInstance().getPermissionDao().getAllDirectPermissionsForAdElement(id)) {
        PermissionsOperationsParameters tempVar = new PermissionsOperationsParameters(permission);
        tempVar.setShouldBeLogged(false);
        Backend.getInstance().runInternalAction(VdcActionType.RemovePermission, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    }
    // Delete the user itself:
    getDbUserDAO().remove(id);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Get the identifier of the user to be removed from the parameters:
    Guid id = getParameters().getId();
    // Check that we are not trying to remove the builting admin user:
    if (PredefinedUsers.ADMIN_USER.getId().equals(id)) {
        addCanDoActionMessage(VdcBllMessages.USER_CANNOT_REMOVE_ADMIN_USER);
        return false;
    }
    // Check that the current user isn't trying to remove himself:
    if (getCurrentUser().getId().equals(id)) {
        addCanDoActionMessage(VdcBllMessages.USER_CANNOT_REMOVE_HIMSELF);
        return false;
    }
    // Check that the user exists in the database:
    DbUser dbUser = getDbUserDAO().get(id);
    if (dbUser == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DB);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Get the identifier of the user to be removed:
    Guid id = getParameters().getId();
    // Check that we are not trying to remove the built-in admin user:
    if (PredefinedUsers.ADMIN_USER.getId().equals(id)) {
        addCanDoActionMessage(VdcBllMessages.USER_CANNOT_REMOVE_ADMIN_USER);
        return false;
    }
    // Check that the current user isn't trying to remove himself:
    if (getCurrentUser().getId().equals(id)) {
        addCanDoActionMessage(VdcBllMessages.USER_CANNOT_REMOVE_HIMSELF);
        return false;
    }
    // Check that the user exists in the database:
    DbUser dbUser = getDbUserDAO().get(id);
    if (dbUser == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DB);
        return false;
    }
    return true;
}
#end_block

#method_before
private void getAttachedTagsToSelectedUsers(TagListModel model) {
    ArrayList<Guid> userIds = new ArrayList<Guid>();
    ArrayList<Guid> grpIds = new ArrayList<Guid>();
    attachedTagsToEntities = new HashMap<Guid, Boolean>();
    allAttachedTags = new ArrayList<org.ovirt.engine.core.common.businessentities.tags>();
    selectedItemsCounter = 0;
    for (Object item : getSelectedItems()) {
        DbUser user = (DbUser) item;
        if (!user.isGroup()) {
            userIds.add(user.getId());
        } else {
            grpIds.add(user.getId());
        }
    }
    for (Guid userId : userIds) {
        AsyncDataProvider.getAttachedTagsToUser(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                UserListModel userListModel = (UserListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                userListModel.allAttachedTags.addAll((ArrayList<org.ovirt.engine.core.common.businessentities.tags>) returnValue);
                userListModel.selectedItemsCounter++;
                if (userListModel.selectedItemsCounter == userListModel.getSelectedItems().size()) {
                    postGetAttachedTags(userListModel, tagListModel);
                }
            }
        }), userId);
    }
    for (Guid grpId : grpIds) {
        AsyncDataProvider.getAttachedTagsToUserGroup(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                UserListModel userListModel = (UserListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                userListModel.allAttachedTags.addAll((ArrayList<org.ovirt.engine.core.common.businessentities.tags>) returnValue);
                userListModel.selectedItemsCounter++;
                if (userListModel.selectedItemsCounter == userListModel.getSelectedItems().size()) {
                    postGetAttachedTags(userListModel, tagListModel);
                }
            }
        }), grpId);
    }
}
#method_after
private void getAttachedTagsToSelectedUsers(TagListModel model) {
    ArrayList<Guid> userIds = new ArrayList<Guid>();
    ArrayList<Guid> grpIds = new ArrayList<Guid>();
    attachedTagsToEntities = new HashMap<Guid, Boolean>();
    allAttachedTags = new ArrayList<Tags>();
    selectedItemsCounter = 0;
    for (Object item : getSelectedItems()) {
        DbUser user = (DbUser) item;
        if (!user.isGroup()) {
            userIds.add(user.getId());
        } else {
            grpIds.add(user.getId());
        }
    }
    for (Guid userId : userIds) {
        AsyncDataProvider.getAttachedTagsToUser(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                UserListModel userListModel = (UserListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                userListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                userListModel.selectedItemsCounter++;
                if (userListModel.selectedItemsCounter == userListModel.getSelectedItems().size()) {
                    postGetAttachedTags(userListModel, tagListModel);
                }
            }
        }), userId);
    }
    for (Guid grpId : grpIds) {
        AsyncDataProvider.getAttachedTagsToUserGroup(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                UserListModel userListModel = (UserListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                userListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                userListModel.selectedItemsCounter++;
                if (userListModel.selectedItemsCounter == userListModel.getSelectedItems().size()) {
                    postGetAttachedTags(userListModel, tagListModel);
                }
            }
        }), grpId);
    }
}
#end_block

#method_before
private void postGetAttachedTags(UserListModel userListModel, TagListModel tagListModel) {
    if (userListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<org.ovirt.engine.core.common.businessentities.tags> attachedTags = Linq.distinct(userListModel.allAttachedTags, new TagsEqualityComparer());
        for (org.ovirt.engine.core.common.businessentities.tags a : attachedTags) {
            int count = 0;
            for (org.ovirt.engine.core.common.businessentities.tags b : allAttachedTags) {
                if (b.gettag_id().equals(a.gettag_id())) {
                    count++;
                }
            }
            userListModel.attachedTagsToEntities.put(a.gettag_id(), count == userListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(userListModel.attachedTagsToEntities);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(userListModel.getLastExecutedCommand().getName(), "OnAssignTags")) {
        userListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#method_after
private void postGetAttachedTags(UserListModel userListModel, TagListModel tagListModel) {
    if (userListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(userListModel.allAttachedTags, new TagsEqualityComparer());
        for (Tags a : attachedTags) {
            int count = 0;
            for (Tags b : allAttachedTags) {
                if (b.gettag_id().equals(a.gettag_id())) {
                    count++;
                }
            }
            userListModel.attachedTagsToEntities.put(a.gettag_id(), count == userListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(userListModel.attachedTagsToEntities);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(userListModel.getLastExecutedCommand().getName(), "OnAssignTags")) {
        userListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#end_block

#method_before
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> userIds = new ArrayList<Guid>();
    ArrayList<Guid> grpIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        DbUser user = (DbUser) item;
        if (user.isGroup()) {
            grpIds.add(user.getId());
        } else {
            userIds.add(user.getId());
        }
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<Guid>();
    ArrayList<Guid> tagsToDetach = new ArrayList<Guid>();
    if (model.getItems() != null && ((ArrayList<TagModel>) model.getItems()).size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<VdcActionParametersBase> usersToAttach = new ArrayList<VdcActionParametersBase>();
    ArrayList<VdcActionParametersBase> grpsToAttach = new ArrayList<VdcActionParametersBase>();
    for (Guid tag_id : tagsToAttach) {
        if (userIds.size() > 0) {
            usersToAttach.add(new AttachEntityToTagParameters(tag_id, userIds));
        }
        if (grpIds.size() > 0) {
            grpsToAttach.add(new AttachEntityToTagParameters(tag_id, grpIds));
        }
    }
    if (usersToAttach.size() > 0) {
        Frontend.RunMultipleAction(VdcActionType.AttachUserToTag, usersToAttach);
    }
    if (grpsToAttach.size() > 0) {
        Frontend.RunMultipleAction(VdcActionType.AttachUserGroupToTag, grpsToAttach);
    }
    ArrayList<VdcActionParametersBase> usersToDetach = new ArrayList<VdcActionParametersBase>();
    ArrayList<VdcActionParametersBase> grpsToDetach = new ArrayList<VdcActionParametersBase>();
    for (Guid tag_id : tagsToDetach) {
        if (userIds.size() > 0) {
            usersToDetach.add(new AttachEntityToTagParameters(tag_id, userIds));
        }
        if (grpIds.size() > 0) {
            grpsToDetach.add(new AttachEntityToTagParameters(tag_id, grpIds));
        }
    }
    if (usersToDetach.size() > 0) {
        Frontend.RunMultipleAction(VdcActionType.DetachUserFromTag, usersToDetach);
    }
    if (grpsToDetach.size() > 0) {
        Frontend.RunMultipleAction(VdcActionType.DetachUserGroupFromTag, grpsToDetach);
    }
    cancel();
}
#method_after
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> userIds = new ArrayList<Guid>();
    ArrayList<Guid> grpIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        DbUser user = (DbUser) item;
        if (user.isGroup()) {
            grpIds.add(user.getId());
        } else {
            userIds.add(user.getId());
        }
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<Guid>();
    ArrayList<Guid> tagsToDetach = new ArrayList<Guid>();
    if (model.getItems() != null && ((ArrayList<TagModel>) model.getItems()).size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<VdcActionParametersBase> usersToAttach = new ArrayList<VdcActionParametersBase>();
    ArrayList<VdcActionParametersBase> grpsToAttach = new ArrayList<VdcActionParametersBase>();
    for (Guid tag_id : tagsToAttach) {
        if (userIds.size() > 0) {
            usersToAttach.add(new AttachEntityToTagParameters(tag_id, userIds));
        }
        if (grpIds.size() > 0) {
            grpsToAttach.add(new AttachEntityToTagParameters(tag_id, grpIds));
        }
    }
    if (usersToAttach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.AttachUserToTag, usersToAttach);
    }
    if (grpsToAttach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.AttachUserGroupToTag, grpsToAttach);
    }
    ArrayList<VdcActionParametersBase> usersToDetach = new ArrayList<VdcActionParametersBase>();
    ArrayList<VdcActionParametersBase> grpsToDetach = new ArrayList<VdcActionParametersBase>();
    for (Guid tag_id : tagsToDetach) {
        if (userIds.size() > 0) {
            usersToDetach.add(new AttachEntityToTagParameters(tag_id, userIds));
        }
        if (grpIds.size() > 0) {
            grpsToDetach.add(new AttachEntityToTagParameters(tag_id, grpIds));
        }
    }
    if (usersToDetach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.DetachUserFromTag, usersToDetach);
    }
    if (grpsToDetach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.DetachUserGroupFromTag, grpsToDetach);
    }
    cancel();
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeUsersTitle());
    // $NON-NLS-1$
    model.setHashName("remove_user");
    model.setMessage(ConstantsManager.getInstance().getConstants().usersMsg());
    ArrayList<String> list = new ArrayList<String>();
    for (DbUser item : Linq.<DbUser>cast(getSelectedItems())) {
        list.add(item.getFirstName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeUsersTitle());
    // $NON-NLS-1$
    model.setHashName("remove_user");
    ArrayList<String> list = new ArrayList<String>();
    for (DbUser item : Linq.<DbUser>cast(getSelectedItems())) {
        list.add(item.getFirstName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.DBUser);
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#method_after
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.DBUser, isCaseSensitiveSearch());
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#end_block

#method_before
public void onAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null) {
        cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    for (Object item : model.getItems()) {
        EntityModel entityModel = (EntityModel) item;
        if (entityModel.getIsSelected()) {
            items.add((DbUser) entityModel.getEntity());
        }
    }
    ArrayList<VdcActionType> actionsList = new ArrayList<VdcActionType>(items.size());
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>(items.size());
    ArrayList<IFrontendActionAsyncCallback> callbacksList = new ArrayList<IFrontendActionAsyncCallback>(items.size());
    for (DbUser item : items) {
        if (item.isGroup()) {
            actionsList.add(VdcActionType.AddGroup);
        } else {
            actionsList.add(VdcActionType.AddUser);
        }
        DirectoryIdParameters parameters = new DirectoryIdParameters();
        parameters.setDirectory(item.getDomain());
        parameters.setId(item.getId());
        parametersList.add(parameters);
        callbacksList.add(null);
    }
    model.startProgress(null);
    IFrontendActionAsyncCallback lastCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    };
    if (callbacksList.size() > 0) {
        callbacksList.set(callbacksList.size() - 1, lastCallback);
    }
    Frontend.RunMultipleActions(actionsList, parametersList, callbacksList, lastCallback, model);
}
#method_after
public void onAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null) {
        cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    for (Object item : model.getItems()) {
        EntityModel entityModel = (EntityModel) item;
        if (entityModel.getIsSelected()) {
            items.add((DbUser) entityModel.getEntity());
        }
    }
    ArrayList<VdcActionType> actionsList = new ArrayList<VdcActionType>(items.size());
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>(items.size());
    ArrayList<IFrontendActionAsyncCallback> callbacksList = new ArrayList<IFrontendActionAsyncCallback>(items.size());
    for (DbUser item : items) {
        if (item.isGroup()) {
            actionsList.add(VdcActionType.AddGroup);
        } else {
            actionsList.add(VdcActionType.AddUser);
        }
        DirectoryIdParameters parameters = new DirectoryIdParameters();
        parameters.setDirectory(item.getDomain());
        parameters.setId(item.getId());
        parametersList.add(parameters);
        callbacksList.add(null);
    }
    model.startProgress(null);
    IFrontendActionAsyncCallback lastCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    };
    if (callbacksList.size() > 0) {
        callbacksList.set(callbacksList.size() - 1, lastCallback);
    }
    Frontend.getInstance().runMultipleActions(actionsList, parametersList, callbacksList, lastCallback, model);
}
#end_block

#method_before
public void onRemove() {
    ArrayList<DbUser> items = Linq.<DbUser>cast(getSelectedItems());
    ArrayList<VdcActionParametersBase> userPrms = new ArrayList<VdcActionParametersBase>();
    ArrayList<VdcActionParametersBase> groupPrms = new ArrayList<VdcActionParametersBase>();
    for (DbUser item : items) {
        if (!item.isGroup()) {
            userPrms.add(new IdParameters(item.getId()));
        } else {
            groupPrms.add(new IdParameters(item.getId()));
        }
    }
    if (userPrms.size() > 0) {
        Frontend.RunMultipleAction(VdcActionType.RemoveUser, userPrms);
    }
    if (groupPrms.size() > 0) {
        Frontend.RunMultipleAction(VdcActionType.RemoveGroup, groupPrms);
    }
    cancel();
}
#method_after
public void onRemove() {
    ArrayList<DbUser> items = Linq.<DbUser>cast(getSelectedItems());
    ArrayList<VdcActionParametersBase> userPrms = new ArrayList<VdcActionParametersBase>();
    ArrayList<VdcActionParametersBase> groupPrms = new ArrayList<VdcActionParametersBase>();
    for (DbUser item : items) {
        if (!item.isGroup()) {
            userPrms.add(new IdParameters(item.getId()));
        } else {
            groupPrms.add(new IdParameters(item.getId()));
        }
    }
    if (userPrms.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.RemoveUser, userPrms);
    }
    if (groupPrms.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.RemoveGroup, groupPrms);
    }
    cancel();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Get the name of the directory and the identifier of the user from
    // the parameters:
    String directory = getParameters().getDirectory();
    Guid id = getParameters().getId();
    // Check that the user is available in the directory (and save the
    // reference to avoid looking it up later when actually adding the
    // user to the database):
    directoryUser = (LdapUser) LdapFactory.getInstance(directory).RunAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(directory, id)).getReturnValue();
    if (directoryUser == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Populate information for the audit log:
    addCustomValue("NewUserName", directoryUser.getUserName());
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Get the name of the directory and the identifier of the user from the parameters:
    String directory = getParameters().getDirectory();
    Guid id = getParameters().getId();
    // Check that the user is available in the directory (and save the reference to avoid looking it up later when
    // actually adding the user to the database):
    directoryUser = (LdapUser) LdapFactory.getInstance(directory).runAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(directory, id)).getReturnValue();
    if (directoryUser == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Populate information for the audit log:
    addCustomValue("NewUserName", directoryUser.getUserName());
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    DbUserDAO dao = getDbUserDAO();
    // First check if the user is already in the database, if it is we
    // need to update, if not we need to insert:
    DbUser dbUser = dao.get(directoryUser.getUserId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        dao.save(dbUser);
    } else {
        Guid id = dbUser.getId();
        dbUser = new DbUser(directoryUser);
        dbUser.setId(id);
        dao.update(dbUser);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    DbUserDAO dao = getDbUserDAO();
    // First check if the user is already in the database, if it is we need to update, if not we need to insert:
    DbUser dbUser = dao.get(directoryUser.getUserId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        dao.save(dbUser);
    } else {
        Guid id = dbUser.getId();
        dbUser = new DbUser(directoryUser);
        dbUser.setId(id);
        dao.update(dbUser);
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Get the identifier of the group from the parameters:
    Guid id = getParameters().getId();
    // Remove the permissions of the group:
    for (permissions permission : getPermissionDAO().getAllDirectPermissionsForAdElement(id)) {
        PermissionsOperationsParameters param = new PermissionsOperationsParameters(permission);
        param.setSessionId(getParameters().getSessionId());
        getBackend().runInternalAction(VdcActionType.RemovePermission, param, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    }
    // Remove the group itself:
    getAdGroupDAO().remove(getAdGroup().getid());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // Get the identifier of the group from the parameters:
    Guid id = getParameters().getId();
    // TODO: This should be done without invoking the command to avoid the overhead.
    for (Permissions permission : getPermissionDAO().getAllDirectPermissionsForAdElement(id)) {
        PermissionsOperationsParameters param = new PermissionsOperationsParameters(permission);
        param.setSessionId(getParameters().getSessionId());
        getBackend().runInternalAction(VdcActionType.RemovePermission, param, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    }
    // Remove the group itself:
    getAdGroupDAO().remove(getAdGroup().getid());
    setSucceeded(true);
}
#end_block

#method_before
@Override
public Response add(Group group) {
    validateParameters(group, "name");
    if (!isNameContainsDomain(group)) {
        validateParameters(group, "domain.id|name");
    }
    String domain = getDomain(group);
    LdapGroup directoryGroup = getEntity(LdapGroup.class, SearchType.AdGroup, getDirectoryGroupSearchPattern(group.getName(), domain));
    if (directoryGroup == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such group: " + group.getName() + " in domain " + domain).build();
    }
    DirectoryIdParameters addGroup = new DirectoryIdParameters();
    addGroup.setDirectory(directoryGroup.getdomain());
    addGroup.setId(directoryGroup.getid());
    return performCreate(VdcActionType.AddGroup, addGroup, new GroupIdResolver(directoryGroup.getid()), BaseResource.class);
}
#method_after
@Override
public Response add(Group group) {
    validateParameters(group, "name");
    if (!isNameContainsDomain(group)) {
        validateParameters(group, "domain.id|name");
    }
    String directoryName = getDirectoryName(group);
    LdapGroup directoryGroup = findDirectoryGroup(directoryName, group);
    if (directoryGroup == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such group: " + group.getName() + " in directory " + directoryName).build();
    }
    DirectoryIdParameters addGroup = new DirectoryIdParameters();
    addGroup.setDirectory(directoryName);
    addGroup.setId(directoryGroup.getid());
    return performCreate(VdcActionType.AddGroup, addGroup, new GroupIdResolver(directoryGroup.getid()), BaseResource.class);
}
#end_block

#method_before
@Override
public void init(FilterConfig filterConfig) throws ServletException {
// Nothing.
}
#method_after
@Override
public void init(FilterConfig filterConfig) throws ServletException {
}
#end_block

#method_before
@Override
public void destroy() {
// Nothing.
}
#method_after
@Override
public void destroy() {
}
#end_block

#method_before
private void doFilter(HttpServletRequest req, HttpServletResponse rsp, FilterChain chain) throws IOException, ServletException {
    // In order to perform the automatic login the principal needs to be populated, if it isn't then we just forward
    // the request to the next filter:
    Principal principal = req.getUserPrincipal();
    if (principal == null) {
        chain.doFilter(req, rsp);
        return;
    }
    // If the user is already logged in then this filter doesn't need to do anything else:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(req.getSession().getId(), false);
    if (dbUser != null) {
        chain.doFilter(req, rsp);
        return;
    }
    // Extract the login name and the authentication profile name from the principal:
    String principalName = principal.getName();
    int index = principalName.lastIndexOf('@');
    if (index == -1) {
        log.error("Can't login user because the principal name \"{}\" doesn't contain the name of the authentication " + "profile.", principalName);
        rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        return;
    }
    String loginName = principalName.substring(0, index);
    String profileName = principalName.substring(index + 1);
    // Check that the authentication profile exists:
    AuthenticationProfile profile = AuthenticationProfileManager.getInstance().getProfile(profileName);
    if (profile == null) {
        log.error("Can't login user \"{}\" because authentication profile \"{}\" doesn't exist.", loginName, profileName);
        rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        return;
    }
    // Check that the user exists in the directory associated to the authentication profile:
    Directory directory = profile.getDirectory();
    DirectoryUser directoryUser = directory.findUser(loginName);
    if (directoryUser == null) {
        log.info("Can't login user \"{}\" with authentication profile \"{}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
        rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        return;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    DbUserDAO dbUserDao = DbFacade.getInstance().getDbUserDao();
    dbUser = dbUserDao.getByExternalId(directory.getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        dbUserDao.save(dbUser);
    }
    // Check if the user has permission to log in:
    PermissionDAO permissionDao = DbFacade.getInstance().getPermissionDao();
    Guid permissionId = permissionDao.getEntityPermissionsForUserAndGroups(dbUser.getId(), dbUser.getGroupIds(), VdcActionType.LoginUser.getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true);
    if (permissionId == null) {
        log.info("Can't login user \"{}\" with authentication profile \"{}\" because the user doesn't have the " + "required permission.", loginName, profileName);
        rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        return;
    }
    // Retrieve the MLA admin status of the user, this may be redundant in some use-cases, but looking forward to
    // single sign on we will want this informatin:
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    dbUser.setAdmin(isAdmin);
    // Attach the user to the session:
    SessionDataContainer.getInstance().setUser(req.getSession().getId(), dbUser);
    // Forward the request to the next filter in the chain:
    chain.doFilter(req, rsp);
}
#method_after
private void doFilter(HttpServletRequest req, HttpServletResponse rsp, FilterChain chain) throws IOException, ServletException {
    // In order to perform the automatic login the principal needs to be populated, if it isn't then we just forward
    // the request to the next filter:
    Principal principal = req.getUserPrincipal();
    if (principal == null) {
        chain.doFilter(req, rsp);
        return;
    }
    // If the user is already logged in then this filter doesn't need to do anything else:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(req.getSession().getId(), false);
    if (dbUser != null) {
        chain.doFilter(req, rsp);
        return;
    }
    // Extract the login name and the authentication profile name from the principal:
    String principalName = principal.getName();
    int index = principalName.lastIndexOf('@');
    if (index == -1) {
        log.error("Can't login user because the principal name \"{}\" doesn't contain the name of the authentication " + "profile.", principalName);
        rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        return;
    }
    String loginName = principalName.substring(0, index);
    String profileName = principalName.substring(index + 1);
    // Check that the authentication profile exists:
    AuthenticationProfile profile = AuthenticationProfileManager.getInstance().getProfile(profileName);
    if (profile == null) {
        log.error("Can't login user \"{}\" because authentication profile \"{}\" doesn't exist.", loginName, profileName);
        rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        return;
    }
    // Check that the user exists in the directory associated to the authentication profile:
    Directory directory = profile.getDirectory();
    if (directory == null) {
        log.info("Can't login user \"{}\" with authentication profile \"{}\" because the directory doesn't exist.", profileName);
        rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        return;
    }
    DirectoryUser directoryUser = directory.findUser(loginName);
    if (directoryUser == null) {
        log.info("Can't login user \"{}\" with authentication profile \"{}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
        rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        return;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    DbUserDAO dbUserDao = DbFacade.getInstance().getDbUserDao();
    dbUser = dbUserDao.getByExternalId(directory.getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        dbUserDao.save(dbUser);
    }
    // Check if the user has permission to log in:
    PermissionDAO permissionDao = DbFacade.getInstance().getPermissionDao();
    Guid permissionId = permissionDao.getEntityPermissionsForUserAndGroups(dbUser.getId(), dbUser.getGroupIds(), VdcActionType.LoginUser.getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true);
    if (permissionId == null) {
        log.info("Can't login user \"{}\" with authentication profile \"{}\" because the user doesn't have the " + "required permission.", loginName, profileName);
        rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        return;
    }
    // Retrieve the MLA admin status of the user, this may be redundant in some use-cases, but looking forward to
    // single sign on we will want this information:
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    dbUser.setAdmin(isAdmin);
    // Attach the user to the session:
    SessionDataContainer.getInstance().setUser(req.getSession().getId(), dbUser);
    // Forward the request to the next filter in the chain:
    chain.doFilter(req, rsp);
}
#end_block

#method_before
@Override
public Directory create(File file, Configuration config) {
    // Get the name of the directory:
    String name = config.getInheritedString(NAME_PARAMETER);
    if (name == null) {
        log.error("The configuration file \"{}\" doesn't contain the name of the directory.", file.getAbsolutePath());
        return null;
    }
    // We are good, create the directory:
    return new InternalDirectory(name);
}
#method_after
@Override
public Directory create(Configuration config) throws ConfigurationException {
    // Get the name of the directory:
    String name = config.getInheritedString(NAME_PARAMETER);
    if (name == null) {
        throw new ConfigurationException("The configuration file \"" + config.getFile().getAbsolutePath() + "\" doesn't contain the name of " + "the directory.");
    }
    // We are good, create the directory:
    return new InternalDirectory(name);
}
#end_block

#method_before
@Override
public boolean authenticate(String name, char[] password) {
    String adminName = Config.<String>GetValue(ConfigValues.AdminUser);
    String adminPassword = Config.<String>GetValue(ConfigValues.AdminPassword);
    return ObjectUtils.equals(name, adminName) && Arrays.equals(password, adminPassword.toCharArray());
}
#method_after
@Override
public AuthenticationResult<?> authenticate(String user, String password) {
    String adminName = Config.<String>getValue(ConfigValues.AdminUser);
    String adminPassword = Config.<String>getValue(ConfigValues.AdminPassword);
    return new BooleanAuthenticationResult(ObjectUtils.equals(user, adminName) && ObjectUtils.equals(password, adminPassword));
}
#end_block

#method_before
@Override
public Authenticator create(File file, Configuration config) {
    // Get the name of the authenticator:
    String name = config.getInheritedString(NAME_PARAMETER);
    if (name == null) {
        log.error("The configuration file \"{}\" doesn't contain the name of the authenticator.", file.getAbsolutePath());
        return null;
    }
    // We are good, create the authenticator:
    return new InternalAuthenticator(name);
}
#method_after
@Override
public Authenticator create(Configuration config) throws ConfigurationException {
    return new InternalAuthenticator();
}
#end_block

#method_before
public String getGroupIds() {
    List<ExternalId> ids = new ArrayList<ExternalId>(mGroups.size());
    for (LdapGroup group : mGroups.values()) {
        ExternalId id = group.getid();
        if (id != null) {
            ids.add(id);
        }
    }
    StringBuilder buffer = new StringBuilder();
    for (int i = 0; i < ids.size(); i++) {
        if (i > 0) {
            buffer.append(',');
        }
        ExternalId id = ids.get(i);
        buffer.append(id);
    }
    return buffer.toString();
}
#method_after
public String getGroupIds() {
    StringBuilder sb = new StringBuilder();
    boolean first = true;
    for (LdapGroup group : mGroups.values()) {
        if (first) {
            first = false;
        } else {
            sb.append(",");
        }
        sb.append(group.getid());
    }
    return sb.toString();
}
#end_block

#method_before
@Override
protected void syncSearch() {
    // allow only a single user lookup at a time
    if ((Boolean) getSearchInProgress().getEntity()) {
        return;
    }
    getSearchInProgress().setEntity(true);
    super.syncSearch();
    // var exclude = ExcludeItems != null ? ExcludeItems.Cast<DbUser>() : new List<DbUser>();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            setusers(new ArrayList<EntityModel>());
            addUsersToModel(queryReturnValue, getExcludeUsers());
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findUsers(// $NON-NLS-1$
    "allnames=" + // $NON-NLS-1$
    (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
    _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            HashSet<Guid> excludeUsers = new HashSet<Guid>();
            if (adElementListModel.getExcludeItems() != null) {
                for (Object item : adElementListModel.getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getId());
                }
            }
            adElementListModel.setgroups(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                LdapGroup a = (LdapGroup) item;
                if (!excludeUsers.contains(a.getid())) {
                    DbUser tempVar3 = new DbUser();
                    tempVar3.setExternalId(a.getid());
                    tempVar3.setFirstName(a.getname());
                    // $NON-NLS-1$
                    tempVar3.setLastName("");
                    // $NON-NLS-1$
                    tempVar3.setLoginName("");
                    tempVar3.setDomain(a.getdomain());
                    DbUser user = tempVar3;
                    EntityModel tempVar4 = new EntityModel();
                    tempVar4.setEntity(user);
                    adElementListModel.getgroups().add(tempVar4);
                }
            }
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findGroups(// $NON-NLS-1$ //$NON-NLS-2$
    "name=" + (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
}
#method_after
@Override
protected void syncSearch() {
    // allow only a single user lookup at a time
    if ((Boolean) getSearchInProgress().getEntity()) {
        return;
    }
    getSearchInProgress().setEntity(true);
    super.syncSearch();
    // var exclude = ExcludeItems != null ? ExcludeItems.Cast<DbUser>() : new List<DbUser>();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            setusers(new ArrayList<EntityModel>());
            addUsersToModel(queryReturnValue, getExcludeUsers());
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findUsers(// $NON-NLS-1$
    "allnames=" + // $NON-NLS-1$
    (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
    _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            HashSet<ExternalId> excludeUsers = new HashSet<ExternalId>();
            if (adElementListModel.getExcludeItems() != null) {
                for (Object item : adElementListModel.getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getExternalId());
                }
            }
            adElementListModel.setgroups(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                LdapGroup a = (LdapGroup) item;
                if (!excludeUsers.contains(a.getid())) {
                    DbUser tempVar3 = new DbUser();
                    tempVar3.setExternalId(a.getid());
                    tempVar3.setFirstName(a.getname());
                    // $NON-NLS-1$
                    tempVar3.setLastName("");
                    // $NON-NLS-1$
                    tempVar3.setLoginName("");
                    tempVar3.setDomain(a.getdomain());
                    DbUser user = tempVar3;
                    EntityModel tempVar4 = new EntityModel();
                    tempVar4.setEntity(user);
                    adElementListModel.getgroups().add(tempVar4);
                }
            }
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findGroups(// $NON-NLS-1$ //$NON-NLS-2$
    "name=" + (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
}
#end_block

#method_before
protected void addUsersToModel(VdcQueryReturnValue returnValue, Set<Guid> excludeUsers) {
    for (IVdcQueryable item : (ArrayList<IVdcQueryable>) returnValue.getReturnValue()) {
        LdapUser a = (LdapUser) item;
        if (!excludeUsers.contains(a.getUserId())) {
            EntityModel tempVar2 = new EntityModel();
            tempVar2.setEntity(new DbUser(a));
            getusers().add(tempVar2);
        }
    }
}
#method_after
protected void addUsersToModel(VdcQueryReturnValue returnValue, Set<ExternalId> excludeUsers) {
    for (IVdcQueryable item : (ArrayList<IVdcQueryable>) returnValue.getReturnValue()) {
        LdapUser a = (LdapUser) item;
        if (!excludeUsers.contains(a.getUserId())) {
            EntityModel tempVar2 = new EntityModel();
            tempVar2.setEntity(new DbUser(a));
            getusers().add(tempVar2);
        }
    }
}
#end_block

#method_before
protected Set<Guid> getExcludeUsers() {
    Set<Guid> excludeUsers = new HashSet<Guid>();
    if (getExcludeItems() != null) {
        for (Object item : getExcludeItems()) {
            DbUser a = (DbUser) item;
            excludeUsers.add(a.getId());
        }
    }
    return excludeUsers;
}
#method_after
protected Set<ExternalId> getExcludeUsers() {
    Set<ExternalId> excludeUsers = new HashSet<ExternalId>();
    if (getExcludeItems() != null) {
        for (Object item : getExcludeItems()) {
            DbUser a = (DbUser) item;
            excludeUsers.add(a.getExternalId());
        }
    }
    return excludeUsers;
}
#end_block

#method_before
protected void findGroups(String searchString, AsyncQuery query) {
    // $NON-NLS-1$ //$NON-NLS-2$
    Frontend.RunQuery(VdcQueryType.Search, new SearchParameters("ADGROUP@" + getDomain().getSelectedItem() + ": " + searchString, SearchType.AdGroup), query);
}
#method_after
protected void findGroups(String searchString, AsyncQuery query) {
    // $NON-NLS-1$ //$NON-NLS-2$
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("ADGROUP@" + getDomain().getSelectedItem() + ": " + searchString, SearchType.AdGroup), query);
}
#end_block

#method_before
protected void findUsers(String searchString, AsyncQuery query) {
    // $NON-NLS-1$ //$NON-NLS-2$
    Frontend.RunQuery(VdcQueryType.Search, new SearchParameters("ADUSER@" + getDomain().getSelectedItem() + ": " + searchString, SearchType.AdUser), query);
}
#method_after
protected void findUsers(String searchString, AsyncQuery query) {
    // $NON-NLS-1$ //$NON-NLS-2$
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("ADUSER@" + getDomain().getSelectedItem() + ": " + searchString, SearchType.AdUser), query);
}
#end_block

#method_before
private boolean handleQueryError(VdcQueryReturnValue returnValue, AdElementListModel model) {
    model.setMessage(null);
    if (!returnValue.getSucceeded()) {
        model.setMessage(Frontend.getAppErrorsTranslator().TranslateErrorTextSingle(returnValue.getExceptionString()));
        getSearchInProgress().setEntity(false);
        return true;
    }
    return false;
}
#method_after
private boolean handleQueryError(VdcQueryReturnValue returnValue, AdElementListModel model) {
    model.setMessage(null);
    if (!returnValue.getSucceeded()) {
        model.setMessage(Frontend.getInstance().getAppErrorsTranslator().translateErrorTextSingle(returnValue.getExceptionString()));
        getSearchInProgress().setEntity(false);
        return true;
    }
    return false;
}
#end_block

#method_before
protected void verifyModel(Group model, int index) {
    assertEquals(GUIDS[index].toString(), model.getId());
    assertArrayEquals(EXTERNAL_IDS[index].getBytes(), model.getExternalId());
    assertEquals(NAMES[index], model.getName());
    assertNotNull(model.getDomain());
    verifyLinks(model);
}
#method_after
protected void verifyModel(Group model, int index) {
    assertEquals(GUIDS[index].toString(), model.getId());
    assertEquals(EXTERNAL_IDS[index].toHex(), model.getExternalId());
    assertEquals(NAMES[index], model.getName());
    assertNotNull(model.getDomain());
    verifyLinks(model);
}
#end_block

#method_before
protected <E> void setUpGetEntityExpectations(VdcQueryType query, Class<? extends VdcQueryParametersBase> clz, String[] names, Object[] values, E entity) throws Exception {
    VdcQueryReturnValue queryResult = control.createMock(VdcQueryReturnValue.class);
    expect(backend.RunQuery(eq(query), eqQueryParams(clz, addSession(names), addSession(values)))).andReturn(queryResult);
    expect(queryResult.getSucceeded()).andReturn(true).anyTimes();
    expect(queryResult.getReturnValue()).andReturn(entity).anyTimes();
}
#method_after
protected <E> void setUpGetEntityExpectations(VdcQueryType query, Class<? extends VdcQueryParametersBase> clz, String[] names, Object[] values, E entity) throws Exception {
    VdcQueryReturnValue queryResult = control.createMock(VdcQueryReturnValue.class);
    expect(backend.runQuery(eq(query), eqQueryParams(clz, addSession(names), addSession(values)))).andReturn(queryResult);
    expect(queryResult.getSucceeded()).andReturn(true).anyTimes();
    expect(queryResult.getReturnValue()).andReturn(entity).anyTimes();
}
#end_block

#method_before
protected <E> void setUpGetEntityExpectations(String query, SearchType type, E entity) throws Exception {
    VdcQueryReturnValue queryResult = control.createMock(VdcQueryReturnValue.class);
    SearchParameters params = new SearchParameters(query, type);
    expect(backend.RunQuery(eq(VdcQueryType.Search), eqSearchParams(params))).andReturn(queryResult);
    expect(queryResult.getSucceeded()).andReturn(true).anyTimes();
    List<E> entities = new ArrayList<E>();
    entities.add(entity);
    expect(queryResult.getReturnValue()).andReturn(entities).anyTimes();
}
#method_after
protected <E> void setUpGetEntityExpectations(String query, SearchType type, E entity) throws Exception {
    VdcQueryReturnValue queryResult = control.createMock(VdcQueryReturnValue.class);
    SearchParameters params = new SearchParameters(query, type);
    expect(backend.runQuery(eq(VdcQueryType.Search), eqSearchParams(params))).andReturn(queryResult);
    expect(queryResult.getSucceeded()).andReturn(true).anyTimes();
    List<E> entities = new ArrayList<E>();
    entities.add(entity);
    expect(queryResult.getReturnValue()).andReturn(entities).anyTimes();
}
#end_block

#method_before
protected void setUpEntityQueryExpectations(VdcQueryType query, Class<? extends VdcQueryParametersBase> queryClass, String[] queryNames, Object[] queryValues, Object queryReturn, Object failure) {
    VdcQueryReturnValue queryResult = control.createMock(VdcQueryReturnValue.class);
    expect(queryResult.getSucceeded()).andReturn(failure == null).anyTimes();
    if (failure == null) {
        expect(queryResult.getReturnValue()).andReturn(queryReturn).anyTimes();
    } else {
        if (failure instanceof String) {
            expect(queryResult.getExceptionString()).andReturn((String) failure).anyTimes();
            setUpL10nExpectations((String) failure);
        } else if (failure instanceof Exception) {
            expect(queryResult.getExceptionString()).andThrow((Exception) failure).anyTimes();
        }
    }
    if (queryClass == GetPermissionsForObjectParameters.class) {
        expect(backend.RunQuery(eq(query), eqQueryParams(queryClass, addSession(queryNames), addSession(queryValues)))).andReturn(queryResult).anyTimes();
    } else {
        expect(backend.RunQuery(eq(query), eqQueryParams(queryClass, addSession(queryNames), addSession(queryValues)))).andReturn(queryResult);
    }
}
#method_after
protected void setUpEntityQueryExpectations(VdcQueryType query, Class<? extends VdcQueryParametersBase> queryClass, String[] queryNames, Object[] queryValues, Object queryReturn, Object failure) {
    VdcQueryReturnValue queryResult = control.createMock(VdcQueryReturnValue.class);
    expect(queryResult.getSucceeded()).andReturn(failure == null).anyTimes();
    if (failure == null) {
        expect(queryResult.getReturnValue()).andReturn(queryReturn).anyTimes();
    } else {
        if (failure instanceof String) {
            expect(queryResult.getExceptionString()).andReturn((String) failure).anyTimes();
            setUpL10nExpectations((String) failure);
        } else if (failure instanceof Exception) {
            expect(queryResult.getExceptionString()).andThrow((Exception) failure).anyTimes();
        }
    }
    if (queryClass == GetPermissionsForObjectParameters.class) {
        expect(backend.runQuery(eq(query), eqQueryParams(queryClass, addSession(queryNames), addSession(queryValues)))).andReturn(queryResult).anyTimes();
    } else {
        expect(backend.runQuery(eq(query), eqQueryParams(queryClass, addSession(queryNames), addSession(queryValues)))).andReturn(queryResult);
    }
}
#end_block

#method_before
protected UriInfo setUpActionExpectations(VdcActionType task, Class<? extends VdcActionParametersBase> clz, String[] names, Object[] values, boolean canDo, boolean success, Object taskReturn, ArrayList<Guid> asyncTasks, ArrayList<AsyncTaskStatus> asyncStatuses, Guid jobId, JobExecutionStatus jobStatus, String baseUri, boolean replay, String errorMessage) {
    VdcReturnValueBase result = control.createMock(VdcReturnValueBase.class);
    expect(result.getCanDoAction()).andReturn(canDo).anyTimes();
    if (canDo) {
        expect(result.getSucceeded()).andReturn(success).anyTimes();
        if (success) {
            if (taskReturn != null) {
                expect(result.getActionReturnValue()).andReturn(taskReturn).anyTimes();
            }
        } else {
            expect(result.getExecuteFailedMessages()).andReturn(asList(FAILURE)).anyTimes();
            setUpL10nExpectations(asList(FAILURE));
        }
    } else {
        expect(result.getCanDoActionMessages()).andReturn(asList(errorMessage)).anyTimes();
        setUpL10nExpectations(asList(errorMessage));
    }
    expect(backend.RunAction(eq(task), eqActionParams(clz, addSession(names), addSession(values)))).andReturn(result);
    VdcQueryReturnValue monitorResult = control.createMock(VdcQueryReturnValue.class);
    expect(monitorResult.getSucceeded()).andReturn(success).anyTimes();
    expect(result.getHasAsyncTasks()).andReturn(asyncTasks != null || jobId != null).anyTimes();
    // simulate polling on async task's statuses, and/or job status.
    setAsyncTaskStatusExpectations(asyncTasks, asyncStatuses, monitorResult, result);
    setJobStatusExpectations(jobId, jobStatus, monitorResult, result);
    UriInfo uriInfo = setUpBasicUriExpectations();
    if (baseUri != null) {
        expect(uriInfo.getPath()).andReturn(baseUri).anyTimes();
    }
    if (replay) {
        control.replay();
    }
    return uriInfo;
}
#method_after
protected UriInfo setUpActionExpectations(VdcActionType task, Class<? extends VdcActionParametersBase> clz, String[] names, Object[] values, boolean canDo, boolean success, Object taskReturn, ArrayList<Guid> asyncTasks, ArrayList<AsyncTaskStatus> asyncStatuses, Guid jobId, JobExecutionStatus jobStatus, String baseUri, boolean replay, String errorMessage) {
    VdcReturnValueBase result = control.createMock(VdcReturnValueBase.class);
    expect(result.getCanDoAction()).andReturn(canDo).anyTimes();
    if (canDo) {
        expect(result.getSucceeded()).andReturn(success).anyTimes();
        if (success) {
            if (taskReturn != null) {
                expect(result.getActionReturnValue()).andReturn(taskReturn).anyTimes();
            }
        } else {
            expect(result.getExecuteFailedMessages()).andReturn(asList(FAILURE)).anyTimes();
            setUpL10nExpectations(asList(FAILURE));
        }
    } else {
        expect(result.getCanDoActionMessages()).andReturn(asList(errorMessage)).anyTimes();
        setUpL10nExpectations(asList(errorMessage));
    }
    expect(backend.runAction(eq(task), eqActionParams(clz, addSession(names), addSession(values)))).andReturn(result);
    VdcQueryReturnValue monitorResult = control.createMock(VdcQueryReturnValue.class);
    expect(monitorResult.getSucceeded()).andReturn(success).anyTimes();
    expect(result.getHasAsyncTasks()).andReturn(asyncTasks != null || jobId != null).anyTimes();
    // simulate polling on async task's statuses, and/or job status.
    setAsyncTaskStatusExpectations(asyncTasks, asyncStatuses, monitorResult, result);
    setJobStatusExpectations(jobId, jobStatus, monitorResult, result);
    UriInfo uriInfo = setUpBasicUriExpectations();
    if (baseUri != null) {
        expect(uriInfo.getPath()).andReturn(baseUri).anyTimes();
    }
    if (replay) {
        control.replay();
    }
    return uriInfo;
}
#end_block

#method_before
protected void verifyLinks(BaseResource model) {
    assertNotNull(model.getHref());
    assertTrue(model.getHref().startsWith("/api"));
    for (Link link : model.getLinks()) {
        assertTrue(link.getHref().startsWith("/api"));
    }
}
#method_after
protected void verifyLinks(BaseResource model) {
    assertNotNull(model.getHref());
    assertTrue(model.getHref().startsWith("/ovirt-engine/api"));
    for (Link link : model.getLinks()) {
        assertTrue(link.getHref().startsWith("/ovirt-engine/api"));
    }
}
#end_block

#method_before
private void setAsyncTaskStatusExpectations(ArrayList<Guid> asyncTasks, ArrayList<AsyncTaskStatus> asyncStatuses, VdcQueryReturnValue monitorResult, VdcReturnValueBase result) {
    if (asyncTasks != null) {
        expect(result.getVdsmTaskIdList()).andReturn(asyncTasks).anyTimes();
        expect(monitorResult.getReturnValue()).andReturn(asyncStatuses).anyTimes();
        expect(backend.RunQuery(eq(VdcQueryType.GetTasksStatusesByTasksIDs), eqQueryParams(GetTasksStatusesByTasksIDsParameters.class, addSession(new String[] {}), addSession(new Object[] {})))).andReturn(monitorResult);
    }
}
#method_after
private void setAsyncTaskStatusExpectations(ArrayList<Guid> asyncTasks, ArrayList<AsyncTaskStatus> asyncStatuses, VdcQueryReturnValue monitorResult, VdcReturnValueBase result) {
    if (asyncTasks != null) {
        expect(result.getVdsmTaskIdList()).andReturn(asyncTasks).anyTimes();
        expect(monitorResult.getReturnValue()).andReturn(asyncStatuses).anyTimes();
        expect(backend.runQuery(eq(VdcQueryType.GetTasksStatusesByTasksIDs), eqQueryParams(GetTasksStatusesByTasksIDsParameters.class, addSession(new String[] {}), addSession(new Object[] {})))).andReturn(monitorResult);
    }
}
#end_block

#method_before
private void setJobStatusExpectations(Guid jobId, JobExecutionStatus jobStatus, VdcQueryReturnValue monitorResult, VdcReturnValueBase result) {
    expect(result.getJobId()).andReturn(jobId).anyTimes();
    if (jobId != null) {
        Job jobMock = control.createMock(org.ovirt.engine.core.common.job.Job.class);
        expect(jobMock.getStatus()).andReturn(jobStatus);
        expect(monitorResult.getReturnValue()).andReturn(jobMock).anyTimes();
        expect(backend.RunQuery(eq(VdcQueryType.GetJobByJobId), eqQueryParams(IdQueryParameters.class, addSession(new String[] { "Id" }), addSession(new Object[] { jobId })))).andReturn(monitorResult);
    }
}
#method_after
private void setJobStatusExpectations(Guid jobId, JobExecutionStatus jobStatus, VdcQueryReturnValue monitorResult, VdcReturnValueBase result) {
    expect(result.getJobId()).andReturn(jobId).anyTimes();
    if (jobId != null) {
        Job jobMock = control.createMock(org.ovirt.engine.core.common.job.Job.class);
        expect(jobMock.getStatus()).andReturn(jobStatus);
        expect(monitorResult.getReturnValue()).andReturn(jobMock).anyTimes();
        expect(backend.runQuery(eq(VdcQueryType.GetJobByJobId), eqQueryParams(IdQueryParameters.class, addSession(new String[] { "Id" }), addSession(new Object[] { jobId })))).andReturn(monitorResult);
    }
}
#end_block

#method_before
public static List<String> getDomainsList(boolean filterInternalDomain) {
    String[] domains = Config.<String>GetValue(ConfigValues.DomainName).split("[,]", -1);
    List<String> results = new ArrayList<String>();
    for (String domain : domains) {
        String trimmedDomain = domain.trim();
        if (!trimmedDomain.isEmpty()) {
            results.add(trimmedDomain);
        }
    }
    if (!filterInternalDomain) {
        results.add(Config.<String>GetValue(ConfigValues.AdminDomain).trim());
    }
    return results;
}
#method_after
public static List<String> getDomainsList(boolean filterInternalDomain) {
    String[] domains = Config.<String>getValue(ConfigValues.DomainName).split("[,]", -1);
    List<String> results = new ArrayList<String>();
    for (String domain : domains) {
        String trimmedDomain = domain.trim();
        if (!trimmedDomain.isEmpty()) {
            results.add(trimmedDomain);
        }
    }
    if (!filterInternalDomain) {
        results.add(Config.<String>getValue(ConfigValues.AdminDomain).trim());
    }
    return results;
}
#end_block

#method_before
public static List<GroupSearchResult> performGroupQuery(String loginName, String password, String domainName, LdapQueryData queryData) {
    LdapCredentials ldapCredentials = new LdapCredentials(LdapBrokerUtils.modifyLoginNameForKerberos(loginName, domainName), password);
    DirectorySearcher directorySearcher = new DirectorySearcher(ldapCredentials);
    try {
        List<GroupSearchResult> searchResults = (List<GroupSearchResult>) directorySearcher.FindAll(queryData);
        return searchResults;
    } catch (DomainNotConfiguredException ex) {
        log.errorFormat("User {0} from domain {1} is a member of a group from {2} which is not configured. Please use the manage domains utility if you wish to add this domain.", loginName, domainName, queryData.getDomain());
        return null;
    }
}
#method_after
public static List<GroupSearchResult> performGroupQuery(String loginName, String password, String domainName, LdapQueryData queryData) {
    LdapCredentials ldapCredentials = new LdapCredentials(LdapBrokerUtils.modifyLoginNameForKerberos(loginName, domainName), password);
    DirectorySearcher directorySearcher = new DirectorySearcher(ldapCredentials);
    try {
        List<GroupSearchResult> searchResults = (List<GroupSearchResult>) directorySearcher.findAll(queryData);
        return searchResults;
    } catch (DomainNotConfiguredException ex) {
        log.errorFormat("User {0} from domain {1} is a member of a group from {2} which is not configured. Please use the manage domains utility if you wish to add this domain.", loginName, domainName, queryData.getDomain());
        return null;
    }
}
#end_block

#method_before
public static void addLdapConfigValues(Hashtable<String, String> env) {
    env.put("com.sun.jndi.ldap.read.timeout", Long.toString(Config.<Integer>GetValue(ConfigValues.LDAPQueryTimeout) * 1000));
    env.put("com.sun.jndi.ldap.connect.timeout", Long.toString(Config.<Integer>GetValue(ConfigValues.LDAPConnectTimeout) * 1000));
}
#method_after
public static void addLdapConfigValues(Hashtable<String, String> env) {
    env.put("com.sun.jndi.ldap.read.timeout", Long.toString(Config.<Integer>getValue(ConfigValues.LDAPQueryTimeout) * 1000));
    env.put("com.sun.jndi.ldap.connect.timeout", Long.toString(Config.<Integer>getValue(ConfigValues.LDAPConnectTimeout) * 1000));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    permissions perm = getParameters().getPermission();
    if (perm == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_PERMISSION_NOT_SENT);
        return false;
    }
    Role role = getRoleDao().get(perm.getrole_id());
    Guid adElementId = perm.getad_element_id();
    if (role == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_INVALID_ROLE_ID);
        return false;
    }
    if (perm.getObjectType() == null || getVdcObjectName() == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_INVALID_OBJECT_ID);
        return false;
    }
    // give permission
    if (getParameters().getUser() == null && getParameters().getGroup() == null && getDbUserDAO().get(adElementId) == null && getAdGroupDAO().get(adElementId) == null) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.USER_MUST_EXIST_IN_DB.toString());
        return false;
    }
    // only system super user can give permissions with admin roles
    if (!isSystemSuperUser() && role.getType() == RoleType.ADMIN) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_ONLY_SYSTEM_SUPER_USER_CAN_GIVE_ADMIN_ROLES);
        return false;
    }
    // don't allow adding permissions to vms from pool externally
    if (!isInternalExecution() && perm.getObjectType() == VdcObjectType.VM) {
        VM vm = getVmDAO().get(perm.getObjectId());
        if (vm != null && vm.getVmPoolId() != null) {
            addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_VM_IN_POOL);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    Permissions perm = getParameters().getPermission();
    if (perm == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_PERMISSION_NOT_SENT);
        return false;
    }
    Role role = getRoleDao().get(perm.getrole_id());
    Guid adElementId = perm.getad_element_id();
    if (role == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_INVALID_ROLE_ID);
        return false;
    }
    if (perm.getObjectType() == null || getVdcObjectName() == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_INVALID_OBJECT_ID);
        return false;
    }
    // give permission
    if (getParameters().getUser() == null && getParameters().getGroup() == null && getDbUserDAO().get(adElementId) == null && getAdGroupDAO().get(adElementId) == null) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.USER_MUST_EXIST_IN_DB.toString());
        return false;
    }
    // only system super user can give permissions with admin roles
    if (!isSystemSuperUser() && role.getType() == RoleType.ADMIN) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_ONLY_SYSTEM_SUPER_USER_CAN_GIVE_ADMIN_ROLES);
        return false;
    }
    // don't allow adding permissions to vms from pool externally
    if (!isInternalExecution() && perm.getObjectType() == VdcObjectType.VM) {
        VM vm = getVmDAO().get(perm.getObjectId());
        if (vm != null && vm.getVmPoolId() != null) {
            addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_VM_IN_POOL);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Get the parameters:
    T parameters = getParameters();
    // The user or group given in the parameters may haven't been added to
    // the database yet, this will be the case if they don't have an
    // internal identifier, if this is the case then they need to be
    // added to the database now, before the permission:
    final DbUser user = parameters.getUser();
    if (user != null && user.getId() == null) {
        user.setId(Guid.newGuid());
        getDbUserDAO().save(user);
    }
    final DbGroup group = parameters.getGroup();
    if (group != null && group.getId() == null) {
        group.setId(Guid.newGuid());
        getAdGroupDAO().save(group);
    }
    // The identifier of the owner of the permission can come from the
    // parameters directly or from the user/group objects:
    Guid ownerId = parameters.getPermission().getad_element_id();
    if (ownerId == null) {
        if (user != null) {
            ownerId = user.getId();
        }
    }
    if (ownerId == null) {
        if (group != null) {
            ownerId = group.getId();
        }
    }
    final permissions paramPermission = parameters.getPermission();
    permissions permission = getPermissionDAO().getForRoleAndAdElementAndObject(paramPermission.getrole_id(), ownerId, paramPermission.getObjectId());
    if (permission == null) {
        paramPermission.setId(Guid.newGuid());
        paramPermission.setad_element_id(ownerId);
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getPermissionDAO().save(paramPermission);
                getCompensationContext().snapshotNewEntity(paramPermission);
                getCompensationContext().stateChanged();
                return null;
            }
        });
        permission = paramPermission;
    }
    getReturnValue().setActionReturnValue(permission.getId());
    if (user != null) {
        updateAdminStatus(permission);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // Get the parameters:
    T parameters = getParameters();
    // The user or group given in the parameters may haven't been added to
    // the database yet, this will be the case if they don't have an
    // internal identifier, if this is the case then they need to be
    // added to the database now, before the permission:
    final DbUser user = parameters.getUser();
    if (user != null && user.getId() == null) {
        user.setId(Guid.newGuid());
        getDbUserDAO().save(user);
    }
    final DbGroup group = parameters.getGroup();
    if (group != null && group.getId() == null) {
        group.setId(Guid.newGuid());
        getAdGroupDAO().save(group);
    }
    // The identifier of the owner of the permission can come from the parameters directly or from the user/group
    // objects:
    Guid ownerId = parameters.getPermission().getad_element_id();
    if (ownerId == null) {
        if (user != null) {
            ownerId = user.getId();
        }
        if (ownerId == null) {
            if (group != null) {
                ownerId = group.getId();
            }
        }
    }
    final Permissions paramPermission = parameters.getPermission();
    Permissions permission = getPermissionDAO().getForRoleAndAdElementAndObject(paramPermission.getrole_id(), ownerId, paramPermission.getObjectId());
    if (permission == null) {
        paramPermission.setId(Guid.newGuid());
        paramPermission.setad_element_id(ownerId);
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getPermissionDAO().save(paramPermission);
                getCompensationContext().snapshotNewEntity(paramPermission);
                getCompensationContext().stateChanged();
                return null;
            }
        });
        permission = paramPermission;
    }
    getReturnValue().setActionReturnValue(permission.getId());
    if (user != null) {
        updateAdminStatus(permission);
    }
    setSucceeded(true);
}
#end_block

#method_before
private void updateAdminStatus(permissions perm) {
    // if the role of the permission is of type admin update the user
    // lastAdminCheckStatus to true
    Role role = getRoleDao().get(perm.getrole_id());
    if (role.getType() == RoleType.ADMIN) {
        MultiLevelAdministrationHandler.setIsAdminGUIFlag(perm.getad_element_id(), true);
    }
}
#method_after
private void updateAdminStatus(Permissions perm) {
    // if the role of the permission is of type admin update the user
    // lastAdminCheckStatus to true
    Role role = getRoleDao().get(perm.getrole_id());
    if (role.getType() == RoleType.ADMIN) {
        MultiLevelAdministrationHandler.setIsAdminGUIFlag(perm.getad_element_id(), true);
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    permissions permission = getParameters().getPermission();
    List<PermissionSubject> permissionsSubject = new ArrayList<>();
    permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    initUserAndGroupData();
    // user from the directory service
    if (getParameters().getUser() != null && _dbUser == null) {
        permissionsSubject.add(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, VdcActionType.AddUser.getActionGroup()));
    }
    return permissionsSubject;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    Permissions permission = getParameters().getPermission();
    List<PermissionSubject> permissionsSubject = new ArrayList<>();
    permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    initUserAndGroupData();
    // user from the directory service
    if (getParameters().getUser() != null && _dbUser == null) {
        permissionsSubject.add(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, VdcActionType.AddUser.getActionGroup()));
    }
    return permissionsSubject;
}
#end_block

#method_before
protected void verifyModel(User model, int index) {
    assertEquals(GUIDS[index].toString(), model.getId());
    assertArrayEquals(EXTERNAL_IDS[index].getBytes(), model.getExternalId());
    assertEquals(NAMES[index], model.getName());
    assertNotNull(model.getDomain());
    assertTrue(model.isSetGroups());
    assertEquals(PARSED_GROUPS.length, model.getGroups().getGroups().size());
    for (int i = 0; i < PARSED_GROUPS.length; i++) {
        Group group = model.getGroups().getGroups().get(i);
        assertEquals(PARSED_GROUPS[i], group.getName());
    }
    verifyLinks(model);
}
#method_after
protected void verifyModel(User model, int index) {
    assertEquals(GUIDS[index].toString(), model.getId());
    assertEquals(EXTERNAL_IDS[index].toHex(), model.getExternalId());
    assertEquals(NAMES[index], model.getName());
    assertNotNull(model.getDomain());
    assertTrue(model.isSetGroups());
    assertEquals(PARSED_GROUPS.length, model.getGroups().getGroups().size());
    for (int i = 0; i < PARSED_GROUPS.length; i++) {
        Group group = model.getGroups().getGroups().get(i);
        assertEquals(PARSED_GROUPS[i], group.getName());
    }
    verifyLinks(model);
}
#end_block

#method_before
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    LdapUser user;
    LdapQueryData queryData = new LdapQueryDataImpl();
    queryData.setFilterParameters(new Object[] { getUserId() });
    queryData.setLdapQueryType(LdapQueryType.getUserByGuid);
    queryData.setDomain(getDomain());
    Object searchResult = directorySearcher.FindOne(queryData);
    user = populateUserData((LdapUser) searchResult, getDomain());
    if (user != null) {
        GroupsDNQueryGenerator generator = createGroupsGeneratorForUser(user);
        List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
        for (LdapQueryData partialQuery : partialQueries) {
            PopulateGroup(partialQuery, getDomain(), user.getGroups(), getLoginName(), getPassword());
        }
    }
    setReturnValue(user);
    setSucceeded(true);
}
#method_after
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    LdapUser user;
    LdapQueryData queryData = new LdapQueryDataImpl();
    queryData.setFilterParameters(new Object[] { getUserId() });
    queryData.setLdapQueryType(LdapQueryType.getUserByGuid);
    queryData.setDomain(getDomain());
    Object searchResult = directorySearcher.findOne(queryData);
    user = populateUserData((LdapUser) searchResult, getDomain());
    if (user != null) {
        GroupsDNQueryGenerator generator = createGroupsGeneratorForUser(user);
        List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
        for (LdapQueryData partialQuery : partialQueries) {
            populateGroup(partialQuery, getDomain(), user.getGroups(), getLoginName(), getPassword());
        }
    }
    setReturnValue(user);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Get the name of the directory and the identifier of the user from
    // the parameters:
    String directory = getParameters().getDirectory();
    ExternalId id = getParameters().getId();
    // Check that the user is available in the directory (and save the
    // reference to avoid looking it up later when actually adding the
    // user to the database):
    directoryUser = (LdapUser) LdapFactory.getInstance(directory).RunAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(directory, id)).getReturnValue();
    if (directoryUser == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Populate information for the audit log:
    addCustomValue("NewUserName", directoryUser.getUserName());
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Get the name of the directory and the identifier of the user from the parameters:
    String directory = getParameters().getDirectory();
    ExternalId id = getParameters().getId();
    // Check that the user is available in the directory (and save the reference to avoid looking it up later when
    // actually adding the user to the database):
    directoryUser = (LdapUser) LdapFactory.getInstance(directory).runAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(directory, id)).getReturnValue();
    if (directoryUser == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Populate information for the audit log:
    addCustomValue("NewUserName", directoryUser.getUserName());
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // First check if the user is already in the database, if it is we
    // need to update, if not we need to insert:
    DbUserDAO dao = getDbUserDAO();
    DbUser dbUser = dao.getByExternalId(directoryUser.getDepartment(), directoryUser.getUserId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        dao.save(dbUser);
    } else {
        Guid id = dbUser.getId();
        dbUser = new DbUser(directoryUser);
        dbUser.setId(id);
        dao.update(dbUser);
    }
    // Return the identifier of the created user:
    setActionReturnValue(dbUser.getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    DbUserDAO dao = getDbUserDAO();
    // First check if the user is already in the database, if it is we need to update, if not we need to insert:
    DbUser dbUser = dao.getByExternalId(directoryUser.getDomainControler(), directoryUser.getUserId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        dao.save(dbUser);
    } else {
        Guid id = dbUser.getId();
        dbUser = new DbUser(directoryUser);
        dbUser.setId(id);
        dao.update(dbUser);
    }
    // Return the identifier of the created user:
    setActionReturnValue(dbUser.getId());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void verifyModel(Group model, int index) {
    assertEquals(GUIDS[index].toString(), model.getId());
    assertArrayEquals(EXTERNAL_IDS[index].getBytes(), model.getExternalId());
    assertEquals(GROUP_NAMES[index], model.getName());
    assertNotNull(model.getDomain());
    assertEquals(new Guid(DOMAIN.getBytes(), true).toString(), model.getDomain().getId());
    verifyLinks(model);
}
#method_after
@Override
protected void verifyModel(Group model, int index) {
    assertEquals(GUIDS[index].toString(), model.getId());
    assertEquals(EXTERNAL_IDS[index].toHex(), model.getExternalId());
    assertEquals(GROUP_NAMES[index], model.getName());
    assertNotNull(model.getDomain());
    assertEquals(new Guid(DOMAIN.getBytes(), true).toString(), model.getDomain().getId());
    verifyLinks(model);
}
#end_block

#method_before
public void init() {
    if (!initialized) {
        log.info("Start initializing " + getClass().getSimpleName());
        int mRefreshRate = Config.<Integer>GetValue(ConfigValues.UserRefreshRate);
        jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "OnTimer", new Class[] {}, new Object[] {}, 0, mRefreshRate, TimeUnit.SECONDS);
        initialized = true;
        log.info("Finished initializing " + getClass().getSimpleName());
    }
}
#method_after
public void init() {
    if (!initialized) {
        log.info("Start initializing " + getClass().getSimpleName());
        int mRefreshRate = Config.<Integer>getValue(ConfigValues.UserRefreshRate);
        jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "onTimer", new Class[] {}, new Object[] {}, 0, mRefreshRate, TimeUnit.SECONDS);
        initialized = true;
        log.info("Finished initializing " + getClass().getSimpleName());
    }
}
#end_block

#method_before
@Override
protected void finalize() throws Throwable {
    Dispose();
}
#method_after
@Override
protected void finalize() throws Throwable {
    dispose();
}
#end_block

#method_before
private static void updateDBUserFromADUser(DbUser dbUser, LdapUser ldapUser, HashSet<Guid> updatedUsers) {
    boolean succeeded = false;
    if (ldapUser == null || !ldapUser.getUserId().equals(dbUser.getExternalId())) {
        if (dbUser.getStatus() != 0) {
            log.warnFormat("User {0} not found in directory server, its status switched to InActive", dbUser.getFirstName());
            dbUser.setStatus(0);
            succeeded = true;
        }
    } else {
        if (dbUser.getStatus() == 0) {
            log.warnFormat("Inactive User {0} found in directory server, its status switched to Active", dbUser.getFirstName());
            dbUser.setStatus(1);
            succeeded = true;
        }
        if (!StringUtils.equals(dbUser.getFirstName(), ldapUser.getName())) {
            dbUser.setFirstName(ldapUser.getName());
            succeeded = true;
        }
        if (!StringUtils.equals(dbUser.getLastName(), ldapUser.getSurName())) {
            dbUser.setLastName(ldapUser.getSurName());
            succeeded = true;
        }
        if (!StringUtils.equals(dbUser.getDomain(), ldapUser.getDomainControler())) {
            dbUser.setDomain(ldapUser.getDomainControler());
            succeeded = true;
        }
        if (!StringUtils.equals(dbUser.getLoginName(), ldapUser.getUserName())) {
            dbUser.setLoginName(ldapUser.getUserName());
            succeeded = true;
        }
        if (!StringUtils.equals(dbUser.getGroupNames(), ldapUser.getGroup())) {
            dbUser.setGroupNames(ldapUser.getGroup());
            succeeded = true;
            updatedUsers.add(dbUser.getId());
        }
        if (!StringUtils.equals(dbUser.getDepartment(), ldapUser.getDepartment())) {
            dbUser.setDepartment(ldapUser.getDepartment());
            succeeded = true;
        }
        if (!StringUtils.equals(dbUser.getRole(), ldapUser.getTitle())) {
            dbUser.setRole(ldapUser.getTitle());
            succeeded = true;
        }
        if (!StringUtils.equals(dbUser.getEmail(), ldapUser.getEmail())) {
            dbUser.setEmail(ldapUser.getEmail());
            succeeded = true;
        }
        if (!StringUtils.equals(dbUser.getGroupIds(), ldapUser.getGroupIds())) {
            dbUser.setGroupIds(ldapUser.getGroupIds());
            succeeded = true;
        }
        if (succeeded) {
            dbUser.setStatus(dbUser.getStatus() + 1);
        }
    }
    if (succeeded) {
        DbFacade.getInstance().getDbUserDao().update(dbUser);
    }
}
#method_after
private static void updateDBUserFromADUser(DbUser dbUser, LdapUser ldapUser, HashSet<Guid> updatedUsers) {
    boolean succeeded = false;
    if (ldapUser == null || !ldapUser.getUserId().equals(dbUser.getExternalId())) {
        if (dbUser.isActive()) {
            log.warnFormat("User {0} not found in directory server, its status switched to InActive", dbUser.getFirstName());
            dbUser.setActive(false);
            succeeded = true;
        }
    } else {
        if (!dbUser.isActive()) {
            log.warnFormat("Inactive User {0} found in directory server, its status switched to Active", dbUser.getFirstName());
            dbUser.setActive(true);
            succeeded = true;
        }
        if (!StringUtils.equals(dbUser.getFirstName(), ldapUser.getName())) {
            dbUser.setFirstName(ldapUser.getName());
            succeeded = true;
        }
        if (!StringUtils.equals(dbUser.getLastName(), ldapUser.getSurName())) {
            dbUser.setLastName(ldapUser.getSurName());
            succeeded = true;
        }
        if (!StringUtils.equals(dbUser.getDomain(), ldapUser.getDomainControler())) {
            dbUser.setDomain(ldapUser.getDomainControler());
            succeeded = true;
        }
        if (!StringUtils.equals(dbUser.getLoginName(), ldapUser.getUserName())) {
            dbUser.setLoginName(ldapUser.getUserName());
            succeeded = true;
        }
        if (!StringUtils.equals(dbUser.getGroupNames(), ldapUser.getGroup())) {
            dbUser.setGroupNames(ldapUser.getGroup());
            succeeded = true;
            updatedUsers.add(dbUser.getId());
        }
        if (!StringUtils.equals(dbUser.getDepartment(), ldapUser.getDepartment())) {
            dbUser.setDepartment(ldapUser.getDepartment());
            succeeded = true;
        }
        if (!StringUtils.equals(dbUser.getRole(), ldapUser.getTitle())) {
            dbUser.setRole(ldapUser.getTitle());
            succeeded = true;
        }
        if (!StringUtils.equals(dbUser.getEmail(), ldapUser.getEmail())) {
            dbUser.setEmail(ldapUser.getEmail());
            succeeded = true;
        }
        if (!StringUtils.equals(dbUser.getGroupIds(), ldapUser.getGroupIds())) {
            dbUser.setGroupIds(ldapUser.getGroupIds());
            succeeded = true;
        }
    }
    if (succeeded) {
        DbFacade.getInstance().getDbUserDao().update(dbUser);
    }
}
#end_block

#method_before
public void refreshAllUserData(List<DbGroup> updatedGroups) {
    try {
        log.info("Start refreshing all users data");
        List<DbUser> allUsers = DbFacade.getInstance().getDbUserDao().getAll();
        List<String> domainsList = LdapBrokerUtils.getDomainsList(true);
        List<DbUser> filteredUsers = LinqUtils.filter(allUsers, new UsersPerDomainPredicate(domainsList));
        Map<String, Map<ExternalId, DbUser>> userByDomains = new HashMap<>();
        // Filter all users by domains
        for (DbUser user : filteredUsers) {
            Map<ExternalId, DbUser> domainUser;
            if (!userByDomains.containsKey(user.getDomain())) {
                domainUser = new HashMap<ExternalId, DbUser>();
                userByDomains.put(user.getDomain(), domainUser);
            } else {
                domainUser = userByDomains.get(user.getDomain());
            }
            domainUser.put(user.getExternalId(), user);
        }
        if (userByDomains.size() != 0) {
            // Refresh users in each domain separately
            for (Map.Entry<String, Map<ExternalId, DbUser>> entry : userByDomains.entrySet()) {
                String domain = entry.getKey();
                Collection<DbUser> users = entry.getValue().values();
                List<ExternalId> ids = new ArrayList<>(users.size());
                for (DbUser user : users) {
                    ids.add(user.getExternalId());
                }
                List<LdapUser> adUsers = (List<LdapUser>) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdUserByUserIdList, new LdapSearchByUserIdListParameters(domain, ids, false)).getReturnValue();
                HashSet<Guid> updatedUsers = new HashSet<Guid>();
                if (adUsers == null) {
                    log.warn("No users returned from directory server during refresh users");
                } else {
                    List<LdapGroup> ldapUpdatedGroups = new ArrayList<>(updatedGroups.size());
                    for (DbGroup dbGroup : updatedGroups) {
                        LdapGroup ldapGroup = new LdapGroup(dbGroup);
                        ldapUpdatedGroups.add(ldapGroup);
                    }
                    LdapBrokerUtils.performGroupPopulationForUsers(adUsers, domain, ldapUpdatedGroups);
                    for (LdapUser adUser : adUsers) {
                        updateDBUserFromADUser(userByDomains.get(domain).get(adUser.getUserId()), adUser, updatedUsers);
                        userByDomains.get(domain).remove(adUser.getUserId());
                    }
                }
                Collection<DbUser> usersForDomain = entry.getValue().values();
                if (usersForDomain == null) {
                    log.warnFormat("No users for domain {0}", domain);
                } else {
                    for (DbUser dbUser : usersForDomain) {
                        if (dbUser.getStatus() != 0) {
                            log.warnFormat("User {0} not found in directory server, its status switched to InActive", dbUser.getFirstName());
                            dbUser.setStatus(AsyncTaskStatusEnum.unknown.getValue());
                            DbFacade.getInstance().getDbUserDao().update(dbUser);
                        }
                    }
                }
                // group or role was changed
                if (updatedUsers.size() > 0) {
                    DbFacade.getInstance().updateLastAdminCheckStatus(updatedUsers.toArray(new Guid[updatedUsers.size()]));
                }
            }
        }
    } catch (RuntimeException e) {
        log.error("Failed to refresh users data.", e);
    }
}
#method_after
public void refreshAllUserData(List<DbGroup> updatedGroups) {
    try {
        log.info("Start refreshing all users data");
        List<DbUser> allUsers = DbFacade.getInstance().getDbUserDao().getAll();
        List<String> domainsList = LdapBrokerUtils.getDomainsList(true);
        List<DbUser> filteredUsers = LinqUtils.filter(allUsers, new UsersPerDomainPredicate(domainsList));
        Map<String, Map<ExternalId, DbUser>> userByDomains = new HashMap<>();
        // Map all users by domains
        for (DbUser user : filteredUsers) {
            Map<ExternalId, DbUser> domainUser;
            if (!userByDomains.containsKey(user.getDomain())) {
                domainUser = new HashMap<>();
                userByDomains.put(user.getDomain(), domainUser);
            } else {
                domainUser = userByDomains.get(user.getDomain());
            }
            domainUser.put(user.getExternalId(), user);
        }
        if (userByDomains.size() != 0) {
            // Refresh users in each domain separately
            for (Map.Entry<String, Map<ExternalId, DbUser>> entry : userByDomains.entrySet()) {
                String domain = entry.getKey();
                Collection<DbUser> users = entry.getValue().values();
                List<ExternalId> ids = new ArrayList<>(users.size());
                for (DbUser user : users) {
                    ids.add(user.getExternalId());
                }
                List<LdapUser> adUsers = (List<LdapUser>) LdapFactory.getInstance(domain).runAdAction(AdActionType.GetAdUserByUserIdList, new LdapSearchByUserIdListParameters(domain, ids, false)).getReturnValue();
                HashSet<Guid> updatedUsers = new HashSet<Guid>();
                if (adUsers == null) {
                    log.warn("No users returned from directory server during refresh users");
                } else {
                    List<LdapGroup> ldapUpdatedGroups = new ArrayList<>(updatedGroups.size());
                    for (DbGroup dbGroup : updatedGroups) {
                        LdapGroup ldapGroup = new LdapGroup(dbGroup);
                        ldapUpdatedGroups.add(ldapGroup);
                    }
                    LdapBrokerUtils.performGroupPopulationForUsers(adUsers, domain, ldapUpdatedGroups);
                    for (LdapUser adUser : adUsers) {
                        updateDBUserFromADUser(userByDomains.get(domain).get(adUser.getUserId()), adUser, updatedUsers);
                        userByDomains.get(domain).remove(adUser.getUserId());
                    }
                }
                Collection<DbUser> usersForDomain = entry.getValue().values();
                if (usersForDomain == null) {
                    log.warnFormat("No users for domain {0}", domain);
                } else {
                    for (DbUser dbUser : usersForDomain) {
                        if (dbUser.isActive()) {
                            log.warnFormat("User {0} not found in directory server, its status switched to InActive", dbUser.getFirstName());
                            dbUser.setActive(false);
                            DbFacade.getInstance().getDbUserDao().update(dbUser);
                        }
                    }
                }
                // group or role was changed
                if (updatedUsers.size() > 0) {
                    DbFacade.getInstance().updateLastAdminCheckStatus(updatedUsers.toArray(new Guid[updatedUsers.size()]));
                }
            }
        }
    } catch (RuntimeException e) {
        log.error("Failed to refresh users data.", e);
    }
}
#end_block

#method_before
private static List<DbGroup> updateGroups() {
    List<DbGroup> groups = DbFacade.getInstance().getDbGroupDao().getAll();
    for (DbGroup group : groups) {
        // following code should not occur
        if (group.getDomain() == null && group.getName().contains("@")) {
            StringBuilder logMsg = new StringBuilder();
            logMsg.append("domain name for ad group ").append(group.getName()).append(" is null. This should not occur, please check that domain name is passed correctly from client");
            log.warn(logMsg.toString());
            String partAfterAtSign = group.getName().split("[@]", -1)[1];
            String newDomainName = partAfterAtSign;
            if (partAfterAtSign.contains("/")) {
                String partPreviousToSlashSign = partAfterAtSign.split("[/]", -1)[0];
                newDomainName = partPreviousToSlashSign;
            }
            group.setDomain(newDomainName);
        }
        // to fetch for them
        if (group.getDomain() != null && !group.getDomain().isEmpty()) {
            if (UsersDomainsCacheManagerService.getInstance().getDomain(group.getDomain()) == null) {
                log.errorFormat("Cannot query for group {0} from domain {1} because the domain is not configured. Please use the manage domains utility if you wish to add this domain.", group.getName(), group.getDomain());
            } else {
                LdapGroup groupFromAD = (LdapGroup) LdapFactory.getInstance(group.getDomain()).RunAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(group.getDomain(), group.getExternalId())).getReturnValue();
                if (// Active
                group.getStatus() == 1 && (groupFromAD == null || groupFromAD.getstatus() == LdapRefStatus.Inactive)) {
                    // Inactive
                    group.setStatus(0);
                } else if (groupFromAD != null && (!StringUtils.equals(group.getName(), groupFromAD.getname()) || group.getStatus() != groupFromAD.getstatus().getValue() || !StringUtils.equals(group.getDistinguishedName(), groupFromAD.getDistinguishedName()))) {
                    group = new DbGroup(groupFromAD);
                }
                DbFacade.getInstance().getDbGroupDao().update(group);
                // memberOf is not persistent and should be set in the returned groups list from the LDAP queries
                if (groupFromAD != null) {
                    group.setMemberOf(groupFromAD.getMemberOf());
                }
            }
        }
    }
    return groups;
}
#method_after
private static List<DbGroup> updateGroups() {
    List<DbGroup> groups = DbFacade.getInstance().getDbGroupDao().getAll();
    for (DbGroup group : groups) {
        // following code should not occur
        if (group.getDomain() == null && group.getName().contains("@")) {
            StringBuilder logMsg = new StringBuilder();
            logMsg.append("domain name for ad group ").append(group.getName()).append(" is null. This should not occur, please check that domain name is passed correctly from client");
            log.warn(logMsg.toString());
            String partAfterAtSign = group.getName().split("[@]", -1)[1];
            String newDomainName = partAfterAtSign;
            if (partAfterAtSign.contains("/")) {
                String partPreviousToSlashSign = partAfterAtSign.split("[/]", -1)[0];
                newDomainName = partPreviousToSlashSign;
            }
            group.setDomain(newDomainName);
        }
        // to fetch for them
        if (group.getDomain() != null && !group.getDomain().isEmpty()) {
            if (UsersDomainsCacheManagerService.getInstance().getDomain(group.getDomain()) == null) {
                log.errorFormat("Cannot query for group {0} from domain {1} because the domain is not configured. Please use the manage domains utility if you wish to add this domain.", group.getName(), group.getDomain());
            } else {
                LdapGroup groupFromAD = (LdapGroup) LdapFactory.getInstance(group.getDomain()).runAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(group.getDomain(), group.getExternalId())).getReturnValue();
                if (group.isActive() && (groupFromAD == null || !groupFromAD.isActive())) {
                    group.setActive(false);
                } else if (groupFromAD != null && (!StringUtils.equals(group.getName(), groupFromAD.getname()) || group.isActive() != groupFromAD.isActive() || !StringUtils.equals(group.getDistinguishedName(), groupFromAD.getDistinguishedName()))) {
                    group = new DbGroup(groupFromAD);
                }
                DbFacade.getInstance().getDbGroupDao().update(group);
                // memberOf is not persistent and should be set in the returned groups list from the LDAP queries
                if (groupFromAD != null) {
                    group.setMemberOf(new HashSet<>(groupFromAD.getMemberOf()));
                }
            }
        }
    }
    return groups;
}
#end_block

#method_before
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    Object group = null;
    LdapQueryData queryData = new LdapQueryDataImpl();
    queryData.setFilterParameters(new Object[] { getGroupId() });
    queryData.setLdapQueryType(LdapQueryType.getGroupByGuid);
    queryData.setDomain(getDomain());
    Object searchResult = directorySearcher.FindOne(queryData);
    if (searchResult != null) {
        GroupSearchResult result = (GroupSearchResult) searchResult;
        ExternalId groupId = result.getId();
        if (ObjectUtils.notEqual(getGroupId(), groupId)) {
            /**
             * Cannot find group - group is Inactive
             */
            group = new LdapGroup(getGroupId());
        } else {
            String distinguishedName = result.getDistinguishedName();
            List<String> memberOf = result.getMemberOf();
            String groupName = LdapBrokerUtils.generateGroupDisplayValue(distinguishedName);
            group = new LdapGroup(groupId, groupName, getDomain(), distinguishedName, memberOf);
        }
    }
    setReturnValue(group);
    setSucceeded(true);
}
#method_after
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    Object group = null;
    LdapQueryData queryData = new LdapQueryDataImpl();
    queryData.setFilterParameters(new Object[] { getGroupId() });
    queryData.setLdapQueryType(LdapQueryType.getGroupByGuid);
    queryData.setDomain(getDomain());
    Object searchResult = directorySearcher.findOne(queryData);
    if (searchResult != null) {
        GroupSearchResult result = (GroupSearchResult) searchResult;
        ExternalId groupId = result.getId();
        if (ObjectUtils.notEqual(getGroupId(), groupId)) {
            /**
             * Cannot find group - group is Inactive
             */
            group = new LdapGroup(getGroupId());
        } else {
            String distinguishedName = result.getDistinguishedName();
            List<String> memberOf = result.getMemberOf();
            String groupName = LdapBrokerUtils.generateGroupDisplayValue(distinguishedName);
            group = new LdapGroup(groupId, groupName, getDomain(), distinguishedName, memberOf);
        }
    }
    setReturnValue(group);
    setSucceeded(true);
}
#end_block

#method_before
private void PopulateUsers() {
    List<LdapQueryData> queries = GenerateUsersQuery();
    List<LdapUser> results = new ArrayList<LdapUser>();
    for (LdapQueryData queryData : queries) {
        java.util.ArrayList<LdapUser> tempUsers = (java.util.ArrayList<LdapUser>) LdapFactory.getInstance(getDomain()).RunAdAction(AdActionType.SearchUserByQuery, new LdapSearchByQueryParameters(getParameters().getSessionId(), getDomain(), queryData)).getReturnValue();
        if (tempUsers != null) {
            results.addAll(tempUsers);
        }
    }
    setReturnValue(results);
}
#method_after
private void PopulateUsers() {
    List<LdapQueryData> queries = GenerateUsersQuery();
    List<LdapUser> results = new ArrayList<LdapUser>();
    for (LdapQueryData queryData : queries) {
        java.util.ArrayList<LdapUser> tempUsers = (java.util.ArrayList<LdapUser>) LdapFactory.getInstance(getDomain()).runAdAction(AdActionType.SearchUserByQuery, new LdapSearchByQueryParameters(getParameters().getSessionId(), getDomain(), queryData)).getReturnValue();
        if (tempUsers != null) {
            results.addAll(tempUsers);
        }
    }
    setReturnValue(results);
}
#end_block

#method_before
public void setMemberOf(List<String> memberOf) {
    this.memberOf = memberOf;
}
#method_after
public void setMemberOf(Set<String> memberOf) {
    this.memberOf = memberOf;
}
#end_block

#method_before
public List<String> getMemberOf() {
    return memberOf;
}
#method_after
public Set<String> getMemberOf() {
    return memberOf;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((externalId == null) ? 0 : externalId.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((distinguishedName == null) ? 0 : distinguishedName.hashCode());
    result = prime * result + ((memberOf == null) ? 0 : memberOf.hashCode());
    result = prime * result + status;
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((externalId == null) ? 0 : externalId.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((distinguishedName == null) ? 0 : distinguishedName.hashCode());
    result = prime * result + ((memberOf == null) ? 0 : memberOf.hashCode());
    result = prime * result + (active ? 1231 : 1237);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DbGroup other = (DbGroup) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(externalId, other.externalId) && ObjectUtils.objectsEqual(domain, other.domain) && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(distinguishedName, other.distinguishedName) && ObjectUtils.objectsEqual(memberOf, other.memberOf) && status == other.status);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DbGroup other = (DbGroup) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(externalId, other.externalId) && ObjectUtils.objectsEqual(domain, other.domain) && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(distinguishedName, other.distinguishedName) && ObjectUtils.objectsEqual(memberOf, other.memberOf) && active == other.active);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
public static DbUser initUser(String sessionId, String domain, ExternalId id) {
    DbUser dbUser = DbFacade.getInstance().getDbUserDao().getByExternalId(domain, id);
    if (dbUser == null) {
        LdapUser adUser = (LdapUser) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(sessionId, domain, id)).getReturnValue();
        if (adUser == null) {
            throw new VdcBLLException(VdcBllErrors.USER_FAILED_POPULATE_DATA);
        }
        dbUser = new DbUser(adUser);
        DbFacade.getInstance().getDbUserDao().save(dbUser);
    }
    return dbUser;
}
#method_after
@SuppressWarnings("deprecation")
public static DbUser initUser(String sessionId, String domain, ExternalId id) {
    DbUser dbUser = DbFacade.getInstance().getDbUserDao().getByExternalId(domain, id);
    if (dbUser == null) {
        LdapUser adUser = (LdapUser) LdapFactory.getInstance(domain).runAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(sessionId, domain, id)).getReturnValue();
        if (adUser == null) {
            throw new VdcBLLException(VdcBllErrors.USER_FAILED_POPULATE_DATA);
        }
        dbUser = new DbUser(adUser);
        DbFacade.getInstance().getDbUserDao().save(dbUser);
    }
    return dbUser;
}
#end_block

#method_before
public List<LdapQueryData> getLdapQueriesData(String domain) {
    int queryLimit = Config.<Integer>GetValue(ConfigValues.MaxLDAPQueryPartsNumber);
    List<LdapQueryData> results = new ArrayList<LdapQueryData>();
    LdapQueryData subQueryData = new LdapQueryDataImpl();
    ArrayList<Object> filterParameters = new ArrayList<Object>();
    int counter = 0;
    for (ExternalId identifier : ldapIdentifiers) {
        filterParameters.add(identifier);
        // Checking if more than queryLimit query clauses were added to the query
        if (counter >= queryLimit) {
            // More than queryLimit query clauses were added to the query -
            // close the query, add it to the results, and start a new query
            subQueryData.setFilterParameters(filterParameters.toArray());
            subQueryData.setLdapQueryType(LdapQueryType.getUsersByUserGuids);
            subQueryData.setBaseDNParameters(null);
            subQueryData.setDomain(domain);
            results.add(subQueryData);
            subQueryData = new LdapQueryDataImpl();
            filterParameters = new ArrayList<Object>();
            counter = 0;
        }
        counter++;
    }
    if (!filterParameters.isEmpty()) {
        subQueryData.setFilterParameters(filterParameters.toArray());
        subQueryData.setLdapQueryType(LdapQueryType.getUsersByUserGuids);
        subQueryData.setBaseDNParameters(null);
        subQueryData.setDomain(domain);
        results.add(subQueryData);
    }
    return results;
}
#method_after
public List<LdapQueryData> getLdapQueriesData(String domain) {
    int queryLimit = Config.<Integer>getValue(ConfigValues.MaxLDAPQueryPartsNumber);
    List<LdapQueryData> results = new ArrayList<LdapQueryData>();
    LdapQueryData subQueryData = new LdapQueryDataImpl();
    ArrayList<Object> filterParameters = new ArrayList<Object>();
    int counter = 0;
    for (ExternalId identifier : ldapIdentifiers) {
        filterParameters.add(identifier);
        // Checking if more than queryLimit query clauses were added to the query
        if (counter >= queryLimit) {
            // More than queryLimit query clauses were added to the query -
            // close the query, add it to the results, and start a new query
            subQueryData.setFilterParameters(filterParameters.toArray());
            subQueryData.setLdapQueryType(LdapQueryType.getUsersByUserGuids);
            subQueryData.setBaseDNParameters(null);
            subQueryData.setDomain(domain);
            results.add(subQueryData);
            subQueryData = new LdapQueryDataImpl();
            filterParameters = new ArrayList<Object>();
            counter = 0;
        }
        counter++;
    }
    if (!filterParameters.isEmpty()) {
        subQueryData.setFilterParameters(filterParameters.toArray());
        subQueryData.setLdapQueryType(LdapQueryType.getUsersByUserGuids);
        subQueryData.setBaseDNParameters(null);
        subQueryData.setDomain(domain);
        results.add(subQueryData);
    }
    return results;
}
#end_block

#method_before
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    java.util.ArrayList<LdapGroup> groupList = new java.util.ArrayList<LdapGroup>();
    List<GroupSearchResult> searchResults = (List<GroupSearchResult>) directorySearcher.FindAll(getLdapQueryData());
    {
        for (GroupSearchResult searchResult : searchResults) {
            String distinguishedName = searchResult.getDistinguishedName();
            List<String> memberOf = searchResult.getMemberOf();
            if (distinguishedName != null) {
                String groupName = LdapBrokerUtils.generateGroupDisplayValue(searchResult.getDistinguishedName());
                LdapGroup group = new LdapGroup(searchResult.getId(), groupName, getDomain(), distinguishedName, memberOf);
                groupList.add(group);
            }
        }
    }
    setReturnValue(groupList);
    setSucceeded(true);
}
#method_after
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    java.util.ArrayList<LdapGroup> groupList = new java.util.ArrayList<LdapGroup>();
    List<GroupSearchResult> searchResults = (List<GroupSearchResult>) directorySearcher.findAll(getLdapQueryData());
    {
        for (GroupSearchResult searchResult : searchResults) {
            String distinguishedName = searchResult.getDistinguishedName();
            List<String> memberOf = searchResult.getMemberOf();
            if (distinguishedName != null) {
                String groupName = LdapBrokerUtils.generateGroupDisplayValue(searchResult.getDistinguishedName());
                LdapGroup group = new LdapGroup(searchResult.getId(), groupName, getDomain(), distinguishedName, memberOf);
                groupList.add(group);
            }
        }
    }
    setReturnValue(groupList);
    setSucceeded(true);
}
#end_block

#method_before
public static LdapUser getUserById(ExternalId id) {
    LdapUser retVal = null;
    DbUser dbUser = getDbUserDAO().getByExternalId(Config.<String>GetValue(ConfigValues.AdminDomain), id);
    if (dbUser != null) {
        retVal = new LdapUser(dbUser);
    }
    return retVal;
}
#method_after
public static LdapUser getUserById(ExternalId id) {
    LdapUser retVal = null;
    DbUser dbUser = getDbUserDAO().getByExternalId(Config.<String>getValue(ConfigValues.AdminDomain), id);
    if (dbUser != null) {
        retVal = new LdapUser(dbUser);
    }
    return retVal;
}
#end_block

#method_before
public static UserAuthenticationResult authenticate(String userName, String password, String domain) {
    UserAuthenticationResult result = null;
    String adminPassword = Config.<String>GetValue(ConfigValues.AdminPassword).trim();
    String adminUser = Config.<String>GetValue(ConfigValues.AdminUser).trim();
    String adminDomain = Config.<String>GetValue(ConfigValues.AdminDomain).trim();
    if (userName.equals(adminUser)) {
        if (domain.equalsIgnoreCase(adminDomain)) {
            if (adminPassword.isEmpty()) {
                result = new UserAuthenticationResult(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE_ACCOUNT_IS_LOCKED_OR_DISABLED);
            } else if (adminPassword.equals(password)) {
                result = new UserAuthenticationResult();
            } else {
                result = new UserAuthenticationResult(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            }
        } else {
            result = new UserAuthenticationResult(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        }
    } else {
        result = new UserAuthenticationResult(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
    }
    return result;
}
#method_after
public static UserAuthenticationResult authenticate(String userName, String password, String domain) {
    UserAuthenticationResult result = null;
    String adminPassword = Config.<String>getValue(ConfigValues.AdminPassword).trim();
    String adminUser = Config.<String>getValue(ConfigValues.AdminUser).trim();
    String adminDomain = Config.<String>getValue(ConfigValues.AdminDomain).trim();
    if (userName.equals(adminUser)) {
        if (domain.equalsIgnoreCase(adminDomain)) {
            if (adminPassword.isEmpty()) {
                result = new UserAuthenticationResult(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE_ACCOUNT_IS_LOCKED_OR_DISABLED);
            } else if (adminPassword.equals(password)) {
                result = new UserAuthenticationResult();
            } else {
                result = new UserAuthenticationResult(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
            }
        } else {
            result = new UserAuthenticationResult(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        }
    } else {
        result = new UserAuthenticationResult(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
    }
    return result;
}
#end_block

#method_before
@Override
protected void verifyModel(User model, int index) {
    assertEquals(GUIDS[index].toString(), model.getId());
    assertArrayEquals(EXTERNAL_IDS[index].getBytes(), model.getExternalId());
    assertEquals(NAMES[index], model.getUserName());
    assertNotNull(model.getDomain());
    assertEquals(new Guid(DOMAIN.getBytes(), true).toString(), model.getDomain().getId());
    assertTrue(model.isSetGroups());
    assertEquals(PARSED_GROUPS.length, model.getGroups().getGroups().size());
    for (int i = 0; i < PARSED_GROUPS.length; i++) {
        Group group = model.getGroups().getGroups().get(i);
        assertEquals(PARSED_GROUPS[i], group.getName());
    }
    verifyLinks(model);
}
#method_after
@Override
protected void verifyModel(User model, int index) {
    assertEquals(GUIDS[index].toString(), model.getId());
    assertEquals(EXTERNAL_IDS[index].toHex(), model.getExternalId());
    assertEquals(NAMES[index], model.getUserName());
    assertNotNull(model.getDomain());
    assertEquals(new Guid(DOMAIN.getBytes(), true).toString(), model.getDomain().getId());
    assertTrue(model.isSetGroups());
    assertEquals(PARSED_GROUPS.length, model.getGroups().getGroups().size());
    for (int i = 0; i < PARSED_GROUPS.length; i++) {
        Group group = model.getGroups().getGroups().get(i);
        assertEquals(PARSED_GROUPS[i], group.getName());
    }
    verifyLinks(model);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((externalId == null) ? 0 : externalId.hashCode());
    result = prime * result + ((department == null) ? 0 : department.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + ((email == null) ? 0 : email.hashCode());
    result = prime * result + ((groupNames == null) ? 0 : groupNames.hashCode());
    result = prime * result + (isAdmin ? 1231 : 1237);
    result = prime * result + ((firstName == null) ? 0 : firstName.hashCode());
    result = prime * result + ((note == null) ? 0 : note.hashCode());
    result = prime * result + ((role == null) ? 0 : role.hashCode());
    result = prime * result + status;
    result = prime * result + ((lastName == null) ? 0 : lastName.hashCode());
    result = prime * result + ((loginName == null) ? 0 : loginName.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((externalId == null) ? 0 : externalId.hashCode());
    result = prime * result + ((department == null) ? 0 : department.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + ((email == null) ? 0 : email.hashCode());
    result = prime * result + ((groupNames == null) ? 0 : groupNames.hashCode());
    result = prime * result + (isAdmin ? 1231 : 1237);
    result = prime * result + ((firstName == null) ? 0 : firstName.hashCode());
    result = prime * result + ((note == null) ? 0 : note.hashCode());
    result = prime * result + ((role == null) ? 0 : role.hashCode());
    result = prime * result + (active ? 1231 : 1237);
    result = prime * result + ((lastName == null) ? 0 : lastName.hashCode());
    result = prime * result + ((loginName == null) ? 0 : loginName.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DbUser other = (DbUser) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(externalId, other.externalId) && ObjectUtils.objectsEqual(department, other.department) && ObjectUtils.objectsEqual(domain, other.domain) && ObjectUtils.objectsEqual(email, other.email) && ObjectUtils.objectsEqual(groupNames, other.groupNames) && isAdmin == other.isAdmin && ObjectUtils.objectsEqual(firstName, other.firstName) && ObjectUtils.objectsEqual(note, other.note) && ObjectUtils.objectsEqual(role, other.role) && status == other.status && ObjectUtils.objectsEqual(lastName, other.lastName) && ObjectUtils.objectsEqual(loginName, other.loginName));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DbUser other = (DbUser) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(externalId, other.externalId) && ObjectUtils.objectsEqual(department, other.department) && ObjectUtils.objectsEqual(domain, other.domain) && ObjectUtils.objectsEqual(email, other.email) && ObjectUtils.objectsEqual(groupNames, other.groupNames) && isAdmin == other.isAdmin && ObjectUtils.objectsEqual(firstName, other.firstName) && ObjectUtils.objectsEqual(note, other.note) && ObjectUtils.objectsEqual(role, other.role) && active == other.active && ObjectUtils.objectsEqual(lastName, other.lastName) && ObjectUtils.objectsEqual(loginName, other.loginName));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Get the identifier of the group from the parameters:
    Guid id = getParameters().getId();
    // Remove the permissions of the group:
    for (permissions permission : getPermissionDAO().getAllDirectPermissionsForAdElement(id)) {
        PermissionsOperationsParameters param = new PermissionsOperationsParameters(permission);
        param.setSessionId(getParameters().getSessionId());
        getBackend().runInternalAction(VdcActionType.RemovePermission, param, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    }
    // Remove the group itself:
    getAdGroupDAO().remove(id);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // Get the identifier of the group from the parameters:
    Guid id = getParameters().getId();
    // TODO: This should be done without invoking the command to avoid the overhead.
    for (Permissions permission : getPermissionDAO().getAllDirectPermissionsForAdElement(id)) {
        PermissionsOperationsParameters param = new PermissionsOperationsParameters(permission);
        param.setSessionId(getParameters().getSessionId());
        getBackend().runInternalAction(VdcActionType.RemovePermission, param, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    }
    // Remove the group itself:
    getAdGroupDAO().remove(id);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue;
    // check if user is not already subscribed to this event with same
    // method and address
    Guid subscriberId = getParameters().getEventSubscriber().getsubscriber_id();
    String eventName = getParameters().getEventSubscriber().getevent_up_name();
    int methodId = getParameters().getEventSubscriber().getmethod_id();
    List<event_subscriber> subscriptions = DbFacade.getInstance().getEventDao().getAllForSubscriber(subscriberId);
    if (IsAlreadySubscribed(subscriptions, subscriberId, eventName, methodId)) {
        addCanDoActionMessage(VdcBllMessages.EN_ALREADY_SUBSCRIBED);
        retValue = false;
    } else {
        // get notification method
        List<EventNotificationMethod> eventNotificationMethods = (DbFacade.getInstance().getEventDao().getEventNotificationMethodsById(methodId));
        if (eventNotificationMethods.size() > 0) {
            // validate event
            List<EventMap> eventMap = DbFacade.getInstance().getEventDao().getEventMapByName(eventName);
            if (eventMap.size() > 0) {
                String domain = getParameters().getDomain();
                // Validate user
                DbUser user = DbFacade.getInstance().getDbUserDao().get(subscriberId);
                if (user == null) {
                    addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DB);
                    retValue = false;
                } else {
                    retValue = ValidateAdd(eventNotificationMethods, getParameters().getEventSubscriber(), user);
                }
            } else {
                addCanDoActionMessage(String.format("$eventName %1$s", eventName));
                addCanDoActionMessage(VdcBllMessages.EN_UNSUPPORTED_NOTIFICATION_EVENT);
                retValue = false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.EN_UNKNOWN_NOTIFICATION_METHOD);
            retValue = false;
        }
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue;
    // check if user is not already subscribed to this event with same
    // method and address
    Guid subscriberId = getParameters().getEventSubscriber().getsubscriber_id();
    String eventName = getParameters().getEventSubscriber().getevent_up_name();
    int methodId = getParameters().getEventSubscriber().getmethod_id();
    List<event_subscriber> subscriptions = DbFacade.getInstance().getEventDao().getAllForSubscriber(subscriberId);
    if (IsAlreadySubscribed(subscriptions, subscriberId, eventName, methodId)) {
        addCanDoActionMessage(VdcBllMessages.EN_ALREADY_SUBSCRIBED);
        retValue = false;
    } else {
        // get notification method
        List<EventNotificationMethod> eventNotificationMethods = (DbFacade.getInstance().getEventDao().getEventNotificationMethodsById(methodId));
        if (eventNotificationMethods.size() > 0) {
            // validate event
            List<EventMap> eventMap = DbFacade.getInstance().getEventDao().getEventMapByName(eventName);
            if (eventMap.size() > 0) {
                // Validate user
                DbUser user = DbFacade.getInstance().getDbUserDao().get(subscriberId);
                if (user == null) {
                    addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DB);
                    retValue = false;
                } else {
                    retValue = ValidateAdd(eventNotificationMethods, getParameters().getEventSubscriber(), user);
                }
            } else {
                addCanDoActionMessage(String.format("$eventName %1$s", eventName));
                addCanDoActionMessage(VdcBllMessages.EN_UNSUPPORTED_NOTIFICATION_EVENT);
                retValue = false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.EN_UNKNOWN_NOTIFICATION_METHOD);
            retValue = false;
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    final String domain = getParameters().getDomain();
    final ExternalId id = getParameters().getId();
    final LdapBroker broker = LdapFactory.getInstance(domain);
    final LdapGroup group = (LdapGroup) broker.RunAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(domain, id)).getReturnValue();
    getQueryReturnValue().setReturnValue(group);
}
#method_after
@Override
protected void executeQueryCommand() {
    final String domain = getParameters().getDomain();
    final ExternalId id = getParameters().getId();
    final LdapBroker broker = LdapFactory.getInstance(domain);
    final LdapGroup group = (LdapGroup) broker.runAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(domain, id)).getReturnValue();
    getQueryReturnValue().setReturnValue(group);
}
#end_block

#method_before
@Override
public Response add(Group group) {
    validateParameters(group, "name");
    if (!isNameContainsDomain(group)) {
        validateParameters(group, "domain.id|name");
    }
    String domain = getDomain(group);
    LdapGroup directoryGroup = getEntity(LdapGroup.class, SearchType.AdGroup, getDirectoryGroupSearchPattern(group.getName(), domain));
    if (directoryGroup == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such group: " + group.getName() + " in domain " + domain).build();
    }
    DirectoryIdParameters parameters = new DirectoryIdParameters();
    parameters.setDirectory(directoryGroup.getdomain());
    parameters.setId(directoryGroup.getid());
    QueryIdResolver<Guid> resolver = new QueryIdResolver<>(VdcQueryType.GetDbGroupById, IdQueryParameters.class);
    return performCreate(VdcActionType.AddGroup, parameters, resolver, BaseResource.class);
}
#method_after
@Override
public Response add(Group group) {
    validateParameters(group, "name");
    if (!isNameContainsDomain(group)) {
        validateParameters(group, "domain.id|name");
    }
    String directoryName = getDirectoryName(group);
    LdapGroup directoryGroup = findDirectoryGroup(directoryName, group);
    if (directoryGroup == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such group: " + group.getName() + " in directory " + directoryName).build();
    }
    DirectoryIdParameters parameters = new DirectoryIdParameters();
    parameters.setDirectory(directoryName);
    parameters.setId(directoryGroup.getid());
    QueryIdResolver<Guid> resolver = new QueryIdResolver<>(VdcQueryType.GetDbGroupById, IdQueryParameters.class);
    return performCreate(VdcActionType.AddGroup, parameters, resolver, BaseResource.class);
}
#end_block

#method_before
@Override
protected void verifyModel(Group model, int index) {
    assertArrayEquals(EXTERNAL_IDS[index].getBytes(), model.getExternalId());
    assertEquals(NAMES[index], model.getName());
}
#method_after
@Override
protected void verifyModel(Group model, int index) {
    assertEquals(EXTERNAL_IDS[index].toHex(), model.getExternalId());
    assertEquals(NAMES[index], model.getName());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    String directory = getParameters().getDirectory();
    ExternalId id = getParameters().getId();
    directoryGroup = (LdapGroup) LdapFactory.getInstance(directory).RunAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(directory, id)).getReturnValue();
    if (directoryGroup == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    addCustomValue("NewUserName", directoryGroup.getname());
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    String directory = getParameters().getDirectory();
    ExternalId id = getParameters().getId();
    directoryGroup = (LdapGroup) LdapFactory.getInstance(directory).runAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(directory, id)).getReturnValue();
    if (directoryGroup == null) {
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    addCustomValue("NewUserName", directoryGroup.getname());
    return true;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    String domain = getParameters().getDomain();
    ExternalId id = getParameters().getId();
    LdapBroker broker = LdapFactory.getInstance(domain);
    LdapUser user = (LdapUser) broker.RunAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(domain, id)).getReturnValue();
    getQueryReturnValue().setReturnValue(user);
}
#method_after
@Override
protected void executeQueryCommand() {
    String domain = getParameters().getDomain();
    ExternalId id = getParameters().getId();
    LdapBroker broker = LdapFactory.getInstance(domain);
    LdapUser user = (LdapUser) broker.runAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(domain, id)).getReturnValue();
    getQueryReturnValue().setReturnValue(user);
}
#end_block

#method_before
private void getAttachedTagsToSelectedUsers(TagListModel model) {
    ArrayList<Guid> userIds = new ArrayList<Guid>();
    ArrayList<Guid> grpIds = new ArrayList<Guid>();
    attachedTagsToEntities = new HashMap<Guid, Boolean>();
    allAttachedTags = new ArrayList<org.ovirt.engine.core.common.businessentities.tags>();
    selectedItemsCounter = 0;
    for (Object item : getSelectedItems()) {
        DbUser user = (DbUser) item;
        if (!user.isGroup()) {
            userIds.add(user.getId());
        } else {
            grpIds.add(user.getId());
        }
    }
    for (Guid userId : userIds) {
        AsyncDataProvider.getAttachedTagsToUser(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                UserListModel userListModel = (UserListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                userListModel.allAttachedTags.addAll((ArrayList<org.ovirt.engine.core.common.businessentities.tags>) returnValue);
                userListModel.selectedItemsCounter++;
                if (userListModel.selectedItemsCounter == userListModel.getSelectedItems().size()) {
                    postGetAttachedTags(userListModel, tagListModel);
                }
            }
        }), userId);
    }
    for (Guid grpId : grpIds) {
        AsyncDataProvider.getAttachedTagsToUserGroup(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                UserListModel userListModel = (UserListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                userListModel.allAttachedTags.addAll((ArrayList<org.ovirt.engine.core.common.businessentities.tags>) returnValue);
                userListModel.selectedItemsCounter++;
                if (userListModel.selectedItemsCounter == userListModel.getSelectedItems().size()) {
                    postGetAttachedTags(userListModel, tagListModel);
                }
            }
        }), grpId);
    }
}
#method_after
private void getAttachedTagsToSelectedUsers(TagListModel model) {
    ArrayList<Guid> userIds = new ArrayList<Guid>();
    ArrayList<Guid> grpIds = new ArrayList<Guid>();
    attachedTagsToEntities = new HashMap<Guid, Boolean>();
    allAttachedTags = new ArrayList<Tags>();
    selectedItemsCounter = 0;
    for (Object item : getSelectedItems()) {
        DbUser user = (DbUser) item;
        if (!user.isGroup()) {
            userIds.add(user.getId());
        } else {
            grpIds.add(user.getId());
        }
    }
    for (Guid userId : userIds) {
        AsyncDataProvider.getAttachedTagsToUser(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                UserListModel userListModel = (UserListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                userListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                userListModel.selectedItemsCounter++;
                if (userListModel.selectedItemsCounter == userListModel.getSelectedItems().size()) {
                    postGetAttachedTags(userListModel, tagListModel);
                }
            }
        }), userId);
    }
    for (Guid grpId : grpIds) {
        AsyncDataProvider.getAttachedTagsToUserGroup(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Object[] array = (Object[]) target;
                UserListModel userListModel = (UserListModel) array[0];
                TagListModel tagListModel = (TagListModel) array[1];
                userListModel.allAttachedTags.addAll((ArrayList<Tags>) returnValue);
                userListModel.selectedItemsCounter++;
                if (userListModel.selectedItemsCounter == userListModel.getSelectedItems().size()) {
                    postGetAttachedTags(userListModel, tagListModel);
                }
            }
        }), grpId);
    }
}
#end_block

#method_before
private void postGetAttachedTags(UserListModel userListModel, TagListModel tagListModel) {
    if (userListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<org.ovirt.engine.core.common.businessentities.tags> attachedTags = Linq.distinct(userListModel.allAttachedTags, new TagsEqualityComparer());
        for (org.ovirt.engine.core.common.businessentities.tags a : attachedTags) {
            int count = 0;
            for (org.ovirt.engine.core.common.businessentities.tags b : allAttachedTags) {
                if (b.gettag_id().equals(a.gettag_id())) {
                    count++;
                }
            }
            userListModel.attachedTagsToEntities.put(a.gettag_id(), count == userListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(userListModel.attachedTagsToEntities);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(userListModel.getLastExecutedCommand().getName(), "OnAssignTags")) {
        userListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#method_after
private void postGetAttachedTags(UserListModel userListModel, TagListModel tagListModel) {
    if (userListModel.getLastExecutedCommand() == getAssignTagsCommand()) {
        ArrayList<Tags> attachedTags = Linq.distinct(userListModel.allAttachedTags, new TagsEqualityComparer());
        for (Tags a : attachedTags) {
            int count = 0;
            for (Tags b : allAttachedTags) {
                if (b.gettag_id().equals(a.gettag_id())) {
                    count++;
                }
            }
            userListModel.attachedTagsToEntities.put(a.gettag_id(), count == userListModel.getSelectedItems().size());
        }
        tagListModel.setAttachedTagsToEntities(userListModel.attachedTagsToEntities);
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(userListModel.getLastExecutedCommand().getName(), "OnAssignTags")) {
        userListModel.postOnAssignTags(tagListModel.getAttachedTagsToEntities());
    }
}
#end_block

#method_before
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> userIds = new ArrayList<Guid>();
    ArrayList<Guid> grpIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        DbUser user = (DbUser) item;
        if (user.isGroup()) {
            grpIds.add(user.getId());
        } else {
            userIds.add(user.getId());
        }
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<Guid>();
    ArrayList<Guid> tagsToDetach = new ArrayList<Guid>();
    if (model.getItems() != null && ((ArrayList<TagModel>) model.getItems()).size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<VdcActionParametersBase> usersToAttach = new ArrayList<VdcActionParametersBase>();
    ArrayList<VdcActionParametersBase> grpsToAttach = new ArrayList<VdcActionParametersBase>();
    for (Guid tag_id : tagsToAttach) {
        if (userIds.size() > 0) {
            usersToAttach.add(new AttachEntityToTagParameters(tag_id, userIds));
        }
        if (grpIds.size() > 0) {
            grpsToAttach.add(new AttachEntityToTagParameters(tag_id, grpIds));
        }
    }
    if (usersToAttach.size() > 0) {
        Frontend.RunMultipleAction(VdcActionType.AttachUserToTag, usersToAttach);
    }
    if (grpsToAttach.size() > 0) {
        Frontend.RunMultipleAction(VdcActionType.AttachUserGroupToTag, grpsToAttach);
    }
    ArrayList<VdcActionParametersBase> usersToDetach = new ArrayList<VdcActionParametersBase>();
    ArrayList<VdcActionParametersBase> grpsToDetach = new ArrayList<VdcActionParametersBase>();
    for (Guid tag_id : tagsToDetach) {
        if (userIds.size() > 0) {
            usersToDetach.add(new AttachEntityToTagParameters(tag_id, userIds));
        }
        if (grpIds.size() > 0) {
            grpsToDetach.add(new AttachEntityToTagParameters(tag_id, grpIds));
        }
    }
    if (usersToDetach.size() > 0) {
        Frontend.RunMultipleAction(VdcActionType.DetachUserFromTag, usersToDetach);
    }
    if (grpsToDetach.size() > 0) {
        Frontend.RunMultipleAction(VdcActionType.DetachUserGroupFromTag, grpsToDetach);
    }
    cancel();
}
#method_after
public void postOnAssignTags(Map<Guid, Boolean> attachedTags) {
    TagListModel model = (TagListModel) getWindow();
    ArrayList<Guid> userIds = new ArrayList<Guid>();
    ArrayList<Guid> grpIds = new ArrayList<Guid>();
    for (Object item : getSelectedItems()) {
        DbUser user = (DbUser) item;
        if (user.isGroup()) {
            grpIds.add(user.getId());
        } else {
            userIds.add(user.getId());
        }
    }
    // prepare attach/detach lists
    ArrayList<Guid> tagsToAttach = new ArrayList<Guid>();
    ArrayList<Guid> tagsToDetach = new ArrayList<Guid>();
    if (model.getItems() != null && ((ArrayList<TagModel>) model.getItems()).size() > 0) {
        ArrayList<TagModel> tags = (ArrayList<TagModel>) model.getItems();
        TagModel rootTag = tags.get(0);
        TagModel.recursiveEditAttachDetachLists(rootTag, attachedTags, tagsToAttach, tagsToDetach);
    }
    ArrayList<VdcActionParametersBase> usersToAttach = new ArrayList<VdcActionParametersBase>();
    ArrayList<VdcActionParametersBase> grpsToAttach = new ArrayList<VdcActionParametersBase>();
    for (Guid tag_id : tagsToAttach) {
        if (userIds.size() > 0) {
            usersToAttach.add(new AttachEntityToTagParameters(tag_id, userIds));
        }
        if (grpIds.size() > 0) {
            grpsToAttach.add(new AttachEntityToTagParameters(tag_id, grpIds));
        }
    }
    if (usersToAttach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.AttachUserToTag, usersToAttach);
    }
    if (grpsToAttach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.AttachUserGroupToTag, grpsToAttach);
    }
    ArrayList<VdcActionParametersBase> usersToDetach = new ArrayList<VdcActionParametersBase>();
    ArrayList<VdcActionParametersBase> grpsToDetach = new ArrayList<VdcActionParametersBase>();
    for (Guid tag_id : tagsToDetach) {
        if (userIds.size() > 0) {
            usersToDetach.add(new AttachEntityToTagParameters(tag_id, userIds));
        }
        if (grpIds.size() > 0) {
            grpsToDetach.add(new AttachEntityToTagParameters(tag_id, grpIds));
        }
    }
    if (usersToDetach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.DetachUserFromTag, usersToDetach);
    }
    if (grpsToDetach.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.DetachUserGroupFromTag, grpsToDetach);
    }
    cancel();
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeUsersTitle());
    // $NON-NLS-1$
    model.setHashName("remove_user");
    model.setMessage(ConstantsManager.getInstance().getConstants().usersMsg());
    ArrayList<String> list = new ArrayList<String>();
    for (DbUser item : Linq.<DbUser>cast(getSelectedItems())) {
        list.add(item.getFirstName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeUsersTitle());
    // $NON-NLS-1$
    model.setHashName("remove_user");
    ArrayList<String> list = new ArrayList<String>();
    for (DbUser item : Linq.<DbUser>cast(getSelectedItems())) {
        list.add(item.getFirstName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.DBUser);
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#method_after
@Override
protected void syncSearch() {
    SearchParameters tempVar = new SearchParameters(getSearchString(), SearchType.DBUser, isCaseSensitiveSearch());
    tempVar.setMaxCount(getSearchPageSize());
    super.syncSearch(VdcQueryType.Search, tempVar);
}
#end_block

#method_before
public void onAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null) {
        cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    for (Object item : model.getItems()) {
        EntityModel entityModel = (EntityModel) item;
        if (entityModel.getIsSelected()) {
            items.add((DbUser) entityModel.getEntity());
        }
    }
    ArrayList<VdcActionType> actionsList = new ArrayList<VdcActionType>(items.size());
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>(items.size());
    for (DbUser item : items) {
        if (item.isGroup()) {
            actionsList.add(VdcActionType.AddGroup);
        } else {
            actionsList.add(VdcActionType.AddUser);
        }
        DirectoryIdParameters parameters = new DirectoryIdParameters();
        parameters.setDirectory(item.getDomain());
        parameters.setId(item.getExternalId());
        parametersList.add(parameters);
    }
    model.startProgress(null);
    IFrontendActionAsyncCallback nopCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
        // Nothing.
        }
    };
    IFrontendActionAsyncCallback lastCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    };
    ArrayList<IFrontendActionAsyncCallback> callbacksList = new ArrayList<IFrontendActionAsyncCallback>(items.size());
    for (int i = 1; i < items.size(); i++) {
        callbacksList.add(nopCallback);
    }
    callbacksList.add(lastCallback);
    Frontend.RunMultipleActions(actionsList, parametersList, callbacksList, lastCallback, model);
}
#method_after
public void onAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null) {
        cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    for (Object item : model.getItems()) {
        EntityModel entityModel = (EntityModel) item;
        if (entityModel.getIsSelected()) {
            items.add((DbUser) entityModel.getEntity());
        }
    }
    ArrayList<VdcActionType> actionsList = new ArrayList<VdcActionType>(items.size());
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>(items.size());
    for (DbUser item : items) {
        if (item.isGroup()) {
            actionsList.add(VdcActionType.AddGroup);
        } else {
            actionsList.add(VdcActionType.AddUser);
        }
        DirectoryIdParameters parameters = new DirectoryIdParameters();
        parameters.setDirectory(item.getDomain());
        parameters.setId(item.getExternalId());
        parametersList.add(parameters);
    }
    model.startProgress(null);
    IFrontendActionAsyncCallback nopCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
        // Nothing.
        }
    };
    IFrontendActionAsyncCallback lastCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    };
    ArrayList<IFrontendActionAsyncCallback> callbacksList = new ArrayList<IFrontendActionAsyncCallback>(items.size());
    for (int i = 1; i < items.size(); i++) {
        callbacksList.add(nopCallback);
    }
    callbacksList.add(lastCallback);
    Frontend.getInstance().runMultipleActions(actionsList, parametersList, callbacksList, lastCallback, model);
}
#end_block

#method_before
public void onRemove() {
    ArrayList<DbUser> items = Linq.<DbUser>cast(getSelectedItems());
    ArrayList<VdcActionParametersBase> userPrms = new ArrayList<VdcActionParametersBase>();
    ArrayList<VdcActionParametersBase> groupPrms = new ArrayList<VdcActionParametersBase>();
    for (DbUser item : items) {
        if (!item.isGroup()) {
            userPrms.add(new IdParameters(item.getId()));
        } else {
            groupPrms.add(new IdParameters(item.getId()));
        }
    }
    if (userPrms.size() > 0) {
        Frontend.RunMultipleAction(VdcActionType.RemoveUser, userPrms);
    }
    if (groupPrms.size() > 0) {
        Frontend.RunMultipleAction(VdcActionType.RemoveGroup, groupPrms);
    }
    cancel();
}
#method_after
public void onRemove() {
    ArrayList<DbUser> items = Linq.<DbUser>cast(getSelectedItems());
    ArrayList<VdcActionParametersBase> userPrms = new ArrayList<VdcActionParametersBase>();
    ArrayList<VdcActionParametersBase> groupPrms = new ArrayList<VdcActionParametersBase>();
    for (DbUser item : items) {
        if (!item.isGroup()) {
            userPrms.add(new IdParameters(item.getId()));
        } else {
            groupPrms.add(new IdParameters(item.getId()));
        }
    }
    if (userPrms.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.RemoveUser, userPrms);
    }
    if (groupPrms.size() > 0) {
        Frontend.getInstance().runMultipleAction(VdcActionType.RemoveGroup, groupPrms);
    }
    cancel();
}
#end_block

#method_before
@Override
protected boolean isUserAuthorizedToRunAction() {
    if (log.isDebugEnabled()) {
        log.debugFormat("IsUserAutorizedToRunAction: Login - no permission check");
    }
    return true;
}
#method_after
@Override
protected boolean isUserAuthorizedToRunAction() {
    if (log.isDebugEnabled()) {
        log.debugFormat("IsUserAutorizedToRunAction: login - no permission check");
    }
    return true;
}
#end_block

#method_before
@Override
protected void verifyModel(User model, int index) {
    assertArrayEquals(EXTERNAL_IDS[index].getBytes(), model.getExternalId());
    assertEquals(NAMES[index], model.getName());
}
#method_after
@Override
protected void verifyModel(User model, int index) {
    assertEquals(EXTERNAL_IDS[index].toHex(), model.getExternalId());
    assertEquals(NAMES[index], model.getName());
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((distinguishedName == null) ? 0 : distinguishedName.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + ((memberOf == null) ? 0 : memberOf.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((distinguishedName == null) ? 0 : distinguishedName.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + ((memberOf == null) ? 0 : memberOf.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + (active ? 1231 : 1237);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    LdapGroup other = (LdapGroup) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(distinguishedName, other.distinguishedName) && ObjectUtils.objectsEqual(domain, other.domain) && ObjectUtils.objectsEqual(memberOf, other.memberOf) && ObjectUtils.objectsEqual(name, other.name) && status == other.status);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    LdapGroup other = (LdapGroup) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(distinguishedName, other.distinguishedName) && ObjectUtils.objectsEqual(domain, other.domain) && ObjectUtils.objectsEqual(memberOf, other.memberOf) && ObjectUtils.objectsEqual(name, other.name) && active == other.active);
}
#end_block

#method_before
@Override
public boolean authenticate(String name, String password) {
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.AuthenticateUser, new LdapUserPasswordBaseParameters(domain, name, password));
    UserAuthenticationResult authResult = (UserAuthenticationResult) ldapResult.getReturnValue();
    return authResult.isSuccessful();
}
#method_after
@Override
public AuthenticationResult<?> authenticate(String name, String password) {
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.AuthenticateUser, new LdapUserPasswordBaseParameters(domain, name, password));
    UserAuthenticationResult authResult = (UserAuthenticationResult) ldapResult.getReturnValue();
    return new ProvisionalAuthenticationResult(authResult);
}
#end_block

#method_before
@Override
public DirectoryUser findUser(String name) {
    // Find the user with the old mechanism:
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.GetAdUserByUserName, new LdapSearchByUserNameParameters(null, domain, name + "@" + domain));
    LdapUser ldapUser = (LdapUser) ldapResult.getReturnValue();
    // Map the user:
    return mapUser(ldapUser);
}
#method_after
@Override
public DirectoryUser findUser(String name) {
    // Find the user with the old mechanism:
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.GetAdUserByUserName, new LdapSearchByUserNameParameters(null, domain, name));
    LdapUser ldapUser = (LdapUser) ldapResult.getReturnValue();
    if (ldapUser == null) {
        return null;
    }
    // Map the user:
    return mapUser(ldapUser);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    super.syncSearch();
    IdQueryParameters param = new IdQueryParameters(((Quota) getEntity()).getId());
    param.setRefresh(getIsQueryFirstTime());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            SearchableListModel searchableListModel = (SearchableListModel) model;
            ArrayList<permissions> list = (ArrayList<permissions>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            Map<Guid, permissions> map = new HashMap<Guid, permissions>();
            for (permissions permission : list) {
                // filter out sys-admin and dc admin from consumers sub-tab
                if (permission.getrole_id().equals(ApplicationGuids.superUser.asGuid()) || permission.getrole_id().equals(ApplicationGuids.dataCenterAdmin.asGuid())) {
                    continue;
                }
                if (!map.containsKey(permission.getad_element_id())) {
                    map.put(permission.getad_element_id(), permission);
                } else {
                    if (map.get(permission.getad_element_id()).getrole_id().equals(ApplicationGuids.quotaConsumer.asGuid())) {
                        map.put(permission.getad_element_id(), permission);
                    }
                }
            }
            list.clear();
            for (permissions permission : map.values()) {
                list.add(permission);
            }
            searchableListModel.setItems(list);
        }
    };
    param.setRefresh(getIsQueryFirstTime());
    Frontend.RunQuery(VdcQueryType.GetPermissionsToConsumeQuotaByQuotaId, param, _asyncQuery);
    setIsQueryFirstTime(false);
}
#method_after
@Override
protected void syncSearch() {
    super.syncSearch();
    IdQueryParameters param = new IdQueryParameters(((Quota) getEntity()).getId());
    param.setRefresh(getIsQueryFirstTime());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            SearchableListModel searchableListModel = (SearchableListModel) model;
            ArrayList<Permissions> list = (ArrayList<Permissions>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            Map<Guid, Permissions> map = new HashMap<Guid, Permissions>();
            for (Permissions permission : list) {
                // filter out sys-admin and dc admin from consumers sub-tab
                if (permission.getrole_id().equals(ApplicationGuids.superUser.asGuid()) || permission.getrole_id().equals(ApplicationGuids.dataCenterAdmin.asGuid())) {
                    continue;
                }
                if (!map.containsKey(permission.getad_element_id())) {
                    map.put(permission.getad_element_id(), permission);
                } else {
                    if (map.get(permission.getad_element_id()).getrole_id().equals(ApplicationGuids.quotaConsumer.asGuid())) {
                        map.put(permission.getad_element_id(), permission);
                    }
                }
            }
            list.clear();
            for (Permissions permission : map.values()) {
                list.add(permission);
            }
            searchableListModel.setItems(list);
        }
    };
    param.setRefresh(getIsQueryFirstTime());
    Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsToConsumeQuotaByQuotaId, param, _asyncQuery);
    setIsQueryFirstTime(false);
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<permissions> items = (((ArrayList<permissions>) getSelectedItems()) != null) ? (ArrayList<permissions>) getSelectedItems() : new ArrayList<permissions>();
    boolean removeExe = false;
    if (items.size() > 0) {
        removeExe = true;
    }
    for (permissions perm : items) {
        if (!perm.getrole_id().equals(ApplicationGuids.quotaConsumer.asGuid())) {
            removeExe = false;
            break;
        }
    }
    getRemoveCommand().setIsExecutionAllowed(removeExe);
}
#method_after
private void updateActionAvailability() {
    ArrayList<Permissions> items = (((ArrayList<Permissions>) getSelectedItems()) != null) ? (ArrayList<Permissions>) getSelectedItems() : new ArrayList<Permissions>();
    boolean removeExe = false;
    if (items.size() > 0) {
        removeExe = true;
    }
    for (Permissions perm : items) {
        if (!perm.getrole_id().equals(ApplicationGuids.quotaConsumer.asGuid())) {
            removeExe = false;
            break;
        }
    }
    getRemoveCommand().setIsExecutionAllowed(removeExe);
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeQuotaAssignmentFromUsersTitle());
    // $NON-NLS-1$
    model.setHashName("remove_quota_assignment_from_user");
    model.setMessage(ConstantsManager.getInstance().getConstants().assignmentsMsg());
    ArrayList<String> list = new ArrayList<String>();
    for (permissions item : Linq.<permissions>cast(getSelectedItems())) {
        list.add(item.getOwnerName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeQuotaAssignmentFromUsersTitle());
    // $NON-NLS-1$
    model.setHashName("remove_quota_assignment_from_user");
    ArrayList<String> list = new ArrayList<String>();
    for (Permissions item : Linq.<Permissions>cast(getSelectedItems())) {
        list.add(item.getOwnerName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void onAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null && !model.getIsEveryoneSelected()) {
        cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    if (model.getIsEveryoneSelected()) {
        DbUser tempVar = new DbUser();
        tempVar.setId(ApplicationGuids.everyone.asGuid());
        items.add(tempVar);
    } else {
        for (Object item : model.getItems()) {
            EntityModel entityModel = (EntityModel) item;
            if (entityModel.getIsSelected()) {
                items.add((DbUser) entityModel.getEntity());
            }
        }
    }
    model.startProgress(null);
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    PermissionsOperationsParameters permissionParams;
    for (DbUser user : items) {
        permissions tempVar2 = new permissions();
        tempVar2.setad_element_id(user.getId());
        tempVar2.setrole_id(ApplicationGuids.quotaConsumer.asGuid());
        permissions perm = tempVar2;
        perm.setObjectId(((Quota) getEntity()).getId());
        perm.setObjectType(VdcObjectType.Quota);
        permissionParams = new PermissionsOperationsParameters();
        if (user.isGroup()) {
            DbGroup group = new DbGroup();
            group.setId(user.getId());
            group.setName(user.getFirstName());
            group.setDomain(user.getDomain());
            permissionParams.setGroup(group);
        } else {
            permissionParams.setUser(user);
        }
        permissionParams.setPermission(perm);
        list.add(permissionParams);
    }
    Frontend.RunMultipleAction(VdcActionType.AddPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            QuotaUserListModel localModel = (QuotaUserListModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
    cancel();
}
#method_after
public void onAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null && !model.getIsEveryoneSelected()) {
        cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    if (model.getIsEveryoneSelected()) {
        DbUser tempVar = new DbUser();
        tempVar.setId(ApplicationGuids.everyone.asGuid());
        items.add(tempVar);
    } else {
        for (Object item : model.getItems()) {
            EntityModel entityModel = (EntityModel) item;
            if (entityModel.getIsSelected()) {
                items.add((DbUser) entityModel.getEntity());
            }
        }
    }
    model.startProgress(null);
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    PermissionsOperationsParameters permissionParams;
    for (DbUser user : items) {
        Permissions tempVar2 = new Permissions();
        tempVar2.setad_element_id(user.getId());
        tempVar2.setrole_id(ApplicationGuids.quotaConsumer.asGuid());
        Permissions perm = tempVar2;
        perm.setObjectId(((Quota) getEntity()).getId());
        perm.setObjectType(VdcObjectType.Quota);
        permissionParams = new PermissionsOperationsParameters();
        if (user.isGroup()) {
            DbGroup group = new DbGroup();
            group.setId(user.getId());
            group.setName(user.getFirstName());
            group.setDomain(user.getDomain());
            permissionParams.setGroup(group);
        } else {
            permissionParams.setUser(user);
        }
        permissionParams.setPermission(perm);
        list.add(permissionParams);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AddPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            QuotaUserListModel localModel = (QuotaUserListModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
    cancel();
}
#end_block

#method_before
private void onRemove() {
    if (getSelectedItems() != null && getSelectedItems().size() > 0) {
        ConfirmationModel model = (ConfirmationModel) getWindow();
        if (model.getProgress() != null) {
            return;
        }
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object perm : getSelectedItems()) {
            PermissionsOperationsParameters tempVar = new PermissionsOperationsParameters();
            tempVar.setPermission((permissions) perm);
            list.add(tempVar);
        }
        model.startProgress(null);
        Frontend.RunMultipleAction(VdcActionType.RemovePermission, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ConfirmationModel localModel = (ConfirmationModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
    cancel();
}
#method_after
private void onRemove() {
    if (getSelectedItems() != null && getSelectedItems().size() > 0) {
        ConfirmationModel model = (ConfirmationModel) getWindow();
        if (model.getProgress() != null) {
            return;
        }
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object perm : getSelectedItems()) {
            PermissionsOperationsParameters tempVar = new PermissionsOperationsParameters();
            tempVar.setPermission((Permissions) perm);
            list.add(tempVar);
        }
        model.startProgress(null);
        Frontend.getInstance().runMultipleAction(VdcActionType.RemovePermission, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ConfirmationModel localModel = (ConfirmationModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
    cancel();
}
#end_block

#method_before
@Test
public void testAddGroupPermission() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpCreationExpectations(VdcActionType.AddPermission, PermissionsOperationsParameters.class, new String[] { "Group.Id", "Permission.ad_element_id", "Permission.ObjectId", "Permission.role_id" }, new Object[] { GUIDS[1], GUIDS[1], GUIDS[2], GUIDS[3] }, true, true, GUIDS[0], VdcQueryType.GetPermissionById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Permission model = new Permission();
    model.setRole(new Role());
    model.getRole().setId(GUIDS[3].toString());
    model.setGroup(new Group());
    model.getGroup().setId(GUIDS[1].toString());
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Permission);
    verifyModel((Permission) response.getEntity(), 0);
}
#method_after
@Test
public void testAddGroupPermission() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpCreationExpectations(VdcActionType.AddPermission, PermissionsOperationsParameters.class, new String[] { "Group.Id", "Permission.ad_element_id", "Permission.ObjectId", "Permission.role_id" }, new Object[] { GUIDS[1], GUIDS[1], targetId, GUIDS[3] }, true, true, GUIDS[0], VdcQueryType.GetPermissionById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Permission model = new Permission();
    model.setRole(new Role());
    model.getRole().setId(GUIDS[3].toString());
    model.setGroup(new Group());
    model.getGroup().setId(GUIDS[1].toString());
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Permission);
    verifyModel((Permission) response.getEntity(), 0);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    VdcObjectType objType = getObjectType();
    boolean directOnly = (objType == VdcObjectType.VM ? true : false);
    GetPermissionsForObjectParameters tempVar = new GetPermissionsForObjectParameters();
    tempVar.setObjectId(getEntityGuid());
    tempVar.setVdcObjectType(objType);
    tempVar.setDirectOnly(directOnly);
    tempVar.setRefresh(getIsQueryFirstTime());
    super.syncSearch(VdcQueryType.GetPermissionsForObject, tempVar);
}
#method_after
@Override
protected void syncSearch() {
    VdcObjectType objType = getObjectType();
    boolean directOnly = (objType == VdcObjectType.VM ? true : false);
    GetPermissionsForObjectParameters tempVar = new GetPermissionsForObjectParameters();
    tempVar.setObjectId(getEntityGuid());
    tempVar.setVdcObjectType(objType);
    tempVar.setDirectOnly(directOnly);
    tempVar.setRefresh(getIsQueryFirstTime());
    tempVar.setAllUsersWithPermission(getAllUsersWithPermission());
    super.syncSearch(VdcQueryType.GetPermissionsForObject, tempVar);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removePermissionTitle());
    // $NON-NLS-1$
    model.setHashName("remove_permission");
    model.setMessage(ConstantsManager.getInstance().getConstants().permissionMsg());
    model.setItems(getSelectedItems());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removePermissionTitle());
    // $NON-NLS-1$
    model.setHashName("remove_permission");
    model.setItems(getSelectedItems());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onRemove() {
    if (getSelectedItems() != null && getSelectedItems().size() > 0) {
        ConfirmationModel model = (ConfirmationModel) getWindow();
        if (model.getProgress() != null) {
            return;
        }
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object perm : getSelectedItems()) {
            PermissionsOperationsParameters tempVar = new PermissionsOperationsParameters();
            tempVar.setPermission((permissions) perm);
            list.add(tempVar);
        }
        model.startProgress(null);
        Frontend.RunMultipleAction(VdcActionType.RemovePermission, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ConfirmationModel localModel = (ConfirmationModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#method_after
private void onRemove() {
    if (getSelectedItems() != null && getSelectedItems().size() > 0) {
        ConfirmationModel model = (ConfirmationModel) getWindow();
        if (model.getProgress() != null) {
            return;
        }
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object perm : getSelectedItems()) {
            PermissionsOperationsParameters tempVar = new PermissionsOperationsParameters();
            tempVar.setPermission((Permissions) perm);
            list.add(tempVar);
        }
        model.startProgress(null);
        Frontend.getInstance().runMultipleAction(VdcActionType.RemovePermission, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ConfirmationModel localModel = (ConfirmationModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#end_block

#method_before
private void onAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.getIsEveryoneSelected() && model.getSelectedItems() == null) {
        cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    if (model.getIsEveryoneSelected()) {
        DbUser tempVar = new DbUser();
        tempVar.setId(ApplicationGuids.everyone.asGuid());
        items.add(tempVar);
    } else {
        for (Object item : model.getItems()) {
            EntityModel entityModel = (EntityModel) item;
            if (entityModel.getIsSelected()) {
                items.add((DbUser) entityModel.getEntity());
            }
        }
    }
    Role role = (Role) model.getRole().getSelectedItem();
    // adGroup/user
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (DbUser user : items) {
        permissions tempVar2 = new permissions();
        tempVar2.setad_element_id(user.getId());
        tempVar2.setrole_id(role.getId());
        permissions perm = tempVar2;
        perm.setObjectId(getEntityGuid());
        perm.setObjectType(this.getObjectType());
        if (user.isGroup()) {
            DbGroup group = new DbGroup();
            group.setId(user.getId());
            group.setName(user.getFirstName());
            group.setDomain(user.getDomain());
            PermissionsOperationsParameters tempVar3 = new PermissionsOperationsParameters();
            tempVar3.setPermission(perm);
            tempVar3.setGroup(group);
            list.add(tempVar3);
        } else {
            PermissionsOperationsParameters tempVar4 = new PermissionsOperationsParameters();
            tempVar4.setPermission(perm);
            tempVar4.setUser(user);
            list.add(tempVar4);
        }
    }
    model.startProgress(null);
    Frontend.RunMultipleAction(VdcActionType.AddPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.getIsEveryoneSelected() && model.getSelectedItems() == null) {
        cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    if (model.getIsEveryoneSelected()) {
        DbUser tempVar = new DbUser();
        tempVar.setId(ApplicationGuids.everyone.asGuid());
        items.add(tempVar);
    } else {
        for (Object item : model.getItems()) {
            EntityModel entityModel = (EntityModel) item;
            if (entityModel.getIsSelected()) {
                items.add((DbUser) entityModel.getEntity());
            }
        }
    }
    Role role = (Role) model.getRole().getSelectedItem();
    // adGroup/user
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (DbUser user : items) {
        Permissions tempVar2 = new Permissions();
        tempVar2.setad_element_id(user.getId());
        tempVar2.setrole_id(role.getId());
        Permissions perm = tempVar2;
        perm.setObjectId(getEntityGuid());
        perm.setObjectType(this.getObjectType());
        if (user.isGroup()) {
            DbGroup group = new DbGroup();
            group.setId(user.getId());
            group.setName(user.getFirstName());
            group.setDomain(user.getDomain());
            PermissionsOperationsParameters tempVar3 = new PermissionsOperationsParameters();
            tempVar3.setPermission(perm);
            tempVar3.setGroup(group);
            list.add(tempVar3);
        } else {
            PermissionsOperationsParameters tempVar4 = new PermissionsOperationsParameters();
            tempVar4.setPermission(perm);
            tempVar4.setUser(user);
            list.add(tempVar4);
        }
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.AddPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
@Override
protected void entityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.entityPropertyChanged(sender, e);
    if (// $NON-NLS-1$
    e.PropertyName.equals("status")) {
        updateActionAvailability();
    }
}
#method_after
@Override
protected void entityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.entityPropertyChanged(sender, e);
    if (// $NON-NLS-1$
    e.propertyName.equals("status")) {
        updateActionAvailability();
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    getRemoveCommand().setIsExecutionAllowed((getSelectedItems() != null && getSelectedItems().size() > 0));
    if (getRemoveCommand().getIsExecutionAllowed() == false) {
        return;
    }
    Guid entityGuid = getEntityGuid();
    for (Object p : getSelectedItems()) {
        if (!entityGuid.equals(((permissions) p).getObjectId())) {
            getRemoveCommand().setIsExecutionAllowed(false);
            return;
        }
    }
}
#method_after
private void updateActionAvailability() {
    getRemoveCommand().setIsExecutionAllowed((getSelectedItems() != null && getSelectedItems().size() > 0));
    if (getRemoveCommand().getIsExecutionAllowed() == false) {
        return;
    }
    Guid entityGuid = getEntityGuid();
    for (Object p : getSelectedItems()) {
        if (!entityGuid.equals(((Permissions) p).getObjectId())) {
            getRemoveCommand().setIsExecutionAllowed(false);
            return;
        }
    }
}
#end_block

#method_before
public permissions getPermission() {
    return permission;
}
#method_after
public Permissions getPermission() {
    return permission;
}
#end_block

#method_before
public void setPermission(permissions value) {
    permission = value;
}
#method_after
public void setPermission(Permissions value) {
    permission = value;
}
#end_block

#method_before
@Override
public Permissions list() {
    Set<permissions> permissions = new TreeSet<permissions>(new PermissionsComparator());
    List<permissions> directPermissions = getBackendCollection(queryType, queryParams);
    permissions.addAll(directPermissions);
    if (queryType.equals(VdcQueryType.GetPermissionsForObject)) {
        permissions.addAll(getInheritedPermissions());
    }
    return mapCollection(permissions);
}
#method_after
@Override
public org.ovirt.engine.api.model.Permissions list() {
    Set<Permissions> permissions = new TreeSet<Permissions>(new PermissionsComparator());
    List<Permissions> directPermissions = getBackendCollection(queryType, queryParams);
    permissions.addAll(directPermissions);
    if (queryType.equals(VdcQueryType.GetPermissionsForObject)) {
        permissions.addAll(getInheritedPermissions());
    }
    return mapCollection(permissions);
}
#end_block

#method_before
private List<permissions> getInheritedPermissions() {
    ((GetPermissionsForObjectParameters) queryParams).setVdcObjectType(objectType);
    ((GetPermissionsForObjectParameters) queryParams).setDirectOnly(false);
    List<permissions> inheritedPermissions = getBackendCollection(queryType, queryParams);
    for (permissions entity : inheritedPermissions) {
        if (objectType != null) {
            entity.setObjectType(objectType);
            entity.setObjectId(targetId);
        }
    }
    return inheritedPermissions;
}
#method_after
private List<Permissions> getInheritedPermissions() {
    ((GetPermissionsForObjectParameters) queryParams).setVdcObjectType(objectType);
    ((GetPermissionsForObjectParameters) queryParams).setDirectOnly(false);
    List<Permissions> inheritedPermissions = getBackendCollection(queryType, queryParams);
    for (Permissions entity : inheritedPermissions) {
        if (objectType != null) {
            entity.setObjectType(objectType);
            entity.setObjectId(targetId);
        }
    }
    return inheritedPermissions;
}
#end_block

#method_before
@Override
public int compare(permissions o1, permissions o2) {
    String id1 = o1.getId().toString();
    String id2 = o2.getId().toString();
    return id1.compareTo(id2);
}
#method_after
@Override
public int compare(Permissions o1, Permissions o2) {
    String id1 = o1.getId().toString();
    String id2 = o2.getId().toString();
    return id1.compareTo(id2);
}
#end_block

#method_before
@Override
public Response add(Permission permission) {
    validateParameters(permission, isPrincipalSubCollection() ? new String[] { "role.id", "dataCenter|cluster|host|storageDomain|vm|vmpool|template.id" } : new String[] { "role.id", "user|group.id" });
    permissions entity = map(permission, getPermissionsTemplate(permission));
    return performCreate(VdcActionType.AddPermission, getPrincipal(entity, permission), new QueryIdResolver<Guid>(VdcQueryType.GetPermissionById, IdQueryParameters.class));
}
#method_after
@Override
public Response add(Permission permission) {
    validateParameters(permission, isPrincipalSubCollection() ? new String[] { "role.id", "dataCenter|cluster|host|storageDomain|vm|vmpool|template.id" } : new String[] { "role.id", "user|group.id" });
    Permissions entity = map(permission, getPermissionsTemplate(permission));
    return performCreate(VdcActionType.AddPermission, getPrincipal(entity, permission), new QueryIdResolver<Guid>(VdcQueryType.GetPermissionById, IdQueryParameters.class));
}
#end_block

#method_before
protected Permissions mapCollection(Set<permissions> entities) {
    Permissions collection = new Permissions();
    for (permissions entity : entities) {
        castEveryonePermissionsToUser(entity);
        Permission permission = map(entity, getUserById(entity.getad_element_id()));
        collection.getPermissions().add(addLinks(permission, permission.getUser() != null ? suggestedParentType : Group.class));
    }
    return collection;
}
#method_after
protected org.ovirt.engine.api.model.Permissions mapCollection(Set<Permissions> entities) {
    org.ovirt.engine.api.model.Permissions collection = new org.ovirt.engine.api.model.Permissions();
    for (Permissions entity : entities) {
        castEveryonePermissionsToUser(entity);
        Permission permission = map(entity, getUserById(entity.getad_element_id()));
        collection.getPermissions().add(addLinks(permission, permission.getUser() != null ? suggestedParentType : Group.class));
    }
    return collection;
}
#end_block

#method_before
private void castEveryonePermissionsToUser(permissions entity) {
    if (entity.getad_element_id() != null && entity.getad_element_id().equals(Guid.EVERYONE) && queryType.equals(VdcQueryType.GetPermissionsByAdElementId)) {
        entity.setad_element_id(this.targetId);
    }
}
#method_after
private void castEveryonePermissionsToUser(Permissions entity) {
    if (entity.getad_element_id() != null && entity.getad_element_id().equals(Guid.EVERYONE) && queryType.equals(VdcQueryType.GetPermissionsByAdElementId)) {
        entity.setad_element_id(this.targetId);
    }
}
#end_block

#method_before
public Permission map(permissions entity, DbUser user) {
    Permission template = new Permission();
    if (entity.getad_element_id() != null) {
        if (isUser(user)) {
            template.setUser(new User());
            template.getUser().setId(entity.getad_element_id().toString());
        } else {
            template.setGroup(new Group());
            template.getGroup().setId(entity.getad_element_id().toString());
        }
    }
    return map(entity, template);
}
#method_after
public Permission map(Permissions entity, DbUser user) {
    Permission template = new Permission();
    if (entity.getad_element_id() != null) {
        if (isUser(user)) {
            template.setUser(new User());
            template.getUser().setId(entity.getad_element_id().toString());
        } else {
            template.setGroup(new Group());
            template.getGroup().setId(entity.getad_element_id().toString());
        }
    }
    return map(entity, template);
}
#end_block

#method_before
protected PermissionsOperationsParameters getPrincipal(permissions entity, Permission permission) {
    PermissionsOperationsParameters ret = null;
    if (isUserSubCollection() || permission.isSetUser()) {
        DbUser user = new DbUser();
        user.setId(isUserSubCollection() ? targetId : asGuid(permission.getUser().getId()));
        user.setDomain(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParameters(entity, user);
    } else if (isGroupSubCollection() || permission.isSetGroup()) {
        DbGroup group = new DbGroup();
        group.setId(isGroupSubCollection() ? targetId : asGuid(permission.getGroup().getId()));
        group.setDomain(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParameters(entity, group);
    }
    return ret;
}
#method_after
protected PermissionsOperationsParameters getPrincipal(Permissions entity, Permission permission) {
    PermissionsOperationsParameters ret = null;
    if (isUserSubCollection() || permission.isSetUser()) {
        DbUser user = new DbUser();
        user.setId(isUserSubCollection() ? targetId : asGuid(permission.getUser().getId()));
        user.setDomain(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParameters(entity, user);
    } else if (isGroupSubCollection() || permission.isSetGroup()) {
        DbGroup group = new DbGroup();
        group.setId(isGroupSubCollection() ? targetId : asGuid(permission.getGroup().getId()));
        group.setDomain(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParameters(entity, group);
    }
    return ret;
}
#end_block

#method_before
protected permissions getPermissionsTemplate(Permission perm) {
    permissions permission = new permissions();
    // representation
    if (isPrincipalSubCollection()) {
        permission.setad_element_id(targetId);
        permission.setObjectId(getMapper(Permission.class, Guid.class).map(perm, null));
    } else {
        if (perm.getUser() != null) {
            permission.setad_element_id(asGuid(perm.getUser().getId()));
        } else {
            // if user is null, group is not null; this was validated before
            permission.setad_element_id(asGuid(perm.getGroup().getId()));
        }
        permission.setObjectId(targetId);
        permission.setObjectType(objectType);
    }
    return permission;
}
#method_after
protected Permissions getPermissionsTemplate(Permission perm) {
    Permissions permission = new Permissions();
    // representation
    if (isPrincipalSubCollection()) {
        permission.setad_element_id(targetId);
        permission.setObjectId(getMapper(Permission.class, Guid.class).map(perm, null));
    } else {
        if (perm.getUser() != null) {
            permission.setad_element_id(asGuid(perm.getUser().getId()));
        } else {
            // if user is null, group is not null; this was validated before
            permission.setad_element_id(asGuid(perm.getGroup().getId()));
        }
        permission.setObjectId(targetId);
        permission.setObjectType(objectType);
    }
    return permission;
}
#end_block

#method_before
protected permissions getPermissions(String id) {
    return getEntity(permissions.class, VdcQueryType.GetPermissionById, new IdQueryParameters(new Guid(id)), id);
}
#method_after
protected Permissions getPermissions(String id) {
    return getEntity(Permissions.class, VdcQueryType.GetPermissionById, new IdQueryParameters(new Guid(id)), id);
}
#end_block

#method_before
@Override
protected Permission doPopulate(Permission model, permissions entity) {
    return model;
}
#method_after
@Override
protected Permission doPopulate(Permission model, Permissions entity) {
    return model;
}
#end_block

#method_before
@Override
protected void syncSearch() {
    super.syncSearch();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            SystemPermissionListModel systemPermissionListModel = (SystemPermissionListModel) model;
            systemPermissionListModel.setItems((Iterable) ((VdcQueryReturnValue) ReturnValue).getReturnValue());
        }
    };
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setRefresh(false);
    Frontend.RunQuery(VdcQueryType.GetSystemPermissions, params, _asyncQuery);
}
#method_after
@Override
protected void syncSearch() {
    super.syncSearch();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            SystemPermissionListModel systemPermissionListModel = (SystemPermissionListModel) model;
            systemPermissionListModel.setItems((Iterable) ((VdcQueryReturnValue) ReturnValue).getReturnValue());
        }
    };
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setRefresh(false);
    Frontend.getInstance().runQuery(VdcQueryType.GetSystemPermissions, params, _asyncQuery);
}
#end_block

#method_before
private void onAttach() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null) {
        cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    for (Object item : model.getItems()) {
        EntityModel entityModel = (EntityModel) item;
        if (entityModel.getIsSelected()) {
            items.add((DbUser) entityModel.getEntity());
        }
    }
    Role role = (Role) model.getRole().getSelectedItem();
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (DbUser user : items) {
        permissions tempVar = new permissions();
        tempVar.setad_element_id(user.getId());
        tempVar.setrole_id(role.getId());
        permissions perm = tempVar;
        if (user.isGroup()) {
            DbGroup group = new DbGroup();
            group.setId(user.getId());
            group.setName(user.getFirstName());
            group.setDomain(user.getDomain());
            PermissionsOperationsParameters tempVar2 = new PermissionsOperationsParameters();
            tempVar2.setPermission(perm);
            tempVar2.setGroup(group);
            list.add(tempVar2);
        } else {
            PermissionsOperationsParameters tempVar3 = new PermissionsOperationsParameters();
            tempVar3.setPermission(perm);
            tempVar3.setUser(user);
            list.add(tempVar3);
        }
    }
    model.startProgress(null);
    Frontend.RunMultipleAction(VdcActionType.AddSystemPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onAttach() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null) {
        cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    for (Object item : model.getItems()) {
        EntityModel entityModel = (EntityModel) item;
        if (entityModel.getIsSelected()) {
            items.add((DbUser) entityModel.getEntity());
        }
    }
    Role role = (Role) model.getRole().getSelectedItem();
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (DbUser user : items) {
        Permissions tempVar = new Permissions();
        tempVar.setad_element_id(user.getId());
        tempVar.setrole_id(role.getId());
        Permissions perm = tempVar;
        if (user.isGroup()) {
            DbGroup group = new DbGroup();
            group.setId(user.getId());
            group.setName(user.getFirstName());
            group.setDomain(user.getDomain());
            PermissionsOperationsParameters tempVar2 = new PermissionsOperationsParameters();
            tempVar2.setPermission(perm);
            tempVar2.setGroup(group);
            list.add(tempVar2);
        } else {
            PermissionsOperationsParameters tempVar3 = new PermissionsOperationsParameters();
            tempVar3.setPermission(perm);
            tempVar3.setUser(user);
            list.add(tempVar3);
        }
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.AddSystemPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeSystemPermissionsTitle());
    // $NON-NLS-1$
    model.setHashName("remove_system_permission");
    model.setMessage(ConstantsManager.getInstance().getConstants().systemPermissionsMsg());
    model.setItems(getSelectedItems());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeSystemPermissionsTitle());
    // $NON-NLS-1$
    model.setHashName("remove_system_permission");
    model.setItems(getSelectedItems());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onRemove() {
    if (getSelectedItems() != null && getSelectedItems().size() > 0) {
        ConfirmationModel model = (ConfirmationModel) getWindow();
        if (model.getProgress() != null) {
            return;
        }
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object perm : getSelectedItems()) {
            PermissionsOperationsParameters tempVar = new PermissionsOperationsParameters();
            tempVar.setPermission((permissions) perm);
            list.add(tempVar);
        }
        model.startProgress(null);
        Frontend.RunMultipleAction(VdcActionType.RemovePermission, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ConfirmationModel localModel = (ConfirmationModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#method_after
private void onRemove() {
    if (getSelectedItems() != null && getSelectedItems().size() > 0) {
        ConfirmationModel model = (ConfirmationModel) getWindow();
        if (model.getProgress() != null) {
            return;
        }
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object perm : getSelectedItems()) {
            PermissionsOperationsParameters tempVar = new PermissionsOperationsParameters();
            tempVar.setPermission((Permissions) perm);
            list.add(tempVar);
        }
        model.startProgress(null);
        Frontend.getInstance().runMultipleAction(VdcActionType.RemoveSystemPermission, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ConfirmationModel localModel = (ConfirmationModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    permissions perm = getParameters().getPermission();
    if (perm == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_PERMISSION_NOT_SENT);
        return false;
    }
    Role role = getRoleDao().get(perm.getrole_id());
    Guid adElementId = perm.getad_element_id();
    if (role == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_INVALID_ROLE_ID);
        return false;
    }
    if (perm.getObjectType() == null || getVdcObjectName() == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_INVALID_OBJECT_ID);
        return false;
    }
    // user or group
    if ((adElementId == null) || (getParameters().getUser() != null && !getParameters().getUser().getId().equals(adElementId)) || (getParameters().getGroup() != null && !getParameters().getGroup().getId().equals(adElementId))) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_USER_ID_MISMATCH);
        return false;
    }
    // give permission
    if (getParameters().getUser() == null && getParameters().getGroup() == null && getDbUserDAO().get(adElementId) == null && getAdGroupDAO().get(adElementId) == null) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.USER_MUST_EXIST_IN_DB.toString());
        return false;
    }
    // only system super user can give permissions with admin roles
    if (!isSystemSuperUser() && role.getType() == RoleType.ADMIN) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_ONLY_SYSTEM_SUPER_USER_CAN_GIVE_ADMIN_ROLES);
        return false;
    }
    // don't allow adding permissions to vms from pool externally
    if (!isInternalExecution() && perm.getObjectType() == VdcObjectType.VM) {
        VM vm = getVmDAO().get(perm.getObjectId());
        if (vm != null && vm.getVmPoolId() != null) {
            addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_VM_IN_POOL);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    Permissions perm = getParameters().getPermission();
    if (perm == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_PERMISSION_NOT_SENT);
        return false;
    }
    Role role = getRoleDao().get(perm.getrole_id());
    Guid adElementId = perm.getad_element_id();
    if (role == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_INVALID_ROLE_ID);
        return false;
    }
    if (perm.getObjectType() == null || getVdcObjectName() == null) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_INVALID_OBJECT_ID);
        return false;
    }
    // user or group
    if ((adElementId == null) || (getParameters().getUser() != null && !getParameters().getUser().getId().equals(adElementId)) || (getParameters().getGroup() != null && !getParameters().getGroup().getId().equals(adElementId))) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_USER_ID_MISMATCH);
        return false;
    }
    // give permission
    if (getParameters().getUser() == null && getParameters().getGroup() == null && getDbUserDAO().get(adElementId) == null && getAdGroupDAO().get(adElementId) == null) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.USER_MUST_EXIST_IN_DB.toString());
        return false;
    }
    // only system super user can give permissions with admin roles
    if (!isSystemSuperUser() && role.getType() == RoleType.ADMIN) {
        addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_ONLY_SYSTEM_SUPER_USER_CAN_GIVE_ADMIN_ROLES);
        return false;
    }
    // don't allow adding permissions to vms from pool externally
    if (!isInternalExecution() && perm.getObjectType() == VdcObjectType.VM) {
        VM vm = getVmDAO().get(perm.getObjectId());
        if (vm != null && vm.getVmPoolId() != null) {
            addCanDoActionMessage(VdcBllMessages.PERMISSION_ADD_FAILED_VM_IN_POOL);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Get the parameters:
    T parameters = getParameters();
    // The user or group given in the parameters may haven't been added to
    // the database yet, this will be the case if they don't have an
    // internal identifier, if this is the case then they need to be
    // added to the database now, before the permission:
    final DbUser user = parameters.getUser();
    if (user != null && user.getId() == null) {
        user.setId(Guid.newGuid());
        getDbUserDAO().save(user);
    }
    final DbGroup group = parameters.getGroup();
    if (group != null && group.getId() == null) {
        group.setId(Guid.newGuid());
        getAdGroupDAO().save(group);
    }
    final permissions paramPermission = parameters.getPermission();
    permissions permission = getPermissionDAO().getForRoleAndAdElementAndObject(paramPermission.getrole_id(), paramPermission.getad_element_id(), paramPermission.getObjectId());
    if (permission == null) {
        paramPermission.setId(Guid.newGuid());
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getPermissionDAO().save(paramPermission);
                getCompensationContext().snapshotNewEntity(paramPermission);
                getCompensationContext().stateChanged();
                return null;
            }
        });
        permission = paramPermission;
    }
    getReturnValue().setActionReturnValue(permission.getId());
    if (user != null) {
        updateAdminStatus(permission);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // Get the parameters:
    T parameters = getParameters();
    // The user or group given in the parameters may haven't been added to
    // the database yet, this will be the case if they don't have an
    // internal identifier, if this is the case then they need to be
    // added to the database now, before the permission:
    final DbUser user = parameters.getUser();
    if (user != null && user.getId() == null) {
        user.setId(Guid.newGuid());
        getDbUserDAO().save(user);
    }
    final DbGroup group = parameters.getGroup();
    if (group != null && group.getId() == null) {
        group.setId(Guid.newGuid());
        getAdGroupDAO().save(group);
    }
    final Permissions paramPermission = parameters.getPermission();
    Permissions permission = getPermissionDAO().getForRoleAndAdElementAndObject(paramPermission.getrole_id(), paramPermission.getad_element_id(), paramPermission.getObjectId());
    if (permission == null) {
        paramPermission.setId(Guid.newGuid());
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getPermissionDAO().save(paramPermission);
                getCompensationContext().snapshotNewEntity(paramPermission);
                getCompensationContext().stateChanged();
                return null;
            }
        });
        permission = paramPermission;
    }
    getReturnValue().setActionReturnValue(permission.getId());
    if (user != null) {
        updateAdminStatus(permission);
    }
    setSucceeded(true);
}
#end_block

#method_before
private void updateAdminStatus(permissions perm) {
    // if the role of the permission is of type admin update the user
    // lastAdminCheckStatus to true
    Role role = getRoleDao().get(perm.getrole_id());
    if (role.getType() == RoleType.ADMIN) {
        MultiLevelAdministrationHandler.setIsAdminGUIFlag(perm.getad_element_id(), true);
    }
}
#method_after
private void updateAdminStatus(Permissions perm) {
    // if the role of the permission is of type admin update the user
    // lastAdminCheckStatus to true
    Role role = getRoleDao().get(perm.getrole_id());
    if (role.getType() == RoleType.ADMIN) {
        MultiLevelAdministrationHandler.setIsAdminGUIFlag(perm.getad_element_id(), true);
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    permissions permission = getParameters().getPermission();
    List<PermissionSubject> permissionsSubject = new ArrayList<>();
    permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    initUserAndGroupData();
    // user from the directory service
    if (getParameters().getUser() != null && _dbUser == null) {
        permissionsSubject.add(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, VdcActionType.AddUser.getActionGroup()));
    }
    return permissionsSubject;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    Permissions permission = getParameters().getPermission();
    List<PermissionSubject> permissionsSubject = new ArrayList<>();
    permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    initUserAndGroupData();
    // user from the directory service
    if (getParameters().getUser() != null && _dbUser == null) {
        permissionsSubject.add(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, VdcActionType.AddUser.getActionGroup()));
    }
    return permissionsSubject;
}
#end_block

#method_before
public static Object populate(Object model, Class<?> clz, List<Class<?>> seen, int level) throws Exception {
    for (Method method : clz.getMethods()) {
        if (isSetter(method)) {
            if (takesPrimitive(method)) {
                random(method, model);
            } else if (takesEnum(method)) {
                shuffle(method, model);
            } else if (takesBigDecimal(method)) {
                populateBigDecimal(method, model);
            } else if (takesXmlGregorianCalendar(method)) {
                populateXmlGregorianCalendar(method, model);
            } else if (takesBytes(method)) {
                populateBytes(method, model);
            } else {
                descend(method, model, scope(seen), level);
            }
        } else if (isGetter(method) && returnsList(method)) {
            fill(method, model, seen, level);
        }
    }
    return model;
}
#method_after
public static Object populate(Object model, Class<?> clz, List<Class<?>> seen, int level) throws Exception {
    for (Method method : clz.getMethods()) {
        if (isSetter(method)) {
            if (takesPrimitive(method)) {
                random(method, model);
            } else if (takesEnum(method)) {
                shuffle(method, model);
            } else if (takesBigDecimal(method)) {
                populateBigDecimal(method, model);
            } else if (takesXmlGregorianCalendar(method)) {
                populateXmlGregorianCalendar(method, model);
            } else {
                descend(method, model, scope(seen), level);
            }
        } else if (isGetter(method) && returnsList(method)) {
            fill(method, model, seen, level);
        }
    }
    return model;
}
#end_block

#method_before
@Test
public void testAddGroupWithExplicitDirectoryName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations("ADGROUP@" + DOMAIN + ": allnames=" + NAMES[0], SearchType.AdGroup, getDirectoryGroup(0));
    setUpCreationExpectations(VdcActionType.AddGroup, AddDirectoryGroupParameters.class, new String[] { "Group.id" }, new Object[] { GUIDS[0] }, true, true, null, VdcQueryType.GetDbGroupById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Domain domain = new Domain();
    domain.setName(DOMAIN);
    Group model = new Group();
    model.setName(NAMES[0]);
    model.setDomain(domain);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Group);
    verifyModel((Group) response.getEntity(), 0);
}
#method_after
@Test
public void testAddGroupWithExplicitDirectoryName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations("ADGROUP@" + DOMAIN + ": allnames=" + NAMES[0], SearchType.AdGroup, getDirectoryGroup(0));
    setUpCreationExpectations(VdcActionType.AddGroup, AddGroupParameters.class, new String[] { "Group.id" }, new Object[] { GUIDS[0] }, true, true, null, VdcQueryType.GetDbGroupById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Domain domain = new Domain();
    domain.setName(DOMAIN);
    Group model = new Group();
    model.setName(NAMES[0]);
    model.setDomain(domain);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Group);
    verifyModel((Group) response.getEntity(), 0);
}
#end_block

#method_before
@Test
public void testAddGroupWithImplicitDirectoryName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations("ADGROUP@" + DOMAIN + ": allnames=" + GROUP_NAMES[0], SearchType.AdGroup, getDirectoryGroup(0));
    setUpCreationExpectations(VdcActionType.AddGroup, AddDirectoryGroupParameters.class, new String[] { "Group.id" }, new Object[] { GUIDS[0] }, true, true, null, VdcQueryType.GetDbGroupById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Group model = new Group();
    model.setName(GROUP_NAMES[0]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Group);
    verifyModel((Group) response.getEntity(), 0);
}
#method_after
@Test
public void testAddGroupWithImplicitDirectoryName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetEntityExpectations("ADGROUP@" + DOMAIN + ": allnames=" + GROUP_NAMES[0], SearchType.AdGroup, getDirectoryGroup(0));
    setUpCreationExpectations(VdcActionType.AddGroup, AddGroupParameters.class, new String[] { "Group.id" }, new Object[] { GUIDS[0] }, true, true, null, VdcQueryType.GetDbGroupById, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Group model = new Group();
    model.setName(GROUP_NAMES[0]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Group);
    verifyModel((Group) response.getEntity(), 0);
}
#end_block

#method_before
@Mapping(from = DbUser.class, to = User.class)
public static User map(DbUser entity, User template) {
    User model = template != null ? template : new User();
    model.setExternalId(entity.getExternalId().getBytes());
    model.setName(entity.getFirstName());
    model.setUserName(entity.getLoginName());
    model.setId(entity.getId().toString());
    model.setLastName(entity.getLastName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroupNames() != null && entity.getGroupNames().trim().length() > 0) {
        model.setGroups(new Groups());
        for (String name : entity.getGroupNames().split(",")) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = DbUser.class, to = User.class)
public static User map(DbUser entity, User template) {
    User model = template != null ? template : new User();
    model.setExternalId(entity.getExternalId().toString());
    model.setName(entity.getFirstName());
    model.setUserName(entity.getLoginName());
    model.setId(entity.getId().toString());
    model.setLastName(entity.getLastName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroupNames() != null && entity.getGroupNames().trim().length() > 0) {
        model.setGroups(new Groups());
        for (String name : entity.getGroupNames().split(",")) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = LdapUser.class, to = User.class)
public static User map(LdapUser entity, User template) {
    User model = template != null ? template : new User();
    model.setExternalId(entity.getUserId().toByteArray());
    model.setName(entity.getName());
    model.setUserName(entity.getUserName());
    model.setId(entity.getUserId().toString());
    model.setLastName(entity.getSurName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroups() != null) {
        model.setGroups(new Groups());
        for (String name : entity.getGroups().keySet()) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDomainControler())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomainControler().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = LdapUser.class, to = User.class)
public static User map(LdapUser entity, User template) {
    User model = template != null ? template : new User();
    model.setName(entity.getName());
    model.setUserName(entity.getUserName());
    model.setId(entity.getUserId().toString());
    model.setLastName(entity.getSurName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroups() != null) {
        model.setGroups(new Groups());
        for (String name : entity.getGroups().keySet()) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDomainControler())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomainControler().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = DbGroup.class, to = Group.class)
public static Group map(DbGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setExternalId(entity.getExternalId().getBytes());
    model.setName(entity.getName());
    model.setId(entity.getId().toString());
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = DbGroup.class, to = Group.class)
public static Group map(DbGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setExternalId(entity.getExternalId().toString());
    model.setName(entity.getName());
    model.setId(entity.getId().toString());
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = LdapGroup.class, to = Group.class)
public static Group map(LdapGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setExternalId(entity.getid().toByteArray());
    model.setName(entity.getname());
    model.setId(entity.getid().toString());
    if (!StringUtils.isEmpty(entity.getdomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getdomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = LdapGroup.class, to = Group.class)
public static Group map(LdapGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setName(entity.getname());
    model.setId(entity.getid().toString());
    if (!StringUtils.isEmpty(entity.getdomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getdomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        addCanDoActionMessage("$device console");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        addCanDoActionMessage("$device sound");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName(), getParameters().isVirtioScsiEnabled())) {
        addCanDoActionMessage("$device VirtIO-SCSI");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        addCanDoActionMessage("$device console");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        addCanDoActionMessage("$device sound");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName(), getParameters().isVirtioScsiEnabled())) {
        addCanDoActionMessage("$device VirtIO-SCSI");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    return true;
}
#end_block

#method_before
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), getParameters().isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), getParameters().isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Before
public void setUp() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    when(osRepository.getMinimumRam(0, Version.v3_0)).thenReturn(0);
    when(osRepository.getMinimumRam(0, null)).thenReturn(0);
    when(osRepository.getMaximumRam(0, Version.v3_0)).thenReturn(256);
    when(osRepository.getMaximumRam(0, null)).thenReturn(256);
    when(osRepository.isWindows(0)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(0)).thenReturn(ArchitectureType.x86_64);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setcpu_name("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setcompatibility_version(Version.v3_0);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
}
#method_after
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    Map<Integer, Map<Version, List<DisplayType>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<DisplayType>>());
    displayTypeMap.get(osId).put(version, Arrays.asList(DisplayType.qxl));
    when(osRepository.getDisplayTypes()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setcpu_name("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setcompatibility_version(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
}
#end_block

#method_before
@Override
protected void beforeUiCommonInitEvent(LoginModel loginModel) {
    CommonModelManager.init(eventBus, user, loginModel, frontendFailureEventListener);
}
#method_after
@Override
protected void beforeUiCommonInitEvent(LoginModel loginModel) {
    CommonModelManager.init(eventBus);
}
#end_block

#method_before
@Override
public void onLogout() {
    // Logout operation happens within the CommonModel SignOut event handler
    CommonModelManager.instance().signOut();
    AsyncDataProvider.clearCache();
}
#method_after
@Override
public void onLogout() {
    // Logout operation happens within the CommonModel SignOut event handler
    CommonModelManager.instance().signOut();
    performLogout();
}
#end_block

#method_before
@Override
protected void initFrontend() {
    super.initFrontend();
    // Configure REST API integration for UI plugin infrastructure
    Frontend.setLoginHandler(new FrontendLoginHandler() {

        @Override
        public void onLoginSuccess(final String userName, final String password, final String domain) {
            Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                @Override
                public void execute() {
                    // $NON-NLS-1$
                    final String domainToken = "@";
                    restApiSessionManager.acquireSession(userName.contains(domainToken) ? userName : userName + domainToken + domain, password);
                }
            });
        }

        @Override
        public void onLogout() {
            restApiSessionManager.releaseSession();
        }
    });
}
#method_after
@Override
protected void initFrontend() {
    super.initFrontend();
    // Configure REST API integration for UI plugin infrastructure
    frontend.setLoginHandler(new FrontendLoginHandler() {

        @Override
        public void onLoginSuccess(final String userName, final String password, final String domain) {
            Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                @Override
                public void execute() {
                    // $NON-NLS-1$
                    final String domainToken = "@";
                    restApiSessionManager.acquireSession(userName.contains(domainToken) ? userName : userName + domainToken + domain, password);
                }
            });
        }

        @Override
        public void onLogout() {
            restApiSessionManager.releaseSession();
        }
    });
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for applicationMode object
    Integer applicationMode = getApplicationMode(request.getSession().getId());
    request.setAttribute(ATTR_APPLICATION_MODE, getApplicationModeObject(applicationMode));
    // Set attribute for pluginDefinitions array
    List<PluginData> pluginData = getPluginData();
    request.setAttribute(ATTR_PLUGIN_DEFS, getPluginDefinitionsArray(pluginData));
    // Set attribute for engineSessionTimeout object
    Integer engineSessionTimeout = getEngineSessionTimeout();
    request.setAttribute(ATTR_ENGINE_SESSION_TIMEOUT, getEngineSessionTimeoutObject(engineSessionTimeout));
    super.doGet(request, response);
}
#method_after
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for applicationMode object
    Integer applicationMode = getApplicationMode(request.getSession().getId());
    request.setAttribute(ATTR_APPLICATION_MODE, getApplicationModeObject(applicationMode));
    // Set attribute for pluginDefinitions array
    List<PluginData> pluginData = getPluginData();
    request.setAttribute(ATTR_PLUGIN_DEFS, getPluginDefinitionsArray(pluginData));
    // Set attribute for engineSessionTimeout object
    Integer engineSessionTimeout = getEngineSessionTimeout(request.getSession().getId());
    request.setAttribute(ATTR_ENGINE_SESSION_TIMEOUT, getEngineSessionTimeoutObject(engineSessionTimeout));
    super.doGet(request, response);
}
#end_block

#method_before
protected Integer getEngineSessionTimeout() {
    // TODO retrieve actual config value
    return 30;
}
#method_after
protected Integer getEngineSessionTimeout(String sessionId) {
    return (Integer) runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.UserSessionTimeOutInterval, ConfigCommon.defaultConfigurationVersion), sessionId);
}
#end_block

#method_before
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<String, NetworkInterfaceModel>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<String, VdsNetworkInterface>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<VdsNetworkInterface>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<String, List<VdsNetworkInterface>>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<String, Set<LogicalNetworkModel>>();
    Map<String, List<NetworkLabelModel>> nicToLabels = new HashMap<String, List<NetworkLabelModel>>();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        // is this a management nic? (comes from backend)
        boolean isNicManagement = nic.getIsManagement();
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final Integer vlanId = nic.getVlanId();
        final int dotpos = nicName.indexOf('.');
        // is this a physical nic?
        boolean isPhysicalInterface = vlanId == null;
        if (isPhysicalInterface) {
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<VdsNetworkInterface>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (dotpos > 0) {
            ifName = nicName.substring(0, dotpos);
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getEntity().setVlanId(nic.getVlanId());
                networkModel.getEntity().setMtu(nic.getMtu());
                networkModel.getEntity().setVmNetwork(nic.isBridged());
            }
            // is this a management network (from backend)?
            if (isNicManagement) {
                networkModel.setManagement(true);
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<LogicalNetworkModel>();
            nicNetworks.add(networkModel);
            // set iface bridge to network
            NetworkInterfaceModel existingEridge = networkModel.getVlanNic();
            // $NON-NLS-1$
            assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
            networkModel.setBridge(new NetworkInterfaceModel(nic, nicNetworks, null, this));
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                NetworkLabelModel labelModel = labelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    Set<LogicalNetworkModel> nicNetworks = nicToNetwork.get(ifName);
                    if (nicNetworks == null) {
                        nicNetworks = new HashSet<LogicalNetworkModel>();
                        nicToNetwork.put(nicName, nicNetworks);
                    }
                    for (LogicalNetworkModel networkModel : labelModel.getNetworks()) {
                        nicNetworks.add(networkModel);
                        networkModel.attachViaLabel();
                    }
                    // attach label itself to nic
                    List<NetworkLabelModel> nicLabels = nicToLabels.get(ifName);
                    if (nicLabels == null) {
                        nicLabels = new ArrayList<NetworkLabelModel>();
                        nicToLabels.put(ifName, nicLabels);
                    }
                    nicLabels.add(labelModel);
                }
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<String>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        String nicName = nic.getName();
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = nicToLabels.get(nicName);
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<NetworkInterfaceModel>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel(nic, nicNetworks, nicLabels, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, this);
        }
        nicModels.put(nicName, nicModel);
    }
    setNics(nicModels);
}
#method_after
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<String, NetworkInterfaceModel>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<String, VdsNetworkInterface>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<VdsNetworkInterface>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<String, List<VdsNetworkInterface>>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<String, Set<LogicalNetworkModel>>();
    Map<String, List<NetworkLabelModel>> nicToLabels = new HashMap<String, List<NetworkLabelModel>>();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        // is this a management nic? (comes from backend)
        final boolean isNicManagement = nic.getIsManagement();
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final Integer vlanId = nic.getVlanId();
        final int dotpos = nicName.indexOf('.');
        if (vlanId == null) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<VdsNetworkInterface>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (dotpos > 0) {
            ifName = nicName.substring(0, dotpos);
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getEntity().setVlanId(nic.getVlanId());
                networkModel.getEntity().setMtu(nic.getMtu());
                networkModel.getEntity().setVmNetwork(nic.isBridged());
            }
            // is this a management network (from backend)?
            if (isNicManagement) {
                networkModel.setManagement(true);
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<LogicalNetworkModel>();
            nicNetworks.add(networkModel);
            // set iface bridge to network
            NetworkInterfaceModel existingEridge = networkModel.getVlanNic();
            // $NON-NLS-1$
            assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
            networkModel.setBridge(new NetworkInterfaceModel(nic, nicNetworks, null, this));
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                NetworkLabelModel labelModel = labelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (LogicalNetworkModel networkModel : labelModel.getNetworks()) {
                        nicToNetwork.get(ifName).add(networkModel);
                        networkModel.attachViaLabel();
                    }
                    // attach label itself to nic
                    List<NetworkLabelModel> nicLabels = nicToLabels.get(ifName);
                    if (nicLabels == null) {
                        nicLabels = new ArrayList<NetworkLabelModel>();
                        nicToLabels.put(ifName, nicLabels);
                    }
                    nicLabels.add(labelModel);
                }
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<String>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        String nicName = nic.getName();
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = nicToLabels.get(nicName);
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<NetworkInterfaceModel>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel(nic, nicNetworks, nicLabels, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, this);
        }
        nicModels.put(nicName, nicModel);
    }
    setNics(nicModels);
}
#end_block

#method_before
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<String, NetworkInterfaceModel>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<String, VdsNetworkInterface>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<VdsNetworkInterface>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<String, List<VdsNetworkInterface>>();
    Map<String, List<LogicalNetworkModel>> nicToNetwork = new HashMap<String, List<LogicalNetworkModel>>();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        // is this a management nic? (comes from backend)
        boolean isNicManagement = nic.getIsManagement();
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final Integer vlanId = nic.getVlanId();
        final int dotpos = nicName.indexOf('.');
        // is this a physical nic?
        boolean isPhysicalInterface = vlanId == null;
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (dotpos > 0) {
            ifName = nicName.substring(0, dotpos);
        } else {
            ifName = nicName;
        }
        if (isPhysicalInterface) {
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<VdsNetworkInterface>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new ArrayList<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getEntity().setVlanId(nic.getVlanId());
                networkModel.getEntity().setMtu(nic.getMtu());
                networkModel.getEntity().setVmNetwork(nic.isBridged());
            }
            // is this a management network (from backend)?
            if (isNicManagement) {
                networkModel.setManagement(true);
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<LogicalNetworkModel>();
            nicNetworks.add(networkModel);
            // set iface bridge to network
            NetworkInterfaceModel existingEridge = networkModel.getVlanNic();
            // $NON-NLS-1$
            assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
            networkModel.setBridge(new NetworkInterfaceModel(nic, nicNetworks, this));
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<String>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        String nicName = nic.getName();
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        List<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<NetworkInterfaceModel>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel(nic, nicNetworks, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, this);
        }
        nicModels.put(nicName, nicModel);
    }
    setNics(nicModels);
}
#method_after
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<String, NetworkInterfaceModel>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<String, VdsNetworkInterface>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<VdsNetworkInterface>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<String, List<VdsNetworkInterface>>();
    Map<String, List<LogicalNetworkModel>> nicToNetwork = new HashMap<String, List<LogicalNetworkModel>>();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        // is this a management nic? (comes from backend)
        final boolean isNicManagement = nic.getIsManagement();
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final Integer vlanId = nic.getVlanId();
        final int dotpos = nicName.indexOf('.');
        if (vlanId == null) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<VdsNetworkInterface>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (dotpos > 0) {
            ifName = nicName.substring(0, dotpos);
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new ArrayList<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getEntity().setVlanId(nic.getVlanId());
                networkModel.getEntity().setMtu(nic.getMtu());
                networkModel.getEntity().setVmNetwork(nic.isBridged());
            }
            // is this a management network (from backend)?
            if (isNicManagement) {
                networkModel.setManagement(true);
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<LogicalNetworkModel>();
            nicNetworks.add(networkModel);
            // set iface bridge to network
            NetworkInterfaceModel existingEridge = networkModel.getVlanNic();
            // $NON-NLS-1$
            assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
            networkModel.setBridge(new NetworkInterfaceModel(nic, nicNetworks, this));
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<String>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        String nicName = nic.getName();
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        List<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<NetworkInterfaceModel>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel(nic, nicNetworks, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, this);
        }
        nicModels.put(nicName, nicModel);
    }
    setNics(nicModels);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), false);
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), false);
            }
            setSucceeded(true);
            return null;
        }
    });
    VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), false);
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getVm().isBalloonEnabled(), false);
            }
            setSucceeded(true);
            return null;
        }
    });
    VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
public Response performRemove(String id) {
    org.ovirt.engine.core.common.businessentities.network.Network entity = lookupNetwork(asGuidOr404(id));
    if (entity == null) {
        notFound();
        return null;
    }
    return performAction(removeAction, getActionParameters(null, entity, true));
}
#method_after
@Override
public Response performRemove(String id) {
    org.ovirt.engine.core.common.businessentities.network.Network entity = lookupNetwork(asGuidOr404(id));
    if (entity == null) {
        notFound();
        return null;
    }
    return performAction(removeAction, getRemoveParameters(entity));
}
#end_block

#method_before
@Override
public Response add(Network network) {
    validateParameters(network, "id|name");
    String networkName = null;
    List<org.ovirt.engine.core.common.businessentities.network.Network> networks = getNetworks(clusterId);
    if (network.isSetId()) {
        org.ovirt.engine.core.common.businessentities.network.Network net = getNetworkById(network.getId(), networks);
        if (net == null) {
            notFound(Network.class);
        } else {
            networkName = net.getName();
        }
    }
    String networkId = null;
    if (network.isSetName()) {
        org.ovirt.engine.core.common.businessentities.network.Network net = getNetworkByName(network.getName(), networks);
        if (net == null) {
            notFound(Network.class);
        } else {
            networkId = net.getId().toString();
        }
    }
    if (!network.isSetId()) {
        network.setId(networkId);
    } else if (network.isSetName() && !network.getId().equals(networkId)) {
        badRequest("Network ID provided does not match the ID for network with name: " + network.getName());
    }
    org.ovirt.engine.core.common.businessentities.network.Network entity = map(network);
    return performCreate(addAction, getActionParameters(network, entity), new NetworkIdResolver(StringUtils.defaultIfEmpty(network.getName(), networkName)));
}
#method_after
@Override
public Response add(Network network) {
    validateParameters(network, "id|name");
    String networkName = null;
    List<org.ovirt.engine.core.common.businessentities.network.Network> networks = getNetworks(clusterId);
    if (network.isSetId()) {
        org.ovirt.engine.core.common.businessentities.network.Network net = getNetworkById(network.getId(), networks);
        if (net == null) {
            notFound(Network.class);
        } else {
            networkName = net.getName();
        }
    }
    String networkId = null;
    if (network.isSetName()) {
        org.ovirt.engine.core.common.businessentities.network.Network net = getNetworkByName(network.getName(), networks);
        if (net == null) {
            notFound(Network.class);
        } else {
            networkId = net.getId().toString();
        }
    }
    if (!network.isSetId()) {
        network.setId(networkId);
    } else if (network.isSetName() && !network.getId().equals(networkId)) {
        badRequest("Network ID provided does not match the ID for network with name: " + network.getName());
    }
    org.ovirt.engine.core.common.businessentities.network.Network entity = map(network);
    return performCreate(addAction, getAddParameters(network, entity), new NetworkIdResolver(StringUtils.defaultIfEmpty(network.getName(), networkName)));
}
#end_block

#method_before
@Override
public Response add(Network network) {
    validateParameters(network, getRequiredAddFields());
    validateEnums(Network.class, network);
    org.ovirt.engine.core.common.businessentities.network.Network entity = map(network);
    AddNetworkStoragePoolParameters params = (AddNetworkStoragePoolParameters) getActionParameters(network, entity);
    return performCreate(addAction, params, new DataCenterNetworkIdResolver(network.getName(), params.getStoragePoolId().toString()));
}
#method_after
@Override
public Response add(Network network) {
    validateParameters(network, getRequiredAddFields());
    validateEnums(Network.class, network);
    org.ovirt.engine.core.common.businessentities.network.Network entity = map(network);
    AddNetworkStoragePoolParameters params = getAddParameters(network, entity);
    return performCreate(addAction, params, new DataCenterNetworkIdResolver(network.getName(), params.getStoragePoolId().toString()));
}
#end_block

#method_before
@Override
public Response add(Network network) {
    validateParameters(network, getRequiredAddFields());
    validateEnums(Network.class, network);
    DataCenter dataCenter = new DataCenter();
    dataCenter.setId(dataCenterId.toString());
    network.setDataCenter(dataCenter);
    org.ovirt.engine.core.common.businessentities.network.Network entity = map(network);
    AddNetworkStoragePoolParameters params = (AddNetworkStoragePoolParameters) getActionParameters(network, entity);
    return performCreate(addAction, params, new DataCenterNetworkIdResolver(network.getName(), params.getStoragePoolId().toString()));
}
#method_after
@Override
public Response add(Network network) {
    validateParameters(network, getRequiredAddFields());
    validateEnums(Network.class, network);
    DataCenter dataCenter = new DataCenter();
    dataCenter.setId(dataCenterId.toString());
    network.setDataCenter(dataCenter);
    org.ovirt.engine.core.common.businessentities.network.Network entity = map(network);
    AddNetworkStoragePoolParameters params = getAddParameters(network, entity);
    return performCreate(addAction, params, new DataCenterNetworkIdResolver(network.getName(), params.getStoragePoolId().toString()));
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(AffinityGroup entity) {
    return createIdParameterMapper(entity.getId()).addValue("name", entity.getName()).addValue("description", entity.getDescription()).addValue("cluster_id", entity.getClusterId()).addValue("polarity", entity.getPolarity()).addValue("enforcement_type", entity.getEnforcementType()).addValue("vm_ids", entity.getVmIds() == null ? StringUtils.EMPTY : StringUtils.join(entity.getVmIds(), SEPARATOR));
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(AffinityGroup entity) {
    return createIdParameterMapper(entity.getId()).addValue("name", entity.getName()).addValue("description", entity.getDescription()).addValue("cluster_id", entity.getClusterId()).addValue("positive", entity.isPositive()).addValue("enforcing", entity.isEnforcing()).addValue("vm_ids", entity.getEntityIds() == null ? StringUtils.EMPTY : StringUtils.join(entity.getEntityIds(), SEPARATOR));
}
#end_block

#method_before
@Override
protected RowMapper<AffinityGroup> createEntityRowMapper() {
    return new RowMapper<AffinityGroup>() {

        @Override
        public AffinityGroup mapRow(ResultSet rs, int arg1) throws SQLException {
            AffinityGroup affinityGroup = new AffinityGroup();
            affinityGroup.setId(getGuid(rs, "id"));
            affinityGroup.setName(rs.getString("name"));
            affinityGroup.setDescription(rs.getString("description"));
            affinityGroup.setClusterId(getGuid(rs, "cluster_id"));
            affinityGroup.setPolarity(AffinityPolarity.forValue(rs.getInt("polarity")));
            affinityGroup.setEnforcementType(AffinityEnforcementType.forValue(rs.getInt("enforcement_type")));
            affinityGroup.setVmIds(GuidUtils.getGuidListFromString(rs.getString("vm_ids")));
            affinityGroup.setVmNames(split(rs.getString("vm_names")));
            return affinityGroup;
        }
    };
}
#method_after
@Override
protected RowMapper<AffinityGroup> createEntityRowMapper() {
    return AffinityGropupRowMapper.instance;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getAffinityGroupDao().getByName(getParameters().getAffinityGroup().getName()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_AFFINITY_GROUP_NAME_EXSITS);
    }
    return validateParameters();
}
#method_after
@Override
protected boolean canDoAction() {
    if (getAffinityGroupDao().getByName(getParameters().getAffinityGroup().getName()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_AFFINITY_GROUP_NAME_EXISTS);
    }
    return validateParameters();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getAffinityGroup().setId(Guid.newGuid());
    getAffinityGroupDao().save(getAffinityGroup());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getAffinityGroup().setId(Guid.newGuid());
    getAffinityGroupDao().save(getAffinityGroup());
    getReturnValue().setActionReturnValue(getAffinityGroup().getId());
    setSucceeded(true);
}
#end_block

#method_before
public String getName() {
    return name;
}
#method_after
@Override
public String getName() {
    return name;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((clusterId == null) ? 0 : clusterId.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((enforcementType == null) ? 0 : enforcementType.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((polarity == null) ? 0 : polarity.hashCode());
    result = prime * result + ((vmIds == null) ? 0 : vmIds.hashCode());
    result = prime * result + ((vmNames == null) ? 0 : vmNames.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((clusterId == null) ? 0 : clusterId.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + (enforcing ? 1231 : 1237);
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + (positive ? 1231 : 1237);
    result = prime * result + ((entityIds == null) ? 0 : entityIds.hashCode());
    result = prime * result + ((entityNames == null) ? 0 : entityNames.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    AffinityGroup other = (AffinityGroup) obj;
    if (clusterId == null) {
        if (other.clusterId != null)
            return false;
    } else if (!clusterId.equals(other.clusterId))
        return false;
    if (description == null) {
        if (other.description != null)
            return false;
    } else if (!description.equals(other.description))
        return false;
    if (enforcementType != other.enforcementType)
        return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    if (polarity != other.polarity)
        return false;
    if (vmIds == null) {
        if (other.vmIds != null)
            return false;
    } else if (!vmIds.equals(other.vmIds))
        return false;
    if (vmNames == null) {
        if (other.vmNames != null)
            return false;
    } else if (!vmNames.equals(other.vmNames))
        return false;
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    AffinityGroup other = (AffinityGroup) obj;
    if (clusterId == null) {
        if (other.clusterId != null)
            return false;
    } else if (!clusterId.equals(other.clusterId))
        return false;
    if (description == null) {
        if (other.description != null)
            return false;
    } else if (!description.equals(other.description))
        return false;
    if (enforcing != other.enforcing)
        return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    if (positive != other.positive)
        return false;
    if (entityIds == null) {
        if (other.entityIds != null)
            return false;
    } else if (!entityIds.equals(other.entityIds))
        return false;
    if (entityNames == null) {
        if (other.entityNames != null)
            return false;
    } else if (!entityNames.equals(other.entityNames))
        return false;
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getAffinityGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_AFFINITY_GROUP_ID);
    }
    if (!getParameters().getAffinityGroup().getClusterId().equals(getClusterId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_CHANGE_CLUSTER_ID);
    }
    if (!getAffinityGroup().getName().equals(getParameters().getAffinityGroup().getName()) && getAffinityGroupDao().getByName(getParameters().getAffinityGroup().getName()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_AFFINITY_GROUP_NAME_EXSITS);
    }
    return validateParameters();
}
#method_after
@Override
protected boolean canDoAction() {
    if (getAffinityGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_AFFINITY_GROUP_ID);
    }
    if (!getParameters().getAffinityGroup().getClusterId().equals(getClusterId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_CHANGE_CLUSTER_ID);
    }
    if (!getAffinityGroup().getName().equals(getParameters().getAffinityGroup().getName()) && getAffinityGroupDao().getByName(getParameters().getAffinityGroup().getName()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_AFFINITY_GROUP_NAME_EXISTS);
    }
    return validateParameters();
}
#end_block

#method_before
@Test
public void canDoAction_testNameChange_Test() {
    doReturn(new AffinityGroup()).when(affinityGroupDao).getByName(affinityGroup.getName());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_AFFINITY_GROUP_NAME_EXSITS);
}
#method_after
@Test
public void canDoAction_testNameChange_Test() {
    doReturn(new AffinityGroup()).when(affinityGroupDao).getByName(affinityGroup.getName());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_AFFINITY_GROUP_NAME_EXISTS);
}
#end_block

#method_before
@Test
public void canDoAction_vmNameExists_Test() {
    doReturn(new AffinityGroup()).when(affinityGroupDao).getByName(anyString());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_AFFINITY_GROUP_NAME_EXSITS);
}
#method_after
@Test
public void canDoAction_vmNameExists_Test() {
    doReturn(new AffinityGroup()).when(affinityGroupDao).getByName(anyString());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_AFFINITY_GROUP_NAME_EXISTS);
}
#end_block

#method_before
@Test
public void canDoAction_duplicateVm_Test() {
    affinityGroup.getVmIds().add(vmId);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_DUPLICTE_VM_IN_AFFINITY_GROUP);
}
#method_after
@Test
public void canDoAction_duplicateVm_Test() {
    affinityGroup.getEntityIds().add(vmId);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_DUPLICTE_VM_IN_AFFINITY_GROUP);
}
#end_block

#method_before
private AffinityGroup createAffinityGroup() {
    affinityGroup = new AffinityGroup();
    affinityGroup.setVmIds(new ArrayList<Guid>());
    affinityGroup.getVmIds().add(vmId);
    return affinityGroup;
}
#method_after
private AffinityGroup createAffinityGroup() {
    affinityGroup = new AffinityGroup();
    affinityGroup.setEntityIds(new ArrayList<Guid>());
    affinityGroup.getEntityIds().add(vmId);
    return affinityGroup;
}
#end_block

#method_before
protected boolean validateParameters() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_CLUSTER_FOR_AFFINITY_GROUP);
    }
    if (getParameters().getAffinityGroup().getVmIds() != null) {
        VmStatic vmStatic = null;
        Set<Guid> vmSet = new HashSet<Guid>();
        for (Guid vmId : getParameters().getAffinityGroup().getVmIds()) {
            vmStatic = getVmStaticDAO().get(vmId);
            if (vmStatic == null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VM_FOR_AFFINITY_GROUP);
            }
            if (!vmStatic.getVdsGroupId().equals(getVdsGroupId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_IN_AFFINITY_GROUP_CLUSTER);
            }
            if (vmSet.contains(vmStatic.getId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DUPLICTE_VM_IN_AFFINITY_GROUP);
            } else {
                vmSet.add(vmStatic.getId());
            }
        }
    }
    return true;
}
#method_after
protected boolean validateParameters() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_CLUSTER_FOR_AFFINITY_GROUP);
    }
    if (getParameters().getAffinityGroup().getEntityIds() != null) {
        VmStatic vmStatic = null;
        Set<Guid> vmSet = new HashSet<Guid>();
        for (Guid vmId : getParameters().getAffinityGroup().getEntityIds()) {
            vmStatic = getVmStaticDAO().get(vmId);
            if (vmStatic == null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VM_FOR_AFFINITY_GROUP);
            }
            if (!vmStatic.getVdsGroupId().equals(getVdsGroupId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_IN_AFFINITY_GROUP_CLUSTER);
            }
            if (vmSet.contains(vmStatic.getId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DUPLICTE_VM_IN_AFFINITY_GROUP);
            } else {
                vmSet.add(vmStatic.getId());
            }
        }
    }
    return true;
}
#end_block

#method_before
private void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<AffinityGroup> nameColumn = new TextColumnWithTooltip<AffinityGroup>() {

        @Override
        public String getValue(AffinityGroup object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameAffinityGroup(), "150px");
    TextColumnWithTooltip<AffinityGroup> descColumn = new TextColumnWithTooltip<AffinityGroup>() {

        @Override
        public String getValue(AffinityGroup object) {
            return object.getDescription();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(descColumn, constants.descriptionAffinityGroup(), "150px");
    TextColumnWithTooltip<AffinityGroup> polarityColumn = new EnumColumn<AffinityGroup, AffinityPolarity>() {

        @Override
        protected AffinityPolarity getRawValue(AffinityGroup object) {
            return object.getPolarity();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(polarityColumn, constants.polarityAffinityGroup(), "100px");
    TextColumnWithTooltip<AffinityGroup> enforceColumn = new EnumColumn<AffinityGroup, AffinityEnforcementType>() {

        @Override
        protected AffinityEnforcementType getRawValue(AffinityGroup object) {
            return object.getEnforcementType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(enforceColumn, constants.enforceAffinityGroup(), "100px");
    addMembersColumn(constants);
    getTable().addActionButton(new WebAdminButtonDefinition<AffinityGroup>(constants.newAffinityGroupLabel()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<AffinityGroup>(constants.editAffinityGroupLabel()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<AffinityGroup>(constants.removeAffinityGroupLabel()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
}
#method_after
private void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<AffinityGroup> nameColumn = new TextColumnWithTooltip<AffinityGroup>() {

        @Override
        public String getValue(AffinityGroup object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameAffinityGroup(), "150px");
    TextColumnWithTooltip<AffinityGroup> descColumn = new TextColumnWithTooltip<AffinityGroup>() {

        @Override
        public String getValue(AffinityGroup object) {
            return object.getDescription();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(descColumn, constants.descriptionAffinityGroup(), "150px");
    BooleanColumn<AffinityGroup> polarityColumn = new BooleanColumn<AffinityGroup>(constants.positiveAffinity(), constants.negativeAffinity()) {

        @Override
        protected Boolean getRawValue(AffinityGroup object) {
            return object.isPositive();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(polarityColumn, constants.polarityAffinityGroup(), "100px");
    BooleanColumn<AffinityGroup> enforceColumn = new BooleanColumn<AffinityGroup>(constants.hardEnforcingAffinity(), constants.softEnforcingAffinity()) {

        @Override
        protected Boolean getRawValue(AffinityGroup object) {
            return object.isEnforcing();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(enforceColumn, constants.enforceAffinityGroup(), "100px");
    getTable().addColumn(new TextColumnWithTooltip<AffinityGroup>() {

        @Override
        public String getValue(AffinityGroup object) {
            // $NON-NLS-1$
            String join = join(getEntityNames(object), ", ");
            if (join.isEmpty()) {
                return constants.noMembersAffinityGroup();
            }
            return join;
        }
    }, constants.membersAffinityGroup(), // $NON-NLS-1$
    "500px");
    getTable().addActionButton(new WebAdminButtonDefinition<AffinityGroup>(constants.newAffinityGroupLabel()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<AffinityGroup>(constants.editAffinityGroupLabel()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<AffinityGroup>(constants.removeAffinityGroupLabel()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
}
#end_block

#method_before
@Override
protected void syncSearch() {
    if (getParentEntity() != null) {
        super.syncSearch();
        AsyncQuery asyncQuery = new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                AffinityGroupListModel<?> affinityGroupListModel = (AffinityGroupListModel<?>) model;
                ArrayList<AffinityGroup> list = (ArrayList<AffinityGroup>) ((VdcQueryReturnValue) returnValue).getReturnValue();
                affinityGroupListModel.setItems(list);
            }
        });
        VdcQueryParametersBase parameters = new IdQueryParameters(getParentEntity().getId());
        parameters.setRefresh(getIsQueryFirstTime());
        Frontend.getInstance().runQuery(getQueryType(), parameters, asyncQuery);
        setIsQueryFirstTime(false);
    }
}
#method_after
@Override
protected void syncSearch() {
    if (getParentEntity() != null) {
        super.syncSearch(queryType, new IdQueryParameters(getParentEntity().getId()));
    }
}
#end_block

#method_before
public void setNewCommand(UICommand newCommand) {
    this.newCommand = newCommand;
}
#method_after
private void setNewCommand(UICommand newCommand) {
    this.newCommand = newCommand;
}
#end_block

#method_before
public void setEditCommand(UICommand editCommand) {
    this.editCommand = editCommand;
}
#method_after
private void setEditCommand(UICommand editCommand) {
    this.editCommand = editCommand;
}
#end_block

#method_before
public void setRemoveCommand(UICommand removeCommand) {
    this.removeCommand = removeCommand;
}
#method_after
private void setRemoveCommand(UICommand removeCommand) {
    this.removeCommand = removeCommand;
}
#end_block

#method_before
public void setParentEntity(T parentEntity) {
    this.parentEntity = parentEntity;
}
#method_after
private void setParentEntity(T parentEntity) {
    this.parentEntity = parentEntity;
}
#end_block

#method_before
private void newEntity() {
    if (getWindow() != null) {
        return;
    }
    AffinityGroupModel model = getNewAffinityGroupModel();
    model.init();
    setWindow(model);
}
#method_after
private void newEntity() {
    if (getWindow() != null) {
        return;
    }
    AffinityGroupModel model = new NewAffinityGroupModel(getNewAffinityGroup(), this, getClusterId(), getClusterName());
    model.init();
    setWindow(model);
}
#end_block

#method_before
private void edit() {
    if (getWindow() != null) {
        return;
    }
    AffinityGroup affinityGroup = getSelectedItem();
    if (affinityGroup == null) {
        return;
    }
    sortVms(affinityGroup);
    AffinityGroupModel model = new EditAffinityGroupModel(affinityGroup, this, getClusterResolver());
    model.init();
    setWindow(model);
}
#method_after
private void edit() {
    if (getWindow() != null) {
        return;
    }
    AffinityGroup affinityGroup = getSelectedItem();
    if (affinityGroup == null) {
        return;
    }
    AffinityGroupModel model = new EditAffinityGroupModel(affinityGroup, this, getClusterId(), getClusterName());
    model.init();
    setWindow(model);
}
#end_block

#method_before
public void setName(EntityModel<String> name) {
    this.name = name;
}
#method_after
private void setName(EntityModel<String> name) {
    this.name = name;
}
#end_block

#method_before
public void setDescription(EntityModel<String> description) {
    this.description = description;
}
#method_after
private void setDescription(EntityModel<String> description) {
    this.description = description;
}
#end_block

#method_before
public void setVmsSelectionModel(VmsSelectionModel vmsSelectionModel) {
    this.vmsSelectionModel = vmsSelectionModel;
}
#method_after
private void setVmsSelectionModel(VmsSelectionModel vmsSelectionModel) {
    this.vmsSelectionModel = vmsSelectionModel;
}
#end_block

#method_before
void onSave() {
    if (!validate()) {
        return;
    }
    if (getProgress() != null) {
        return;
    }
    AffinityGroup group = getAffinityGroup();
    group.setName(getName().getEntity());
    group.setDescription(getDescription().getEntity());
    group.setClusterId(clusterResolver.getClusterId());
    group.setEnforcementType(getEnforcementType().getSelectedItem());
    group.setPolarity(getPolarity().getSelectedItem());
    group.setEntityIds(getVmsSelectionModel().getSelectedVmIds());
    startProgress(null);
    Frontend.getInstance().runAction(getSaveActionType(), new AffinityGroupCRUDParameters(group.getId(), group), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            stopProgress();
            if (result != null && result.getReturnValue() != null && result.getReturnValue().getSucceeded()) {
                cancel();
            }
        }
    }, this);
}
#method_after
void onSave() {
    if (!validate()) {
        return;
    }
    if (getProgress() != null) {
        return;
    }
    AffinityGroup group = getAffinityGroup();
    group.setName(getName().getEntity());
    group.setDescription(getDescription().getEntity());
    group.setClusterId(clusterId);
    group.setEnforcing(getEnforcing().getEntity());
    group.setPositive(getPositive().getEntity());
    group.setEntityIds(getVmsSelectionModel().getSelectedVmIds());
    startProgress(null);
    Frontend.getInstance().runAction(saveActionType, new AffinityGroupCRUDParameters(group.getId(), group), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            stopProgress();
            if (result != null && result.getReturnValue() != null && result.getReturnValue().getSucceeded()) {
                cancel();
            }
        }
    }, this);
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    setAffinityGroupListModel(new VmAffinityGroupListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new VmGeneralModel());
    list.add(new VmInterfaceListModel());
    VmDiskListModel diskListModel = new VmDiskListModel();
    diskListModel.setSystemTreeContext(this);
    list.add(diskListModel);
    list.add(new VmSnapshotListModel());
    list.add(new VmEventListModel());
    list.add(new VmAppListModel());
    list.add(new PermissionListModel());
    list.add(getAffinityGroupListModel());
    list.add(new VmSessionsModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new VmGeneralModel());
    list.add(new VmInterfaceListModel());
    VmDiskListModel diskListModel = new VmDiskListModel();
    diskListModel.setSystemTreeContext(this);
    list.add(diskListModel);
    list.add(new VmSnapshotListModel());
    list.add(new VmEventListModel());
    list.add(new VmAppListModel());
    list.add(new PermissionListModel());
    list.add(new VmAffinityGroupListModel());
    list.add(new VmSessionsModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
public void setItems(Iterable value) {
    consoleModelsCache.updateCache(value);
    super.setItems(value);
}
#method_after
@Override
public void setItems(Iterable value) {
    consoleModelsCache.updateVmCache(value);
    super.setItems(value);
}
#end_block

#method_before
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForVm(((VM) getSelectedItem()));
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForEntity(getSelectedItem());
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void createSnapshot() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.setValidateByVmSnapshots(true);
    model.initialize();
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    // $NON-NLS-1$
    UICommand closeCommand = new UICommand("Cancel", this);
    closeCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.setCloseCommand(closeCommand);
}
#method_after
private void createSnapshot() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.setValidateByVmSnapshots(true);
    model.initialize();
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
}
#end_block

#method_before
public void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    tempVar.setVmType(model.getVmType().getSelectedItem());
    if (model.getQuota().getSelectedItem() != null) {
        tempVar.setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    tempVar.setVmOs(model.getOSType().getSelectedItem());
    tempVar.setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    tempVar.setSingleQxlPci(model.getIsSingleQxlEnabled().getEntity());
    tempVar.setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    // $NON-NLS-1$
    tempVar.setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : "");
    tempVar.setVmMemSizeMb(model.getMemSize().getEntity());
    tempVar.setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    tempVar.setVdsGroupId(model.getSelectedCluster().getId());
    tempVar.setTimeZone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? (model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    tempVar.setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    tempVar.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    tempVar.setStateless(model.getIsStateless().getEntity());
    tempVar.setRunAndPause(model.getIsRunAndPause().getEntity());
    tempVar.setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    tempVar.setDeleteProtected(model.getIsDeleteProtected().getEntity());
    tempVar.setSsoMethod(model.extractSelectedSsoMethod());
    tempVar.setDefaultBootSequence(model.getBootSequence());
    tempVar.setAutoStartup(model.getIsHighlyAvailable().getEntity());
    // $NON-NLS-1$
    tempVar.setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : "");
    tempVar.setUsbPolicy(vm.getUsbPolicy());
    tempVar.setInitrdUrl(vm.getInitrdUrl());
    tempVar.setKernelUrl(vm.getKernelUrl());
    tempVar.setKernelParams(vm.getKernelParams());
    tempVar.setDedicatedVmForVds(vm.getDedicatedVmForVds());
    tempVar.setMigrationSupport(vm.getMigrationSupport());
    tempVar.setVncKeyboardLayout(vm.getVncKeyboardLayout());
    VM newvm = tempVar;
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    newvm.setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    newvm.setPriority(prioritySelectedItem.getEntity());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newvm, model.getName().getEntity(), model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse(model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions(model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#method_after
public void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    tempVar.setVmType(model.getVmType().getSelectedItem());
    if (model.getQuota().getSelectedItem() != null) {
        tempVar.setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    tempVar.setVmOs(model.getOSType().getSelectedItem());
    tempVar.setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    tempVar.setSingleQxlPci(model.getIsSingleQxlEnabled().getEntity());
    tempVar.setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    // $NON-NLS-1$
    tempVar.setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : "");
    tempVar.setVmMemSizeMb(model.getMemSize().getEntity());
    tempVar.setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    tempVar.setVdsGroupId(model.getSelectedCluster().getId());
    tempVar.setTimeZone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? (model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    tempVar.setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    tempVar.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    tempVar.setStateless(model.getIsStateless().getEntity());
    tempVar.setRunAndPause(model.getIsRunAndPause().getEntity());
    tempVar.setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    tempVar.setDeleteProtected(model.getIsDeleteProtected().getEntity());
    tempVar.setSsoMethod(model.extractSelectedSsoMethod());
    tempVar.setDefaultBootSequence(model.getBootSequence());
    tempVar.setAutoStartup(model.getIsHighlyAvailable().getEntity());
    // $NON-NLS-1$
    tempVar.setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : "");
    tempVar.setUsbPolicy(vm.getUsbPolicy());
    tempVar.setInitrdUrl(vm.getInitrdUrl());
    tempVar.setKernelUrl(vm.getKernelUrl());
    tempVar.setKernelParams(vm.getKernelParams());
    tempVar.setDedicatedVmForVds(vm.getDedicatedVmForVds());
    tempVar.setMigrationSupport(vm.getMigrationSupport());
    tempVar.setDefaultVncKeyboardLayout(vm.getDefaultVncKeyboardLayout());
    VM newvm = tempVar;
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    newvm.setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    newvm.setPriority(prioritySelectedItem.getEntity());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newvm, model.getName().getEntity(), model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse(model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions(model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#end_block

#method_before
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    String name = model.getName().getEntity();
    // Save changes.
    VmTemplate template = model.getTemplate().getSelectedItem();
    getcurrentVm().setVmType(model.getVmType().getSelectedItem());
    getcurrentVm().setVmtGuid(template.getId());
    getcurrentVm().setName(name);
    if (model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    getcurrentVm().setVmOs(model.getOSType().getSelectedItem());
    getcurrentVm().setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setSingleQxlPci(model.getIsSingleQxlEnabled().getEntity());
    getcurrentVm().setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    getcurrentVm().setVmDescription(model.getDescription().getEntity());
    getcurrentVm().setComment(model.getComment().getEntity());
    getcurrentVm().setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setVmMemSizeMb(model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = model.getSelectedCluster().getId();
    getcurrentVm().setVdsGroupId(newClusterID);
    getcurrentVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? model.getTimeZone().getSelectedItem().getTimeZoneKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setUsbPolicy(model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setStateless(model.getIsStateless().getEntity());
    getcurrentVm().setRunAndPause(model.getIsRunAndPause().getEntity());
    getcurrentVm().setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    getcurrentVm().setDeleteProtected(model.getIsDeleteProtected().getEntity());
    getcurrentVm().setSsoMethod(model.extractSelectedSsoMethod());
    getcurrentVm().setDefaultBootSequence(model.getBootSequence());
    getcurrentVm().setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setAutoStartup(model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setInitrdUrl(model.getInitrd_path().getEntity());
    getcurrentVm().setKernelUrl(model.getKernel_path().getEntity());
    getcurrentVm().setKernelParams(model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomPropertySheet().serialize());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    getcurrentVm().setPriority(prioritySelectedItem.getEntity());
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    getcurrentVm().setVncKeyboardLayout(model.getVncKeyboardLayout().getSelectedItem());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    if (model.getIsAutoAssign().getEntity()) {
        getcurrentVm().setDedicatedVmForVds(null);
    } else {
        VDS defaultHost = model.getDefaultHost().getSelectedItem();
        getcurrentVm().setDedicatedVmForVds(defaultHost.getId());
    }
    getcurrentVm().setMigrationSupport(model.getMigrationMode().getSelectedItem());
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                    getWindow().stopProgress();
                    cancel();
                    setGuideContext(vmId);
                    updateActionAvailability();
                    getGuideCommand().execute();
                }

                @Override
                public void queryFailed() {
                    getWindow().stopProgress();
                    cancel();
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager), this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if (model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vmListModel.getcurrentVm(), unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, template.getId());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VmManagementParametersBase params = new VmManagementParametersBase(getcurrentVm());
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vmListModel.getcurrentVm());
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vmListModel.getcurrentVm().getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#method_after
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    String name = model.getName().getEntity();
    // Save changes.
    VmTemplate template = model.getTemplate().getSelectedItem();
    getcurrentVm().setVmType(model.getVmType().getSelectedItem());
    getcurrentVm().setVmtGuid(template.getId());
    getcurrentVm().setName(name);
    if (model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    getcurrentVm().setVmOs(model.getOSType().getSelectedItem());
    getcurrentVm().setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setSingleQxlPci(model.getIsSingleQxlEnabled().getEntity());
    getcurrentVm().setAllowConsoleReconnect(model.getAllowConsoleReconnect().getEntity());
    getcurrentVm().setVmDescription(model.getDescription().getEntity());
    getcurrentVm().setComment(model.getComment().getEntity());
    getcurrentVm().setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setVmMemSizeMb(model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = model.getSelectedCluster().getId();
    getcurrentVm().setVdsGroupId(newClusterID);
    getcurrentVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? model.getTimeZone().getSelectedItem().getTimeZoneKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setUsbPolicy(model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setStateless(model.getIsStateless().getEntity());
    getcurrentVm().setRunAndPause(model.getIsRunAndPause().getEntity());
    getcurrentVm().setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    getcurrentVm().setDeleteProtected(model.getIsDeleteProtected().getEntity());
    getcurrentVm().setSsoMethod(model.extractSelectedSsoMethod());
    getcurrentVm().setDefaultBootSequence(model.getBootSequence());
    getcurrentVm().setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setAutoStartup(model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setInitrdUrl(model.getInitrd_path().getEntity());
    getcurrentVm().setKernelUrl(model.getKernel_path().getEntity());
    getcurrentVm().setKernelParams(model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomPropertySheet().serialize());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    getcurrentVm().setPriority(prioritySelectedItem.getEntity());
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    getcurrentVm().setDefaultVncKeyboardLayout(model.getVncKeyboardLayout().getSelectedItem());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    if (model.getIsAutoAssign().getEntity()) {
        getcurrentVm().setDedicatedVmForVds(null);
    } else {
        VDS defaultHost = model.getDefaultHost().getSelectedItem();
        getcurrentVm().setDedicatedVmForVds(defaultHost.getId());
    }
    getcurrentVm().setMigrationSupport(model.getMigrationMode().getSelectedItem());
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                    getWindow().stopProgress();
                    cancel();
                    setGuideContext(vmId);
                    updateActionAvailability();
                    getGuideCommand().execute();
                }

                @Override
                public void queryFailed() {
                    getWindow().stopProgress();
                    cancel();
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager), this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if (model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vmListModel.getcurrentVm(), unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, template.getId());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VmManagementParametersBase params = new VmManagementParametersBase(getcurrentVm());
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vmListModel.getcurrentVm());
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vmListModel.getcurrentVm().getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#end_block

#method_before
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.PropertyName.equals("status")) {
        // $NON-NLS-1$
        updateActionAvailability();
    }
}
#method_after
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.propertyName.equals("status")) {
        // $NON-NLS-1$
        updateActionAvailability();
    }
}
#end_block

#method_before
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consoleModelsCache.getVmConsolesForVm(vm).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consoleModelsCache.getVmConsolesForEntity(vm).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consoleModelsCache.getVmConsolesForVm(vm).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#method_after
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consoleModelsCache.getVmConsolesForEntity(vm).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<Snapshot, VmListModel, VmSnapshotListModel> getVmSnapshotListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VmSnapshotCreatePopupPresenterWidget> createPopupProvider, final Provider<VmClonePopupPresenterWidget> cloneVmPopupProvider, final Provider<VmSnapshotPreviewPopupPresenterWidget> previewPopupProvider) {
    return new SearchableDetailTabModelProvider<Snapshot, VmListModel, VmSnapshotListModel>(eventBus, defaultConfirmPopupProvider, VmListModel.class, VmSnapshotListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmSnapshotListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return createPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
                getModel().setSystemTreeSelectedItem(this.getMainModel().getSystemTreeSelectedItem());
                return cloneVmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getPreviewCommand()) {
                return previewPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<Snapshot, VmListModel, VmSnapshotListModel> getVmSnapshotListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VmSnapshotCreatePopupPresenterWidget> createPopupProvider, final Provider<VmClonePopupPresenterWidget> cloneVmPopupProvider, final Provider<VmSnapshotPreviewPopupPresenterWidget> previewPopupProvider, final Provider<VmSnapshotCustomPreviewPopupPresenterWidget> customPreviewPopupProvider) {
    return new SearchableDetailTabModelProvider<Snapshot, VmListModel, VmSnapshotListModel>(eventBus, defaultConfirmPopupProvider, VmListModel.class, VmSnapshotListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmSnapshotListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand()) {
                return createPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
                getModel().setSystemTreeSelectedItem(this.getMainModel().getSystemTreeSelectedItem());
                return cloneVmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getPreviewCommand()) {
                return previewPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCustomPreviewCommand()) {
                return customPreviewPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
}
#end_block

#method_before
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVolumeList(asyncQuery, cluster.getName());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVmListByClusterName(asyncQuery1, cluster.getName());
            AsyncQuery asyncQuery2 = new AsyncQuery();
            asyncQuery2.setModel(clusterModel);
            asyncQuery2.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VDS> vdsList = (ArrayList<VDS>) result;
                    if (vdsList.size() > 0) {
                        clusterModel.getEnableTrustedService().setIsChangable(false);
                        clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
                    }
                }
            };
            AsyncDataProvider.getHostListByCluster(asyncQuery2, cluster.getName());
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVolumeList(asyncQuery, cluster.getName());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVmListByClusterName(asyncQuery1, cluster.getName());
            AsyncQuery asyncQuery2 = new AsyncQuery();
            asyncQuery2.setModel(clusterModel);
            asyncQuery2.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VDS> vdsList = (ArrayList<VDS>) result;
                    if (vdsList.size() > 0) {
                        clusterModel.getEnableTrustedService().setIsChangable(false);
                        clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
                    }
                }
            };
            AsyncDataProvider.getHostListByCluster(asyncQuery2, cluster.getName());
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setdescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setdescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
public void init(List<VM> vms, List<Guid> usedVms) {
    if (vms == null || usedVms == null) {
        return;
    }
    allVmMap = new HashMap<Guid, VM>();
    for (VM vm : vms) {
        allVmMap.put(vm.getId(), vm);
    }
    for (Guid guid : usedVms) {
        usedVmMap.put(guid, allVmMap.get(guid));
    }
    disableEvent = true;
    VmSelectionModel selectionModel;
    List<VmSelectionModel> list = new ArrayList<VmSelectionModel>();
    for (Entry<Guid, VM> entry : usedVmMap.entrySet()) {
        Pair<String, VM> pair = new Pair<String, VM>(entry.getValue().getName(), entry.getValue());
        selectionModel = createNewLineModel(pair);
        selectionModel.getVms().setSelectedItem(pair);
        list.add(selectionModel);
    }
    disableEvent = false;
    setItems(list);
}
#method_after
public void init(List<VM> vms, List<Guid> usedVms) {
    if (vms == null || usedVms == null) {
        return;
    }
    allVmNameMap = new HashMap<String, VM>();
    Map<Guid, VM> vmmMap = new HashMap<Guid, VM>();
    for (VM vm : vms) {
        allVmNameMap.put(vm.getName(), vm);
        vmmMap.put(vm.getId(), vm);
    }
    Set<String> usedVmNames = new HashSet<String>();
    for (Guid guid : usedVms) {
        usedVmNames.add(vmmMap.get(guid).getName());
    }
    init(allVmNameMap.keySet(), usedVmNames);
}
#end_block

#method_before
public VmSelectionModel createNewLineModel() {
    return createNewLineModel(null);
}
#method_after
@Override
public KeyValueLineModel createNewLineModel(String key) {
    KeyValueLineModel keyValueLineModel = super.createNewLineModel(key);
    keyValueLineModel.getValue().setIsAvailable(false);
    keyValueLineModel.getValues().setIsAvailable(false);
    return keyValueLineModel;
}
#end_block

#method_before
public List<Guid> getSelectedVmIds() {
    List<Guid> list = new ArrayList<Guid>();
    for (VmSelectionModel vmSelectionModel : getItems()) {
        Pair<String, VM> selectedItem = vmSelectionModel.getVms().getSelectedItem();
        if (isKeyValid(selectedItem)) {
            list.add(selectedItem.getSecond().getId());
        }
    }
    return list;
}
#method_after
public List<Guid> getSelectedVmIds() {
    List<Guid> list = new ArrayList<Guid>();
    for (KeyValueLineModel keyModel : getItems()) {
        String selectedItem = keyModel.getKeys().getSelectedItem();
        if (isKeyValid(selectedItem)) {
            list.add(allVmNameMap.get(selectedItem).getId());
        }
    }
    return list;
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
}
#end_block

#method_before
private void localize(ApplicationConstants constants) {
    nameEditor.setLabel(constants.affinityGroupNameLabel());
    descriptionEditor.setLabel(constants.affinityDescriptionLabel());
    polarityEditor.setLabel(constants.affinityGroupPolarityLabel());
    enforcementTypeEditor.setLabel(constants.affinityGroupEnforceTypeLabel());
}
#method_after
private void localize(ApplicationConstants constants) {
    nameEditor.setLabel(constants.affinityGroupNameLabel());
    descriptionEditor.setLabel(constants.affinityDescriptionLabel());
    positiveEditor.setLabel(constants.affinityGroupPolarityLabel());
    enforcingEditor.setLabel(constants.affinityGroupEnforceTypeLabel());
}
#end_block

#method_before
void localize() {
    // Boot Options
    runAsStatelessEditor.setLabel(constants.runOncePopupRunAsStatelessLabel());
    runAndPauseEditor.setLabel(constants.runOncePopupRunAndPauseLabel());
    attachFloppyEditor.setLabel(constants.runOncePopupAttachFloppyLabel());
    attachIsoEditor.setLabel(constants.runOncePopupAttachIsoLabel());
    bootSequenceLabel.setText(constants.runOncePopupBootSequenceLabel());
    // Linux Boot Options
    kernelPathEditor.setLabel(constants.runOncePopupKernelPathLabel());
    initrdPathEditor.setLabel(constants.runOncePopupInitrdPathLabel());
    kernelParamsEditor.setLabel(constants.runOncePopupKernelParamsLabel());
    // WindowsSysprep
    sysprepToEnableLabel.setText(constants.runOnceSysPrepToEnableLabel());
    sysPrepDomainNameListBoxEditor.setLabel(constants.runOncePopupSysPrepDomainNameLabel());
    useAlternateCredentialsEditor.setLabel(constants.runOnceUseAlternateCredentialsLabel());
    sysPrepUserNameEditor.setLabel(constants.runOncePopupSysPrepUserNameLabel());
    sysPrepPasswordEditor.setLabel(constants.runOncePopupSysPrepPasswordLabel());
    // Linux Cloud-Init
    cloudInitEnabledEditor.setLabel(constants.runOncePopupCloudInitLabel());
    // Display Protocol
    displayConsoleVncEditor.setLabel(constants.runOncePopupDisplayConsoleVncLabel());
    displayConsoleSpiceEditor.setLabel(constants.runOncePopupDisplayConsoleSpiceLabel());
    // Host Tab
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
}
#method_after
void localize() {
    // Boot Options
    runAsStatelessEditor.setLabel(constants.runOncePopupRunAsStatelessLabel());
    runAndPauseEditor.setLabel(constants.runOncePopupRunAndPauseLabel());
    attachFloppyEditor.setLabel(constants.runOncePopupAttachFloppyLabel());
    attachIsoEditor.setLabel(constants.runOncePopupAttachIsoLabel());
    bootSequenceLabel.setText(constants.runOncePopupBootSequenceLabel());
    // Linux Boot Options
    kernelPathEditor.setLabel(constants.runOncePopupKernelPathLabel());
    initrdPathEditor.setLabel(constants.runOncePopupInitrdPathLabel());
    kernelParamsEditor.setLabel(constants.runOncePopupKernelParamsLabel());
    // WindowsSysprep
    sysprepToEnableLabel.setText(constants.runOnceSysPrepToEnableLabel());
    sysPrepDomainNameListBoxEditor.setLabel(constants.runOncePopupSysPrepDomainNameLabel());
    useAlternateCredentialsEditor.setLabel(constants.runOnceUseAlternateCredentialsLabel());
    sysPrepUserNameEditor.setLabel(constants.runOncePopupSysPrepUserNameLabel());
    sysPrepPasswordEditor.setLabel(constants.runOncePopupSysPrepPasswordLabel());
    // Linux Cloud-Init
    cloudInitEnabledEditor.setLabel(constants.runOncePopupCloudInitLabel());
    // Display Protocol
    displayConsoleVncEditor.setLabel(constants.runOncePopupDisplayConsoleVncLabel());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    displayConsoleSpiceEditor.setLabel(constants.runOncePopupDisplayConsoleSpiceLabel());
    // Host Tab
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
}
#end_block

#method_before
private void addStyles() {
    importGlusterConfigurationEditor.addContentWidgetStyleName(style.editorContentWidget());
    migrateOnErrorOption_NOEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_YESEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_HA_ONLYEditor.addContentWidgetStyleName(style.label());
    countThreadsAsCoresEditor.setContentWidgetStyleName(style.fullWidth());
    enableTrustedServiceEditor.setContentWidgetStyleName(style.fullWidth());
}
#method_after
private void addStyles() {
    importGlusterConfigurationEditor.addContentWidgetStyleName(style.editorContentWidget());
    migrateOnErrorOption_NOEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_YESEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_HA_ONLYEditor.addContentWidgetStyleName(style.label());
    countThreadsAsCoresEditor.setContentWidgetStyleName(style.fullWidth());
    enableTrustedServiceEditor.setContentWidgetStyleName(style.fullWidth());
    enableHaReservationEditor.setContentWidgetStyleName(style.fullWidth());
}
#end_block

#method_before
private void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    commentEditor.setLabel(constants.commentLabel());
    cPUEditor.setLabel(constants.clusterPopupCPULabel());
    architectureEditor.setLabel(constants.clusterPopupArchitectureLabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    enableOvirtServiceOptionEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceOptionEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupPasswordLabel());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.asRadioButton().setHTML(templates.radioButtonLabel(constants.clusterPopupOptimizationNoneLabel()));
    cpuThreadsPanelTitle.setText(constants.clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
    clusterPolicyTab.setLabel(constants.clusterPopupClusterPolicyTabLabel());
    additionPropsPanelTitle.setText(constants.clusterPolicyAdditionalPropsPanelTitle());
    enableTrustedServiceEditor.setLabel(constants.clusterPolicyEnableTrustedServiceLabel());
    clusterPolicyEditor.setLabel(constants.clusterPolicySelectPolicyLabel());
    enableBallooning.setLabel(constants.enableBallooningLabel());
    schedulerOptimizationPanelTitle.setText(constants.schedulerOptimizationPanelLabel());
    optimizeForUtilizationEditor.setLabel(constants.optimizeForUtilizationLabel());
    optimizeForSpeedEditor.setLabel(constants.optimizeForSpeedLabel());
    guarantyResourcesEditor.setLabel(constants.guarantyResourcesLabel());
    allowOverbookingEditor.setLabel(constants.allowOverbookingLabel());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    consoleTab.setLabel(constants.consoleTabLabel());
}
#method_after
private void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    commentEditor.setLabel(constants.commentLabel());
    cPUEditor.setLabel(constants.clusterPopupCPULabel());
    architectureEditor.setLabel(constants.clusterPopupArchitectureLabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    enableOvirtServiceOptionEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceOptionEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupPasswordLabel());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.asRadioButton().setHTML(templates.radioButtonLabel(constants.clusterPopupOptimizationNoneLabel()));
    cpuThreadsPanelTitle.setText(constants.clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
    clusterPolicyTab.setLabel(constants.clusterPopupClusterPolicyTabLabel());
    additionPropsPanelTitle.setText(constants.clusterPolicyAdditionalPropsPanelTitle());
    enableTrustedServiceEditor.setLabel(constants.clusterPolicyEnableTrustedServiceLabel());
    enableHaReservationEditor.setLabel(constants.clusterPolicyEnableHaReservationLabel());
    clusterPolicyEditor.setLabel(constants.clusterPolicySelectPolicyLabel());
    enableBallooning.setLabel(constants.enableBallooningLabel());
    schedulerOptimizationPanelTitle.setText(constants.schedulerOptimizationPanelLabel());
    optimizeForUtilizationEditor.setLabel(constants.optimizeForUtilizationLabel());
    optimizeForSpeedEditor.setLabel(constants.optimizeForSpeedLabel());
    guarantyResourcesEditor.setLabel(constants.guarantyResourcesLabel());
    allowOverbookingEditor.setLabel(constants.allowOverbookingLabel());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    consoleTab.setLabel(constants.consoleTabLabel());
}
#end_block

#method_before
private void initCheckBoxEditors() {
    importGlusterConfigurationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    countThreadsAsCoresEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableTrustedServiceEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableBallooning = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableBallooning.getContentWidgetContainer().setWidth("350px");
}
#method_after
private void initCheckBoxEditors() {
    importGlusterConfigurationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    countThreadsAsCoresEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableTrustedServiceEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableHaReservationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableBallooning = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableBallooning.getContentWidgetContainer().setWidth("350px");
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Windows Sysprep
    domainEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<EntityModel<DisplayType>>(new NullSafeRenderer<EntityModel<DisplayType>>() {

        @Override
        public String renderNullSafe(EntityModel<DisplayType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new AbstractRenderer<String>() {

        final String globalLayout = (String) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayout);

        @Override
        public String render(String object) {
            if (object == null) {
                return messages.globalVncKeyboardLayoutCaption(globalLayout);
            } else {
                return object;
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Windows Sysprep
    domainEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<EntityModel<DisplayType>>(new NullSafeRenderer<EntityModel<DisplayType>>() {

        @Override
        public String renderNullSafe(EntityModel<DisplayType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages));
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#end_block

#method_before
protected void init(Set<String> allKeys, Set<String> usedKeys) {
    this.allKeys = new HashSet<String>(allKeys);
    this.usedKeys = new HashSet<String>(usedKeys);
    List<KeyValueLineModel> list = new ArrayList<KeyValueLineModel>();
    KeyValueLineModel lineModel;
    disableEvent = true;
    for (String key : usedKeys) {
        lineModel = createNewLineModel(key);
        lineModel.getKeys().setSelectedItem(key);
        fillLineModel(lineModel, key);
        list.add(lineModel);
    }
    disableEvent = false;
    setItems(list);
}
#method_after
protected void init(Set<String> allKeys, Set<String> usedKeys) {
    this.allKeys = new HashSet<String>(allKeys);
    this.usedKeys = new HashSet<String>(usedKeys);
    List<KeyValueLineModel> list = new ArrayList<KeyValueLineModel>();
    disableEvent = true;
    for (String key : usedKeys) {
        KeyValueLineModel lineModel = createNewLineModel(key);
        lineModel.getKeys().setSelectedItem(key);
        setValueByKey(lineModel, key);
        list.add(lineModel);
    }
    disableEvent = false;
    setItems(list);
}
#end_block

#method_before
public List<String> getAvailableKeys(String key) {
    List<String> list = getAvailableKeys();
    boolean realKey = isKeyValid(key);
    if (realKey && !list.contains(key)) {
        list.add(0, key);
    }
    list.remove(selectKey);
    list.remove(noKeys);
    if (!realKey) {
        if (list.size() > 0) {
            list.add(0, selectKey);
        } else {
            list.add(noKeys);
        }
    }
    return list;
}
#method_after
private List<String> getAvailableKeys(String key) {
    List<String> list = getAvailableKeys();
    boolean realKey = isKeyValid(key);
    if (realKey && !list.contains(key)) {
        list.add(0, key);
    }
    list.remove(selectKey);
    list.remove(noKeys);
    if (!realKey) {
        if (list.size() > 0) {
            list.add(0, selectKey);
        } else {
            list.add(noKeys);
        }
    }
    return list;
}
#end_block

#method_before
public List<String> getAvailableKeys() {
    List<String> list = (allKeys == null) ? new LinkedList<String>() : new LinkedList<String>(allKeys);
    list.removeAll(getUsedKeys());
    if (list.size() > 0) {
        list.add(0, selectKey);
    } else {
        list.add(noKeys);
    }
    return list;
}
#method_after
private List<String> getAvailableKeys() {
    List<String> list = (allKeys == null) ? new LinkedList<String>() : new LinkedList<String>(allKeys);
    list.removeAll(getUsedKeys());
    if (list.size() > 0) {
        list.add(0, selectKey);
    } else {
        list.add(noKeys);
    }
    return list;
}
#end_block

#method_before
@Override
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    final Pair<List<Guid>, Guid> migrationRule = super.balance(cluster, hosts, parameters, messages);
    List<VDS> allHosts = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(cluster.getId());
    Pair<VDS, VDSStatus> action = evaluatePowerManagementSituation(getDownHosts(allHosts, parameters), getMaintenanceHosts(allHosts, parameters), getEmptyHosts(allHosts, parameters), parameters);
    if (action != null)
        processPmAction(action);
    return migrationRule;
}
#method_after
@Override
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    final Pair<List<Guid>, Guid> migrationRule = super.balance(cluster, hosts, parameters, messages);
    List<VDS> allHosts = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(cluster.getId());
    List<VDS> emptyHosts = new ArrayList<>();
    List<VDS> maintenanceHosts = new ArrayList<>();
    List<VDS> downHosts = new ArrayList<>();
    getHostLists(allHosts, parameters, emptyHosts, maintenanceHosts, downHosts);
    Pair<VDS, VDSStatus> action = evaluatePowerManagementSituation(cluster, downHosts, maintenanceHosts, emptyHosts, parameters);
    if (action != null) {
        processPmAction(action);
    }
    return migrationRule;
}
#end_block

#method_before
private void processPmAction(Pair<VDS, VDSStatus> action) {
    VDS vds = action.getFirst();
    VDSStatus currentStatus = vds.getStatus();
    VDSStatus targetStatus = action.getSecond();
    if (targetStatus == VDSStatus.Maintenance && currentStatus == VDSStatus.Up) {
        logAction(vds, AuditLogType.PM_POLICY_UP_TO_MAINTENANCE);
        /* Up -> Maint */
        List<Guid> vdsList = new ArrayList<>(1);
        vdsList.add(vds.getId());
        MaintenanceNumberOfVdssParameters parameters = new MaintenanceNumberOfVdssParameters(vdsList, true, true);
        Backend.getInstance().runInternalAction(VdcActionType.MaintenanceNumberOfVdss, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Down && currentStatus == VDSStatus.Maintenance) {
        logAction(vds, AuditLogType.PM_POLICY_MAINTENANCE_TO_DOWN);
        /* Maint -> Down */
        FenceVdsActionParameters parameters = new FenceVdsActionParameters(vds.getId(), FenceActionType.Start, true);
        Backend.getInstance().runInternalAction(VdcActionType.StopVds, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Up && currentStatus == VDSStatus.Maintenance) {
        logAction(vds, AuditLogType.PM_POLICY_TO_UP);
        /* Maint -> Up */
        VdsActionParameters parameters = new VdsActionParameters(vds.getId());
        Backend.getInstance().runInternalAction(VdcActionType.ActivateVds, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Up && currentStatus == VDSStatus.Down) {
        logAction(vds, AuditLogType.PM_POLICY_TO_UP);
        /* Down -> Up */
        FenceVdsActionParameters parameters = new FenceVdsActionParameters(vds.getId(), FenceActionType.Start);
        Backend.getInstance().runInternalAction(VdcActionType.StartVds, parameters, ExecutionHandler.createInternalJobContext());
    } else {
    /* Should not ever happen... */
    }
}
#method_after
private void processPmAction(Pair<VDS, VDSStatus> action) {
    VDS vds = action.getFirst();
    VDSStatus currentStatus = vds.getStatus();
    VDSStatus targetStatus = action.getSecond();
    if (targetStatus == VDSStatus.Maintenance && currentStatus == VDSStatus.Up) {
        logAction(vds, AuditLogType.PM_POLICY_UP_TO_MAINTENANCE);
        /* Up -> Maint */
        Guid[] vdsList = new Guid[] { vds.getId() };
        MaintenanceNumberOfVdssParameters parameters = new MaintenanceNumberOfVdssParameters(Arrays.asList(vdsList), true, true);
        Backend.getInstance().runInternalAction(VdcActionType.MaintenanceNumberOfVdss, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Down && currentStatus == VDSStatus.Maintenance) {
        logAction(vds, AuditLogType.PM_POLICY_MAINTENANCE_TO_DOWN);
        /* Maint -> Down */
        FenceVdsActionParameters parameters = new FenceVdsActionParameters(vds.getId(), FenceActionType.Stop, true);
        Backend.getInstance().runInternalAction(VdcActionType.StopVds, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Up && currentStatus == VDSStatus.Maintenance) {
        logAction(vds, AuditLogType.PM_POLICY_TO_UP);
        /* Maint -> Up */
        VdsActionParameters parameters = new VdsActionParameters(vds.getId());
        Backend.getInstance().runInternalAction(VdcActionType.ActivateVds, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Up && currentStatus == VDSStatus.Down) {
        logAction(vds, AuditLogType.PM_POLICY_TO_UP);
        /* Down -> Up */
        FenceVdsActionParameters parameters = new FenceVdsActionParameters(vds.getId(), FenceActionType.Start);
        Backend.getInstance().runInternalAction(VdcActionType.StartVds, parameters, ExecutionHandler.createInternalJobContext());
    } else {
        /* Should not ever happen... */
        log.errorFormat("Unknown host power management transition {0} -> {1}", currentStatus.toString(), targetStatus.toString());
    }
}
#end_block

#method_before
protected Pair<VDS, VDSStatus> evaluatePowerManagementSituation(List<VDS> pmDownHosts, List<VDS> pmMaintenanceHosts, List<VDS> emptyHosts, Map<String, String> parameters) {
    final int requiredReserve = tryParseWithDefault(parameters.get("HostsInReserve"), Config.<Integer>getValue(ConfigValues.HostsInReserve));
    final int enableAutoPM = tryParseWithDefault(parameters.get("EnableAutomaticHostPowerManagement"), Config.<Integer>getValue(ConfigValues.EnableAutomaticHostPowerManagement));
    /* Automatic power management is disabled */
    if (enableAutoPM == 0)
        return null;
    /* We need more hosts but there are no available for us */
    if (requiredReserve > emptyHosts.size() && pmDownHosts.isEmpty() && pmMaintenanceHosts.isEmpty())
        return null;
    else /* We have enough free hosts so shut some hosts in maintenance down
           keep at least one spare in maintenance during the process.
         */
    if (requiredReserve < emptyHosts.size() && pmMaintenanceHosts.size() > 1) {
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Down);
    } else /* We do have enough empty hosts to put something to maintenance */
    if (requiredReserve < emptyHosts.size()) {
        /* Find hosts with automatic PM enabled that are not the current SPM */
        List<VDS> hostsWithAutoPM = LinqUtils.filter(emptyHosts, new Predicate<VDS>() {

            @Override
            public boolean eval(VDS vds) {
                return !vds.isDisablePowerManagementPolicy() && vds.getSpmStatus() != VdsSpmStatus.SPM && vds.getpm_enabled();
            }
        });
        return hostsWithAutoPM.isEmpty() ? null : new Pair<>(hostsWithAutoPM.get(0), VDSStatus.Maintenance);
    } else /* We have the right amount of empty hosts to start shutting the
           hosts that are resting in maintenance down.
         */
    if (requiredReserve == emptyHosts.size() && pmMaintenanceHosts.isEmpty() == false) {
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Down);
    } else /* We do not have enough free hosts, but we still have some hosts
           in maintenance. We can easily activate those.
         */
    if (requiredReserve > emptyHosts.size() && pmMaintenanceHosts.isEmpty() == false) {
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Up);
    } else /* We do not have enough free hosts and no hosts in pm maintenance,
           so we need to start some hosts up.
         */
    if (requiredReserve > emptyHosts.size() && pmMaintenanceHosts.isEmpty()) {
        return new Pair<>(pmDownHosts.get(0), VDSStatus.Up);
    }
    return null;
}
#method_after
protected Pair<VDS, VDSStatus> evaluatePowerManagementSituation(VDSGroup cluster, List<VDS> pmDownHosts, List<VDS> pmMaintenanceHosts, List<VDS> emptyHosts, Map<String, String> parameters) {
    final int requiredReserve = tryParseWithDefault(parameters.get("HostsInReserve"), Config.<Integer>getValue(ConfigValues.HostsInReserve));
    String enableAutoPMParameter = parameters.get("EnableAutomaticHostPowerManagement");
    Boolean enableAutoPM = enableAutoPMParameter == null ? null : Boolean.valueOf(enableAutoPMParameter);
    if (enableAutoPM == null) {
        enableAutoPM = Config.<Boolean>getValue(ConfigValues.EnableAutomaticHostPowerManagement);
    }
    /* Automatic power management is disabled */
    if (!enableAutoPM.booleanValue()) {
        log.infoFormat("Automatic power management is disabled for cluster {0}.", cluster.getName());
        return null;
    }
    /* We need more hosts but there are no available for us */
    if (requiredReserve > emptyHosts.size() && pmDownHosts.isEmpty() && pmMaintenanceHosts.isEmpty()) {
        log.infoFormat("Cluster {0} does not have enough spare hosts, but no additional host is available.", cluster.getName());
        return null;
    } else /* We have enough free hosts so shut some hosts in maintenance down
           keep at least one spare in maintenance during the process.
         */
    if (requiredReserve < emptyHosts.size() && pmMaintenanceHosts.size() > 1) {
        log.infoFormat("Cluster {0} does have enough spare hosts, shutting one host down.", cluster.getName());
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Down);
    } else /* We do have enough empty hosts to put something to maintenance */
    if (requiredReserve < emptyHosts.size()) {
        /* Find hosts with automatic PM enabled that are not the current SPM */
        List<VDS> hostsWithAutoPM = LinqUtils.filter(emptyHosts, new Predicate<VDS>() {

            @Override
            public boolean eval(VDS vds) {
                return !vds.isDisablePowerManagementPolicy() && vds.getSpmStatus() != VdsSpmStatus.SPM && vds.getpm_enabled();
            }
        });
        if (hostsWithAutoPM.isEmpty()) {
            log.infoFormat("Cluster {0} does have too many spare hosts, but none can be put to maintenance.", cluster.getName());
            return null;
        } else {
            return new Pair<>(hostsWithAutoPM.get(0), VDSStatus.Maintenance);
        }
    } else /* We have the right amount of empty hosts to start shutting the
           hosts that are resting in maintenance down.
         */
    if (requiredReserve == emptyHosts.size() && pmMaintenanceHosts.isEmpty() == false) {
        log.infoFormat("Cluster {0} does have enough spare hosts, shutting one host down.", cluster.getName());
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Down);
    } else /* We do not have enough free hosts, but we still have some hosts
           in maintenance. We can easily activate those.
         */
    if (requiredReserve > emptyHosts.size() && pmMaintenanceHosts.isEmpty() == false) {
        log.infoFormat("Cluster {0} does not have enough spare hosts, reactivating one.", cluster.getName());
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Up);
    } else /* We do not have enough free hosts and no hosts in pm maintenance,
           so we need to start some hosts up.
         */
    if (requiredReserve > emptyHosts.size() && pmMaintenanceHosts.isEmpty()) {
        log.infoFormat("Cluster {0} does not have enough spare hosts, trying to start one up.", cluster.getName());
        return new Pair<>(pmDownHosts.get(0), VDSStatus.Up);
    }
    /* All power management constraints were satisfied, no need to do anything */
    return null;
}
#end_block

#method_before
public boolean getKeepPolicyPMEnabled() {
    return _keepPolicyPMEnabled;
}
#method_after
public boolean getKeepPolicyPMEnabled() {
    return keepPolicyPMEnabled;
}
#end_block

#method_before
public void setKeepPolicyPMEnabled(boolean _keepPolicyPMEnabled) {
    this._keepPolicyPMEnabled = _keepPolicyPMEnabled;
}
#method_after
public void setKeepPolicyPMEnabled(boolean _keepPolicyPMEnabled) {
    this.keepPolicyPMEnabled = _keepPolicyPMEnabled;
}
#end_block

#method_before
public boolean getKeepPolicyPMEnabled() {
    return _keepPolicyPMEnabled;
}
#method_after
public boolean getKeepPolicyPMEnabled() {
    return keepPolicyPMEnabled;
}
#end_block

#method_before
public void setKeepPolicyPMEnabled(boolean _keepPolicyPMEnabled) {
    this._keepPolicyPMEnabled = _keepPolicyPMEnabled;
}
#method_after
public void setKeepPolicyPMEnabled(boolean _keepPolicyPMEnabled) {
    this.keepPolicyPMEnabled = _keepPolicyPMEnabled;
}
#end_block

#method_before
private void MoveVdssToGoingToMaintenanceMode() {
    List<VDS> spms = new ArrayList<VDS>();
    for (VDS vds : vdssToMaintenance.values()) {
        if (vds.getSpmStatus() != VdsSpmStatus.SPM) {
            setVdsStatusToPrepareForMaintaice(vds);
        } else {
            spms.add(vds);
        }
    }
    for (VDS vds : spms) {
        setVdsStatusToPrepareForMaintaice(vds);
    }
    cancelIncommingMigrations();
    freeLock();
}
#method_after
private void MoveVdssToGoingToMaintenanceMode() {
    List<VDS> spms = new ArrayList<VDS>();
    Iterator<VDS> it = vdssToMaintenance.values().iterator();
    while (it.hasNext()) {
        VDS vds = it.next();
        // SPMs will move to Prepare For Maintenance later after standard hosts
        if (vds.getSpmStatus() != VdsSpmStatus.SPM) {
            if (!setVdsStatusToPrepareForMaintenance(vds)) {
                it.remove();
            }
        } else {
            spms.add(vds);
        }
    }
    for (VDS vds : spms) {
        if (!setVdsStatusToPrepareForMaintenance(vds)) {
            vdssToMaintenance.remove(vds.getId());
        }
    }
    cancelIncommingMigrations();
    freeLock();
}
#end_block

#method_before
private void MigrateAllVdss() {
    for (Guid vdsId : getParameters().getVdsIdList()) {
        // ParametersCurrentUser = CurrentUser
        MaintenanceVdsParameters tempVar = new MaintenanceVdsParameters(vdsId, getParameters().getIsInternal());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCorrelationId(getParameters().getCorrelationId());
        VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.MaintenanceVds, tempVar, ExecutionHandler.createInternalJobContext());
        if (!result.getCanDoAction()) {
            getReturnValue().getCanDoActionMessages().addAll(result.getCanDoActionMessages());
            getReturnValue().setCanDoAction(false);
        }
    }
}
#method_after
private void MigrateAllVdss() {
    for (Guid vdsId : vdssToMaintenance.keySet()) {
        // ParametersCurrentUser = CurrentUser
        MaintenanceVdsParameters tempVar = new MaintenanceVdsParameters(vdsId, getParameters().getIsInternal());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCorrelationId(getParameters().getCorrelationId());
        VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.MaintenanceVds, tempVar, ExecutionHandler.createInternalJobContext());
        if (!result.getCanDoAction()) {
            getReturnValue().getCanDoActionMessages().addAll(result.getCanDoActionMessages());
            getReturnValue().setCanDoAction(false);
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    MoveVdssToGoingToMaintenanceMode();
    MigrateAllVdss();
    // set network to operational / non-operational
    for (Guid id : _vdsGroupIds) {
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(id);
        for (Network net : networks) {
            NetworkClusterHelper.setStatus(id, net);
        }
    }
    // clear the automatic PM flag unless instructed otherwise
    if (!getParameters().getKeepPolicyPMEnabled()) {
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
            vds.setPowerManagementControlledByPolicy(false);
            DbFacade.getInstance().getVdsDynamicDao().update(vds.getDynamicData());
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    MoveVdssToGoingToMaintenanceMode();
    MigrateAllVdss();
    // find clusters for hosts that should move to maintenance
    Set<Guid> clusters = new HashSet<>();
    for (VDS vds : vdssToMaintenance.values()) {
        if (!clusters.contains(vds.getVdsGroupId())) {
            clusters.add(vds.getVdsGroupId());
            // set network to operational / non-operational
            List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(vds.getVdsGroupId());
            for (Network net : networks) {
                NetworkClusterHelper.setStatus(vds.getVdsGroupId(), net);
            }
        }
    }
    // clear the automatic PM flag unless instructed otherwise
    if (!getParameters().getKeepPolicyPMEnabled()) {
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
            vds.setPowerManagementControlledByPolicy(false);
            getDbFacade().getVdsDynamicDao().updateVdsDynamicPowerManagementPolicyFlag(getVdsId(), getVds().getDynamicData().isPowerManagementControlledByPolicy());
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    _vdsGroupIds = new ArrayList<Guid>();
    Set<Guid> vdsWithRunningVMs = new HashSet<Guid>();
    List<String> hostNotRespondingList = new ArrayList<String>();
    List<String> hostsWithNonMigratableVms = new ArrayList<String>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<String>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
        if (vds == null) {
            log.error(String.format("ResourceManager::vdsMaintenance could not find vds_id = '%1$s'", vdsId));
            addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
            result = false;
            continue;
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                List<VM> vms = getVmDAO().getAllRunningForVds(vdsId);
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational)) {
                    result = false;
                    addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL.toString());
                } else {
                    if (vms.size() > 0) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    _vdsGroupIds.add(vds.getVdsGroupId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<String>();
                    for (VM vm : vms) {
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error(String.format("VDS %1$s contains non migratable VMs", vdsId));
                        result = false;
                    } else if (!validate(new VmValidator(vms).vmNotHavingPluggedDiskSnapshots(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                        result = false;
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = false;
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                        result = false;
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a CanDoAction message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a CanDoAction message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            Set<Guid> clustersAsSet = new HashSet<Guid>();
            clustersAsSet.addAll(_vdsGroupIds);
            List<String> problematicClusters = new ArrayList<String>();
            List<String> allHostsWithRunningVms = new ArrayList<String>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<String>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addCanDoActionMessage(VdcBllMessages.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getCanDoActionMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getCanDoActionMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    Set<Guid> clustersAsSet = new HashSet<Guid>();
    Set<Guid> vdsWithRunningVMs = new HashSet<Guid>();
    List<String> hostNotRespondingList = new ArrayList<String>();
    List<String> hostsWithNonMigratableVms = new ArrayList<String>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<String>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
        if (vds == null) {
            log.error(String.format("ResourceManager::vdsMaintenance could not find vds_id = '%1$s'", vdsId));
            addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
            result = false;
            continue;
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                List<VM> vms = getVmDAO().getAllRunningForVds(vdsId);
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational)) {
                    result = false;
                    addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL.toString());
                } else {
                    if (vms.size() > 0) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getVdsGroupId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<String>();
                    for (VM vm : vms) {
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error(String.format("VDS %1$s contains non migratable VMs", vdsId));
                        result = false;
                    } else if (!validate(new VmValidator(vms).vmNotHavingPluggedDiskSnapshots(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                        result = false;
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = false;
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                        result = false;
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a CanDoAction message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a CanDoAction message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<String>();
            List<String> allHostsWithRunningVms = new ArrayList<String>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<String>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addCanDoActionMessage(VdcBllMessages.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getCanDoActionMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getCanDoActionMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSStatus lastStatus = getVds().getStatus();
    VDSReturnValue vdsReturnValue = null;
    try {
        // Set status immediately to prevent a race (BZ 636950/656224)
        setStatus();
        // Regular (no secondary agent) , multiple sequential agents or multiple concurrent agents
        if (StringUtils.isEmpty(getVds().getPmSecondaryIp())) {
            handleSingleAgent(lastStatus, vdsReturnValue);
        } else {
            if (getVds().isPmSecondaryConcurrent()) {
                handleMultipleConcurrentAgents(lastStatus, vdsReturnValue);
            } else {
                handleMultipleSequentialAgents(lastStatus, vdsReturnValue);
            }
        }
        setSucceeded(getFenceSucceeded());
    } finally {
        if (!getSucceeded()) {
            setStatus(lastStatus);
            AlertIfPowerManagementOperationFailed();
        } else // Successful fencing with reboot or shutdown op. Clear the power management policy flag
        if (EnumSet.of(FenceActionType.Restart, FenceActionType.Stop).contains(getParameters().getAction()) && getParameters().getKeepPolicyPMEnabled() == false) {
            getVds().setPowerManagementControlledByPolicy(false);
            DbFacade.getInstance().getVdsDynamicDao().update(getVds().getDynamicData());
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSStatus lastStatus = getVds().getStatus();
    VDSReturnValue vdsReturnValue = null;
    try {
        // Set status immediately to prevent a race (BZ 636950/656224)
        setStatus();
        // Regular (no secondary agent) , multiple sequential agents or multiple concurrent agents
        if (StringUtils.isEmpty(getVds().getPmSecondaryIp())) {
            handleSingleAgent(lastStatus, vdsReturnValue);
        } else {
            if (getVds().isPmSecondaryConcurrent()) {
                handleMultipleConcurrentAgents(lastStatus, vdsReturnValue);
            } else {
                handleMultipleSequentialAgents(lastStatus, vdsReturnValue);
            }
        }
        setSucceeded(getFenceSucceeded());
    } finally {
        if (!getSucceeded()) {
            setStatus(lastStatus);
            AlertIfPowerManagementOperationFailed();
        } else // Successful fencing with reboot or shutdown op. Clear the power management policy flag
        if ((getParameters().getAction() == FenceActionType.Restart || getParameters().getAction() == FenceActionType.Stop) && getParameters().getKeepPolicyPMEnabled() == false) {
            getVds().setPowerManagementControlledByPolicy(false);
            getDbFacade().getVdsDynamicDao().updateVdsDynamicPowerManagementPolicyFlag(getVdsId(), getVds().getDynamicData().isPowerManagementControlledByPolicy());
        }
    }
}
#end_block

#method_before
protected boolean waitForStatus(String vdsName, FenceActionType actionType, FenceAgentOrder order) {
    final String FENCE_CMD = (actionType == FenceActionType.Start) ? "on" : "off";
    final String ACTION_NAME = actionType.name().toLowerCase();
    int i = 1;
    boolean statusReached = false;
    log.infoFormat("Waiting for vds {0} to {1}", vdsName, ACTION_NAME);
    // Waiting before first attempt to check the host status.
    // This is done because if we will attempt to get host status immediately
    // in most cases it will not turn from on/off to off/on and we will need
    // to wait a full cycle for it.
    ThreadUtils.sleep(SLEEP_BEFORE_FIRST_ATTEMPT);
    while (!statusReached && i <= getRerties()) {
        log.infoFormat("Attempt {0} to get vds {1} status", i, vdsName);
        if (executor.findProxyHost()) {
            VDSReturnValue returnValue = executor.fence(order);
            if (returnValue != null && returnValue.getReturnValue() != null) {
                FenceStatusReturnValue value = (FenceStatusReturnValue) returnValue.getReturnValue();
                if (value.getStatus().equalsIgnoreCase("unknown")) {
                    // No need to retry , agent definitions are corrupted
                    log.warnFormat("Host {0} {1} PM Agent definitions are corrupted, Waiting for Host to {2} aborted.", vdsName, order.name(), actionType.name());
                    break;
                } else {
                    if (FENCE_CMD.equalsIgnoreCase(value.getStatus())) {
                        statusReached = true;
                        log.infoFormat("vds {0} status is {1}", vdsName, FENCE_CMD);
                    } else {
                        i++;
                        if (i <= getRerties())
                            ThreadUtils.sleep(getDelayInSeconds() * 1000);
                    }
                }
            } else {
                log.errorFormat("Failed to get host {0} status.", vdsName);
                break;
            }
        } else {
            break;
        }
    }
    if (!statusReached) {
        // Send an Alert
        String actionName = (getParameters().getParentCommand() == VdcActionType.RestartVds) ? FenceActionType.Restart.name() : ACTION_NAME;
        AuditLogableBase auditLogable = new AuditLogableBase();
        auditLogable.addCustomValue("Host", vdsName);
        auditLogable.addCustomValue("Status", actionName);
        AuditLogDirector.log(auditLogable, AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED);
        log.errorFormat("Failed to verify host {0} {1} status. Have retried {2} times with delay of {3} seconds between each retry.", vdsName, ACTION_NAME, getRerties(), getDelayInSeconds());
    }
    return statusReached;
}
#method_after
protected boolean waitForStatus(String vdsName, FenceActionType actionType, FenceAgentOrder order) {
    final String FENCE_CMD = (actionType == FenceActionType.Start) ? "on" : "off";
    final String ACTION_NAME = actionType.name().toLowerCase();
    int i = 1;
    boolean statusReached = false;
    log.infoFormat("Waiting for vds {0} to {1}", vdsName, ACTION_NAME);
    // Waiting before first attempt to check the host status.
    // This is done because if we will attempt to get host status immediately
    // in most cases it will not turn from on/off to off/on and we will need
    // to wait a full cycle for it.
    ThreadUtils.sleep(SLEEP_BEFORE_FIRST_ATTEMPT);
    while (!statusReached && i <= getRerties()) {
        log.infoFormat("Attempt {0} to get vds {1} status", i, vdsName);
        if (executor.findProxyHost()) {
            VDSReturnValue returnValue = executor.fence(order);
            if (returnValue != null && returnValue.getReturnValue() != null) {
                FenceStatusReturnValue value = (FenceStatusReturnValue) returnValue.getReturnValue();
                if (value.getStatus().equalsIgnoreCase("unknown")) {
                    // No need to retry , agent definitions are corrupted
                    log.warnFormat("Host {0} {1} PM Agent definitions are corrupted, Waiting for Host to {2} aborted.", vdsName, order.name(), actionType.name());
                    break;
                } else {
                    if (FENCE_CMD.equalsIgnoreCase(value.getStatus())) {
                        statusReached = true;
                        log.infoFormat("vds {0} status is {1}", vdsName, FENCE_CMD);
                    } else {
                        i++;
                        if (i <= getRerties())
                            ThreadUtils.sleep(getDelayInSeconds() * 1000);
                    }
                }
            } else {
                log.errorFormat("Failed to get host {0} status.", vdsName);
                break;
            }
        } else {
            break;
        }
    }
    if (!statusReached) {
        // Send an Alert
        String actionName = (getParameters().getParentCommand() == VdcActionType.RestartVds) ? FenceActionType.Restart.name() : ACTION_NAME;
        AuditLogableBase auditLogable = new AuditLogableBase();
        auditLogable.addCustomValue("Host", vdsName);
        auditLogable.addCustomValue("Status", actionName);
        auditLogable.setVdsId(getVds().getId());
        AuditLogDirector.log(auditLogable, AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED);
        log.errorFormat("Failed to verify host {0} {1} status. Have retried {2} times with delay of {3} seconds between each retry.", vdsName, ACTION_NAME, getRerties(), getDelayInSeconds());
    }
    return statusReached;
}
#end_block

#method_before
@Override
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    final Pair<List<Guid>, Guid> migrationRule = super.balance(cluster, hosts, parameters, messages);
    List<VDS> allHosts = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(cluster.getId());
    Pair<VDS, VDSStatus> action = evaluatePowerManagementSituation(getDownHosts(allHosts, parameters), getMaintenanceHosts(allHosts, parameters), getEmptyHosts(allHosts, parameters), parameters);
    if (action != null)
        processPmAction(action);
    return migrationRule;
}
#method_after
@Override
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    final Pair<List<Guid>, Guid> migrationRule = super.balance(cluster, hosts, parameters, messages);
    List<VDS> allHosts = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(cluster.getId());
    List<VDS> emptyHosts = new ArrayList<>();
    List<VDS> maintenanceHosts = new ArrayList<>();
    List<VDS> downHosts = new ArrayList<>();
    getHostLists(allHosts, parameters, emptyHosts, maintenanceHosts, downHosts);
    Pair<VDS, VDSStatus> action = evaluatePowerManagementSituation(cluster, downHosts, maintenanceHosts, emptyHosts, parameters);
    if (action != null) {
        processPmAction(action);
    }
    return migrationRule;
}
#end_block

#method_before
private void processPmAction(Pair<VDS, VDSStatus> action) {
    VDS vds = action.getFirst();
    VDSStatus currentStatus = vds.getStatus();
    VDSStatus targetStatus = action.getSecond();
    if (targetStatus == VDSStatus.Maintenance && currentStatus == VDSStatus.Up) {
        logAction(vds, AuditLogType.PM_POLICY_UP_TO_MAINTENANCE);
        /* Up -> Maint */
        List<Guid> vdsList = new ArrayList<>(1);
        vdsList.add(vds.getId());
        MaintenanceNumberOfVdssParameters parameters = new MaintenanceNumberOfVdssParameters(vdsList, true, true);
        Backend.getInstance().runInternalAction(VdcActionType.MaintenanceNumberOfVdss, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Down && currentStatus == VDSStatus.Maintenance) {
        logAction(vds, AuditLogType.PM_POLICY_MAINTENANCE_TO_DOWN);
        /* Maint -> Down */
        VdsPowerDownParameters parameters = new VdsPowerDownParameters(vds.getId());
        parameters.setKeepPolicyPMEnabled(true);
        Backend.getInstance().runInternalAction(VdcActionType.VdsPowerDown, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Up && currentStatus == VDSStatus.Maintenance) {
        logAction(vds, AuditLogType.PM_POLICY_TO_UP);
        /* Maint -> Up */
        VdsActionParameters parameters = new VdsActionParameters(vds.getId());
        Backend.getInstance().runInternalAction(VdcActionType.ActivateVds, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Up && currentStatus == VDSStatus.Down) {
        logAction(vds, AuditLogType.PM_POLICY_TO_UP);
        /* Down -> Up */
        FenceVdsActionParameters parameters = new FenceVdsActionParameters(vds.getId(), FenceActionType.Start);
        Backend.getInstance().runInternalAction(VdcActionType.StartVds, parameters, ExecutionHandler.createInternalJobContext());
    } else {
    /* Should not ever happen... */
    }
}
#method_after
private void processPmAction(Pair<VDS, VDSStatus> action) {
    VDS vds = action.getFirst();
    VDSStatus currentStatus = vds.getStatus();
    VDSStatus targetStatus = action.getSecond();
    if (targetStatus == VDSStatus.Maintenance && currentStatus == VDSStatus.Up) {
        logAction(vds, AuditLogType.PM_POLICY_UP_TO_MAINTENANCE);
        /* Up -> Maint */
        Guid[] vdsList = new Guid[] { vds.getId() };
        MaintenanceNumberOfVdssParameters parameters = new MaintenanceNumberOfVdssParameters(Arrays.asList(vdsList), true, true);
        Backend.getInstance().runInternalAction(VdcActionType.MaintenanceNumberOfVdss, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Down && currentStatus == VDSStatus.Maintenance) {
        logAction(vds, AuditLogType.PM_POLICY_MAINTENANCE_TO_DOWN);
        /* Maint -> Down */
        VdsPowerDownParameters parameters = new VdsPowerDownParameters(vds.getId());
        parameters.setKeepPolicyPMEnabled(true);
        Backend.getInstance().runInternalAction(VdcActionType.VdsPowerDown, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Up && currentStatus == VDSStatus.Maintenance) {
        logAction(vds, AuditLogType.PM_POLICY_TO_UP);
        /* Maint -> Up */
        VdsActionParameters parameters = new VdsActionParameters(vds.getId());
        Backend.getInstance().runInternalAction(VdcActionType.ActivateVds, parameters, ExecutionHandler.createInternalJobContext());
    } else if (targetStatus == VDSStatus.Up && currentStatus == VDSStatus.Down) {
        logAction(vds, AuditLogType.PM_POLICY_TO_UP);
        /* Down -> Up */
        FenceVdsActionParameters parameters = new FenceVdsActionParameters(vds.getId(), FenceActionType.Start);
        Backend.getInstance().runInternalAction(VdcActionType.StartVds, parameters, ExecutionHandler.createInternalJobContext());
    } else {
        /* Should not ever happen... */
        log.errorFormat("Unknown host power management transition {0} -> {1}", currentStatus.toString(), targetStatus.toString());
    }
}
#end_block

#method_before
protected Pair<VDS, VDSStatus> evaluatePowerManagementSituation(List<VDS> pmDownHosts, List<VDS> pmMaintenanceHosts, List<VDS> emptyHosts, Map<String, String> parameters) {
    final int requiredReserve = tryParseWithDefault(parameters.get("HostsInReserve"), Config.<Integer>getValue(ConfigValues.HostsInReserve));
    final int enableAutoPM = tryParseWithDefault(parameters.get("EnableAutomaticHostPowerManagement"), Config.<Integer>getValue(ConfigValues.EnableAutomaticHostPowerManagement));
    /* Automatic power management is disabled */
    if (enableAutoPM == 0)
        return null;
    /* We need more hosts but there are no available for us */
    if (requiredReserve > emptyHosts.size() && pmDownHosts.isEmpty() && pmMaintenanceHosts.isEmpty())
        return null;
    else /* We have enough free hosts so shut some hosts in maintenance down
           keep at least one spare in maintenance during the process.
         */
    if (requiredReserve < emptyHosts.size() && pmMaintenanceHosts.size() > 1) {
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Down);
    } else /* We do have enough empty hosts to put something to maintenance */
    if (requiredReserve < emptyHosts.size()) {
        /* Find hosts with automatic PM enabled that are not the current SPM */
        List<VDS> hostsWithAutoPM = LinqUtils.filter(emptyHosts, new Predicate<VDS>() {

            @Override
            public boolean eval(VDS vds) {
                return !vds.isDisablePowerManagementPolicy() && vds.getSpmStatus() != VdsSpmStatus.SPM && vds.getpm_enabled();
            }
        });
        return hostsWithAutoPM.isEmpty() ? null : new Pair<>(hostsWithAutoPM.get(0), VDSStatus.Maintenance);
    } else /* We have the right amount of empty hosts to start shutting the
           hosts that are resting in maintenance down.
         */
    if (requiredReserve == emptyHosts.size() && pmMaintenanceHosts.isEmpty() == false) {
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Down);
    } else /* We do not have enough free hosts, but we still have some hosts
           in maintenance. We can easily activate those.
         */
    if (requiredReserve > emptyHosts.size() && pmMaintenanceHosts.isEmpty() == false) {
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Up);
    } else /* We do not have enough free hosts and no hosts in pm maintenance,
           so we need to start some hosts up.
         */
    if (requiredReserve > emptyHosts.size() && pmMaintenanceHosts.isEmpty()) {
        return new Pair<>(pmDownHosts.get(0), VDSStatus.Up);
    }
    return null;
}
#method_after
protected Pair<VDS, VDSStatus> evaluatePowerManagementSituation(VDSGroup cluster, List<VDS> pmDownHosts, List<VDS> pmMaintenanceHosts, List<VDS> emptyHosts, Map<String, String> parameters) {
    final int requiredReserve = tryParseWithDefault(parameters.get("HostsInReserve"), Config.<Integer>getValue(ConfigValues.HostsInReserve));
    String enableAutoPMParameter = parameters.get("EnableAutomaticHostPowerManagement");
    Boolean enableAutoPM = enableAutoPMParameter == null ? null : Boolean.valueOf(enableAutoPMParameter);
    if (enableAutoPM == null) {
        enableAutoPM = Config.<Boolean>getValue(ConfigValues.EnableAutomaticHostPowerManagement);
    }
    /* Automatic power management is disabled */
    if (!enableAutoPM.booleanValue()) {
        log.infoFormat("Automatic power management is disabled for cluster {0}.", cluster.getName());
        return null;
    }
    /* We need more hosts but there are no available for us */
    if (requiredReserve > emptyHosts.size() && pmDownHosts.isEmpty() && pmMaintenanceHosts.isEmpty()) {
        log.infoFormat("Cluster {0} does not have enough spare hosts, but no additional host is available.", cluster.getName());
        return null;
    } else /* We have enough free hosts so shut some hosts in maintenance down
           keep at least one spare in maintenance during the process.
         */
    if (requiredReserve < emptyHosts.size() && pmMaintenanceHosts.size() > 1) {
        log.infoFormat("Cluster {0} does have enough spare hosts, shutting one host down.", cluster.getName());
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Down);
    } else /* We do have enough empty hosts to put something to maintenance */
    if (requiredReserve < emptyHosts.size()) {
        /* Find hosts with automatic PM enabled that are not the current SPM */
        List<VDS> hostsWithAutoPM = LinqUtils.filter(emptyHosts, new Predicate<VDS>() {

            @Override
            public boolean eval(VDS vds) {
                return !vds.isDisablePowerManagementPolicy() && vds.getSpmStatus() != VdsSpmStatus.SPM && vds.getpm_enabled();
            }
        });
        if (hostsWithAutoPM.isEmpty()) {
            log.infoFormat("Cluster {0} does have too many spare hosts, but none can be put to maintenance.", cluster.getName());
            return null;
        } else {
            return new Pair<>(hostsWithAutoPM.get(0), VDSStatus.Maintenance);
        }
    } else /* We have the right amount of empty hosts to start shutting the
           hosts that are resting in maintenance down.
         */
    if (requiredReserve == emptyHosts.size() && pmMaintenanceHosts.isEmpty() == false) {
        log.infoFormat("Cluster {0} does have enough spare hosts, shutting one host down.", cluster.getName());
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Down);
    } else /* We do not have enough free hosts, but we still have some hosts
           in maintenance. We can easily activate those.
         */
    if (requiredReserve > emptyHosts.size() && pmMaintenanceHosts.isEmpty() == false) {
        log.infoFormat("Cluster {0} does not have enough spare hosts, reactivating one.", cluster.getName());
        return new Pair<>(pmMaintenanceHosts.get(0), VDSStatus.Up);
    } else /* We do not have enough free hosts and no hosts in pm maintenance,
           so we need to start some hosts up.
         */
    if (requiredReserve > emptyHosts.size() && pmMaintenanceHosts.isEmpty()) {
        log.infoFormat("Cluster {0} does not have enough spare hosts, trying to start one up.", cluster.getName());
        return new Pair<>(pmDownHosts.get(0), VDSStatus.Up);
    }
    /* All power management constraints were satisfied, no need to do anything */
    return null;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.infoFormat("SSH powerdown will not be executed on host {0}({1}) since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    /* Try this only when the Host is in maintenance state */
    if (getVds().getStatus() != VDSStatus.Maintenance) {
        setCommandShouldBeLogged(false);
        log.infoFormat("SSH powerdown will not be executed on host {0}({1}) since it is not in Maintenance.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    boolean result = executeSshPowerdown(getVds().getVdsGroupCompatibilityVersion().toString());
    if (result) {
        // SSH powerdown executed without errors set the status to down
        getVds().setStatus(VDSStatus.Down);
        // clear the automatic PM flag unless instructed otherwise
        if (!getParameters().getKeepPolicyPMEnabled()) {
            getVds().setPowerManagementControlledByPolicy(false);
        }
        getDbFacade().getVdsDynamicDao().update(getVds().getDynamicData());
    } else if (getParameters().getFallbackToPowerManagement() && getVds().getpm_enabled()) {
        FenceVdsActionParameters parameters = new FenceVdsActionParameters(getVds().getId(), FenceActionType.Stop);
        parameters.setKeepPolicyPMEnabled(getParameters().getKeepPolicyPMEnabled());
        Backend.getInstance().runInternalAction(VdcActionType.StopVds, parameters, ExecutionHandler.createInternalJobContext());
    }
    getReturnValue().setSucceeded(result);
}
#method_after
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        handleError("SSH power down will not be executed on host {0} ({1}) since it doesn't exist anymore.");
        return;
    }
    /* Try this only when the Host is in maintenance state */
    if (getVds().getStatus() != VDSStatus.Maintenance) {
        handleError("SSH power down will not be executed on host {0} ({1}) since it is not in Maintenance.");
        return;
    }
    boolean result = executeSshPowerdown(getVds().getVdsGroupCompatibilityVersion().toString());
    if (result) {
        // SSH powerdown executed without errors set the status to down
        getVds().setStatus(VDSStatus.Down);
        // clear the automatic PM flag unless instructed otherwise
        if (!getParameters().getKeepPolicyPMEnabled()) {
            getVds().setPowerManagementControlledByPolicy(false);
            getDbFacade().getVdsDynamicDao().updateVdsDynamicPowerManagementPolicyFlag(getVdsId(), getVds().getDynamicData().isPowerManagementControlledByPolicy());
        }
    } else if (getParameters().getFallbackToPowerManagement() && getVds().getpm_enabled()) {
        FenceVdsActionParameters parameters = new FenceVdsActionParameters(getVds().getId(), FenceActionType.Stop);
        parameters.setKeepPolicyPMEnabled(getParameters().getKeepPolicyPMEnabled());
        Backend.getInstance().runInternalAction(VdcActionType.StopVds, parameters, ExecutionHandler.createInternalJobContext());
    }
    getReturnValue().setSucceeded(result);
}
#end_block

#method_before
private boolean executeSshPowerdown(String version) {
    boolean ret = false;
    try (final EngineSSHClient sshClient = new EngineSSHClient();
        final ByteArrayOutputStream cmdOut = new ByteArrayOutputStream();
        final ByteArrayOutputStream cmdErr = new ByteArrayOutputStream()) {
        try {
            log.infoFormat("Opening SSH powerdown session on host {0}", getVds().getHostName());
            sshClient.setVds(getVds());
            sshClient.useDefaultKeyPair();
            sshClient.connect();
            sshClient.authenticate();
            log.infoFormat("Executing SSH powerdown command on host {0}", getVds().getHostName());
            sshClient.executeCommand(Config.<String>getValue(ConfigValues.SshVdsPowerdownCommand, version), null, cmdOut, cmdErr);
            ret = true;
        } catch (Exception ex) {
            log.errorFormat("SSH powerdown command failed on host {0}: {1}\nStdout: {2}\nStderr: {3}\nStacktrace: {4}", getVds().getHostName(), ex.getMessage(), cmdOut.toString(), cmdErr.toString(), ex);
        }
    } catch (IOException e) {
        log.error("IOException", e);
    }
    return ret;
}
#method_after
private boolean executeSshPowerdown(String version) {
    boolean ret = false;
    try (final EngineSSHClient sshClient = new EngineSSHClient();
        final ByteArrayOutputStream cmdOut = new ByteArrayOutputStream();
        final ByteArrayOutputStream cmdErr = new ByteArrayOutputStream()) {
        try {
            log.infoFormat("Opening SSH power down session on host {0}", getVds().getHostName());
            sshClient.setVds(getVds());
            sshClient.useDefaultKeyPair();
            sshClient.connect();
            sshClient.authenticate();
            log.infoFormat("Executing SSH power down command on host {0}", getVds().getHostName());
            sshClient.executeCommand(Config.<String>getValue(ConfigValues.SshVdsPowerdownCommand, version), null, cmdOut, cmdErr);
            ret = true;
        } catch (Exception ex) {
            log.errorFormat("SSH power down command failed on host {0}: {1}\nStdout: {2}\nStderr: {3}\nStacktrace: {4}", getVds().getHostName(), ex.getMessage(), cmdOut.toString(), cmdErr.toString(), ex);
        }
    } catch (IOException e) {
        log.error("IOException", e);
    }
    return ret;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((mVdsStatic == null) ? 0 : mVdsStatic.hashCode());
    result = prime * result + ((cpuName == null) ? 0 : cpuName.hashCode());
    result = prime * result + ((_spm_status == null) ? 0 : _spm_status.hashCode());
    result = prime * result + cpuOverCommitDurationMinutes;
    result = prime * result + highUtilization;
    result = prime * result + lowUtilization;
    result = prime * result + ((mImagesLastCheck == null) ? 0 : mImagesLastCheck.hashCode());
    result = prime * result + ((mImagesLastDelay == null) ? 0 : mImagesLastDelay.hashCode());
    result = prime * result + ((mInterfaceList == null) ? 0 : mInterfaceList.hashCode());
    result = prime * result + ((mNetworkList == null) ? 0 : mNetworkList.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + ((privateDomains == null) ? 0 : privateDomains.hashCode());
    result = prime * result + ((vdsSpmId == null) ? 0 : vdsSpmId.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vdsGroupVirtService == null) ? 0 : vdsGroupVirtService.hashCode());
    result = prime * result + ((vdsGroupGlusterService == null) ? 0 : vdsGroupGlusterService.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((mVdsStatic == null) ? 0 : mVdsStatic.hashCode());
    result = prime * result + ((cpuName == null) ? 0 : cpuName.hashCode());
    result = prime * result + ((_spm_status == null) ? 0 : _spm_status.hashCode());
    result = prime * result + ((mImagesLastCheck == null) ? 0 : mImagesLastCheck.hashCode());
    result = prime * result + ((mImagesLastDelay == null) ? 0 : mImagesLastDelay.hashCode());
    result = prime * result + ((mInterfaceList == null) ? 0 : mInterfaceList.hashCode());
    result = prime * result + ((mNetworkList == null) ? 0 : mNetworkList.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + ((privateDomains == null) ? 0 : privateDomains.hashCode());
    result = prime * result + ((vdsSpmId == null) ? 0 : vdsSpmId.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vdsGroupVirtService == null) ? 0 : vdsGroupVirtService.hashCode());
    result = prime * result + ((vdsGroupGlusterService == null) ? 0 : vdsGroupGlusterService.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VDS other = (VDS) obj;
    return (ObjectUtils.objectsEqual(mVdsStatic, other.mVdsStatic) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && _spm_status == other._spm_status && cpuOverCommitDurationMinutes == other.cpuOverCommitDurationMinutes && highUtilization == other.highUtilization && lowUtilization == other.lowUtilization && ObjectUtils.objectsEqual(mImagesLastCheck, other.mImagesLastCheck) && ObjectUtils.objectsEqual(mImagesLastDelay, other.mImagesLastDelay) && ObjectUtils.objectsEqual(mInterfaceList, other.mInterfaceList) && ObjectUtils.objectsEqual(mNetworkList, other.mNetworkList) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && ObjectUtils.objectsEqual(privateDomains, other.privateDomains) && ObjectUtils.objectsEqual(vdsSpmId, other.vdsSpmId) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && ObjectUtils.objectsEqual(vdsGroupCompatibilityVersion, other.vdsGroupCompatibilityVersion) && ObjectUtils.objectsEqual(vdsGroupCpuName, other.vdsGroupCpuName) && ObjectUtils.objectsEqual(vdsGroupDescription, other.vdsGroupDescription) && ObjectUtils.objectsEqual(vdsGroupName, other.vdsGroupName) && ObjectUtils.objectsEqual(vdsGroupVirtService, other.vdsGroupVirtService) && ObjectUtils.objectsEqual(vdsGroupGlusterService, other.vdsGroupGlusterService));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VDS other = (VDS) obj;
    return (ObjectUtils.objectsEqual(mVdsStatic, other.mVdsStatic) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && _spm_status == other._spm_status && ObjectUtils.objectsEqual(mImagesLastCheck, other.mImagesLastCheck) && ObjectUtils.objectsEqual(mImagesLastDelay, other.mImagesLastDelay) && ObjectUtils.objectsEqual(mInterfaceList, other.mInterfaceList) && ObjectUtils.objectsEqual(mNetworkList, other.mNetworkList) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && ObjectUtils.objectsEqual(privateDomains, other.privateDomains) && ObjectUtils.objectsEqual(vdsSpmId, other.vdsSpmId) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && ObjectUtils.objectsEqual(vdsGroupCompatibilityVersion, other.vdsGroupCompatibilityVersion) && ObjectUtils.objectsEqual(vdsGroupCpuName, other.vdsGroupCpuName) && ObjectUtils.objectsEqual(vdsGroupDescription, other.vdsGroupDescription) && ObjectUtils.objectsEqual(vdsGroupName, other.vdsGroupName) && ObjectUtils.objectsEqual(vdsGroupVirtService, other.vdsGroupVirtService) && ObjectUtils.objectsEqual(vdsGroupGlusterService, other.vdsGroupGlusterService));
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    return vm;
}
#end_block

#method_before
private static NetworkCluster cloneNetworkCluster(NetworkCluster instance) {
    NetworkCluster obj = new NetworkCluster();
    obj.setStatus(instance.getStatus());
    obj.setDisplay(instance.isDisplay());
    obj.setRequired(instance.isRequired());
    obj.setMigration(instance.isMigration());
    return obj;
}
#method_after
private static NetworkCluster cloneNetworkCluster(NetworkCluster instance) {
    NetworkCluster obj = new NetworkCluster();
    obj.setId(instance.getId());
    obj.setStatus(instance.getStatus());
    obj.setDisplay(instance.isDisplay());
    obj.setRequired(instance.isRequired());
    obj.setMigration(instance.isMigration());
    return obj;
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName((String) model.getName().getEntity());
    host.setComment((String) model.getComment().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity().toString() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : (String) model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = (Boolean) model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : (String) model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap((model.getPmOptionsMap()));
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy((Boolean) model.getDisableAutomaticPowerManagement().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = ((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword((String) model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setProviderId(networkProvider.getId());
            parameters.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName((String) model.getName().getEntity());
    host.setComment((String) model.getComment().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity().toString() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : (String) model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = (Boolean) model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : (String) model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap((model.getPmOptionsMap()));
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = ((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword((String) model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setProviderId(networkProvider.getId());
            parameters.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
public void onAddHost() {
    cancelConfirm();
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    // Save changes.
    VDS host = new VDS();
    host.setVdsName((String) model.getName().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort((Integer) model.getPort().getEntity());
    host.setSshPort(Integer.valueOf((String) model.getAuthSshPort().getEntity()));
    host.setSshUsername(model.getUserName().getEntity().toString());
    host.setSshKeyFingerprint(model.getFetchSshFingerprint().getEntity().toString());
    host.setVdsGroupId(((VDSGroup) model.getCluster().getSelectedItem()).getId());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap(model.getPmOptionsMap());
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy((Boolean) model.getDisableAutomaticPowerManagement().getEntity());
    AddVdsActionParameters vdsActionParams = new AddVdsActionParameters();
    vdsActionParams.setvds(host);
    vdsActionParams.setVdsId(host.getId());
    if (model.getUserPassword().getEntity() != null) {
        vdsActionParams.setPassword((String) model.getUserPassword().getEntity());
    }
    vdsActionParams.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    vdsActionParams.setRebootAfterInstallation(((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService());
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVds, vdsActionParams, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterGuideModel localModel = (ClusterGuideModel) result.getState();
            localModel.postOnAddHost(result.getReturnValue());
        }
    }, this);
}
#method_after
public void onAddHost() {
    cancelConfirm();
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    // Save changes.
    VDS host = new VDS();
    host.setVdsName((String) model.getName().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort((Integer) model.getPort().getEntity());
    host.setSshPort(Integer.valueOf((String) model.getAuthSshPort().getEntity()));
    host.setSshUsername(model.getUserName().getEntity().toString());
    host.setSshKeyFingerprint(model.getFetchSshFingerprint().getEntity().toString());
    host.setVdsGroupId(((VDSGroup) model.getCluster().getSelectedItem()).getId());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap(model.getPmOptionsMap());
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    AddVdsActionParameters vdsActionParams = new AddVdsActionParameters();
    vdsActionParams.setvds(host);
    vdsActionParams.setVdsId(host.getId());
    if (model.getUserPassword().getEntity() != null) {
        vdsActionParams.setPassword((String) model.getUserPassword().getEntity());
    }
    vdsActionParams.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    vdsActionParams.setRebootAfterInstallation(((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService());
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVds, vdsActionParams, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterGuideModel localModel = (ClusterGuideModel) result.getState();
            localModel.postOnAddHost(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
@Override
public void update(VdsDynamic vds) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("cpu_cores", vds.getcpu_cores()).addValue("cpu_threads", vds.getCpuThreads()).addValue("cpu_model", vds.getcpu_model()).addValue("cpu_speed_mh", vds.getcpu_speed_mh()).addValue("if_total_speed", vds.getif_total_speed()).addValue("kvm_enabled", vds.getkvm_enabled()).addValue("mem_commited", vds.getmem_commited()).addValue("physical_mem_mb", vds.getphysical_mem_mb()).addValue("status", vds.getStatus()).addValue("vds_id", vds.getId()).addValue("vm_active", vds.getvm_active()).addValue("vm_count", vds.getvm_count()).addValue("vms_cores_count", vds.getvms_cores_count()).addValue("vm_migrating", vds.getvm_migrating()).addValue("reserved_mem", vds.getreserved_mem()).addValue("guest_overhead", vds.getguest_overhead()).addValue("rpm_version", vds.getVersion().getRpmName()).addValue("software_version", vds.getsoftware_version()).addValue("version_name", vds.getversion_name()).addValue("build_name", vds.getbuild_name()).addValue("previous_status", vds.getprevious_status()).addValue("cpu_flags", vds.getcpu_flags()).addValue("cpu_over_commit_time_stamp", vds.getcpu_over_commit_time_stamp()).addValue("pending_vcpus_count", vds.getpending_vcpus_count()).addValue("pending_vmem_size", vds.getpending_vmem_size()).addValue("cpu_sockets", vds.getcpu_sockets()).addValue("net_config_dirty", vds.getnet_config_dirty()).addValue("supported_cluster_levels", vds.getsupported_cluster_levels()).addValue("supported_engines", vds.getsupported_engines()).addValue("host_os", vds.gethost_os()).addValue("kvm_version", vds.getkvm_version()).addValue("libvirt_version", vds.getlibvirt_version().getRpmName()).addValue("spice_version", vds.getspice_version()).addValue("gluster_version", vds.getGlusterVersion().getRpmName()).addValue("kernel_version", vds.getkernel_version()).addValue("iscsi_initiator_name", vds.getIScsiInitiatorName()).addValue("transparent_hugepages_state", vds.getTransparentHugePagesState().getValue()).addValue("hooks", vds.getHooksStr()).addValue("non_operational_reason", vds.getNonOperationalReason().getValue()).addValue("hw_manufacturer", vds.getHardwareManufacturer()).addValue("hw_product_name", vds.getHardwareProductName()).addValue("hw_version", vds.getHardwareVersion()).addValue("hw_serial_number", vds.getHardwareSerialNumber()).addValue("hw_uuid", vds.getHardwareUUID()).addValue("hw_family", vds.getHardwareFamily()).addValue("hbas", new JsonObjectSerializer().serialize(vds.getHBAs())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines()).addValue("controlled_by_pm_policy", vds.isPowerManagementControlledByPolicy());
    getCallsHandler().executeModification("UpdateVdsDynamic", parameterSource);
}
#method_after
@Override
public void update(VdsDynamic vds) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("cpu_cores", vds.getcpu_cores()).addValue("cpu_threads", vds.getCpuThreads()).addValue("cpu_model", vds.getcpu_model()).addValue("cpu_speed_mh", vds.getcpu_speed_mh()).addValue("if_total_speed", vds.getif_total_speed()).addValue("kvm_enabled", vds.getkvm_enabled()).addValue("mem_commited", vds.getmem_commited()).addValue("physical_mem_mb", vds.getphysical_mem_mb()).addValue("status", vds.getStatus()).addValue("vds_id", vds.getId()).addValue("vm_active", vds.getvm_active()).addValue("vm_count", vds.getvm_count()).addValue("vms_cores_count", vds.getvms_cores_count()).addValue("vm_migrating", vds.getvm_migrating()).addValue("reserved_mem", vds.getreserved_mem()).addValue("guest_overhead", vds.getguest_overhead()).addValue("rpm_version", vds.getVersion().getRpmName()).addValue("software_version", vds.getsoftware_version()).addValue("version_name", vds.getversion_name()).addValue("build_name", vds.getbuild_name()).addValue("previous_status", vds.getprevious_status()).addValue("cpu_flags", vds.getcpu_flags()).addValue("cpu_over_commit_time_stamp", vds.getcpu_over_commit_time_stamp()).addValue("pending_vcpus_count", vds.getpending_vcpus_count()).addValue("pending_vmem_size", vds.getpending_vmem_size()).addValue("cpu_sockets", vds.getcpu_sockets()).addValue("net_config_dirty", vds.getnet_config_dirty()).addValue("supported_cluster_levels", vds.getsupported_cluster_levels()).addValue("supported_engines", vds.getsupported_engines()).addValue("host_os", vds.gethost_os()).addValue("kvm_version", vds.getkvm_version()).addValue("libvirt_version", vds.getlibvirt_version().getRpmName()).addValue("spice_version", vds.getspice_version()).addValue("gluster_version", vds.getGlusterVersion().getRpmName()).addValue("kernel_version", vds.getkernel_version()).addValue("iscsi_initiator_name", vds.getIScsiInitiatorName()).addValue("transparent_hugepages_state", vds.getTransparentHugePagesState().getValue()).addValue("hooks", vds.getHooksStr()).addValue("non_operational_reason", vds.getNonOperationalReason().getValue()).addValue("hw_manufacturer", vds.getHardwareManufacturer()).addValue("hw_product_name", vds.getHardwareProductName()).addValue("hw_version", vds.getHardwareVersion()).addValue("hw_serial_number", vds.getHardwareSerialNumber()).addValue("hw_uuid", vds.getHardwareUUID()).addValue("hw_family", vds.getHardwareFamily()).addValue("hbas", new JsonObjectSerializer().serialize(vds.getHBAs())).addValue("supported_emulated_machines", vds.getSupportedEmulatedMachines());
    getCallsHandler().executeModification("UpdateVdsDynamic", parameterSource);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VdsStatic other = (VdsStatic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(hostName, other.hostName) && ObjectUtils.objectsEqual(consoleAddress, other.consoleAddress) && ObjectUtils.objectsEqual(managementIp, other.managementIp) && ObjectUtils.objectsEqual(name, other.name) && otpValidity == other.otpValidity && pmEnabled == other.pmEnabled && ObjectUtils.objectsEqual(pmOptions, other.pmOptions) && ObjectUtils.objectsEqual(pmOptionsMap, other.pmOptionsMap) && ObjectUtils.objectsEqual(pmPassword, other.pmPassword) && ObjectUtils.objectsEqual(pmPort, other.pmPort) && ObjectUtils.objectsEqual(pmType, other.pmType) && ObjectUtils.objectsEqual(pmUser, other.pmUser) && ObjectUtils.objectsEqual(pmSecondaryIp, other.pmSecondaryIp) && pmSecondaryConcurrent == other.pmSecondaryConcurrent && ObjectUtils.objectsEqual(pmSecondaryOptions, other.pmSecondaryOptions) && ObjectUtils.objectsEqual(pmSecondaryOptionsMap, other.pmSecondaryOptionsMap) && ObjectUtils.objectsEqual(pmSecondaryPassword, other.pmSecondaryPassword) && ObjectUtils.objectsEqual(pmSecondaryPort, other.pmSecondaryPort) && ObjectUtils.objectsEqual(pmSecondaryType, other.pmSecondaryType) && ObjectUtils.objectsEqual(pmSecondaryUser, other.pmSecondaryUser) && port == other.port && sshPort == other.sshPort && ObjectUtils.objectsEqual(sshUsername, other.sshUsername) && ObjectUtils.objectsEqual(serverSslEnabled, other.serverSslEnabled) && ObjectUtils.objectsEqual(uniqueId, other.uniqueId) && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && ObjectUtils.objectsEqual(vdsStrength, other.vdsStrength) && vdsType == other.vdsType && ObjectUtils.objectsEqual(sshKeyFingerprint, other.sshKeyFingerprint)) && ObjectUtils.objectsEqual(disablePowerManagementPolicy, other.disablePowerManagementPolicy);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VdsStatic other = (VdsStatic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(hostName, other.hostName) && ObjectUtils.objectsEqual(consoleAddress, other.consoleAddress) && ObjectUtils.objectsEqual(managementIp, other.managementIp) && ObjectUtils.objectsEqual(name, other.name) && otpValidity == other.otpValidity && pmEnabled == other.pmEnabled && ObjectUtils.objectsEqual(pmOptions, other.pmOptions) && ObjectUtils.objectsEqual(pmOptionsMap, other.pmOptionsMap) && ObjectUtils.objectsEqual(pmPassword, other.pmPassword) && ObjectUtils.objectsEqual(pmPort, other.pmPort) && ObjectUtils.objectsEqual(pmType, other.pmType) && ObjectUtils.objectsEqual(pmUser, other.pmUser) && ObjectUtils.objectsEqual(pmSecondaryIp, other.pmSecondaryIp) && pmSecondaryConcurrent == other.pmSecondaryConcurrent && ObjectUtils.objectsEqual(pmSecondaryOptions, other.pmSecondaryOptions) && ObjectUtils.objectsEqual(pmSecondaryOptionsMap, other.pmSecondaryOptionsMap) && ObjectUtils.objectsEqual(pmSecondaryPassword, other.pmSecondaryPassword) && ObjectUtils.objectsEqual(pmSecondaryPort, other.pmSecondaryPort) && ObjectUtils.objectsEqual(pmSecondaryType, other.pmSecondaryType) && ObjectUtils.objectsEqual(pmSecondaryUser, other.pmSecondaryUser) && port == other.port && sshPort == other.sshPort && ObjectUtils.objectsEqual(sshUsername, other.sshUsername) && ObjectUtils.objectsEqual(serverSslEnabled, other.serverSslEnabled) && ObjectUtils.objectsEqual(uniqueId, other.uniqueId) && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && ObjectUtils.objectsEqual(vdsStrength, other.vdsStrength) && vdsType == other.vdsType && ObjectUtils.objectsEqual(sshKeyFingerprint, other.sshKeyFingerprint)) && disablePowerManagementPolicy == other.disablePowerManagementPolicy;
}
#end_block

#method_before
private void updateOptionsNonLocalFS() {
    if (clusters == null || allStorageDomains == null || attachedStorageDomains == null || isoStorageDomains == null || allHosts == null) {
        return;
    }
    // Add cluster action.
    // $NON-NLS-1$
    UICommand addClusterAction = new UICommand("AddCluster", this);
    if (clusters.isEmpty()) {
        addClusterAction.setTitle(DataCenterConfigureClustersAction);
        getCompulsoryActions().add(addClusterAction);
    } else {
        addClusterAction.setTitle(DataCenterAddAnotherClusterAction);
        getOptionalActions().add(addClusterAction);
    }
    ArrayList<VDS> hosts = new ArrayList<VDS>();
    ArrayList<VDS> availableHosts = new ArrayList<VDS>();
    ArrayList<VDS> upHosts = new ArrayList<VDS>();
    for (VDS vds : allHosts) {
        if (Linq.isClusterItemExistInList(clusters, vds.getVdsGroupId())) {
            hosts.add(vds);
        }
        if ((vds.getStatus() == VDSStatus.Maintenance || vds.getStatus() == VDSStatus.PendingApproval) && doesHostSupportAnyCluster(clusters, vds)) {
            availableHosts.add(vds);
        }
        if (vds.getStatus() == VDSStatus.Up && Linq.isClusterItemExistInList(clusters, vds.getVdsGroupId())) {
            upHosts.add(vds);
        }
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("AddHost", this);
    tempVar.setIsExecutionAllowed(clusters.size() > 0);
    UICommand addHostAction = tempVar;
    addHostAction.setTitle(DataCenterConfigureHostsAction);
    getCompulsoryActions().add(addHostAction);
    // Select host action.
    // $NON-NLS-1$
    UICommand selectHostAction = new UICommand("SelectHost", this);
    // If now compatible hosts are found - disable the select host button
    selectHostAction.setIsChangable(availableHosts.size() > 0);
    selectHostAction.setIsExecutionAllowed(availableHosts.size() > 0);
    if (clusters.size() > 0) {
        if (hosts.isEmpty()) {
            selectHostAction.setTitle(DataCenterSelectHostsAction);
            getCompulsoryActions().add(selectHostAction);
        } else {
            selectHostAction.setTitle(DataCenterSelectHostsAction);
            getOptionalActions().add(selectHostAction);
        }
    }
    ArrayList<StorageDomain> unattachedStorage = new ArrayList<StorageDomain>();
    boolean addToList;
    Version version3_0 = new Version(3, 0);
    for (StorageDomain item : allStorageDomains) {
        addToList = false;
        if (item.getStorageDomainType() == StorageDomainType.Data && item.getStorageType() == getEntity().getStorageType() && item.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) {
            if (getEntity().getStoragePoolFormatType() == null) {
                // compat logic: in case its not v1 and the version is less than 3.0 break.
                if (item.getStorageStaticData().getStorageFormat() != StorageFormatType.V1 && getEntity().getcompatibility_version().compareTo(version3_0) < 0) {
                    continue;
                }
                addToList = true;
            } else if (getEntity().getStoragePoolFormatType() == item.getStorageStaticData().getStorageFormat()) {
                addToList = true;
            }
        }
        if (addToList) {
            unattachedStorage.add(item);
        }
    }
    ArrayList<StorageDomain> attachedDataStorages = new ArrayList<StorageDomain>();
    for (StorageDomain a : attachedStorageDomains) {
        if (a.getStorageDomainType() == StorageDomainType.Data || a.getStorageDomainType() == StorageDomainType.Master) {
            attachedDataStorages.add(a);
        }
    }
    // $NON-NLS-1$
    UICommand addDataStorageAction = new UICommand("AddDataStorage", this);
    addDataStorageAction.getExecuteProhibitionReasons().add(NoUpHostReason);
    addDataStorageAction.setIsExecutionAllowed(upHosts.size() > 0);
    if (unattachedStorage.isEmpty() && attachedDataStorages.isEmpty()) {
        addDataStorageAction.setTitle(DataCenterConfigureStorageAction);
        getCompulsoryActions().add(addDataStorageAction);
    } else {
        addDataStorageAction.setTitle(DataCenterAddMoreStorageAction);
        getOptionalActions().add(addDataStorageAction);
    }
    // Attach data storage action.
    // $NON-NLS-1$
    UICommand attachDataStorageAction = new UICommand("AttachDataStorage", this);
    if (upHosts.isEmpty()) {
        attachDataStorageAction.getExecuteProhibitionReasons().add(NoUpHostReason);
    }
    attachDataStorageAction.setIsExecutionAllowed(unattachedStorage.size() > 0 && upHosts.size() > 0);
    if (attachedDataStorages.isEmpty()) {
        attachDataStorageAction.setTitle(DataCenterAttachStorageAction);
        getCompulsoryActions().add(attachDataStorageAction);
    } else {
        attachDataStorageAction.setTitle(DataCenterAttachMoreStorageAction);
        getOptionalActions().add(attachDataStorageAction);
    }
    // $NON-NLS-1$
    UICommand addIsoStorageAction = new UICommand("AddIsoStorage", this);
    addIsoStorageAction.getExecuteProhibitionReasons().add(NoDataDomainAttachedReason);
    addIsoStorageAction.setIsExecutionAllowed(getEntity().getStatus() == StoragePoolStatus.Up);
    if (isoStorageDomains.isEmpty()) {
        addIsoStorageAction.setTitle(DataCenterConfigureISOLibraryAction);
        getOptionalActions().add(addIsoStorageAction);
    }
    // Attach ISO storage action.
    // Allow to attach ISO domain only when there are Data storages attached
    // and there ISO storages to attach and ther are no ISO storages actually
    // attached.
    ArrayList<StorageDomain> attachedIsoStorages = new ArrayList<StorageDomain>();
    for (StorageDomain sd : attachedStorageDomains) {
        if (sd.getStorageDomainType() == StorageDomainType.ISO) {
            attachedIsoStorages.add(sd);
        }
    }
    boolean attachIsoAllowed = (attachedDataStorages.size() > 0 && Linq.isAnyStorageDomainIsMatserAndActive(attachedDataStorages) && isoStorageDomains.size() > 0 && attachedIsoStorages.isEmpty() && upHosts.size() > 0);
    // The action is available if there are no storages attached to the
    // Data Center. It will not always be allowed.
    boolean attachIsoAvailable = attachedIsoStorages.isEmpty();
    // $NON-NLS-1$
    UICommand attachIsoStorageAction = new UICommand("AttachIsoStorage", this);
    attachIsoStorageAction.setIsAvailable(attachIsoAvailable);
    if (upHosts.isEmpty()) {
        attachIsoStorageAction.getExecuteProhibitionReasons().add(NoUpHostReason);
    }
    attachIsoStorageAction.setIsExecutionAllowed(attachIsoAllowed);
    if (attachIsoAvailable) {
        attachIsoStorageAction.setTitle(DataCenterAttachISOLibraryAction);
        getOptionalActions().add(attachIsoStorageAction);
    }
    stopProgress();
}
#method_after
private void updateOptionsNonLocalFS() {
    if (clusters == null || allStorageDomains == null || attachedStorageDomains == null || isoStorageDomains == null || allHosts == null) {
        return;
    }
    // Add cluster action.
    // $NON-NLS-1$
    UICommand addClusterAction = new UICommand("AddCluster", this);
    if (clusters.isEmpty()) {
        addClusterAction.setTitle(DataCenterConfigureClustersAction);
        getCompulsoryActions().add(addClusterAction);
    } else {
        addClusterAction.setTitle(DataCenterAddAnotherClusterAction);
        getOptionalActions().add(addClusterAction);
    }
    ArrayList<VDS> hosts = new ArrayList<VDS>();
    ArrayList<VDS> availableHosts = new ArrayList<VDS>();
    ArrayList<VDS> upHosts = new ArrayList<VDS>();
    for (VDS vds : allHosts) {
        if (Linq.isClusterItemExistInList(clusters, vds.getVdsGroupId())) {
            hosts.add(vds);
        }
        if ((vds.getStatus() == VDSStatus.Maintenance || vds.getStatus() == VDSStatus.PendingApproval) && doesHostSupportAnyCluster(clusters, vds)) {
            availableHosts.add(vds);
        }
        if (vds.getStatus() == VDSStatus.Up && Linq.isClusterItemExistInList(clusters, vds.getVdsGroupId())) {
            upHosts.add(vds);
        }
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("AddHost", this);
    tempVar.setIsExecutionAllowed(clusters.size() > 0);
    UICommand addHostAction = tempVar;
    addHostAction.setTitle(DataCenterConfigureHostsAction);
    getCompulsoryActions().add(addHostAction);
    // Select host action.
    // $NON-NLS-1$
    UICommand selectHostAction = new UICommand("SelectHost", this);
    // If now compatible hosts are found - disable the select host button
    selectHostAction.setIsChangable(availableHosts.size() > 0);
    selectHostAction.setIsExecutionAllowed(availableHosts.size() > 0);
    if (clusters.size() > 0) {
        if (hosts.isEmpty()) {
            selectHostAction.setTitle(DataCenterSelectHostsAction);
            getCompulsoryActions().add(selectHostAction);
        } else {
            selectHostAction.setTitle(DataCenterSelectHostsAction);
            getOptionalActions().add(selectHostAction);
        }
    }
    ArrayList<StorageDomain> unattachedStorage = new ArrayList<StorageDomain>();
    boolean addToList;
    Version version3_0 = new Version(3, 0);
    for (StorageDomain item : allStorageDomains) {
        addToList = false;
        if (item.getStorageDomainType() == StorageDomainType.Data && item.getStorageType() == getEntity().getStorageType() && item.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) {
            if (getEntity().getStoragePoolFormatType() == null) {
                // compat logic: in case its not v1 and the version is less than 3.0 break.
                if (item.getStorageStaticData().getStorageFormat() != StorageFormatType.V1 && getEntity().getcompatibility_version().compareTo(version3_0) < 0) {
                    continue;
                }
                addToList = true;
            } else if (getEntity().getStoragePoolFormatType() == item.getStorageStaticData().getStorageFormat()) {
                addToList = true;
            }
        }
        if (addToList) {
            unattachedStorage.add(item);
        }
    }
    ArrayList<StorageDomain> attachedDataStorages = new ArrayList<StorageDomain>();
    for (StorageDomain a : attachedStorageDomains) {
        if (a.getStorageDomainType() == StorageDomainType.Data || a.getStorageDomainType() == StorageDomainType.Master) {
            attachedDataStorages.add(a);
        }
    }
    // $NON-NLS-1$
    UICommand addDataStorageAction = new UICommand("AddDataStorage", this);
    addDataStorageAction.getExecuteProhibitionReasons().add(NoUpHostReason);
    addDataStorageAction.setIsExecutionAllowed(upHosts.size() > 0);
    if (unattachedStorage.isEmpty() && attachedDataStorages.isEmpty()) {
        addDataStorageAction.setTitle(DataCenterConfigureStorageAction);
        getCompulsoryActions().add(addDataStorageAction);
    } else {
        addDataStorageAction.setTitle(DataCenterAddMoreStorageAction);
        getOptionalActions().add(addDataStorageAction);
    }
    // Attach data storage action.
    // $NON-NLS-1$
    UICommand attachDataStorageAction = new UICommand("AttachDataStorage", this);
    if (upHosts.isEmpty()) {
        attachDataStorageAction.getExecuteProhibitionReasons().add(NoUpHostReason);
    }
    attachDataStorageAction.setIsExecutionAllowed(unattachedStorage.size() > 0 && upHosts.size() > 0);
    if (attachedDataStorages.isEmpty()) {
        attachDataStorageAction.setTitle(DataCenterAttachStorageAction);
        getCompulsoryActions().add(attachDataStorageAction);
    } else {
        attachDataStorageAction.setTitle(DataCenterAttachMoreStorageAction);
        getOptionalActions().add(attachDataStorageAction);
    }
    // $NON-NLS-1$
    UICommand addIsoStorageAction = new UICommand("AddIsoStorage", this);
    addIsoStorageAction.getExecuteProhibitionReasons().add(NoDataDomainAttachedReason);
    addIsoStorageAction.setIsExecutionAllowed(getEntity().getStatus() == StoragePoolStatus.Up);
    if (isoStorageDomains.isEmpty()) {
        addIsoStorageAction.setTitle(DataCenterConfigureISOLibraryAction);
        getOptionalActions().add(addIsoStorageAction);
    }
    // Attach ISO storage action.
    // Allow to attach ISO domain only when there are Data storages attached
    // and there ISO storages to attach and ther are no ISO storages actually
    // attached.
    ArrayList<StorageDomain> attachedIsoStorages = new ArrayList<StorageDomain>();
    for (StorageDomain sd : attachedStorageDomains) {
        if (sd.getStorageDomainType() == StorageDomainType.ISO) {
            attachedIsoStorages.add(sd);
        }
    }
    boolean attachIsoAllowed = (attachedDataStorages.size() > 0 && Linq.isAnyStorageDomainIsMasterAndActive(attachedDataStorages) && isoStorageDomains.size() > 0 && attachedIsoStorages.isEmpty() && upHosts.size() > 0);
    // The action is available if there are no storages attached to the
    // Data Center. It will not always be allowed.
    boolean attachIsoAvailable = attachedIsoStorages.isEmpty();
    // $NON-NLS-1$
    UICommand attachIsoStorageAction = new UICommand("AttachIsoStorage", this);
    attachIsoStorageAction.setIsAvailable(attachIsoAvailable);
    if (upHosts.isEmpty()) {
        attachIsoStorageAction.getExecuteProhibitionReasons().add(NoUpHostReason);
    }
    attachIsoStorageAction.setIsExecutionAllowed(attachIsoAllowed);
    if (attachIsoAvailable) {
        attachIsoStorageAction.setTitle(DataCenterAttachISOLibraryAction);
        getOptionalActions().add(attachIsoStorageAction);
    }
    stopProgress();
}
#end_block

#method_before
public void onAddHost() {
    cancelConfirm();
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    // Save changes.
    VDS host = new VDS();
    host.setVdsName((String) model.getName().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    host.setSshUsername(model.getUserName().getEntity().toString());
    host.setSshKeyFingerprint(model.getFetchSshFingerprint().getEntity().toString());
    host.setVdsGroupId(((VDSGroup) model.getCluster().getSelectedItem()).getId());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap(model.getPmOptionsMap());
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy((Boolean) model.getDisableAutomaticPowerManagement().getEntity());
    AddVdsActionParameters addVdsParams = new AddVdsActionParameters();
    addVdsParams.setVdsId(host.getId());
    addVdsParams.setvds(host);
    if (model.getUserPassword().getEntity() != null) {
        addVdsParams.setPassword((String) model.getUserPassword().getEntity());
    }
    addVdsParams.setRebootAfterInstallation(((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService());
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVds, addVdsParams, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel localModel = (DataCenterGuideModel) result.getState();
            localModel.postOnAddHost(result.getReturnValue());
        }
    }, this);
}
#method_after
public void onAddHost() {
    cancelConfirm();
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    // Save changes.
    VDS host = new VDS();
    host.setVdsName((String) model.getName().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    host.setSshUsername(model.getUserName().getEntity().toString());
    host.setSshKeyFingerprint(model.getFetchSshFingerprint().getEntity().toString());
    host.setVdsGroupId(((VDSGroup) model.getCluster().getSelectedItem()).getId());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap(model.getPmOptionsMap());
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    AddVdsActionParameters addVdsParams = new AddVdsActionParameters();
    addVdsParams.setVdsId(host.getId());
    addVdsParams.setvds(host);
    if (model.getUserPassword().getEntity() != null) {
        addVdsParams.setPassword((String) model.getUserPassword().getEntity());
    }
    addVdsParams.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    addVdsParams.setRebootAfterInstallation(((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService());
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVds, addVdsParams, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            DataCenterGuideModel localModel = (DataCenterGuideModel) result.getState();
            localModel.postOnAddHost(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
public EntityModel getDisableAutomaticPowerManagement() {
    return disableAutomaticPowerManagement;
}
#method_after
public EntityModel<Boolean> getDisableAutomaticPowerManagement() {
    return disableAutomaticPowerManagement;
}
#end_block

#method_before
private void setDisableAutomaticPowerManagement(EntityModel value) {
    disableAutomaticPowerManagement = value;
}
#method_after
private void setDisableAutomaticPowerManagement(EntityModel<Boolean> value) {
    disableAutomaticPowerManagement = value;
}
#end_block

#method_before
private void dataCenter_SelectedItemChanged() {
    StoragePool dataCenter = (StoragePool) getDataCenter().getSelectedItem();
    if (dataCenter != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                HostModel hostModel = (HostModel) model;
                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) result;
                VDSGroup oldCluster = (VDSGroup) hostModel.getCluster().getSelectedItem();
                StoragePool selectedDataCenter = (StoragePool) getDataCenter().getSelectedItem();
                // clusters
                if (clusters.isEmpty() || clusters.size() > 0 && clusters.get(0).getStoragePoolId().equals(selectedDataCenter.getId())) {
                    hostModel.getCluster().setItems(clusters);
                    if (oldCluster != null) {
                        VDSGroup newSelectedItem = Linq.firstOrDefault(clusters, new Linq.ClusterPredicate(oldCluster.getId()));
                        if (newSelectedItem != null) {
                            hostModel.getCluster().setSelectedItem(newSelectedItem);
                        }
                    }
                    if (hostModel.getCluster().getSelectedItem() == null) {
                        hostModel.getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
                    }
                }
            }
        };
        AsyncDataProvider.getClusterList(_asyncQuery, dataCenter.getId());
    }
}
#method_after
private void dataCenter_SelectedItemChanged() {
    StoragePool dataCenter = (StoragePool) getDataCenter().getSelectedItem();
    if (dataCenter != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                HostModel hostModel = (HostModel) model;
                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) result;
                StoragePool selectedDataCenter = (StoragePool) getDataCenter().getSelectedItem();
                // clusters
                if (clusters.isEmpty() || clusters.size() > 0 && clusters.get(0).getStoragePoolId().equals(selectedDataCenter.getId())) {
                    if (hostModel.getIsNew()) {
                        updateClusterList(hostModel, clusters);
                    } else {
                        AsyncQuery architectureQuery = new AsyncQuery();
                        architectureQuery.setModel(new Object[] { hostModel, clusters });
                        architectureQuery.asyncCallback = new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                Object[] objArray = (Object[]) model;
                                HostModel hostModel = (HostModel) objArray[0];
                                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) objArray[1];
                                ArchitectureType architecture = (ArchitectureType) returnValue;
                                ArrayList<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
                                for (VDSGroup cluster : clusters) {
                                    if (cluster.getArchitecture() == ArchitectureType.undefined || cluster.getArchitecture() == architecture) {
                                        filteredClusters.add(cluster);
                                    }
                                }
                                updateClusterList(hostModel, filteredClusters);
                            }
                        };
                        AsyncDataProvider.getHostArchitecture(architectureQuery, hostModel.getHostId());
                    }
                }
            }
        };
        AsyncDataProvider.getClusterList(_asyncQuery, dataCenter.getId());
    }
}
#end_block

#method_before
@Override
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    // TODO should be handled in a more generic way
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsPowerManagementTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsPowerManagementTabValid()) {
                    powerManagementTab.markAsValid();
                } else {
                    powerManagementTab.markAsInvalid(null);
                }
            }
        }
    });
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            fetchResult.setText((String) object.getFetchResult().getEntity());
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    rbPassword.setValue(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            Object selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#method_after
@Override
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    // TODO should be handled in a more generic way
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsPowerManagementTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsPowerManagementTabValid()) {
                    powerManagementTab.markAsValid();
                } else {
                    powerManagementTab.markAsInvalid(null);
                }
            }
        }
    });
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            fetchResult.setText((String) object.getFetchResult().getEntity());
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    rbPassword.setValue(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            Object selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VdsDynamic other = (VdsDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(_supportedClusterVersionsSet, other._supportedClusterVersionsSet) && ObjectUtils.objectsEqual(_supportedENGINESVersionsSet, other._supportedENGINESVersionsSet) && ObjectUtils.objectsEqual(buildName, other.buildName) && ObjectUtils.objectsEqual(cpu_cores, other.cpu_cores) && ObjectUtils.objectsEqual(cpuThreads, other.cpuThreads) && ObjectUtils.objectsEqual(cpu_flags, other.cpu_flags) && ObjectUtils.objectsEqual(cpu_model, other.cpu_model) && ObjectUtils.objectsEqual(cpu_over_commit_time_stamp, other.cpu_over_commit_time_stamp) && ObjectUtils.objectsEqual(cpu_sockets, other.cpu_sockets) && ObjectUtils.objectsEqual(cpu_speed_mh, other.cpu_speed_mh) && ObjectUtils.objectsEqual(guest_overhead, other.guest_overhead) && ObjectUtils.objectsEqual(hooksStr, other.hooksStr) && ObjectUtils.objectsEqual(host_os, other.host_os) && ObjectUtils.objectsEqual(iScsiInitiatorName, other.iScsiInitiatorName) && ObjectUtils.objectsEqual(if_total_speed, other.if_total_speed) && ObjectUtils.objectsEqual(kernel_version, other.kernel_version) && ObjectUtils.objectsEqual(kvm_enabled, other.kvm_enabled) && ObjectUtils.objectsEqual(kvm_version, other.kvm_version) && ObjectUtils.objectsEqual(libvirt_version, other.libvirt_version) && ObjectUtils.objectsEqual(rpmVersion, other.rpmVersion) && ObjectUtils.objectsEqual(mem_commited, other.mem_commited) && ObjectUtils.objectsEqual(net_config_dirty, other.net_config_dirty) && nonOperationalReason == other.nonOperationalReason && ObjectUtils.objectsEqual(pending_vcpus_count, other.pending_vcpus_count) && ObjectUtils.objectsEqual(pending_vmem_size, other.pending_vmem_size) && ObjectUtils.objectsEqual(physical_mem_mb, other.physical_mem_mb) && previous_status == other.previous_status && ObjectUtils.objectsEqual(reserved_mem, other.reserved_mem) && ObjectUtils.objectsEqual(getsoftware_version(), other.getsoftware_version()) && ObjectUtils.objectsEqual(spice_version, other.spice_version) && ObjectUtils.objectsEqual(glusterVersion, other.glusterVersion) && status == other.status && ObjectUtils.objectsEqual(supported_cluster_levels, other.supported_cluster_levels) && ObjectUtils.objectsEqual(supported_engines, other.supported_engines) && transparentHugePagesState == other.transparentHugePagesState && ObjectUtils.objectsEqual(versionName, other.versionName) && ObjectUtils.objectsEqual(vm_active, other.vm_active) && vm_count == other.vm_count && ObjectUtils.objectsEqual(vm_migrating, other.vm_migrating) && ObjectUtils.objectsEqual(vms_cores_count, other.vms_cores_count) && ObjectUtils.objectsEqual(hwManufacturer, other.hwManufacturer) && ObjectUtils.objectsEqual(hwProductName, other.hwProductName) && ObjectUtils.objectsEqual(hwVersion, other.hwVersion) && ObjectUtils.objectsEqual(hwSerialNumber, other.hwSerialNumber) && ObjectUtils.objectsEqual(hwUUID, other.hwUUID) && ObjectUtils.objectsEqual(hwFamily, other.hwFamily) && ObjectUtils.objectsEqual(HBAs, other.HBAs) && ObjectUtils.objectsEqual(supportedEmulatedMachines, other.supportedEmulatedMachines)) && ObjectUtils.objectsEqual(powerManagementControlledByPolicy, other.powerManagementControlledByPolicy);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VdsDynamic other = (VdsDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(_supportedClusterVersionsSet, other._supportedClusterVersionsSet) && ObjectUtils.objectsEqual(_supportedENGINESVersionsSet, other._supportedENGINESVersionsSet) && ObjectUtils.objectsEqual(buildName, other.buildName) && ObjectUtils.objectsEqual(cpu_cores, other.cpu_cores) && ObjectUtils.objectsEqual(cpuThreads, other.cpuThreads) && ObjectUtils.objectsEqual(cpu_flags, other.cpu_flags) && ObjectUtils.objectsEqual(cpu_model, other.cpu_model) && ObjectUtils.objectsEqual(cpu_over_commit_time_stamp, other.cpu_over_commit_time_stamp) && ObjectUtils.objectsEqual(cpu_sockets, other.cpu_sockets) && ObjectUtils.objectsEqual(cpu_speed_mh, other.cpu_speed_mh) && ObjectUtils.objectsEqual(guest_overhead, other.guest_overhead) && ObjectUtils.objectsEqual(hooksStr, other.hooksStr) && ObjectUtils.objectsEqual(host_os, other.host_os) && ObjectUtils.objectsEqual(iScsiInitiatorName, other.iScsiInitiatorName) && ObjectUtils.objectsEqual(if_total_speed, other.if_total_speed) && ObjectUtils.objectsEqual(kernel_version, other.kernel_version) && ObjectUtils.objectsEqual(kvm_enabled, other.kvm_enabled) && ObjectUtils.objectsEqual(kvm_version, other.kvm_version) && ObjectUtils.objectsEqual(libvirt_version, other.libvirt_version) && ObjectUtils.objectsEqual(rpmVersion, other.rpmVersion) && ObjectUtils.objectsEqual(mem_commited, other.mem_commited) && ObjectUtils.objectsEqual(net_config_dirty, other.net_config_dirty) && nonOperationalReason == other.nonOperationalReason && ObjectUtils.objectsEqual(pending_vcpus_count, other.pending_vcpus_count) && ObjectUtils.objectsEqual(pending_vmem_size, other.pending_vmem_size) && ObjectUtils.objectsEqual(physical_mem_mb, other.physical_mem_mb) && previous_status == other.previous_status && ObjectUtils.objectsEqual(reserved_mem, other.reserved_mem) && ObjectUtils.objectsEqual(getsoftware_version(), other.getsoftware_version()) && ObjectUtils.objectsEqual(spice_version, other.spice_version) && ObjectUtils.objectsEqual(glusterVersion, other.glusterVersion) && status == other.status && ObjectUtils.objectsEqual(supported_cluster_levels, other.supported_cluster_levels) && ObjectUtils.objectsEqual(supported_engines, other.supported_engines) && transparentHugePagesState == other.transparentHugePagesState && ObjectUtils.objectsEqual(versionName, other.versionName) && ObjectUtils.objectsEqual(vm_active, other.vm_active) && vm_count == other.vm_count && ObjectUtils.objectsEqual(vm_migrating, other.vm_migrating) && ObjectUtils.objectsEqual(vms_cores_count, other.vms_cores_count) && ObjectUtils.objectsEqual(hwManufacturer, other.hwManufacturer) && ObjectUtils.objectsEqual(hwProductName, other.hwProductName) && ObjectUtils.objectsEqual(hwVersion, other.hwVersion) && ObjectUtils.objectsEqual(hwSerialNumber, other.hwSerialNumber) && ObjectUtils.objectsEqual(hwUUID, other.hwUUID) && ObjectUtils.objectsEqual(hwFamily, other.hwFamily) && ObjectUtils.objectsEqual(HBAs, other.HBAs) && ObjectUtils.objectsEqual(supportedEmulatedMachines, other.supportedEmulatedMachines)) && powerManagementControlledByPolicy == other.powerManagementControlledByPolicy;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSGroup vdsGroup = getVdsGroup();
    boolean initSucceeded = true;
    /* Host is UP, re-set the policy controlled power management flag */
    getVds().setPowerManagementControlledByPolicy(true);
    DbFacade.getInstance().getVdsDynamicDao().update(getVds().getDynamicData());
    if (vdsGroup.supportsTrustedService()) {
        initSucceeded = initTrustedService();
    }
    if (initSucceeded && vdsGroup.supportsVirtService()) {
        initSucceeded = initVirtResources();
    }
    if (initSucceeded && vdsGroup.supportsGlusterService()) {
        initSucceeded = initGlusterHost();
    }
    setSucceeded(initSucceeded);
}
#method_after
@Override
protected void executeCommand() {
    VDSGroup vdsGroup = getVdsGroup();
    boolean initSucceeded = true;
    /* Host is UP, re-set the policy controlled power management flag */
    getVds().setPowerManagementControlledByPolicy(true);
    DbFacade.getInstance().getVdsDynamicDao().updateVdsDynamicPowerManagementPolicyFlag(getVds().getId(), getVds().isPowerManagementControlledByPolicy());
    if (vdsGroup.supportsTrustedService()) {
        initSucceeded = initTrustedService();
    }
    if (initSucceeded && vdsGroup.supportsVirtService()) {
        initSucceeded = initVirtResources();
    }
    if (initSucceeded && vdsGroup.supportsGlusterService()) {
        initSucceeded = initGlusterHost();
    }
    setSucceeded(initSucceeded);
}
#end_block

#method_before
private boolean initGlusterPeerProcess() {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVds().getVdsGroupId())) {
        glusterPeerListSucceeded = true;
        glusterPeerProbeSucceeded = true;
        Map<String, String> customLogValues = new HashMap<String, String>();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS vds : vdsList) {
                if (!getVdsId().equals(vds.getId())) {
                    upServer = vds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!hostExists(glusterServers, getVds())) {
                    if (!glusterPeerProbe(upServer.getId(), getVds().getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + getVds().getHostName());
                        setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                    int retries = 0;
                    while (retries < MAX_RETRIES_GLUSTER_PROBE_STATUS) {
                        // though gluster peer probe succeeds, it takes some time for the host to be
                        // listed as a peer. Return success only when the host is acknowledged as peer
                        // from another upServer.
                        VDS newUpServer = getNewUpServer(upServer);
                        if (newUpServer == null) {
                            // there's no other up server. so there's no issue with peer status results
                            return true;
                        }
                        List<GlusterServerInfo> newGlusterServers = getGlusterPeers(newUpServer.getId());
                        if (!hostExists(newGlusterServers, getVds())) {
                            log.infoFormat("Failed to find host {0} in gluster peer list from {1} on attempt {2}", getVds(), newUpServer, ++retries);
                            // if num of attempts done
                            if (retries == MAX_RETRIES_GLUSTER_PROBE_STATUS) {
                                customLogValues.put("Command", "gluster peer status " + getVds().getHostName());
                                setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                                return false;
                            }
                            try {
                                // give time for gluster peer probe to propogate to servers.
                                Thread.sleep(1000);
                            } catch (Exception e) {
                                log.error(e.getMessage());
                                break;
                            }
                        } else {
                            return true;
                        }
                    }
                }
            }
        }
        return true;
    }
}
#method_after
private boolean initGlusterPeerProcess() {
    // condition.
    try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVds().getVdsGroupId())) {
        glusterPeerListSucceeded = true;
        glusterPeerProbeSucceeded = true;
        Map<String, String> customLogValues = new HashMap<String, String>();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
        // If the cluster already having Gluster servers, get an up server
        if (vdsList != null && vdsList.size() > 0) {
            VDS upServer = null;
            for (VDS vds : vdsList) {
                if (!getVdsId().equals(vds.getId())) {
                    upServer = vds;
                    break;
                }
            }
            // If new server is not part of the existing gluster peers, add into peer group
            if (upServer != null) {
                List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
                customLogValues.put("Server", upServer.getHostName());
                if (glusterServers.size() == 0) {
                    customLogValues.put("Command", "gluster peer status");
                    setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                    return false;
                } else if (!getGlusterUtil().isHostExists(glusterServers, getVds())) {
                    if (!glusterPeerProbe(upServer.getId(), getVds().getHostName())) {
                        customLogValues.put("Command", "gluster peer probe " + getVds().getHostName());
                        setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                        return false;
                    }
                    int retries = 0;
                    while (retries < MAX_RETRIES_GLUSTER_PROBE_STATUS) {
                        // though gluster peer probe succeeds, it takes some time for the host to be
                        // listed as a peer. Return success only when the host is acknowledged as peer
                        // from another upServer.
                        VDS newUpServer = getNewUpServer(upServer);
                        if (newUpServer == null) {
                            // there's no other up server. so there's no issue with peer status results
                            return true;
                        }
                        List<GlusterServerInfo> newGlusterServers = getGlusterPeers(newUpServer.getId());
                        if (!getGlusterUtil().isHostExists(newGlusterServers, getVds())) {
                            log.infoFormat("Failed to find host {0} in gluster peer list from {1} on attempt {2}", getVds(), newUpServer, ++retries);
                            // if num of attempts done
                            if (retries == MAX_RETRIES_GLUSTER_PROBE_STATUS) {
                                customLogValues.put("Command", "gluster peer status " + getVds().getHostName());
                                setNonOperational(NonOperationalReason.GLUSTER_COMMAND_FAILED, customLogValues);
                                return false;
                            }
                            try {
                                // give time for gluster peer probe to propogate to servers.
                                Thread.sleep(1000);
                            } catch (Exception e) {
                                log.error(e.getMessage());
                                break;
                            }
                        } else {
                            return true;
                        }
                    }
                }
            }
        }
        return true;
    }
}
#end_block

#method_before
@Mapping(from = PowerManagement.class, to = VdsStatic.class)
public static VdsStatic map(PowerManagement model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    entity.setManagementIp(getManagementIp(model, entity));
    entity.setPmType(getManagementType(model, entity));
    entity.setPmUser(getManagementUser(model, entity));
    entity.setPmPassword(getManagementPassword(model, entity));
    entity.setPmOptions(getManagementOptions(model, entity));
    if (model.isSetEnabled()) {
        entity.setPmEnabled(model.isEnabled());
    }
    if (model.isSetDisableAutomaticPm()) {
        entity.setDisablePowerManagementPolicy(model.isDisableAutomaticPm());
    }
    if (model.isSetPmProxies()) {
        String delim = "";
        StringBuilder builder = new StringBuilder();
        for (PmProxy pmProxy : model.getPmProxies().getPmProxy()) {
            builder.append(delim);
            builder.append(pmProxy.getType());
            delim = ",";
        }
        entity.setPmProxyPreferences(builder.toString());
    }
    if (model.isSetAgents()) {
        // Currently only Primary/Secondary agents are supported
        int order = 1;
        for (Agent agent : model.getAgents().getAgents()) {
            if (agent.isSetOrder()) {
                order = agent.getOrder();
            }
            if (order == 1) {
                // Primary
                // in case that order is not defined, secondary will still be defined correctly.
                order++;
            } else if (order == 2) {
                // Secondary
                if (agent.isSetType()) {
                    entity.setPmSecondaryType(agent.getType());
                }
                if (agent.isSetAddress()) {
                    entity.setPmSecondaryIp(agent.getAddress());
                }
                if (agent.isSetUsername()) {
                    entity.setPmSecondaryUser(agent.getUsername());
                }
                if (agent.isSetPassword()) {
                    entity.setPmSecondaryPassword(agent.getPassword());
                }
                if (agent.isSetOptions()) {
                    entity.setPmSecondaryOptions(map(agent.getOptions(), null));
                }
                if (agent.isSetConcurrent()) {
                    entity.setPmSecondaryConcurrent(agent.isConcurrent());
                }
            }
        }
    }
    return entity;
}
#method_after
@Mapping(from = PowerManagement.class, to = VdsStatic.class)
public static VdsStatic map(PowerManagement model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    entity.setManagementIp(getManagementIp(model, entity));
    entity.setPmType(getManagementType(model, entity));
    entity.setPmUser(getManagementUser(model, entity));
    entity.setPmPassword(getManagementPassword(model, entity));
    entity.setPmOptions(getManagementOptions(model, entity));
    if (model.isSetEnabled()) {
        entity.setPmEnabled(model.isEnabled());
    }
    if (model.isSetAutomaticPmEnabled()) {
        entity.setDisablePowerManagementPolicy(!model.isAutomaticPmEnabled());
    }
    if (model.isSetPmProxies()) {
        String delim = "";
        StringBuilder builder = new StringBuilder();
        for (PmProxy pmProxy : model.getPmProxies().getPmProxy()) {
            builder.append(delim);
            builder.append(pmProxy.getType());
            delim = ",";
        }
        entity.setPmProxyPreferences(builder.toString());
    }
    if (model.isSetAgents()) {
        // Currently only Primary/Secondary agents are supported
        int order = 1;
        for (Agent agent : model.getAgents().getAgents()) {
            if (agent.isSetOrder()) {
                order = agent.getOrder();
            }
            if (order == 1) {
                // Primary
                // in case that order is not defined, secondary will still be defined correctly.
                order++;
            } else if (order == 2) {
                // Secondary
                if (agent.isSetType()) {
                    entity.setPmSecondaryType(agent.getType());
                }
                if (agent.isSetAddress()) {
                    entity.setPmSecondaryIp(agent.getAddress());
                }
                if (agent.isSetUsername()) {
                    entity.setPmSecondaryUser(agent.getUsername());
                }
                if (agent.isSetPassword()) {
                    entity.setPmSecondaryPassword(agent.getPassword());
                }
                if (agent.isSetOptions()) {
                    entity.setPmSecondaryOptions(map(agent.getOptions(), null));
                }
                if (agent.isSetConcurrent()) {
                    entity.setPmSecondaryConcurrent(agent.isConcurrent());
                }
            }
        }
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = PowerManagement.class)
public static PowerManagement map(VDS entity, PowerManagement template) {
    PowerManagement model = template != null ? template : new PowerManagement();
    model.setType(entity.getPmType());
    model.setEnabled(entity.getpm_enabled());
    model.setAddress(entity.getManagementIp());
    model.setUsername(entity.getPmUser());
    model.setDisableAutomaticPm(entity.isDisablePowerManagementPolicy());
    if (entity.getPmOptionsMap() != null) {
        model.setOptions(map(entity.getPmOptionsMap(), null));
    }
    if (entity.getPmProxyPreferences() != null) {
        PmProxies pmProxies = new PmProxies();
        String[] proxies = StringUtils.split(entity.getPmProxyPreferences(), ",");
        for (String proxy : proxies) {
            PmProxy pmProxy = new PmProxy();
            pmProxy.setType(proxy);
            pmProxies.getPmProxy().add(pmProxy);
        }
        model.setPmProxies(pmProxies);
    }
    if (entity.getpm_enabled()) {
        // Set Primary Agent
        Agent agent = new Agent();
        if (!StringUtils.isEmpty(entity.getManagementIp())) {
            agent.setType(entity.getPmType());
            agent.setAddress(entity.getManagementIp());
            agent.setUsername(entity.getPmUser());
            if (entity.getPmOptionsMap() != null) {
                agent.setOptions(map(entity.getPmOptionsMap(), null));
            }
            agent.setOrder(1);
            model.setAgents(new Agents());
            model.getAgents().getAgents().add(agent);
        }
        // Set Secondary Agent
        if (!StringUtils.isEmpty(entity.getPmSecondaryIp())) {
            agent = new Agent();
            agent.setType(entity.getPmSecondaryType());
            agent.setAddress(entity.getPmSecondaryIp());
            agent.setUsername(entity.getPmSecondaryUser());
            if (entity.getPmOptionsMap() != null) {
                agent.setOptions(map(entity.getPmSecondaryOptionsMap(), null));
            }
            agent.setOrder(2);
            agent.setConcurrent(entity.isPmSecondaryConcurrent());
            model.getAgents().getAgents().add(agent);
        }
    }
    return model;
}
#method_after
@Mapping(from = VDS.class, to = PowerManagement.class)
public static PowerManagement map(VDS entity, PowerManagement template) {
    PowerManagement model = template != null ? template : new PowerManagement();
    model.setType(entity.getPmType());
    model.setEnabled(entity.getpm_enabled());
    model.setAddress(entity.getManagementIp());
    model.setUsername(entity.getPmUser());
    model.setAutomaticPmEnabled(!entity.isDisablePowerManagementPolicy());
    if (entity.getPmOptionsMap() != null) {
        model.setOptions(map(entity.getPmOptionsMap(), null));
    }
    if (entity.getPmProxyPreferences() != null) {
        PmProxies pmProxies = new PmProxies();
        String[] proxies = StringUtils.split(entity.getPmProxyPreferences(), ",");
        for (String proxy : proxies) {
            PmProxy pmProxy = new PmProxy();
            pmProxy.setType(proxy);
            pmProxies.getPmProxy().add(pmProxy);
        }
        model.setPmProxies(pmProxies);
    }
    if (entity.getpm_enabled()) {
        // Set Primary Agent
        Agent agent = new Agent();
        if (!StringUtils.isEmpty(entity.getManagementIp())) {
            agent.setType(entity.getPmType());
            agent.setAddress(entity.getManagementIp());
            agent.setUsername(entity.getPmUser());
            if (entity.getPmOptionsMap() != null) {
                agent.setOptions(map(entity.getPmOptionsMap(), null));
            }
            agent.setOrder(1);
            model.setAgents(new Agents());
            model.getAgents().getAgents().add(agent);
        }
        // Set Secondary Agent
        if (!StringUtils.isEmpty(entity.getPmSecondaryIp())) {
            agent = new Agent();
            agent.setType(entity.getPmSecondaryType());
            agent.setAddress(entity.getPmSecondaryIp());
            agent.setUsername(entity.getPmSecondaryUser());
            if (entity.getPmOptionsMap() != null) {
                agent.setOptions(map(entity.getPmSecondaryOptionsMap(), null));
            }
            agent.setOrder(2);
            agent.setConcurrent(entity.isPmSecondaryConcurrent());
            model.getAgents().getAgents().add(agent);
        }
    }
    return model;
}
#end_block

#method_before
@Override
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    if (hosts == null || hosts.size() < 2) {
        int hostCount = hosts == null ? 0 : hosts.size();
        log.debugFormat("No balancing for cluster {0}, contains only {1} host(s)", cluster.getName(), hostCount);
        return null;
    }
    // get vds that over committed for the time defined
    /* returns list of Hosts with
         *    cpuUtilization >= highUtilization
         *    && cpuOverCommitMinutes >= CpuOverCommitDurationMinutes
         */
    List<VDS> overUtilizedHosts = getOverUtilizedHosts(hosts, parameters);
    // if no hosts is overutilized, then there is nothing to balance...
    if (overUtilizedHosts == null || overUtilizedHosts.size() == 0) {
        return null;
    }
    // returns hosts with utilization lower then the specified threshold
    List<VDS> underUtilizedHosts = getUnderUtilizedHosts(cluster, hosts, parameters);
    // if no host has a spare power, then there is nothing we can do to balance it..
    if (underUtilizedHosts == null || underUtilizedHosts.size() == 0) {
        return null;
    }
    VDS randomHost = overUtilizedHosts.get(new Random().nextInt(overUtilizedHosts.size()));
    List<VM> migrableVmsOnRandomHost = getMigrableVmsRunningOnVds(randomHost.getId());
    if (migrableVmsOnRandomHost.isEmpty()) {
        return null;
    }
    VM vm = getBestVmToMigrate(randomHost.getId(), migrableVmsOnRandomHost);
    List<Guid> underUtilizedHostsKeys = new ArrayList<Guid>();
    for (VDS vds : underUtilizedHosts) {
        underUtilizedHostsKeys.add(vds.getId());
    }
    return new Pair<List<Guid>, Guid>(underUtilizedHostsKeys, vm.getId());
}
#method_after
@Override
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    if (hosts == null || hosts.size() < 2) {
        int hostCount = hosts == null ? 0 : hosts.size();
        log.debugFormat("No balancing for cluster {0}, contains only {1} host(s)", cluster.getName(), hostCount);
        return null;
    }
    // get vds that over committed for the time defined
    /* returns list of Hosts with
         *    cpuUtilization >= highUtilization
         *    && cpuOverCommitMinutes >= CpuOverCommitDurationMinutes
         */
    List<VDS> overUtilizedHosts = getOverUtilizedHosts(hosts, parameters);
    // if there aren't any overutilized hosts, then there is nothing to balance...
    if (overUtilizedHosts == null || overUtilizedHosts.size() == 0) {
        log.infoFormat("There is no over-utilized host in cluster '{0}'", cluster.getName());
        return null;
    }
    // returns hosts with utilization lower than the specified threshold
    List<VDS> underUtilizedHosts = getUnderUtilizedHosts(cluster, hosts, parameters);
    // if no host has a spare power, then there is nothing we can do to balance it..
    if (underUtilizedHosts == null || underUtilizedHosts.size() == 0) {
        log.warnFormat("All hosts are over-utilized, can't balance the cluster '{0}'", cluster.getName());
        return null;
    }
    VDS randomHost = overUtilizedHosts.get(new Random().nextInt(overUtilizedHosts.size()));
    List<VM> migrableVmsOnRandomHost = getMigrableVmsRunningOnVds(randomHost.getId());
    if (migrableVmsOnRandomHost.isEmpty()) {
        return null;
    }
    VM vm = getBestVmToMigrate(randomHost.getId(), migrableVmsOnRandomHost);
    List<Guid> underUtilizedHostsKeys = new ArrayList<Guid>();
    for (VDS vds : underUtilizedHosts) {
        underUtilizedHostsKeys.add(vds.getId());
    }
    return new Pair<List<Guid>, Guid>(underUtilizedHostsKeys, vm.getId());
}
#end_block

#method_before
private VDS getWorstVDS(List<VDS> relevantHosts, Map<String, String> parameters) {
    VDS worstVDS = relevantHosts.get(0);
    for (VDS vds : relevantHosts) {
        if (getOccupiedVMSLots(vds, parameters) > getOccupiedVMSLots(worstVDS, parameters))
            worstVDS = vds;
    }
    return worstVDS;
}
#method_after
private VDS getWorstVDS(List<VDS> relevantHosts, Map<String, String> parameters) {
    VDS worstVds = relevantHosts.get(0);
    int worstVdsSlots = 0;
    for (VDS vds : relevantHosts) {
        if (getOccupiedVmSlots(vds, parameters) > worstVdsSlots) {
            worstVds = vds;
            worstVdsSlots = getOccupiedVmSlots(worstVds, parameters);
        }
    }
    return worstVds;
}
#end_block

#method_before
@Override
protected List<VDS> getOverUtilizedHosts(List<VDS> relevantHosts, final Map<String, String> parameters) {
    final int highVmCountUtilization = tryParseWithDefault(parameters.get("HighVMCount"), getHighVMCountDefaultValue());
    final VDS worstVDS = getWorstVDS(relevantHosts, parameters);
    if (getOccupiedVMSLots(worstVDS, parameters) < highVmCountUtilization) {
        log.debugFormat("No host is overutilized, the worst is {1} with {2} occupied VM slots", worstVDS.getName(), getOccupiedVMSLots(worstVDS, parameters));
        return null;
    }
    return LinqUtils.filter(relevantHosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return getOccupiedVMSLots(p, parameters) >= getOccupiedVMSLots(worstVDS, parameters);
        }
    });
}
#method_after
@Override
protected List<VDS> getOverUtilizedHosts(List<VDS> relevantHosts, final Map<String, String> parameters) {
    final int highVmCountUtilization = NumberUtils.toInt(parameters.get("HighVmCount"), highVmCountDefault);
    final VDS worstVDS = getWorstVDS(relevantHosts, parameters);
    final int worstVdsOccupiedVmSlots = getOccupiedVmSlots(worstVDS, parameters);
    if (worstVdsOccupiedVmSlots < highVmCountUtilization) {
        log.infoFormat("There is no host with more than {0} running guests, no balancing is needed", highVmCountUtilization);
        return null;
    }
    return LinqUtils.filter(relevantHosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return getOccupiedVmSlots(p, parameters) >= worstVdsOccupiedVmSlots;
        }
    });
}
#end_block

#method_before
@Override
protected List<VDS> getUnderUtilizedHosts(VDSGroup cluster, List<VDS> relevantHosts, final Map<String, String> parameters) {
    final int migrationThreshold = tryParseWithDefault(parameters.get("MigrationThreshold"), getMigrationThresholdDefault());
    final VDS worstVDS = getWorstVDS(relevantHosts, parameters);
    return LinqUtils.filter(relevantHosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            int distance = getOccupiedVMSLots(worstVDS, parameters) - getOccupiedVMSLots(p, parameters);
            return distance < migrationThreshold;
        }
    });
}
#method_after
@Override
protected List<VDS> getUnderUtilizedHosts(VDSGroup cluster, List<VDS> relevantHosts, final Map<String, String> parameters) {
    final int migrationThreshold = NumberUtils.toInt(parameters.get("MigrationThreshold"), migrationThresholdDefault);
    final VDS worstVDS = getWorstVDS(relevantHosts, parameters);
    final int worstVdsOccupiedVmSlots = getOccupiedVmSlots(worstVDS, parameters);
    List<VDS> underUtilizedHosts = LinqUtils.filter(relevantHosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            int distance = worstVdsOccupiedVmSlots - getOccupiedVmSlots(p, parameters);
            return distance >= migrationThreshold;
        }
    });
    if (underUtilizedHosts.size() == 0) {
        log.warnFormat("There is no host with less than {0} running guests", worstVdsOccupiedVmSlots - migrationThreshold);
    }
    return underUtilizedHosts;
}
#end_block

#method_before
public static PolicyUnitImpl getPolicyUnitImpl(PolicyUnit policyUnit) {
    switch(policyUnit.getName()) {
        case "PinToHost":
            return new PinToHostPolicyUnit(policyUnit);
        case "CPU":
            return new CPUPolicyUnit(policyUnit);
        case "Memory":
            return new MemoryPolicyUnit(policyUnit);
        case "Network":
            return new NetworkPolicyUnit(policyUnit);
        case "HA":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new HostedEngineHAClusterWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.Filter) {
                return new HostedEngineHAClusterFilterPolicyUnit(policyUnit);
            }
        case "CPU-Level":
            return new CpuLevelFilterPolicyUnit(policyUnit);
        case "None":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new NoneWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new NoneBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForPowerSaving":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new PowerSavingWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new PowerSavingBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForEvenDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new EvenDistributionWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new EvenDistributionBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForEvenGuestDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new EvenGuestDistributionWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new EvenGuestDistributionBalancePolicyUnit(policyUnit);
            }
            break;
        default:
            break;
    }
    throw new NotImplementedException("policyUnit: " + policyUnit.getName());
}
#method_after
public static PolicyUnitImpl getPolicyUnitImpl(PolicyUnit policyUnit) {
    switch(policyUnit.getName()) {
        case "PinToHost":
            return new PinToHostPolicyUnit(policyUnit);
        case "CPU":
            return new CPUPolicyUnit(policyUnit);
        case "Memory":
            return new MemoryPolicyUnit(policyUnit);
        case "Network":
            return new NetworkPolicyUnit(policyUnit);
        case "HA":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new HostedEngineHAClusterWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.Filter) {
                return new HostedEngineHAClusterFilterPolicyUnit(policyUnit);
            }
        case "OptimalForHaReservation":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new HaReservationWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new HaReservationBalancePolicyUnit(policyUnit);
            }
            break;
        case "CPU-Level":
            return new CpuLevelFilterPolicyUnit(policyUnit);
        case "None":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new NoneWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new NoneBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForPowerSaving":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new PowerSavingWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new PowerSavingBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForEvenDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new EvenDistributionWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new EvenDistributionBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForEvenGuestDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new EvenGuestDistributionWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new EvenGuestDistributionBalancePolicyUnit(policyUnit);
            }
            break;
        default:
            break;
    }
    throw new NotImplementedException("policyUnit: " + policyUnit.getName());
}
#end_block

#method_before
private int calcEvenGuestDistributionScore(VDS vds) {
    return Math.max(0, vds.getVmCount());
}
#method_after
private int calcEvenGuestDistributionScore(VDS vds, Map<String, String> parameters) {
    return Math.max(0, getOccupiedVmSlots(vds, parameters));
}
#end_block

#method_before
@Override
public List<Pair<Guid, Integer>> score(List<VDS> hosts, VM vm, Map<String, String> parameters) {
    VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(hosts.get(0).getVdsGroupId());
    List<Pair<Guid, Integer>> scores = new ArrayList<Pair<Guid, Integer>>();
    for (VDS vds : hosts) {
        scores.add(new Pair<Guid, Integer>(vds.getId(), calcEvenGuestDistributionScore(vds)));
    }
    return scores;
}
#method_after
@Override
public List<Pair<Guid, Integer>> score(List<VDS> hosts, VM vm, Map<String, String> parameters) {
    List<Pair<Guid, Integer>> scores = new ArrayList<Pair<Guid, Integer>>();
    for (VDS vds : hosts) {
        scores.add(new Pair<Guid, Integer>(vds.getId(), calcEvenGuestDistributionScore(vds, parameters)));
    }
    return scores;
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getTemplate().setIsChangable(false);
    getModel().getVmType().setIsChangable(true);
    getModel().getCopyPermissions().setIsAvailable(true);
    DisksAllocationModel disksAllocationModel = getModel().getDisksAllocationModel();
    disksAllocationModel.setIsAliasChangable(true);
    AsyncDataProvider.getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final StoragePool dataCenter = (StoragePool) returnValue;
            if (dataCenter == null) {
                disableNewTemplateModel(ConstantsManager.getInstance().getConstants().dataCenterIsNotAccessibleMsg());
            } else {
                AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
                        model.setDataCentersAndClusters(model, Arrays.asList(dataCenter), clusters, vm.getVdsGroupId());
                        initTemplate();
                    }
                }, getModel().getHash()), true, false);
                AsyncDataProvider.isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                    }
                }, getModel().getHash()), vm.getId());
            }
        }
    }, getModel().getHash()), vm.getStoragePoolId());
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getTemplate().setIsChangable(false);
    getModel().getVmType().setIsChangable(true);
    getModel().getCopyPermissions().setIsAvailable(true);
    DisksAllocationModel disksAllocationModel = getModel().getDisksAllocationModel();
    disksAllocationModel.setIsAliasChangable(true);
    AsyncDataProvider.getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final StoragePool dataCenter = (StoragePool) returnValue;
            if (dataCenter == null) {
                disableNewTemplateModel(ConstantsManager.getInstance().getConstants().dataCenterIsNotAccessibleMsg());
            } else {
                AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
                        List<VDSGroup> filteredClusters = AsyncDataProvider.filterByArchitecture(clusters, vm.getClusterArch());
                        model.setDataCentersAndClusters(model, Arrays.asList(dataCenter), filteredClusters, vm.getVdsGroupId());
                        initTemplate();
                    }
                }, getModel().getHash()), true, false);
                AsyncDataProvider.isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                    }
                }, getModel().getHash()), vm.getId());
            }
        }
    }, getModel().getHash()), vm.getStoragePoolId());
}
#end_block

#method_before
@Override
public void setItems(Iterable value) {
    consoleModelsCache.updateCache(value);
    super.setItems(value);
}
#method_after
@Override
public void setItems(Iterable value) {
    consoleModelsCache.updateVmCache(value);
    super.setItems(value);
}
#end_block

#method_before
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForVm(((VM) getSelectedItem()));
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForEntity(getSelectedItem());
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void createSnapshot() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.setValidateByVmSnapshots(true);
    model.initialize();
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    // $NON-NLS-1$
    UICommand closeCommand = new UICommand("Cancel", this);
    closeCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.setCloseCommand(closeCommand);
}
#method_after
private void createSnapshot() {
    VM vm = (VM) getSelectedItem();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.setValidateByVmSnapshots(true);
    model.initialize();
    model.getCommands().add(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
}
#end_block

#method_before
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.PropertyName.equals("status")) {
        // $NON-NLS-1$
        updateActionAvailability();
    }
}
#method_after
@Override
protected void selectedItemPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.selectedItemPropertyChanged(sender, e);
    if (e.propertyName.equals("status")) {
        // $NON-NLS-1$
        updateActionAvailability();
    }
}
#end_block

#method_before
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consoleModelsCache.getVmConsolesForVm(vm).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consoleModelsCache.getVmConsolesForEntity(vm).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ChangeCDModel.ExecutedEventDefinition)) {
        changeCD(sender, args);
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ChangeCDModel.executedEventDefinition)) {
        changeCD(sender, args);
    }
}
#end_block

#method_before
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consoleModelsCache.getVmConsolesForVm(vm).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#method_after
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consoleModelsCache.getVmConsolesForEntity(vm).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.setVncKeyboardLayout(instance.getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    return vm;
}
#end_block

#method_before
private static NetworkCluster cloneNetworkCluster(NetworkCluster instance) {
    NetworkCluster obj = new NetworkCluster();
    obj.setStatus(instance.getStatus());
    obj.setDisplay(instance.isDisplay());
    obj.setRequired(instance.isRequired());
    obj.setMigration(instance.isMigration());
    return obj;
}
#method_after
private static NetworkCluster cloneNetworkCluster(NetworkCluster instance) {
    NetworkCluster obj = new NetworkCluster();
    obj.setId(instance.getId());
    obj.setStatus(instance.getStatus());
    obj.setDisplay(instance.isDisplay());
    obj.setRequired(instance.isRequired());
    obj.setMigration(instance.isMigration());
    return obj;
}
#end_block

#method_before
@Override
public void setItems(Iterable value) {
    if (items != value) {
        itemsChanging(value, items);
        items = value;
        getItemsChangedEvent().raise(this, EventArgs.Empty);
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("Items"));
        UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
        if (items != null && selectedItem != null) {
            for (Object object : items) {
                UserPortalItemModel itemModel = (UserPortalItemModel) object;
                if (itemModel.getEntity().equals(selectedItem.getEntity())) {
                    this.selectedItem = itemModel;
                    break;
                }
            }
        }
        onSelectedItemChanged();
    }
}
#method_after
@Override
public void setItems(Iterable value) {
    if (items != value) {
        itemsChanging(value, items);
        items = value;
        getItemsChangedEvent().raise(this, EventArgs.EMPTY);
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("Items"));
        UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
        if (items != null && selectedItem != null) {
            for (Object object : items) {
                UserPortalItemModel itemModel = (UserPortalItemModel) object;
                if (itemModel.getEntity().equals(selectedItem.getEntity())) {
                    this.selectedItem = itemModel;
                    break;
                }
            }
        }
        onSelectedItemChanged();
    }
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    UnitVmModel model = (UnitVmModel) getWindow();
    if (ev.matchesDefinition(ItemsChangedEventDefinition) && sender == model.getDataCenterWithClustersList()) {
        updateDataCenterWithCluster();
    } else if (ev.matchesDefinition(ItemsChangedEventDefinition) && sender == model.getDefaultHost()) {
        vmModel_DefaultHost_ItemsChanged();
    } else if (ev.matchesDefinition(ItemsChangedEventDefinition) && sender == model.getDisplayProtocol()) {
        vmModel_DisplayProtocol_ItemsChanged();
    } else if (ev.matchesDefinition(ItemsChangedEventDefinition) && sender == model.getPriority()) {
        vmModel_Priority_ItemsChanged();
    } else if (ev.matchesDefinition(ItemsChangedEventDefinition) && sender == model.getTimeZone()) {
        vmModel_TimeZone_ItemsChanged();
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    UnitVmModel model = (UnitVmModel) getWindow();
    if (ev.matchesDefinition(itemsChangedEventDefinition) && sender == model.getDataCenterWithClustersList()) {
        updateDataCenterWithCluster();
    } else if (ev.matchesDefinition(itemsChangedEventDefinition) && sender == model.getDefaultHost()) {
        vmModel_DefaultHost_ItemsChanged();
    } else if (ev.matchesDefinition(itemsChangedEventDefinition) && sender == model.getDisplayProtocol()) {
        vmModel_DisplayProtocol_ItemsChanged();
    } else if (ev.matchesDefinition(itemsChangedEventDefinition) && sender == model.getPriority()) {
        vmModel_Priority_ItemsChanged();
    } else if (ev.matchesDefinition(itemsChangedEventDefinition) && sender == model.getTimeZone()) {
        vmModel_TimeZone_ItemsChanged();
    }
}
#end_block

#method_before
@Override
public void onVmAndPoolLoad() {
    if (getvms() != null && getpools() != null) {
        // Complete search.
        // Remove pools that has provided VMs.
        ArrayList<VmPool> filteredPools = new ArrayList<VmPool>();
        poolMap = new HashMap<Guid, VmPool>();
        for (VmPool pool : getpools()) {
            // Add pool to map.
            poolMap.put(pool.getVmPoolId(), pool);
            int attachedVmsCount = 0;
            for (VM vm : getvms()) {
                if (vm.getVmPoolId() != null && vm.getVmPoolId().equals(pool.getVmPoolId())) {
                    attachedVmsCount++;
                }
            }
            if (attachedVmsCount < pool.getMaxAssignedVmsPerUser()) {
                filteredPools.add(pool);
            }
        }
        // Merge VMs and Pools, and create item models.
        List all = Linq.concat(getvms(), filteredPools);
        Collections.sort(all, new NameableComparator());
        consoleModelsCache.updateCache(filterVms(all));
        ArrayList<Model> items = new ArrayList<Model>();
        for (Object item : all) {
            VmConsoles consoles = null;
            if (item instanceof VM) {
                consoles = consoleModelsCache.getVmConsolesForVm((VM) item);
            }
            UserPortalItemModel model = new UserPortalItemModel(item, consoles);
            model.setEntity(item);
            items.add(model);
        }
        setItems(items);
        setCanConnectAutomatically(getAutoConnectableConsoles().size() == 1);
        setvms(null);
        setpools(null);
        getSearchCompletedEvent().raise(this, EventArgs.Empty);
    }
}
#method_after
@Override
public void onVmAndPoolLoad() {
    if (getvms() != null && getpools() != null) {
        // Complete search.
        // Remove pools that has provided VMs.
        ArrayList<VmPool> filteredPools = new ArrayList<VmPool>();
        for (VmPool pool : getpools()) {
            // Add pool to map.
            int attachedVmsCount = 0;
            for (VM vm : getvms()) {
                if (vm.getVmPoolId() != null && vm.getVmPoolId().equals(pool.getVmPoolId())) {
                    attachedVmsCount++;
                }
            }
            if (attachedVmsCount < pool.getMaxAssignedVmsPerUser()) {
                filteredPools.add(pool);
            }
        }
        // Merge VMs and Pools, and create item models.
        final List all = Linq.concat(getvms(), filteredPools);
        List<VdcQueryType> poolQueryList = new ArrayList<VdcQueryType>();
        List<VdcQueryParametersBase> poolParamList = new ArrayList<VdcQueryParametersBase>();
        for (VmPool p : filteredPools) {
            poolQueryList.add(VdcQueryType.GetVmDataByPoolId);
            poolParamList.add(new IdQueryParameters(p.getVmPoolId()));
        }
        Frontend.getInstance().runMultipleQueries(poolQueryList, poolParamList, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                List<VM> vmsOfPools = new LinkedList<VM>();
                List<VdcQueryReturnValue> poolRepresentants = result.getReturnValues();
                for (VdcQueryReturnValue poolRepresentant : poolRepresentants) {
                    vmsOfPools.add((VM) poolRepresentant.getReturnValue());
                }
                consoleModelsCache.updateVmCache(getvms());
                consoleModelsCache.updatePoolCache(vmsOfPools);
                Collections.sort(all, new NameableComparator());
                ArrayList<Model> items = new ArrayList<Model>();
                for (Object item : all) {
                    VmConsoles consoles = consoleModelsCache.getVmConsolesForEntity(item);
                    UserPortalItemModel model = new UserPortalItemModel(item, consoles);
                    model.setEntity(item);
                    items.add(model);
                }
                setItems(items);
                setvms(null);
                setpools(null);
                getSearchCompletedEvent().raise(this, EventArgs.EMPTY);
            }
        });
    }
}
#end_block

#method_before
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    createInfo.put(VdsProperties.emulatedMachine, DbFacade.getInstance().getVdsGroupDao().get(vm.getVdsGroupId()).getEmulatedMachine());
    // enabled.
    if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
        createInfo.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
        createInfo.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getVdsGroupCpuFlagsData() != null) {
        createInfo.put(VdsProperties.cpuType, vm.getVdsGroupCpuFlagsData());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    String keyboardLayout = vm.getVncKeyboardLayout();
    if (keyboardLayout == null) {
        keyboardLayout = vm.getDefaultVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
        }
    }
    createInfo.put(VdsProperties.KeyboardLayout, keyboardLayout);
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getDisplayType() == DisplayType.vnc) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
}
#method_after
protected void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (Config.<Boolean>getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    createInfo.put(VdsProperties.emulatedMachine, DbFacade.getInstance().getVdsGroupDao().get(vm.getVdsGroupId()).getEmulatedMachine());
    // enabled.
    if (Config.<Boolean>getValue(ConfigValues.SSLEnabled)) {
        createInfo.put(VdsProperties.spiceSslCipherSuite, Config.<String>getValue(ConfigValues.CipherSuite));
        createInfo.put(VdsProperties.SpiceSecureChannels, Config.<String>getValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getVdsGroupCpuFlagsData() != null) {
        createInfo.put(VdsProperties.cpuType, vm.getVdsGroupCpuFlagsData());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
    if (keyboardLayout == null) {
        keyboardLayout = vm.getDefaultVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = Config.<String>getValue(ConfigValues.VncKeyboardLayout);
        }
    }
    createInfo.put(VdsProperties.KeyboardLayout, keyboardLayout);
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getDisplayType() == DisplayType.vnc) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
}
#end_block

#method_before
protected void initClusters(final List<StoragePool> dataCenters) {
    AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            model.setDataCentersAndClusters(model, dataCenters, (List<VDSGroup>) returnValue, vm.getVdsGroupId());
            initTemplate();
            initCdImage();
            initSoundCard(vm.getId());
        }
    }, getModel().getHash()), true, false);
}
#method_after
protected void initClusters(final List<StoragePool> dataCenters) {
    AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
            List<VDSGroup> filteredClusters = AsyncDataProvider.filterByArchitecture(clusters, vm.getClusterArch());
            model.setDataCentersAndClusters(model, dataCenters, filteredClusters, vm.getVdsGroupId());
            initTemplate();
            initCdImage();
            initSoundCard(vm.getId());
        }
    }, getModel().getHash()), true, false);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((acpiEnabled == null) ? 0 : acpiEnabled.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + bootSequence.hashCode();
    result = prime * result + ((clientIp == null) ? 0 : clientIp.hashCode());
    result = prime * result + ((display == null) ? 0 : display.hashCode());
    result = prime * result + ((displayIp == null) ? 0 : displayIp.hashCode());
    result = prime * result + ((displaySecurePort == null) ? 0 : displaySecurePort.hashCode());
    result = prime * result + displayType.hashCode();
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((consoleCurUserName == null) ? 0 : consoleCurUserName.hashCode());
    result = prime * result + ((guestCurUserName == null) ? 0 : guestCurUserName.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guestLastLoginTime == null) ? 0 : guestLastLoginTime.hashCode());
    result = prime * result + ((guestLastLogoutTime == null) ? 0 : guestLastLogoutTime.hashCode());
    result = prime * result + ((guestOs == null) ? 0 : guestOs.hashCode());
    result = prime * result + ((guestRequestedMemory == null) ? 0 : guestRequestedMemory.hashCode());
    result = prime * result + ((hibernationVolHandle == null) ? 0 : hibernationVolHandle.hashCode());
    result = prime * result + ((kvmEnable == null) ? 0 : kvmEnable.hashCode());
    result = prime * result + ((lastVdsRunOn == null) ? 0 : lastVdsRunOn.hashCode());
    result = prime * result + ((disks == null) ? 0 : disks.hashCode());
    result = prime * result + ((mExitMessage == null) ? 0 : mExitMessage.hashCode());
    result = prime * result + exitStatus.hashCode();
    result = prime * result + (win2kHackEnabled ? 1231 : 1237);
    result = prime * result + ((migratingToVds == null) ? 0 : migratingToVds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((runOnVds == null) ? 0 : runOnVds.hashCode());
    result = prime * result + session.hashCode();
    result = prime * result + status.hashCode();
    result = prime * result + ((utcDiff == null) ? 0 : utcDiff.hashCode());
    result = prime * result + ((vmHost == null) ? 0 : vmHost.hashCode());
    result = prime * result + ((vmIp == null) ? 0 : vmIp.hashCode());
    result = prime * result + ((vmFQDN == null) ? 0 : vmFQDN.hashCode());
    result = prime * result + ((lastStartTime == null) ? 0 : lastStartTime.hashCode());
    result = prime * result + ((vmPid == null) ? 0 : vmPid.hashCode());
    result = prime * result + (lastWatchdogEvent == null ? 0 : lastWatchdogEvent.hashCode());
    result = prime * result + (lastWatchdogAction == null ? 0 : lastWatchdogAction.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((acpiEnabled == null) ? 0 : acpiEnabled.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + bootSequence.hashCode();
    result = prime * result + ((clientIp == null) ? 0 : clientIp.hashCode());
    result = prime * result + ((display == null) ? 0 : display.hashCode());
    result = prime * result + ((displayIp == null) ? 0 : displayIp.hashCode());
    result = prime * result + ((displaySecurePort == null) ? 0 : displaySecurePort.hashCode());
    result = prime * result + displayType.hashCode();
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((consoleCurUserName == null) ? 0 : consoleCurUserName.hashCode());
    result = prime * result + ((guestCurUserName == null) ? 0 : guestCurUserName.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guestLastLoginTime == null) ? 0 : guestLastLoginTime.hashCode());
    result = prime * result + ((guestLastLogoutTime == null) ? 0 : guestLastLogoutTime.hashCode());
    result = prime * result + ((guestOs == null) ? 0 : guestOs.hashCode());
    result = prime * result + ((guestRequestedMemory == null) ? 0 : guestRequestedMemory.hashCode());
    result = prime * result + ((hibernationVolHandle == null) ? 0 : hibernationVolHandle.hashCode());
    result = prime * result + ((kvmEnable == null) ? 0 : kvmEnable.hashCode());
    result = prime * result + ((lastVdsRunOn == null) ? 0 : lastVdsRunOn.hashCode());
    result = prime * result + ((disks == null) ? 0 : disks.hashCode());
    result = prime * result + ((mExitMessage == null) ? 0 : mExitMessage.hashCode());
    result = prime * result + exitStatus.hashCode();
    result = prime * result + (win2kHackEnabled ? 1231 : 1237);
    result = prime * result + ((migratingToVds == null) ? 0 : migratingToVds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((runOnVds == null) ? 0 : runOnVds.hashCode());
    result = prime * result + session.hashCode();
    result = prime * result + status.hashCode();
    result = prime * result + ((utcDiff == null) ? 0 : utcDiff.hashCode());
    result = prime * result + ((vmHost == null) ? 0 : vmHost.hashCode());
    result = prime * result + ((vmIp == null) ? 0 : vmIp.hashCode());
    result = prime * result + ((vmFQDN == null) ? 0 : vmFQDN.hashCode());
    result = prime * result + ((lastStartTime == null) ? 0 : lastStartTime.hashCode());
    result = prime * result + ((lastStopTime == null) ? 0 : lastStopTime.hashCode());
    result = prime * result + ((vmPid == null) ? 0 : vmPid.hashCode());
    result = prime * result + (lastWatchdogEvent == null ? 0 : lastWatchdogEvent.hashCode());
    result = prime * result + (lastWatchdogAction == null ? 0 : lastWatchdogAction.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(acpiEnabled, other.acpiEnabled) && ObjectUtils.objectsEqual(appList, other.appList) && bootSequence == other.bootSequence && ObjectUtils.objectsEqual(clientIp, other.clientIp) && ObjectUtils.objectsEqual(display, other.display) && ObjectUtils.objectsEqual(displayIp, other.displayIp) && ObjectUtils.objectsEqual(displaySecurePort, other.displaySecurePort) && displayType == other.displayType && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(consoleCurUserName, other.consoleCurUserName) && ObjectUtils.objectsEqual(guestCurUserName, other.guestCurUserName) && ObjectUtils.objectsEqual(consoleUserId, other.consoleUserId) && ObjectUtils.objectsEqual(guestLastLoginTime, other.guestLastLoginTime) && ObjectUtils.objectsEqual(guestLastLogoutTime, other.guestLastLogoutTime) && ObjectUtils.objectsEqual(guestOs, other.guestOs) && ObjectUtils.objectsEqual(guestRequestedMemory, other.guestRequestedMemory) && ObjectUtils.objectsEqual(hibernationVolHandle, other.hibernationVolHandle) && ObjectUtils.objectsEqual(kvmEnable, other.kvmEnable) && ObjectUtils.objectsEqual(lastVdsRunOn, other.lastVdsRunOn) && ObjectUtils.objectsEqual(disks, other.disks) && ObjectUtils.objectsEqual(mExitMessage, other.mExitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && ObjectUtils.objectsEqual(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && ObjectUtils.objectsEqual(runOnVds, other.runOnVds) && session == other.session && status == other.status && ObjectUtils.objectsEqual(utcDiff, other.utcDiff) && ObjectUtils.objectsEqual(vmHost, other.vmHost) && ObjectUtils.objectsEqual(vmIp, other.vmIp) && ObjectUtils.objectsEqual(vmFQDN, other.vmFQDN) && ObjectUtils.objectsEqual(lastStartTime, other.lastStartTime) && ObjectUtils.objectsEqual(vmPid, other.vmPid) && ObjectUtils.objectsEqual(lastWatchdogEvent, other.lastWatchdogEvent) && ObjectUtils.objectsEqual(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && ObjectUtils.objectsEqual(cpuName, other.cpuName));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(acpiEnabled, other.acpiEnabled) && ObjectUtils.objectsEqual(appList, other.appList) && bootSequence == other.bootSequence && ObjectUtils.objectsEqual(clientIp, other.clientIp) && ObjectUtils.objectsEqual(display, other.display) && ObjectUtils.objectsEqual(displayIp, other.displayIp) && ObjectUtils.objectsEqual(displaySecurePort, other.displaySecurePort) && displayType == other.displayType && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(consoleCurUserName, other.consoleCurUserName) && ObjectUtils.objectsEqual(guestCurUserName, other.guestCurUserName) && ObjectUtils.objectsEqual(consoleUserId, other.consoleUserId) && ObjectUtils.objectsEqual(guestLastLoginTime, other.guestLastLoginTime) && ObjectUtils.objectsEqual(guestLastLogoutTime, other.guestLastLogoutTime) && ObjectUtils.objectsEqual(guestOs, other.guestOs) && ObjectUtils.objectsEqual(guestRequestedMemory, other.guestRequestedMemory) && ObjectUtils.objectsEqual(hibernationVolHandle, other.hibernationVolHandle) && ObjectUtils.objectsEqual(kvmEnable, other.kvmEnable) && ObjectUtils.objectsEqual(lastVdsRunOn, other.lastVdsRunOn) && ObjectUtils.objectsEqual(disks, other.disks) && ObjectUtils.objectsEqual(mExitMessage, other.mExitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && ObjectUtils.objectsEqual(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && ObjectUtils.objectsEqual(runOnVds, other.runOnVds) && session == other.session && status == other.status && ObjectUtils.objectsEqual(utcDiff, other.utcDiff) && ObjectUtils.objectsEqual(vmHost, other.vmHost) && ObjectUtils.objectsEqual(vmIp, other.vmIp) && ObjectUtils.objectsEqual(vmFQDN, other.vmFQDN) && ObjectUtils.objectsEqual(lastStartTime, other.lastStartTime) && ObjectUtils.objectsEqual(lastStopTime, other.lastStopTime) && ObjectUtils.objectsEqual(vmPid, other.vmPid) && ObjectUtils.objectsEqual(lastWatchdogEvent, other.lastWatchdogEvent) && ObjectUtils.objectsEqual(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && ObjectUtils.objectsEqual(cpuName, other.cpuName));
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    return model;
}
#end_block

#method_before
@Mapping(from = VM.class, to = RunVmOnceParams.class)
public static RunVmOnceParams map(VM vm, RunVmOnceParams template) {
    RunVmOnceParams params = template != null ? template : new RunVmOnceParams();
    if (vm.isSetStateless() && vm.isStateless()) {
        params.setRunAsStateless(true);
    }
    if (vm.isSetDisplay() && vm.getDisplay().isSetType()) {
        DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
        if (displayType != null) {
            params.setUseVnc(displayType == DisplayType.VNC);
        }
    }
    if (vm.isSetDisplay() && vm.getDisplay().isSetKeyboardLayout()) {
        String vncKeyboardLayout = vm.getDisplay().getKeyboardLayout();
        if (vncKeyboardLayout != null) {
            params.setVncKeyboardLayout(vncKeyboardLayout);
        }
    }
    if (vm.isSetOs() && vm.getOs().getBoot().size() > 0) {
        params.setBootSequence(map(vm.getOs().getBoot(), null));
    }
    if (vm.isSetCdroms() && vm.getCdroms().isSetCdRoms()) {
        String file = vm.getCdroms().getCdRoms().get(0).getFile().getId();
        if (file != null) {
            params.setDiskPath(file);
        }
    }
    if (vm.isSetFloppies() && vm.getFloppies().isSetFloppies()) {
        String file = vm.getFloppies().getFloppies().get(0).getFile().getId();
        if (file != null) {
            params.setFloppyPath(file);
        }
    }
    if (vm.isSetCustomProperties()) {
        params.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            params.setBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            params.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            params.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            params.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        params.setSysPrepDomainName(vm.getDomain().getName());
        if (vm.getDomain().isSetUser()) {
            if (vm.getDomain().getUser().isSetUserName()) {
                params.setSysPrepUserName(vm.getDomain().getUser().getUserName());
            }
            if (vm.getDomain().getUser().isSetPassword()) {
                params.setSysPrepPassword(vm.getDomain().getUser().getPassword());
            }
        }
    }
    if (vm.isSetCpuShares()) {
        params.setCpuShares(vm.getCpuShares());
    }
    return params;
}
#method_after
@Mapping(from = VM.class, to = RunVmOnceParams.class)
public static RunVmOnceParams map(VM vm, RunVmOnceParams template) {
    RunVmOnceParams params = template != null ? template : new RunVmOnceParams();
    if (vm.isSetStateless() && vm.isStateless()) {
        params.setRunAsStateless(true);
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                params.setUseVnc(displayType == DisplayType.VNC);
            }
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String vncKeyboardLayout = vm.getDisplay().getKeyboardLayout();
            params.setVncKeyboardLayout(vncKeyboardLayout);
        }
    }
    if (vm.isSetOs() && vm.getOs().getBoot().size() > 0) {
        params.setBootSequence(map(vm.getOs().getBoot(), null));
    }
    if (vm.isSetCdroms() && vm.getCdroms().isSetCdRoms()) {
        String file = vm.getCdroms().getCdRoms().get(0).getFile().getId();
        if (file != null) {
            params.setDiskPath(file);
        }
    }
    if (vm.isSetFloppies() && vm.getFloppies().isSetFloppies()) {
        String file = vm.getFloppies().getFloppies().get(0).getFile().getId();
        if (file != null) {
            params.setFloppyPath(file);
        }
    }
    if (vm.isSetCustomProperties()) {
        params.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            params.setBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            params.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            params.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            params.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        params.setSysPrepDomainName(vm.getDomain().getName());
        if (vm.getDomain().isSetUser()) {
            if (vm.getDomain().getUser().isSetUserName()) {
                params.setSysPrepUserName(vm.getDomain().getUser().getUserName());
            }
            if (vm.getDomain().getUser().isSetPassword()) {
                params.setSysPrepPassword(vm.getDomain().getUser().getPassword());
            }
        }
    }
    if (vm.isSetCpuShares()) {
        params.setCpuShares(vm.getCpuShares());
    }
    return params;
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getIsoImage()) {
            IsoImage_SelectedItemChanged();
        } else if (sender == getFloppyImage()) {
            floppyImage_SelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getAttachFloppy()) {
            attachFloppy_EntityChanged();
        } else if (sender == getAttachIso()) {
            attachIso_EntityChanged();
        } else if (sender == getIsVmFirstRun()) {
            isVmFirstRun_EntityChanged();
        } else if (sender == getUseAlternateCredentials()) {
            useAlternateCredentials_EntityChanged();
        } else if (sender == getDisplayConsole_Vnc_IsSelected() && (Boolean) ((EntityModel) sender).getEntity()) {
            getDisplayConsole_Spice_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(true);
        } else if (sender == getDisplayConsole_Spice_IsSelected() && (Boolean) ((EntityModel) sender).getEntity()) {
            getDisplayConsole_Vnc_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(false);
        } else if (sender == getIsAutoAssign()) {
            isAutoAssign_EntityChanged(sender, args);
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getIsoImage()) {
            IsoImage_SelectedItemChanged();
        } else if (sender == getFloppyImage()) {
            floppyImage_SelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getAttachFloppy()) {
            attachFloppy_EntityChanged();
        } else if (sender == getAttachIso()) {
            attachIso_EntityChanged();
        } else if (sender == getIsVmFirstRun()) {
            isVmFirstRun_EntityChanged();
        } else if (sender == getUseAlternateCredentials()) {
            useAlternateCredentials_EntityChanged();
        } else if (sender == getDisplayConsole_Vnc_IsSelected() && (Boolean) ((EntityModel) sender).getEntity()) {
            getDisplayConsole_Spice_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(true);
        } else if (sender == getDisplayConsole_Spice_IsSelected() && (Boolean) ((EntityModel) sender).getEntity()) {
            getDisplayConsole_Vnc_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(false);
        } else if (sender == getIsAutoAssign()) {
            isAutoAssign_EntityChanged(sender, args);
        }
    }
}
#end_block

#method_before
private void initVncKeyboardLayout() {
    final List<String> layouts = (List<String>) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayoutValidValues);
    final ArrayList<String> vncKeyboardLayoutItems = new ArrayList<String>();
    vncKeyboardLayoutItems.add(null);
    vncKeyboardLayoutItems.addAll(layouts);
    getVncKeyboardLayout().setItems(vncKeyboardLayoutItems);
    getVncKeyboardLayout().setIsChangable(false);
}
#method_after
private void initVncKeyboardLayout() {
    List<String> layouts = (List<String>) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayoutValidValues);
    List<String> vncKeyboardLayoutItems = new ArrayList<String>();
    vncKeyboardLayoutItems.add(null);
    vncKeyboardLayoutItems.addAll(layouts);
    getVncKeyboardLayout().setItems(vncKeyboardLayoutItems);
    getVncKeyboardLayout().setIsChangable(false);
}
#end_block

#method_before
void initListBoxEditors() {
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new AbstractRenderer<String>() {

        final String globalLayout = (String) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayout);

        @Override
        public String render(String object) {
            if (object == null) {
                return messages.globalVncKeyboardLayoutCaption(globalLayout);
            } else {
                return object;
            }
        }
    });
}
#method_after
void initListBoxEditors() {
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages));
}
#end_block

#method_before
@Override
public void edit(final RunOnceModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    runOnceModel = object;
    // Update Linux options panel
    final EntityModel isLinuxOptionsAvailable = object.getIsLinuxOptionsAvailable();
    object.getIsLinuxOptionsAvailable().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isLinux = (Boolean) isLinuxOptionsAvailable.getEntity();
            linuxBootOptionsPanel.setVisible(isLinux);
        }
    });
    object.getIsCloudInitEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean selected = (Boolean) object.getIsCloudInitEnabled().getEntity();
            cloudInitWidget.setVisible(selected);
        }
    });
    object.getIsSysprepEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean selected = (Boolean) object.getIsSysprepEnabled().getEntity();
            sysprepOptions.setVisible(selected);
            sysprepToEnableLabel.setVisible(!selected);
        }
    });
    object.getIsCloudInitPossible().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cloudInitSubPanel.setVisible((Boolean) object.getIsCloudInitPossible().getEntity());
            initialRunPanel.setVisible(cloudInitSubPanel.isVisible() || sysprepSubPanel.isVisible());
        }
    });
    object.getIsSysprepPossible().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            sysprepSubPanel.setVisible((Boolean) object.getIsSysprepPossible().getEntity());
            initialRunPanel.setVisible(cloudInitSubPanel.isVisible() || sysprepSubPanel.isVisible());
        }
    });
    // Update Host combo
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = (Boolean) object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to
            // listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    object.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsHostTabVisible".equals(propName)) {
                // $NON-NLS-1$
                hostPanel.setVisible(object.getIsHostTabVisible());
            } else if ("IsCustomPropertiesSheetVisible".equals(propName)) {
                // $NON-NLS-1$
                customPropertiesPanel.setVisible(object.getIsCustomPropertiesSheetVisible());
            }
        }
    });
    // Update BootSequence ListBox
    bootSequenceModel = object.getBootSequence();
    UpdateBootSequenceListBox();
    cloudInitWidget.edit(object.getCloudInit());
}
#method_after
@Override
public void edit(final RunOnceModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    runOnceModel = object;
    // Update Linux options panel
    final EntityModel isLinuxOptionsAvailable = object.getIsLinuxOptionsAvailable();
    object.getIsLinuxOptionsAvailable().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isLinux = (Boolean) isLinuxOptionsAvailable.getEntity();
            linuxBootOptionsPanel.setVisible(isLinux);
        }
    });
    object.getIsCloudInitEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean selected = (Boolean) object.getIsCloudInitEnabled().getEntity();
            cloudInitWidget.setVisible(selected);
        }
    });
    object.getIsSysprepEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean selected = (Boolean) object.getIsSysprepEnabled().getEntity();
            sysprepOptions.setVisible(selected);
            sysprepToEnableLabel.setVisible(!selected);
        }
    });
    object.getIsCloudInitPossible().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cloudInitSubPanel.setVisible((Boolean) object.getIsCloudInitPossible().getEntity());
            initialRunPanel.setVisible(cloudInitSubPanel.isVisible() || sysprepSubPanel.isVisible());
        }
    });
    object.getIsSysprepPossible().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            sysprepSubPanel.setVisible((Boolean) object.getIsSysprepPossible().getEntity());
            initialRunPanel.setVisible(cloudInitSubPanel.isVisible() || sysprepSubPanel.isVisible());
        }
    });
    // Update Host combo
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = (Boolean) object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to
            // listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    object.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsHostTabVisible".equals(propName)) {
                // $NON-NLS-1$
                hostPanel.setVisible(object.getIsHostTabVisible());
            } else if ("IsCustomPropertiesSheetVisible".equals(propName)) {
                // $NON-NLS-1$
                customPropertiesPanel.setVisible(object.getIsCustomPropertiesSheetVisible());
            }
        }
    });
    // Update BootSequence ListBox
    bootSequenceModel = object.getBootSequence();
    UpdateBootSequenceListBox();
    cloudInitWidget.edit(object.getCloudInit());
}
#end_block

#method_before
private void preview() {
    VM vm = (VM) getEntity();
    if (vm == null) {
        return;
    }
    Snapshot snapshot = (Snapshot) getSelectedItem();
    // if snapshot doesn't have memory, just trigger preview without showing popup
    if (!isMemorySnapshotSupported() || snapshot.getMemoryVolume().isEmpty()) {
        Frontend.getInstance().runAction(VdcActionType.TryBackToAllSnapshotsOfVm, new TryBackToAllSnapshotsOfVmParameters(vm.getId(), snapshot.getId()), null);
    } else // otherwise, show a popup asking whether to use the memory or not
    {
        SnapshotModel model = new SnapshotModel();
        setWindow(model);
        model.setTitle(ConstantsManager.getInstance().getConstants().previewSnapshotTitle());
        // $NON-NLS-1$
        model.setHashName("preview_snapshot");
        model.getCommands().add(// $NON-NLS-1$
        new UICommand("OnPreview", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
        UICommand cancelCommand = // $NON-NLS-1$
        new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true);
        model.getCommands().add(cancelCommand);
        model.setCancelCommand(cancelCommand);
        model.setCloseCommand(// $NON-NLS-1$
        new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().close()).setIsCancel(true));
    }
}
#method_after
private void preview() {
    VM vm = (VM) getEntity();
    if (vm == null) {
        return;
    }
    Snapshot snapshot = (Snapshot) getSelectedItem();
    // if snapshot doesn't have memory, just trigger preview without showing popup
    if (!isMemorySnapshotSupported() || snapshot.getMemoryVolume().isEmpty()) {
        Frontend.getInstance().runAction(VdcActionType.TryBackToAllSnapshotsOfVm, new TryBackToAllSnapshotsOfVmParameters(vm.getId(), snapshot.getId()), null);
    } else // otherwise, show a popup asking whether to use the memory or not
    {
        SnapshotModel model = new SnapshotModel();
        setWindow(model);
        model.setTitle(ConstantsManager.getInstance().getConstants().previewSnapshotTitle());
        // $NON-NLS-1$
        model.setHashName("preview_snapshot");
        // $NON-NLS-1$
        addCommands(model, "OnPreview");
    }
}
#end_block

#method_before
private void newEntity() {
    VM vm = (VM) getEntity();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.initialize();
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    // $NON-NLS-1$
    UICommand closeCommand = new UICommand("Cancel", this);
    closeCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.setCloseCommand(closeCommand);
}
#method_after
private void newEntity() {
    VM vm = (VM) getEntity();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.initialize();
    model.setCancelCommand(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
}
#end_block

#method_before
public void updateActionAvailability() {
    VM vm = (VM) getEntity();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    List<VM> vmList = vm != null ? Collections.singletonList(vm) : Collections.<VM>emptyList();
    boolean isVmDown = vm != null && vm.getStatus() == VMStatus.Down;
    boolean isVmImageLocked = vm != null && vm.getStatus() == VMStatus.ImageLocked;
    boolean isPreviewing = getIsPreviewing();
    boolean isLocked = getIsLocked();
    boolean isSelected = snapshot != null && snapshot.getType() != SnapshotType.ACTIVE;
    boolean isStateless = getIsStateless();
    boolean isCloneVmSupported = getIsCloneVmSupported();
    getCanSelectSnapshot().setEntity(!isPreviewing && !isLocked && !isStateless && VdcActionUtils.canExecute(vmList, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getNewCommand().setIsExecutionAllowed(!isPreviewing && !isLocked && !isVmImageLocked && !isStateless);
    getPreviewCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCommitCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getUndoCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getRemoveCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCloneVmCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && !isVmImageLocked && !isStateless && isCloneVmSupported);
}
#method_after
public void updateActionAvailability() {
    VM vm = (VM) getEntity();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    List<VM> vmList = vm != null ? Collections.singletonList(vm) : Collections.<VM>emptyList();
    boolean isVmDown = vm != null && vm.getStatus() == VMStatus.Down;
    boolean isVmImageLocked = vm != null && vm.getStatus() == VMStatus.ImageLocked;
    boolean isPreviewing = getIsPreviewing();
    boolean isLocked = getIsLocked();
    boolean isSelected = snapshot != null && snapshot.getType() != SnapshotType.ACTIVE;
    boolean isStateless = getIsStateless();
    boolean isCloneVmSupported = getIsCloneVmSupported();
    getCanSelectSnapshot().setEntity(!isPreviewing && !isLocked && !isStateless && VdcActionUtils.canExecute(vmList, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getNewCommand().setIsExecutionAllowed(!isPreviewing && !isLocked && !isVmImageLocked && !isStateless);
    getPreviewCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCustomPreviewCommand().setIsExecutionAllowed(getPreviewCommand().getIsExecutionAllowed());
    getCommitCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getUndoCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getRemoveCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCloneVmCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && !isVmImageLocked && !isStateless && isCloneVmSupported);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getPreviewCommand()) {
        preview();
    } else if (command == getCommitCommand()) {
        commit();
    } else if (command == getUndoCommand()) {
        undo();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getCloneVmCommand()) {
        cloneVM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnCloneVM")) {
        onCloneVM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnPreview")) {
        OnPreview();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getPreviewCommand()) {
        preview();
    } else if (command == getCustomPreviewCommand()) {
        customPreview();
    } else if (command == getCommitCommand()) {
        commit();
    } else if (command == getUndoCommand()) {
        undo();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getCloneVmCommand()) {
        cloneVM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnCloneVM")) {
        onCloneVM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnPreview")) {
        onPreview();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnCustomPreview")) {
        onCustomPreview();
    }
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setDefaultVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setDefaultVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    return entity;
}
#end_block

#method_before
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getDisplay());
    setDisplaySecurePort(vm.getDisplaySecurePort());
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setDisplayType(vm.getDisplayType());
    setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setDisplayIp(vm.getDisplayIp());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    if (SimpleDependecyInjector.getInstance().get(OsRepository.class).isLinux(getVmOsId())) {
        setUtcDiff(vm.getUtcDiff());
    }
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#method_after
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getDisplay());
    setDisplaySecurePort(vm.getDisplaySecurePort());
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setDisplayType(vm.getDisplayType());
    getDynamicData().setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setDisplayIp(vm.getDisplayIp());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    if (SimpleDependecyInjector.getInstance().get(OsRepository.class).isLinux(getVmOsId())) {
        setUtcDiff(vm.getUtcDiff());
    }
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#end_block

#method_before
public SetupNetworksParameters buildParameters(Guid hostId, Guid sourceClusterId, Guid targetClusterId) {
    List<Network> targetClusterNetworks = getNetworkDAO().getAllForCluster(targetClusterId);
    Map<String, Network> targetClusterNetworksByName = Entities.entitiesByName(targetClusterNetworks);
    SetupNetworksParameters params = createSetupNetworksParameters(hostId);
    Map<String, VdsNetworkInterface> nicsByNetwork = Entities.hostInterfacesByNetworkName(params.getInterfaces());
    Map<String, List<Network>> networksByLabel = getClusterNetworksByLabel(targetClusterNetworks);
    List<VdsNetworkInterface> hostNics = new ArrayList<>(params.getInterfaces());
    // Detect which networks should be added and which should be removed
    for (VdsNetworkInterface nic : hostNics) {
        adjustNetworksByLabel(targetClusterNetworksByName, params, nicsByNetwork, networksByLabel, nic);
    }
    return params;
}
#method_after
public SetupNetworksParameters buildParameters(Guid hostId, Guid sourceClusterId, Guid targetClusterId) {
    List<Network> targetClusterNetworks = getNetworkDAO().getAllForCluster(targetClusterId);
    Map<String, Network> targetClusterNetworksByName = Entities.entitiesByName(targetClusterNetworks);
    SetupNetworksParameters params = createSetupNetworksParameters(hostId);
    Map<String, VdsNetworkInterface> nicsByNetwork = Entities.hostInterfacesByNetworkName(params.getInterfaces());
    Map<String, List<Network>> targetNetworksByLabel = getClusterNetworksByLabel(targetClusterNetworks);
    Map<String, List<Network>> sourceNetworksByLabel = getClusterNetworksByLabel(getNetworkDAO().getAllForCluster(sourceClusterId));
    List<VdsNetworkInterface> hostNics = new ArrayList<>(params.getInterfaces());
    // Detect which networks should be added and which should be removed
    for (VdsNetworkInterface nic : hostNics) {
        adjustNetworksByLabel(sourceNetworksByLabel, targetClusterNetworksByName, targetNetworksByLabel, params, nicsByNetwork, nic);
    }
    return params;
}
#end_block

#method_before
public void adjustNetworksByLabel(Map<String, Network> targetClusterNetworksByName, SetupNetworksParameters params, Map<String, VdsNetworkInterface> nicsByNetwork, Map<String, List<Network>> networksByLabel, VdsNetworkInterface nic) {
    if (nic.getLabels() == null) {
        return;
    }
    for (String label : nic.getLabels()) {
        for (Network net : networksByLabel.get(label)) {
            if (targetClusterNetworksByName.containsKey(net.getName()) && !nicsByNetwork.containsKey(net.getName())) {
                configureNetwork(nic, params.getInterfaces(), net);
            } else if (!targetClusterNetworksByName.containsKey(net.getName()) && nicsByNetwork.containsKey(net.getName())) {
                removeNetworkFromParameters(params, nic, net);
            }
        }
    }
}
#method_after
public void adjustNetworksByLabel(Map<String, List<Network>> sourceNetworksByLabel, Map<String, Network> targetNetworksByName, Map<String, List<Network>> targetNetworksByLabel, SetupNetworksParameters params, Map<String, VdsNetworkInterface> nicsByNetwork, VdsNetworkInterface nic) {
    if (nic.getLabels() == null) {
        return;
    }
    for (String label : nic.getLabels()) {
        // configure networks by target cluster assignment
        List<Network> targetLabeledNetworks = targetNetworksByLabel.get(label);
        if (targetLabeledNetworks != null) {
            for (Network net : targetLabeledNetworks) {
                if (targetNetworksByName.containsKey(net.getName()) && !nicsByNetwork.containsKey(net.getName())) {
                    configureNetwork(nic, params.getInterfaces(), net);
                } else if (configuredNetworkNotAssignedToCluster(targetNetworksByName, nicsByNetwork, net)) {
                    removeNetworkFromParameters(params, nic, net);
                }
            }
        }
        // remove labeled networks originated in source cluster but not assigned to target cluster
        List<Network> sourceLabeledNetworks = sourceNetworksByLabel.get(label);
        if (sourceLabeledNetworks != null) {
            for (Network net : sourceLabeledNetworks) {
                if (configuredNetworkNotAssignedToCluster(targetNetworksByName, nicsByNetwork, net)) {
                    removeNetworkFromParameters(params, nic, net);
                }
            }
        }
    }
}
#end_block

#method_before
public void removeNetworkFromParameters(SetupNetworksParameters params, VdsNetworkInterface nic, Network net) {
    if (NetworkUtils.isVlan(net)) {
        VdsNetworkInterface vlan = getVlanDevice(params.getInterfaces(), nic, net);
        if (vlan == null) {
            throw new VdcBLLException(VdcBllErrors.NETWORK_LABEL_CONFLICT);
        } else {
            params.getInterfaces().remove(vlan);
        }
    }
}
#method_after
public void removeNetworkFromParameters(SetupNetworksParameters params, VdsNetworkInterface nic, Network net) {
    if (NetworkUtils.isVlan(net)) {
        VdsNetworkInterface vlan = getVlanDevice(params.getInterfaces(), nic, net);
        if (vlan == null) {
            throw new VdcBLLException(VdcBllErrors.NETWORK_LABEL_CONFLICT);
        } else {
            params.getInterfaces().remove(vlan);
        }
    } else if (StringUtils.equals(net.getName(), nic.getNetworkName())) {
        nic.setNetworkName(null);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getNic() == null) {
        return failCanDoAction(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST);
    }
    if (NetworkUtils.isLabeled(getNic()) || !getNic().getLabels().contains(getLabel())) {
        return failCanDoAction(VdcBllMessages.INTERFACE_NOT_LABELED);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getNic() == null) {
        return failCanDoAction(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST);
    }
    if (!NetworkUtils.isLabeled(getNic()) || !getNic().getLabels().contains(getLabel())) {
        return failCanDoAction(VdcBllMessages.INTERFACE_NOT_LABELED);
    }
    return true;
}
#end_block

#method_before
public void removeNetworkFromParameters(SetupNetworksParameters params, VdsNetworkInterface nic, Network net) {
    if (NetworkUtils.isVlan(net)) {
        VdsNetworkInterface vlan = getVlanDevice(params.getInterfaces(), nic, net);
        if (vlan == null) {
            throw new VdcBLLException(VdcBllErrors.NETWORK_LABEL_CONFLICT);
        } else {
            params.getInterfaces().remove(vlan);
        }
    } else {
        if (StringUtils.equals(net.getName(), nic.getNetworkName())) {
            nic.setNetworkName(null);
        }
    }
}
#method_after
public void removeNetworkFromParameters(SetupNetworksParameters params, VdsNetworkInterface nic, Network net) {
    if (NetworkUtils.isVlan(net)) {
        VdsNetworkInterface vlan = getVlanDevice(params.getInterfaces(), nic, net);
        if (vlan == null) {
            throw new VdcBLLException(VdcBllErrors.NETWORK_LABEL_CONFLICT);
        } else {
            params.getInterfaces().remove(vlan);
        }
    } else if (StringUtils.equals(net.getName(), nic.getNetworkName())) {
        nic.setNetworkName(null);
    }
}
#end_block

#method_before
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.Empty);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
}
#end_block

#method_before
public static void getVolumeList(AsyncQuery aQuery, String clusterName) {
    if ((ApplicationModeHelper.getUiMode().getValue() & ApplicationMode.GlusterOnly.getValue()) == 0) {
        aQuery.asyncCallback.onSuccess(aQuery.Model, new ArrayList<GlusterVolumeEntity>());
        return;
    }
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<GlusterVolumeEntity> list = (ArrayList<GlusterVolumeEntity>) source;
                return list;
            }
            return new ArrayList<GlusterVolumeEntity>();
        }
    };
    SearchParameters searchParameters;
    searchParameters = // $NON-NLS-1$
    clusterName == null ? // $NON-NLS-1$
    new SearchParameters("Volumes:", SearchType.GlusterVolume) : // $NON-NLS-1$
    new SearchParameters("Volumes: cluster.name=" + clusterName, SearchType.GlusterVolume);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public static void getVolumeList(AsyncQuery aQuery, String clusterName) {
    if ((ApplicationModeHelper.getUiMode().getValue() & ApplicationMode.GlusterOnly.getValue()) == 0) {
        aQuery.asyncCallback.onSuccess(aQuery.model, new ArrayList<GlusterVolumeEntity>());
        return;
    }
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<GlusterVolumeEntity> list = (ArrayList<GlusterVolumeEntity>) source;
                return list;
            }
            return new ArrayList<GlusterVolumeEntity>();
        }
    };
    SearchParameters searchParameters;
    searchParameters = // $NON-NLS-1$
    clusterName == null ? // $NON-NLS-1$
    new SearchParameters("Volumes:", SearchType.GlusterVolume) : // $NON-NLS-1$
    new SearchParameters("Volumes: cluster.name=" + clusterName, SearchType.GlusterVolume);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#end_block

#method_before
public static void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.getInstance().runQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#method_after
public static void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.getInstance().runQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = (ArrayList<VdsNetworkInterface>) (returnValue.getReturnValue());
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (StringHelper.stringsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.Model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (StringHelper.stringsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.Model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.Model, ifacesOptions);
                }
            }
        }));
    }
}
#method_after
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = (ArrayList<VdsNetworkInterface>) (returnValue.getReturnValue());
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (StringHelper.stringsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (StringHelper.stringsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#end_block

#method_before
private void dataCenter_SelectedItemChanged() {
    StoragePool dataCenter = (StoragePool) getDataCenter().getSelectedItem();
    if (dataCenter != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                HostModel hostModel = (HostModel) model;
                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) result;
                VDSGroup oldCluster = (VDSGroup) hostModel.getCluster().getSelectedItem();
                StoragePool selectedDataCenter = (StoragePool) getDataCenter().getSelectedItem();
                // clusters
                if (clusters.isEmpty() || clusters.size() > 0 && clusters.get(0).getStoragePoolId().equals(selectedDataCenter.getId())) {
                    hostModel.getCluster().setItems(clusters);
                    if (oldCluster != null) {
                        VDSGroup newSelectedItem = Linq.firstOrDefault(clusters, new Linq.ClusterPredicate(oldCluster.getId()));
                        if (newSelectedItem != null) {
                            hostModel.getCluster().setSelectedItem(newSelectedItem);
                        }
                    }
                    if (hostModel.getCluster().getSelectedItem() == null) {
                        hostModel.getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
                    }
                }
            }
        };
        if (getIsNew()) {
            AsyncDataProvider.getClusterList(_asyncQuery, dataCenter.getId());
        } else {
            AsyncDataProvider.getClusterListByFlags(_asyncQuery, dataCenter.getId(), getVdsFlags());
        }
    }
}
#method_after
private void dataCenter_SelectedItemChanged() {
    StoragePool dataCenter = (StoragePool) getDataCenter().getSelectedItem();
    if (dataCenter != null) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                HostModel hostModel = (HostModel) model;
                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) result;
                StoragePool selectedDataCenter = (StoragePool) getDataCenter().getSelectedItem();
                // clusters
                if (clusters.isEmpty() || clusters.size() > 0 && clusters.get(0).getStoragePoolId().equals(selectedDataCenter.getId())) {
                    if (hostModel.getIsNew()) {
                        updateClusterList(hostModel, clusters);
                    } else {
                        AsyncQuery architectureQuery = new AsyncQuery();
                        architectureQuery.setModel(new Object[] { hostModel, clusters });
                        architectureQuery.asyncCallback = new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                Object[] objArray = (Object[]) model;
                                HostModel hostModel = (HostModel) objArray[0];
                                ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) objArray[1];
                                ArchitectureType architecture = (ArchitectureType) returnValue;
                                ArrayList<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
                                for (VDSGroup cluster : clusters) {
                                    if (cluster.getArchitecture() == ArchitectureType.undefined || cluster.getArchitecture() == architecture) {
                                        filteredClusters.add(cluster);
                                    }
                                }
                                updateClusterList(hostModel, filteredClusters);
                            }
                        };
                        AsyncDataProvider.getHostArchitecture(architectureQuery, hostModel.getHostId());
                    }
                }
            }
        };
        AsyncDataProvider.getClusterList(_asyncQuery, dataCenter.getId());
    }
}
#end_block

#method_before
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    setVdsFlags(vds.getCpuFlags());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    getPkSection().setIsChangable(false);
    getPkSection().setIsAvailable(false);
    // Use public key when edit or approve host
    setAuthenticationMethod(AuthenticationMethod.PublicKey);
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.pmOptionsStringToMap(vds.getPmOptions()));
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#method_after
public void updateModelFromVds(VDS vds, ArrayList<StoragePool> dataCenters, boolean isEditWithPMemphasis, SystemTreeItemModel selectedSystemTreeItem) {
    setHostId(vds.getId());
    getOverrideIpTables().setIsAvailable(showInstallationProperties());
    setSpmPriorityValue(vds.getVdsSpmPriority());
    setOriginalName(vds.getName());
    getName().setEntity(vds.getName());
    getComment().setEntity(vds.getComment());
    getHost().setEntity(vds.getHostName());
    getFetchSshFingerprint().setEntity(vds.getSshKeyFingerprint());
    getUserName().setEntity(vds.getSshUsername());
    getAuthSshPort().setEntity(vds.getSshPort());
    setPort(vds);
    boolean consoleAddressEnabled = vds.getConsoleAddress() != null;
    getConsoleAddressEnabled().setEntity(consoleAddressEnabled);
    getConsoleAddress().setEntity(vds.getConsoleAddress());
    getConsoleAddress().setIsChangable(consoleAddressEnabled);
    getPkSection().setIsChangable(false);
    getPkSection().setIsAvailable(false);
    // Use public key when edit or approve host
    setAuthenticationMethod(AuthenticationMethod.PublicKey);
    setAllowChangeHost(vds);
    // Set primary PM parameters.
    getManagementIp().setEntity(vds.getManagementIp());
    getPmUserName().setEntity(vds.getPmUser());
    getPmPassword().setEntity(vds.getPmPassword());
    getPmType().setSelectedItem(vds.getPmType());
    setPmOptionsMap(VdsStatic.pmOptionsStringToMap(vds.getPmOptions()));
    // Set secondary PM parameters.
    getPmSecondaryIp().setEntity(vds.getPmSecondaryIp());
    getPmSecondaryUserName().setEntity(vds.getPmSecondaryUser());
    getPmSecondaryPassword().setEntity(vds.getPmSecondaryPassword());
    getPmSecondaryType().setSelectedItem(vds.getPmSecondaryType());
    setPmSecondaryOptionsMap(vds.getPmSecondaryOptionsMap());
    // Set other PM parameters.
    if (isEditWithPMemphasis) {
        setIsPowerManagementTabSelected(true);
        getIsPm().setEntity(true);
        getIsPm().setIsChangable(false);
    } else {
        getIsPm().setEntity(vds.getpm_enabled());
    }
    getPmSecondaryConcurrent().setEntity(vds.isPmSecondaryConcurrent());
    updateModelDataCenterFromVds(dataCenters, vds);
    ArrayList<VDSGroup> clusters;
    if (getCluster().getItems() == null) {
        VDSGroup tempVar = new VDSGroup();
        tempVar.setName(vds.getVdsGroupName());
        tempVar.setId(vds.getVdsGroupId());
        tempVar.setcompatibility_version(vds.getVdsGroupCompatibilityVersion());
        getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { tempVar })));
    }
    clusters = (ArrayList<VDSGroup>) getCluster().getItems();
    updateModelClusterFromVds(clusters, vds);
    if (getCluster().getSelectedItem() == null) {
        getCluster().setSelectedItem(Linq.firstOrDefault(clusters));
    }
    if (vds.getStatus() != VDSStatus.Maintenance && vds.getStatus() != VDSStatus.PendingApproval) {
        setAllowChangeHostPlacementPropertiesWhenNotInMaintenance();
    } else if (selectedSystemTreeItem != null) {
        final UIConstants constants = ConstantsManager.getInstance().getConstants();
        switch(selectedSystemTreeItem.getType()) {
            case Host:
                getName().setIsChangable(false);
                getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                break;
            case Hosts:
            case Cluster:
            case Cluster_Gluster:
                getCluster().setIsChangable(false);
                getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                getDataCenter().setIsChangable(false);
                break;
            case DataCenter:
                StoragePool selectDataCenter = (StoragePool) selectedSystemTreeItem.getEntity();
                getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                getDataCenter().setSelectedItem(selectDataCenter);
                getDataCenter().setIsChangable(false);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    setArchitecture(new ListModel<ArchitectureType>());
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#method_after
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    setArchitecture(new ListModel<ArchitectureType>());
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#end_block

#method_before
private void postInit() {
    getDescription().setEntity(getEntity().getdescription());
    getComment().setEntity(getEntity().getComment());
    setMemoryOverCommit(getEntity().getmax_vds_memory_over_commit());
    getCountThreadsAsCores().setEntity(getEntity().getCountThreadsAsCores());
    getEnableBallooning().setEntity(getEntity().isEnableBallooning());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            clusterModel.getDataCenter().setItems(dataCenters);
            clusterModel.getDataCenter().setSelectedItem(null);
            for (StoragePool a : dataCenters) {
                if (clusterModel.getEntity().getStoragePoolId() != null && a.getId().equals(clusterModel.getEntity().getStoragePoolId())) {
                    clusterModel.getDataCenter().setSelectedItem(a);
                    break;
                }
            }
            clusterModel.getDataCenter().setIsChangable(clusterModel.getDataCenter().getSelectedItem() == null);
            clusterModel.setMigrateOnErrorOption(clusterModel.getEntity().getMigrateOnError());
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#method_after
private void postInit() {
    getDescription().setEntity(getEntity().getdescription());
    getComment().setEntity(getEntity().getComment());
    initSpiceProxy();
    setMemoryOverCommit(getEntity().getmax_vds_memory_over_commit());
    getCountThreadsAsCores().setEntity(getEntity().getCountThreadsAsCores());
    getEnableBallooning().setEntity(getEntity().isEnableBallooning());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            clusterModel.getDataCenter().setItems(dataCenters);
            clusterModel.getDataCenter().setSelectedItem(null);
            for (StoragePool a : dataCenters) {
                if (clusterModel.getEntity().getStoragePoolId() != null && a.getId().equals(clusterModel.getEntity().getStoragePoolId())) {
                    clusterModel.getDataCenter().setSelectedItem(a);
                    break;
                }
            }
            clusterModel.getDataCenter().setIsChangable(clusterModel.getDataCenter().getSelectedItem() == null);
            clusterModel.setMigrateOnErrorOption(clusterModel.getEntity().getMigrateOnError());
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            storagePool_SelectedItemChanged(args);
        } else if (sender == getVersion()) {
            version_SelectedItemChanged(args);
        } else if (sender == getClusterPolicy()) {
            clusterPolicyChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition)) {
        EntityModel senderEntityModel = (EntityModel) sender;
        if ((Boolean) senderEntityModel.getEntity()) {
            if (senderEntityModel == getOptimizationNone_IsSelected()) {
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForServer_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForDesktop_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationCustom_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_YES()) {
                getMigrateOnErrorOption_NO().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_NO()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_HA_ONLY()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_NO().setEntity(false);
            } else if (senderEntityModel == getOptimizeForUtilization()) {
                getOptimizeForSpeed().setEntity(false);
            } else if (senderEntityModel == getOptimizeForSpeed()) {
                getOptimizeForUtilization().setEntity(false);
            } else if (senderEntityModel == getGuarantyResources()) {
                getAllowOverbooking().setEntity(false);
            } else if (senderEntityModel == getAllowOverbooking()) {
                getGuarantyResources().setEntity(false);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            storagePool_SelectedItemChanged(args);
        } else if (sender == getVersion()) {
            version_SelectedItemChanged(args);
        } else if (sender == getClusterPolicy()) {
            clusterPolicyChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        EntityModel senderEntityModel = (EntityModel) sender;
        if (senderEntityModel == getSpiceProxyEnabled()) {
            getSpiceProxy().setIsChangable(getSpiceProxyEnabled().getEntity());
        } else if ((Boolean) senderEntityModel.getEntity()) {
            if (senderEntityModel == getOptimizationNone_IsSelected()) {
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForServer_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForDesktop_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationCustom_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_YES()) {
                getMigrateOnErrorOption_NO().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_NO()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_HA_ONLY()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_NO().setEntity(false);
            } else if (senderEntityModel == getOptimizeForUtilization()) {
                getOptimizeForSpeed().setEntity(false);
            } else if (senderEntityModel == getOptimizeForSpeed()) {
                getOptimizeForUtilization().setEntity(false);
            } else if (senderEntityModel == getGuarantyResources()) {
                getAllowOverbooking().setEntity(false);
            } else if (senderEntityModel == getAllowOverbooking()) {
                getGuarantyResources().setEntity(false);
            }
        }
    }
}
#end_block

#method_before
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            ServerCpu oldSelectedCpu = clusterModel.getCPU().getSelectedItem();
            clusterModel.getCPU().setItems(cpus);
            clusterModel.getCPU().setSelectedItem(oldSelectedCpu != null ? Linq.firstOrDefault(cpus, new Linq.ServerCpuPredicate(oldSelectedCpu.getCpuName())) : null);
            if (clusterModel.getCPU().getSelectedItem() == null || !isCPUinitialized) {
                initCPU();
            }
            if (getIsEdit()) {
                if (StringHelper.isNullOrEmpty(getEntity().getcpu_name())) {
                    List<ArchitectureType> architectures = new ArrayList<ArchitectureType>();
                    if (getEntity().getArchitecture().equals(ArchitectureType.undefined)) {
                        architectures.add(ArchitectureType.undefined);
                    }
                    for (ServerCpu cpu : cpus) {
                        ArchitectureType cpuArch = cpu.getArchitecture();
                        if (!architectures.contains(cpuArch)) {
                            architectures.add(cpuArch);
                        }
                    }
                    ArchitectureType oldSelectedArch = (ArchitectureType) clusterModel.getArchitecture().getSelectedItem();
                    getArchitecture().setItems(architectures);
                    if (oldSelectedArch != null) {
                        getArchitecture().setSelectedItem(oldSelectedArch);
                    } else {
                        getArchitecture().setSelectedItem(getEntity().getArchitecture());
                    }
                }
            } else {
                getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(ArchitectureType.values())));
                getArchitecture().setSelectedItem(ArchitectureType.undefined);
            }
        }
    };
    if (getIsEdit()) {
        AsyncDataProvider.getAllowedCPUList(_asyncQuery, getEntity().getId(), version);
    } else {
        AsyncDataProvider.getCPUList(_asyncQuery, version);
    }
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
}
#method_after
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
}
#end_block

#method_before
private void clusterPolicyChanged() {
    ClusterPolicy clusterPolicy = getClusterPolicy().getSelectedItem();
    ArrayList<String> lines = new ArrayList<String>();
    Map<Guid, PolicyUnit> allPolicyUnits = new HashMap<Guid, PolicyUnit>();
    if (clusterPolicy.getFilters() != null) {
        for (Guid policyUnitId : clusterPolicy.getFilters()) {
            allPolicyUnits.put(policyUnitId, policyUnitMap.get(policyUnitId));
        }
    }
    if (clusterPolicy.getFunctions() != null) {
        for (Pair<Guid, Integer> pair : clusterPolicy.getFunctions()) {
            allPolicyUnits.put(pair.getFirst(), policyUnitMap.get(pair.getFirst()));
        }
    }
    if (clusterPolicy.getBalance() != null) {
        allPolicyUnits.put(clusterPolicy.getBalance(), policyUnitMap.get(clusterPolicy.getBalance()));
    }
    for (PolicyUnit policyUnit : allPolicyUnits.values()) {
        if (policyUnit.getParameterRegExMap() != null) {
            for (Map.Entry<String, String> keyValue : policyUnit.getParameterRegExMap().entrySet()) {
                lines.add(keyValue.getKey() + '=' + keyValue.getValue());
            }
        }
    }
    getCustomPropertySheet().setKeyValueString(lines);
    if (getIsEdit() && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
        getCustomPropertySheet().setEntity(KeyValueModel.convertProperties(getEntity().getClusterPolicyProperties()));
    } else {
        getCustomPropertySheet().setEntity(KeyValueModel.convertProperties(clusterPolicy.getParameterMap()));
    }
}
#method_after
private void clusterPolicyChanged() {
    ClusterPolicy clusterPolicy = getClusterPolicy().getSelectedItem();
    ArrayList<String> lines = new ArrayList<String>();
    Map<Guid, PolicyUnit> allPolicyUnits = new HashMap<Guid, PolicyUnit>();
    if (clusterPolicy.getFilters() != null) {
        for (Guid policyUnitId : clusterPolicy.getFilters()) {
            allPolicyUnits.put(policyUnitId, policyUnitMap.get(policyUnitId));
        }
    }
    if (clusterPolicy.getFunctions() != null) {
        for (Pair<Guid, Integer> pair : clusterPolicy.getFunctions()) {
            allPolicyUnits.put(pair.getFirst(), policyUnitMap.get(pair.getFirst()));
        }
    }
    if (clusterPolicy.getBalance() != null) {
        allPolicyUnits.put(clusterPolicy.getBalance(), policyUnitMap.get(clusterPolicy.getBalance()));
    }
    for (PolicyUnit policyUnit : allPolicyUnits.values()) {
        if (policyUnit.getParameterRegExMap() != null) {
            for (Map.Entry<String, String> keyValue : policyUnit.getParameterRegExMap().entrySet()) {
                lines.add(keyValue.getKey() + '=' + keyValue.getValue());
            }
        }
    }
    getCustomPropertySheet().setKeyValueString(lines);
    if (getIsEdit() && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
        getCustomPropertySheet().deserialize(KeyValueModel.convertProperties(getEntity().getClusterPolicyProperties()));
    } else {
        getCustomPropertySheet().deserialize(KeyValueModel.convertProperties(clusterPolicy.getParameterMap()));
    }
}
#end_block

#method_before
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(40), new I18NNameValidation() });
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        getCPU().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    // TODO: async validation for webadmin
    // string name = (string)Name.Entity;
    // //Check name unicitate.
    // if (String.Compare(name, OriginalName, true) != 0 && !DataProvider.IsClusterNameUnique(name))
    // {
    // Name.IsValid = false;
    // Name.InvalidityReasons.Add("Name must be unique.");
    // }
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    setIsGeneralTabValid(getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true));
    return getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true) && getCustomPropertySheet().getIsValid();
}
#method_after
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(40), new I18NNameValidation() });
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        getCPU().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    // TODO: async validation for webadmin
    // string name = (string)Name.Entity;
    // //Check name unicitate.
    // if (String.Compare(name, OriginalName, true) != 0 && !DataProvider.IsClusterNameUnique(name))
    // {
    // Name.IsValid = false;
    // Name.InvalidityReasons.Add("Name must be unique.");
    // }
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    setIsGeneralTabValid(getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true));
    return getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getSpiceProxy().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true) && getCustomPropertySheet().getIsValid();
}
#end_block

#method_before
public void install() {
    if (getWindow() != null) {
        return;
    }
    InstallModel model = new InstallModel();
    setWindow(model);
    model.setTitle(constants.installHostTitle());
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(getEntity().getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    if (getEntity().getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getoVirtISOsList(new AsyncQuery(model, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                InstallModel model = (InstallModel) target;
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                Collections.sort(isos, Collections.reverseOrder());
                model.getOVirtISO().setItems(isos);
                model.getOVirtISO().setSelectedItem(Linq.firstOrDefault(isos));
                model.getOVirtISO().setIsAvailable(true);
                model.getOVirtISO().setIsChangable(!isos.isEmpty());
                model.getHostVersion().setIsAvailable(true);
                if (isos.isEmpty()) {
                    model.setMessage(constants.thereAreNoISOversionsVompatibleWithHostCurrentVerMsg());
                }
                addInstallCommands(model, isos.isEmpty());
                getWindow().stopProgress();
            }
        }), getEntity().getId());
    } else {
        model.getUserPassword().setIsAvailable(true);
        model.getUserPassword().setIsChangable(true);
        Version v3 = new Version(3, 0);
        boolean isLessThan3 = getEntity().getVdsGroupCompatibilityVersion().compareTo(v3) < 0;
        if (!isLessThan3) {
            model.getOverrideIpTables().setIsAvailable(true);
            model.getOverrideIpTables().setEntity(true);
        }
        addInstallCommands(model, false);
        getWindow().stopProgress();
    }
}
#method_after
public void install() {
    if (getWindow() != null) {
        return;
    }
    InstallModel model = new InstallModel();
    model.setVds(getEntity());
    setWindow(model);
    model.setTitle(constants.installHostTitle());
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(getEntity().getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    if (getEntity().getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getoVirtISOsList(new AsyncQuery(model, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                InstallModel model = (InstallModel) target;
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                Collections.sort(isos, Collections.reverseOrder());
                model.getOVirtISO().setItems(isos);
                model.getOVirtISO().setSelectedItem(Linq.firstOrDefault(isos));
                model.getOVirtISO().setIsAvailable(true);
                model.getOVirtISO().setIsChangable(!isos.isEmpty());
                model.getHostVersion().setIsAvailable(true);
                if (isos.isEmpty()) {
                    model.setMessage(constants.thereAreNoISOversionsVompatibleWithHostCurrentVerMsg());
                }
                addInstallCommands(model, isos.isEmpty());
                getWindow().stopProgress();
            }
        }), getEntity().getId());
    } else {
        model.getUserPassword().setIsAvailable(true);
        model.getUserPassword().setIsChangable(true);
        Version v3 = new Version(3, 0);
        boolean isLessThan3 = getEntity().getVdsGroupCompatibilityVersion().compareTo(v3) < 0;
        if (!isLessThan3) {
            model.getOverrideIpTables().setIsAvailable(true);
            model.getOverrideIpTables().setEntity(true);
        }
        addInstallCommands(model, false);
        getWindow().stopProgress();
    }
}
#end_block

#method_before
public boolean isHostExists(List<GlusterServerInfo> glusterServers, VDS server) {
    if (GlusterFeatureSupported.glusterHostUuidSupported(server.getVdsGroupCompatibilityVersion())) {
        GlusterServer glusterServer = DbFacade.getInstance().getGlusterServerDao().getByServerId(server.getId());
        if (glusterServer != null) {
            for (GlusterServerInfo glusterServerInfo : glusterServers) {
                if (glusterServerInfo.getUuid().equals(glusterServer.getGlusterServerUuid())) {
                    return true;
                }
            }
        }
    } else {
        for (GlusterServerInfo glusterServer : glusterServers) {
            if (glusterServer.getHostnameOrIp().equals(server.getHostName())) {
                return true;
            }
            try {
                String glusterHostAddr = InetAddress.getByName(glusterServer.getHostnameOrIp()).getHostAddress();
                for (VdsNetworkInterface vdsNwInterface : getVdsInterfaces(server.getId())) {
                    if (glusterHostAddr.equals(vdsNwInterface.getAddress())) {
                        return true;
                    }
                }
            } catch (UnknownHostException e) {
                log.errorFormat("Could not resole IP address of the host {0}. Error: {1}", glusterServer.getHostnameOrIp(), e.getMessage());
            }
        }
    }
    return false;
}
#method_after
public boolean isHostExists(List<GlusterServerInfo> glusterServers, VDS server) {
    if (GlusterFeatureSupported.glusterHostUuidSupported(server.getVdsGroupCompatibilityVersion())) {
        GlusterServer glusterServer = DbFacade.getInstance().getGlusterServerDao().getByServerId(server.getId());
        if (glusterServer != null) {
            for (GlusterServerInfo glusterServerInfo : glusterServers) {
                if (glusterServerInfo.getUuid().equals(glusterServer.getGlusterServerUuid())) {
                    return true;
                }
            }
        }
    } else {
        for (GlusterServerInfo glusterServer : glusterServers) {
            if (glusterServer.getHostnameOrIp().equals(server.getHostName())) {
                return true;
            }
            try {
                String glusterHostAddr = InetAddress.getByName(glusterServer.getHostnameOrIp()).getHostAddress();
                for (VdsNetworkInterface vdsNwInterface : getVdsInterfaces(server.getId())) {
                    if (glusterHostAddr.equals(vdsNwInterface.getAddress())) {
                        return true;
                    }
                }
            } catch (UnknownHostException e) {
                log.errorFormat("Could not resolve IP address of the host {0}. Error: {1}", glusterServer.getHostnameOrIp(), e.getMessage());
            }
        }
    }
    return false;
}
#end_block

#method_before
public boolean checkHaReservationStatusForCluster(VDSGroup cluster, List<VDS> failedHosts) {
    List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(cluster.getId());
    // No hosts, return true
    if (hosts == null) {
        return true;
    }
    // HA Reservation is not possible with less the 2 hosts
    if (hosts.size() < 2) {
        return false;
    }
    // List of host id and cpu/ram free resources
    // for the outer Pair, first is host id second is a Pair of cpu and ram
    // for the inner Pair, first is cpu second is ram
    List<Pair<Guid, Pair<Integer, Integer>>> hostsUnutilizedResources = getUnutilizedResources(hosts);
    List<VM> vmInCluster = DbFacade.getInstance().getVmDao().getAllForVdsGroup(cluster.getId());
    if (vmInCluster == null) {
        return true;
    }
    // Filter non HA Vms
    vmInCluster = LinqUtils.filter(vmInCluster, new Predicate<VM>() {

        @Override
        public boolean eval(VM v) {
            return v.isAutoStartup();
        }
    });
    Map<Guid, List<VM>> hostToHaVmsMapping = mapVmToHost(vmInCluster);
    for (VDS host : hosts) {
        boolean isHaSafe = findReplacementForHost(cluster, host, hostToHaVmsMapping.get(host.getId()), hostsUnutilizedResources);
        if (!isHaSafe) {
            failedHosts.add(host);
        }
    }
    if (failedHosts.size() == 0) {
        return true;
    } else {
        return false;
    }
}
#method_after
public boolean checkHaReservationStatusForCluster(VDSGroup cluster, List<VDS> failedHosts) {
    List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAllForVdsGroup(cluster.getId());
    // No hosts, return true
    if (hosts == null || hosts.isEmpty()) {
        return true;
    }
    // HA Reservation is not possible with less than 2 hosts
    if (hosts.size() < 2) {
        log.debugFormat("Cluster: {0} failed HA reservation check because there is only one host in the cluster", cluster.getName());
        failedHosts.addAll(hosts);
        return false;
    }
    // List of host id and cpu/ram free resources
    // for the outer Pair, first is host id second is a Pair of cpu and ram
    // for the inner Pair, first is cpu second is ram
    List<Pair<Guid, Pair<Integer, Integer>>> hostsUnutilizedResources = getUnutilizedResources(hosts);
    Map<Guid, List<VM>> hostToHaVmsMapping = mapHaVmToHostByCluster(cluster.getId());
    for (VDS host : hosts) {
        if (hostToHaVmsMapping.get(host.getId()) != null) {
            boolean isHaSafe = findReplacementForHost(cluster, host, hostToHaVmsMapping.get(host.getId()), hostsUnutilizedResources);
            if (!isHaSafe) {
                failedHosts.add(host);
            }
        }
    }
    log.infoFormat("HA reservation status for cluster {0} is {1}", cluster.getName(), failedHosts.isEmpty() ? "OK" : "Failed");
    return failedHosts.isEmpty();
}
#end_block

#method_before
private boolean findReplacementForHost(VDSGroup cluster, VDS host, List<VM> vmList, List<Pair<Guid, Pair<Integer, Integer>>> hostsUnutilizedResources) {
    Map<Guid, Pair<Integer, Integer>> additionalHostsUtilizedResources = new HashMap<Guid, Pair<Integer, Integer>>();
    for (VM vm : vmList) {
        int curVmMemSize = (int) Math.round(vm.getMemSizeMb() * (vm.getUsageMemPercent() / 100.0));
        int curVmCpuPercent = vm.getUsageCpuPercent() * vm.getNumOfCpus() / SlaValidator.getEffectiveCpuCores(host, cluster.getCountThreadsAsCores());
        boolean foundForCurVm = false;
        for (Pair<Guid, Pair<Integer, Integer>> hostData : hostsUnutilizedResources) {
            // Make sure not to run on the same Host as the Host we are testing
            if (hostData.getFirst().equals(host.getId())) {
                continue;
            }
            // Check Memory and CPU
            if (hostData.getSecond() != null && hostData.getSecond().getSecond() != null && hostData.getSecond().getFirst() != null) {
                int memoryFree = hostData.getSecond().getSecond();
                int cpuFree = hostData.getSecond().getFirst();
                long additionalMemory = 0;
                int additionalCpu = 0;
                if (additionalHostsUtilizedResources.get(hostData.getFirst()) != null) {
                    additionalCpu = additionalHostsUtilizedResources.get(hostData.getFirst()).getFirst();
                    additionalMemory = additionalHostsUtilizedResources.get(hostData.getFirst()).getSecond();
                }
                if ((memoryFree - additionalMemory) >= curVmMemSize && (cpuFree - additionalCpu) >= curVmCpuPercent) {
                    // Found a place for current vm, add the RAM and CPU size to additionalHostsUtilizedResources
                    if (!additionalHostsUtilizedResources.containsKey(hostData.getFirst())) {
                        Pair<Integer, Long> cpuRamPair = new Pair<Integer, Long>();
                        cpuRamPair.setSecond(new Long(curVmMemSize));
                        cpuRamPair.setFirst(curVmCpuPercent);
                    } else {
                        Pair<Integer, Integer> cpuRamPair = additionalHostsUtilizedResources.get(hostData.getFirst());
                        cpuRamPair.setSecond(cpuRamPair.getSecond() + curVmMemSize);
                        cpuRamPair.setFirst(cpuRamPair.getFirst() + curVmCpuPercent);
                    }
                    foundForCurVm = true;
                    break;
                }
            }
        }
        if (!foundForCurVm) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean findReplacementForHost(VDSGroup cluster, VDS host, List<VM> vmList, List<Pair<Guid, Pair<Integer, Integer>>> hostsUnutilizedResources) {
    Map<Guid, Pair<Integer, Integer>> additionalHostsUtilizedResources = new HashMap<Guid, Pair<Integer, Integer>>();
    for (VM vm : vmList) {
        int curVmMemSize = 0;
        if (vm.getUsageMemPercent() != null) {
            curVmMemSize = (int) Math.round(vm.getMemSizeMb() * (vm.getUsageMemPercent() / 100.0));
        }
        int curVmCpuPercent = 0;
        if (vm.getUsageCpuPercent() != null) {
            curVmCpuPercent = vm.getUsageCpuPercent() * vm.getNumOfCpus() / SlaValidator.getEffectiveCpuCores(host, cluster.getCountThreadsAsCores());
        }
        log.debugFormat("VM {0}. CPU usage:{1}%, RAM usage:{2}MB", vm.getName(), curVmCpuPercent, curVmMemSize);
        boolean foundForCurVm = false;
        for (Pair<Guid, Pair<Integer, Integer>> hostData : hostsUnutilizedResources) {
            // Make sure not to run on the same Host as the Host we are testing
            if (hostData.getFirst().equals(host.getId())) {
                continue;
            }
            // Check Memory and CPU
            if (hostData.getSecond() != null && hostData.getSecond().getSecond() != null && hostData.getSecond().getFirst() != null) {
                int memoryFree = hostData.getSecond().getSecond();
                int cpuFree = hostData.getSecond().getFirst();
                long additionalMemory = 0;
                int additionalCpu = 0;
                if (additionalHostsUtilizedResources.get(hostData.getFirst()) != null) {
                    additionalCpu = additionalHostsUtilizedResources.get(hostData.getFirst()).getFirst();
                    additionalMemory = additionalHostsUtilizedResources.get(hostData.getFirst()).getSecond();
                }
                if ((memoryFree - additionalMemory) >= curVmMemSize && (cpuFree - additionalCpu) >= curVmCpuPercent) {
                    // Found a place for current vm, add the RAM and CPU size to additionalHostsUtilizedResources
                    Pair<Integer, Integer> cpuRamPair = additionalHostsUtilizedResources.get(hostData.getFirst());
                    if (cpuRamPair != null) {
                        cpuRamPair.setFirst(cpuRamPair.getFirst() + curVmCpuPercent);
                        cpuRamPair.setSecond(cpuRamPair.getSecond() + curVmMemSize);
                    } else {
                        cpuRamPair = new Pair<>(curVmCpuPercent, curVmMemSize);
                        additionalHostsUtilizedResources.put(hostData.getFirst(), cpuRamPair);
                    }
                    foundForCurVm = true;
                    break;
                }
            }
        }
        if (!foundForCurVm) {
            log.infoFormat("Did not found a replacement host for VM:{0}", vm.getName());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private Map<Guid, List<VM>> mapVmToHost(List<VM> vms) {
    Map<Guid, List<VM>> hostToHaVmsMapping = new HashMap<Guid, List<VM>>();
    for (VM vm : vms) {
        if (vm.getRunOnVds() != null) {
            if (!hostToHaVmsMapping.containsKey(vm.getRunOnVds())) {
                List<VM> vmsOfHost = new ArrayList<VM>();
                vmsOfHost.add(vm);
                hostToHaVmsMapping.put(vm.getRunOnVds(), vmsOfHost);
            } else {
                hostToHaVmsMapping.get(vm.getRunOnVds()).add(vm);
            }
        }
    }
    return hostToHaVmsMapping;
}
#method_after
public static Map<Guid, List<VM>> mapVmToHost(List<VM> vms) {
    Map<Guid, List<VM>> hostToHaVmsMapping = new HashMap<>();
    for (VM vm : vms) {
        if (!Guid.isNullOrEmpty(vm.getRunOnVds())) {
            if (!hostToHaVmsMapping.containsKey(vm.getRunOnVds())) {
                List<VM> vmsOfHost = new ArrayList<VM>();
                vmsOfHost.add(vm);
                hostToHaVmsMapping.put(vm.getRunOnVds(), vmsOfHost);
            } else {
                hostToHaVmsMapping.get(vm.getRunOnVds()).add(vm);
            }
        }
    }
    return hostToHaVmsMapping;
}
#end_block

#method_before
private List<Pair<Guid, Pair<Integer, Integer>>> getUnutilizedResources(List<VDS> hosts) {
    List<Pair<Guid, Pair<Integer, Integer>>> hostsUnutilizedResources = new ArrayList<Pair<Guid, Pair<Integer, Integer>>>();
    for (VDS host : hosts) {
        Pair<Integer, Integer> innerUnutilizedCpuRamPair = new Pair<Integer, Integer>();
        innerUnutilizedCpuRamPair.setFirst(100 - host.getUsageCpuPercent());
        int hostFreeMem = 0;
        if (host.getPhysicalMemMb() != null && host.getUsageMemPercent() != null) {
            int usedMem = (int) Math.round(host.getPhysicalMemMb() * (host.getUsageMemPercent() / 100.0));
            hostFreeMem = host.getPhysicalMemMb() - usedMem;
        }
        innerUnutilizedCpuRamPair.setSecond(hostFreeMem);
        Pair<Guid, Pair<Integer, Integer>> outerUnutilizedCpuRamPair = new Pair<Guid, Pair<Integer, Integer>>();
        outerUnutilizedCpuRamPair.setFirst(host.getId());
        outerUnutilizedCpuRamPair.setSecond(innerUnutilizedCpuRamPair);
        hostsUnutilizedResources.add(outerUnutilizedCpuRamPair);
    }
    return hostsUnutilizedResources;
}
#method_after
private List<Pair<Guid, Pair<Integer, Integer>>> getUnutilizedResources(List<VDS> hosts) {
    List<Pair<Guid, Pair<Integer, Integer>>> hostsUnutilizedResources = new ArrayList<>();
    for (VDS host : hosts) {
        Pair<Integer, Integer> innerUnutilizedCpuRamPair = new Pair<>();
        int hostFreeCpu = 0;
        if (host.getUsageCpuPercent() != null) {
            hostFreeCpu = 100 - host.getUsageCpuPercent();
        }
        innerUnutilizedCpuRamPair.setFirst(hostFreeCpu);
        // Get available memory for the Host, round down to int
        int hostFreeMem = (int) host.getMaxSchedulingMemory();
        innerUnutilizedCpuRamPair.setSecond(hostFreeMem);
        Pair<Guid, Pair<Integer, Integer>> outerUnutilizedCpuRamPair = new Pair<>(host.getId(), innerUnutilizedCpuRamPair);
        hostsUnutilizedResources.add(outerUnutilizedCpuRamPair);
    }
    return hostsUnutilizedResources;
}
#end_block

#method_before
public static void enableHaReservationCheck() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start HA Reservation check");
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(instance, "performHaResevationCheck", new Class[] {}, new Object[] {}, Config.<Integer>getValue(ConfigValues.VdsHaReservationIntervalInMinutes), Config.<Integer>getValue(ConfigValues.VdsHaReservationIntervalInMinutes), TimeUnit.MINUTES);
        log.info("Finished HA Reservation check");
    }
}
#method_after
public static void enableHaReservationCheck() {
    if (Config.<Boolean>getValue(ConfigValues.EnableVdsLoadBalancing)) {
        log.info("Start HA Reservation check");
        Integer interval = Config.<Integer>getValue(ConfigValues.VdsHaReservationIntervalInMinutes);
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(instance, "performHaResevationCheck", new Class[] {}, new Object[] {}, interval, interval, TimeUnit.MINUTES);
        log.info("Finished HA Reservation check");
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debugFormat("HA Reservation check timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    if (clusters != null) {
        for (VDSGroup cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<VDS>();
                boolean status = new HaReservationHandling().checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!status) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    StringBuilder failedHostsStr = new StringBuilder();
                    int commaCount = returnedFailedHosts.size() - 1;
                    for (VDS host : returnedFailedHosts) {
                        failedHostsStr.append(host.getName());
                        if (commaCount > 0) {
                            failedHostsStr.append(", ");
                            commaCount--;
                        }
                    }
                    logable.addCustomValue("Hosts", failedHostsStr.toString());
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION);
                }
            }
        }
    }
}
#method_after
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling();
        for (VDSGroup cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<VDS>();
                boolean status = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!status) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    String failedHostsStr = StringUtils.join(returnedFailedHosts, ", ");
                    logable.addCustomValue("Hosts", failedHostsStr);
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION);
                    log.infoFormat("Cluster: {0} fail to pass HA reservation check.", cluster.getName());
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#end_block

#method_before
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STATUS_CHANGE_FAILED_DUE_TO_STOP_SPM_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#method_after
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ARCHITECTURE_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STATUS_CHANGE_FAILED_DUE_TO_STOP_SPM_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@Override
public List<Pair<Guid, Integer>> score(List<VDS> hosts, VM vm, Map<String, String> parameters) {
    List<Pair<Guid, Integer>> scores = new ArrayList<Pair<Guid, Integer>>();
    Map<Guid, Integer> hostsHaVmCount = new HashMap<Guid, Integer>();
    // If the vm is not HA or the cluster is not marked as HA Reservation set default score.
    VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(hosts.get(0).getVdsGroupId());
    if (!vm.isAutoStartup() || !vdsGroup.supportsHaReservation()) {
        fillDefaultScores(hosts, scores);
    } else {
        // Use a single call to the DB to retrieve all VM in the Cluster and map them by Host id
        Map<Guid, List<VM>> hostId2HaVmMapping = mapHaVmToHostByCluster(vdsGroup.getId());
        int maxCount = 0;
        for (VDS host : hosts) {
            int count = 0;
            if (hostId2HaVmMapping.containsKey(host.getId())) {
                count = hostId2HaVmMapping.get(host.getId()).size();
            }
            maxCount = (maxCount < count) ? count : maxCount;
            hostsHaVmCount.put(host.getId(), count);
        }
        // Fit count to scale of 0 to RATIO_FACTOR
        if (maxCount > 0) {
            for (VDS host : hosts) {
                int fittedCount = Math.round(hostsHaVmCount.get(host.getId()).floatValue() / maxCount * RATIO_FACTOR);
                hostsHaVmCount.put(host.getId(), fittedCount);
            }
        }
        // Get scale down param
        Integer scaleDownParameter = 1;
        if (parameters.get("ScaleDown") != null) {
            scaleDownParameter = Integer.parseInt(parameters.get("ScaleDown"));
        } else {
            scaleDownParameter = Config.<Integer>getValue(ConfigValues.ScaleDownForHaReservation);
        }
        // Set the score pairs
        for (VDS host : hosts) {
            // Scale down if needed
            int haCount = hostsHaVmCount.get(host.getId());
            haCount = (int) Math.ceil(haCount / scaleDownParameter.floatValue());
            scores.add(new Pair<Guid, Integer>(host.getId(), haCount));
        }
    }
    return scores;
}
#method_after
@Override
public List<Pair<Guid, Integer>> score(List<VDS> hosts, VM vm, Map<String, String> parameters) {
    log.info("Started HA reservation scoring method");
    List<Pair<Guid, Integer>> scores = new ArrayList<Pair<Guid, Integer>>();
    Map<Guid, Integer> hostsHaVmCount = new HashMap<Guid, Integer>();
    // If the vm is not HA or the cluster is not marked as HA Reservation set default score.
    VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(hosts.get(0).getVdsGroupId());
    if (!vm.isAutoStartup() || !vdsGroup.supportsHaReservation()) {
        fillDefaultScores(hosts, scores);
    } else {
        // Use a single call to the DB to retrieve all VM in the Cluster and map them by Host id
        Map<Guid, List<VM>> hostId2HaVmMapping = HaReservationHandling.mapHaVmToHostByCluster(vdsGroup.getId());
        int maxCount = 0;
        for (VDS host : hosts) {
            int count = 0;
            if (hostId2HaVmMapping.containsKey(host.getId())) {
                count = hostId2HaVmMapping.get(host.getId()).size();
            }
            maxCount = (maxCount < count) ? count : maxCount;
            hostsHaVmCount.put(host.getId(), count);
        }
        // Fit count to scale of 0 to RATIO_FACTOR
        if (maxCount > 0) {
            for (VDS host : hosts) {
                int fittedCount = Math.round(hostsHaVmCount.get(host.getId()).floatValue() / maxCount * RATIO_FACTOR);
                hostsHaVmCount.put(host.getId(), fittedCount);
            }
        }
        // Get scale down param
        Integer scaleDownParameter = 1;
        if (parameters.get("ScaleDown") != null) {
            scaleDownParameter = Integer.parseInt(parameters.get("ScaleDown"));
        } else {
            scaleDownParameter = Config.<Integer>getValue(ConfigValues.ScaleDownForHaReservation);
        }
        // Set the score pairs
        for (VDS host : hosts) {
            // Scale down if needed
            int haCount = hostsHaVmCount.get(host.getId());
            haCount = (int) Math.ceil(haCount / scaleDownParameter.floatValue());
            scores.add(new Pair<Guid, Integer>(host.getId(), haCount));
            log.infoFormat("Score for host:{0} is {1}", host.getName(), haCount);
        }
    }
    return scores;
}
#end_block

#method_before
@Override
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    if (!cluster.supportsHaReservation()) {
        return null;
    }
    if (hosts == null || hosts.size() < 2) {
        int hostCount = hosts == null ? 0 : hosts.size();
        log.debugFormat("No balancing for cluster {0}, contains only {1} host(s)", cluster.getName(), hostCount);
        return null;
    }
    int haVmsInCluster = 0;
    Map<Guid, List<VM>> hostId2HaVmMapping = mapHaVmToHostByCluster(cluster.getId());
    haVmsInCluster = countHaVmsInCluster(hostId2HaVmMapping);
    int optimalHaDistribution = (int) Math.ceil(((double) haVmsInCluster / hosts.size()));
    int overUtilizationParam = 100;
    if (parameters.get("OverUtilization") != null) {
        overUtilizationParam = Integer.parseInt(parameters.get("OverUtilization"));
    } else {
        overUtilizationParam = Config.<Integer>getValue(ConfigValues.OverUtilizationForHaReservation);
    }
    int overUtilizationThreshold = (int) Math.ceil(optimalHaDistribution * (overUtilizationParam / 100));
    List<VDS> overUtilizedHosts = getOverUtilizedHosts(hosts, hostId2HaVmMapping, optimalHaDistribution);
    if (overUtilizedHosts.size() == 0) {
        return null;
    }
    List<VDS> underUtilizedHosts = getUnderUtilizedHosts(hosts, hostId2HaVmMapping, overUtilizationParam);
    if (underUtilizedHosts.size() == 0) {
        return null;
    }
    // Get random host from the over utilized hosts
    VDS randomHost = overUtilizedHosts.get(new Random().nextInt(overUtilizedHosts.size()));
    List<VM> migrableVmsOnRandomHost = getMigrableVmsRunningOnVds(randomHost.getId(), hostId2HaVmMapping);
    if (migrableVmsOnRandomHost.isEmpty()) {
        return null;
    }
    // Get random vm to migrate
    VM vm = migrableVmsOnRandomHost.get(new Random().nextInt(migrableVmsOnRandomHost.size()));
    List<Guid> underUtilizedHostsKeys = new ArrayList<Guid>();
    for (VDS vds : underUtilizedHosts) {
        underUtilizedHostsKeys.add(vds.getId());
    }
    return new Pair<List<Guid>, Guid>(underUtilizedHostsKeys, vm.getId());
}
#method_after
@Override
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    log.debugFormat("Started HA reservation balancing method for cluster: {0}", cluster.getName());
    if (!cluster.supportsHaReservation()) {
        return null;
    }
    if (hosts == null || hosts.size() < 2) {
        int hostCount = hosts == null ? 0 : hosts.size();
        log.debugFormat("No balancing for cluster {0}, contains only {1} host(s)", cluster.getName(), hostCount);
        return null;
    }
    int haVmsInCluster = 0;
    Map<Guid, List<VM>> hostId2HaVmMapping = HaReservationHandling.mapHaVmToHostByCluster(cluster.getId());
    haVmsInCluster = countHaVmsInCluster(hostId2HaVmMapping);
    int optimalHaDistribution = (int) Math.ceil(((double) haVmsInCluster / hosts.size()));
    int overUtilizationParam = DEFAULT_OVER_UTILIZATION_VALUE;
    if (parameters.get("OverUtilization") != null) {
        overUtilizationParam = NumberUtils.toInt(parameters.get("OverUtilization"));
    } else {
        overUtilizationParam = Config.<Integer>getValue(ConfigValues.OverUtilizationForHaReservation);
    }
    log.debugFormat("optimalHaDistribution value:{0}", optimalHaDistribution);
    int overUtilizationThreshold = (int) Math.ceil(optimalHaDistribution * (overUtilizationParam / 100.0));
    log.debugFormat("overUtilizationThreshold value: {0}", overUtilizationThreshold);
    List<VDS> overUtilizedHosts = getHostUtilizedByCondition(hosts, hostId2HaVmMapping, overUtilizationThreshold, Condition.MORE_THAN);
    if (overUtilizedHosts.isEmpty()) {
        log.debugFormat("No over utilized hosts for cluster: {0}", cluster.getName());
        return null;
    }
    List<VDS> underUtilizedHosts = getHostUtilizedByCondition(hosts, hostId2HaVmMapping, overUtilizationParam, Condition.LESS_THAN);
    if (underUtilizedHosts.size() == 0) {
        log.debugFormat("No under utilized hosts for cluster: {0}", cluster.getName());
        return null;
    }
    // Get random host from the over utilized hosts
    VDS randomHost = overUtilizedHosts.get(new Random().nextInt(overUtilizedHosts.size()));
    List<VM> migrableVmsOnRandomHost = getMigrableVmsRunningOnVds(randomHost.getId(), hostId2HaVmMapping);
    if (migrableVmsOnRandomHost.isEmpty()) {
        log.debugFormat("No migratable hosts were found for cluster: {0} ", cluster.getName());
        return null;
    }
    // Get random vm to migrate
    VM vm = migrableVmsOnRandomHost.get(new Random().nextInt(migrableVmsOnRandomHost.size()));
    log.infoFormat("VM to be migrated:{0}", vm.getName());
    List<Guid> underUtilizedHostsKeys = new ArrayList<Guid>();
    for (VDS vds : underUtilizedHosts) {
        underUtilizedHostsKeys.add(vds.getId());
    }
    return new Pair<List<Guid>, Guid>(underUtilizedHostsKeys, vm.getId());
}
#end_block

#method_before
private List<VM> getMigrableVmsRunningOnVds(final Guid hostId, Map<Guid, List<VM>> hostId2HaVmMapping) {
    List<VM> vms = hostId2HaVmMapping.get(hostId);
    vms = LinqUtils.filter(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM v) {
            return v.getMigrationSupport() == MigrationSupport.MIGRATABLE && !hostId.equals(v.getDedicatedVmForVds());
        }
    });
    return vms;
}
#method_after
private List<VM> getMigrableVmsRunningOnVds(final Guid hostId, Map<Guid, List<VM>> hostId2HaVmMapping) {
    List<VM> vms = hostId2HaVmMapping.get(hostId);
    vms = LinqUtils.filter(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM v) {
            return v.getMigrationSupport() == MigrationSupport.MIGRATABLE;
        }
    });
    return vms;
}
#end_block

#method_before
@Override
public void edit(final InstallModel model) {
    driver.edit(model);
    if (model.getVds().getStatus() == VDSStatus.InstallFailed) {
        rbPassword.setValue(true);
        model.setAuthenticationMethod(AuthenticationMethod.Password);
        displayPasswordField(true);
    } else {
        rbPublicKey.setValue(true);
        model.setAuthenticationMethod(AuthenticationMethod.PublicKey);
        displayPasswordField(false);
    }
    rbPassword.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            model.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPasswordField(true);
        }
    });
    rbPublicKey.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            model.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPasswordField(false);
        }
    });
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderWidget.edit(model.getNetworkProviderModel());
}
#method_after
@Override
public void edit(final InstallModel model) {
    driver.edit(model);
    boolean installedFailed = model.getVds().getStatus() == VDSStatus.InstallFailed;
    model.setAuthenticationMethod(installedFailed ? AuthenticationMethod.Password : AuthenticationMethod.PublicKey);
    displayPasswordField(installedFailed);
    rbPassword.setValue(installedFailed);
    rbPublicKey.setValue(!installedFailed);
    rbPassword.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            model.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPasswordField(true);
        }
    });
    rbPublicKey.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            model.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPasswordField(false);
        }
    });
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderWidget.edit(model.getNetworkProviderModel());
}
#end_block

#method_before
public void setVds(VDS v) {
    vds = v;
}
#method_after
public void setVds(VDS value) {
    vds = value;
}
#end_block

#method_before
public void install() {
    if (getWindow() != null) {
        return;
    }
    InstallModel model = new InstallModel();
    setWindow(model);
    model.setVds(getEntity());
    model.setTitle(constants.installHostTitle());
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(getEntity().getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    if (getEntity().getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getoVirtISOsList(new AsyncQuery(model, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                InstallModel model = (InstallModel) target;
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                Collections.sort(isos, Collections.reverseOrder());
                model.getOVirtISO().setItems(isos);
                model.getOVirtISO().setSelectedItem(Linq.firstOrDefault(isos));
                model.getOVirtISO().setIsAvailable(true);
                model.getOVirtISO().setIsChangable(!isos.isEmpty());
                model.getHostVersion().setIsAvailable(true);
                if (isos.isEmpty()) {
                    model.setMessage(constants.thereAreNoISOversionsVompatibleWithHostCurrentVerMsg());
                }
                addInstallCommands(model, isos.isEmpty());
                getWindow().stopProgress();
            }
        }), getEntity().getId());
    } else {
        model.getUserPassword().setIsAvailable(true);
        model.getUserPassword().setIsChangable(true);
        Version v3 = new Version(3, 0);
        boolean isLessThan3 = getEntity().getVdsGroupCompatibilityVersion().compareTo(v3) < 0;
        if (!isLessThan3) {
            model.getOverrideIpTables().setIsAvailable(true);
            model.getOverrideIpTables().setEntity(true);
        }
        addInstallCommands(model, false);
        getWindow().stopProgress();
    }
}
#method_after
public void install() {
    if (getWindow() != null) {
        return;
    }
    InstallModel model = new InstallModel();
    model.setVds(getEntity());
    setWindow(model);
    model.setTitle(constants.installHostTitle());
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(getEntity().getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    if (getEntity().getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getoVirtISOsList(new AsyncQuery(model, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                InstallModel model = (InstallModel) target;
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                Collections.sort(isos, Collections.reverseOrder());
                model.getOVirtISO().setItems(isos);
                model.getOVirtISO().setSelectedItem(Linq.firstOrDefault(isos));
                model.getOVirtISO().setIsAvailable(true);
                model.getOVirtISO().setIsChangable(!isos.isEmpty());
                model.getHostVersion().setIsAvailable(true);
                if (isos.isEmpty()) {
                    model.setMessage(constants.thereAreNoISOversionsVompatibleWithHostCurrentVerMsg());
                }
                addInstallCommands(model, isos.isEmpty());
                getWindow().stopProgress();
            }
        }), getEntity().getId());
    } else {
        model.getUserPassword().setIsAvailable(true);
        model.getUserPassword().setIsChangable(true);
        Version v3 = new Version(3, 0);
        boolean isLessThan3 = getEntity().getVdsGroupCompatibilityVersion().compareTo(v3) < 0;
        if (!isLessThan3) {
            model.getOverrideIpTables().setIsAvailable(true);
            model.getOverrideIpTables().setEntity(true);
        }
        addInstallCommands(model, false);
        getWindow().stopProgress();
    }
}
#end_block

#method_before
public void editHost() {
    // Let's the parent model know about request.
    getRequestEditEvent().raise(this, EventArgs.Empty);
}
#method_after
public void editHost() {
    // Let's the parent model know about request.
    getRequestEditEvent().raise(this, EventArgs.EMPTY);
}
#end_block

#method_before
@Override
protected void entityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.entityPropertyChanged(sender, e);
    if (// $NON-NLS-1$ //$NON-NLS-2$
    e.PropertyName.equals("net_config_dirty") || e.PropertyName.equals("status") || e.PropertyName.equals("spm_status") || // $NON-NLS-1$ //$NON-NLS-2$
    e.PropertyName.equals("vm_active")) {
        updateUpgradeAlert = true;
        updateAlerts();
    }
    if (// $NON-NLS-1$ //$NON-NLS-2$
    e.PropertyName.equals("usage_mem_percent") || e.PropertyName.equals("physical_mem_mb")) {
        updateMemory();
    }
    if (// $NON-NLS-1$ //$NON-NLS-2$
    e.PropertyName.equals("swap_total") || e.PropertyName.equals("swap_free")) {
        updateSwapUsed();
    }
}
#method_after
@Override
protected void entityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.entityPropertyChanged(sender, e);
    if (// $NON-NLS-1$ //$NON-NLS-2$
    e.propertyName.equals("net_config_dirty") || e.propertyName.equals("status") || e.propertyName.equals("spm_status") || // $NON-NLS-1$ //$NON-NLS-2$
    e.propertyName.equals("vm_active")) {
        updateUpgradeAlert = true;
        updateAlerts();
    }
    if (// $NON-NLS-1$ //$NON-NLS-2$
    e.propertyName.equals("usage_mem_percent") || e.propertyName.equals("physical_mem_mb")) {
        updateMemory();
    }
    if (// $NON-NLS-1$ //$NON-NLS-2$
    e.propertyName.equals("swap_total") || e.propertyName.equals("swap_free")) {
        updateSwapUsed();
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    ExtendedVmDynamic other = (ExtendedVmDynamic) obj;
    return ObjectUtils.objectsEqual(host, other.host);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    if (!super.equals(obj)) {
        return false;
    }
    ExtendedVmDynamic other = (ExtendedVmDynamic) obj;
    return Objects.equals(host, other.host);
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = super.hashCode();
    result = 31 * result + (host != null ? host.hashCode() : 0);
    return result;
}
#method_after
@Override
public int hashCode() {
    int result = super.hashCode();
    result = 31 * result + Objects.hashCode(host);
    return result;
}
#end_block

#method_before
public static void main(String[] args) {
    NotificationProperties prop = null;
    initLogging();
    try {
        prop = NotificationProperties.getInstance();
        prop.validate();
    } catch (Exception ex) {
        log.error("Failed to parse configuration.", ex);
        System.exit(1);
    }
    if (args != null && args.length > 0 && ARG_VALIDATE.equals(args[0])) {
        // command line argument to validate only entered
        System.exit(0);
    }
    NotifierSignalHandler handler = new NotifierSignalHandler();
    handler.addScheduledExecutorService(notifyScheduler);
    handler.addScheduledExecutorService(monitorScheduler);
    Runtime.getRuntime().addShutdownHook(handler);
    NotificationService notificationService = null;
    EngineMonitorService engineMonitorService = null;
    try {
        notificationService = new NotificationService(prop);
        engineMonitorService = new EngineMonitorService(prop);
        // add notification service to scheduler with its configurable interval
        handler.addServiceHandler(notifyScheduler.scheduleWithFixedDelay(notificationService, 1, prop.getLong(NotificationProperties.INTERVAL_IN_SECONDS), TimeUnit.SECONDS));
        // add engine monitor service to scheduler with its configurable interval
        handler.addServiceHandler(monitorScheduler.scheduleWithFixedDelay(engineMonitorService, 1, prop.getLong(NotificationProperties.ENGINE_INTERVAL_IN_SECONDS), TimeUnit.SECONDS));
    } catch (Exception e) {
        log.error("Failed to run the event notification service. ", e);
        // flag exit code to calling script after threads shut down.
        System.exit(1);
    }
}
#method_after
public static void main(String[] args) {
    NotificationProperties prop = null;
    initLogging();
    try {
        prop = NotificationProperties.getInstance();
        prop.validate();
    } catch (Exception ex) {
        log.error("Failed to parse configuration.", ex);
        // print error also to stderr to be seen in console during service startup
        System.err.println(ex.getMessage());
        System.exit(1);
    }
    if (args != null && args.length > 0 && ARG_VALIDATE.equals(args[0])) {
        // command line argument to validate only entered
        System.exit(0);
    }
    NotifierSignalHandler handler = new NotifierSignalHandler();
    handler.addScheduledExecutorService(notifyScheduler);
    handler.addScheduledExecutorService(monitorScheduler);
    Runtime.getRuntime().addShutdownHook(handler);
    try {
        NotificationService notificationService = new NotificationService(prop);
        EngineMonitorService engineMonitorService = new EngineMonitorService(prop);
        // add notification service to scheduler with its configurable interval
        handler.addServiceHandler(notifyScheduler.scheduleWithFixedDelay(notificationService, 1, prop.getLong(NotificationProperties.INTERVAL_IN_SECONDS), TimeUnit.SECONDS));
        // add engine monitor service to scheduler with its configurable interval
        handler.addServiceHandler(monitorScheduler.scheduleWithFixedDelay(engineMonitorService, 1, prop.getLong(NotificationProperties.ENGINE_INTERVAL_IN_SECONDS), TimeUnit.SECONDS));
    } catch (Exception e) {
        log.error("Failed to run the event notification service. ", e);
        // flag exit code to calling script after threads shut down.
        System.exit(1);
    }
}
#end_block

#method_before
@Override
public Response add(VM vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            Guid templateId = getTemplateId(vm);
            VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(getClusterId(vm));
            }
            VDSGroup cluster = lookupCluster(staticVm.getVdsGroupId());
            if (cluster.getArchitecture() == ArchitectureType.undefined) {
                throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity("The selected cluster does not have architecture, please set it before adding vms.").build());
            }
            if (Guid.Empty.equals(templateId) && !vm.isSetOs()) {
                replaceDefaultOs(staticVm, cluster);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), cluster));
            if (!isFiltered()) {
                // resolve the host's ID, because it will be needed down the line
                if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                    staticVm.setDedicatedVmForVds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
                }
            } else {
                vm.setPlacementPolicy(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
                response = cloneVmFromTemplate(staticVm, vm, templateId);
            } else if (Guid.Empty.equals(templateId)) {
                response = addVmFromScratch(staticVm, vm, storageDomainId);
            } else {
                response = addVm(staticVm, vm, storageDomainId, templateId);
            }
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#method_after
@Override
public Response add(VM vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            Guid templateId = getTemplateId(vm);
            VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(getClusterId(vm));
            }
            VDSGroup cluster = lookupCluster(staticVm.getVdsGroupId());
            if (Guid.Empty.equals(templateId) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            if (Guid.Empty.equals(templateId) && !vm.isSetDisplay()) {
                staticVm.setDefaultDisplayType(null);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), cluster));
            if (!isFiltered()) {
                // resolve the host's ID, because it will be needed down the line
                if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                    staticVm.setDedicatedVmForVds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
                }
            } else {
                vm.setPlacementPolicy(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
                response = cloneVmFromTemplate(staticVm, vm, templateId);
            } else if (Guid.Empty.equals(templateId)) {
                response = addVmFromScratch(staticVm, vm, storageDomainId);
            } else {
                response = addVm(staticVm, vm, storageDomainId, templateId);
            }
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#end_block

#method_before
@Override
public void onVmAndPoolLoad() {
    if (getvms() != null && getpools() != null) {
        // Complete search.
        // Remove pools that has provided VMs.
        ArrayList<VmPool> filteredPools = new ArrayList<VmPool>();
        for (VmPool pool : getpools()) {
            // Add pool to map.
            int attachedVmsCount = 0;
            for (VM vm : getvms()) {
                if (vm.getVmPoolId() != null && vm.getVmPoolId().equals(pool.getVmPoolId())) {
                    attachedVmsCount++;
                }
            }
            if (attachedVmsCount < pool.getMaxAssignedVmsPerUser()) {
                filteredPools.add(pool);
            }
        }
        // Merge VMs and Pools, and create item models.
        final List all = Linq.concat(getvms(), filteredPools);
        List<VdcQueryType> poolQueryList = new ArrayList<VdcQueryType>();
        List<VdcQueryParametersBase> poolParamList = new ArrayList<VdcQueryParametersBase>();
        for (VmPool p : filteredPools) {
            poolQueryList.add(VdcQueryType.GetVmDataByPoolId);
            poolParamList.add(new IdQueryParameters(p.getVmPoolId()));
        }
        Frontend.getInstance().runMultipleQueries(poolQueryList, poolParamList, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                List<VM> vmsOfPools = new LinkedList<VM>();
                List<VdcQueryReturnValue> poolRepresentants = result.getReturnValues();
                for (VdcQueryReturnValue poolRepresentant : poolRepresentants) {
                    vmsOfPools.add((VM) poolRepresentant.getReturnValue());
                }
                consoleModelsCache.updateVmCache(getvms());
                consoleModelsCache.updatePoolCache(vmsOfPools);
                Collections.sort(all, new NameableComparator());
                ArrayList<Model> items = new ArrayList<Model>();
                for (Object item : all) {
                    VmConsoles consoles = (item instanceof VM) ? consoleModelsCache.getVmConsolesForVmId(((VM) item).getId()) : consoleModelsCache.getVmConsolesForPoolId(((VmPool) item).getVmPoolId());
                    UserPortalItemModel model = new UserPortalItemModel(item, consoles);
                    model.setEntity(item);
                    items.add(model);
                }
                setItems(items);
                setvms(null);
                setpools(null);
                getSearchCompletedEvent().raise(this, EventArgs.EMPTY);
            }
        });
    }
}
#method_after
@Override
public void onVmAndPoolLoad() {
    if (getvms() != null && getpools() != null) {
        // Complete search.
        // Remove pools that has provided VMs.
        ArrayList<VmPool> filteredPools = new ArrayList<VmPool>();
        for (VmPool pool : getpools()) {
            // Add pool to map.
            int attachedVmsCount = 0;
            for (VM vm : getvms()) {
                if (vm.getVmPoolId() != null && vm.getVmPoolId().equals(pool.getVmPoolId())) {
                    attachedVmsCount++;
                }
            }
            if (attachedVmsCount < pool.getMaxAssignedVmsPerUser()) {
                filteredPools.add(pool);
            }
        }
        // Merge VMs and Pools, and create item models.
        final List all = Linq.concat(getvms(), filteredPools);
        List<VdcQueryType> poolQueryList = new ArrayList<VdcQueryType>();
        List<VdcQueryParametersBase> poolParamList = new ArrayList<VdcQueryParametersBase>();
        for (VmPool p : filteredPools) {
            poolQueryList.add(VdcQueryType.GetVmDataByPoolId);
            poolParamList.add(new IdQueryParameters(p.getVmPoolId()));
        }
        Frontend.getInstance().runMultipleQueries(poolQueryList, poolParamList, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                List<VM> vmsOfPools = new LinkedList<VM>();
                List<VdcQueryReturnValue> poolRepresentants = result.getReturnValues();
                for (VdcQueryReturnValue poolRepresentant : poolRepresentants) {
                    vmsOfPools.add((VM) poolRepresentant.getReturnValue());
                }
                consoleModelsCache.updateVmCache(getvms());
                consoleModelsCache.updatePoolCache(vmsOfPools);
                Collections.sort(all, new NameableComparator());
                ArrayList<Model> items = new ArrayList<Model>();
                for (Object item : all) {
                    VmConsoles consoles = consoleModelsCache.getVmConsolesForEntity(item);
                    UserPortalItemModel model = new UserPortalItemModel(item, consoles);
                    model.setEntity(item);
                    items.add(model);
                }
                setItems(items);
                setvms(null);
                setpools(null);
                getSearchCompletedEvent().raise(this, EventArgs.EMPTY);
            }
        });
    }
}
#end_block

#method_before
@Override
public void onVmAndPoolLoad() {
    if (getvms() != null && getpools() != null) {
        // Complete search.
        // Remove pools that has provided VMs.
        ArrayList<VmPool> filteredPools = new ArrayList<VmPool>();
        for (VmPool pool : getpools()) {
            int attachedVmsCount = 0;
            for (VM vm : getvms()) {
                if (vm.getVmPoolId() != null && vm.getVmPoolId().equals(pool.getVmPoolId())) {
                    attachedVmsCount++;
                }
            }
            if (attachedVmsCount < pool.getMaxAssignedVmsPerUser()) {
                filteredPools.add(pool);
            }
        }
        // Merge VMs and Pools, and create item models.
        final List all = Linq.concat(getvms(), filteredPools);
        List<VdcQueryType> poolQueryList = new ArrayList<VdcQueryType>();
        List<VdcQueryParametersBase> poolParamList = new ArrayList<VdcQueryParametersBase>();
        for (VmPool p : filteredPools) {
            poolQueryList.add(VdcQueryType.GetVmDataByPoolId);
            poolParamList.add(new IdQueryParameters(p.getVmPoolId()));
        }
        Frontend.getInstance().runMultipleQueries(poolQueryList, poolParamList, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                List<VM> vmsOfPools = new LinkedList<VM>();
                List<VdcQueryReturnValue> poolRepresentants = result.getReturnValues();
                for (VdcQueryReturnValue poolRepresentant : poolRepresentants) {
                    vmsOfPools.add((VM) poolRepresentant.getReturnValue());
                }
                consoleModelsCache.updateVmCache(getvms());
                consoleModelsCache.updatePoolCache(vmsOfPools);
                Collections.sort(all, new NameableComparator());
                ArrayList<Model> items = new ArrayList<Model>();
                for (Object item : all) {
                    VmConsoles consoles = (item instanceof VM) ? consoleModelsCache.getVmConsolesForVmId(((VM) item).getId()) : consoleModelsCache.getVmConsolesForPoolId(((VmPool) item).getVmPoolId());
                    UserPortalItemModel model = new UserPortalItemModel(item, consoles);
                    model.setEntity(item);
                    items.add(model);
                }
                setItems(items);
                setvms(null);
                setpools(null);
                getSearchCompletedEvent().raise(this, EventArgs.EMPTY);
            }
        });
    }
}
#method_after
@Override
public void onVmAndPoolLoad() {
    if (getvms() != null && getpools() != null) {
        // Complete search.
        // Remove pools that has provided VMs.
        ArrayList<VmPool> filteredPools = new ArrayList<VmPool>();
        for (VmPool pool : getpools()) {
            int attachedVmsCount = 0;
            for (VM vm : getvms()) {
                if (vm.getVmPoolId() != null && vm.getVmPoolId().equals(pool.getVmPoolId())) {
                    attachedVmsCount++;
                }
            }
            if (attachedVmsCount < pool.getMaxAssignedVmsPerUser()) {
                filteredPools.add(pool);
            }
        }
        // Merge VMs and Pools, and create item models.
        final List all = Linq.concat(getvms(), filteredPools);
        List<VdcQueryType> poolQueryList = new ArrayList<VdcQueryType>();
        List<VdcQueryParametersBase> poolParamList = new ArrayList<VdcQueryParametersBase>();
        for (VmPool p : filteredPools) {
            poolQueryList.add(VdcQueryType.GetVmDataByPoolId);
            poolParamList.add(new IdQueryParameters(p.getVmPoolId()));
        }
        Frontend.getInstance().runMultipleQueries(poolQueryList, poolParamList, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                List<VM> vmsOfPools = new LinkedList<VM>();
                List<VdcQueryReturnValue> poolRepresentants = result.getReturnValues();
                for (VdcQueryReturnValue poolRepresentant : poolRepresentants) {
                    vmsOfPools.add((VM) poolRepresentant.getReturnValue());
                }
                consoleModelsCache.updateVmCache(getvms());
                consoleModelsCache.updatePoolCache(vmsOfPools);
                Collections.sort(all, new NameableComparator());
                ArrayList<Model> items = new ArrayList<Model>();
                for (Object item : all) {
                    VmConsoles consoles = consoleModelsCache.getVmConsolesForEntity(item);
                    UserPortalItemModel model = new UserPortalItemModel(item, consoles);
                    model.setEntity(item);
                    items.add(model);
                }
                setItems(items);
                setvms(null);
                setpools(null);
                getSearchCompletedEvent().raise(this, EventArgs.EMPTY);
            }
        });
    }
}
#end_block

#method_before
private void storeConsolesInternal(VmConsoles consoles, boolean isPool) {
    ConsoleProtocol selectedProtocol = consoles.getSelectedProcotol();
    ConsoleContext context = consoles.getConsoleContext();
    String id = isPool ? consoles.getVm().getVmPoolId().toString() : consoles.getVm().getId().toString();
    KeyMaker keyMaker = new KeyMaker(id, isPool, context);
    clientStorage.setLocalItem(keyMaker.make(SELECTED_PROTOCOL), selectedProtocol.toString());
    if (selectedProtocol == ConsoleProtocol.SPICE) {
        storeSpiceData(consoles, keyMaker);
    } else if (selectedProtocol == ConsoleProtocol.VNC) {
        storeVncData(consoles, keyMaker);
    } else if (selectedProtocol == ConsoleProtocol.RDP) {
        storeRdpData(consoles, keyMaker);
    }
}
#method_after
private void storeConsolesInternal(VmConsoles consoles, boolean isPool) {
    ConsoleProtocol selectedProtocol = consoles.getSelectedProcotol();
    ConsoleContext context = consoles.getConsoleContext();
    String id = consoles.getEntityId().toString();
    KeyMaker keyMaker = new KeyMaker(id, isPool, context);
    clientStorage.setLocalItem(keyMaker.make(SELECTED_PROTOCOL), selectedProtocol.toString());
    if (selectedProtocol == ConsoleProtocol.SPICE) {
        storeSpiceData(consoles, keyMaker);
    } else if (selectedProtocol == ConsoleProtocol.VNC) {
        storeVncData(consoles, keyMaker);
    } else if (selectedProtocol == ConsoleProtocol.RDP) {
        storeRdpData(consoles, keyMaker);
    }
}
#end_block

#method_before
@Override
public void loadFromLocalStorage(VmConsoles consoles) {
    String vmId = guidToStringNullSafe(consoles.getVm().getId());
    String poolId = guidToStringNullSafe(consoles.getVm().getVmPoolId());
    ConsoleContext context = consoles.getConsoleContext();
    KeyMaker poolKeyMaker = new KeyMaker(poolId, true, context);
    // load pool defaults
    loadConsolesWithKeymaker(consoles, poolKeyMaker);
    if (consoles instanceof VmConsolesImpl) {
        KeyMaker vmKeyMaker = new KeyMaker(vmId, false, context);
        // load vm
        loadConsolesWithKeymaker(consoles, vmKeyMaker);
    }
}
#method_after
@Override
public void loadFromLocalStorage(VmConsoles consoles) {
    String vmId = guidToStringNullSafe(consoles.getVm().getId());
    String poolId = guidToStringNullSafe(consoles.getVm().getVmPoolId());
    ConsoleContext context = consoles.getConsoleContext();
    if (poolId != null) {
        KeyMaker poolKeyMaker = new KeyMaker(poolId, true, context);
        // load pool defaults
        loadConsolesWithKeymaker(consoles, poolKeyMaker);
    }
    if (consoles instanceof VmConsolesImpl) {
        KeyMaker vmKeyMaker = new KeyMaker(vmId, false, context);
        // load vm
        loadConsolesWithKeymaker(consoles, vmKeyMaker);
    }
}
#end_block

#method_before
public String make(String key) {
    return vmOrPoolId + isPool + context + key;
}
#method_after
public String make(String key) {
    return id + isPool + context + key;
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    // todo revisit this, connectAutomatically flag may not be needed
    if (connectAutomatically.readConnectAutomatically() && model.getCanConnectAutomatically() && !alreadyOpened) {
        try {
            model.getAutoConnectableConsoles().get(0).connect();
            alreadyOpened = true;
        } catch (VmConsoles.ConsoleConnectException e) {
            errorPopupManager.show(e.getLocalizedErrorMessage());
        }
    }
    unregisterModels();
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    if (connectAutomatically.readConnectAutomatically() && model.getCanConnectAutomatically() && !alreadyOpened) {
        try {
            model.getAutoConnectableConsoles().get(0).connect();
            alreadyOpened = true;
        } catch (VmConsoles.ConsoleConnectException e) {
            errorPopupManager.show(e.getLocalizedErrorMessage());
        }
    }
    unregisterModels();
}
#end_block

#method_before
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForVmId((((VM) getSelectedItem()).getId()));
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void editConsole() {
    if (getWindow() != null || getSelectedItem() == null) {
        return;
    }
    final VmConsoles activeVmConsoles = consoleModelsCache.getVmConsolesForEntity(getSelectedItem());
    final ConsolePopupModel model = new ConsolePopupModel();
    model.setVmConsoles(activeVmConsoles);
    // $NON-NLS-1$
    model.setHashName("editConsole");
    setWindow(model);
    // $NON-NLS-1$
    final UICommand saveCommand = new UICommand("OnEditConsoleSave", this);
    saveCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    saveCommand.setIsDefault(true);
    model.getCommands().add(saveCommand);
    // $NON-NLS-1$
    final UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consoleModelsCache.getVmConsolesForVmId(vm.getId()).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isConsoleCommandsExecutionAllowed() {
    final List<VM> list = getSelectedItems();
    if (list == null) {
        return false;
    }
    // return true, if at least one console is available
    for (VM vm : list) {
        if (consoleModelsCache.getVmConsolesForEntity(vm).canConnectToConsole()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consoleModelsCache.getVmConsolesForVmId(vm.getId()).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#method_after
private void connectToConsoles() {
    StringBuilder errorMessages = null;
    final List<VM> list = getSelectedItems();
    if (list == null || list.isEmpty()) {
        return;
    }
    for (VM vm : list) {
        try {
            consoleModelsCache.getVmConsolesForEntity(vm).connect();
        } catch (VmConsoles.ConsoleConnectException e) {
            final String errorMessage = e.getLocalizedErrorMessage();
            if (errorMessage != null) {
                if (errorMessages == null) {
                    errorMessages = new StringBuilder();
                } else {
                    // $NON-NLS-1$
                    errorMessages.append("\r\n");
                }
                errorMessages.append(vm.getName()).append(// $NON-NLS-1$
                " - ").append(errorMessage);
            }
        }
    }
    if (errorMessages != null) {
        errorPopupManager.show(errorMessages.toString());
    }
}
#end_block

#method_before
@Override
protected boolean shouldRenderCell(UserPortalItemModel model) {
    return model.isPool() || model.getVM().isRunningOrPaused();
}
#method_after
@Override
protected boolean shouldRenderCell(UserPortalItemModel model) {
    return model.isPool() || (model.getVM() != null) && model.getVM().isRunningOrPaused();
}
#end_block

#method_before
@BeforeClass
public static void setUp() throws Exception {
    preferences = new MapBackedPreferences(preferences, "");
    preferences.node("/os/rhel7/id").put("value", "777");
    preferences.node("/os/rhel7/name").put("value", "RHEL 7");
    preferences.node("/os/rhel7/family").put("value", "linux");
    preferences.node("/os/rhel7/bus").put("value", "64");
    preferences.node("/os/rhel7/devices/network").put("value", NETWORK_DEVICES);
    preferences.node("/os/rhel7/devices/disk/hotpluggableInterfaces").put("value", DISK_HOTPLUGGABLE_INTERFACES);
    preferences.node("/os/rhel7/watchDogModels").put("value", WATCH_DOG_MODELS);
    preferences.node("/os/rhel7/resources/minimum/ram").put("value", "1024");
    preferences.node("/os/rhel7/resources/minimum/ram").put("value.3.1", "512");
    preferences.node("/os/rhel7/resources/maximum/ram").put("value", "2048");
    preferences.node("/os/rhel7/displayProtocols").put("value", "vnc/cirrus,qxl/qxl");
    preferences.node("/os/rhel7/sysprepPath").put("value", PATH_TO_SYSPREP);
    preferences.node("/os/rhel7/productKey").put("value", SOME_PRODUCT_KEY);
    preferences.node("/os/rhel7/devices/audio").put("value", SOUND_DEVICE);
    preferences.node("/os/rhel7/devices/cdInterface").put("value", CD_INTERFACE);
    preferences.node("/os/rhel7/isTimezoneTypeInteger").put("value", "false");
    preferences.node("/os/bados/id").put("value", "666");
    preferences.node("/os/bados/derivedFrom").put("value", "nonExistingOs");
    preferences.node("/os/rhel8/id").put("value", "888");
    preferences.node("/os/rhel8/derivedFrom").put("value", "rhel7");
    preferences.node("/os/windows_8/id").put("value", "20");
    preferences.node("/backwardCompatibility").put("Windows8", "20");
    OsRepositoryImpl.INSTANCE.init(preferences);
}
#method_after
@BeforeClass
public static void setUp() throws Exception {
    preferences = new MapBackedPreferences(preferences, "");
    preferences.node("/os/rhel7/id").put("value", "777");
    preferences.node("/os/rhel7/name").put("value", "RHEL 7");
    preferences.node("/os/rhel7/family").put("value", "linux");
    preferences.node("/os/rhel7/bus").put("value", "64");
    preferences.node("/os/rhel7/devices/network").put("value", NETWORK_DEVICES);
    preferences.node("/os/rhel7/devices/disk/hotpluggableInterfaces").put("value", DISK_HOTPLUGGABLE_INTERFACES);
    preferences.node("/os/rhel7/devices/watchdog/models").put("value", WATCH_DOG_MODELS);
    preferences.node("/os/rhel7/resources/minimum/ram").put("value", "1024");
    preferences.node("/os/rhel7/resources/minimum/ram").put("value.3.1", "512");
    preferences.node("/os/rhel7/resources/maximum/ram").put("value", "2048");
    preferences.node("/os/rhel7/devices/display/protocols").put("value", "vnc/cirrus,qxl/qxl");
    preferences.node("/os/rhel7/sysprepPath").put("value", PATH_TO_SYSPREP);
    preferences.node("/os/rhel7/productKey").put("value", SOME_PRODUCT_KEY);
    preferences.node("/os/rhel7/devices/audio").put("value", SOUND_DEVICE);
    preferences.node("/os/rhel7/devices/cdInterface").put("value", CD_INTERFACE);
    preferences.node("/os/rhel7/isTimezoneTypeInteger").put("value", "false");
    preferences.node("/os/bados/id").put("value", "666");
    preferences.node("/os/bados/derivedFrom").put("value", "nonExistingOs");
    preferences.node("/os/rhel8/id").put("value", "888");
    preferences.node("/os/rhel8/derivedFrom").put("value", "rhel7");
    preferences.node("/os/windows_8/id").put("value", "20");
    preferences.node("/backwardCompatibility").put("Windows8", "20");
    OsRepositoryImpl.INSTANCE.init(preferences);
}
#end_block

#method_before
@Test
public void testLoadOverridingFiles() throws Exception {
    Assert.assertEquals("qxl/qxl", OsInfoPreferencesLoader.INSTANCE.getPreferences().node("/os/default/displayProtocols").get("value", "qxl/qxl"));
}
#method_after
@Test
public void testLoadOverridingFiles() throws Exception {
    Assert.assertEquals("qxl/qxl", OsInfoPreferencesLoader.INSTANCE.getPreferences().node("/os/default/devices/display/protocols").get("value", "qxl/qxl"));
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVm().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity(), getVm().getOs(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVm().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    List<VmNetworkInterface> nics = getVm().getInterfaces();
    vmInterfaceManager.sortVmNics(nics, getVm().getStaticData().getManagedDeviceMap());
    // If we import it as a new entity, then we allocate all MAC addresses in advance
    if (getParameters().isImportAsNewEntity()) {
        List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
        for (int i = 0; i < nics.size(); ++i) {
            nics.get(i).setMacAddress(macAddresses.get(i));
        }
    }
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), !getParameters().isImportAsNewEntity(), getVm().getOs(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#end_block

#method_before
private void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.ImageLocked);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setAppList(getParameters().getVm().getDynamicData().getAppList());
    getVmDynamicDAO().save(tempVar);
    getCompensationContext().snapshotNewEntity(tempVar);
}
#method_after
private void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.ImageLocked);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setLastStopTime(new Date());
    tempVar.setAppList(getParameters().getVm().getDynamicData().getAppList());
    getVmDynamicDAO().save(tempVar);
    getCompensationContext().snapshotNewEntity(tempVar);
}
#end_block

#method_before
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return true;
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), false);
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), false);
}
#end_block

#method_before
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNic iface : getVmInterfaces()) {
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#method_after
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    tempVar.setLastStopTime(new Date());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#end_block

#method_before
@Before
public void setUp() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    final int osId = 0;
    final Version version = Version.v3_0;
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    Map<Integer, Map<Version, List<DisplayType>>> displayTypeMap = new HashMap<Integer, Map<Version, List<DisplayType>>>();
    displayTypeMap.put(osId, new HashMap<Version, List<DisplayType>>());
    displayTypeMap.get(osId).put(version, Arrays.asList(DisplayType.qxl));
    when(osRepository.getDisplayTypes()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setId(Guid.newGuid());
    group.setcompatibility_version(version);
    vm.setVdsGroupId(group.getId());
    vmStatic.setVdsGroupId(group.getId());
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
}
#method_after
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    Map<Integer, Map<Version, List<DisplayType>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<DisplayType>>());
    displayTypeMap.get(osId).put(version, Arrays.asList(DisplayType.qxl));
    when(osRepository.getDisplayTypes()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setcpu_name("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setcompatibility_version(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), false);
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), false);
            }
            setSucceeded(true);
            return null;
        }
    });
    VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), false);
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getVm().isBalloonEnabled(), false);
            }
            setSucceeded(true);
            return null;
        }
    });
    VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Before
public void setUp() {
    // init the injector with the osRepository instance
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    final int osId = 0;
    Map<Integer, Map<Version, List<DisplayType>>> displayTypeMap = new HashMap<Integer, Map<Version, List<DisplayType>>>();
    displayTypeMap.put(osId, new HashMap<Version, List<DisplayType>>());
    displayTypeMap.get(osId).put(null, Arrays.asList(DisplayType.qxl));
    when(osRepository.getDisplayTypes()).thenReturn(displayTypeMap);
}
#method_after
@Before
public void setUp() {
    // init the injector with the osRepository instance
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    final int osId = 0;
    Map<Integer, Map<Version, List<DisplayType>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<DisplayType>>());
    displayTypeMap.get(osId).put(null, Arrays.asList(DisplayType.qxl));
    when(osRepository.getDisplayTypes()).thenReturn(displayTypeMap);
}
#end_block

#method_before
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), getParameters().isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected boolean hasWatchdog() {
    return getParameters().getWatchdog() != null ? true : VmDeviceUtils.hasWatchdog(getVmId());
}
#method_after
protected boolean hasWatchdog() {
    return getParameters().getWatchdog() != null;
}
#end_block

#method_before
public static boolean isDisplayTypeSupported(int osId, DisplayType defaultDisplayType, List<String> reasons, Version clusterVersion) {
    boolean result = VmValidationUtils.isDisplayTypeSupported(osId, clusterVersion, defaultDisplayType);
    if (!result) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_VM_DISPLAY_TYPE_IS_NOT_SUPPORTED_BY_OS.toString());
    }
    return result;
}
#method_after
public static boolean isDisplayTypeSupported(int osId, DisplayType defaultDisplayType, List<String> reasons, Version clusterVersion) {
    boolean result = VmValidationUtils.isDisplayTypeSupported(osId, clusterVersion, defaultDisplayType);
    if (!result) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_VM_DISPLAY_TYPE_IS_NOT_SUPPORTED_BY_OS.name());
    }
    return result;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Set parameters for messaging.
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM__CLUSTER);
    VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    } else {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        if (ObjectIdentityChecker.CanUpdateField(vm, "vdsGroupId", vm.getStatus())) {
            targetCluster = DbFacade.getInstance().getVdsGroupDao().get(getParameters().getClusterId());
            if (targetCluster == null) {
                addCanDoActionMessage(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
                return false;
            }
            // Check that the target cluster is in the same data center.
            if (!targetCluster.getStoragePoolId().equals(vm.getStoragePoolId())) {
                addCanDoActionMessage(VdcBllMessages.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
                return false;
            }
            List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
            Version clusterCompatibilityVersion = targetCluster.getcompatibility_version();
            if (!validateDestinationClusterContainsNetworks(interfaces) || !validateNics(interfaces, clusterCompatibilityVersion)) {
                return false;
            }
            // Check if VM static parameters are compatible for new cluster.
            boolean isCpuSocketsValid = AddVmCommand.checkCpuSockets(vm.getStaticData().getNumOfSockets(), vm.getStaticData().getCpuPerSocket(), clusterCompatibilityVersion.getValue(), getReturnValue().getCanDoActionMessages());
            if (!isCpuSocketsValid) {
                return false;
            }
            // Check that the USB policy is legal
            if (!VmHandler.isUsbPolicyLegal(vm.getUsbPolicy(), vm.getOs(), targetCluster, getReturnValue().getCanDoActionMessages())) {
                return false;
            }
            // Check if the display type is supported
            if (!VmHandler.isDisplayTypeSupported(vm.getOs(), vm.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), clusterCompatibilityVersion)) {
                return false;
            }
            if (VmDeviceUtils.isVirtioScsiControllerAttached(vm.getId()) && !FeatureSupported.virtIoScsi(targetCluster.getcompatibility_version())) {
                return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.VM_STATUS_NOT_VALID_FOR_UPDATE);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Set parameters for messaging.
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM__CLUSTER);
    VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    } else {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        if (ObjectIdentityChecker.CanUpdateField(vm, "vdsGroupId", vm.getStatus())) {
            targetCluster = DbFacade.getInstance().getVdsGroupDao().get(getParameters().getClusterId());
            if (targetCluster == null) {
                addCanDoActionMessage(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
                return false;
            }
            // Check that the target cluster is in the same data center.
            if (!targetCluster.getStoragePoolId().equals(vm.getStoragePoolId())) {
                addCanDoActionMessage(VdcBllMessages.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
                return false;
            }
            List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
            Version clusterCompatibilityVersion = targetCluster.getcompatibility_version();
            if (!validateDestinationClusterContainsNetworks(interfaces) || !validateNics(interfaces, clusterCompatibilityVersion)) {
                return false;
            }
            // Check if VM static parameters are compatible for new cluster.
            boolean isCpuSocketsValid = AddVmCommand.checkCpuSockets(vm.getStaticData().getNumOfSockets(), vm.getStaticData().getCpuPerSocket(), clusterCompatibilityVersion.getValue(), getReturnValue().getCanDoActionMessages());
            if (!isCpuSocketsValid) {
                return false;
            }
            // Check that the USB policy is legal
            if (!VmHandler.isUsbPolicyLegal(vm.getUsbPolicy(), vm.getOs(), targetCluster, getReturnValue().getCanDoActionMessages())) {
                return false;
            }
            // Check if the display type is supported
            if (!VmHandler.isDisplayTypeSupported(vm.getOs(), vm.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), clusterCompatibilityVersion)) {
                return false;
            }
            if (VmDeviceUtils.isVirtioScsiControllerAttached(vm.getId()) && !FeatureSupported.virtIoScsi(targetCluster.getcompatibility_version())) {
                return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
            }
            // A existing VM cannot be changed into a cluster without a defined architecture
            if (targetCluster.getArchitecture() == ArchitectureType.undefined) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
            } else if (targetCluster.getArchitecture() != vm.getClusterArch()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_CLUSTER_DIFFERENT_ARCHITECTURES);
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.VM_STATUS_NOT_VALID_FOR_UPDATE);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVmTemplate().getId())) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_EDIT_BLANK_TEMPLATE);
    }
    boolean returnValue = false;
    mOldTemplate = DbFacade.getInstance().getVmTemplateDao().get(getVmTemplate().getId());
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    if (mOldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IS_LOCKED);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName()) && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    } else {
        if (getVdsGroup() == null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CLUSTER_IS_NOT_VALID);
        } else if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && isDomainLegal(getParameters().getVmTemplateData().getDomain(), getReturnValue().getCanDoActionMessages())) {
            returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
            if (!returnValue) {
                addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
            }
        }
    }
    // Check that the USB policy is legal
    if (returnValue) {
        returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    }
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue) {
        returnValue = validate((new VmWatchdogValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isDisplayTypeSupported(getParameters().getVmTemplateData().getOsId(), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateData().getId());
        if (!VmCommand.checkPciAndIdeLimit(getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, new ArrayList<DiskImageBase>(getParameters().getVmTemplateData().getDiskList()), VmDeviceUtils.isVirtioScsiControllerAttached(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
        }
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVmTemplate().getId())) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_EDIT_BLANK_TEMPLATE);
    }
    boolean returnValue = false;
    mOldTemplate = DbFacade.getInstance().getVmTemplateDao().get(getVmTemplate().getId());
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    if (mOldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IS_LOCKED);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName()) && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    } else {
        if (getVdsGroup() == null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CLUSTER_IS_NOT_VALID);
        } else if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && isDomainLegal(getParameters().getVmTemplateData().getDomain(), getReturnValue().getCanDoActionMessages())) {
            returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
            if (!returnValue) {
                addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
            }
        }
    }
    // Check that the USB policy is legal
    if (returnValue) {
        returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    }
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate((new VmWatchdogValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isDisplayTypeSupported(getParameters().getVmTemplateData().getOsId(), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version());
    }
    if (returnValue) {
        returnValue = AddVmCommand.checkCpuSockets(getParameters().getVmTemplateData().getNumOfSockets(), getParameters().getVmTemplateData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateData().getId());
        if (!VmCommand.checkPciAndIdeLimit(getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, new ArrayList<DiskImageBase>(getParameters().getVmTemplateData().getDiskList()), VmDeviceUtils.isVirtioScsiControllerAttached(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), VmDeviceUtils.isBalloonEnabled(getParameters().getVmTemplateData().getId()), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages())) {
            returnValue = false;
        }
    }
    return returnValue;
}
#end_block

#method_before
protected boolean hasWatchdog(Guid templateId) {
    return getParameters().getWatchdog() != null ? true : VmDeviceUtils.hasWatchdog(templateId);
}
#method_after
protected boolean hasWatchdog(Guid templateId) {
    return getParameters().getWatchdog() != null;
}
#end_block

#method_before
public Map<String, Action> loadParametersMetaData() {
    parametersMetaData = new HashMap<String, Action>();
    try {
        InputStream stream = FileUtils.get(RESOURCES_PACKAGE, PARAMS_METADATA);
        if (stream != null) {
            Constructor constructor = new CustomClassLoaderConstructor(Thread.currentThread().getContextClassLoader());
            Object result = new Yaml(constructor).load(stream);
            for (Action action : ((MetaData) result).getActions()) {
                parametersMetaData.put(uriInfo.getBaseUri().getPath() + action.getName(), action);
            }
        } else {
            LOG.error("Parameters metatdata file not found.");
        }
    } catch (Exception e) {
        LOG.error("Loading parameters metatdata failed.", e);
    }
    return parametersMetaData;
}
#method_after
public Map<String, Action> loadParametersMetaData() {
    parametersMetaData = new HashMap<String, Action>();
    try {
        InputStream stream = FileUtils.get(RESOURCES_PACKAGE, PARAMS_METADATA);
        if (stream != null) {
            Constructor constructor = new CustomClassLoaderConstructor(Thread.currentThread().getContextClassLoader());
            Object result = new Yaml(constructor).load(stream);
            /**
             * uriInfo.getBaseUri().getPath() might be: /ovirt-engine/api/ (with trailing '/') or: /ovirt-engine/api
             * (without trailing '/') - depending on the context of the request. The reason for this variability is
             * not clear. In any case - we assume no trailing '/' when creating the action name, so we add a check
             * and eliminate the trailing slash if necessary.
             */
            String baseUri = uriInfo.getBaseUri().getPath();
            if (baseUri.endsWith("/")) {
                baseUri = baseUri.substring(0, baseUri.length() - 1);
            }
            for (Action action : ((MetaData) result).getActions()) {
                parametersMetaData.put(baseUri + action.getName(), action);
            }
        } else {
            LOG.error("Parameters metatdata file not found.");
        }
    } catch (Exception e) {
        LOG.error("Loading parameters metatdata failed.", e);
    }
    return parametersMetaData;
}
#end_block

#method_before
public Collection<DetailedLink> getLinks() throws ClassNotFoundException, IOException {
    // SortedSet<Link> results = new TreeSet<Link>();
    List<DetailedLink> results = new ArrayList<DetailedLink>();
    List<Class<?>> classes = ReflectionHelper.getClasses(RESOURCES_PACKAGE);
    List<String> paths = applicationMode == ApplicationMode.GlusterOnly ? ApiUtils.getGlusterRels(uriInfo) : ApiUtils.getAllRels(uriInfo);
    for (String path : paths) {
        Class<?> resource = findResource(path, classes);
        String entryPointPath = uriInfo.getBaseUri().getPath();
        String prefix = entryPointPath.endsWith("/") ? entryPointPath + path : entryPointPath + "/" + path;
        results.addAll(describe(resource, prefix, new HashMap<String, Type>()));
    }
    return results;
}
#method_after
public Collection<DetailedLink> getLinks() throws ClassNotFoundException, IOException {
    // SortedSet<Link> results = new TreeSet<Link>();
    List<DetailedLink> results = new ArrayList<DetailedLink>();
    List<Class<?>> classes = ReflectionHelper.getClasses(RESOURCES_PACKAGE);
    String entryPointPath = uriInfo.getBaseUri().getPath();
    for (String path : rels) {
        Class<?> resource = findResource(path, classes);
        String prefix = entryPointPath.endsWith("/") ? entryPointPath + path : entryPointPath + "/" + path;
        results.addAll(describe(resource, prefix, new HashMap<String, Type>()));
    }
    return results;
}
#end_block

#method_before
private DetailedLink findUsage(RSDL rsdl, UriInfo uriInfo, String httpMethod) {
    for (DetailedLink link : rsdl.getLinks().getLinks()) {
        if (isMatch(link, uriInfo, httpMethod)) {
            return link;
        }
    }
    // should never happen
    return null;
}
#method_after
private DetailedLink findUsage(RSDL rsdl, UriInfo uriInfo, String httpMethod) {
    DetailedLink link = null;
    for (DetailedLink currentLink : rsdl.getLinks().getLinks()) {
        if (isMatch(currentLink, uriInfo, httpMethod)) {
            link = currentLink;
            break;
        }
    }
    assert (link != null) : "Corresponding link not found (this should not happen)";
    return link;
}
#end_block

#method_before
private RSDL getRSDL(Application application) {
    for (Object obj : application.getSingletons()) {
        if (obj instanceof BackendApiResource) {
            BackendApiResource resource = (BackendApiResource) obj;
            return resource.getRSDL();
        }
    }
    // should never happen
    return null;
}
#method_after
private RSDL getRSDL(Application application) {
    RSDL rsdl = null;
    for (Object obj : application.getSingletons()) {
        if (obj instanceof BackendApiResource) {
            BackendApiResource resource = (BackendApiResource) obj;
            rsdl = resource.getRSDL();
            break;
        }
    }
    assert (rsdl != null) : "Resource that generates RSDL, BackendApiResource, not found (this should never happen)";
    return rsdl;
}
#end_block

#method_before
private boolean isMatch(DetailedLink link, UriInfo uriInfo, String httpMethod) {
    int baseUriLength = uriInfo.getBaseUri().getPath().length();
    // e.g: [vms, {vm:id}, start]
    String[] linkPathSegments = link.getHref().substring(baseUriLength).split("/");
    // e.g: [vms, f26b0918-8e16-4915-b1c2-7f39e568de23, start]
    List<PathSegment> uriPathSegments = uriInfo.getPathSegments();
    return isMatchLength(linkPathSegments, uriPathSegments) && isMatchePath(linkPathSegments, uriPathSegments) && isMatchRel(link.getRel(), httpMethod);
}
#method_after
private boolean isMatch(DetailedLink link, UriInfo uriInfo, String httpMethod) {
    int baseUriLength = uriInfo.getBaseUri().getPath().length();
    // e.g: [vms, {vm:id}, start]
    String[] linkPathSegments = link.getHref().substring(baseUriLength).split("/");
    // e.g: [vms, f26b0918-8e16-4915-b1c2-7f39e568de23, start]
    List<PathSegment> uriPathSegments = uriInfo.getPathSegments();
    return isMatchLength(linkPathSegments, uriPathSegments) && isMatchPath(linkPathSegments, uriPathSegments) && isMatchRel(link.getRel(), httpMethod);
}
#end_block

#method_before
private Collection<DetailedLink> getLinks() {
    return ApiUtils.getLinks(getUriInfo());
}
#method_after
private Collection<DetailedLink> getLinks() {
    return ApiRootLinksCreator.getLinks(getUriInfo());
}
#end_block

#method_before
private Collection<DetailedLink> getGlusterLinks() {
    return ApiUtils.getGlusterLinks(getUriInfo());
}
#method_after
private Collection<DetailedLink> getGlusterLinks() {
    return ApiRootLinksCreator.getGlusterLinks(getUriInfo());
}
#end_block

#method_before
public synchronized RSDL getRSDL() {
    if (rsdl == null) {
        rsdl = new RsdlBuilder(getUriInfo(), getCurrent().get(ApplicationMode.class)).description(RSDL_DESCRIPTION).rel(RSDL_REL).href(getUriInfo().getBaseUri().getPath() + QUERY_PARAMETER + RSDL_CONSTRAINT_PARAMETER).schema(new SchemaBuilder().rel(SCHEMA_REL).href(getUriInfo().getBaseUri().getPath() + QUERY_PARAMETER + SCHEMA_CONSTRAINT_PARAMETER).name(SCHEMA_NAME).description(SCHEMA_DESCRIPTION).build()).generalMetadata(new GeneralMetadataBuilder().rel(GENERAL_METADATA_REL).href(getUriInfo().getBaseUri().getPath().replace("api", "*")).name(GENERAL_METADATA_NAME).description(GENERAL_METADATA_DESCRIPTION).build()).build();
    }
    return rsdl;
}
#method_after
public synchronized RSDL getRSDL() {
    if (rsdl == null) {
        List<String> rels = getCurrent().get(ApplicationMode.class) == ApplicationMode.GlusterOnly ? ApiRootLinksCreator.getGlusterRels(uriInfo) : ApiRootLinksCreator.getAllRels(uriInfo);
        rsdl = new RsdlBuilder(getUriInfo(), rels).description(RSDL_DESCRIPTION).rel(RSDL_REL).href(getUriInfo().getBaseUri().getPath() + QUERY_PARAMETER + RSDL_CONSTRAINT_PARAMETER).schema(new SchemaBuilder().rel(SCHEMA_REL).href(getUriInfo().getBaseUri().getPath() + QUERY_PARAMETER + SCHEMA_CONSTRAINT_PARAMETER).name(SCHEMA_NAME).description(SCHEMA_DESCRIPTION).build()).generalMetadata(new GeneralMetadataBuilder().rel(GENERAL_METADATA_REL).href(getUriInfo().getBaseUri().getPath().replace("api", "*")).name(GENERAL_METADATA_NAME).description(GENERAL_METADATA_DESCRIPTION).build()).build();
    }
    return rsdl;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (disk == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk && ((DiskImage) disk).getImageStatus() == ImageStatus.ILLEGAL) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
    }
    if (isImageDisk && ((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED);
        addCanDoActionMessage(String.format("$%1$s %2$s", "diskAliases", disk.getDiskAlias()));
        return false;
    }
    if (!isVmExist() || !isVmInUpPausedDownStatus()) {
        return false;
    }
    updateDisksFromDb();
    if (!isDiskCanBeAddedToVm(disk, getVm()) || !isDiskPassPciAndIdeLimit(disk)) {
        return false;
    }
    if (getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (!disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = getStorageDomainDAO().getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    DiskValidator diskValidator = new DiskValidator(disk);
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm().getOs(), getVm().getVdsGroupCompatibilityVersion()))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return isOsSupportingHotPlug() && isHotPlugSupported() && isInterfaceSupportedForPlugUnPlug(disk);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (disk == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    if (isOperationPerformedOnDiskSnapshot() && (!validate(getSnapshotsValidator().snapshotExists(getSnapshot())) || !validate(getSnapshotsValidator().snapshotTypeSupported(getSnapshot(), Collections.singletonList(SnapshotType.REGULAR))))) {
        return false;
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk) {
        // TODO : this load and check of the active disk will be removed
        // after inspecting upgrade
        Disk activeDisk = loadActiveDisk(disk.getId());
        if (((DiskImage) activeDisk).getImageStatus() == ImageStatus.ILLEGAL) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        }
        if (((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED);
            addCanDoActionMessage(String.format("$%1$s %2$s", "diskAliases", disk.getDiskAlias()));
            return false;
        }
    }
    if (!isVmExist() || !isVmInUpPausedDownStatus()) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    updateDisksFromDb();
    if (!isDiskCanBeAddedToVm(disk, getVm()) || !isDiskPassPciAndIdeLimit(disk)) {
        return false;
    }
    if (getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (!isOperationPerformedOnDiskSnapshot() && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = getStorageDomainDAO().getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    DiskValidator diskValidator = getDiskValidator(disk);
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return canPerformDiskHotPlug(disk);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    final VmDevice vmDevice = createVmDevice();
    getVmDeviceDao().save(vmDevice);
    // update cached image
    List<Disk> imageList = new ArrayList<Disk>();
    imageList.add(disk);
    VmHandler.updateDisksForVm(getVm(), imageList);
    if (disk.isAllowSnapshot()) {
        updateDiskVmSnapshotId();
    }
    // update vm device boot order
    updateBootOrderInVmDevice();
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        performPlugCommand(VDSCommandType.HotPlugDisk, disk, vmDevice);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (!isOperationPerformedOnDiskSnapshot()) {
        getVmStaticDAO().incrementDbGeneration(getVm().getId());
    }
    final VmDevice vmDevice = createVmDevice();
    getVmDeviceDao().save(vmDevice);
    // update cached image
    List<Disk> imageList = new ArrayList<Disk>();
    imageList.add(disk);
    VmHandler.updateDisksForVm(getVm(), imageList);
    if (!isOperationPerformedOnDiskSnapshot()) {
        if (disk.isAllowSnapshot()) {
            updateDiskVmSnapshotId();
        }
    }
    // update vm device boot order
    updateBootOrderInVmDevice();
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        performPlugCommand(VDSCommandType.HotPlugDisk, disk, vmDevice);
    }
    setSucceeded(true);
}
#end_block

#method_before
protected VmDevice createVmDevice() {
    return new VmDevice(new VmDeviceId(disk.getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), "", 0, null, true, getParameters().isPlugUnPlug(), false, "", null);
}
#method_after
protected VmDevice createVmDevice() {
    return new VmDevice(new VmDeviceId(disk.getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), "", 0, null, true, getParameters().isPlugUnPlug(), getParameters().isReadOnly(), "", null, getParameters().getSnapshotId());
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<Disk> diskList = DbFacade.getInstance().getDiskDao().getAllAttachableDisksByPoolId(getParameters().getStoragePoolId(), getParameters().getVmId(), getUserID(), getParameters().isFiltered());
    ArrayList<Disk> filteredDiskList = new ArrayList<Disk>();
    VM vm = DbFacade.getInstance().getVmDao().get(getParameters().getVmId());
    List<String> supportedDiskInterfaceNames = getOsRepository().getDiskInterfaces(vm.getOs(), vm.getVdsGroupCompatibilityVersion());
    List<DiskInterface> supportedDiskInterfaces = new ArrayList<DiskInterface>();
    for (String interfaceName : supportedDiskInterfaceNames) {
        try {
            supportedDiskInterfaces.add(DiskInterface.valueOf(interfaceName));
        } catch (IllegalArgumentException e) {
        // ignore if we can't find the enum value.
        }
    }
    for (Disk disk : diskList) {
        if (supportedDiskInterfaces.contains(disk.getDiskInterface())) {
            filteredDiskList.add(disk);
        }
    }
    setReturnValue(filteredDiskList);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<Disk> diskList = DbFacade.getInstance().getDiskDao().getAllAttachableDisksByPoolId(getParameters().getStoragePoolId(), getParameters().getVmId(), getUserID(), getParameters().isFiltered());
    if (CollectionUtils.isEmpty(diskList)) {
        setReturnValue(new ArrayList<>());
        return;
    }
    VM vm = DbFacade.getInstance().getVmDao().get(getParameters().getVmId(), getUserID(), getParameters().isFiltered());
    if (vm == null) {
        setReturnValue(new ArrayList<>());
        return;
    }
    List<Disk> filteredDiskList = new ArrayList<>();
    for (Disk disk : diskList) {
        if (VmValidationUtils.isDiskInterfaceSupportedByOs(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), disk.getDiskInterface())) {
            filteredDiskList.add(disk);
        }
    }
    setReturnValue(filteredDiskList);
}
#end_block

#method_before
public OsRepository getOsRepository() {
    return SimpleDependecyInjector.getInstance().get(OsRepository.class);
}
#method_after
protected OsRepository getOsRepository() {
    return SimpleDependecyInjector.getInstance().get(OsRepository.class);
}
#end_block

#method_before
public ValidationResult isVirtIoScsiValid(VM vm) {
    if (DiskInterface.VirtIO_SCSI != disk.getDiskInterface()) {
        return ValidationResult.VALID;
    }
    if (disk.getSgio() != null) {
        if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
            return new ValidationResult(VdcBllMessages.SCSI_GENERIC_IO_IS_NOT_SUPPORTED_FOR_IMAGE_DISK);
        }
    }
    if (vm != null) {
        if (!FeatureSupported.virtIoScsi(vm.getVdsGroupCompatibilityVersion())) {
            return new ValidationResult(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        return isOsSupportedForVirtIoScsi(vm);
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult isVirtIoScsiValid(VM vm) {
    if (DiskInterface.VirtIO_SCSI != disk.getDiskInterface()) {
        return ValidationResult.VALID;
    }
    if (disk.getSgio() != null) {
        if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
            return new ValidationResult(VdcBllMessages.SCSI_GENERIC_IO_IS_NOT_SUPPORTED_FOR_IMAGE_DISK);
        }
    }
    if (vm != null) {
        if (!FeatureSupported.virtIoScsi(vm.getVdsGroupCompatibilityVersion())) {
            return new ValidationResult(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        if (!isVirtioScsiControllerAttached(vm.getId())) {
            return new ValidationResult(VdcBllMessages.CANNOT_PERFORM_ACTION_VIRTIO_SCSI_IS_DISABLED);
        }
        return isOsSupportedForVirtIoScsi(vm);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult isOsSupportedForVirtIoScsi(VM vm) {
    // TODO move this config val to osinfo
    final List<String> unsupportedOSs = Config.<List<String>>GetValue(ConfigValues.VirtIoScsiUnsupportedOsList);
    String vmOs = SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(vm.getVmOsId());
    for (String os : unsupportedOSs) {
        if (os.equalsIgnoreCase(vmOs)) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult isOsSupportedForVirtIoScsi(VM vm) {
    if (!VmValidationUtils.isDiskInterfaceSupportedByOs(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), DiskInterface.VirtIO_SCSI)) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult isDiskInterfaceSupported(int osId, Version version) {
    List<String> supportedDiskInterfaceNames = getOsRepository().getDiskInterfaces(osId, version);
    List<DiskInterface> supportedDiskInterfaces = new ArrayList<DiskInterface>();
    for (String interfaceName : supportedDiskInterfaceNames) {
        try {
            supportedDiskInterfaces.add(DiskInterface.valueOf(interfaceName));
        } catch (IllegalArgumentException e) {
        // ignore if we can't find the enum value.
        }
    }
    return (!supportedDiskInterfaces.contains(disk.getDiskInterface())) ? new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED) : ValidationResult.VALID;
}
#method_after
public ValidationResult isDiskInterfaceSupported(VM vm) {
    if (vm != null) {
        if (!VmValidationUtils.isDiskInterfaceSupportedByOs(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), disk.getDiskInterface())) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED, String.format("$osName %s", getOsRepository().getOsName(vm.getOs())));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public OsRepository getOsRepository() {
    return SimpleDependecyInjector.getInstance().get(OsRepository.class);
}
#method_after
private static OsRepository getOsRepository() {
    return SimpleDependecyInjector.getInstance().get(OsRepository.class);
}
#end_block

#method_before
private void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.ImageLocked);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setAppList(getParameters().getVm().getDynamicData().getAppList());
    getVmDynamicDAO().save(tempVar);
    getCompensationContext().snapshotNewEntity(tempVar);
}
#method_after
private void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.ImageLocked);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setLastStopTime(new Date());
    tempVar.setAppList(getParameters().getVm().getDynamicData().getAppList());
    getVmDynamicDAO().save(tempVar);
    getCompensationContext().snapshotNewEntity(tempVar);
}
#end_block

#method_before
protected <P extends VdcActionParametersBase> P sessionize(P parameters) {
    return sessionHelper.sessionize(parameters);
}
#method_after
protected <P extends VdcQueryParametersBase> P sessionize(P parameters) {
    return sessionHelper.sessionize(parameters);
}
#end_block

#method_before
private void addVideoCardByDisplayType(DisplayType displayType, int numOfMonitors, boolean singleQxlPci) {
    Map<String, Object> struct = new HashMap<String, Object>();
    VmDeviceType vmDeviceType = getOsRepository().getDisplayDevice(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), displayType);
    // create a monitor as an unmanaged device
    struct.put(VdsProperties.Type, VmDeviceGeneralType.VIDEO.getValue());
    struct.put(VdsProperties.Device, vmDeviceType);
    struct.put(VdsProperties.SpecParams, getNewMonitorSpecParams(displayType, numOfMonitors, singleQxlPci));
    struct.put(VdsProperties.DeviceId, String.valueOf(Guid.newGuid()));
    devices.add(struct);
}
#method_after
private void addVideoCardByDisplayType(DisplayType displayType, int numOfMonitors, boolean singleQxlPci) {
    Map<String, Object> struct = new HashMap<String, Object>();
    VmDeviceType vmDeviceType = getOsRepository().getDisplayDevice(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), displayType);
    // create a monitor as an unmanaged device
    struct.put(VdsProperties.Type, VmDeviceGeneralType.VIDEO.getValue());
    struct.put(VdsProperties.Device, vmDeviceType.getName());
    struct.put(VdsProperties.SpecParams, getNewMonitorSpecParams(displayType, numOfMonitors, singleQxlPci));
    struct.put(VdsProperties.DeviceId, String.valueOf(Guid.newGuid()));
    devices.add(struct);
}
#end_block

#method_before
private OsRepository getOsRepository() {
    return SimpleDependecyInjector.getInstance().get(OsRepository.class);
}
#method_after
private static OsRepository getOsRepository() {
    return SimpleDependecyInjector.getInstance().get(OsRepository.class);
}
#end_block

#method_before
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.CDROM) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct);
        addDevice(struct, vmDevice, "");
    }
    // check first if CD was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            struct = new HashMap<String, Object>();
            String cdPath = vm.getCdPath();
            addCdDetails(vmDevice, struct);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
}
#method_after
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.CDROM) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, "");
    }
    // check first if CD was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            struct = new HashMap<String, Object>();
            String cdPath = vm.getCdPath();
            addCdDetails(vmDevice, struct, vm);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmFloppy() {
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.FLOPPY) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct);
        addDevice(struct, vmDevice, "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            Map<String, Object> struct = new HashMap<String, Object>();
            String file = vm.getFloppyPath();
            addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#method_after
@Override
protected void buildVmFloppy() {
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.FLOPPY) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            Map<String, Object> struct = new HashMap<String, Object>();
            String file = vm.getFloppyPath();
            addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<String, Object>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForVirtioScsiDisk(unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#method_after
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<String, Object>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
@Override
protected void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Map.Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), Base64.encodeBase64String(entry.getValue()));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addCdDetails(vmDevice, struct);
    addDevice(struct, vmDevice, "");
}
#method_after
@Override
protected void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Map.Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), Base64.encodeBase64String(entry.getValue()));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addCdDetails(vmDevice, struct, vm);
    addDevice(struct, vmDevice, "");
}
#end_block

#method_before
private static boolean addQosForDevice(Map<String, Object> struct, VnicProfile vnicProfile, Version vdsGroupCompatibilityVersion) {
    if (vnicProfile.getNetworkQosId() != null) {
        if (!FeatureSupported.networkQoS(vdsGroupCompatibilityVersion)) {
            return false;
        }
        NetworkQoS networkQoS = DbFacade.getInstance().getQosDao().get(vnicProfile.getNetworkQosId());
        if (networkQoS != null) {
            Map<String, Object> specParams = (Map<String, Object>) struct.get(VdsProperties.SpecParams);
            if (specParams == null) {
                specParams = new HashMap<>();
                struct.put(VdsProperties.SpecParams, specParams);
            }
            addQosData(specParams, VdsProperties.QOS_INBOUND, networkQoS.getInboundAverage(), networkQoS.getInboundPeak(), networkQoS.getInboundBurst());
            addQosData(specParams, VdsProperties.QOS_OUTBOUND, networkQoS.getOutboundAverage(), networkQoS.getOutboundPeak(), networkQoS.getOutboundBurst());
        }
    }
    return true;
}
#method_after
private static boolean addQosForDevice(Map<String, Object> struct, VnicProfile vnicProfile, Version vdsGroupCompatibilityVersion) {
    Guid qosId = vnicProfile.getNetworkQosId();
    if (qosId != null) {
        if (!FeatureSupported.networkQoS(vdsGroupCompatibilityVersion)) {
            return false;
        }
        Map<String, Object> specParams = (Map<String, Object>) struct.get(VdsProperties.SpecParams);
        if (specParams == null) {
            specParams = new HashMap<>();
            struct.put(VdsProperties.SpecParams, specParams);
        }
        NetworkQoS networkQoS = DbFacade.getInstance().getQosDao().get(qosId);
        NetworkQosMapper qosMapper = new NetworkQosMapper(specParams, VdsProperties.QOS_INBOUND, VdsProperties.QOS_OUTBOUND);
        qosMapper.serialize(networkQoS);
    }
    return true;
}
#end_block

#method_before
private static void addCdDetails(VmDevice vmDevice, Map<String, Object> struct) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    // IDE slot 2 is reserved by VDSM to CDROM
    struct.put(VdsProperties.Index, "2");
    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
    struct.put(VdsProperties.ReadOnly, Boolean.TRUE.toString());
    struct.put(VdsProperties.Shareable, Boolean.FALSE.toString());
}
#method_after
private static void addCdDetails(VmDevice vmDevice, Map<String, Object> struct, VM vm) {
    OsRepository osRepository = getOsRepository();
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getVdsGroupCompatibilityVersion());
    if ("scsi".equals(cdInterface)) {
        // SCSI unit 0 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "0");
        struct.put(VdsProperties.Address, createAddressForScsiDisk(0, 0));
    } else if ("ide".equals(cdInterface)) {
        // IDE slot 2 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "2");
    }
    struct.put(VdsProperties.INTERFACE, cdInterface);
    struct.put(VdsProperties.ReadOnly, Boolean.TRUE.toString());
    struct.put(VdsProperties.Shareable, Boolean.FALSE.toString());
}
#end_block

#method_before
@Override
protected void buildVmVirtioScsi() {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        struct.put(VdsProperties.Device, VdsProperties.Scsi);
        struct.put(VdsProperties.Model, VdsProperties.VirtioScsi);
        addAddress(vmDevice, struct);
        addDevice(struct, vmDevice, null);
    }
}
#method_after
@Override
protected void buildVmVirtioScsi() {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName());
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        struct.put(VdsProperties.Device, VdsProperties.Scsi);
        struct.put(VdsProperties.Model, VdsProperties.VirtioScsi);
        struct.put(VdsProperties.Index, Integer.toString(virtioScsiIndex));
        addAddress(vmDevice, struct);
        virtioScsiIndex++;
        addDevice(struct, vmDevice, null);
    }
}
#end_block

#method_before
public static Map<VmDevice, Integer> getVmDeviceUnitMapForVirtioScsiDisks(VM vm) {
    List<Disk> disks = new ArrayList<Disk>(vm.getDiskMap().values());
    Map<VmDevice, Integer> vmDeviceUnitMap = new HashMap<>();
    Map<VmDevice, Disk> vmDeviceDiskMap = new HashMap<>();
    for (Disk disk : disks) {
        if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
            VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
            Map<String, String> address = XmlRpcStringUtils.string2Map(vmDevice.getAddress());
            String unitStr = address.get(VdsProperties.Unit);
            // Otherwise, adding to 'vmDeviceDiskMap' for setting the unit property later.
            if (StringUtils.isNotEmpty(unitStr)) {
                vmDeviceUnitMap.put(vmDevice, Integer.valueOf(unitStr));
            } else {
                vmDeviceDiskMap.put(vmDevice, disk);
            }
        }
    }
    // Find available unit (disk's index in VirtIO-SCSI controller) for disks with empty address
    for (Entry<VmDevice, Disk> entry : vmDeviceDiskMap.entrySet()) {
        int unit = getAvailableUnitForVirtioScsiDisk(vmDeviceUnitMap);
        vmDeviceUnitMap.put(entry.getKey(), unit);
    }
    return vmDeviceUnitMap;
}
#method_after
public static Map<VmDevice, Integer> getVmDeviceUnitMapForVirtioScsiDisks(VM vm) {
    return getVmDeviceUnitMapForScsiDisks(vm, DiskInterface.VirtIO_SCSI, false);
}
#end_block

#method_before
private static List<VmDevice> getPluggedInterfaces(List<VmDevice> devices) {
    ArrayList<VmDevice> result = new ArrayList<VmDevice>();
    for (VmDevice device : devices) {
        if (isBridge(device) && device.getIsPlugged()) {
            result.add(device);
        }
    }
    return result;
}
#method_after
private static List<VmDevice> getPluggedInterfaces(List<VmDevice> devices) {
    List<VmDevice> result = new ArrayList<VmDevice>();
    for (VmDevice device : devices) {
        if (isBridge(device) && device.getIsPlugged()) {
            result.add(device);
        }
    }
    return result;
}
#end_block

#method_before
private static List<VmDevice> sortInterfacesByName(VM vm, List<VmDevice> pluggedInterfaces) {
    if (pluggedInterfaces.size() < 2) {
        return pluggedInterfaces;
    }
    final HashMap<Guid, String> deviceIdToIfaceName = new HashMap<Guid, String>();
    for (VmNetworkInterface iface : vm.getInterfaces()) {
        deviceIdToIfaceName.put(iface.getId(), iface.getName());
    }
    Collections.sort(pluggedInterfaces, new Comparator<VmDevice>() {

        @Override
        public int compare(VmDevice first, VmDevice second) {
            Guid firstDeviceId = first.getId().getDeviceId();
            Guid secondDeviceId = second.getId().getDeviceId();
            String firstIfaceName = deviceIdToIfaceName.get(firstDeviceId);
            String secondIfaceName = deviceIdToIfaceName.get(secondDeviceId);
            return firstIfaceName.compareTo(secondIfaceName);
        }
    });
    return pluggedInterfaces;
}
#method_after
private static List<VmDevice> sortInterfacesByName(VM vm, List<VmDevice> pluggedInterfaces) {
    if (pluggedInterfaces.size() < 2) {
        return pluggedInterfaces;
    }
    final Map<Guid, String> deviceIdToIfaceName = new HashMap<Guid, String>();
    for (VmNetworkInterface iface : vm.getInterfaces()) {
        deviceIdToIfaceName.put(iface.getId(), iface.getName());
    }
    Collections.sort(pluggedInterfaces, new Comparator<VmDevice>() {

        @Override
        public int compare(VmDevice first, VmDevice second) {
            Guid firstDeviceId = first.getId().getDeviceId();
            Guid secondDeviceId = second.getId().getDeviceId();
            String firstIfaceName = deviceIdToIfaceName.get(firstDeviceId);
            String secondIfaceName = deviceIdToIfaceName.get(secondDeviceId);
            return firstIfaceName.compareTo(secondIfaceName);
        }
    });
    return pluggedInterfaces;
}
#end_block

#method_before
public void setName(EntityModel<String> name) {
    this.name = name;
}
#method_after
private void setName(EntityModel<String> name) {
    this.name = name;
}
#end_block

#method_before
public void setCidr(EntityModel<String> cidr) {
    this.cidr = cidr;
}
#method_after
private void setCidr(EntityModel<String> cidr) {
    this.cidr = cidr;
}
#end_block

#method_before
public ListModel<NetworkView> getNetwork() {
    return network;
}
#method_after
public EntityModel<NetworkView> getNetwork() {
    return network;
}
#end_block

#method_before
public void setNetwork(ListModel<NetworkView> network) {
    this.network = network;
}
#method_after
private void setNetwork(ListModel<NetworkView> network) {
    this.network = network;
}
#end_block

#method_before
public void setIpVersion(ListModel<IpVersion> ipVersion) {
    this.ipVersion = ipVersion;
}
#method_after
private void setIpVersion(ListModel<IpVersion> ipVersion) {
    this.ipVersion = ipVersion;
}
#end_block

#method_before
private void onSave() {
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    flush();
    startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddSubnetToProvider, new AddExternalSubnetParameters(subnet, getNetwork().getSelectedItem().getId()), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
            }
        }
    }, this, true);
}
#method_after
private void onSave() {
    if (!validate()) {
        return;
    }
    // Save changes.
    flush();
    startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddSubnetToProvider, new AddExternalSubnetParameters(subnet, getNetwork().getEntity().getId()), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
            }
        }
    }, this, true);
}
#end_block

#method_before
public void flush() {
    if (subnet == null) {
        subnet = new ExternalSubnet();
    }
    subnet.setName(getName().getEntity());
    Network network = getNetwork().getSelectedItem();
    subnet.setExternalNetwork(network != null ? network.getProvidedBy() : null);
    subnet.setCidr(getCidr().getEntity());
    subnet.setIpVersion(getIpVersion().getSelectedItem());
}
#method_after
public void flush() {
    subnet = new ExternalSubnet();
    subnet.setName(getName().getEntity());
    Network network = getNetwork().getEntity();
    subnet.setExternalNetwork(network.getProvidedBy());
    subnet.setCidr(getCidr().getEntity());
    subnet.setIpVersion(getIpVersion().getSelectedItem());
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if ("OnSave".equals(command.getName())) {
        // $NON-NLS-1$
        onSave();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    }
}
#end_block

#method_before
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new AsciiNameValidation() });
    List<IValidation> cidrValidations = new ArrayList<IValidation>();
    cidrValidations.add(new NotEmptyValidation());
    if (getIpVersion().getSelectedItem() == IpVersion.IPV4) {
        cidrValidations.add(new CidrValidation());
    }
    getCidr().validateEntity(cidrValidations.toArray(new IValidation[0]));
    getIpVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    return getName().getIsValid() && getCidr().getIsValid() && getIpVersion().getIsValid();
}
#method_after
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new AsciiNameValidation() });
    getCidr().validateEntity(new IValidation[] { getIpVersion().getSelectedItem() == IpVersion.IPV4 ? new CidrValidation() : new NotEmptyValidation() });
    getIpVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    return getName().getIsValid() && getCidr().getIsValid() && getIpVersion().getIsValid();
}
#end_block

#method_before
public boolean validate() {
    RegexValidation tempVar = new RegexValidation();
    // $NON-NLS-1$
    tempVar.setExpression("^[A-Za-z0-9_]{1,15}$");
    tempVar.setMessage(ConstantsManager.getInstance().getConstants().nameMustContainAlphanumericMaxLenMsg());
    RegexValidation tempVar2 = new RegexValidation();
    tempVar2.setIsNegate(true);
    // $NON-NLS-1$
    tempVar2.setExpression("^(bond)");
    tempVar2.setMessage(ConstantsManager.getInstance().getConstants().networkNameStartMsg());
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar, tempVar2 });
    LengthValidation tempVar3 = new LengthValidation();
    tempVar3.setMaxLength(40);
    getDescription().validateEntity(new IValidation[] { tempVar3 });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getVLanTag().setIsValid(true);
    if ((Boolean) getHasVLanTag().getEntity()) {
        IntegerValidation tempVar4 = new IntegerValidation();
        tempVar4.setMinimum(0);
        tempVar4.setMaximum(4094);
        getVLanTag().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar4 });
    }
    getMtu().setIsValid(true);
    if ((Boolean) getHasMtu().getEntity()) {
        IntegerValidation tempVar5 = new IntegerValidation();
        tempVar5.setMinimum(68);
        tempVar5.setMaximum(9000);
        getMtu().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar5 });
    }
    getExternalProviders().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getSubnetName().validateEntity(new IValidation[] { new AsciiNameValidation() });
    getSubnetCidr().setIsValid(true);
    getSubnetIpVersion().setIsValid(true);
    if (getSubnetName().getEntity() != null && !getSubnetName().getEntity().isEmpty()) {
        List<IValidation> cidrValidations = new ArrayList<IValidation>();
        cidrValidations.add(new NotEmptyValidation());
        if (getSubnetIpVersion().getSelectedItem() == IpVersion.IPV4) {
            cidrValidations.add(new CidrValidation());
        }
        getSubnetCidr().validateEntity(cidrValidations.toArray(new IValidation[0]));
        getSubnetIpVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean profilesValid = true;
    Iterable<VnicProfileModel> profiles = getProfiles().getItems();
    for (VnicProfileModel profileModel : profiles) {
        if (!profileModel.validate()) {
            profilesValid = false;
        }
    }
    return getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && getSubnetName().getIsValid() && getSubnetCidr().getIsValid() && getSubnetIpVersion().getIsValid() && profilesValid;
}
#method_after
public boolean validate() {
    RegexValidation tempVar = new RegexValidation();
    // $NON-NLS-1$
    tempVar.setExpression("^[A-Za-z0-9_]{1,15}$");
    tempVar.setMessage(ConstantsManager.getInstance().getConstants().nameMustContainAlphanumericMaxLenMsg());
    RegexValidation tempVar2 = new RegexValidation();
    tempVar2.setIsNegate(true);
    // $NON-NLS-1$
    tempVar2.setExpression("^(bond)");
    tempVar2.setMessage(ConstantsManager.getInstance().getConstants().networkNameStartMsg());
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar, tempVar2 });
    LengthValidation tempVar3 = new LengthValidation();
    tempVar3.setMaxLength(40);
    getDescription().validateEntity(new IValidation[] { tempVar3 });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getVLanTag().setIsValid(true);
    if ((Boolean) getHasVLanTag().getEntity()) {
        IntegerValidation tempVar4 = new IntegerValidation();
        tempVar4.setMinimum(0);
        tempVar4.setMaximum(4094);
        getVLanTag().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar4 });
    }
    getMtu().setIsValid(true);
    if ((Boolean) getHasMtu().getEntity()) {
        IntegerValidation tempVar5 = new IntegerValidation();
        tempVar5.setMinimum(68);
        tempVar5.setMaximum(9000);
        getMtu().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar5 });
    }
    getExternalProviders().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getSubnetName().validateEntity(new IValidation[] { new AsciiNameValidation() });
    if (getSubnetName().getEntity() != null && !getSubnetName().getEntity().isEmpty()) {
        getSubnetCidr().validateEntity(new IValidation[] { getSubnetIpVersion().getSelectedItem() == IpVersion.IPV4 ? new CidrValidation() : new NotEmptyValidation() });
        getSubnetIpVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean profilesValid = true;
    Iterable<VnicProfileModel> profiles = getProfiles().getItems();
    for (VnicProfileModel profileModel : profiles) {
        if (!profileModel.validate()) {
            profilesValid = false;
        }
    }
    return getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && getSubnetName().getIsValid() && getSubnetCidr().getIsValid() && getSubnetIpVersion().getIsValid() && profilesValid;
}
#end_block

#method_before
public void syncWithBackend() {
    final StoragePool dc = getSelectedDc();
    if (dc == null) {
        return;
    }
    // Get IsSupportBridgesReportByVDSM
    boolean isSupportBridgesReportByVDSM = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.SupportBridgesReportByVDSM, dc.getcompatibility_version().toString());
    setSupportBridgesReportByVDSM(isSupportBridgesReportByVDSM);
    // Get IsMTUOverrideSupported
    boolean isMTUOverrideSupported = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MTUOverrideSupported, dc.getcompatibility_version().toString());
    setMTUOverrideSupported(isMTUOverrideSupported);
    onExportChanged();
    getProfiles().updateDcId(dc.getId());
}
#method_after
public void syncWithBackend() {
    final StoragePool dc = getSelectedDc();
    if (dc == null) {
        return;
    }
    // Get IsSupportBridgesReportByVDSM
    boolean isSupportBridgesReportByVDSM = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.SupportBridgesReportByVDSM, dc.getcompatibility_version().toString());
    setSupportBridgesReportByVDSM(isSupportBridgesReportByVDSM);
    // Get IsMTUOverrideSupported
    boolean isMTUOverrideSupported = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MTUOverrideSupported, dc.getcompatibility_version().toString());
    setMTUOverrideSupported(isMTUOverrideSupported);
    AsyncQuery query = new AsyncQuery();
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Iterable<NetworkQoS> qos = (Iterable<NetworkQoS>) returnValue;
            getQos().setItems(qos);
            getQos().setSelectedItem(Linq.findNetworkQosById(qos, getNetwork().getQosId()));
        }
    };
    AsyncDataProvider.getAllNetworkQos(dc.getId(), query);
    onExportChanged();
    getProfiles().updateDcId(dc.getId());
}
#end_block

#method_before
protected void addCommands() {
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("OnSave", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar2.setIsDefault(true);
    getCommands().add(tempVar2);
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("Cancel", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar3.setIsCancel(true);
    getCommands().add(tempVar3);
}
#method_after
private void addCommands() {
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("OnSave", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar2.setIsDefault(true);
    getCommands().add(tempVar2);
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("Cancel", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar3.setIsCancel(true);
    getCommands().add(tempVar3);
    // $NON-NLS-1$
    addQosCommand = new UICommand("AddQos", this);
    addQosCommand.setTitle(ConstantsManager.getInstance().getConstants().newNetworkQosButton());
}
#end_block

#method_before
public void flush() {
    network.setDataCenterId(getSelectedDc().getId());
    network.setName((String) getName().getEntity());
    network.setStp((Boolean) getIsStpEnabled().getEntity());
    network.setDescription((String) getDescription().getEntity());
    network.setLabel((String) getNetworkLabel().getEntity());
    network.setComment((String) getComment().getEntity());
    network.setVmNetwork((Boolean) getIsVmNetwork().getEntity());
    network.setMtu(0);
    if ((Boolean) getHasMtu().getEntity()) {
        network.setMtu(Integer.parseInt(getMtu().getEntity().toString()));
    }
    network.setVlanId(null);
    if ((Boolean) getHasVLanTag().getEntity()) {
        network.setVlanId(Integer.parseInt(getVLanTag().getEntity().toString()));
    }
    for (VnicProfileModel profileModel : getProfiles().getItems()) {
        profileModel.flush();
    }
}
#method_after
public void flush() {
    network.setDataCenterId(getSelectedDc().getId());
    network.setName((String) getName().getEntity());
    network.setStp((Boolean) getIsStpEnabled().getEntity());
    network.setDescription((String) getDescription().getEntity());
    network.setLabel((String) getNetworkLabel().getEntity());
    network.setComment((String) getComment().getEntity());
    network.setVmNetwork((Boolean) getIsVmNetwork().getEntity());
    network.setMtu(0);
    if ((Boolean) getHasMtu().getEntity()) {
        network.setMtu(Integer.parseInt(getMtu().getEntity().toString()));
    }
    network.setVlanId(null);
    if ((Boolean) getHasVLanTag().getEntity()) {
        network.setVlanId(Integer.parseInt(getVLanTag().getEntity().toString()));
    }
    for (VnicProfileModel profileModel : getProfiles().getItems()) {
        profileModel.flush();
    }
    if (getQos().getIsChangable()) {
        NetworkQoS qos = getQos().getSelectedItem();
        network.setQosId(qos == NetworkQoSModel.EMPTY_QOS ? null : qos.getId());
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        onSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (StringHelper.stringsEqual(command.getName(), "OnSave")) {
        // $NON-NLS-1$
        onSave();
    } else if (StringHelper.stringsEqual(command.getName(), "Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command == getAddQosCommand()) {
        addQos();
    }
}
#end_block

#method_before
private static void initSeverities() {
    initDefaultSeverities();
    initProviderSeverities();
    initNetworkSeverities();
    initImportExportSeverities();
    initEngineSeverities();
    initVMsPoolSeverities();
    initBookmarkSeverities();
    initVMSeverities();
    initQuotaSeverities();
    initQoSSeverities();
    initTagSeverities();
    initClusterSeverities();
    initMLASeverities();
    initHostSeverities();
    initStorageSeverities();
    initTaskSeverities();
    initGlusterSeverities();
    initDwhSeverities();
    initConfigSeverities();
    initUserAccountSeverities();
    initCommonSeverities();
    initClusterPolicySeverities();
    initExtrnalEvents();
}
#method_after
private static void initSeverities() {
    initDefaultSeverities();
    initProviderSeverities();
    initNetworkSeverities();
    initImportExportSeverities();
    initEngineSeverities();
    initVMsPoolSeverities();
    initBookmarkSeverities();
    initVMSeverities();
    initQuotaSeverities();
    initQoSSeverities();
    initTagSeverities();
    initClusterSeverities();
    initMLASeverities();
    initHostSeverities();
    initStorageSeverities();
    initTaskSeverities();
    initGlusterSeverities();
    initDwhSeverities();
    initConfigSeverities();
    initUserAccountSeverities();
    initCommonSeverities();
    initClusterPolicySeverities();
    initExtrnalEvents();
    initMomPoliciesSeverities();
}
#end_block

#method_before
private static void initGlusterSeverities() {
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_MODIFIED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_ALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_CONFLICT_DETECTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_NEW, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_GETCONTENT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICES_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_TYPE_ADDED_TO_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOPPED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, AuditLogSeverity.WARNING);
}
#method_after
private static void initGlusterSeverities() {
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_MODIFIED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_ALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_MIGRATE_BRICK_DATA_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_ENABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_PARTIAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DISABLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_CONFLICT_DETECTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_NEW, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_DETECTED_DELETE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_GETCONTENT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICES_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_TYPE_ADDED_TO_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_CLUSTER_SERVICE_STATUS_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_ADDED_TO_SERVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVER_SERVICE_STATUS_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_ADD_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REMOVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_HOOK_REFRESH_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_START_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOPPED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_STOP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_SERVICE_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_HOST_UUID_ALREADY_EXISTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.GLUSTER_BRICK_STATUS_CHANGED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_DETECTED_FROM_CLI, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS_DETECTED_FROM_CLI, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_NOT_FOUND_FROM_CLI, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REMOVE_GLUSTER_VOLUME_BRICKS_NOT_FOUND_FROM_CLI, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initMLASeverities() {
    severities.put(AuditLogType.USER_VDC_LOGIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDC_LOGOUT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGOUT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ADUSER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_ADUSER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_ADUSER, AuditLogSeverity.WARNING);
}
#method_after
private static void initMLASeverities() {
    severities.put(AuditLogType.USER_VDC_LOGIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDC_LOGOUT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_VDC_LOGOUT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.AD_COMPUTER_ACCOUNT_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACHED_ACTION_GROUP_TO_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACHED_ACTION_GROUP_FROM_ROLE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_ROLE_WITH_ACTION_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_ADUSER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_ADUSER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_ADUSER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_SYSTEM_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_SYSTEM_PERMISSION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SYSTEM_PERMISSION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SYSTEM_PERMISSION_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ARCHITECTURE_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#method_after
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ARCHITECTURE_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STATUS_CHANGE_FAILED_DUE_TO_STOP_SPM_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
}
#method_after
private static void initVMSeverities() {
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_STATUS_RESTORED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MEMORY_UNDER_GUARANTEED_VALUE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_SRC_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_MOVE_IMAGE_GROUP_FAILED_TO_DELETE_DST_IMAGE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.EXCEEDED_MAXIMUM_NUM_OF_RESTART_HA_VM_ATTEMPTS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.WATCHDOG_EVENT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_SET_TICKET, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_SET_TICKET_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.ADD_VM_FROM_SNAPSHOT_INVALID_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VM_CONSOLE_CONNECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VM_CONSOLE_DISCONNECTED, AuditLogSeverity.NORMAL);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    String vdsGroupCpuName = getVds().getVdsGroupCpuName();
    VDSGroup grp = DbFacade.getInstance().getVdsGroupDao().get(getVds().getVdsGroupId());
    ServerCpu sc = CpuFlagsManagerHandler.FindMaxServerCpuByFlags(getVds().getCpuFlags(), getVds().getVdsGroupCompatibilityVersion());
    if (sc == null) {
        // operational
        if (!StringUtils.isEmpty(getVds().getCpuFlags())) {
            foundCPU = false;
        } else {
            _hasFlags = false;
        }
        log.errorFormat("Could not find server cpu for server {0}:{1}, flags: {2}", getVdsId(), getVds().getName(), getVds().getCpuFlags());
    }
    // Checks whether the host and the cluster have the same architecture
    if (_hasFlags && foundCPU && !grp.getArchitecture().equals(ArchitectureType.undefined) && !sc.getArchitecture().equals(grp.getArchitecture())) {
        _architectureMismatch = true;
        addCustomValue("VdsArchitecture", sc.getArchitecture().name());
        addCustomValue("VdsGroupArchitecture", grp.getArchitecture().name());
        SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(getVdsId(), NonOperationalReason.ARCHITECTURE_INCOMPATIBLE_WITH_CLUSTER);
        tempVar.setSaveToDb(true);
        Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar, ExecutionHandler.createInternalJobContext());
    }
    // if cluster doesn't have cpu then get the cpu from the vds
    if (_hasFlags && foundCPU && !_architectureMismatch && StringUtils.isEmpty(vdsGroupCpuName)) {
        // update group with the cpu name
        grp.setcpu_name(sc.getCpuName());
        grp.setArchitecture(null);
        // use suppress in order to update group even if action fails
        // (out of the transaction)
        VdsGroupOperationParameters tempVar = new VdsGroupOperationParameters(grp);
        tempVar.setTransactionScopeOption(TransactionScopeOption.Suppress);
        tempVar.setIsInternalCommand(true);
        Backend.getInstance().runInternalAction(VdcActionType.UpdateVdsGroup, tempVar);
        vdsGroupCpuName = sc.getCpuName();
    }
    // If the host CPU name is not found by the CpuFlagsManagerHandler class, report an error
    if (!foundCPU) {
        SetNonOperationalVdsParameters tempVar2 = new SetNonOperationalVdsParameters(getVdsId(), NonOperationalReason.CPU_TYPE_UNSUPPORTED);
        tempVar2.setSaveToDb(true);
        Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar2, ExecutionHandler.createInternalJobContext());
    } else if (!_architectureMismatch) {
        List<String> missingFlags = CpuFlagsManagerHandler.missingServerCpuFlags(vdsGroupCpuName, getVds().getCpuFlags(), getVds().getVdsGroupCompatibilityVersion());
        if (!StringUtils.isEmpty(getVds().getCpuFlags()) && (!foundCPU || missingFlags != null)) {
            if (missingFlags != null) {
                addCustomValue("CpuFlags", StringUtils.join(missingFlags, ", "));
                if (missingFlags.contains("nx")) {
                    AuditLogableBase logable = new AuditLogableBase(getVds().getId());
                    AuditLogDirector.log(logable, AuditLogType.CPU_FLAGS_NX_IS_MISSING);
                }
            }
            SetNonOperationalVdsParameters tempVar2 = new SetNonOperationalVdsParameters(getVdsId(), NonOperationalReason.CPU_TYPE_INCOMPATIBLE_WITH_CLUSTER);
            tempVar2.setSaveToDb(true);
            Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar2, ExecutionHandler.createInternalJobContext());
        } else {
            // if no need to change to non operational then don't log the command
            setCommandShouldBeLogged(false);
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    String vdsGroupCpuName = getVds().getVdsGroupCpuName();
    VDSGroup grp = DbFacade.getInstance().getVdsGroupDao().get(getVds().getVdsGroupId());
    ServerCpu sc = CpuFlagsManagerHandler.FindMaxServerCpuByFlags(getVds().getCpuFlags(), getVds().getVdsGroupCompatibilityVersion());
    if (sc == null) {
        // operational
        if (!StringUtils.isEmpty(getVds().getCpuFlags())) {
            foundCPU = false;
        } else {
            _hasFlags = false;
        }
        log.errorFormat("Could not find server cpu for server {0}:{1}, flags: {2}", getVdsId(), getVds().getName(), getVds().getCpuFlags());
    }
    // Checks whether the host and the cluster have the same architecture
    if (_hasFlags && foundCPU) {
        if (grp.getArchitecture() != ArchitectureType.undefined && sc.getArchitecture() != grp.getArchitecture()) {
            architectureMatch = false;
            addCustomValue("VdsArchitecture", sc.getArchitecture().name());
            addCustomValue("VdsGroupArchitecture", grp.getArchitecture().name());
            SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(getVdsId(), NonOperationalReason.ARCHITECTURE_INCOMPATIBLE_WITH_CLUSTER);
            tempVar.setSaveToDb(true);
            Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar, ExecutionHandler.createInternalJobContext());
        } else {
            // if cluster doesn't have cpu then get the cpu from the vds
            if (StringUtils.isEmpty(vdsGroupCpuName)) {
                // update group with the cpu name
                grp.setcpu_name(sc.getCpuName());
                grp.setArchitecture(ArchitectureType.undefined);
                // use suppress in order to update group even if action fails
                // (out of the transaction)
                VdsGroupOperationParameters tempVar = new VdsGroupOperationParameters(grp);
                tempVar.setTransactionScopeOption(TransactionScopeOption.Suppress);
                tempVar.setIsInternalCommand(true);
                Backend.getInstance().runInternalAction(VdcActionType.UpdateVdsGroup, tempVar);
                vdsGroupCpuName = sc.getCpuName();
            }
        }
    }
    // If the host CPU name is not found by the CpuFlagsManagerHandler class, report an error
    if (architectureMatch) {
        List<String> missingFlags = CpuFlagsManagerHandler.missingServerCpuFlags(vdsGroupCpuName, getVds().getCpuFlags(), getVds().getVdsGroupCompatibilityVersion());
        if (!StringUtils.isEmpty(getVds().getCpuFlags()) && (!foundCPU || missingFlags != null)) {
            if (missingFlags != null) {
                addCustomValue("CpuFlags", StringUtils.join(missingFlags, ", "));
                if (missingFlags.contains("nx")) {
                    AuditLogableBase logable = new AuditLogableBase(getVds().getId());
                    AuditLogDirector.log(logable, AuditLogType.CPU_FLAGS_NX_IS_MISSING);
                }
            }
            SetNonOperationalVdsParameters tempVar2 = new SetNonOperationalVdsParameters(getVdsId(), NonOperationalReason.CPU_TYPE_INCOMPATIBLE_WITH_CLUSTER);
            tempVar2.setSaveToDb(true);
            Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar2, ExecutionHandler.createInternalJobContext());
        } else {
            // if no need to change to non operational then don't log the command
            setCommandShouldBeLogged(false);
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    if (!foundCPU) {
        return AuditLogType.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION;
    } else if (_architectureMismatch) {
        return AuditLogType.VDS_ARCHITECTURE_NOT_SUPPORTED_FOR_CLUSTER;
    } else if (!_hasFlags) {
        return AuditLogType.VDS_CPU_RETRIEVE_FAILED;
    } else {
        return AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    if (!foundCPU) {
        return AuditLogType.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION;
    } else if (!architectureMatch) {
        return AuditLogType.VDS_ARCHITECTURE_NOT_SUPPORTED_FOR_CLUSTER;
    } else if (!_hasFlags) {
        return AuditLogType.VDS_CPU_RETRIEVE_FAILED;
    } else {
        return AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER;
    }
}
#end_block

#method_before
public static boolean isBondVlan(List<VdsNetworkInterface> interfaces, VdsNetworkInterface iface) {
    boolean retVal = false;
    if (iface.getVlanId() != null) {
        for (VdsNetworkInterface i : interfaces) {
            if (i.getBonded() != null && i.getBonded() == true && interfaceBasedOn(iface.getName(), i.getName())) {
                retVal = true;
                break;
            }
        }
    }
    return retVal;
}
#method_after
public static boolean isBondVlan(List<VdsNetworkInterface> interfaces, VdsNetworkInterface iface) {
    boolean retVal = false;
    if (isVlan(iface)) {
        for (VdsNetworkInterface i : interfaces) {
            if (i.getBonded() != null && i.getBonded() == true && interfaceBasedOn(iface.getName(), i.getName())) {
                retVal = true;
                break;
            }
        }
    }
    return retVal;
}
#end_block

#method_before
public static boolean interfaceHasVlan(VdsNetworkInterface iface, List<VdsNetworkInterface> allIfaces) {
    for (VdsNetworkInterface i : allIfaces) {
        if (i.getVlanId() != null && interfaceBasedOn(i.getName(), iface.getName())) {
            return true;
        }
    }
    return false;
}
#method_after
public static boolean interfaceHasVlan(VdsNetworkInterface iface, List<VdsNetworkInterface> allIfaces) {
    for (VdsNetworkInterface i : allIfaces) {
        if (isVlan(i) && interfaceBasedOn(i.getName(), iface.getName())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public static boolean isNetworkInSync(VdsNetworkInterface iface, Network network, NetworkQoS qos) {
    return (network.getMtu() == 0 || iface.getMtu() == network.getMtu()) && Objects.equals(iface.getVlanId(), network.getVlanId()) && iface.isBridged() == network.isVmNetwork() && (Objects.equals(iface.getQos(), qos) || iface.isQosOverridden());
}
#method_after
public static boolean isNetworkInSync(VdsNetworkInterface iface, Network network, NetworkQoS qos) {
    return (network.getMtu() == 0 || iface.getMtu() == network.getMtu()) && Objects.equals(iface.getVlanId(), network.getVlanId()) && iface.isBridged() == network.isVmNetwork() && (isQosInSync(iface, qos) || iface.isQosOverridden());
}
#end_block

#method_before
public static boolean isNonVmNonVlanNetwork(Network network) {
    return !network.isVmNetwork() && network.getVlanId() == null;
}
#method_after
public static boolean isNonVmNonVlanNetwork(Network network) {
    return !network.isVmNetwork() && !isVlan(network);
}
#end_block

#method_before
private void assertInterfaceModified(SetupNetworksHelper helper, VdsNetworkInterface iface) {
    assertTrue(MessageFormat.format("Expected interface ''{0}'' to be modified but it wasn''t. Modified interfaces: {1}", iface, helper.getModifiedInterfaces()), helper.getModifiedInterfaces().contains(iface));
}
#method_after
private void assertInterfaceModified(SetupNetworksHelper helper, VdsNetworkInterface iface) {
    Set<String> modifiedNames = new HashSet<String>();
    for (VdsNetworkInterface modifiedIface : helper.getModifiedInterfaces()) {
        modifiedNames.add(modifiedIface.getName());
    }
    assertTrue(MessageFormat.format("Expected interface ''{0}'' to be modified but it wasn''t. Modified interfaces: {1}", iface, helper.getModifiedInterfaces()), modifiedNames.contains(iface.getName()));
}
#end_block

#method_before
private VdsNetworkInterface createVdsInterface(Guid id, String name, Boolean bonded, String bondName, Integer vlanId, String networkName, boolean bridged, String address, boolean qosOverridden) {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setId(id);
    iface.setName(name);
    iface.setBonded(bonded);
    iface.setBondName(bondName);
    iface.setVlanId(vlanId);
    iface.setNetworkName(networkName);
    iface.setBridged(bridged);
    iface.setAddress(address);
    iface.setQosOverridden(qosOverridden);
    return iface;
}
#method_after
private VdsNetworkInterface createVdsInterface(Guid id, String name, Boolean bonded, String bondName, Integer vlanId, String networkName, boolean bridged, String address, boolean qosOverridden, Set<String> labels) {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setId(id);
    iface.setName(name);
    iface.setBonded(bonded);
    iface.setBondName(bondName);
    iface.setVlanId(vlanId);
    iface.setNetworkName(networkName);
    iface.setBridged(bridged);
    iface.setAddress(address);
    iface.setQosOverridden(qosOverridden);
    iface.setLabels(labels);
    return iface;
}
#end_block

#method_before
private VdsNetworkInterface createNic(String nicName, String networkName) {
    return createVdsInterface(Guid.newGuid(), nicName, false, null, null, networkName, true, null, false);
}
#method_after
private VdsNetworkInterface createNic(String nicName, String networkName) {
    return createVdsInterface(Guid.newGuid(), nicName, false, null, null, networkName, true, null, false, null);
}
#end_block

#method_before
private VdsNetworkInterface createNicSyncedWithNetwork(String nicName, Network network) {
    VdsNetworkInterface nic = createVdsInterface(Guid.newGuid(), nicName, false, null, network.getVlanId(), network.getName(), network.isVmNetwork(), network.getAddr(), false);
    return nic;
}
#method_after
private VdsNetworkInterface createNicSyncedWithNetwork(String nicName, Network network) {
    VdsNetworkInterface nic = createVdsInterface(Guid.newGuid(), nicName, false, null, network.getVlanId(), network.getName(), network.isVmNetwork(), network.getAddr(), false, null);
    return nic;
}
#end_block

#method_before
private VdsNetworkInterface createBond(String name, String networkName) {
    return createVdsInterface(Guid.newGuid(), name, true, null, null, networkName, true, null, false);
}
#method_after
private VdsNetworkInterface createBond(String name, String networkName) {
    return createVdsInterface(Guid.newGuid(), name, true, null, null, networkName, true, null, false, null);
}
#end_block

#method_before
private VdsNetworkInterface createVlan(String baseIfaceName, int vlanId, String networkName) {
    return createVdsInterface(Guid.newGuid(), baseIfaceName + "." + vlanId, false, null, vlanId, networkName, true, null, false);
}
#method_after
private VdsNetworkInterface createVlan(String baseIfaceName, int vlanId, String networkName) {
    return createVdsInterface(Guid.newGuid(), baseIfaceName + "." + vlanId, false, null, vlanId, networkName, true, null, false, null);
}
#end_block

#method_before
private VdsNetworkInterface enslaveOrReleaseNIC(VdsNetworkInterface iface, String bondName) {
    return createVdsInterface(iface.getId(), iface.getName(), false, bondName, null, null, true, null, false);
}
#method_after
private VdsNetworkInterface enslaveOrReleaseNIC(VdsNetworkInterface iface, String bondName) {
    return createVdsInterface(iface.getId(), iface.getName(), false, bondName, null, null, true, null, false, null);
}
#end_block

#method_before
private void mockExistingIfaces(VdsNetworkInterface... nics) {
    List<VdsNetworkInterface> existingIfaces = new ArrayList<VdsNetworkInterface>();
    for (int i = 0; i < nics.length; i++) {
        existingIfaces.add(createVdsInterface(nics[i].getId(), nics[i].getName(), nics[i].getBonded(), nics[i].getBondName(), nics[i].getVlanId(), nics[i].getNetworkName(), nics[i].isBridged(), nics[i].getAddress(), nics[i].isQosOverridden()));
    }
    when(interfaceDAO.getAllInterfacesForVds(any(Guid.class))).thenReturn(existingIfaces);
}
#method_after
private void mockExistingIfaces(VdsNetworkInterface... nics) {
    List<VdsNetworkInterface> existingIfaces = new ArrayList<VdsNetworkInterface>();
    for (int i = 0; i < nics.length; i++) {
        existingIfaces.add(createVdsInterface(nics[i].getId(), nics[i].getName(), nics[i].getBonded(), nics[i].getBondName(), nics[i].getVlanId(), nics[i].getNetworkName(), nics[i].isBridged(), nics[i].getAddress(), nics[i].isQosOverridden(), nics[i].getLabels()));
    }
    when(interfaceDAO.getAllInterfacesForVds(any(Guid.class))).thenReturn(existingIfaces);
}
#end_block

#method_before
public List<String> validate() {
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String name = iface.getName();
        if (addInterfaceToProcessedList(iface)) {
            if (isBond(iface)) {
                extractBondIfModified(iface, name);
            } else if (StringUtils.isNotBlank(iface.getBondName())) {
                extractBondSlave(iface);
            }
            // validate and extract to network map
            if (violations.isEmpty() && StringUtils.isNotBlank(iface.getNetworkName())) {
                extractNetwork(iface);
                validateGateway(iface);
            }
        }
    }
    validateInterfacesExist();
    validateBondSlavesCount();
    extractRemovedNetworks();
    extractRemovedBonds();
    detectSlaveChanges();
    validateMTU();
    validateNetworkQos();
    return translateViolations();
}
#method_after
public List<String> validate() {
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String name = iface.getName();
        if (addInterfaceToProcessedList(iface)) {
            if (isBond(iface)) {
                extractBondIfModified(iface, name);
            } else if (StringUtils.isNotBlank(iface.getBondName())) {
                extractBondSlave(iface);
            }
            // validate and extract to network map
            if (violations.isEmpty() && StringUtils.isNotBlank(iface.getNetworkName())) {
                extractNetwork(iface);
                validateGateway(iface);
            }
        }
    }
    validateInterfacesExist();
    validateBondSlavesCount();
    extractRemovedNetworks();
    extractRemovedBonds();
    extractModifiedInterfaces();
    detectSlaveChanges();
    validateMTU();
    validateNetworkQos();
    validateNotRemovingLabeledNetworks();
    return translateViolations();
}
#end_block

#method_before
private void validateNetworkQos() {
    boolean featureSupported = FeatureSupported.HostNetworkQos(vds.getVdsGroupCompatibilityVersion());
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        if (iface.isQosOverridden()) {
            if (!featureSupported) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, iface.getNetworkName());
            }
            NetworkQosValidator qosValidator = new NetworkQosValidator(iface.getQos());
            if (qosValidator.allValuesPresent() != ValidationResult.VALID) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_MISSING_VALUES, iface.getNetworkName());
            }
            if (qosValidator.peakConsistentWithAverage() != ValidationResult.VALID) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_PEAK_LOWER_THAN_AVERAGE, iface.getNetworkName());
            }
        }
    }
}
#method_after
private void validateNetworkQos() {
    boolean featureSupported = FeatureSupported.hostNetworkQos(vds.getVdsGroupCompatibilityVersion());
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        if (iface.isQosOverridden()) {
            if (!featureSupported) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, iface.getNetworkName());
            }
            NetworkQosValidator qosValidator = new NetworkQosValidator(iface.getQos());
            if (qosValidator.allValuesPresent() != ValidationResult.VALID) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_MISSING_VALUES, iface.getNetworkName());
            }
            if (qosValidator.peakConsistentWithAverage() != ValidationResult.VALID) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_PEAK_LOWER_THAN_AVERAGE, iface.getNetworkName());
            }
        }
    }
}
#end_block

#method_before
private void extractNetwork(VdsNetworkInterface iface) {
    String networkName = iface.getNetworkName();
    // prevent attaching 2 interfaces to 1 network
    if (attachedNetworksNames.contains(networkName)) {
        addViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName);
    } else {
        attachedNetworksNames.add(networkName);
        // check if network exists on cluster
        if (getExistingClusterNetworks().containsKey(networkName)) {
            Network network = getExistingClusterNetworks().get(networkName);
            validateNetworkInternal(network);
            validateNetworkExclusiveOnIface(iface, determineNetworkType(network.getVlanId(), network.isVmNetwork()));
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            if (existingIface != null && !networkName.equals(existingIface.getNetworkName())) {
                existingIface = getExistingIfaceByNetwork(networkName);
            }
            if (existingIface != null && existingIface.getNetworkImplementationDetails() != null && !existingIface.getNetworkImplementationDetails().isInSync()) {
                if (networkShouldBeSynced(networkName)) {
                    modifiedNetworks.add(network);
                } else if (networkWasModified(iface)) {
                    addViolation(VdcBllMessages.NETWORKS_NOT_IN_SYNC, networkName);
                }
            } else {
                if (networkWasModified(iface)) {
                    if (networkIpAddressWasSameAsHostnameAndChanged(iface)) {
                        addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED, networkName);
                    }
                    modifiedNetworks.add(network);
                }
                if ((existingIface == null && iface.isQosOverridden()) || existingIface != null && (iface.isQosOverridden() != existingIface.isQosOverridden())) {
                    modifiedInterfaces.add(iface);
                }
            }
        } else {
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            existingIface = (existingIface == null ? iface : existingIface);
            validateNetworkExclusiveOnIface(iface, determineNetworkType(existingIface.getVlanId(), existingIface.isBridged()));
            if (unmanagedNetworkChanged(iface)) {
                addViolation(VdcBllMessages.NETWORKS_DONT_EXIST_IN_CLUSTER, networkName);
            }
        }
    }
}
#method_after
private void extractNetwork(VdsNetworkInterface iface) {
    String networkName = iface.getNetworkName();
    // prevent attaching 2 interfaces to 1 network
    if (attachedNetworksNames.contains(networkName)) {
        addViolation(VdcBllMessages.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName);
    } else {
        attachedNetworksNames.add(networkName);
        // check if network exists on cluster
        if (getExistingClusterNetworks().containsKey(networkName)) {
            Network network = getExistingClusterNetworks().get(networkName);
            validateNetworkInternal(network);
            validateNetworkExclusiveOnIface(iface, determineNetworkType(network.getVlanId(), network.isVmNetwork()));
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            if (existingIface != null && !networkName.equals(existingIface.getNetworkName())) {
                existingIface = getExistingIfaceByNetwork(networkName);
            }
            if (existingIface != null && existingIface.getNetworkImplementationDetails() != null && !existingIface.getNetworkImplementationDetails().isInSync()) {
                if (networkShouldBeSynced(networkName)) {
                    modifiedNetworks.add(network);
                } else if (networkWasModified(iface)) {
                    addViolation(VdcBllMessages.NETWORKS_NOT_IN_SYNC, networkName);
                }
            } else if (networkWasModified(iface)) {
                if (networkIpAddressWasSameAsHostnameAndChanged(iface)) {
                    addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_ADDRESS_CANNOT_BE_CHANGED, networkName);
                }
                modifiedNetworks.add(network);
            }
        } else {
            VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
            existingIface = (existingIface == null ? iface : existingIface);
            validateNetworkExclusiveOnIface(iface, determineNetworkType(existingIface.getVlanId(), existingIface.isBridged()));
            if (unmanagedNetworkChanged(iface)) {
                addViolation(VdcBllMessages.NETWORKS_DONT_EXIST_IN_CLUSTER, networkName);
            }
        }
    }
}
#end_block

#method_before
public Collection<VdsNetworkInterface> getModifiedInterfaces() {
    return modifiedInterfaces;
}
#method_after
public List<VdsNetworkInterface> getModifiedInterfaces() {
    return modifiedInterfaces;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        setSucceeded(true);
        return;
    }
    T bckndCmdParams = getParameters();
    final SetupNetworksVdsCommandParameters vdsCmdParams = new SetupNetworksVdsCommandParameters(getVdsId(), getNetworks(), getRemovedNetworks(), getBonds(), getRemovedBonds(), getInterfaces());
    vdsCmdParams.setForce(bckndCmdParams.isForce());
    vdsCmdParams.setCheckConnectivity(bckndCmdParams.isCheckConnectivity());
    int timeout = bckndCmdParams.getConectivityTimeout() != null ? bckndCmdParams.getConectivityTimeout() : Config.<Integer>getValue(ConfigValues.NetworkConnectivityCheckTimeoutInSeconds);
    vdsCmdParams.setConectivityTimeout(timeout);
    FutureVDSCall<VDSReturnValue> setupNetworksTask = createFutureTask(vdsCmdParams);
    if (bckndCmdParams.isCheckConnectivity()) {
        pollInterruptively(setupNetworksTask);
    }
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                setSucceeded(TransactionSupport.executeInNewTransaction(updateVdsNetworksInTx()));
            }
        }
    } catch (TimeoutException e) {
        log.debugFormat("Setup networks command timed out for {0} seconds", timeout);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        if (!getModifiedInterfaces().isEmpty()) {
            updateModifiedInterfaces();
        }
        setSucceeded(true);
        return;
    }
    if (!getRemovedBonds().isEmpty()) {
        unlabelRemovedBonds();
    }
    T bckndCmdParams = getParameters();
    final SetupNetworksVdsCommandParameters vdsCmdParams = new SetupNetworksVdsCommandParameters(getVdsId(), getNetworks(), getRemovedNetworks(), getBonds(), getRemovedBonds(), getInterfaces());
    vdsCmdParams.setForce(bckndCmdParams.isForce());
    vdsCmdParams.setCheckConnectivity(bckndCmdParams.isCheckConnectivity());
    int timeout = bckndCmdParams.getConectivityTimeout() != null ? bckndCmdParams.getConectivityTimeout() : Config.<Integer>getValue(ConfigValues.NetworkConnectivityCheckTimeoutInSeconds);
    vdsCmdParams.setConectivityTimeout(timeout);
    FutureVDSCall<VDSReturnValue> setupNetworksTask = createFutureTask(vdsCmdParams);
    if (bckndCmdParams.isCheckConnectivity()) {
        pollInterruptively(setupNetworksTask);
    }
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                setSucceeded(TransactionSupport.executeInNewTransaction(updateVdsNetworksInTx()));
            }
        }
    } catch (TimeoutException e) {
        log.debugFormat("Setup networks command timed out for {0} seconds", timeout);
    }
}
#end_block

#method_before
private Collection<VdsNetworkInterface> getModifiedInterfaces() {
    return helper.getModifiedInterfaces();
}
#method_after
private List<VdsNetworkInterface> getModifiedInterfaces() {
    return helper.getModifiedInterfaces();
}
#end_block

#method_before
private TransactionMethod<Boolean> updateVdsNetworksInTx() {
    return new TransactionMethod<Boolean>() {

        @Override
        public Boolean runInTransaction() {
            // update the interfaces whose qosOverridden field has changed
            getDbFacade().getInterfaceDao().updateQosOverridden(getModifiedInterfaces());
            // save the new network topology to DB
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CollectVdsNetworkData, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
            // Update cluster networks (i.e. check if need to activate each new network)
            for (Network net : getNetworks()) {
                NetworkClusterHelper.setStatus(getVdsGroupId(), net);
            }
            return Boolean.TRUE;
        }
    };
}
#method_after
private TransactionMethod<Boolean> updateVdsNetworksInTx() {
    return new TransactionMethod<Boolean>() {

        @Override
        public Boolean runInTransaction() {
            // save the new network topology to DB
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CollectVdsNetworkData, new CollectHostNetworkDataVdsCommandParameters(getVds(), getInterfaces()));
            // Update cluster networks (i.e. check if need to activate each new network)
            for (Network net : getNetworks()) {
                NetworkClusterHelper.setStatus(getVdsGroupId(), net);
            }
            return Boolean.TRUE;
        }
    };
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkIsSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, true, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkIsSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, true, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkIsSyncWithMtuUnset() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, true, iface.getNetworkName(), iface.isBridged(), 0, iface.getVlanId(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkIsSyncWithMtuUnset() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, true, iface.getNetworkName(), iface.isBridged(), 0, iface.getVlanId(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkOutOfSyncWithMtuUnset() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), !iface.isBridged(), 0, RandomUtils.instance().nextInt(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkOutOfSyncWithMtuUnset() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), !iface.isBridged(), 0, RandomUtils.instance().nextInt(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkMtuOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu() + 1, iface.getVlanId(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkMtuOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu() + 1, iface.getVlanId(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkVmNetworkOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), !iface.isBridged(), iface.getMtu(), iface.getVlanId(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkVmNetworkOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), !iface.isBridged(), iface.getMtu(), iface.getVlanId(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkVlanOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId() + 1, null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkVlanOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId() + 1, createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkQosOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId(), new NetworkQoS());
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkQosOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    NetworkQoS qos = createQos();
    qos.setOutboundAverage(30);
    qos.setOutboundPeak(30);
    qos.setOutboundBurst(30);
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId(), qos);
}
#end_block

#method_before
private VdsNetworkInterface createNetworkDevice() {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setNetworkName(RandomUtils.instance().nextString(10));
    iface.setBridged(RandomUtils.instance().nextBoolean());
    iface.setMtu(100);
    iface.setVlanId(100);
    return iface;
}
#method_after
private VdsNetworkInterface createNetworkDevice() {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setNetworkName(RandomUtils.instance().nextString(10));
    iface.setBridged(RandomUtils.instance().nextBoolean());
    iface.setMtu(100);
    iface.setVlanId(100);
    iface.setQos(createQos());
    return iface;
}
#end_block

#method_before
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    NetworkQoSDao qosDao = getDbFacade().getQosDao();
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface.getName());
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() != 0) {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        if (FeatureSupported.HostNetworkQos(getVds().getVdsGroupCompatibilityVersion())) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(opts, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#method_after
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    NetworkQoSDao qosDao = getDbFacade().getQosDao();
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface.getName());
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() != 0) {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        if (qosConfiguredOnInterface(iface, network) && FeatureSupported.hostNetworkQos(getDbFacade().getVdsDao().get(getParameters().getVdsId()).getVdsGroupCompatibilityVersion())) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(opts, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#end_block

#method_before
private void qos(Network network, VdsNetworkInterface iface, NetworkQoS expectedQos, Version clusterCompatibilityVersion) {
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, Version.v3_3, false);
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, new Version(3, 4), true);
    when(host.getVdsGroupCompatibilityVersion()).thenReturn(clusterCompatibilityVersion);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(network), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(iface));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(network);
    NetworkQosMapper qosMapper = new NetworkQosMapper(networkStruct, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
    assertEquals(qosMapper.deserialize(), expectedQos);
}
#method_after
private void qos(Network network, VdsNetworkInterface iface, NetworkQoS expectedQos, boolean hostNetworkQosSupported) {
    Version version = mock(Version.class);
    when(host.getVdsGroupCompatibilityVersion()).thenReturn(version);
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, version, hostNetworkQosSupported);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(network), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(iface));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(network);
    NetworkQosMapper qosMapper = new NetworkQosMapper(networkStruct, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
    assertEquals(expectedQos, qosMapper.deserialize());
}
#end_block

#method_before
@Test
public void qosNotSupported() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    when(qosDao.get(any(Guid.class))).thenReturn(createQos());
    qos(network, iface, null, Version.v3_3);
}
#method_after
@Test
public void qosNotSupported() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    when(qosDao.get(any(Guid.class))).thenReturn(createQos());
    qos(network, iface, null, false);
}
#end_block

#method_before
@Test
public void qosOnNetwork() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    NetworkQoS qos = createQos();
    when(qosDao.get(any(Guid.class))).thenReturn(qos);
    qos(network, iface, qos, new Version(3, 4));
}
#method_after
@Test
public void qosOnNetwork() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    Guid qosId = Guid.newGuid();
    network.setQosId(qosId);
    NetworkQoS qos = createQos();
    qos.setId(qosId);
    when(qosDao.get(qosId)).thenReturn(qos);
    qos(network, iface, qos, true);
}
#end_block

#method_before
@Test
public void qosOnInterface() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    NetworkQoS qos = createQos();
    when(qosDao.get(any(Guid.class))).thenReturn(qos);
    iface.setQosOverridden(true);
    qos(network, iface, null, new Version(3, 4));
}
#method_after
@Test
public void qosOnInterface() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    NetworkQoS qos = createQos();
    iface.setQos(qos);
    iface.setQosOverridden(true);
    when(qosDao.get(any(Guid.class))).thenReturn(createQos());
    qos(network, iface, qos, true);
}
#end_block

#method_before
private SetupNetworksVDSCommand<SetupNetworksVdsCommandParameters> createCommand(SetupNetworksVdsCommandParameters parameters) {
    final DbFacade dbFacade = mock(DbFacade.class);
    final VdsStaticDAO vdsStaticDao = mock(VdsStaticDAO.class);
    when(dbFacade.getVdsStaticDao()).thenReturn(vdsStaticDao);
    when(dbFacade.getQosDao()).thenReturn(qosDao);
    // No way to avoid these calls by regular mocking, so must implement anonymously.
    return new SetupNetworksVDSCommand<SetupNetworksVdsCommandParameters>(parameters) {

        @Override
        protected IVdsServer initializeVdsBroker(Guid vdsId) {
            return server;
        }

        @Override
        protected DbFacade getDbFacade() {
            return dbFacade;
        }

        @Override
        protected VDS getVds() {
            return host;
        }
    };
}
#method_after
private SetupNetworksVDSCommand<SetupNetworksVdsCommandParameters> createCommand(SetupNetworksVdsCommandParameters parameters) {
    final DbFacade dbFacade = mock(DbFacade.class);
    final VdsStaticDAO vdsStaticDao = mock(VdsStaticDAO.class);
    final VdsDAO vdsDao = mock(VdsDAO.class);
    when(dbFacade.getVdsStaticDao()).thenReturn(vdsStaticDao);
    when(dbFacade.getVdsDao()).thenReturn(vdsDao);
    when(dbFacade.getQosDao()).thenReturn(qosDao);
    when(vdsDao.get(any(Guid.class))).thenReturn(host);
    // No way to avoid these calls by regular mocking, so must implement anonymously.
    return new SetupNetworksVDSCommand<SetupNetworksVdsCommandParameters>(parameters) {

        @Override
        protected IVdsServer initializeVdsBroker(Guid vdsId) {
            return server;
        }

        @Override
        protected DbFacade getDbFacade() {
            return dbFacade;
        }
    };
}
#end_block

#method_before
private NetworkQoS createQos() {
    NetworkQoS qos = new NetworkQoS();
    qos.setInboundAverage(30);
    qos.setInboundPeak(30);
    qos.setInboundBurst(30);
    return qos;
}
#method_after
private NetworkQoS createQos() {
    NetworkQoS qos = new NetworkQoS();
    qos.setInboundAverage(RandomUtils.instance().nextInt(0, 1000000));
    qos.setInboundPeak(RandomUtils.instance().nextInt(0, 1000000));
    qos.setInboundBurst(RandomUtils.instance().nextInt(0, 1000000));
    qos.setOutboundAverage(RandomUtils.instance().nextInt(0, 1000000));
    qos.setOutboundPeak(RandomUtils.instance().nextInt(0, 1000000));
    qos.setOutboundBurst(RandomUtils.instance().nextInt(0, 1000000));
    return qos;
}
#end_block

#method_before
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), hasWatchdog(), getParameters().isBalloonEnabled(), getParameters().isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return true;
}
#end_block

#method_before
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNic iface : getVmInterfaces()) {
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    List<VmNic> nics = getVmInterfaces();
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    vmInterfaceManager.sortVmNics(nics, getVmInterfaceDevices());
    List<String> macAddresses = MacPoolManager.getInstance().allocateMacAddresses(nics.size());
    // Add interfaces from template
    for (int i = 0; i < nics.size(); ++i) {
        VmNic iface = nics.get(i);
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(macAddresses.get(i));
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>getValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getVdsGroupId()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#method_after
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>getValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getVdsGroupId()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    vmStatic.setOriginalTemplateGuid(vmStatic.getVmtGuid());
    vmStatic.setOriginalTemplateName(getVmTemplate().getName());
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    return entity;
}
#end_block

#method_before
@Override
public MapSqlParameterMapper<VmDynamic> getBatchMapper() {
    return new MapSqlParameterMapper<VmDynamic>() {

        @Override
        public MapSqlParameterSource map(VmDynamic entity) {
            MapSqlParameterSource paramValue = new MapSqlParameterSource().addValue("guest_cur_user_name", entity.getGuestCurrentUserName()).addValue("console_cur_user_name", entity.getConsoleCurrentUserName()).addValue("guest_last_login_time", entity.getGuestLastLoginTime()).addValue("guest_last_logout_time", entity.getGuestLastLogoutTime()).addValue("console_user_id", entity.getConsoleUserId()).addValue("guest_os", entity.getGuestOs()).addValue("migrating_to_vds", entity.getMigratingToVds()).addValue("run_on_vds", entity.getRunOnVds()).addValue("status", entity.getStatus()).addValue("vm_guid", entity.getId()).addValue("vm_host", entity.getVmHost()).addValue("vm_ip", entity.getVmIp()).addValue("last_start_time", entity.getLastStartTime()).addValue("last_stop_time", entity.getLastStopTime()).addValue("vm_pid", entity.getVmPid()).addValue("vm_fqdn", entity.getVmFQDN()).addValue("app_list", entity.getAppList()).addValue("display", entity.getDisplay()).addValue("acpi_enable", entity.getAcpiEnable()).addValue("session", entity.getSession()).addValue("display_ip", entity.getDisplayIp()).addValue("display_type", entity.getDisplayType()).addValue("kvm_enable", entity.getKvmEnable()).addValue("boot_sequence", entity.getBootSequence()).addValue("display_secure_port", entity.getDisplaySecurePort()).addValue("utc_diff", entity.getUtcDiff()).addValue("last_vds_run_on", entity.getLastVdsRunOn()).addValue("client_ip", entity.getClientIp()).addValue("guest_requested_memory", entity.getGuestRequestedMemory()).addValue("hibernation_vol_handle", entity.getHibernationVolHandle()).addValue("exit_status", entity.getExitStatus()).addValue("pause_status", entity.getPauseStatus()).addValue("exit_message", entity.getExitMessage()).addValue("hash", entity.getHash()).addValue("guest_agent_nics_hash", entity.getGuestAgentNicsHash()).addValue("last_watchdog_event", entity.getLastWatchdogEvent()).addValue("last_watchdog_action", entity.getLastWatchdogAction()).addValue("cpu_name", entity.getCpuName());
            return paramValue;
        }
    };
}
#method_after
@Override
public MapSqlParameterMapper<VmDynamic> getBatchMapper() {
    return new MapSqlParameterMapper<VmDynamic>() {

        @Override
        public MapSqlParameterSource map(VmDynamic entity) {
            MapSqlParameterSource paramValue = new MapSqlParameterSource().addValue("guest_cur_user_name", entity.getGuestCurrentUserName()).addValue("console_cur_user_name", entity.getConsoleCurrentUserName()).addValue("guest_last_login_time", entity.getGuestLastLoginTime()).addValue("guest_last_logout_time", entity.getGuestLastLogoutTime()).addValue("console_user_id", entity.getConsoleUserId()).addValue("guest_os", entity.getGuestOs()).addValue("migrating_to_vds", entity.getMigratingToVds()).addValue("run_on_vds", entity.getRunOnVds()).addValue("status", entity.getStatus()).addValue("vm_guid", entity.getId()).addValue("vm_host", entity.getVmHost()).addValue("vm_ip", entity.getVmIp()).addValue("last_start_time", entity.getLastStartTime()).addValue("last_stop_time", entity.getLastStopTime()).addValue("vm_pid", entity.getVmPid()).addValue("vm_fqdn", entity.getVmFQDN()).addValue("app_list", entity.getAppList()).addValue("display", entity.getDisplay()).addValue("acpi_enable", entity.getAcpiEnable()).addValue("session", entity.getSession()).addValue("display_ip", entity.getDisplayIp()).addValue("display_type", entity.getDisplayType()).addValue("kvm_enable", entity.getKvmEnable()).addValue("boot_sequence", entity.getBootSequence()).addValue("display_secure_port", entity.getDisplaySecurePort()).addValue("utc_diff", entity.getUtcDiff()).addValue("last_vds_run_on", entity.getLastVdsRunOn()).addValue("client_ip", entity.getClientIp()).addValue("guest_requested_memory", entity.getGuestRequestedMemory()).addValue("hibernation_vol_handle", entity.getHibernationVolHandle()).addValue("exit_status", entity.getExitStatus()).addValue("pause_status", entity.getPauseStatus()).addValue("exit_message", entity.getExitMessage()).addValue("hash", entity.getHash()).addValue("guest_agent_nics_hash", entity.getGuestAgentNicsHash()).addValue("last_watchdog_event", entity.getLastWatchdogEvent()).addValue("last_watchdog_action", entity.getLastWatchdogAction()).addValue("is_run_once", entity.isRunOnce()).addValue("cpu_name", entity.getCpuName());
            return paramValue;
        }
    };
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getNic() == null) {
        return failCanDoAction(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST);
    }
    if (getNic().getLabels() != null && getNic().getLabels().contains(getLabel())) {
        return failCanDoAction(VdcBllMessages.INTERFACE_ALREADY_LABELED);
    }
    if (!ValidationUtils.validateInputs(getValidationGroups(), getNic()).isEmpty()) {
        return failCanDoAction(VdcBllMessages.IMPROPER_INTERFACE_IS_LABELED);
    }
    for (VdsNetworkInterface nic : getHostInterfaces()) {
        if (!StringUtils.equals(nic.getName(), getNicName()) && nic.getLabels() != null && nic.getLabels().contains(getLabel())) {
            return failCanDoAction(VdcBllMessages.OTHER_INTERFACE_ALREADY_LABELED, "$LabeledNic " + nic.getName());
        }
    }
    List<String> assignedNetworks = validateNetworksNotAssignedToIncorrectNics();
    if (!assignedNetworks.isEmpty()) {
        return failCanDoAction(VdcBllMessages.LABELED_NETWORK_ATTACHED_TO_WRONG_INTERFACE, "$AssignedNetworks " + StringUtils.join(assignedNetworks.toArray(new String[assignedNetworks.size()]), ", "));
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getNic() == null) {
        return failCanDoAction(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST);
    }
    if (getNic().getLabels() != null && getNic().getLabels().contains(getLabel())) {
        return failCanDoAction(VdcBllMessages.INTERFACE_ALREADY_LABELED);
    }
    if (!ValidationUtils.validateInputs(getValidationGroups(), getNic()).isEmpty()) {
        return failCanDoAction(VdcBllMessages.IMPROPER_INTERFACE_IS_LABELED);
    }
    for (VdsNetworkInterface nic : getHostInterfaces()) {
        if (!StringUtils.equals(nic.getName(), getNicName()) && nic.getLabels() != null && nic.getLabels().contains(getLabel())) {
            return failCanDoAction(VdcBllMessages.OTHER_INTERFACE_ALREADY_LABELED, "$LabeledNic " + nic.getName());
        }
    }
    List<String> assignedNetworks = validateNetworksNotAssignedToIncorrectNics();
    if (!assignedNetworks.isEmpty()) {
        return failCanDoAction(VdcBllMessages.LABELED_NETWORK_ATTACHED_TO_WRONG_INTERFACE, "$AssignedNetworks " + StringUtils.join(assignedNetworks, ", "));
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    NetworkQosValidator validator = new NetworkQosValidator(getNetworkQoS());
    return validateParameters() && validateNameNotExistInDC() && validate(validator.allValuesPresent()) && validate(validator.peakConsistentWithAverage());
}
#method_after
@Override
protected boolean canDoAction() {
    NetworkQosValidator validator = new NetworkQosValidator(getNetworkQoS());
    return validateParameters() && validate(validator.nameNotTakenInDc()) && validate(validator.allValuesPresent()) && validate(validator.peakConsistentWithAverage());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (validateParameters()) {
        NetworkQosValidator validator = new NetworkQosValidator(getNetworkQoS());
        if (!validate(validator.qosExists()) || !validate(validator.consistentDataCenter()) || !validate(validator.allValuesPresent()) || !validate(validator.peakConsistentWithAverage())) {
            return false;
        } else {
            NetworkQoS oldNetworkQoS = getNetworkQoSDao().get(getNetworkQoS().getId());
            if (!oldNetworkQoS.getName().equals(getNetworkQoS().getName())) {
                return validateNameNotExistInDC();
            }
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    NetworkQosValidator validator = new NetworkQosValidator(getNetworkQoS());
    return (validateParameters() && validate(validator.qosExists()) && validate(validator.consistentDataCenter()) && validate(validator.allValuesPresent()) && validate(validator.peakConsistentWithAverage()) && validate(validator.nameNotChangedOrNotTaken()));
}
#end_block

#method_before
@Before
public void setup() {
    qos = new NetworkQoS();
    oldQos = new NetworkQoS();
    validator = spy(new NetworkQosValidator(qos));
    doReturn(oldQos).when(validator).getOldQos();
    nullValidator = spy(new NetworkQosValidator(null));
    doReturn(oldQos).when(nullValidator).getOldQos();
}
#method_after
@Before
public void setup() {
    qos = new NetworkQoS();
    oldQos = new NetworkQoS();
    allQos = new ArrayList<NetworkQoS>();
    validator = spy(new NetworkQosValidator(qos));
    doReturn(oldQos).when(validator).getOldQos();
    doReturn(allQos).when(validator).getAllQosInDc();
    nullValidator = spy(new NetworkQosValidator(null));
    doReturn(oldQos).when(nullValidator).getOldQos();
}
#end_block

#method_before
@Test
public void allValuesPresent() {
    qos.setInboundAverage(BANDWIDTH_MEDIUM);
    qos.setInboundPeak(BANDWIDTH_MEDIUM);
    qos.setInboundBurst(BANDWIDTH_MEDIUM);
    valuesPresentTest(isValid());
}
#method_after
@Test
public void allValuesPresent() {
    qos.setInboundAverage(BANDWIDTH_MEDIUM);
    qos.setInboundPeak(BANDWIDTH_MEDIUM);
    qos.setInboundBurst(BANDWIDTH_MEDIUM);
    qos.setOutboundAverage(BANDWIDTH_MEDIUM);
    qos.setOutboundPeak(BANDWIDTH_MEDIUM);
    qos.setOutboundBurst(BANDWIDTH_MEDIUM);
    valuesPresentTest(isValid());
}
#end_block

#method_before
private void peakConsistentWithAverageTest(Matcher<ValidationResult> matcher) {
    qos.setInboundAverage(BANDWIDTH_MEDIUM);
    assertThat(validator.peakConsistentWithAverage(), matcher);
}
#method_after
private void peakConsistentWithAverageTest(Matcher<ValidationResult> matcher) {
    qos.setInboundAverage(BANDWIDTH_MEDIUM);
    qos.setOutboundAverage(BANDWIDTH_MEDIUM);
    assertThat(validator.peakConsistentWithAverage(), matcher);
}
#end_block

#method_before
@Test
public void peakHigherThanAverage() {
    qos.setInboundPeak(BANDWIDTH_HIGH);
    peakConsistentWithAverageTest(isValid());
}
#method_after
@Test
public void peakHigherThanAverage() {
    qos.setInboundPeak(BANDWIDTH_HIGH);
    qos.setOutboundPeak(BANDWIDTH_HIGH);
    peakConsistentWithAverageTest(isValid());
}
#end_block

#method_before
@Test
public void peakEqualToAverage() {
    qos.setInboundPeak(BANDWIDTH_MEDIUM);
    peakConsistentWithAverageTest(isValid());
}
#method_after
@Test
public void peakEqualToAverage() {
    qos.setInboundPeak(BANDWIDTH_MEDIUM);
    qos.setOutboundPeak(BANDWIDTH_MEDIUM);
    peakConsistentWithAverageTest(isValid());
}
#end_block

#method_before
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.Empty);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
private VdsNetworkInterface createVdsInterface(Guid id, String name, Boolean bonded, String bondName, Integer vlanId, String networkName, boolean bridged, String address) {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setId(id);
    iface.setName(name);
    iface.setBonded(bonded);
    iface.setBondName(bondName);
    iface.setVlanId(vlanId);
    iface.setNetworkName(networkName);
    iface.setBridged(bridged);
    iface.setAddress(address);
    return iface;
}
#method_after
private VdsNetworkInterface createVdsInterface(Guid id, String name, Boolean bonded, String bondName, Integer vlanId, String networkName, boolean bridged, String address, Set<String> labels) {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setId(id);
    iface.setName(name);
    iface.setBonded(bonded);
    iface.setBondName(bondName);
    iface.setVlanId(vlanId);
    iface.setNetworkName(networkName);
    iface.setBridged(bridged);
    iface.setAddress(address);
    iface.setLabels(labels);
    return iface;
}
#end_block

#method_before
private VdsNetworkInterface createNic(String nicName, String networkName) {
    return createVdsInterface(Guid.newGuid(), nicName, false, null, null, networkName, true, null);
}
#method_after
private VdsNetworkInterface createNic(String nicName, String networkName) {
    return createVdsInterface(Guid.newGuid(), nicName, false, null, null, networkName, true, null, null);
}
#end_block

#method_before
private VdsNetworkInterface createNicSyncedWithNetwork(String nicName, Network network) {
    VdsNetworkInterface nic = createVdsInterface(Guid.newGuid(), nicName, false, null, network.getVlanId(), network.getName(), network.isVmNetwork(), network.getAddr());
    return nic;
}
#method_after
private VdsNetworkInterface createNicSyncedWithNetwork(String nicName, Network network) {
    VdsNetworkInterface nic = createVdsInterface(Guid.newGuid(), nicName, false, null, network.getVlanId(), network.getName(), network.isVmNetwork(), network.getAddr(), null);
    return nic;
}
#end_block

#method_before
private VdsNetworkInterface createBond(String name, String networkName) {
    return createVdsInterface(Guid.newGuid(), name, true, null, null, networkName, true, null);
}
#method_after
private VdsNetworkInterface createBond(String name, String networkName) {
    return createVdsInterface(Guid.newGuid(), name, true, null, null, networkName, true, null, null);
}
#end_block

#method_before
private VdsNetworkInterface createVlan(String baseIfaceName, int vlanId, String networkName) {
    return createVdsInterface(Guid.newGuid(), baseIfaceName + "." + vlanId, false, null, vlanId, networkName, true, null);
}
#method_after
private VdsNetworkInterface createVlan(String baseIfaceName, int vlanId, String networkName) {
    return createVdsInterface(Guid.newGuid(), baseIfaceName + "." + vlanId, false, null, vlanId, networkName, true, null, null);
}
#end_block

#method_before
private VdsNetworkInterface enslaveOrReleaseNIC(VdsNetworkInterface iface, String bondName) {
    return createVdsInterface(iface.getId(), iface.getName(), false, bondName, null, null, true, null);
}
#method_after
private VdsNetworkInterface enslaveOrReleaseNIC(VdsNetworkInterface iface, String bondName) {
    return createVdsInterface(iface.getId(), iface.getName(), false, bondName, null, null, true, null, null);
}
#end_block

#method_before
private void mockExistingIfaces(VdsNetworkInterface... nics) {
    List<VdsNetworkInterface> existingIfaces = new ArrayList<VdsNetworkInterface>();
    for (int i = 0; i < nics.length; i++) {
        existingIfaces.add(createVdsInterface(nics[i].getId(), nics[i].getName(), nics[i].getBonded(), nics[i].getBondName(), nics[i].getVlanId(), nics[i].getNetworkName(), nics[i].isBridged(), nics[i].getAddress()));
    }
    when(interfaceDAO.getAllInterfacesForVds(any(Guid.class))).thenReturn(existingIfaces);
}
#method_after
private void mockExistingIfaces(VdsNetworkInterface... nics) {
    List<VdsNetworkInterface> existingIfaces = new ArrayList<VdsNetworkInterface>();
    for (int i = 0; i < nics.length; i++) {
        existingIfaces.add(createVdsInterface(nics[i].getId(), nics[i].getName(), nics[i].getBonded(), nics[i].getBondName(), nics[i].getVlanId(), nics[i].getNetworkName(), nics[i].isBridged(), nics[i].getAddress(), nics[i].getLabels()));
    }
    when(interfaceDAO.getAllInterfacesForVds(any(Guid.class))).thenReturn(existingIfaces);
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkIsSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, true, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkIsSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, true, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkIsSyncWithMtuUnset() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, true, iface.getNetworkName(), iface.isBridged(), 0, iface.getVlanId(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkIsSyncWithMtuUnset() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, true, iface.getNetworkName(), iface.isBridged(), 0, iface.getVlanId(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkOutOfSyncWithMtuUnset() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), !iface.isBridged(), 0, RandomUtils.instance().nextInt(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkOutOfSyncWithMtuUnset() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), !iface.isBridged(), 0, RandomUtils.instance().nextInt(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkMtuOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu() + 1, iface.getVlanId(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkMtuOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu() + 1, iface.getVlanId(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkVmNetworkOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), !iface.isBridged(), iface.getMtu(), iface.getVlanId(), null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkVmNetworkOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), !iface.isBridged(), iface.getMtu(), iface.getVlanId(), createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkVlanOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId() + 1, null);
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkVlanOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId() + 1, createQos());
}
#end_block

#method_before
@Test
public void calculateNetworkImplementationDetailsNetworkQosOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId(), new NetworkQoS());
}
#method_after
@Test
public void calculateNetworkImplementationDetailsNetworkQosOutOfSync() throws Exception {
    VdsNetworkInterface iface = createNetworkDevice();
    NetworkQoS qos = createQos();
    qos.setOutboundAverage(30);
    qos.setOutboundPeak(30);
    qos.setOutboundBurst(30);
    calculateNetworkImplementationDetailsAndAssertSync(iface, false, iface.getNetworkName(), iface.isBridged(), iface.getMtu(), iface.getVlanId(), qos);
}
#end_block

#method_before
private VdsNetworkInterface createNetworkDevice() {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setNetworkName(RandomUtils.instance().nextString(10));
    iface.setBridged(RandomUtils.instance().nextBoolean());
    iface.setMtu(100);
    iface.setVlanId(100);
    return iface;
}
#method_after
private VdsNetworkInterface createNetworkDevice() {
    VdsNetworkInterface iface = new VdsNetworkInterface();
    iface.setNetworkName(RandomUtils.instance().nextString(10));
    iface.setBridged(RandomUtils.instance().nextBoolean());
    iface.setMtu(100);
    iface.setVlanId(100);
    iface.setQos(createQos());
    return iface;
}
#end_block

#method_before
public List<String> validate() {
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String name = iface.getName();
        if (addInterfaceToProcessedList(iface)) {
            if (isBond(iface)) {
                extractBondIfModified(iface, name);
            } else if (StringUtils.isNotBlank(iface.getBondName())) {
                extractBondSlave(iface);
            }
            // validate and extract to network map
            if (violations.isEmpty() && StringUtils.isNotBlank(iface.getNetworkName())) {
                extractNetwork(iface);
                validateGateway(iface);
            }
        }
    }
    validateInterfacesExist();
    validateBondSlavesCount();
    extractRemovedNetworks();
    extractRemovedBonds();
    detectSlaveChanges();
    validateMTU();
    return translateViolations();
}
#method_after
public List<String> validate() {
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String name = iface.getName();
        if (addInterfaceToProcessedList(iface)) {
            if (isBond(iface)) {
                extractBondIfModified(iface, name);
            } else if (StringUtils.isNotBlank(iface.getBondName())) {
                extractBondSlave(iface);
            }
            // validate and extract to network map
            if (violations.isEmpty() && StringUtils.isNotBlank(iface.getNetworkName())) {
                extractNetwork(iface);
                validateGateway(iface);
            }
        }
    }
    validateInterfacesExist();
    validateBondSlavesCount();
    extractRemovedNetworks();
    extractRemovedBonds();
    extractModifiedLabeledInterfaces();
    detectSlaveChanges();
    validateMTU();
    validateNotRemovingLabeledNetworks();
    return translateViolations();
}
#end_block

#method_before
public static boolean isBondVlan(List<VdsNetworkInterface> interfaces, VdsNetworkInterface iface) {
    boolean retVal = false;
    if (iface.getVlanId() != null) {
        for (VdsNetworkInterface i : interfaces) {
            if (i.getBonded() != null && i.getBonded() == true && interfaceBasedOn(iface.getName(), i.getName())) {
                retVal = true;
                break;
            }
        }
    }
    return retVal;
}
#method_after
public static boolean isBondVlan(List<VdsNetworkInterface> interfaces, VdsNetworkInterface iface) {
    boolean retVal = false;
    if (isVlan(iface)) {
        for (VdsNetworkInterface i : interfaces) {
            if (i.getBonded() != null && i.getBonded() == true && interfaceBasedOn(iface.getName(), i.getName())) {
                retVal = true;
                break;
            }
        }
    }
    return retVal;
}
#end_block

#method_before
public static boolean interfaceHasVlan(VdsNetworkInterface iface, List<VdsNetworkInterface> allIfaces) {
    for (VdsNetworkInterface i : allIfaces) {
        if (i.getVlanId() != null && interfaceBasedOn(i.getName(), iface.getName())) {
            return true;
        }
    }
    return false;
}
#method_after
public static boolean interfaceHasVlan(VdsNetworkInterface iface, List<VdsNetworkInterface> allIfaces) {
    for (VdsNetworkInterface i : allIfaces) {
        if (isVlan(i) && interfaceBasedOn(i.getName(), iface.getName())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public static boolean isNetworkInSync(VdsNetworkInterface iface, Network network, NetworkQoS qos) {
    return (network.getMtu() == 0 || iface.getMtu() == network.getMtu()) && Objects.equals(iface.getVlanId(), network.getVlanId()) && iface.isBridged() == network.isVmNetwork() && Objects.equals(iface.getQos(), qos);
}
#method_after
public static boolean isNetworkInSync(VdsNetworkInterface iface, Network network, NetworkQoS qos) {
    return (network.getMtu() == 0 || iface.getMtu() == network.getMtu()) && Objects.equals(iface.getVlanId(), network.getVlanId()) && iface.isBridged() == network.isVmNetwork() && isQosInSync(iface, qos);
}
#end_block

#method_before
public static boolean isNonVmNonVlanNetwork(Network network) {
    return !network.isVmNetwork() && network.getVlanId() == null;
}
#method_after
public static boolean isNonVmNonVlanNetwork(Network network) {
    return !network.isVmNetwork() && !isVlan(network);
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    // call getVdsCapabilities verb
    super.executeVdsBrokerCommand();
    updateNetConfigDirtyFlag();
    // update to db
    persistAndEnforceNetworkCompliance(getVds(), skipManagementNetwork());
    proceedProxyReturnValue();
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    // call getVdsCapabilities verb
    super.executeVdsBrokerCommand();
    updateNetConfigDirtyFlag();
    // update to db
    persistAndEnforceNetworkCompliance(getVds(), skipManagementNetwork(), Entities.entitiesByName(getParameters().getInterfaces()));
    proceedProxyReturnValue();
}
#end_block

#method_before
public static NonOperationalReason persistAndEnforceNetworkCompliance(VDS vds, boolean skipManagementNetwork) {
    persistTopology(vds);
    if (vds.getStatus() != VDSStatus.Maintenance) {
        List<Network> clusterNetworks = DbFacade.getInstance().getNetworkDao().getAllForCluster(vds.getVdsGroupId());
        if (skipManagementNetwork) {
            skipManagementNetworkCheck(vds.getInterfaces(), clusterNetworks);
        }
        Map<String, String> customLogValues;
        // here we check if the vds networks match it's cluster networks
        String networks = getMissingOperationalClusterNetworks(vds, clusterNetworks);
        if (networks.length() > 0) {
            customLogValues = new HashMap<String, String>();
            customLogValues.put("Networks", networks);
            setNonOperationl(vds, NonOperationalReason.NETWORK_UNREACHABLE, customLogValues);
            return NonOperationalReason.NETWORK_UNREACHABLE;
        }
        // Check that VM networks are implemented above a bridge.
        networks = getVmNetworksImplementedAsBridgeless(vds, clusterNetworks);
        if (networks.length() > 0) {
            customLogValues = new HashMap<String, String>();
            customLogValues.put("Networks", networks);
            setNonOperationl(vds, NonOperationalReason.VM_NETWORK_IS_BRIDGELESS, customLogValues);
            return NonOperationalReason.VM_NETWORK_IS_BRIDGELESS;
        }
        logUnsynchronizedNetworks(vds, Entities.entitiesByName(clusterNetworks));
    }
    return NonOperationalReason.NONE;
}
#method_after
public static NonOperationalReason persistAndEnforceNetworkCompliance(VDS vds, boolean skipManagementNetwork, Map<String, VdsNetworkInterface> nicsByName) {
    persistTopology(vds, nicsByName);
    if (vds.getStatus() != VDSStatus.Maintenance) {
        List<Network> clusterNetworks = DbFacade.getInstance().getNetworkDao().getAllForCluster(vds.getVdsGroupId());
        if (skipManagementNetwork) {
            skipManagementNetworkCheck(vds.getInterfaces(), clusterNetworks);
        }
        Map<String, String> customLogValues;
        // here we check if the vds networks match it's cluster networks
        String networks = getMissingOperationalClusterNetworks(vds, clusterNetworks);
        if (networks.length() > 0) {
            customLogValues = new HashMap<String, String>();
            customLogValues.put("Networks", networks);
            setNonOperationl(vds, NonOperationalReason.NETWORK_UNREACHABLE, customLogValues);
            return NonOperationalReason.NETWORK_UNREACHABLE;
        }
        // Check that VM networks are implemented above a bridge.
        networks = getVmNetworksImplementedAsBridgeless(vds, clusterNetworks);
        if (networks.length() > 0) {
            customLogValues = new HashMap<String, String>();
            customLogValues.put("Networks", networks);
            setNonOperationl(vds, NonOperationalReason.VM_NETWORK_IS_BRIDGELESS, customLogValues);
            return NonOperationalReason.VM_NETWORK_IS_BRIDGELESS;
        }
        logUnsynchronizedNetworks(vds, Entities.entitiesByName(clusterNetworks));
    }
    return NonOperationalReason.NONE;
}
#end_block

#method_before
private static void persistTopology(VDS vds) {
    InterfaceDao interfaceDAO = DbFacade.getInstance().getInterfaceDao();
    List<VdsNetworkInterface> dbIfaces = interfaceDAO.getAllInterfacesForVds(vds.getId());
    List<String> updatedIfaces = new ArrayList<String>();
    List<VdsNetworkInterface> dbIfacesToBatch = new ArrayList<>();
    // First we check what interfaces need to update/delete
    for (VdsNetworkInterface dbIface : dbIfaces) {
        boolean found = false;
        for (VdsNetworkInterface vdsIface : vds.getInterfaces()) {
            if (dbIface.getName().equals(vdsIface.getName())) {
                // we preserve only the ID from the Database
                // everything else is what we got from getVdsCapabilities
                vdsIface.setId(dbIface.getId());
                dbIfacesToBatch.add(vdsIface);
                updatedIfaces.add(vdsIface.getName());
                found = true;
                break;
            }
        }
        if (!found) {
            interfaceDAO.removeInterfaceFromVds(dbIface.getId());
            interfaceDAO.removeStatisticsForVds(dbIface.getId());
        }
    }
    if (!dbIfacesToBatch.isEmpty()) {
        interfaceDAO.massUpdateInterfacesForVds(dbIfacesToBatch);
    }
    // now all that left is add the interfaces that not exists in the Database
    for (VdsNetworkInterface vdsIface : vds.getInterfaces()) {
        if (!updatedIfaces.contains(vdsIface.getName())) {
            interfaceDAO.saveInterfaceForVds(vdsIface);
            interfaceDAO.saveStatisticsForVds(vdsIface.getStatistics());
        }
    }
}
#method_after
private static void persistTopology(VDS vds, Map<String, VdsNetworkInterface> nicsByName) {
    InterfaceDao interfaceDAO = DbFacade.getInstance().getInterfaceDao();
    List<VdsNetworkInterface> dbIfaces = interfaceDAO.getAllInterfacesForVds(vds.getId());
    List<String> updatedIfaces = new ArrayList<String>();
    List<VdsNetworkInterface> dbIfacesToBatch = new ArrayList<>();
    Map<String, VdsNetworkInterface> hostNicsByNames = Entities.entitiesByName(vds.getInterfaces());
    // First we check what interfaces need to update/delete
    for (VdsNetworkInterface dbIface : dbIfaces) {
        if (hostNicsByNames.containsKey(dbIface.getName())) {
            VdsNetworkInterface vdsIface = hostNicsByNames.get(dbIface.getName());
            // we preserve only the ID and the labels from the Database
            // everything else is what we got from getVdsCapabilities
            vdsIface.setId(dbIface.getId());
            vdsIface.setLabels(dbIface.getLabels());
            dbIfacesToBatch.add(vdsIface);
            updatedIfaces.add(vdsIface.getName());
        } else {
            interfaceDAO.removeInterfaceFromVds(dbIface.getId());
            interfaceDAO.removeStatisticsForVds(dbIface.getId());
        }
    }
    if (nicsByName != null) {
        updateInterfacesWithUserConfiguration(dbIfacesToBatch, nicsByName);
        updateInterfacesWithUserConfiguration(vds.getInterfaces(), nicsByName);
    }
    if (!dbIfacesToBatch.isEmpty()) {
        interfaceDAO.massUpdateInterfacesForVds(dbIfacesToBatch);
    }
    // now all that left is add the interfaces that not exists in the Database
    for (VdsNetworkInterface vdsIface : vds.getInterfaces()) {
        if (!updatedIfaces.contains(vdsIface.getName())) {
            interfaceDAO.saveInterfaceForVds(vdsIface);
            interfaceDAO.saveStatisticsForVds(vdsIface.getStatistics());
        }
    }
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
        if (vds.getUsageCpuPercent() >= vds.getHighUtilization() || vds.getUsageCpuPercent() <= vds.getLowUtilization()) {
            if (vds.getCpuOverCommitTimestamp() == null) {
                vds.setCpuOverCommitTimestamp(new Date());
            }
        } else {
            vds.setCpuOverCommitTimestamp(null);
        }
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    Integer haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    Integer haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
}
#end_block

#method_before
private void applyNetworkChangesToHosts() {
    SyncNetworkParametersBuilder builder = new SyncNetworkParametersBuilder();
    ArrayList<VdcActionParametersBase> parameters = builder.buildParameters(getNetwork());
    if (!parameters.isEmpty()) {
        getBackend().runInternalMultipleActions(VdcActionType.PersistentSetupNetworks, parameters);
    }
}
#method_after
private void applyNetworkChangesToHosts() {
    SyncNetworkParametersBuilder builder = new SyncNetworkParametersBuilder();
    ArrayList<VdcActionParametersBase> parameters = builder.buildParameters(getNetwork(), getOldNetwork());
    if (!parameters.isEmpty()) {
        getBackend().runInternalMultipleActions(VdcActionType.PersistentSetupNetworks, parameters);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (onlyPermittedFieldsChanged()) {
        return true;
    }
    NetworkValidator validatorNew = new NetworkValidator(getNetwork());
    UpdateNetworkValidator validatorOld = new UpdateNetworkValidator(getOldNetwork());
    return validate(validatorNew.dataCenterExists()) && validate(validatorNew.vmNetworkSetCorrectly()) && validate(validatorNew.stpForVmNetworkOnly()) && validate(validatorNew.mtuValid()) && validate(validatorNew.networkPrefixValid()) && validate(validatorNew.vlanIdNotUsed()) && validate(validatorNew.qosExistsInDc()) && validate(validatorOld.networkIsSet()) && validate(validatorOld.notRenamingManagementNetwork(getNetwork())) && validate(validatorNew.networkNameNotUsed()) && validate(validatorOld.networkNotUsedByRunningVms()) && validate(validatorOld.nonVmNetworkNotUsedByVms(getNetwork())) && validate(validatorOld.nonVmNetworkNotUsedByTemplates(getNetwork())) && validate(validatorOld.notRenamingUsedNetwork(getNetworkName())) && (oldAndNewNetworkIsNotExternal() || validate(validatorOld.externalNetworkDetailsUnchanged(getNetwork())));
}
#method_after
@Override
protected boolean canDoAction() {
    if (onlyPermittedFieldsChanged()) {
        return true;
    }
    NetworkValidator validatorNew = new NetworkValidator(getNetwork());
    UpdateNetworkValidator validatorOld = new UpdateNetworkValidator(getOldNetwork());
    return validate(validatorNew.dataCenterExists()) && validate(validatorNew.vmNetworkSetCorrectly()) && validate(validatorNew.stpForVmNetworkOnly()) && validate(validatorNew.mtuValid()) && validate(validatorNew.networkPrefixValid()) && validate(validatorNew.vlanIdNotUsed()) && validate(validatorNew.qosExistsInDc()) && validate(validatorOld.networkIsSet()) && validate(validatorOld.notRenamingManagementNetwork(getNetwork())) && validate(validatorNew.networkNameNotUsed()) && validate(validatorOld.networkNotUsedByRunningVms()) && validate(validatorOld.nonVmNetworkNotUsedByVms(getNetwork())) && validate(validatorOld.nonVmNetworkNotUsedByTemplates(getNetwork())) && validate(validatorOld.notRenamingUsedNetwork(getNetworkName())) && validate(validatorOld.notRenamingLabel(getNetwork().getLabel())) && (oldAndNewNetworkIsNotExternal() || validate(validatorOld.externalNetworkDetailsUnchanged(getNetwork())));
}
#end_block

#method_before
private ArrayList<VdcActionParametersBase> buildParameters(Network network) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getVdsInterfacesByNetworkId(getNetwork().getId());
    Set<Guid> hostIdsToSync = new HashSet<>();
    for (VdsNetworkInterface nic : nics) {
        if (!NetworkUtils.isNetworkInSync(nic, getNetwork(), getDbFacade().getQosDao().get(getNetwork().getQosId()))) {
            hostIdsToSync.add(nic.getVdsId());
        }
    }
    for (Guid hostId : hostIdsToSync) {
        SetupNetworksParameters setupNetworkParams = createSetupNetworksParameters(hostId);
        setupNetworkParams.setNetworksToSync(Collections.singletonList(getNetworkName()));
        parameters.add(setupNetworkParams);
    }
    return parameters;
}
#method_after
private ArrayList<VdcActionParametersBase> buildParameters(Network network, Network oldNetwork) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getVdsInterfacesByNetworkId(network.getId());
    // sync network on nics if the label wasn't changed
    if (!labelChanged()) {
        createSyncNetworkParameters(parameters, nics);
        return parameters;
    }
    // add network to labeled interfaces and sync network on the rest
    if (labelAdded()) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(network);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForAdd = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to add network
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // add network to labeled nic if network not configured on host
            if (nic == null) {
                nicsForAdd.add(labeledNic);
            } else {
                // sync the network
                nicsForSync.add(nic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createAddNetworkParameters(nicsForAdd));
        createSyncNetworkParameters(parameters, nicsForSync);
        return parameters;
    }
    // remove network from labeled interfaces
    if (labelRemoved()) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(oldNetwork);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForRemove = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to remove the network from
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // remove the network from labeled nic
            if (nic != null) {
                nicsForRemove.add(labeledNic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createRemoveNetworkParameters(nicsForRemove));
        createSyncNetworkParameters(parameters, nicsForSync);
        return parameters;
    }
    return parameters;
}
#end_block

#method_before
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    NetworkQoSDao qosDao = getDbFacade().getQosDao();
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface.getName());
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() != 0) {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        if (FeatureSupported.HostNetworkQos(getVds().getVdsGroupCompatibilityVersion())) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(opts, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(qosDao.get(network.getQosId()));
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#method_after
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    NetworkQoSDao qosDao = getDbFacade().getQosDao();
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface.getName());
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() != 0) {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        if (network.getQosId() != null && FeatureSupported.hostNetworkQos(getVds().getVdsGroupCompatibilityVersion())) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(opts, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(qosDao.get(network.getQosId()));
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#end_block

#method_before
private void qos(Network network, VdsNetworkInterface iface, NetworkQoS expectedQos, Version clusterCompatibilityVersion) {
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, Version.v3_3, false);
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, new Version(3, 4), true);
    when(host.getVdsGroupCompatibilityVersion()).thenReturn(clusterCompatibilityVersion);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(network), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(iface));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(network);
    NetworkQosMapper qosMapper = new NetworkQosMapper(networkStruct, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
    assertEquals(qosMapper.deserialize(), expectedQos);
}
#method_after
private void qos(Network network, VdsNetworkInterface iface, NetworkQoS expectedQos, boolean hostNetworkQosSupported) {
    Version version = mock(Version.class);
    when(host.getVdsGroupCompatibilityVersion()).thenReturn(version);
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, version, hostNetworkQosSupported);
    SetupNetworksVdsCommandParameters parameters = new SetupNetworksVdsCommandParameters(Guid.newGuid(), Collections.singletonList(network), Collections.<String>emptyList(), Collections.<VdsNetworkInterface>emptyList(), Collections.<String>emptySet(), Collections.singletonList(iface));
    createCommand(parameters).execute();
    verifyMethodPassedToHost();
    Map<String, Object> networkStruct = assertNeworkWasSent(network);
    NetworkQosMapper qosMapper = new NetworkQosMapper(networkStruct, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
    assertEquals(expectedQos, qosMapper.deserialize());
}
#end_block

#method_before
@Test
public void qosNotSupported() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    when(qosDao.get(any(Guid.class))).thenReturn(createQos());
    qos(network, iface, null, Version.v3_3);
}
#method_after
@Test
public void qosNotSupported() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    when(qosDao.get(any(Guid.class))).thenReturn(createQos());
    qos(network, iface, null, false);
}
#end_block

#method_before
@Test
public void qosOnNetwork() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    NetworkQoS qos = createQos();
    when(qosDao.get(any(Guid.class))).thenReturn(qos);
    qos(network, iface, qos, new Version(3, 4));
}
#method_after
@Test
public void qosOnNetwork() {
    Network network = createNetwork(null);
    VdsNetworkInterface iface = createNic("eth0", null, null, network.getName());
    Guid qosId = Guid.newGuid();
    network.setQosId(qosId);
    NetworkQoS qos = createQos();
    qos.setId(qosId);
    when(qosDao.get(qosId)).thenReturn(qos);
    qos(network, iface, qos, true);
}
#end_block

#method_before
private NetworkQoS createQos() {
    NetworkQoS qos = new NetworkQoS();
    qos.setInboundAverage(30);
    qos.setInboundPeak(30);
    qos.setInboundBurst(30);
    return qos;
}
#method_after
private NetworkQoS createQos() {
    NetworkQoS qos = new NetworkQoS();
    qos.setInboundAverage(RandomUtils.instance().nextInt(0, 1000000));
    qos.setInboundPeak(RandomUtils.instance().nextInt(0, 1000000));
    qos.setInboundBurst(RandomUtils.instance().nextInt(0, 1000000));
    qos.setOutboundAverage(RandomUtils.instance().nextInt(0, 1000000));
    qos.setOutboundPeak(RandomUtils.instance().nextInt(0, 1000000));
    qos.setOutboundBurst(RandomUtils.instance().nextInt(0, 1000000));
    return qos;
}
#end_block

#method_before
private OsRepository getOsRepository() {
    return SimpleDependecyInjector.getInstance().get(OsRepository.class);
}
#method_after
private static OsRepository getOsRepository() {
    return SimpleDependecyInjector.getInstance().get(OsRepository.class);
}
#end_block

#method_before
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.CDROM) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct);
        addDevice(struct, vmDevice, "");
    }
    // check first if CD was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            struct = new HashMap<String, Object>();
            String cdPath = vm.getCdPath();
            addCdDetails(vmDevice, struct);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
}
#method_after
@Override
protected void buildVmCD() {
    Map<String, Object> struct;
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.CDROM) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, "");
    }
    // check first if CD was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            struct = new HashMap<String, Object>();
            String cdPath = vm.getCdPath();
            addCdDetails(vmDevice, struct, vm);
            addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmFloppy() {
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.FLOPPY) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct);
        addDevice(struct, vmDevice, "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            Map<String, Object> struct = new HashMap<String, Object>();
            String file = vm.getFloppyPath();
            addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#method_after
@Override
protected void buildVmFloppy() {
    // check if we have payload CD
    if (vm.getVmPayload() != null && vm.getVmPayload().getType() == VmDeviceType.FLOPPY) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, (vm.getVmPayload() == null) ? null : vm.getVmPayload().getSpecParams(), true, true, true, "", null, null);
        Map<String, Object> struct = new HashMap<String, Object>();
        addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            Map<String, Object> struct = new HashMap<String, Object>();
            String file = vm.getFloppyPath();
            addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<String, Object>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForVirtioScsiDisk(unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#method_after
@Override
protected void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<String, Object>();
        // get vm device for this disk from DB
        VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && disk.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.put(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null && FeatureSupported.hotPlugDiskSnapshot(vm.getVdsGroupCompatibilityVersion())) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
@Override
protected void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Map.Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), Base64.encodeBase64String(entry.getValue()));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addCdDetails(vmDevice, struct);
    addDevice(struct, vmDevice, "");
}
#method_after
@Override
protected void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Map.Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), Base64.encodeBase64String(entry.getValue()));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null);
    Map<String, Object> struct = new HashMap<String, Object>();
    addCdDetails(vmDevice, struct, vm);
    addDevice(struct, vmDevice, "");
}
#end_block

#method_before
private static void addCdDetails(VmDevice vmDevice, Map<String, Object> struct) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    // IDE slot 2 is reserved by VDSM to CDROM
    struct.put(VdsProperties.Index, "2");
    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
    struct.put(VdsProperties.ReadOnly, Boolean.TRUE.toString());
    struct.put(VdsProperties.Shareable, Boolean.FALSE.toString());
}
#method_after
private static void addCdDetails(VmDevice vmDevice, Map<String, Object> struct, VM vm) {
    OsRepository osRepository = getOsRepository();
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getVdsGroupCompatibilityVersion());
    if ("scsi".equals(cdInterface)) {
        // SCSI unit 0 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "0");
        struct.put(VdsProperties.Address, createAddressForScsiDisk(0, 0));
    } else if ("ide".equals(cdInterface)) {
        // IDE slot 2 is reserved by VDSM to CDROM
        struct.put(VdsProperties.Index, "2");
    }
    struct.put(VdsProperties.INTERFACE, cdInterface);
    struct.put(VdsProperties.ReadOnly, Boolean.TRUE.toString());
    struct.put(VdsProperties.Shareable, Boolean.FALSE.toString());
}
#end_block

#method_before
@Override
protected void buildVmVirtioScsi() {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName());
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        struct.put(VdsProperties.Device, VdsProperties.Scsi);
        struct.put(VdsProperties.Model, VdsProperties.VirtioScsi);
        addAddress(vmDevice, struct);
        addDevice(struct, vmDevice, null);
    }
}
#method_after
@Override
protected void buildVmVirtioScsi() {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName());
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        struct.put(VdsProperties.Device, VdsProperties.Scsi);
        struct.put(VdsProperties.Model, VdsProperties.VirtioScsi);
        struct.put(VdsProperties.Index, Integer.toString(virtioScsiIndex));
        addAddress(vmDevice, struct);
        virtioScsiIndex++;
        addDevice(struct, vmDevice, null);
    }
}
#end_block

#method_before
public static Map<VmDevice, Integer> getVmDeviceUnitMapForVirtioScsiDisks(VM vm) {
    List<Disk> disks = new ArrayList<Disk>(vm.getDiskMap().values());
    Map<VmDevice, Integer> vmDeviceUnitMap = new HashMap<>();
    Map<VmDevice, Disk> vmDeviceDiskMap = new HashMap<>();
    for (Disk disk : disks) {
        if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
            VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
            Map<String, String> address = XmlRpcStringUtils.string2Map(vmDevice.getAddress());
            String unitStr = address.get(VdsProperties.Unit);
            // Otherwise, adding to 'vmDeviceDiskMap' for setting the unit property later.
            if (StringUtils.isNotEmpty(unitStr)) {
                vmDeviceUnitMap.put(vmDevice, Integer.valueOf(unitStr));
            } else {
                vmDeviceDiskMap.put(vmDevice, disk);
            }
        }
    }
    // Find available unit (disk's index in VirtIO-SCSI controller) for disks with empty address
    for (Entry<VmDevice, Disk> entry : vmDeviceDiskMap.entrySet()) {
        int unit = getAvailableUnitForVirtioScsiDisk(vmDeviceUnitMap);
        vmDeviceUnitMap.put(entry.getKey(), unit);
    }
    return vmDeviceUnitMap;
}
#method_after
public static Map<VmDevice, Integer> getVmDeviceUnitMapForVirtioScsiDisks(VM vm) {
    return getVmDeviceUnitMapForScsiDisks(vm, DiskInterface.VirtIO_SCSI, false);
}
#end_block

#method_before
private void applyNetworkChangesToHosts() {
    SyncNetworkParametersBuilder builder = new SyncNetworkParametersBuilder();
    ArrayList<VdcActionParametersBase> parameters = builder.buildParameters(getNetwork());
    if (!parameters.isEmpty()) {
        getBackend().runInternalMultipleActions(VdcActionType.PersistentSetupNetworks, parameters);
    }
}
#method_after
private void applyNetworkChangesToHosts() {
    SyncNetworkParametersBuilder builder = new SyncNetworkParametersBuilder();
    ArrayList<VdcActionParametersBase> parameters = builder.buildParameters(getNetwork(), getOldNetwork());
    if (!parameters.isEmpty()) {
        getBackend().runInternalMultipleActions(VdcActionType.PersistentSetupNetworks, parameters);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (onlyPermittedFieldsChanged()) {
        return true;
    }
    NetworkValidator validatorNew = new NetworkValidator(getNetwork());
    UpdateNetworkValidator validatorOld = new UpdateNetworkValidator(getOldNetwork());
    return validate(validatorNew.dataCenterExists()) && validate(validatorNew.vmNetworkSetCorrectly()) && validate(validatorNew.stpForVmNetworkOnly()) && validate(validatorNew.mtuValid()) && validate(validatorNew.networkPrefixValid()) && validate(validatorNew.vlanIdNotUsed()) && validate(validatorNew.qosExistsInDc()) && validate(validatorOld.networkIsSet()) && validate(validatorOld.notRenamingManagementNetwork(getNetwork())) && validate(validatorNew.networkNameNotUsed()) && validate(validatorOld.networkNotUsedByRunningVms()) && validate(validatorOld.nonVmNetworkNotUsedByVms(getNetwork())) && validate(validatorOld.nonVmNetworkNotUsedByTemplates(getNetwork())) && validate(validatorOld.notRenamingUsedNetwork(getNetworkName())) && (oldAndNewNetworkIsNotExternal() || validate(validatorOld.externalNetworkDetailsUnchanged(getNetwork())));
}
#method_after
@Override
protected boolean canDoAction() {
    if (onlyPermittedFieldsChanged()) {
        return true;
    }
    NetworkValidator validatorNew = new NetworkValidator(getNetwork());
    UpdateNetworkValidator validatorOld = new UpdateNetworkValidator(getOldNetwork());
    return validate(validatorNew.dataCenterExists()) && validate(validatorNew.vmNetworkSetCorrectly()) && validate(validatorNew.stpForVmNetworkOnly()) && validate(validatorNew.mtuValid()) && validate(validatorNew.networkPrefixValid()) && validate(validatorNew.vlanIdNotUsed()) && validate(validatorNew.qosExistsInDc()) && validate(validatorOld.networkIsSet()) && validate(validatorOld.notRenamingManagementNetwork(getNetwork())) && validate(validatorNew.networkNameNotUsed()) && validate(validatorOld.networkNotUsedByRunningVms()) && validate(validatorOld.nonVmNetworkNotUsedByVms(getNetwork())) && validate(validatorOld.nonVmNetworkNotUsedByTemplates(getNetwork())) && validate(validatorOld.notRenamingUsedNetwork(getNetworkName())) && validate(validatorOld.notRenamingLabel(getNetwork().getLabel())) && (oldAndNewNetworkIsNotExternal() || validate(validatorOld.externalNetworkDetailsUnchanged(getNetwork())));
}
#end_block

#method_before
private ArrayList<VdcActionParametersBase> buildParameters(Network network) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getVdsInterfacesByNetworkId(getNetwork().getId());
    Set<Guid> hostIdsToSync = new HashSet<>();
    for (VdsNetworkInterface nic : nics) {
        if (!NetworkUtils.isNetworkInSync(nic, getNetwork())) {
            hostIdsToSync.add(nic.getVdsId());
        }
    }
    for (Guid hostId : hostIdsToSync) {
        SetupNetworksParameters setupNetworkParams = createSetupNetworksParameters(hostId);
        setupNetworkParams.setNetworksToSync(Collections.singletonList(getNetworkName()));
        parameters.add(setupNetworkParams);
    }
    return parameters;
}
#method_after
private ArrayList<VdcActionParametersBase> buildParameters(Network network, Network oldNetwork) {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getVdsInterfacesByNetworkId(network.getId());
    // sync network on nics if the label wasn't changed
    if (!labelChanged()) {
        createSyncNetworkParameters(parameters, nics);
        return parameters;
    }
    // add network to labeled interfaces and sync network on the rest
    if (labelAdded()) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(network);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForAdd = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to add network
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // add network to labeled nic if network not configured on host
            if (nic == null) {
                nicsForAdd.add(labeledNic);
            } else {
                // sync the network
                nicsForSync.add(nic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createAddNetworkParameters(nicsForAdd));
        createSyncNetworkParameters(parameters, nicsForSync);
        return parameters;
    }
    // remove network from labeled interfaces
    if (labelRemoved()) {
        List<VdsNetworkInterface> labeledNics = getLabeledNics(oldNetwork);
        Map<Guid, VdsNetworkInterface> hostToNic = mapHostToNic(nics);
        List<VdsNetworkInterface> nicsForRemove = new ArrayList<>();
        Set<VdsNetworkInterface> nicsForSync = new HashSet<>();
        // nics to remove the network from
        for (VdsNetworkInterface labeledNic : labeledNics) {
            VdsNetworkInterface nic = hostToNic.get(labeledNic.getVdsId());
            // remove the network from labeled nic
            if (nic != null) {
                nicsForRemove.add(labeledNic);
            }
        }
        // add the unlabeled nics to be synced
        for (VdsNetworkInterface nic : nics) {
            if (!nicsForSync.contains(nic)) {
                nicsForSync.add(nic);
            }
        }
        parameters.addAll(createRemoveNetworkParameters(nicsForRemove));
        createSyncNetworkParameters(parameters, nicsForSync);
        return parameters;
    }
    return parameters;
}
#end_block

#method_before
public ValidationResult vlanIdNotUsed() {
    if (network.getVlanId() != null) {
        for (Network otherNetwork : getNetworks()) {
            if (otherNetwork.getVlanId() != null && otherNetwork.getVlanId().equals(network.getVlanId()) && !otherNetwork.getId().equals(network.getId())) {
                return new ValidationResult(VdcBllMessages.NETWORK_VLAN_IN_USE, String.format("$vlanId %d", network.getVlanId()));
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult vlanIdNotUsed() {
    if (NetworkUtils.isVlan(network)) {
        for (Network otherNetwork : getNetworks()) {
            if (NetworkUtils.isVlan(otherNetwork) && otherNetwork.getVlanId().equals(network.getVlanId()) && !otherNetwork.getId().equals(network.getId())) {
                return new ValidationResult(VdcBllMessages.NETWORK_VLAN_IN_USE, String.format("$vlanId %d", network.getVlanId()));
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
protected NetworkQoS getOldQos() {
    if (!oldQosRetrieved) {
        oldQos = DbFacade.getInstance().getQosDao().get(qos.getId());
        oldQosRetrieved = true;
    }
    return oldQos;
}
#method_after
protected NetworkQoS getOldQos() {
    if (oldQos == null) {
        oldQos = DbFacade.getInstance().getQosDao().get(qos.getId());
    }
    return oldQos;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (validateParameters()) {
        NetworkQosValidator validator = new NetworkQosValidator(getNetworkQoS());
        if (!validate(validator.qosExists()) || !validate(validator.consistentDataCenter())) {
            return false;
        } else {
            NetworkQoS oldNetworkQoS = getNetworkQoSDao().get(getNetworkQoS().getId());
            if (validateValues()) {
                if (!oldNetworkQoS.getName().equals(getNetworkQoS().getName())) {
                    return validateNameNotExistInDC();
                }
            } else {
                return false;
            }
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    NetworkQosValidator validator = new NetworkQosValidator(getNetworkQoS());
    return (validateParameters() && validate(validator.qosExists()) && validate(validator.consistentDataCenter()) && validateValues() && validate(validator.nameNotChangedOrNotTaken()));
}
#end_block

#method_before
@Before
public void setup() {
    qos = new NetworkQoS();
    oldQos = new NetworkQoS();
    validator = spy(new NetworkQosValidator(qos));
    doReturn(oldQos).when(validator).getOldQos();
    nullValidator = spy(new NetworkQosValidator(null));
    doReturn(oldQos).when(nullValidator).getOldQos();
}
#method_after
@Before
public void setup() {
    qos = new NetworkQoS();
    oldQos = new NetworkQoS();
    allQos = new ArrayList<NetworkQoS>();
    validator = spy(new NetworkQosValidator(qos));
    doReturn(oldQos).when(validator).getOldQos();
    doReturn(allQos).when(validator).getAllQosInDc();
    nullValidator = spy(new NetworkQosValidator(null));
    doReturn(oldQos).when(nullValidator).getOldQos();
}
#end_block

#method_before
@Override
public void saveStatisticsForVds(VdsNetworkStatistics stats) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", stats.getId()).addValue("rx_drop", stats.getReceiveDropRate()).addValue("rx_rate", stats.getReceiveRate()).addValue("tx_drop", stats.getTransmitDropRate()).addValue("tx_rate", stats.getTransmitRate()).addValue("iface_status", stats.getStatus()).addValue("vds_id", stats.getVdsId());
    getCallsHandler().executeModification("Insertvds_interface_statistics", parameterSource);
}
#method_after
@Override
public void saveStatisticsForVds(VdsNetworkStatistics stats) {
    MapSqlParameterSource parameterSource = createStatisticsParametersMapper(stats);
    getCallsHandler().executeModification("Insertvds_interface_statistics", parameterSource);
}
#end_block

#method_before
@Override
public void massUpdateInterfacesForVds(List<VdsNetworkInterface> dbIfacesToBatch) {
    updateAllInBatch("Updatevds_interface", dbIfacesToBatch, new MapSqlParameterMapper<VdsNetworkInterface>() {

        @Override
        public MapSqlParameterSource map(VdsNetworkInterface entity) {
            MapSqlParameterSource paramValue = new MapSqlParameterSource().addValue("addr", entity.getAddress()).addValue("bond_name", entity.getBondName()).addValue("bond_type", entity.getBondType()).addValue("gateway", entity.getGateway()).addValue("id", entity.getId()).addValue("is_bond", entity.getBonded()).addValue("bond_opts", entity.getBondOptions()).addValue("mac_addr", entity.getMacAddress()).addValue("name", entity.getName()).addValue("network_name", entity.getNetworkName()).addValue("speed", entity.getSpeed()).addValue("subnet", entity.getSubnet()).addValue("boot_protocol", entity.getBootProtocol()).addValue("type", entity.getType()).addValue("vds_id", entity.getVdsId()).addValue("vlan_id", entity.getVlanId()).addValue("mtu", entity.getMtu()).addValue("bridged", entity.isBridged()).addValue("qos_id", entity.getQos() == null ? null : entity.getQos().getId());
            return paramValue;
        }
    });
}
#method_after
@Override
public void massUpdateInterfacesForVds(List<VdsNetworkInterface> dbIfacesToBatch) {
    updateAllInBatch("Updatevds_interface", dbIfacesToBatch, new MapSqlParameterMapper<VdsNetworkInterface>() {

        @Override
        public MapSqlParameterSource map(VdsNetworkInterface nic) {
            return createInterfaceParametersMapper(nic);
        }
    });
}
#end_block

#method_before
public void updateAllInBatch(String procedureName, Collection<VdsNetworkInterface> paramValues, MapSqlParameterMapper<VdsNetworkInterface> mapper) {
    getCallsHandler().executeStoredProcAsBatch(procedureName, paramValues, mapper);
}
#method_after
public void updateAllInBatch(String procedureName, Collection<VdsNetworkInterface> paramValues, MapSqlParameterMapper<VdsNetworkInterface> mapper) {
    for (VdsNetworkInterface entity : paramValues) {
        persistQosChanges(entity);
    }
    getCallsHandler().executeStoredProcAsBatch(procedureName, paramValues, mapper);
}
#end_block

#method_before
@Override
public void saveInterfaceForVds(VdsNetworkInterface entity) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("addr", entity.getAddress()).addValue("bond_name", entity.getBondName()).addValue("bond_type", entity.getBondType()).addValue("gateway", entity.getGateway()).addValue("id", entity.getId()).addValue("is_bond", entity.getBonded()).addValue("bond_opts", entity.getBondOptions()).addValue("mac_addr", entity.getMacAddress()).addValue("name", entity.getName()).addValue("network_name", entity.getNetworkName()).addValue("speed", entity.getSpeed()).addValue("subnet", entity.getSubnet()).addValue("boot_protocol", entity.getBootProtocol()).addValue("type", entity.getType()).addValue("vds_id", entity.getVdsId()).addValue("vlan_id", entity.getVlanId()).addValue("mtu", entity.getMtu()).addValue("bridged", entity.isBridged()).addValue("qos_id", entity.getQos() == null ? null : entity.getQos().getId());
    getCallsHandler().executeModification("Insertvds_interface", parameterSource);
}
#method_after
@Override
public void saveInterfaceForVds(VdsNetworkInterface nic) {
    persistQosChanges(nic);
    MapSqlParameterSource parameterSource = createInterfaceParametersMapper(nic);
    getCallsHandler().executeModification("Insertvds_interface", parameterSource);
}
#end_block

#method_before
@Override
public void massUpdateStatisticsForVds(Collection<VdsNetworkStatistics> statistics) {
    List<MapSqlParameterSource> executions = new ArrayList<>(statistics.size());
    for (VdsNetworkStatistics stats : statistics) {
        executions.add(getCustomMapSqlParameterSource().addValue("id", stats.getId()).addValue("rx_drop", stats.getReceiveDropRate()).addValue("rx_rate", stats.getReceiveRate()).addValue("tx_drop", stats.getTransmitDropRate()).addValue("tx_rate", stats.getTransmitRate()).addValue("iface_status", stats.getStatus()).addValue("vds_id", stats.getVdsId()));
    }
    getCallsHandler().executeStoredProcAsBatch("Updatevds_interface_statistics", executions);
}
#method_after
@Override
public void massUpdateStatisticsForVds(Collection<VdsNetworkStatistics> statistics) {
    List<MapSqlParameterSource> executions = new ArrayList<>(statistics.size());
    for (VdsNetworkStatistics stats : statistics) {
        executions.add(createStatisticsParametersMapper(stats));
    }
    getCallsHandler().executeStoredProcAsBatch("Updatevds_interface_statistics", executions);
}
#end_block

#method_before
private void update(VdsNetworkStatistics stats) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", stats.getId()).addValue("rx_drop", stats.getReceiveDropRate()).addValue("rx_rate", stats.getReceiveRate()).addValue("tx_drop", stats.getTransmitDropRate()).addValue("tx_rate", stats.getTransmitRate()).addValue("iface_status", stats.getStatus()).addValue("vds_id", stats.getVdsId());
    getCallsHandler().executeModification("Updatevds_interface_statistics", parameterSource);
}
#method_after
private void update(VdsNetworkStatistics stats) {
    getCallsHandler().executeModification("Updatevds_interface_statistics", createStatisticsParametersMapper(stats));
}
#end_block

#method_before
@Override
public void updateInterfaceForVds(VdsNetworkInterface entity) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("addr", entity.getAddress()).addValue("bond_name", entity.getBondName()).addValue("bond_type", entity.getBondType()).addValue("gateway", entity.getGateway()).addValue("id", entity.getId()).addValue("is_bond", entity.getBonded()).addValue("bond_opts", entity.getBondOptions()).addValue("mac_addr", entity.getMacAddress()).addValue("name", entity.getName()).addValue("network_name", entity.getNetworkName()).addValue("speed", entity.getSpeed()).addValue("subnet", entity.getSubnet()).addValue("boot_protocol", entity.getBootProtocol()).addValue("type", entity.getType()).addValue("vds_id", entity.getVdsId()).addValue("vlan_id", entity.getVlanId()).addValue("mtu", entity.getMtu()).addValue("bridged", entity.isBridged()).addValue("qos_id", entity.getQos() == null ? null : entity.getQos().getId());
    getCallsHandler().executeModification("Updatevds_interface", parameterSource);
}
#method_after
@Override
public void updateInterfaceForVds(VdsNetworkInterface nic) {
    persistQosChanges(nic);
    getCallsHandler().executeModification("Updatevds_interface", createInterfaceParametersMapper(nic));
}
#end_block

#method_before
@Override
public void removeInterfaceFromVds(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", id);
    getCallsHandler().executeModification("Deletevds_interface", parameterSource);
}
#method_after
@Override
public void removeInterfaceFromVds(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", id);
    DbFacade.getInstance().getQosDao().remove(id);
    getCallsHandler().executeModification("Deletevds_interface", parameterSource);
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(Network network) {
    return getCustomMapSqlParameterSource().addValue("addr", network.getAddr()).addValue("description", network.getDescription()).addValue("free_text_comment", network.getComment()).addValue("id", network.getId()).addValue("name", network.getName()).addValue("subnet", network.getSubnet()).addValue("gateway", network.getGateway()).addValue("type", network.getType()).addValue("vlan_id", network.getVlanId()).addValue("stp", network.getStp()).addValue("storage_pool_id", network.getDataCenterId()).addValue("mtu", network.getMtu()).addValue("vm_network", network.isVmNetwork()).addValue("provider_network_provider_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getProviderId()).addValue("provider_network_external_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getExternalId()).addValue("qos_id", network.getQos() == null ? null : network.getQos().getId());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(Network network) {
    return getCustomMapSqlParameterSource().addValue("addr", network.getAddr()).addValue("description", network.getDescription()).addValue("free_text_comment", network.getComment()).addValue("id", network.getId()).addValue("name", network.getName()).addValue("subnet", network.getSubnet()).addValue("gateway", network.getGateway()).addValue("type", network.getType()).addValue("vlan_id", network.getVlanId()).addValue("stp", network.getStp()).addValue("storage_pool_id", network.getDataCenterId()).addValue("mtu", network.getMtu()).addValue("vm_network", network.isVmNetwork()).addValue("provider_network_provider_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getProviderId()).addValue("provider_network_external_id", network.getProvidedBy() == null ? null : network.getProvidedBy().getExternalId()).addValue("qos_id", network.getQosId()).addValue("label", network.getLabel());
}
#end_block

#method_before
@Override
public T mapRow(ResultSet rs, int rowNum) throws SQLException {
    T entity = createNetworkEntity();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setName(rs.getString("name"));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setType((Integer) rs.getObject("type"));
    entity.setAddr(rs.getString("addr"));
    entity.setSubnet(rs.getString("subnet"));
    entity.setGateway(rs.getString("gateway"));
    entity.setVlanId((Integer) rs.getObject("vlan_id"));
    entity.setStp(rs.getBoolean("stp"));
    entity.setDataCenterId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setMtu(rs.getInt("mtu"));
    entity.setVmNetwork(rs.getBoolean("vm_network"));
    Guid providerId = getGuid(rs, "provider_network_provider_id");
    if (providerId != null) {
        entity.setProvidedBy(new ProviderNetwork(providerId, rs.getString("provider_network_external_id")));
    }
    entity.setQos(DbFacade.getInstance().getQosDao().get(getGuid(rs, "qos_id")));
    return entity;
}
#method_after
@Override
public T mapRow(ResultSet rs, int rowNum) throws SQLException {
    T entity = createNetworkEntity();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setName(rs.getString("name"));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setType((Integer) rs.getObject("type"));
    entity.setAddr(rs.getString("addr"));
    entity.setSubnet(rs.getString("subnet"));
    entity.setGateway(rs.getString("gateway"));
    entity.setVlanId((Integer) rs.getObject("vlan_id"));
    entity.setStp(rs.getBoolean("stp"));
    entity.setDataCenterId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setMtu(rs.getInt("mtu"));
    entity.setVmNetwork(rs.getBoolean("vm_network"));
    Guid providerId = getGuid(rs, "provider_network_provider_id");
    if (providerId != null) {
        entity.setProvidedBy(new ProviderNetwork(providerId, rs.getString("provider_network_external_id")));
    }
    entity.setQosId(getGuid(rs, "qos_id"));
    entity.setLabel(rs.getString("label"));
    return entity;
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(getName()).append(" {id=").append(getId()).append(", vdsId=").append(getVdsId()).append(", macAddress=").append(getMacAddress()).append(", networkName=").append(getNetworkName()).append(", vlanId=").append(getVlanId()).append(", bonded=").append(getBonded()).append(", bondName=").append(getBondName()).append(", bondOptions=").append(getBondOptions()).append(", bootProtocol=").append(getBootProtocol()).append(", address=").append(getAddress()).append(", subnet=").append(getSubnet()).append(", gateway=").append(getGateway()).append(", mtu=").append(getMtu()).append(", bridged=").append(isBridged()).append(", speed=").append(getSpeed()).append(", type=").append(getType()).append(", networkImplementationDetails=").append(getNetworkImplementationDetails()).append(", qos=").append(getQos()).append("}");
    return builder.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(getName()).append(" {id=").append(getId()).append(", vdsId=").append(getVdsId()).append(", macAddress=").append(getMacAddress()).append(", networkName=").append(getNetworkName()).append(", vlanId=").append(getVlanId()).append(", bonded=").append(getBonded()).append(", bondName=").append(getBondName()).append(", bondOptions=").append(getBondOptions()).append(", bootProtocol=").append(getBootProtocol()).append(", address=").append(getAddress()).append(", subnet=").append(getSubnet()).append(", gateway=").append(getGateway()).append(", mtu=").append(getMtu()).append(", bridged=").append(isBridged()).append(", speed=").append(getSpeed()).append(", type=").append(getType()).append(", networkImplementationDetails=").append(getNetworkImplementationDetails()).append(", qos=").append(getQos()).append(", labels=").append(getLabels()).append("}");
    return builder.toString();
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + ((address == null) ? 0 : address.hashCode());
    result = prime * result + ((bondName == null) ? 0 : bondName.hashCode());
    result = prime * result + ((bondOptions == null) ? 0 : bondOptions.hashCode());
    result = prime * result + ((bondType == null) ? 0 : bondType.hashCode());
    result = prime * result + ((bonded == null) ? 0 : bonded.hashCode());
    result = prime * result + ((bootProtocol == null) ? 0 : bootProtocol.hashCode());
    result = prime * result + ((networkName == null) ? 0 : networkName.hashCode());
    result = prime * result + (bridged ? 1231 : 1237);
    result = prime * result + ((gateway == null) ? 0 : gateway.hashCode());
    result = prime * result + mtu;
    result = prime * result + ((subnet == null) ? 0 : subnet.hashCode());
    result = prime * result + ((vdsId == null) ? 0 : vdsId.hashCode());
    result = prime * result + ((vlanId == null) ? 0 : vlanId.hashCode());
    result = prime * result + ((qos == null) ? 0 : qos.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + ((address == null) ? 0 : address.hashCode());
    result = prime * result + ((bondName == null) ? 0 : bondName.hashCode());
    result = prime * result + ((bondOptions == null) ? 0 : bondOptions.hashCode());
    result = prime * result + ((bondType == null) ? 0 : bondType.hashCode());
    result = prime * result + ((bonded == null) ? 0 : bonded.hashCode());
    result = prime * result + ((bootProtocol == null) ? 0 : bootProtocol.hashCode());
    result = prime * result + ((networkName == null) ? 0 : networkName.hashCode());
    result = prime * result + (bridged ? 1231 : 1237);
    result = prime * result + ((gateway == null) ? 0 : gateway.hashCode());
    result = prime * result + mtu;
    result = prime * result + ((subnet == null) ? 0 : subnet.hashCode());
    result = prime * result + ((vdsId == null) ? 0 : vdsId.hashCode());
    result = prime * result + ((vlanId == null) ? 0 : vlanId.hashCode());
    result = prime * result + ((qos == null) ? 0 : qos.hashCode());
    result = prime * result + ((labels == null) ? 0 : labels.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (!(obj instanceof VdsNetworkInterface)) {
        return false;
    }
    VdsNetworkInterface other = (VdsNetworkInterface) obj;
    if (address == null) {
        if (other.address != null) {
            return false;
        }
    } else if (!address.equals(other.address)) {
        return false;
    }
    if (bondName == null) {
        if (other.bondName != null) {
            return false;
        }
    } else if (!bondName.equals(other.bondName)) {
        return false;
    }
    if (bondOptions == null) {
        if (other.bondOptions != null) {
            return false;
        }
    } else if (!bondOptions.equals(other.bondOptions)) {
        return false;
    }
    if (bondType == null) {
        if (other.bondType != null) {
            return false;
        }
    } else if (!bondType.equals(other.bondType)) {
        return false;
    }
    if (bonded == null) {
        if (other.bonded != null) {
            return false;
        }
    } else if (!bonded.equals(other.bonded)) {
        return false;
    }
    if (bootProtocol != other.bootProtocol) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(networkName, other.networkName)) {
        return false;
    }
    if (bridged != other.bridged) {
        return false;
    }
    if (gateway == null) {
        if (other.gateway != null) {
            return false;
        }
    } else if (!gateway.equals(other.gateway)) {
        return false;
    }
    if (mtu != other.mtu) {
        return false;
    }
    if (subnet == null) {
        if (other.subnet != null) {
            return false;
        }
    } else if (!subnet.equals(other.subnet)) {
        return false;
    }
    if (vdsId == null) {
        if (other.vdsId != null) {
            return false;
        }
    } else if (!vdsId.equals(other.vdsId)) {
        return false;
    }
    if (vlanId == null) {
        if (other.vlanId != null) {
            return false;
        }
    } else if (!vlanId.equals(other.vlanId)) {
        return false;
    }
    if (!Objects.equals(qos, other.qos)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (!(obj instanceof VdsNetworkInterface)) {
        return false;
    }
    VdsNetworkInterface other = (VdsNetworkInterface) obj;
    if (address == null) {
        if (other.address != null) {
            return false;
        }
    } else if (!address.equals(other.address)) {
        return false;
    }
    if (bondName == null) {
        if (other.bondName != null) {
            return false;
        }
    } else if (!bondName.equals(other.bondName)) {
        return false;
    }
    if (bondOptions == null) {
        if (other.bondOptions != null) {
            return false;
        }
    } else if (!bondOptions.equals(other.bondOptions)) {
        return false;
    }
    if (bondType == null) {
        if (other.bondType != null) {
            return false;
        }
    } else if (!bondType.equals(other.bondType)) {
        return false;
    }
    if (bonded == null) {
        if (other.bonded != null) {
            return false;
        }
    } else if (!bonded.equals(other.bonded)) {
        return false;
    }
    if (bootProtocol != other.bootProtocol) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(networkName, other.networkName)) {
        return false;
    }
    if (bridged != other.bridged) {
        return false;
    }
    if (gateway == null) {
        if (other.gateway != null) {
            return false;
        }
    } else if (!gateway.equals(other.gateway)) {
        return false;
    }
    if (mtu != other.mtu) {
        return false;
    }
    if (subnet == null) {
        if (other.subnet != null) {
            return false;
        }
    } else if (!subnet.equals(other.subnet)) {
        return false;
    }
    if (vdsId == null) {
        if (other.vdsId != null) {
            return false;
        }
    } else if (!vdsId.equals(other.vdsId)) {
        return false;
    }
    if (vlanId == null) {
        if (other.vlanId != null) {
            return false;
        }
    } else if (!vlanId.equals(other.vlanId)) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(qos, other.qos)) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(labels, other.labels)) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(getName()).append(" {id=").append(getId()).append(", description=").append(getDescription()).append(", comment=").append(getComment()).append(", subnet=").append(getSubnet()).append(", gateway=").append(getGateway()).append(", type=").append(getType()).append(", vlanId=").append(getVlanId()).append(", stp=").append(getStp()).append(", dataCenterId=").append(getDataCenterId()).append(", mtu=").append(getMtu()).append(", vmNetwork=").append(isVmNetwork()).append(", cluster=").append(getCluster()).append(", providedBy=").append(getProvidedBy()).append(", label=").append(getLabel()).append(", qos=").append(getQos()).append("}");
    return builder.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(getName()).append(" {id=").append(getId()).append(", description=").append(getDescription()).append(", comment=").append(getComment()).append(", subnet=").append(getSubnet()).append(", gateway=").append(getGateway()).append(", type=").append(getType()).append(", vlanId=").append(getVlanId()).append(", stp=").append(getStp()).append(", dataCenterId=").append(getDataCenterId()).append(", mtu=").append(getMtu()).append(", vmNetwork=").append(isVmNetwork()).append(", cluster=").append(getCluster()).append(", providedBy=").append(getProvidedBy()).append(", label=").append(getLabel()).append(", qosId=").append(getQosId()).append("}");
    return builder.toString();
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((addr == null) ? 0 : addr.hashCode());
    // FIXME: remove cluster from hashCode calculation - breaks the tests when working in JDBC template mode
    /*
        result = prime * result + ((cluster == null) ? 0 : cluster.hashCode());
        */
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((gateway == null) ? 0 : gateway.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((dataCenterId == null) ? 0 : dataCenterId.hashCode());
    result = prime * result + (stp ? 1231 : 1237);
    result = prime * result + ((subnet == null) ? 0 : subnet.hashCode());
    result = prime * result + ((type == null) ? 0 : type.hashCode());
    result = prime * result + ((vlanId == null) ? 0 : vlanId.hashCode());
    result = prime * result + (mtu);
    result = prime * result + ((vmNetwork) ? 11 : 13);
    result = prime * result + ((providedBy == null) ? 0 : providedBy.hashCode());
    result = prime * result + ((label == null) ? 0 : label.hashCode());
    result = prime * result + ((qos == null) ? 0 : qos.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((addr == null) ? 0 : addr.hashCode());
    // FIXME: remove cluster from hashCode calculation - breaks the tests when working in JDBC template mode
    /*
        result = prime * result + ((cluster == null) ? 0 : cluster.hashCode());
        */
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((gateway == null) ? 0 : gateway.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((dataCenterId == null) ? 0 : dataCenterId.hashCode());
    result = prime * result + (stp ? 1231 : 1237);
    result = prime * result + ((subnet == null) ? 0 : subnet.hashCode());
    result = prime * result + ((type == null) ? 0 : type.hashCode());
    result = prime * result + ((vlanId == null) ? 0 : vlanId.hashCode());
    result = prime * result + (mtu);
    result = prime * result + ((vmNetwork) ? 11 : 13);
    result = prime * result + ((providedBy == null) ? 0 : providedBy.hashCode());
    result = prime * result + ((label == null) ? 0 : label.hashCode());
    result = prime * result + ((qosId == null) ? 0 : qosId.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    Network other = (Network) obj;
    if (addr == null) {
        if (other.addr != null)
            return false;
    } else if (!addr.equals(other.addr))
        return false;
    /*
        if (cluster == null) {
            if (other.cluster != null)
                return false;
        } else if (!cluster.equals(other.cluster))
            return false;
            */
    if (description == null) {
        if (other.description != null)
            return false;
    } else if (!description.equals(other.description))
        return false;
    if (gateway == null) {
        if (other.gateway != null)
            return false;
    } else if (!gateway.equals(other.gateway))
        return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    if (dataCenterId == null) {
        if (other.dataCenterId != null)
            return false;
    } else if (!dataCenterId.equals(other.dataCenterId))
        return false;
    if (stp != other.stp)
        return false;
    if (subnet == null) {
        if (other.subnet != null)
            return false;
    } else if (!subnet.equals(other.subnet))
        return false;
    if (type == null) {
        if (other.type != null)
            return false;
    } else if (!type.equals(other.type))
        return false;
    if (vlanId == null) {
        if (other.vlanId != null)
            return false;
    } else if (!vlanId.equals(other.vlanId))
        return false;
    if (mtu != other.mtu)
        return false;
    if (vmNetwork != other.vmNetwork) {
        return false;
    }
    if (providedBy == null) {
        if (other.providedBy != null)
            return false;
    } else if (!providedBy.equals(other.providedBy))
        return false;
    if (label == null) {
        if (other.label != null)
            return false;
    } else if (!label.equals(other.label))
        return false;
    if (!Objects.equals(qos, other.qos)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    Network other = (Network) obj;
    if (addr == null) {
        if (other.addr != null)
            return false;
    } else if (!addr.equals(other.addr))
        return false;
    /*
        if (cluster == null) {
            if (other.cluster != null)
                return false;
        } else if (!cluster.equals(other.cluster))
            return false;
            */
    if (description == null) {
        if (other.description != null)
            return false;
    } else if (!description.equals(other.description))
        return false;
    if (gateway == null) {
        if (other.gateway != null)
            return false;
    } else if (!gateway.equals(other.gateway))
        return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    if (dataCenterId == null) {
        if (other.dataCenterId != null)
            return false;
    } else if (!dataCenterId.equals(other.dataCenterId))
        return false;
    if (stp != other.stp)
        return false;
    if (subnet == null) {
        if (other.subnet != null)
            return false;
    } else if (!subnet.equals(other.subnet))
        return false;
    if (type == null) {
        if (other.type != null)
            return false;
    } else if (!type.equals(other.type))
        return false;
    if (vlanId == null) {
        if (other.vlanId != null)
            return false;
    } else if (!vlanId.equals(other.vlanId))
        return false;
    if (mtu != other.mtu)
        return false;
    if (vmNetwork != other.vmNetwork) {
        return false;
    }
    if (providedBy == null) {
        if (other.providedBy != null)
            return false;
    } else if (!providedBy.equals(other.providedBy))
        return false;
    if (label == null) {
        if (other.label != null)
            return false;
    } else if (!label.equals(other.label))
        return false;
    if (!ObjectUtils.objectsEqual(qosId, other.qosId)) {
        return false;
    }
    return true;
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_ADDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_ADDITION_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private Provider<?> getProvider() {
    if (provider == null) {
        provider = getDbFacade().getProviderDao().get(getExternalNetwork().getProviderId());
    }
    return provider;
}
#method_after
private Provider<?> getProvider() {
    if (provider == null && getExternalNetwork() != null) {
        provider = getDbFacade().getProviderDao().get(getExternalNetwork().getProviderId());
    }
    return provider;
}
#end_block

#method_before
private ProviderNetwork getExternalNetwork() {
    if (externalNetwork == null) {
        Network network = getNetworkDAO().get(getParameters().getNetworkId());
        externalNetwork = network.getProvidedBy();
    }
    return externalNetwork;
}
#method_after
private ProviderNetwork getExternalNetwork() {
    if (externalNetwork == null) {
        Network network = getNetworkDAO().get(getParameters().getNetworkId());
        if (network != null) {
            externalNetwork = network.getProvidedBy();
        }
    }
    return externalNetwork;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    ProviderValidator validator = new ProviderValidator(getProvider());
    return validate(validator.providerIsSet()) && super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    ProviderValidator validator = new ProviderValidator(getProvider());
    return validate(validator.providerIsSet());
}
#end_block

#method_before
@Override
public String add(Network network) {
    NetworkForCreate networkForCreate = new NetworkForCreate();
    networkForCreate.setAdminStateUp(true);
    networkForCreate.setName(network.getName());
    if (network.getLabel() != null) {
        networkForCreate.setProviderPhysicalNetwork(network.getLabel());
        if (network.getVlanId() == null) {
            networkForCreate.setProviderNetworkType(FLAT_NETWORK);
        } else {
            networkForCreate.setProviderNetworkType(VLAN_NETWORK);
            networkForCreate.setProviderSegmentationId(network.getVlanId());
        }
    }
    if (!provider.isRequiringAuthentication()) {
        networkForCreate.setTenantId(DEVICE_OWNER);
    }
    try {
        com.woorea.openstack.quantum.model.Network createdNetwork = getClient().networks().create(networkForCreate).execute();
        return createdNetwork.getId();
    } catch (RuntimeException e) {
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    }
}
#method_after
@Override
public String add(Network network) {
    NetworkForCreate networkForCreate = new NetworkForCreate();
    networkForCreate.setAdminStateUp(true);
    networkForCreate.setName(network.getName());
    if (network.getLabel() != null) {
        networkForCreate.setProviderPhysicalNetwork(network.getLabel());
        if (NetworkUtils.isVlan(network)) {
            networkForCreate.setProviderNetworkType(VLAN_NETWORK);
            networkForCreate.setProviderSegmentationId(network.getVlanId());
        } else {
            networkForCreate.setProviderNetworkType(FLAT_NETWORK);
        }
    }
    if (!provider.isRequiringAuthentication()) {
        networkForCreate.setTenantId(DEVICE_OWNER);
    }
    try {
        com.woorea.openstack.quantum.model.Network createdNetwork = getClient().networks().create(networkForCreate).execute();
        return createdNetwork.getId();
    } catch (RuntimeException e) {
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    }
}
#end_block

#method_before
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.Empty);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
@Override
public void edit(final NewExternalSubnetModel subnet) {
    driver.edit(subnet);
}
#method_after
@Override
public void edit(final NewExternalSubnetModel subnet) {
    driver.edit(subnet);
    networkEditor.asValueBox().setValue(subnet.getNetwork().getEntity().getName());
}
#end_block

#method_before
public void setName(EntityModel<String> name) {
    this.name = name;
}
#method_after
private void setName(EntityModel<String> name) {
    this.name = name;
}
#end_block

#method_before
public void setCidr(EntityModel<String> cidr) {
    this.cidr = cidr;
}
#method_after
private void setCidr(EntityModel<String> cidr) {
    this.cidr = cidr;
}
#end_block

#method_before
public ListModel<NetworkView> getNetwork() {
    return network;
}
#method_after
public EntityModel<NetworkView> getNetwork() {
    return network;
}
#end_block

#method_before
public void setNetwork(ListModel<NetworkView> network) {
    this.network = network;
}
#method_after
private void setNetwork(ListModel<NetworkView> network) {
    this.network = network;
}
#end_block

#method_before
public void setIpVersion(ListModel<IpVersion> ipVersion) {
    this.ipVersion = ipVersion;
}
#method_after
private void setIpVersion(ListModel<IpVersion> ipVersion) {
    this.ipVersion = ipVersion;
}
#end_block

#method_before
private void onSave() {
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    flush();
    startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddSubnetToProvider, new AddExternalSubnetParameters(subnet, getNetwork().getSelectedItem().getId()), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
            }
        }
    }, this, true);
}
#method_after
private void onSave() {
    if (!validate()) {
        return;
    }
    // Save changes.
    flush();
    startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddSubnetToProvider, new AddExternalSubnetParameters(subnet, getNetwork().getEntity().getId()), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
            }
        }
    }, this, true);
}
#end_block

#method_before
public void flush() {
    if (subnet == null) {
        subnet = new ExternalSubnet();
    }
    subnet.setName(getName().getEntity());
    Network network = getNetwork().getSelectedItem();
    subnet.setExternalNetwork(network != null ? network.getProvidedBy() : null);
    subnet.setCidr(getCidr().getEntity());
    subnet.setIpVersion(getIpVersion().getSelectedItem());
}
#method_after
public void flush() {
    subnet = new ExternalSubnet();
    subnet.setName(getName().getEntity());
    Network network = getNetwork().getEntity();
    subnet.setExternalNetwork(network.getProvidedBy());
    subnet.setCidr(getCidr().getEntity());
    subnet.setIpVersion(getIpVersion().getSelectedItem());
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if ("OnSave".equals(command.getName())) {
        // $NON-NLS-1$
        onSave();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    }
}
#end_block

#method_before
public void newSubnet() {
    if (getWindow() != null) {
        return;
    }
    NewExternalSubnetModel model = new NewExternalSubnetModel(this);
    setWindow(model);
    initNetworkInModel(model);
}
#method_after
public void newSubnet() {
    if (getWindow() != null) {
        return;
    }
    NewExternalSubnetModel model = new NewExternalSubnetModel(getEntity(), this);
    setWindow(model);
}
#end_block

#method_before
@Override
public NetworkView getEntity() {
    return (NetworkView) ((super.getEntity() instanceof NetworkView) ? super.getEntity() : null);
}
#method_after
@Override
public NetworkView getEntity() {
    return (NetworkView) super.getEntity();
}
#end_block

#method_before
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        @SuppressWarnings("unchecked")
        public void onSuccess(Object model, Object returnValue) {
            NetworkExternalSubnetListModel.this.setItems((List<ExternalSubnet>) returnValue);
        }
    };
    AsyncDataProvider.getExternalSubnetsByNetworkId(asyncQuery, getEntity().getId());
}
#method_after
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    super.syncSearch(VdcQueryType.GetExternalSubnetsOnProviderByNetwork, new IdQueryParameters(getEntity().getId()));
}
#end_block

#method_before
@Override
protected void entityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.entityPropertyChanged(sender, e);
    if (e.PropertyName.equals("name")) {
        // $NON-NLS-1$
        getSearchCommand().execute();
    }
}
#method_after
@Override
protected void entityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.entityPropertyChanged(sender, e);
    if (e.propertyName.equals("name")) {
        // $NON-NLS-1$
        getSearchCommand().execute();
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    NetworkView network = getEntity();
    getNewCommand().setIsExecutionAllowed(network != null && network.isExternal());
    getRemoveCommand().setIsExecutionAllowed((getSelectedItems() != null && getSelectedItems().size() > 0));
}
#method_after
private void updateActionAvailability() {
    getRemoveCommand().setIsExecutionAllowed((getSelectedItems() != null && getSelectedItems().size() > 0));
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newSubnet();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newSubnet();
    } else if (command == getRemoveCommand()) {
        remove();
    }
}
#end_block

#method_before
@Override
public String add(Network network) {
    NetworkForCreate networkForCreate = new NetworkForCreate();
    networkForCreate.setAdminStateUp(true);
    networkForCreate.setName(network.getName());
    if (network.getLabel() != null) {
        networkForCreate.setProviderPhysicalNetwork(network.getLabel());
        if (network.getVlanId() == null) {
            networkForCreate.setProviderNetworkType(FLAT_NETWORK);
        } else {
            networkForCreate.setProviderNetworkType(VLAN_NETWORK);
            networkForCreate.setProviderSegmentationId(network.getVlanId());
        }
    }
    if (!provider.isRequiringAuthentication()) {
        networkForCreate.setTenantId(DEVICE_OWNER);
    }
    try {
        com.woorea.openstack.quantum.model.Network createdNetwork = getClient().networks().create(networkForCreate).execute();
        return createdNetwork.getId();
    } catch (RuntimeException e) {
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    }
}
#method_after
@Override
public String add(Network network) {
    NetworkForCreate networkForCreate = new NetworkForCreate();
    networkForCreate.setAdminStateUp(true);
    networkForCreate.setName(network.getName());
    if (network.getLabel() != null) {
        networkForCreate.setProviderPhysicalNetwork(network.getLabel());
        if (NetworkUtils.isVlan(network)) {
            networkForCreate.setProviderNetworkType(VLAN_NETWORK);
            networkForCreate.setProviderSegmentationId(network.getVlanId());
        } else {
            networkForCreate.setProviderNetworkType(FLAT_NETWORK);
        }
    }
    if (!provider.isRequiringAuthentication()) {
        networkForCreate.setTenantId(DEVICE_OWNER);
    }
    try {
        com.woorea.openstack.quantum.model.Network createdNetwork = getClient().networks().create(networkForCreate).execute();
        return createdNetwork.getId();
    } catch (RuntimeException e) {
        throw new VdcBLLException(VdcBllErrors.PROVIDER_FAILURE, e);
    }
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VNIC_PROFILE_UNSUPPORTED_FEATURES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_NETWORK_BY_LABEL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.LABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.LABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UNLABEL_NIC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UNLABEL_NIC_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SUBNET_REMOVED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SUBNET_REMOVAL_FAILED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    ProviderValidator validator = new ProviderValidator(getProvider());
    return validate(validator.providerIsSet()) && super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    ProviderValidator validator = new ProviderValidator(getProvider());
    return validate(validator.providerIsSet());
}
#end_block

#method_before
@Override
protected void postSaveAction(Guid networkGuid, boolean succeeded) {
    super.postSaveAction(networkGuid, succeeded);
    if (!succeeded) {
        return;
    }
    Guid networkId = getNetwork().getId() == null ? networkGuid : getNetwork().getId();
    ArrayList<VdcActionParametersBase> actionParameters1 = new ArrayList<VdcActionParametersBase>();
    for (NetworkClusterModel networkClusterModel : getClustersToAttach()) {
        Network tempVar = new Network();
        tempVar.setId(networkId);
        tempVar.setName(getNetwork().getName());
        // Init default NetworkCluster values (required, display, status)
        NetworkCluster networkCluster = new NetworkCluster();
        networkCluster.setRequired(networkClusterModel.isRequired());
        tempVar.setCluster(networkCluster);
        actionParameters1.add(new AttachNetworkToVdsGroupParameter(networkClusterModel.getEntity(), tempVar));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AttachNetworkToVdsGroup, actionParameters1);
    if ((Boolean) getExport().getEntity() && !getSubnetName().getEntity().isEmpty()) {
        ExternalSubnet subnet = new ExternalSubnet();
        subnet.setName(getSubnetName().getEntity());
        subnet.setCidr(getSubnetCidr().getEntity());
        subnet.setIpVersion(getSubnetIpVersion().getSelectedItem());
        actionParameters1 = new ArrayList<VdcActionParametersBase>();
        actionParameters1.add(new AddExternalSubnetParameters(subnet, networkId));
        Frontend.getInstance().runMultipleAction(VdcActionType.AddSubnetToProvider, actionParameters1);
    }
}
#method_after
@Override
protected void postSaveAction(Guid networkGuid, boolean succeeded) {
    super.postSaveAction(networkGuid, succeeded);
    if (!succeeded) {
        return;
    }
    Guid networkId = getNetwork().getId() == null ? networkGuid : getNetwork().getId();
    ArrayList<VdcActionParametersBase> actionParameters1 = new ArrayList<VdcActionParametersBase>();
    for (NetworkClusterModel networkClusterModel : getClustersToAttach()) {
        Network tempVar = new Network();
        tempVar.setId(networkId);
        tempVar.setName(getNetwork().getName());
        // Init default NetworkCluster values (required, display, status)
        NetworkCluster networkCluster = new NetworkCluster();
        networkCluster.setRequired(networkClusterModel.isRequired());
        tempVar.setCluster(networkCluster);
        actionParameters1.add(new AttachNetworkToVdsGroupParameter(networkClusterModel.getEntity(), tempVar));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AttachNetworkToVdsGroup, actionParameters1);
    if ((Boolean) getExport().getEntity() && getSubnetName().getEntity() != null && !getSubnetName().getEntity().isEmpty()) {
        ExternalSubnet subnet = new ExternalSubnet();
        subnet.setName(getSubnetName().getEntity());
        subnet.setCidr(getSubnetCidr().getEntity());
        subnet.setIpVersion(getSubnetIpVersion().getSelectedItem());
        Frontend.getInstance().runAction(VdcActionType.AddSubnetToProvider, new AddExternalSubnetParameters(subnet, networkId));
    }
}
#end_block

#method_before
@Override
public void init(final T model) {
    // Let the parent do its work
    super.init(model);
    // Listen to Properties
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            NetworkModel model = (NetworkModel) sender;
            String propertyName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("Message".equals(propertyName)) {
                // $NON-NLS-1$
                getView().setMessageLabel(model.getMessage());
            }
        }
    });
    getView().toggleSubnetVisibility((Boolean) model.getExport().getEntity());
    model.getExport().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            getView().toggleSubnetVisibility((Boolean) model.getExport().getEntity());
        }
    });
    getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
    model.getProfiles().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).PropertyName)) {
                // $NON-NLS-1$
                getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
            }
        }
    });
}
#method_after
@Override
public void init(final T model) {
    // Let the parent do its work
    super.init(model);
    // Listen to Properties
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            NetworkModel model = (NetworkModel) sender;
            String propertyName = ((PropertyChangedEventArgs) args).propertyName;
            if ("Message".equals(propertyName)) {
                // $NON-NLS-1$
                getView().setMessageLabel(model.getMessage());
            }
        }
    });
    getView().toggleSubnetVisibility((Boolean) model.getExport().getEntity());
    model.getExport().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            getView().toggleSubnetVisibility((Boolean) model.getExport().getEntity());
        }
    });
    getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
    model.getProfiles().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                getView().toggleProfilesVisibility(model.getProfiles().getIsAvailable());
            }
        }
    });
}
#end_block

#method_before
public boolean validate() {
    RegexValidation tempVar = new RegexValidation();
    // $NON-NLS-1$
    tempVar.setExpression("^[A-Za-z0-9_]{1,15}$");
    tempVar.setMessage(ConstantsManager.getInstance().getConstants().nameMustContainAlphanumericMaxLenMsg());
    RegexValidation tempVar2 = new RegexValidation();
    tempVar2.setIsNegate(true);
    // $NON-NLS-1$
    tempVar2.setExpression("^(bond)");
    tempVar2.setMessage(ConstantsManager.getInstance().getConstants().networkNameStartMsg());
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar, tempVar2 });
    LengthValidation tempVar3 = new LengthValidation();
    tempVar3.setMaxLength(40);
    getDescription().validateEntity(new IValidation[] { tempVar3 });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getVLanTag().setIsValid(true);
    if ((Boolean) getHasVLanTag().getEntity()) {
        IntegerValidation tempVar4 = new IntegerValidation();
        tempVar4.setMinimum(0);
        tempVar4.setMaximum(4094);
        getVLanTag().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar4 });
    }
    getMtu().setIsValid(true);
    if ((Boolean) getHasMtu().getEntity()) {
        IntegerValidation tempVar5 = new IntegerValidation();
        tempVar5.setMinimum(68);
        tempVar5.setMaximum(9000);
        getMtu().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar5 });
    }
    getExternalProviders().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getSubnetName().validateEntity(new IValidation[] { new AsciiNameValidation() });
    getSubnetCidr().setIsValid(true);
    getSubnetIpVersion().setIsValid(true);
    if (getSubnetName().getEntity() != null && !getSubnetName().getEntity().isEmpty()) {
        getSubnetCidr().validateEntity(new IValidation[] { new NotEmptyValidation() });
        getSubnetIpVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean profilesValid = true;
    Iterable<VnicProfileModel> profiles = getProfiles().getItems();
    for (VnicProfileModel profileModel : profiles) {
        if (!profileModel.validate()) {
            profilesValid = false;
        }
    }
    return getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && getSubnetName().getIsValid() && getSubnetCidr().getIsValid() && getSubnetIpVersion().getIsValid() && profilesValid;
}
#method_after
public boolean validate() {
    RegexValidation tempVar = new RegexValidation();
    // $NON-NLS-1$
    tempVar.setExpression("^[A-Za-z0-9_]{1,15}$");
    tempVar.setMessage(ConstantsManager.getInstance().getConstants().nameMustContainAlphanumericMaxLenMsg());
    RegexValidation tempVar2 = new RegexValidation();
    tempVar2.setIsNegate(true);
    // $NON-NLS-1$
    tempVar2.setExpression("^(bond)");
    tempVar2.setMessage(ConstantsManager.getInstance().getConstants().networkNameStartMsg());
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar, tempVar2 });
    LengthValidation tempVar3 = new LengthValidation();
    tempVar3.setMaxLength(40);
    getDescription().validateEntity(new IValidation[] { tempVar3 });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getVLanTag().setIsValid(true);
    if ((Boolean) getHasVLanTag().getEntity()) {
        IntegerValidation tempVar4 = new IntegerValidation();
        tempVar4.setMinimum(0);
        tempVar4.setMaximum(4094);
        getVLanTag().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar4 });
    }
    getMtu().setIsValid(true);
    if ((Boolean) getHasMtu().getEntity()) {
        IntegerValidation tempVar5 = new IntegerValidation();
        tempVar5.setMinimum(68);
        tempVar5.setMaximum(9000);
        getMtu().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar5 });
    }
    getExternalProviders().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getSubnetName().validateEntity(new IValidation[] { new AsciiNameValidation() });
    if (getSubnetName().getEntity() != null && !getSubnetName().getEntity().isEmpty()) {
        getSubnetCidr().validateEntity(new IValidation[] { new NotEmptyValidation() });
        getSubnetIpVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean profilesValid = true;
    Iterable<VnicProfileModel> profiles = getProfiles().getItems();
    for (VnicProfileModel profileModel : profiles) {
        if (!profileModel.validate()) {
            profilesValid = false;
        }
    }
    return getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && getSubnetName().getIsValid() && getSubnetCidr().getIsValid() && getSubnetIpVersion().getIsValid() && profilesValid;
}
#end_block

#method_before
@Override
public NetworkView getEntity() {
    return (NetworkView) ((super.getEntity() instanceof NetworkView) ? super.getEntity() : null);
}
#method_after
@Override
public NetworkView getEntity() {
    return (NetworkView) super.getEntity();
}
#end_block

#method_before
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        @SuppressWarnings("unchecked")
        public void onSuccess(Object model, Object returnValue) {
            NetworkExternalSubnetListModel.this.setItems((List<ExternalSubnet>) returnValue);
        }
    };
    AsyncDataProvider.getExternalSubnetsByNetworkId(asyncQuery, getEntity().getId());
}
#method_after
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    super.syncSearch(VdcQueryType.GetExternalSubnetsOnProviderByNetwork, new IdQueryParameters(getEntity().getId()));
}
#end_block

#method_before
@Override
protected void entityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.entityPropertyChanged(sender, e);
    if (e.PropertyName.equals("name")) {
        // $NON-NLS-1$
        getSearchCommand().execute();
    }
}
#method_after
@Override
protected void entityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.entityPropertyChanged(sender, e);
    if (e.propertyName.equals("name")) {
        // $NON-NLS-1$
        getSearchCommand().execute();
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getRemoveCommand()) {
        remove();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getRemoveCommand()) {
        remove();
    }
}
#end_block

#method_before
private void onRemove() {
    if (getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (ExternalSubnet subnet : getSubnets()) {
        VdcActionParametersBase parameters = new ExternalSubnetParameters(subnet);
        list.add(parameters);
    }
    startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveSubnetFromProvider, list, false, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            stopProgress();
            cancel();
        }
    }, null);
}
#method_after
private void onRemove() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (ExternalSubnet subnet : getSubnets()) {
        VdcActionParametersBase parameters = new ExternalSubnetParameters(subnet);
        list.add(parameters);
    }
    startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveSubnetFromProvider, list, false, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            stopProgress();
            sourceListModel.getSearchCommand().execute();
            cancel();
        }
    }, null);
}
#end_block

#method_before
public List<ExternalSubnet> getSubnets() {
    return subnets;
}
#method_after
private List<ExternalSubnet> getSubnets() {
    return subnets;
}
#end_block

#method_before
private void cancel() {
    sourceListModel.setWindow(null);
    sourceListModel.setConfirmWindow(null);
    sourceListModel.getSearchCommand().execute();
}
#method_after
private void cancel() {
    sourceListModel.setWindow(null);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("OnRemove".equals(command.getName())) {
        // $NON-NLS-1$
        onRemove();
    }
}
#end_block

#method_before
@Override
public EventResult masterDomainNotOperational(Guid storageDomainId, Guid storagePoolId, boolean isReconstructToInactiveDomains) {
    VdcActionParametersBase parameters = new ReconstructMasterParameters(storagePoolId, storageDomainId, true, isReconstructToInactiveDomains);
    boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.ReconstructMasterDomain, parameters, ExecutionHandler.createInternalJobContext()).getSucceeded();
    return new EventResult(isSucceeded, EventType.RECONSTRUCT);
}
#method_after
@Override
public EventResult masterDomainNotOperational(Guid storageDomainId, Guid storagePoolId, boolean isReconstructToInactiveDomains, boolean canReconstructToCurrentMaster) {
    VdcActionParametersBase parameters = new ReconstructMasterParameters(storagePoolId, storageDomainId, true, isReconstructToInactiveDomains, canReconstructToCurrentMaster);
    boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.ReconstructMasterDomain, parameters, ExecutionHandler.createInternalJobContext()).getSucceeded();
    return new EventResult(isSucceeded, EventType.RECONSTRUCT);
}
#end_block

#method_before
@Override
public void processOnVmStop(Guid vmId) {
    VmPoolHandler.ProcessVmPoolOnStopVm(vmId, null);
}
#method_after
@Override
public void processOnVmStop(Guid vmId) {
    VmPoolHandler.processVmPoolOnStopVm(vmId, null);
}
#end_block

#method_before
@Override
public void vdsNotResponding(final VDS vds, final boolean executeSshSoftFencing) {
    ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.infoFormat("ResourceManager::vdsNotResponding entered for Host {0}, {1}", vds.getId(), vds.getHostName());
            boolean shouldExecRealFencing = true;
            if (executeSshSoftFencing) {
                VdcReturnValueBase retVal = Backend.getInstance().runInternalAction(VdcActionType.SshSoftFencing, new VdsActionParameters(vds.getId()), ExecutionHandler.createInternalJobContext());
                // if SSH Soft Fencing command execution was successful, do not execute
                // standard fencing immediately, but wait to see if it helped
                shouldExecRealFencing = !retVal.getSucceeded();
            }
            if (MonitoringStrategyFactory.getMonitoringStrategyForVds(vds).isPowerManagementSupported() && shouldExecRealFencing) {
                Backend.getInstance().runInternalAction(VdcActionType.VdsNotRespondingTreatment, new FenceVdsActionParameters(vds.getId(), FenceActionType.Restart), ExecutionHandler.createInternalJobContext());
            }
        }
    });
}
#method_after
@Override
public void vdsNotResponding(final VDS vds, final boolean executeSshSoftFencing) {
    ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.infoFormat("ResourceManager::vdsNotResponding entered for Host {0}, {1}", vds.getId(), vds.getHostName());
            boolean shouldExecRealFencing = true;
            if (executeSshSoftFencing) {
                VdcReturnValueBase retVal = Backend.getInstance().runInternalAction(VdcActionType.SshSoftFencing, new VdsActionParameters(vds.getId()), ExecutionHandler.createInternalJobContext());
                // if SSH Soft Fencing command execution was successful, do not execute
                // standard fencing immediately, but wait to see if it helped
                shouldExecRealFencing = !retVal.getSucceeded();
            }
            if (MonitoringStrategyFactory.getMonitoringStrategyForVds(vds).isPowerManagementSupported() && shouldExecRealFencing) {
                Backend.getInstance().runInternalAction(VdcActionType.VdsNotRespondingTreatment, new FenceVdsActionParameters(vds.getId(), FenceActionType.Restart), ExecutionHandler.createInternalJobContext());
            }
            moveBricksToUnknown(vds);
        }
    });
}
#end_block

#method_before
@Override
public boolean vdsUpEvent(final VDS vds) {
    HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds);
    boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded();
    if (isSucceeded) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                try {
                    // migrate vms that its their default vds and failback
                    // is on
                    List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId());
                    if (vmsToMigrate.size() > 0) {
                        ArrayList<VdcActionParametersBase> vmToServerParametersList = new ArrayList(LinqUtils.foreach(vmsToMigrate, new Function<VmStatic, VdcActionParametersBase>() {

                            @Override
                            public VdcActionParametersBase eval(VmStatic vm) {
                                MigrateVmToServerParameters parameters = new MigrateVmToServerParameters(false, vm.getId(), vds.getId());
                                parameters.setShouldBeLogged(false);
                                return parameters;
                            }
                        }));
                        ExecutionContext executionContext = new ExecutionContext();
                        executionContext.setMonitored(true);
                        Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, vmToServerParametersList, executionContext);
                    }
                } catch (RuntimeException e) {
                    log.errorFormat("Failed to initialize Vds on up. Error: {0}", e);
                }
            }
        });
    }
    return isSucceeded;
}
#method_after
@Override
public boolean vdsUpEvent(final VDS vds) {
    HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds);
    boolean isSucceeded = Backend.getInstance().runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded();
    if (isSucceeded) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                try {
                    // migrate vms that its their default vds and failback
                    // is on
                    List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId());
                    if (vmsToMigrate.size() > 0) {
                        ArrayList<VdcActionParametersBase> vmToServerParametersList = new ArrayList<VdcActionParametersBase>(LinqUtils.foreach(vmsToMigrate, new Function<VmStatic, VdcActionParametersBase>() {

                            @Override
                            public VdcActionParametersBase eval(VmStatic vm) {
                                MigrateVmToServerParameters parameters = new MigrateVmToServerParameters(false, vm.getId(), vds.getId());
                                parameters.setShouldBeLogged(false);
                                return parameters;
                            }
                        }));
                        ExecutionContext executionContext = new ExecutionContext();
                        executionContext.setMonitored(true);
                        Backend.getInstance().runInternalMultipleActions(VdcActionType.MigrateVmToServer, vmToServerParametersList, executionContext);
                    }
                } catch (RuntimeException e) {
                    log.errorFormat("Failed to initialize Vds on up. Error: {0}", e);
                }
            }
        });
    }
    return isSucceeded;
}
#end_block

#method_before
@Override
public void processOnClientIpChange(final VDS vds, final Guid vmId) {
    final VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(vmId);
    // (this happened when user close the console to spice/vnc)
    if (StringUtils.isEmpty(vmDynamic.getClientIp())) {
        vmDynamic.setConsoleCurrentUserName(null);
        DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
    }
}
#method_after
@Override
public void processOnClientIpChange(final VDS vds, final Guid vmId) {
    final VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(vmId);
    final AuditLogableBase event = new AuditLogableBase();
    event.setVmId(vmId);
    event.setUserName(vmDynamic.getConsoleCurrentUserName());
    // (this happened when user close the console to spice/vnc)
    if (StringUtils.isEmpty(vmDynamic.getClientIp())) {
        vmDynamic.setConsoleCurrentUserName(null);
        DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
        AuditLogDirector.log(event, AuditLogType.VM_CONSOLE_DISCONNECTED);
    } else {
        AuditLogDirector.log(event, AuditLogType.VM_CONSOLE_CONNECTED);
    }
}
#end_block

#method_before
@Override
public void processOnVmPoweringUp(Guid vds_id, Guid vmid, String display_ip, int display_port) {
    IVdsAsyncCommand command = Backend.getInstance().getResourceManager().GetAsyncCommandForVm(vmid);
    if (command != null) {
        command.onPowerringUp();
        if (command.getAutoStart() && command.getAutoStartVdsId() != null) {
            try {
                String otp64 = Ticketing.GenerateOTP();
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmTicket, new SetVmTicketVDSCommandParameters(vds_id, vmid, otp64, 60, "", Guid.Empty));
                log.infoFormat("VdsEventListener.ProcessOnVmPoweringUp - Auto start logic, starting spice to vm - {0} ", vmid);
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.StartSpice, new StartSpiceVDSCommandParameters(command.getAutoStartVdsId(), display_ip, display_port, otp64));
            } catch (RuntimeException ex) {
                log.errorFormat("VdsEventListener.ProcessOnVmPoweringUp - failed to start spice on VM - {0} - {1} - {2}", vmid, ex.getMessage(), ex.getStackTrace());
            }
        }
    }
}
#method_after
@Override
public void processOnVmPoweringUp(Guid vds_id, Guid vmid, String display_ip, int display_port) {
    IVdsAsyncCommand command = Backend.getInstance().getResourceManager().GetAsyncCommandForVm(vmid);
    /*
         * XXX: command is null after successful migration, because runningSucceeded removes the
         *      MigrateVmCommand instance from the async cache too early.
         *      See the order of succeededToRunVm and processOnVmPoweringUp
         *      in VdsUpdateRunTimeInfo.afterRefreshTreatment
         */
    if (command != null) {
        command.onPowerringUp();
        if (command.getAutoStart() && command.getAutoStartVdsId() != null) {
            try {
                String otp64 = Ticketing.generateOTP();
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmTicket, new SetVmTicketVDSCommandParameters(vds_id, vmid, otp64, 60, "", Guid.Empty));
                log.infoFormat("VdsEventListener.ProcessOnVmPoweringUp - Auto start logic, starting spice to vm - {0} ", vmid);
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.StartSpice, new StartSpiceVDSCommandParameters(command.getAutoStartVdsId(), display_ip, display_port, otp64));
            } catch (RuntimeException ex) {
                log.errorFormat("VdsEventListener.ProcessOnVmPoweringUp - failed to start spice on VM - {0} - {1} - {2}", vmid, ex.getMessage(), ex.getStackTrace());
            }
        }
    }
}
#end_block

#method_before
@Override
public void storagePoolUpEvent(StoragePool storagePool) {
    AsyncTaskManager.getInstance().AddStoragePoolExistingTasks(storagePool);
}
#method_after
@Override
public void storagePoolUpEvent(StoragePool storagePool) {
    AsyncTaskManager.getInstance().addStoragePoolExistingTasks(storagePool);
}
#end_block

#method_before
public void addVmsToRun(List<Guid> vmIds) {
    final DateTime now = DateTime.getNow();
    LinkedList<Pair<Guid, DateTime>> vmsToAdd = new LinkedList<>();
    for (Guid vmId : vmIds) {
        vmsToAdd.add(new Pair<>(vmId, now));
    }
    autoStartVmsToRun.addAll(vmsToAdd);
}
#method_after
public void addVmsToRun(List<Guid> vmIds) {
    ArrayList<AutoStartVmToRestart> vmsToAdd = new ArrayList<>(vmIds.size());
    for (Guid vmId : vmIds) {
        vmsToAdd.add(new AutoStartVmToRestart(vmId));
    }
    autoStartVmsToRestart.addAll(vmsToAdd);
}
#end_block

#method_before
@OnTimerMethodAnnotation("startFailedAutoStartVms")
public void startFailedAutoStartVms() {
    LinkedList<Pair<Guid, DateTime>> idsToRemove = new LinkedList<>();
    final DateTime now = DateTime.getNow();
    final DateTime nextTimeOfRetryToRun = now.AddSeconds(RETRY_TO_RUN_HA_VM_INTERVAL);
    for (Pair<Guid, DateTime> vmIdAndDateTime : autoStartVmsToRun) {
        // if it is not the time to rerun this VM yet, skip for now
        if (now.compareTo(vmIdAndDateTime.getSecond()) < 0) {
            continue;
        }
        Guid vmId = vmIdAndDateTime.getFirst();
        EngineLock runVmLock = createLockForRunVmCommand(vmId);
        if (!getLockManager().acquireLock(runVmLock).getFirst()) {
            log.infoFormat("Could not acquire lock for running HA VM {0}", vmId);
            continue;
        }
        if (!runVm(vmId, runVmLock) && getVmDynamicDao().get(vmId).getStatus() == VMStatus.Down) {
            AuditLogableBase event = new AuditLogableBase();
            event.setVmId(vmId);
            AuditLogDirector.log(event, AuditLogType.HA_VM_RESTART_FAILED);
            vmIdAndDateTime.setSecond(nextTimeOfRetryToRun);
            continue;
        }
        // the VM reached status which is different from Down, therefore we can remove it from
        // the set and from now on errors will be detected by VdsUpdateRuntimeInfo
        idsToRemove.add(vmIdAndDateTime);
    }
    autoStartVmsToRun.removeAll(idsToRemove);
}
#method_after
@OnTimerMethodAnnotation("startFailedAutoStartVms")
public void startFailedAutoStartVms() {
    LinkedList<AutoStartVmToRestart> vmsToRemove = new LinkedList<>();
    final DateTime iterationStartTime = DateTime.getNow();
    final Date nextTimeOfRetryToRun = iterationStartTime.addSeconds(RETRY_TO_RUN_HA_VM_INTERVAL);
    for (AutoStartVmToRestart autoStartVmToRestart : autoStartVmsToRestart) {
        // (we'll try again in the next iteration)
        if (!autoStartVmToRestart.isTimeToRun(iterationStartTime)) {
            continue;
        }
        Guid vmId = autoStartVmToRestart.getVmId();
        EngineLock runVmLock = createEngineLockForRunVm(vmId);
        // acquired, skip for now  and we'll try again in the next iteration
        if (!acquireLock(runVmLock)) {
            log.debugFormat("Could not acquire lock for running HA VM {0}", vmId);
            continue;
        }
        if (!isVmNeedsToBeAutoStarted(vmId)) {
            // if the VM doesn't need to be auto started anymore, release the lock and
            // remove the VM from the collection of VMs that should be auto started
            releaseLock(runVmLock);
            vmsToRemove.add(autoStartVmToRestart);
            continue;
        }
        if (runVm(vmId, runVmLock)) {
            // the VM reached WaitForLunch, so from now on this job is not responsible
            // to auto start it, future failures will be detected by the monitoring
            vmsToRemove.add(autoStartVmToRestart);
        } else {
            logFailedAttemptToRestartHighlyAvailableVm(vmId);
            if (!autoStartVmToRestart.scheduleNextTimeToRun(nextTimeOfRetryToRun)) {
                // if we could not schedule the next time to run the VM, it means
                // that we reached the maximum number of tried so don't try anymore
                vmsToRemove.add(autoStartVmToRestart);
                logFailureToRestartHighlyAvailableVm(vmId);
            }
        }
    }
    autoStartVmsToRestart.removeAll(vmsToRemove);
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.UpdateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.UpdateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#end_block

#method_before
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.GetValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getMemFree() == null || stat.getusage_mem_percent() == null) {
        return;
    }
    AuditLogType valueToLog = stat.getMemFree() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE;
    if ((stat.getMemFree() < minAvailableThreshold && Version.v3_2.compareTo(_vds.getVersion()) <= 0) || stat.getusage_mem_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("AvailableMemory", stat.getMemFree().toString());
        logable.addCustomValue("UsedMemory", stat.getusage_mem_percent().toString());
        logable.addCustomValue("Threshold", stat.getMemFree() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#method_after
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getMemFree() == null || stat.getusage_mem_percent() == null) {
        return;
    }
    AuditLogType valueToLog = stat.getMemFree() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE;
    if ((stat.getMemFree() < minAvailableThreshold && Version.v3_2.compareTo(_vds.getVersion()) <= 0) || stat.getusage_mem_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("AvailableMemory", stat.getMemFree().toString());
        logable.addCustomValue("UsedMemory", stat.getusage_mem_percent().toString());
        logable.addCustomValue("Threshold", stat.getMemFree() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void checkVdsCpuThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxCpuUsedThresholdInPercentage);
    if (stat.getusage_cpu_percent() != null && stat.getusage_cpu_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedCpu", stat.getusage_cpu_percent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_CPU_USE);
    }
}
#method_after
private void checkVdsCpuThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxCpuUsedThresholdInPercentage);
    if (stat.getusage_cpu_percent() != null && stat.getusage_cpu_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedCpu", stat.getusage_cpu_percent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_CPU_USE);
    }
}
#end_block

#method_before
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxNetworkUsedThresholdInPercentage);
    if (stat.getusage_network_percent() != null && stat.getusage_network_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedNetwork", stat.getusage_network_percent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_NETWORK_USE);
    }
}
#method_after
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxNetworkUsedThresholdInPercentage);
    if (stat.getusage_network_percent() != null && stat.getusage_network_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedNetwork", stat.getusage_network_percent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_NETWORK_USE);
    }
}
#end_block

#method_before
private void checkVdsSwapThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.GetValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getswap_total() == null || stat.getswap_free() == null || stat.getswap_total() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getswap_total() - stat.getswap_free()) / stat.getswap_total();
    AuditLogType valueToLog = stat.getswap_free() < minAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getswap_free() < minAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getswap_free().toString());
        logable.addCustomValue("Threshold", stat.getswap_free() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#method_after
private void checkVdsSwapThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.getValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getswap_total() == null || stat.getswap_free() == null || stat.getswap_total() == 0) {
        return;
    }
    Long swapUsedPercent = (stat.getswap_total() - stat.getswap_free()) / stat.getswap_total();
    AuditLogType valueToLog = stat.getswap_free() < minAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getswap_free() < minAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.addCustomValue("AvailableSwapMemory", stat.getswap_free().toString());
        logable.addCustomValue("Threshold", stat.getswap_free() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void refreshVdsStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#method_after
private void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getName());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.execute();
    ResourceManager.getInstance().getEventListener().updateSchedulingStats(_vds);
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#end_block

#method_before
private void alertIfLowDiskSpaceOnHost() {
    Map<String, Long> disksUsage = _vds.getLocalDisksUsage();
    if (disksUsage == null || disksUsage.isEmpty()) {
        return;
    }
    List<String> disksWithLowSpace = new ArrayList<String>();
    List<String> disksWithCriticallyLowSpace = new ArrayList<String>();
    final int lowSpaceCriticalThreshold = Config.<Integer>GetValue(ConfigValues.VdsLocalDisksCriticallyLowFreeSpace);
    final int lowSpaceThreshold = Config.<Integer>GetValue(ConfigValues.VdsLocalDisksLowFreeSpace);
    for (Entry<String, Long> diskUsage : disksUsage.entrySet()) {
        if (diskUsage.getValue() != null) {
            if (diskUsage.getValue() <= lowSpaceCriticalThreshold) {
                disksWithCriticallyLowSpace.add(diskUsage.getKey());
            } else if (diskUsage.getValue() <= lowSpaceThreshold) {
                disksWithLowSpace.add(diskUsage.getKey());
            }
        }
    }
    logLowDiskSpaceOnHostDisks(disksWithLowSpace, lowSpaceThreshold, AuditLogType.VDS_LOW_DISK_SPACE);
    logLowDiskSpaceOnHostDisks(disksWithCriticallyLowSpace, lowSpaceCriticalThreshold, AuditLogType.VDS_LOW_DISK_SPACE_ERROR);
}
#method_after
private void alertIfLowDiskSpaceOnHost() {
    Map<String, Long> disksUsage = _vds.getLocalDisksUsage();
    if (disksUsage == null || disksUsage.isEmpty()) {
        return;
    }
    List<String> disksWithLowSpace = new ArrayList<String>();
    List<String> disksWithCriticallyLowSpace = new ArrayList<String>();
    final int lowSpaceCriticalThreshold = Config.<Integer>getValue(ConfigValues.VdsLocalDisksCriticallyLowFreeSpace);
    final int lowSpaceThreshold = Config.<Integer>getValue(ConfigValues.VdsLocalDisksLowFreeSpace);
    for (Entry<String, Long> diskUsage : disksUsage.entrySet()) {
        if (diskUsage.getValue() != null) {
            if (diskUsage.getValue() <= lowSpaceCriticalThreshold) {
                disksWithCriticallyLowSpace.add(diskUsage.getKey());
            } else if (diskUsage.getValue() <= lowSpaceThreshold) {
                disksWithLowSpace.add(diskUsage.getKey());
            }
        }
    }
    logLowDiskSpaceOnHostDisks(disksWithLowSpace, lowSpaceThreshold, AuditLogType.VDS_LOW_DISK_SPACE);
    logLowDiskSpaceOnHostDisks(disksWithCriticallyLowSpace, lowSpaceCriticalThreshold, AuditLogType.VDS_LOW_DISK_SPACE_ERROR);
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        Pair<List<String>, List<String>> problematicNics = determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>GetValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retreive it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                StringBuilder sNics = new StringBuilder();
                StringBuilder sNetworks = new StringBuilder();
                for (String nic : brokenNics) {
                    sNics.append(nic).append(", ");
                }
                for (String net : networks) {
                    sNetworks.append(net).append(", ");
                }
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), sNics.toString(), sNetworks.toString());
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", StringUtils.stripEnd(sNetworks.toString(), ", "));
                logable.addCustomValue("Interfaces", StringUtils.stripEnd(sNics.toString(), ", "));
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        Pair<List<String>, List<String>> problematicNics = determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retreive it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                StringBuilder sNics = new StringBuilder();
                StringBuilder sNetworks = new StringBuilder();
                for (String nic : brokenNics) {
                    sNics.append(nic).append(", ");
                }
                for (String net : networks) {
                    sNetworks.append(net).append(", ");
                }
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), sNics.toString(), sNetworks.toString());
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", StringUtils.stripEnd(sNetworks.toString(), ", "));
                logable.addCustomValue("Interfaces", StringUtils.stripEnd(sNics.toString(), ", "));
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#end_block

#method_before
private void refreshVmStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.executeWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.error("GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#method_after
private void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.executeWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.error("GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#end_block

#method_before
private boolean devicePluggable(VmDevice device) {
    return (VmDeviceType.DISK.getName().equals(device.getDevice()) && VmDeviceGeneralType.DISK == device.getType()) || (VmDeviceType.BRIDGE.getName().equals(device.getDevice()) && VmDeviceGeneralType.INTERFACE == device.getType());
}
#method_after
private boolean devicePluggable(VmDevice device) {
    return VmDeviceCommonUtils.isDisk(device) || VmDeviceCommonUtils.isBridge(device);
}
#end_block

#method_before
private Guid addNewVmDevice(Guid vmId, Map device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.errorFormat("Empty or NULL values were passed for a VM {0} device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, false, alias, null, null);
        newVmDevices.add(newDevice);
        log.debugFormat("New device was marked for adding to VM {0} Devices : {1}", vmId, newDevice);
    }
    return newDeviceId;
}
#method_after
private Guid addNewVmDevice(Guid vmId, Map device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.errorFormat("Empty or NULL values were passed for a VM {0} device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, Boolean.getBoolean((String) device.get(VdsProperties.ReadOnly)), alias, null, null);
        newVmDevices.add(newDevice);
        log.debugFormat("New device was marked for adding to VM {0} Devices : {1}", vmId, newDevice);
    }
    return newDeviceId;
}
#end_block

#method_before
private void proceedBalloonCheck() {
    if (isBalloonActiveOnHost()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (balloonInfo.getCurrentMemory().intValue() == balloonInfo.getBalloonMaxMemory().intValue() || balloonInfo.getCurrentMemory().intValue() != balloonInfo.getBalloonTargetMemory().intValue())) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && balloonInfo.getCurrentMemory().intValue() != balloonInfo.getBalloonMaxMemory().intValue()) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#method_after
private void proceedBalloonCheck() {
    if (isBalloonActiveOnHost()) {
        for (VmInternalData vmInternalData : _runningVms.values()) {
            VmBalloonInfo balloonInfo = vmInternalData.getVmStatistics().getVmBalloonInfo();
            Guid vmId = vmInternalData.getVmDynamic().getId();
            if (_vmDict.get(vmId) == null) {
                // if vm is unknown - continue
                continue;
            }
            if (isBalloonDeviceActiveOnVm(vmInternalData) && (Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory()) || !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonTargetMemory()))) {
                vmBalloonDriverIsRequestedAndUnavailable(vmId);
            } else {
                vmBalloonDriverIsNotRequestedOrAvailable(vmId);
            }
            if (vmInternalData.getVmStatistics().getusage_mem_percent() != null && // guest agent is down
            vmInternalData.getVmStatistics().getusage_mem_percent() == 0 && // check if the device is present
            balloonInfo.isBalloonDeviceEnabled() && !Objects.equals(balloonInfo.getCurrentMemory(), balloonInfo.getBalloonMaxMemory())) {
                guestAgentIsDownAndBalloonInfalted(vmId);
            } else {
                guestAgentIsUpOrBalloonDeflated(vmId);
            }
        }
    }
}
#end_block

#method_before
// add the vm to the list of vms with uncontrolled inflated balloon or increment its counter
private void guestAgentIsDownAndBalloonInfalted(Guid vmId) {
    Integer currentVal = vmsWithUncontrolledBalloon.get(vmId);
    if (currentVal == null) {
        vmsWithUncontrolledBalloon.put(vmId, 1);
    } else {
        vmsWithUncontrolledBalloon.put(vmId, currentVal + 1);
        if (currentVal >= Config.<Integer>GetValue(ConfigValues.IterationsWithBalloonProblem)) {
            AuditLogableBase auditLogable = new AuditLogableBase();
            auditLogable.setVmId(vmId);
            AuditLogDirector.log(auditLogable, AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED);
            vmsWithUncontrolledBalloon.put(vmId, 0);
        }
    }
}
#method_after
// add the vm to the list of vms with uncontrolled inflated balloon or increment its counter
private void guestAgentIsDownAndBalloonInfalted(Guid vmId) {
    Integer currentVal = vmsWithUncontrolledBalloon.get(vmId);
    if (currentVal == null) {
        vmsWithUncontrolledBalloon.put(vmId, 1);
    } else {
        vmsWithUncontrolledBalloon.put(vmId, currentVal + 1);
        if (currentVal >= Config.<Integer>getValue(ConfigValues.IterationsWithBalloonProblem)) {
            AuditLogableBase auditLogable = new AuditLogableBase();
            auditLogable.setVmId(vmId);
            AuditLogDirector.log(auditLogable, AuditLogType.VM_BALLOON_DRIVER_UNCONTROLLED);
            vmsWithUncontrolledBalloon.put(vmId, 0);
        }
    }
}
#end_block

#method_before
// add the vm to the list of vms with balloon driver problem or increment its counter
private void vmBalloonDriverIsRequestedAndUnavailable(Guid vmId) {
    Integer currentVal = vmsWithBalloonDriverProblem.get(vmId);
    if (currentVal == null) {
        vmsWithBalloonDriverProblem.put(vmId, 1);
    } else {
        vmsWithBalloonDriverProblem.put(vmId, currentVal + 1);
        if (currentVal >= Config.<Integer>GetValue(ConfigValues.IterationsWithBalloonProblem)) {
            AuditLogableBase auditLogable = new AuditLogableBase();
            auditLogable.setVmId(vmId);
            AuditLogDirector.log(auditLogable, AuditLogType.VM_BALLOON_DRIVER_ERROR);
            vmsWithBalloonDriverProblem.put(vmId, 0);
        }
    }
}
#method_after
// add the vm to the list of vms with balloon driver problem or increment its counter
private void vmBalloonDriverIsRequestedAndUnavailable(Guid vmId) {
    Integer currentVal = vmsWithBalloonDriverProblem.get(vmId);
    if (currentVal == null) {
        vmsWithBalloonDriverProblem.put(vmId, 1);
    } else {
        vmsWithBalloonDriverProblem.put(vmId, currentVal + 1);
        if (currentVal >= Config.<Integer>getValue(ConfigValues.IterationsWithBalloonProblem)) {
            AuditLogableBase auditLogable = new AuditLogableBase();
            auditLogable.setVmId(vmId);
            AuditLogDirector.log(auditLogable, AuditLogType.VM_BALLOON_DRIVER_ERROR);
            vmsWithBalloonDriverProblem.put(vmId, 0);
        }
    }
}
#end_block

#method_before
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()));
        }
        log.infoFormat("vm {0} running in db and not running in vds - add to rerun treatment. vds {1}", vmToRemove.getName(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
        }
    }
}
#method_after
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()));
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private void refreshCommitedMemory() {
    Integer memCommited = _vds.getGuestOverhead();
    int vmsCoresCount = 0;
    for (VM vm : _vmDict.values()) {
        memCommited += vm.getVmMemSizeMb();
        memCommited += _vds.getGuestOverhead();
        vmsCoresCount += vm.getNumOfCpus();
    }
    if (memCommited == null || !memCommited.equals(_vds.getMemCommited())) {
        _vds.setMemCommited(memCommited);
        _saveVdsDynamic = true;
    }
    if (_vds.getVmsCoresCount() == null || !_vds.getVmsCoresCount().equals(vmsCoresCount)) {
        _vds.setVmsCoresCount(vmsCoresCount);
        _saveVdsDynamic = true;
    }
    if (_vds.getPendingVcpusCount() != 0 && !runningVmsInTransition) {
        _vds.setPendingVcpusCount(0);
        _saveVdsDynamic = true;
    }
    if (_vds.getPendingVmemSize() != 0 && !runningVmsInTransition) {
        // set also vmem size to 0
        _vds.setPendingVmemSize(0);
        _saveVdsDynamic = true;
    }
}
#method_after
private void refreshCommitedMemory() {
    Integer memCommited = _vds.getGuestOverhead();
    int vmsCoresCount = 0;
    for (VM vm : _vmDict.values()) {
        memCommited += vm.getVmMemSizeMb();
        memCommited += _vds.getGuestOverhead();
        vmsCoresCount += vm.getNumOfCpus();
    }
    if (memCommited == null || !memCommited.equals(_vds.getMemCommited())) {
        _vds.setMemCommited(memCommited);
        _saveVdsDynamic = true;
    }
    if (_vds.getVmsCoresCount() == null || !_vds.getVmsCoresCount().equals(vmsCoresCount)) {
        _vds.setVmsCoresCount(vmsCoresCount);
        _saveVdsDynamic = true;
    }
}
#end_block

#method_before
private boolean updateVmRunTimeInfo(RefObject<VM> vmToUpdate, VmDynamic vmNewDynamicData) {
    boolean returnValue = false;
    if (vmToUpdate.argvalue == null) {
        vmToUpdate.argvalue = getDbFacade().getVmDao().get(vmNewDynamicData.getId());
        // if vm exists in db update info
        if (vmToUpdate.argvalue != null) {
            // TODO: This is done to keep consistency with VmDAO.getById(Guid).
            // It should probably be removed, but some research is required.
            vmToUpdate.argvalue.setInterfaces(getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vmToUpdate.argvalue.getId()));
            _vmDict.put(vmToUpdate.argvalue.getId(), vmToUpdate.argvalue);
            if (vmNewDynamicData.getStatus() == VMStatus.Up) {
                if (!_succededToRunVms.contains(vmToUpdate.argvalue.getId())) {
                    _succededToRunVms.add(vmToUpdate.argvalue.getId());
                }
            }
        }
    }
    if (vmToUpdate.argvalue != null) {
        // check if dynamic data changed - update cache and DB
        List<String> props = ObjectIdentityChecker.GetChangedFields(vmToUpdate.argvalue.getDynamicData(), vmNewDynamicData);
        // dont check fields:
        props.remove("vmHost");
        props.remove("runOnVds");
        props.remove("disks");
        props.remove("bootSequence");
        props.remove("lastVdsRunOn");
        props.remove("hibernationVolHandle");
        props.remove("exitMessage");
        props.remove("lastStartTime");
        props.remove("consoleUserId");
        props.remove("consoleCurrentUserName");
        props.remove("runOnce");
        props.remove("cpuName");
        if (vmNewDynamicData.getStatus() != VMStatus.Up) {
            props.remove("appList");
            vmNewDynamicData.setAppList(vmToUpdate.argvalue.getAppList());
        } else if (props.contains("status") && vmToUpdate.argvalue.getDynamicData().getStatus() == VMStatus.PreparingForHibernate) {
            vmNewDynamicData.setStatus(VMStatus.PreparingForHibernate);
            props.remove("status");
        }
        // if anything else changed
        if (props.size() > 0) {
            vmToUpdate.argvalue.updateRunTimeDynamicData(vmNewDynamicData, _vds.getId(), _vds.getName());
            returnValue = true;
        }
    } else {
        // line.
        if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
            log.info("VDS::UpdateVmRunTimeInfo Error: found VM on a VDS that is not in the database!");
        }
    }
    return returnValue;
}
#method_after
private boolean updateVmRunTimeInfo(RefObject<VM> vmToUpdate, VmDynamic vmNewDynamicData) {
    boolean returnValue = false;
    if (vmToUpdate.argvalue == null) {
        vmToUpdate.argvalue = getDbFacade().getVmDao().get(vmNewDynamicData.getId());
        // if vm exists in db update info
        if (vmToUpdate.argvalue != null) {
            // TODO: This is done to keep consistency with VmDAO.getById(Guid).
            // It should probably be removed, but some research is required.
            vmToUpdate.argvalue.setInterfaces(getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vmToUpdate.argvalue.getId()));
            _vmDict.put(vmToUpdate.argvalue.getId(), vmToUpdate.argvalue);
            if (vmNewDynamicData.getStatus() == VMStatus.Up) {
                if (!_succededToRunVms.contains(vmToUpdate.argvalue.getId())) {
                    _succededToRunVms.add(vmToUpdate.argvalue.getId());
                }
            }
        }
    }
    if (vmToUpdate.argvalue != null) {
        // check if dynamic data changed - update cache and DB
        List<String> props = ObjectIdentityChecker.GetChangedFields(vmToUpdate.argvalue.getDynamicData(), vmNewDynamicData);
        // dont check fields:
        props.remove("vmHost");
        props.remove("runOnVds");
        props.remove("disks");
        props.remove("bootSequence");
        props.remove("lastVdsRunOn");
        props.remove("hibernationVolHandle");
        props.remove("exitMessage");
        props.remove("lastStartTime");
        props.remove("consoleUserId");
        props.remove("consoleCurrentUserName");
        props.remove("runOnce");
        props.remove("cpuName");
        if (vmNewDynamicData.getStatus() != VMStatus.Up) {
            props.remove("appList");
            vmNewDynamicData.setAppList(vmToUpdate.argvalue.getAppList());
        } else if (props.contains("status") && vmToUpdate.argvalue.getDynamicData().getStatus() == VMStatus.PreparingForHibernate) {
            vmNewDynamicData.setStatus(VMStatus.PreparingForHibernate);
            props.remove("status");
        }
        // if anything else changed
        if (props.size() > 0) {
            vmToUpdate.argvalue.updateRunTimeDynamicData(vmNewDynamicData, _vds.getId(), _vds.getName());
            returnValue = true;
        }
    } else {
        // line.
        if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
            log.info("VDS::UpdateVmRunTimeInfo Error: found VM on a VDS that is not in the database!");
        }
    }
    return returnValue;
}
#end_block

