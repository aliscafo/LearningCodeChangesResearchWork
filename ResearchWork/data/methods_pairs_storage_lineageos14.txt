149
#method_before
@Override
protected void onAttachedToWindow() {
    super.onAttachedToWindow();
    mContext.registerReceiver(mIntentReceiver, new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
    mObserver.observe();
    updateSettings();
}
#method_after
@Override
protected void onAttachedToWindow() {
    super.onAttachedToWindow();
    LineageStatusBarItem.Manager manager = LineageStatusBarItem.findManager((View) this);
    manager.addDarkReceiver(mDarkReceiver);
    manager.addVisibilityReceiver(mVisibilityReceiver);
    mContext.registerReceiver(mIntentReceiver, new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
    mObserver.observe();
    updateSettings();
}
#end_block

#method_before
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(LineageSettings.Secure.getUriFor(LineageSettings.Secure.NETWORK_TRAFFIC_MODE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Secure.getUriFor(LineageSettings.Secure.NETWORK_TRAFFIC_AUTOHIDE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Secure.getUriFor(LineageSettings.Secure.NETWORK_TRAFFIC_SHOW_UNITS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Secure.getUriFor(LineageSettings.Secure.NETWORK_TRAFFIC_USE_KBPS), false, this, UserHandle.USER_ALL);
}
#method_after
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(LineageSettings.Secure.getUriFor(LineageSettings.Secure.NETWORK_TRAFFIC_MODE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Secure.getUriFor(LineageSettings.Secure.NETWORK_TRAFFIC_AUTOHIDE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Secure.getUriFor(LineageSettings.Secure.NETWORK_TRAFFIC_UNITS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Secure.getUriFor(LineageSettings.Secure.NETWORK_TRAFFIC_SHOW_UNITS), false, this, UserHandle.USER_ALL);
}
#end_block

#method_before
private void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    mMode = LineageSettings.Secure.getIntForUser(resolver, LineageSettings.Secure.NETWORK_TRAFFIC_MODE, 0, UserHandle.USER_CURRENT);
    mAutoHide = LineageSettings.Secure.getIntForUser(resolver, LineageSettings.Secure.NETWORK_TRAFFIC_AUTOHIDE, 0, UserHandle.USER_CURRENT) == 1;
    mShowUnits = LineageSettings.Secure.getIntForUser(resolver, LineageSettings.Secure.NETWORK_TRAFFIC_SHOW_UNITS, 1, UserHandle.USER_CURRENT) == 1;
    mUseKbps = LineageSettings.Secure.getIntForUser(resolver, LineageSettings.Secure.NETWORK_TRAFFIC_USE_KBPS, 0, UserHandle.USER_CURRENT) == 1;
    if (mMode != MODE_DISABLED) {
        updateTrafficDrawable();
    }
    updateViewState();
}
#method_after
private void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    mMode = LineageSettings.Secure.getIntForUser(resolver, LineageSettings.Secure.NETWORK_TRAFFIC_MODE, 0, UserHandle.USER_CURRENT);
    mAutoHide = LineageSettings.Secure.getIntForUser(resolver, LineageSettings.Secure.NETWORK_TRAFFIC_AUTOHIDE, 0, UserHandle.USER_CURRENT) == 1;
    mUnits = LineageSettings.Secure.getIntForUser(resolver, LineageSettings.Secure.NETWORK_TRAFFIC_UNITS, /* Mbps */
    1, UserHandle.USER_CURRENT);
    switch(mUnits) {
        case UNITS_KILOBITS:
            mAutoHideThreshold = AUTOHIDE_THRESHOLD_KILOBITS;
            break;
        case UNITS_MEGABITS:
            mAutoHideThreshold = AUTOHIDE_THRESHOLD_MEGABITS;
            break;
        case UNITS_KILOBYTES:
            mAutoHideThreshold = AUTOHIDE_THRESHOLD_KILOBYTES;
            break;
        case UNITS_MEGABYTES:
            mAutoHideThreshold = AUTOHIDE_THRESHOLD_MEGABYTES;
            break;
        default:
            mAutoHideThreshold = 0;
            break;
    }
    mShowUnits = LineageSettings.Secure.getIntForUser(resolver, LineageSettings.Secure.NETWORK_TRAFFIC_SHOW_UNITS, 1, UserHandle.USER_CURRENT) == 1;
    if (mMode != MODE_DISABLED) {
        updateTrafficDrawable();
    }
    updateViewState();
}
#end_block

#method_before
private void acquireWakeLockInternal(IBinder lock, int flags, String tag, String packageName, WorkSource ws, String historyTag, int uid, int pid) {
    synchronized (mLock) {
        if (DEBUG_SPEW) {
            Slog.d(TAG, "acquireWakeLockInternal: lock=" + Objects.hashCode(lock) + ", flags=0x" + Integer.toHexString(flags) + ", tag=\"" + tag + "\", ws=" + ws + ", uid=" + uid + ", pid=" + pid);
        }
        WakeLock wakeLock;
        int index = findWakeLockIndexLocked(lock);
        boolean notifyAcquire;
        if (index >= 0) {
            wakeLock = mWakeLocks.get(index);
            if (!wakeLock.hasSameProperties(flags, tag, ws, uid, pid)) {
                // Update existing wake lock.  This shouldn't happen but is harmless.
                notifyWakeLockChangingLocked(wakeLock, flags, tag, packageName, uid, pid, ws, historyTag);
                wakeLock.updateProperties(flags, tag, packageName, ws, historyTag, uid, pid);
            }
            notifyAcquire = false;
        } else {
            UidState state = mUidState.get(uid);
            if (state == null) {
                state = new UidState(uid);
                state.mProcState = ActivityManager.PROCESS_STATE_NONEXISTENT;
                mUidState.put(uid, state);
            }
            state.mNumWakeLocks++;
            wakeLock = new WakeLock(lock, flags, tag, packageName, ws, historyTag, uid, pid, state);
            try {
                lock.linkToDeath(wakeLock, 0);
            } catch (RemoteException ex) {
                throw new IllegalArgumentException("Wake lock is already dead.");
            }
            mWakeLocks.add(wakeLock);
            setWakeLockDisabledStateLocked(wakeLock);
            notifyAcquire = true;
        }
        applyWakeLockFlagsOnAcquireLocked(wakeLock, uid);
        mDirty |= DIRTY_WAKE_LOCKS;
        updatePowerStateLocked();
        if (notifyAcquire) {
            // This needs to be done last so we are sure we have acquired the
            // kernel wake lock.  Otherwise we have a race where the system may
            // go to sleep between the time we start the accounting in battery
            // stats and when we actually get around to telling the kernel to
            // stay awake.
            notifyWakeLockAcquiredLocked(wakeLock);
        }
    }
}
#method_after
private void acquireWakeLockInternal(IBinder lock, int flags, String tag, String packageName, WorkSource ws, String historyTag, int uid, int pid) {
    synchronized (mLock) {
        if (DEBUG_SPEW) {
            Slog.d(TAG, "acquireWakeLockInternal: lock=" + Objects.hashCode(lock) + ", flags=0x" + Integer.toHexString(flags) + ", tag=\"" + tag + "\", ws=" + ws + ", uid=" + uid + ", pid=" + pid);
        }
        WakeLock wakeLock;
        int index = findWakeLockIndexLocked(lock);
        boolean notifyAcquire;
        if (index >= 0) {
            wakeLock = mWakeLocks.get(index);
            if (!wakeLock.hasSameProperties(flags, tag, ws, uid, pid)) {
                // Update existing wake lock.  This shouldn't happen but is harmless.
                notifyWakeLockChangingLocked(wakeLock, flags, tag, packageName, uid, pid, ws, historyTag);
                wakeLock.updateProperties(flags, tag, packageName, ws, historyTag, uid, pid);
            }
            notifyAcquire = false;
        } else {
            UidState state = mUidState.get(uid);
            if (state == null) {
                state = new UidState(uid);
                state.mProcState = ActivityManager.PROCESS_STATE_NONEXISTENT;
                mUidState.put(uid, state);
            }
            state.mNumWakeLocks++;
            wakeLock = new WakeLock(lock, flags, tag, packageName, ws, historyTag, uid, pid, state);
            try {
                lock.linkToDeath(wakeLock, 0);
            } catch (RemoteException ex) {
                throw new IllegalArgumentException("Wake lock is already dead.");
            }
            mWakeLocks.add(wakeLock);
            setWakeLockDisabledStateLocked(wakeLock);
            qcNsrmPowExt.checkPmsBlockedWakelocks(uid, pid, flags, tag, wakeLock);
            notifyAcquire = true;
        }
        applyWakeLockFlagsOnAcquireLocked(wakeLock, uid);
        mDirty |= DIRTY_WAKE_LOCKS;
        updatePowerStateLocked();
        if (notifyAcquire) {
            // This needs to be done last so we are sure we have acquired the
            // kernel wake lock.  Otherwise we have a race where the system may
            // go to sleep between the time we start the accounting in battery
            // stats and when we actually get around to telling the kernel to
            // stay awake.
            notifyWakeLockAcquiredLocked(wakeLock);
        }
    }
}
#end_block

#method_before
private void notifyWakeLockAcquiredLocked(WakeLock wakeLock) {
    if (mSystemReady && !wakeLock.mDisabled) {
        wakeLock.mNotifiedAcquired = true;
        mNotifier.onWakeLockAcquired(wakeLock.mFlags, wakeLock.mTag, wakeLock.mPackageName, wakeLock.mOwnerUid, wakeLock.mOwnerPid, wakeLock.mWorkSource, wakeLock.mHistoryTag);
        restartNofifyLongTimerLocked(wakeLock);
    }
}
#method_after
protected void notifyWakeLockAcquiredLocked(WakeLock wakeLock) {
    if (mSystemReady && !wakeLock.mDisabled) {
        wakeLock.mNotifiedAcquired = true;
        mNotifier.onWakeLockAcquired(wakeLock.mFlags, wakeLock.mTag, wakeLock.mPackageName, wakeLock.mOwnerUid, wakeLock.mOwnerPid, wakeLock.mWorkSource, wakeLock.mHistoryTag);
        restartNofifyLongTimerLocked(wakeLock);
    }
}
#end_block

#method_before
private void notifyWakeLockReleasedLocked(WakeLock wakeLock) {
    if (mSystemReady && wakeLock.mNotifiedAcquired) {
        wakeLock.mNotifiedAcquired = false;
        wakeLock.mAcquireTime = 0;
        mNotifier.onWakeLockReleased(wakeLock.mFlags, wakeLock.mTag, wakeLock.mPackageName, wakeLock.mOwnerUid, wakeLock.mOwnerPid, wakeLock.mWorkSource, wakeLock.mHistoryTag);
        notifyWakeLockLongFinishedLocked(wakeLock);
    }
}
#method_after
protected void notifyWakeLockReleasedLocked(WakeLock wakeLock) {
    if (mSystemReady && wakeLock.mNotifiedAcquired) {
        wakeLock.mNotifiedAcquired = false;
        wakeLock.mAcquireTime = 0;
        mNotifier.onWakeLockReleased(wakeLock.mFlags, wakeLock.mTag, wakeLock.mPackageName, wakeLock.mOwnerUid, wakeLock.mOwnerPid, wakeLock.mWorkSource, wakeLock.mHistoryTag);
        notifyWakeLockLongFinishedLocked(wakeLock);
    }
}
#end_block

#method_before
private void updatePowerStateLocked() {
    if (!mSystemReady || mDirty == 0) {
        return;
    }
    if (!Thread.holdsLock(mLock)) {
        Slog.wtf(TAG, "Power manager lock was not held when calling updatePowerStateLocked");
    }
    Trace.traceBegin(Trace.TRACE_TAG_POWER, "updatePowerState");
    try {
        // Phase 0: Basic state updates.
        updateIsPoweredLocked(mDirty);
        updateStayOnLocked(mDirty);
        updateScreenBrightnessBoostLocked(mDirty);
        // Phase 1: Update wakefulness.
        // Loop because the wake lock and user activity computations are influenced
        // by changes in wakefulness.
        final long now = SystemClock.uptimeMillis();
        int dirtyPhase2 = 0;
        for (; ; ) {
            int dirtyPhase1 = mDirty;
            dirtyPhase2 |= dirtyPhase1;
            mDirty = 0;
            updateWakeLockSummaryLocked(dirtyPhase1);
            updateUserActivitySummaryLocked(now, dirtyPhase1);
            if (!updateWakefulnessLocked(dirtyPhase1)) {
                break;
            }
        }
        // Phase 2: Update display power state.
        boolean displayBecameReady = updateDisplayPowerStateLocked(dirtyPhase2);
        // Phase 3: Update dream state (depends on display ready signal).
        updateDreamLocked(dirtyPhase2, displayBecameReady);
        // Phase 4: Send notifications, if needed.
        finishWakefulnessChangeIfNeededLocked();
        // Phase 5: Update suspend blocker.
        // Because we might release the last suspend blocker here, we need to make sure
        // we finished everything else first!
        updateSuspendBlockerLocked();
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_POWER);
    }
}
#method_after
protected void updatePowerStateLocked() {
    if (!mSystemReady || mDirty == 0) {
        return;
    }
    if (!Thread.holdsLock(mLock)) {
        Slog.wtf(TAG, "Power manager lock was not held when calling updatePowerStateLocked");
    }
    Trace.traceBegin(Trace.TRACE_TAG_POWER, "updatePowerState");
    try {
        // Phase 0: Basic state updates.
        updateIsPoweredLocked(mDirty);
        updateStayOnLocked(mDirty);
        updateScreenBrightnessBoostLocked(mDirty);
        // Phase 1: Update wakefulness.
        // Loop because the wake lock and user activity computations are influenced
        // by changes in wakefulness.
        final long now = SystemClock.uptimeMillis();
        int dirtyPhase2 = 0;
        for (; ; ) {
            int dirtyPhase1 = mDirty;
            dirtyPhase2 |= dirtyPhase1;
            mDirty = 0;
            updateWakeLockSummaryLocked(dirtyPhase1);
            updateUserActivitySummaryLocked(now, dirtyPhase1);
            if (!updateWakefulnessLocked(dirtyPhase1)) {
                break;
            }
        }
        // Phase 2: Update display power state.
        boolean displayBecameReady = updateDisplayPowerStateLocked(dirtyPhase2);
        // Phase 3: Update dream state (depends on display ready signal).
        updateDreamLocked(dirtyPhase2, displayBecameReady);
        // Phase 4: Send notifications, if needed.
        finishWakefulnessChangeIfNeededLocked();
        // Phase 5: Update suspend blocker.
        // Because we might release the last suspend blocker here, we need to make sure
        // we finished everything else first!
        updateSuspendBlockerLocked();
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_POWER);
    }
}
#end_block

#method_before
private void updateUserActivitySummaryLocked(long now, int dirty) {
    // Update the status of the user activity timeout timer.
    if ((dirty & (DIRTY_WAKE_LOCKS | DIRTY_USER_ACTIVITY | DIRTY_WAKEFULNESS | DIRTY_SETTINGS)) != 0) {
        mHandler.removeMessages(MSG_USER_ACTIVITY_TIMEOUT);
        long nextTimeout = 0;
        if (mWakefulness == WAKEFULNESS_AWAKE || mWakefulness == WAKEFULNESS_DREAMING || mWakefulness == WAKEFULNESS_DOZING) {
            final int sleepTimeout = getSleepTimeoutLocked();
            final int screenOffTimeout = getScreenOffTimeoutLocked(sleepTimeout);
            final int screenDimDuration = getScreenDimDurationLocked(screenOffTimeout);
            final boolean userInactiveOverride = mUserInactiveOverrideFromWindowManager;
            mUserActivitySummary = 0;
            if (mLastUserActivityTime >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTime + screenOffTimeout - screenDimDuration;
                if (now < nextTimeout) {
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                    if (mWakefulness == WAKEFULNESS_AWAKE) {
                        int buttonBrightness;
                        if (mButtonBrightnessOverrideFromWindowManager >= 0) {
                            buttonBrightness = mButtonBrightnessOverrideFromWindowManager;
                        } else {
                            if (!mDevForceNavbar) {
                                buttonBrightness = mButtonBrightness;
                            } else {
                                buttonBrightness = 0;
                            }
                        }
                        if (mButtonTimeout != 0 && now > mLastUserActivityTime + mButtonTimeout) {
                            mButtonsLight.setBrightness(0);
                        } else {
                            if (!mProximityPositive) {
                                mButtonsLight.setBrightness(buttonBrightness);
                                if (buttonBrightness != 0 && mButtonTimeout != 0) {
                                    nextTimeout = now + mButtonTimeout;
                                }
                            }
                        }
                    }
                } else {
                    nextTimeout = mLastUserActivityTime + screenOffTimeout;
                    if (now < nextTimeout) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                    }
                }
            }
            if (mUserActivitySummary == 0 && mLastUserActivityTimeNoChangeLights >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTimeNoChangeLights + screenOffTimeout;
                if (now < nextTimeout) {
                    if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_BRIGHT || mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_VR) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                    } else if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_DIM) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                    }
                }
            }
            if (mUserActivitySummary == 0) {
                if (sleepTimeout >= 0) {
                    final long anyUserActivity = Math.max(mLastUserActivityTime, mLastUserActivityTimeNoChangeLights);
                    if (anyUserActivity >= mLastWakeTime) {
                        nextTimeout = anyUserActivity + sleepTimeout;
                        if (now < nextTimeout) {
                            mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                        }
                    }
                } else {
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                    nextTimeout = -1;
                }
            }
            if (mUserActivitySummary != USER_ACTIVITY_SCREEN_DREAM && userInactiveOverride) {
                if ((mUserActivitySummary & (USER_ACTIVITY_SCREEN_BRIGHT | USER_ACTIVITY_SCREEN_DIM)) != 0) {
                    // Device is being kept awake by recent user activity
                    if (nextTimeout >= now && mOverriddenTimeout == -1) {
                        // Save when the next timeout would have occurred
                        mOverriddenTimeout = nextTimeout;
                    }
                }
                mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                nextTimeout = -1;
            }
            if (mUserActivitySummary != 0 && nextTimeout >= 0) {
                Message msg = mHandler.obtainMessage(MSG_USER_ACTIVITY_TIMEOUT);
                msg.setAsynchronous(true);
                mHandler.sendMessageAtTime(msg, nextTimeout);
            }
        } else {
            mUserActivitySummary = 0;
        }
        if (DEBUG_SPEW) {
            Slog.d(TAG, "updateUserActivitySummaryLocked: mWakefulness=" + PowerManagerInternal.wakefulnessToString(mWakefulness) + ", mUserActivitySummary=0x" + Integer.toHexString(mUserActivitySummary) + ", nextTimeout=" + TimeUtils.formatUptime(nextTimeout));
        }
    }
}
#method_after
private void updateUserActivitySummaryLocked(long now, int dirty) {
    // Update the status of the user activity timeout timer.
    if ((dirty & (DIRTY_WAKE_LOCKS | DIRTY_USER_ACTIVITY | DIRTY_WAKEFULNESS | DIRTY_SETTINGS)) != 0) {
        mHandler.removeMessages(MSG_USER_ACTIVITY_TIMEOUT);
        long nextTimeout = 0;
        if (mWakefulness == WAKEFULNESS_AWAKE || mWakefulness == WAKEFULNESS_DREAMING || mWakefulness == WAKEFULNESS_DOZING) {
            final int sleepTimeout = getSleepTimeoutLocked();
            final int screenOffTimeout = getScreenOffTimeoutLocked(sleepTimeout);
            final int screenDimDuration = getScreenDimDurationLocked(screenOffTimeout);
            final boolean userInactiveOverride = mUserInactiveOverrideFromWindowManager;
            mUserActivitySummary = 0;
            if (mLastUserActivityTime >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTime + screenOffTimeout - screenDimDuration;
                if (now < nextTimeout) {
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                    if (mWakefulness == WAKEFULNESS_AWAKE) {
                        int buttonBrightness;
                        if (mButtonBrightnessOverrideFromWindowManager >= 0) {
                            buttonBrightness = mButtonBrightnessOverrideFromWindowManager;
                        } else {
                            if (!mDevForceNavbar) {
                                buttonBrightness = mButtonBrightness;
                            } else {
                                buttonBrightness = 0;
                            }
                        }
                        if (mButtonTimeout != 0 && now > mLastUserActivityTime + mButtonTimeout) {
                            mButtonsLight.setBrightness(0);
                        } else {
                            if (!mProximityPositive) {
                                mButtonsLight.setBrightness(buttonBrightness);
                                if (buttonBrightness != 0 && mButtonTimeout != 0) {
                                    nextTimeout = now + mButtonTimeout;
                                }
                            }
                        }
                    }
                } else {
                    nextTimeout = mLastUserActivityTime + screenOffTimeout;
                    if (now < nextTimeout) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                        if (mWakefulness == WAKEFULNESS_AWAKE) {
                            mButtonsLight.setBrightness(0);
                        }
                    }
                }
            }
            if (mUserActivitySummary == 0 && mLastUserActivityTimeNoChangeLights >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTimeNoChangeLights + screenOffTimeout;
                if (now < nextTimeout) {
                    if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_BRIGHT || mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_VR) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                    } else if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_DIM) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                    }
                }
            }
            if (mUserActivitySummary == 0) {
                if (sleepTimeout >= 0) {
                    final long anyUserActivity = Math.max(mLastUserActivityTime, mLastUserActivityTimeNoChangeLights);
                    if (anyUserActivity >= mLastWakeTime) {
                        nextTimeout = anyUserActivity + sleepTimeout;
                        if (now < nextTimeout) {
                            mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                        }
                    }
                } else {
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                    nextTimeout = -1;
                }
            }
            if (mUserActivitySummary != USER_ACTIVITY_SCREEN_DREAM && userInactiveOverride) {
                if ((mUserActivitySummary & (USER_ACTIVITY_SCREEN_BRIGHT | USER_ACTIVITY_SCREEN_DIM)) != 0) {
                    // Device is being kept awake by recent user activity
                    if (nextTimeout >= now && mOverriddenTimeout == -1) {
                        // Save when the next timeout would have occurred
                        mOverriddenTimeout = nextTimeout;
                    }
                }
                mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                nextTimeout = -1;
            }
            if (mUserActivitySummary != 0 && nextTimeout >= 0) {
                Message msg = mHandler.obtainMessage(MSG_USER_ACTIVITY_TIMEOUT);
                msg.setAsynchronous(true);
                mHandler.sendMessageAtTime(msg, nextTimeout);
            }
        } else {
            mUserActivitySummary = 0;
        }
        if (DEBUG_SPEW) {
            Slog.d(TAG, "updateUserActivitySummaryLocked: mWakefulness=" + PowerManagerInternal.wakefulnessToString(mWakefulness) + ", mUserActivitySummary=0x" + Integer.toHexString(mUserActivitySummary) + ", nextTimeout=" + TimeUtils.formatUptime(nextTimeout));
        }
    }
}
#end_block

#method_before
private void shutdownOrRebootInternal(@HaltMode final int haltMode, final boolean confirm, final String reason, boolean wait) {
    if (mHandler == null || !mSystemReady) {
        if (RescueParty.isAttemptingFactoryReset()) {
            // If we're stuck in a really low-level reboot loop, and a
            // rescue party is trying to prompt the user for a factory data
            // reset, we must GET TO DA CHOPPA!
            PowerManagerService.lowLevelReboot(reason);
        } else {
            throw new IllegalStateException("Too early to call shutdown() or reboot()");
        }
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            synchronized (this) {
                if (haltMode == HALT_MODE_REBOOT_SAFE_MODE) {
                    ShutdownThread.rebootSafeMode(getUiContext(), confirm);
                } else if (haltMode == HALT_MODE_REBOOT) {
                    ShutdownThread.reboot(getUiContext(), reason, confirm);
                } else {
                    ShutdownThread.shutdown(getUiContext(), reason, confirm);
                }
            }
        }
    };
    // ShutdownThread must run on a looper capable of displaying the UI.
    Message msg = Message.obtain(UiThread.getHandler(), runnable);
    msg.setAsynchronous(true);
    UiThread.getHandler().sendMessage(msg);
    // PowerManager.reboot() is documented not to return so just wait for the inevitable.
    if (wait) {
        synchronized (runnable) {
            while (true) {
                try {
                    runnable.wait();
                } catch (InterruptedException e) {
                }
            }
        }
    }
}
#method_after
private void shutdownOrRebootInternal(@HaltMode final int haltMode, final boolean confirm, final String reason, boolean wait, final boolean custom) {
    if (mHandler == null || !mSystemReady) {
        if (RescueParty.isAttemptingFactoryReset()) {
            // If we're stuck in a really low-level reboot loop, and a
            // rescue party is trying to prompt the user for a factory data
            // reset, we must GET TO DA CHOPPA!
            PowerManagerService.lowLevelReboot(reason);
        } else {
            throw new IllegalStateException("Too early to call shutdown() or reboot()");
        }
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            synchronized (this) {
                if (haltMode == HALT_MODE_REBOOT_SAFE_MODE) {
                    ShutdownThread.rebootSafeMode(getUiContext(), confirm);
                } else if (haltMode == HALT_MODE_REBOOT) {
                    if (custom) {
                        ShutdownThread.rebootCustom(getUiContext(), reason, confirm);
                    } else {
                        ShutdownThread.reboot(getUiContext(), reason, confirm);
                    }
                } else {
                    ShutdownThread.shutdown(getUiContext(), reason, confirm);
                }
            }
        }
    };
    // ShutdownThread must run on a looper capable of displaying the UI.
    Message msg = Message.obtain(UiThread.getHandler(), runnable);
    msg.setAsynchronous(true);
    UiThread.getHandler().sendMessage(msg);
    // PowerManager.reboot() is documented not to return so just wait for the inevitable.
    if (wait) {
        synchronized (runnable) {
            while (true) {
                try {
                    runnable.wait();
                } catch (InterruptedException e) {
                }
            }
        }
    }
}
#end_block

#method_before
// Binder call
@Override
public void reboot(boolean confirm, String reason, boolean wait) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT, null);
    if (PowerManager.REBOOT_RECOVERY.equals(reason) || PowerManager.REBOOT_RECOVERY_UPDATE.equals(reason)) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.RECOVERY, null);
    }
    final long ident = Binder.clearCallingIdentity();
    try {
        shutdownOrRebootInternal(HALT_MODE_REBOOT, confirm, reason, wait);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
// Binder call
@Override
public void reboot(boolean confirm, String reason, boolean wait) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT, null);
    if (PowerManager.REBOOT_RECOVERY.equals(reason) || PowerManager.REBOOT_RECOVERY_UPDATE.equals(reason)) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.RECOVERY, null);
    }
    final long ident = Binder.clearCallingIdentity();
    try {
        shutdownOrRebootInternal(HALT_MODE_REBOOT, confirm, reason, wait, false);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
// Binder call
@Override
public void rebootSafeMode(boolean confirm, boolean wait) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT, null);
    final long ident = Binder.clearCallingIdentity();
    try {
        shutdownOrRebootInternal(HALT_MODE_REBOOT_SAFE_MODE, confirm, PowerManager.REBOOT_SAFE_MODE, wait);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
// Binder call
@Override
public void rebootSafeMode(boolean confirm, boolean wait) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT, null);
    final long ident = Binder.clearCallingIdentity();
    try {
        shutdownOrRebootInternal(HALT_MODE_REBOOT_SAFE_MODE, confirm, PowerManager.REBOOT_SAFE_MODE, wait, false);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
// Binder call
@Override
public void shutdown(boolean confirm, String reason, boolean wait) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT, null);
    final long ident = Binder.clearCallingIdentity();
    try {
        shutdownOrRebootInternal(HALT_MODE_SHUTDOWN, confirm, reason, wait);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
// Binder call
@Override
public void shutdown(boolean confirm, String reason, boolean wait) {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT, null);
    final long ident = Binder.clearCallingIdentity();
    try {
        shutdownOrRebootInternal(HALT_MODE_SHUTDOWN, confirm, reason, wait, false);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
public void onPageLoadFinished() {
    mLoading = false;
    if (!mUrlBarHasFocus) {
        updateUrlBarText();
    }
    updateSecureIconVisibility();
}
#method_after
public void onPageLoadFinished(Context context, SslCertificate certificate) {
    mLoading = false;
    if (!mUrlBarHasFocus) {
        updateUrlBarText();
    }
    updateSecureIconVisibility();
    updateSSLCertificateDialog(context, certificate);
}
#end_block

#method_before
public void updateSSLCertificateDialog(SslCertificate certificate) {
    // This will only update the dialog if the site we're accessing has SSL enabled
    if (certificate != null) {
        Context context = this.mSecureIcon.getContext();
        View dialogView = LayoutInflater.from(context).inflate(R.layout.dialog_ssl_certificate_info, null);
        // Get the text views
        TextView domainView = (TextView) dialogView.findViewById(R.id.domain);
        TextView issuedToCNView = (TextView) dialogView.findViewById(R.id.issued_to_cn);
        TextView issuedToOView = (TextView) dialogView.findViewById(R.id.issued_to_o);
        TextView issuedToUNView = (TextView) dialogView.findViewById(R.id.issued_to_un);
        TextView issuedByCNView = (TextView) dialogView.findViewById(R.id.issued_by_cn);
        TextView issuedByOView = (TextView) dialogView.findViewById(R.id.issued_by_o);
        TextView issuedByUNView = (TextView) dialogView.findViewById(R.id.issued_by_un);
        TextView startDateView = (TextView) dialogView.findViewById(R.id.start_date);
        TextView endDateView = (TextView) dialogView.findViewById(R.id.end_date);
        // Generate the labels
        String domainLabel = context.getString(R.string.ssl_cert_dialog_domain_label) + "  ";
        String cnLabel = context.getString(R.string.ssl_cert_dialog_common_name) + "  ";
        String orgLabel = context.getString(R.string.ssl_cert_dialog_organization) + "  ";
        String unLabel = context.getString(R.string.ssl_cert_dialog_organizational_unit) + "  ";
        String startDateLabel = context.getString(R.string.ssl_cert_dialog_valid_not_before) + "  ";
        String endDateLabel = context.getString(R.string.ssl_cert_dialog_valid_not_after) + "  ";
        // Get the domain name
        String domainString = Uri.parse(mUrl).getHost();
        // Get the validity dates
        Date startDate = certificate.getValidNotBeforeDate();
        Date endDate = certificate.getValidNotAfterDate();
        // Create a spannable string builder to apply color to the values
        SpannableStringBuilder domainStringBuilder = new SpannableStringBuilder(domainLabel + domainString);
        SpannableStringBuilder issuedToCNStringBuilder = new SpannableStringBuilder(cnLabel + certificate.getIssuedTo().getCName());
        SpannableStringBuilder issuedToOStringBuilder = new SpannableStringBuilder(orgLabel + certificate.getIssuedTo().getOName());
        SpannableStringBuilder issuedToUNStringBuilder = new SpannableStringBuilder(unLabel + certificate.getIssuedTo().getUName());
        SpannableStringBuilder issuedByCNStringBuilder = new SpannableStringBuilder(cnLabel + certificate.getIssuedBy().getCName());
        SpannableStringBuilder issuedByOStringBuilder = new SpannableStringBuilder(orgLabel + certificate.getIssuedBy().getOName());
        SpannableStringBuilder issuedByUNStringBuilder = new SpannableStringBuilder(unLabel + certificate.getIssuedBy().getUName());
        SpannableStringBuilder startDateStringBuilder = new SpannableStringBuilder(startDateLabel + DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.LONG).format(startDate));
        SpannableStringBuilder endDateStringBuilder = new SpannableStringBuilder(endDateLabel + DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.LONG).format(endDate));
        // Define the color we want to use to highlight the certificate's values
        ForegroundColorSpan colorSpan = new ForegroundColorSpan(context.getColor(R.color.colorAccent));
        // Apply color to certificate values
        domainStringBuilder.setSpan(colorSpan, domainLabel.length(), domainStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_INCLUSIVE);
        issuedToCNStringBuilder.setSpan(colorSpan, cnLabel.length(), issuedToCNStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_INCLUSIVE);
        issuedToOStringBuilder.setSpan(colorSpan, orgLabel.length(), issuedToOStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_INCLUSIVE);
        issuedToUNStringBuilder.setSpan(colorSpan, unLabel.length(), issuedToUNStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_INCLUSIVE);
        issuedByCNStringBuilder.setSpan(colorSpan, cnLabel.length(), issuedByCNStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_INCLUSIVE);
        issuedByOStringBuilder.setSpan(colorSpan, orgLabel.length(), issuedByOStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_INCLUSIVE);
        issuedByUNStringBuilder.setSpan(colorSpan, unLabel.length(), issuedByUNStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_INCLUSIVE);
        startDateStringBuilder.setSpan(colorSpan, startDateLabel.length(), startDateStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_INCLUSIVE);
        endDateStringBuilder.setSpan(colorSpan, endDateLabel.length(), endDateStringBuilder.length(), Spanned.SPAN_EXCLUSIVE_INCLUSIVE);
        // Update TextViews
        domainView.setText(domainStringBuilder);
        issuedToCNView.setText(issuedToCNStringBuilder);
        issuedToOView.setText(issuedToOStringBuilder);
        issuedToUNView.setText(issuedToUNStringBuilder);
        issuedByCNView.setText(issuedByCNStringBuilder);
        issuedByOView.setText(issuedByOStringBuilder);
        issuedByUNView.setText(issuedByUNStringBuilder);
        startDateView.setText(startDateStringBuilder);
        endDateView.setText(endDateStringBuilder);
        // Build the dialog
        AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(context, R.style.Theme_AppCompat_Light_Dialog_Alert).setTitle(context.getString(R.string.ssl_cert_dialog_title)).setView(dialogView).setNegativeButton(android.R.string.cancel, null);
        // Create the dialog
        final AlertDialog dialog = dialogBuilder.create();
        // Make it so the dialog will show if you tap the lock icon
        mSecureIcon.setOnTouchListener((v, event) -> {
            dialog.show();
            return false;
        });
    }
}
#method_after
private void updateSSLCertificateDialog(Context context, SslCertificate certificate) {
    if (certificate == null)
        return;
    // Show the dialog if you tap the lock icon and the cert is valid
    mSecureIcon.setOnClickListener((v) -> {
        View view = LayoutInflater.from(context).inflate(R.layout.dialog_ssl_certificate_info, new LinearLayout(context));
        // Get the text views
        TextView domainView = (TextView) view.findViewById(R.id.domain);
        KeyValueView issuedToCNView = (KeyValueView) view.findViewById(R.id.issued_to_cn);
        KeyValueView issuedToOView = (KeyValueView) view.findViewById(R.id.issued_to_o);
        KeyValueView issuedToUNView = (KeyValueView) view.findViewById(R.id.issued_to_un);
        KeyValueView issuedByCNView = (KeyValueView) view.findViewById(R.id.issued_by_cn);
        KeyValueView issuedByOView = (KeyValueView) view.findViewById(R.id.issued_by_o);
        KeyValueView issuedByUNView = (KeyValueView) view.findViewById(R.id.issued_by_un);
        KeyValueView issuedOnView = (KeyValueView) view.findViewById(R.id.issued_on);
        KeyValueView expiresOnView = (KeyValueView) view.findViewById(R.id.expires_on);
        // Get the domain name
        String domainString = Uri.parse(mUrl).getHost();
        // Get the validity dates
        Date startDate = certificate.getValidNotBeforeDate();
        Date endDate = certificate.getValidNotAfterDate();
        // Update TextViews
        domainView.setText(domainString);
        issuedToCNView.setText(R.string.ssl_cert_dialog_common_name, certificate.getIssuedTo().getCName());
        issuedToOView.setText(R.string.ssl_cert_dialog_organization, certificate.getIssuedTo().getOName());
        issuedToUNView.setText(R.string.ssl_cert_dialog_organizational_unit, certificate.getIssuedTo().getUName());
        issuedByCNView.setText(R.string.ssl_cert_dialog_common_name, certificate.getIssuedBy().getCName());
        issuedByOView.setText(R.string.ssl_cert_dialog_organization, certificate.getIssuedBy().getOName());
        issuedByUNView.setText(R.string.ssl_cert_dialog_organizational_unit, certificate.getIssuedBy().getUName());
        issuedOnView.setText(R.string.ssl_cert_dialog_issued_on, DateFormat.getDateTimeInstance().format(startDate));
        expiresOnView.setText(R.string.ssl_cert_dialog_expires_on, DateFormat.getDateTimeInstance().format(endDate));
        // Build and show the dialog
        new AlertDialog.Builder(context).setTitle(R.string.ssl_cert_dialog_title).setView(view).setNegativeButton(R.string.ssl_cert_dialog_dismiss, null).create().show();
    });
}
#end_block

#method_before
@Override
public void onPageFinished(WebView view, String url) {
    super.onPageFinished(view, url);
    mUrlBarController.onPageLoadFinished();
    mUrlBarController.updateSSLCertificateDialog(view.getCertificate());
}
#method_after
@Override
public void onPageFinished(WebView view, String url) {
    super.onPageFinished(view, url);
    mUrlBarController.onPageLoadFinished(view.getContext(), view.getCertificate());
}
#end_block

#method_before
@Override
public void onReceivedHttpAuthRequest(WebView view, HttpAuthHandler handler, String host, String realm) {
    Context context = view.getContext();
    AlertDialog.Builder builder = new AlertDialog.Builder(context);
    LayoutInflater layoutInflater = LayoutInflater.from(context);
    View dialogView = layoutInflater.inflate(R.layout.auth_dialog, new LinearLayout(context));
    EditText username = (EditText) dialogView.findViewById(R.id.username);
    EditText password = (EditText) dialogView.findViewById(R.id.password);
    TextView auth_detail = (TextView) dialogView.findViewById(R.id.auth_detail);
    String text = context.getString(R.string.auth_dialog_detail, view.getUrl());
    auth_detail.setText(text);
    builder.setView(dialogView).setCancelable(false).setTitle(R.string.auth_dialog_title).setPositiveButton(R.string.auth_dialog_login, (dialog, whichButton) -> handler.proceed(username.getText().toString(), password.getText().toString())).setNegativeButton(android.R.string.cancel, (dialog, whichButton) -> handler.cancel()).show();
}
#method_after
@Override
public void onReceivedHttpAuthRequest(WebView view, HttpAuthHandler handler, String host, String realm) {
    Context context = view.getContext();
    AlertDialog.Builder builder = new AlertDialog.Builder(context);
    LayoutInflater layoutInflater = LayoutInflater.from(context);
    View dialogView = layoutInflater.inflate(R.layout.auth_dialog, new LinearLayout(context));
    EditText username = (EditText) dialogView.findViewById(R.id.username);
    EditText password = (EditText) dialogView.findViewById(R.id.password);
    TextView auth_detail = (TextView) dialogView.findViewById(R.id.auth_detail);
    String text = context.getString(R.string.auth_dialog_detail, view.getUrl());
    auth_detail.setText(text);
    builder.setView(dialogView).setTitle(R.string.auth_dialog_title).setPositiveButton(R.string.auth_dialog_login, (dialog, whichButton) -> handler.proceed(username.getText().toString(), password.getText().toString())).setNegativeButton(android.R.string.cancel, (dialog, whichButton) -> handler.cancel()).setOnDismissListener(dialog -> handler.cancel()).show();
}
#end_block

#method_before
public void showDialog(boolean keyguardShowing, boolean isDeviceProvisioned) {
    mKeyguardShowing = keyguardShowing;
    mDeviceProvisioned = isDeviceProvisioned;
    if (mDialog != null) {
        mDialog.dismiss();
        mDialog = null;
        mDialog = createDialog();
        // Show delayed, so that the dismiss of the previous dialog completes
        mHandler.sendEmptyMessage(MESSAGE_SHOW);
    } else {
        mDialog = createDialog();
        handleShow();
    }
}
#method_after
public void showDialog(boolean keyguardShowing, boolean isDeviceProvisioned) {
    mKeyguardShowing = keyguardShowing;
    mDeviceProvisioned = isDeviceProvisioned;
    mIsRestartMenu = false;
    mCurrentMenuActions = mRootMenuActions;
    if (mDialog != null) {
        mDialog.dismiss();
        mDialog = null;
        mHandler.sendEmptyMessage(MESSAGE_SHOW);
    } else {
        handleShow();
    }
}
#end_block

#method_before
private void handleShow() {
    awakenIfNecessary();
    prepareDialog();
    // If we only have 1 item and it's a simple press action, just do this action.
    if (mAdapter.getCount() == 1 && mAdapter.getItem(0) instanceof SinglePressAction && !(mAdapter.getItem(0) instanceof LongPressAction)) {
        ((SinglePressAction) mAdapter.getItem(0)).onPress();
    } else {
        WindowManager.LayoutParams attrs = mDialog.getWindow().getAttributes();
        attrs.setTitle("ActionsDialog");
        mDialog.getWindow().setAttributes(attrs);
        mDialog.show();
        mWindowManagerFuncs.onGlobalActionsShown();
    }
}
#method_after
private void handleShow() {
    awakenIfNecessary();
    mDialog = createDialog();
    prepareDialog();
    // If we only have 1 item and it's a simple press action, just do this action.
    if (mAdapter.getCount() == 1 && mAdapter.getItem(0) instanceof SinglePressAction && !(mAdapter.getItem(0) instanceof LongPressAction)) {
        ((SinglePressAction) mAdapter.getItem(0)).onPress();
    } else {
        WindowManager.LayoutParams attrs = mDialog.getWindow().getAttributes();
        attrs.setTitle("ActionsDialog");
        mDialog.getWindow().setAttributes(attrs);
        mDialog.show();
        mWindowManagerFuncs.onGlobalActionsShown();
    }
}
#end_block

#method_before
private ActionsDialog createDialog() {
    // Simple toggle style if there's no vibrator, otherwise use a tri-state
    if (!mHasVibrator) {
        mSilentModeAction = new SilentModeToggleAction();
    } else {
        mSilentModeAction = new SilentModeTriStateAction(mContext, mAudioManager, mHandler);
    }
    mAirplaneModeOn = new ToggleAction(R.drawable.ic_lock_airplane_mode, R.drawable.ic_lock_airplane_mode_off, R.string.global_actions_toggle_airplane_mode, R.string.global_actions_airplane_mode_on_status, R.string.global_actions_airplane_mode_off_status) {

        void onToggle(boolean on) {
            if (mHasTelephony && Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) {
                mIsWaitingForEcmExit = true;
                // Launch ECM exit dialog
                Intent ecmDialogIntent = new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null);
                ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                mContext.startActivity(ecmDialogIntent);
            } else {
                changeAirplaneModeSystemSetting(on);
            }
        }

        @Override
        protected void changeStateFromPress(boolean buttonOn) {
            if (!mHasTelephony)
                return;
            // In ECM mode airplane state cannot be changed
            if (!(Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) {
                mState = buttonOn ? State.TurningOn : State.TurningOff;
                mAirplaneState = mState;
            }
        }

        public boolean showDuringKeyguard() {
            return true;
        }

        public boolean showBeforeProvisioning() {
            return false;
        }
    };
    onAirplaneModeChanged();
    mItems = new ArrayList<Action>();
    String[] actionsArray;
    if (mActions == null) {
        actionsArray = mContext.getResources().getStringArray(com.android.internal.R.array.config_globalActionsList);
    } else {
        actionsArray = mActions.split("\\|");
    }
    // Always add the power off option
    mItems.add(new PowerAction());
    ArraySet<String> addedKeys = new ArraySet<String>();
    for (int i = 0; i < actionsArray.length; i++) {
        String actionKey = actionsArray[i];
        if (addedKeys.contains(actionKey)) {
            // If we already have added this, don't add it again.
            continue;
        }
        if (GLOBAL_ACTION_KEY_POWER.equals(actionKey)) {
            continue;
        } else if (GLOBAL_ACTION_KEY_SCREENSHOT.equals(actionKey)) {
            mItems.add(new ScreenshotAction());
        } else if (GLOBAL_ACTION_KEY_AIRPLANE.equals(actionKey)) {
            mItems.add(mAirplaneModeOn);
        } else if (GLOBAL_ACTION_KEY_BUGREPORT.equals(actionKey)) {
            if (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.BUGREPORT_IN_POWER_MENU, 0) != 0 && isCurrentUserOwner()) {
                mItems.add(new BugReportAction());
            }
        } else if (GLOBAL_ACTION_KEY_SILENT.equals(actionKey)) {
            if (mShowSilentToggle) {
                mItems.add(mSilentModeAction);
            }
        } else if (GLOBAL_ACTION_KEY_USERS.equals(actionKey)) {
            List<UserInfo> users = ((UserManager) mContext.getSystemService(Context.USER_SERVICE)).getUsers();
            if (users.size() > 1) {
                addUsersToMenu(mItems);
            }
        } else if (GLOBAL_ACTION_KEY_SETTINGS.equals(actionKey)) {
            mItems.add(getSettingsAction());
        } else if (GLOBAL_ACTION_KEY_LOCKDOWN.equals(actionKey)) {
            mItems.add(getLockdownAction());
        } else if (GLOBAL_ACTION_KEY_VOICEASSIST.equals(actionKey)) {
            mItems.add(getVoiceAssistAction());
        } else if (GLOBAL_ACTION_KEY_ASSIST.equals(actionKey)) {
            mItems.add(getAssistAction());
        } else if (GLOBAL_ACTION_KEY_RESTART.equals(actionKey)) {
            mItems.add(new RestartAction());
        } else {
            Log.e(TAG, "Invalid global action key " + actionKey);
        }
        // Add here so we don't add more than one.
        addedKeys.add(actionKey);
    }
    if (mEmergencyAffordanceManager.needsEmergencyAffordance()) {
        mItems.add(getEmergencyAction());
    }
    mAdapter = new MyAdapter();
    OnItemLongClickListener onItemLongClickListener = new OnItemLongClickListener() {

        @Override
        public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long id) {
            final Action action = mAdapter.getItem(position);
            if (action instanceof LongPressAction) {
                mDialog.dismiss();
                return ((LongPressAction) action).onLongPress();
            }
            return false;
        }
    };
    ActionsDialog dialog = new ActionsDialog(mContext, this, mAdapter, onItemLongClickListener);
    // Handled by the custom class.
    dialog.setCanceledOnTouchOutside(false);
    dialog.setKeyguardShowing(mKeyguardShowing);
    dialog.setOnDismissListener(this);
    return dialog;
}
#method_after
private ActionsDialog createDialog() {
    // Simple toggle style if there's no vibrator, otherwise use a tri-state
    if (!mHasVibrator) {
        mSilentModeAction = new SilentModeToggleAction();
    } else {
        mSilentModeAction = new SilentModeTriStateAction(mContext, mAudioManager, mHandler);
    }
    mAirplaneModeOn = new ToggleAction(com.android.systemui.R.drawable.ic_lock_airplane_mode_enabled, com.android.systemui.R.drawable.ic_lock_airplane_mode_disabled, R.string.global_actions_toggle_airplane_mode, R.string.global_actions_airplane_mode_on_status, R.string.global_actions_airplane_mode_off_status) {

        void onToggle(boolean on) {
            if (mHasTelephony && Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) {
                mIsWaitingForEcmExit = true;
                // Launch ECM exit dialog
                Intent ecmDialogIntent = new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null);
                ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                mContext.startActivity(ecmDialogIntent);
            } else {
                changeAirplaneModeSystemSetting(on);
            }
        }

        @Override
        protected void changeStateFromPress(boolean buttonOn) {
            if (!mHasTelephony)
                return;
            // In ECM mode airplane state cannot be changed
            if (!(Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) {
                mState = buttonOn ? State.TurningOn : State.TurningOff;
                mAirplaneState = mState;
            }
        }

        public boolean showDuringKeyguard() {
            return true;
        }

        public boolean showBeforeProvisioning() {
            return false;
        }
    };
    onAirplaneModeChanged();
    mItems = new ArrayList<Action>();
    // Always add the power off and restart options if we're not in advanced restart submenu
    if (!mIsRestartMenu) {
        mItems.add(new PowerAction());
        mItems.add(new RestartAction());
    }
    ArraySet<String> addedKeys = new ArraySet<String>();
    for (int i = 0; i < mCurrentMenuActions.length; i++) {
        String actionKey = mCurrentMenuActions[i];
        if (addedKeys.contains(actionKey)) {
            // If we already have added this, don't add it again.
            continue;
        }
        if (GLOBAL_ACTION_KEY_POWER.equals(actionKey)) {
            continue;
        } else if (GLOBAL_ACTION_KEY_SCREENSHOT.equals(actionKey)) {
            mItems.add(new ScreenshotAction());
        } else if (GLOBAL_ACTION_KEY_AIRPLANE.equals(actionKey)) {
            mItems.add(mAirplaneModeOn);
        } else if (GLOBAL_ACTION_KEY_BUGREPORT.equals(actionKey)) {
            if (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.BUGREPORT_IN_POWER_MENU, 0) != 0 && isCurrentUserOwner()) {
                mItems.add(new BugReportAction());
            }
        } else if (GLOBAL_ACTION_KEY_SILENT.equals(actionKey)) {
            if (mShowSilentToggle) {
                mItems.add(mSilentModeAction);
            }
        } else if (GLOBAL_ACTION_KEY_USERS.equals(actionKey)) {
            List<UserInfo> users = ((UserManager) mContext.getSystemService(Context.USER_SERVICE)).getUsers();
            if (users.size() > 1) {
                addUsersToMenu(mItems);
            }
        } else if (GLOBAL_ACTION_KEY_SETTINGS.equals(actionKey)) {
            mItems.add(getSettingsAction());
        } else if (GLOBAL_ACTION_KEY_LOCKDOWN.equals(actionKey)) {
            mItems.add(getLockdownAction());
        } else if (GLOBAL_ACTION_KEY_VOICEASSIST.equals(actionKey)) {
            mItems.add(getVoiceAssistAction());
        } else if (GLOBAL_ACTION_KEY_ASSIST.equals(actionKey)) {
            mItems.add(getAssistAction());
        } else if (GLOBAL_ACTION_KEY_RESTART.equals(actionKey)) {
            if (!mIsRestartMenu) {
                continue;
            } else {
                mItems.add(new RestartAction());
            }
        } else if (GLOBAL_ACTION_KEY_RESTART_RECOVERY.equals(actionKey) && PowerMenuUtils.isAdvancedRestartPossible(mContext)) {
            mItems.add(new RestartRecoveryAction());
        } else if (GLOBAL_ACTION_KEY_RESTART_BOOTLOADER.equals(actionKey) && PowerMenuUtils.isAdvancedRestartPossible(mContext)) {
            mItems.add(new RestartBootloaderAction());
        } else if (GLOBAL_ACTION_KEY_RESTART_DOWNLOAD.equals(actionKey) && PowerMenuUtils.isAdvancedRestartPossible(mContext)) {
            mItems.add(new RestartDownloadAction());
        } else {
            Log.e(TAG, "Invalid global action key " + actionKey);
        }
        // Add here so we don't add more than one.
        addedKeys.add(actionKey);
    }
    if (mEmergencyAffordanceManager.needsEmergencyAffordance() && !mIsRestartMenu) {
        mItems.add(getEmergencyAction());
    }
    mAdapter = new MyAdapter();
    OnItemLongClickListener onItemLongClickListener = new OnItemLongClickListener() {

        @Override
        public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long id) {
            final Action action = mAdapter.getItem(position);
            if (action instanceof LongPressAction) {
                mDialog.dismiss();
                return ((LongPressAction) action).onLongPress();
            }
            return false;
        }
    };
    ActionsDialog dialog = new ActionsDialog(mContext, this, mAdapter, onItemLongClickListener);
    // Handled by the custom class.
    dialog.setCanceledOnTouchOutside(false);
    dialog.setKeyguardShowing(mKeyguardShowing);
    dialog.setOnDismissListener(this);
    return dialog;
}
#end_block

#method_before
@Override
public boolean onLongPress() {
    UserManager um = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
    if (!um.hasUserRestriction(UserManager.DISALLOW_SAFE_BOOT)) {
        mWindowManagerFuncs.reboot(true, true);
        return true;
    }
    return false;
}
#method_after
@Override
public boolean onLongPress() {
    UserManager um = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
    if (!um.hasUserRestriction(UserManager.DISALLOW_SAFE_BOOT)) {
        mWindowManagerFuncs.reboot(true, null);
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public boolean onLongPress() {
    UserManager um = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
    if (!um.hasUserRestriction(UserManager.DISALLOW_SAFE_BOOT)) {
        mWindowManagerFuncs.reboot(true, true);
        return true;
    }
    return false;
}
#method_after
@Override
public boolean onLongPress() {
    UserManager um = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
    if (!um.hasUserRestriction(UserManager.DISALLOW_SAFE_BOOT)) {
        mWindowManagerFuncs.reboot(true, null);
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public void onPress() {
    mWindowManagerFuncs.reboot(false, true);
}
#method_after
@Override
public void onPress() {
    if (!mIsRestartMenu && shouldShowRestartSubmenu()) {
        mIsRestartMenu = true;
        mCurrentMenuActions = mRestartMenuActions;
        if (mDialog != null) {
            mDialog.dismiss();
            mDialog = null;
            // Show delayed, so that the dismiss of the previous dialog completes
            mHandler.sendEmptyMessageDelayed(MESSAGE_SHOW, DIALOG_SHOW_DELAY);
        } else {
            handleShow();
        }
    } else {
        mHandler.sendEmptyMessage(MESSAGE_DISMISS);
        if (mIsRestartMenu || !PowerMenuUtils.isAdvancedRestartPossible(mContext)) {
            mWindowManagerFuncs.reboot(false, null);
        }
    }
}
#end_block

#method_before
private Action getSettingsAction() {
    return new SinglePressAction(R.drawable.ic_lock_settings, R.string.global_action_settings) {

        @Override
        public void onPress() {
            Intent intent = new Intent(Settings.ACTION_SETTINGS);
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
            mContext.startActivity(intent);
        }

        @Override
        public boolean showDuringKeyguard() {
            return true;
        }

        @Override
        public boolean showBeforeProvisioning() {
            return true;
        }
    };
}
#method_after
private Action getSettingsAction() {
    return new SinglePressAction(R.drawable.ic_settings, R.string.global_action_settings) {

        @Override
        public void onPress() {
            Intent intent = new Intent(Settings.ACTION_SETTINGS);
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
            mContext.startActivity(intent);
        }

        @Override
        public boolean showDuringKeyguard() {
            return true;
        }

        @Override
        public boolean showBeforeProvisioning() {
            return true;
        }
    };
}
#end_block

#method_before
private void addUsersToMenu(ArrayList<Action> items) {
    UserManager um = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
    if (um.isUserSwitcherEnabled()) {
        List<UserInfo> users = um.getUsers();
        UserInfo currentUser = getCurrentUser();
        final int avatarSize = mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.global_actions_avatar_size);
        for (final UserInfo user : users) {
            if (user.supportsSwitchToByUser()) {
                boolean isCurrentUser = currentUser == null ? user.id == 0 : (currentUser.id == user.id);
                Drawable avatar = null;
                Bitmap rawAvatar = um.getUserIcon(user.id);
                if (rawAvatar == null) {
                    rawAvatar = UserIcons.convertToBitmap(UserIcons.getDefaultUserIcon(user.isGuest() ? UserHandle.USER_NULL : user.id, /*light=*/
                    false));
                }
                avatar = new BitmapDrawable(mContext.getResources(), createCircularClip(rawAvatar, avatarSize, avatarSize));
                SinglePressAction switchToUser = new SinglePressAction(com.android.internal.R.drawable.ic_lock_user, avatar, (user.name != null ? user.name : "Primary")) {

                    public void onPress() {
                        try {
                            ActivityManager.getService().switchUser(user.id);
                        } catch (RemoteException re) {
                            Log.e(TAG, "Couldn't switch user " + re);
                        }
                    }

                    public boolean showDuringKeyguard() {
                        return true;
                    }

                    public boolean showBeforeProvisioning() {
                        return false;
                    }
                };
                if (isCurrentUser) {
                    switchToUser.setStatus(mContext.getString(R.string.global_action_current_user));
                }
                items.add(switchToUser);
            }
        }
    }
}
#method_after
private void addUsersToMenu(ArrayList<Action> items) {
    UserManager um = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
    if (um.isUserSwitcherEnabled()) {
        List<UserInfo> users = um.getUsers();
        UserInfo currentUser = getCurrentUser();
        final int avatarSize = mContext.getResources().getDimensionPixelSize(com.android.systemui.R.dimen.global_actions_avatar_size);
        for (final UserInfo user : users) {
            if (user.supportsSwitchToByUser()) {
                boolean isCurrentUser = currentUser == null ? user.id == 0 : (currentUser.id == user.id);
                Drawable avatar = null;
                Bitmap rawAvatar = um.getUserIcon(user.id);
                if (rawAvatar == null) {
                    rawAvatar = UserIcons.convertToBitmap(UserIcons.getDefaultUserIcon(user.isGuest() ? UserHandle.USER_NULL : user.id, /*light=*/
                    false));
                }
                avatar = new BitmapDrawable(mContext.getResources(), createCircularClip(rawAvatar, avatarSize, avatarSize));
                SinglePressAction switchToUser = new SinglePressAction(com.android.systemui.R.drawable.ic_lock_user, avatar, (user.name != null ? user.name : "Primary")) {

                    public void onPress() {
                        try {
                            ActivityManager.getService().switchUser(user.id);
                        } catch (RemoteException re) {
                            Log.e(TAG, "Couldn't switch user " + re);
                        }
                    }

                    public boolean showDuringKeyguard() {
                        return true;
                    }

                    public boolean showBeforeProvisioning() {
                        return false;
                    }
                };
                if (isCurrentUser) {
                    switchToUser.setStatus(mContext.getString(com.android.systemui.R.string.global_action_current_user));
                }
                items.add(switchToUser);
            }
        }
    }
}
#end_block

#method_before
private void takeScreenshot(final boolean partial) {
    synchronized (mScreenshotLock) {
        if (mScreenshotConnection != null) {
            return;
        }
        ComponentName cn = new ComponentName("com.android.systemui", "com.android.systemui.screenshot.TakeScreenshotService");
        Intent intent = new Intent();
        intent.setComponent(cn);
        ServiceConnection conn = new ServiceConnection() {

            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                synchronized (mScreenshotLock) {
                    if (mScreenshotConnection != this) {
                        return;
                    }
                    Messenger messenger = new Messenger(service);
                    Message msg = Message.obtain(null, 1);
                    msg.what = partial ? WindowManager.TAKE_SCREENSHOT_SELECTED_REGION : WindowManager.TAKE_SCREENSHOT_FULLSCREEN;
                    final ServiceConnection myConn = this;
                    Handler h = new Handler(mHandler.getLooper()) {

                        @Override
                        public void handleMessage(Message msg) {
                            synchronized (mScreenshotLock) {
                                if (mScreenshotConnection == myConn) {
                                    mContext.unbindService(mScreenshotConnection);
                                    mScreenshotConnection = null;
                                    mHandler.removeCallbacks(mScreenshotTimeout);
                                }
                            }
                        }
                    };
                    msg.replyTo = new Messenger(h);
                    msg.arg1 = msg.arg2 = 0;
                    /* wait for the dialog box to close */
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException ie) {
                    // Do nothing
                    }
                    /* take the screenshot */
                    try {
                        messenger.send(msg);
                    } catch (RemoteException e) {
                    // Do nothing
                    }
                }
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
            }
        };
        if (mContext.bindService(intent, conn, Context.BIND_AUTO_CREATE)) {
            mScreenshotConnection = conn;
            mHandler.postDelayed(mScreenshotTimeout, 10000);
        }
    }
}
#method_after
private void takeScreenshot(final boolean partial) {
    synchronized (mScreenshotLock) {
        if (mScreenshotConnection != null) {
            return;
        }
        ComponentName cn = new ComponentName(SYSUI_PACKAGE, SYSUI_SCREENSHOT_SERVICE);
        Intent intent = new Intent();
        intent.setComponent(cn);
        ServiceConnection conn = new ServiceConnection() {

            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                synchronized (mScreenshotLock) {
                    if (mScreenshotConnection != this) {
                        return;
                    }
                    Messenger messenger = new Messenger(service);
                    Message msg = Message.obtain(null, 1);
                    msg.what = partial ? WindowManager.TAKE_SCREENSHOT_SELECTED_REGION : WindowManager.TAKE_SCREENSHOT_FULLSCREEN;
                    final ServiceConnection myConn = this;
                    Handler h = new Handler(mHandler.getLooper()) {

                        @Override
                        public void handleMessage(Message msg) {
                            synchronized (mScreenshotLock) {
                                if (mScreenshotConnection == myConn) {
                                    mContext.unbindService(mScreenshotConnection);
                                    mScreenshotConnection = null;
                                    mHandler.removeCallbacks(mScreenshotTimeout);
                                }
                            }
                        }
                    };
                    msg.replyTo = new Messenger(h);
                    msg.arg1 = msg.arg2 = 0;
                    /* wait for the dialog box to close and take screenshot */
                    h.postDelayed(new Runnable() {

                        @Override
                        public void run() {
                            try {
                                messenger.send(msg);
                            } catch (RemoteException e) {
                            // Do nothing
                            }
                        }
                    }, 1000);
                }
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
            }
        };
        if (mContext.bindServiceAsUser(intent, conn, Context.BIND_AUTO_CREATE, UserHandle.CURRENT)) {
            mScreenshotConnection = conn;
            mHandler.postDelayed(mScreenshotTimeout, 10000);
        }
    }
}
#end_block

#method_before
public View getView(int position, View convertView, ViewGroup parent) {
    Action action = getItem(position);
    View view = action.create(mContext, convertView, parent, LayoutInflater.from(mContext));
    if (position == 2) {
        HardwareUiLayout.get(parent).setDivisionView(view);
    }
    return view;
}
#method_after
public View getView(int position, View convertView, ViewGroup parent) {
    Action action = getItem(position);
    View view = action.create(mContext, convertView, parent, LayoutInflater.from(mContext));
    if (position == 2 && !mIsRestartMenu) {
        HardwareUiLayout.get(parent).setDivisionView(view);
    }
    return view;
}
#end_block

#method_before
public View create(Context context, View convertView, ViewGroup parent, LayoutInflater inflater) {
    willCreate();
    View v = inflater.inflate(R.layout.global_actions_item, parent, false);
    ImageView icon = (ImageView) v.findViewById(R.id.icon);
    TextView messageView = (TextView) v.findViewById(R.id.message);
    TextView statusView = (TextView) v.findViewById(R.id.status);
    final boolean enabled = isEnabled();
    if (messageView != null) {
        messageView.setText(mMessageResId);
        messageView.setEnabled(enabled);
    }
    boolean on = ((mState == State.On) || (mState == State.TurningOn));
    if (icon != null) {
        icon.setImageDrawable(context.getDrawable((on ? mEnabledIconResId : mDisabledIconResid)));
        icon.setEnabled(enabled);
    }
    if (statusView != null) {
        statusView.setText(on ? mEnabledStatusMessageResId : mDisabledStatusMessageResId);
        statusView.setVisibility(View.VISIBLE);
        statusView.setEnabled(enabled);
    }
    v.setEnabled(enabled);
    return v;
}
#method_after
public View create(Context context, View convertView, ViewGroup parent, LayoutInflater inflater) {
    willCreate();
    View v = inflater.inflate(com.android.systemui.R.layout.global_actions_item, parent, false);
    ImageView icon = (ImageView) v.findViewById(R.id.icon);
    TextView messageView = (TextView) v.findViewById(R.id.message);
    TextView statusView = (TextView) v.findViewById(R.id.status);
    final boolean enabled = isEnabled();
    if (messageView != null) {
        messageView.setText(mMessageResId);
        messageView.setEnabled(enabled);
    }
    boolean on = ((mState == State.On) || (mState == State.TurningOn));
    if (icon != null) {
        icon.setImageDrawable(context.getDrawable((on ? mEnabledIconResId : mDisabledIconResid)));
        icon.setEnabled(enabled);
    }
    if (statusView != null) {
        statusView.setVisibility(View.GONE);
    }
    v.setEnabled(enabled);
    return v;
}
#end_block

#method_before
protected void updatePowerMenuActions() {
    ContentResolver resolver = mContext.getContentResolver();
    mActions = LineageSettings.Secure.getStringForUser(resolver, LineageSettings.Secure.POWER_MENU_ACTIONS, UserHandle.USER_CURRENT);
}
#method_after
protected void updatePowerMenuActions() {
    ContentResolver resolver = mContext.getContentResolver();
    final String powerMenuActions = LineageSettings.Secure.getStringForUser(resolver, LineageSettings.Secure.POWER_MENU_ACTIONS, UserHandle.USER_CURRENT);
    if (powerMenuActions != null) {
        mRootMenuActions = powerMenuActions.split("\\|");
    } else {
        mRootMenuActions = mDefaultMenuActions;
    }
}
#end_block

#method_before
public static void shutdown(final Context context, String reason, boolean confirm) {
    mReboot = false;
    mRebootSafeMode = false;
    mReason = reason;
    shutdownInner(context, confirm);
}
#method_after
public static void shutdown(final Context context, String reason, boolean confirm) {
    mReboot = false;
    mRebootSafeMode = false;
    mReason = reason;
    mRebootCustom = false;
    shutdownInner(context, confirm);
}
#end_block

#method_before
private static void shutdownInner(final Context context, boolean confirm) {
    // ShutdownThread is called from many places, so best to verify here that the context passed
    // in is themed.
    context.assertRuntimeOverlayThemable();
    // any additional calls are just returned
    synchronized (sIsStartedGuard) {
        if (sIsStarted) {
            Log.d(TAG, "Request to shutdown already running, returning.");
            return;
        }
    }
    boolean showRebootOption = false;
    String[] actionsArray;
    String actions = LineageSettings.Secure.getStringForUser(context.getContentResolver(), LineageSettings.Secure.POWER_MENU_ACTIONS, UserHandle.USER_CURRENT);
    if (actions == null) {
        actionsArray = context.getResources().getStringArray(com.android.internal.R.array.config_globalActionsList);
    } else {
        actionsArray = actions.split("\\|");
    }
    for (int i = 0; i < actionsArray.length; i++) {
        if (actionsArray[i].equals("restart")) {
            showRebootOption = true;
            break;
        }
    }
    final int longPressBehavior = context.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    int resourceId = mRebootSafeMode ? com.android.internal.R.string.reboot_safemode_confirm : (longPressBehavior == 2 ? com.android.internal.R.string.shutdown_confirm_question : com.android.internal.R.string.shutdown_confirm);
    if (showRebootOption && !mRebootSafeMode) {
        resourceId = com.android.internal.R.string.reboot_confirm;
    }
    Log.d(TAG, "Notifying thread to start shutdown longPressBehavior=" + longPressBehavior);
    if (confirm) {
        final CloseDialogReceiver closer = new CloseDialogReceiver(context);
        final boolean advancedReboot = RebootUtils.isAdvancedRebootPossible(context);
        if (sConfirmDialog != null) {
            sConfirmDialog.dismiss();
            sConfirmDialog = null;
        }
        AlertDialog.Builder confirmDialogBuilder = new AlertDialog.Builder(context).setTitle(mRebootSafeMode ? com.android.internal.R.string.reboot_safemode_title : showRebootOption ? com.android.internal.R.string.reboot_title : com.android.internal.R.string.power_off);
        if (!advancedReboot || mRebootSafeMode) {
            confirmDialogBuilder.setMessage(resourceId);
        } else {
            confirmDialogBuilder.setSingleChoiceItems(com.android.internal.R.array.shutdown_reboot_options, 0, null);
        }
        confirmDialogBuilder.setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                if (!mRebootSafeMode && advancedReboot) {
                    boolean softReboot = false;
                    ListView reasonsList = ((AlertDialog) dialog).getListView();
                    int selected = reasonsList.getCheckedItemPosition();
                    if (selected != ListView.INVALID_POSITION) {
                        String[] actions = context.getResources().getStringArray(com.android.internal.R.array.shutdown_reboot_actions);
                        if (selected >= 0 && selected < actions.length) {
                            mReason = actions[selected];
                            if (mReason.equals("soft_reboot")) {
                                doSoftReboot();
                                return;
                            }
                        }
                    }
                    mReboot = true;
                }
                beginShutdownSequence(context);
            }
        });
        confirmDialogBuilder.setNegativeButton(com.android.internal.R.string.no, null);
        sConfirmDialog = confirmDialogBuilder.create();
        closer.dialog = sConfirmDialog;
        sConfirmDialog.setOnDismissListener(closer);
        sConfirmDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
        sConfirmDialog.show();
    } else {
        beginShutdownSequence(context);
    }
}
#method_after
private static void shutdownInner(final Context context, boolean confirm) {
    // ShutdownThread is called from many places, so best to verify here that the context passed
    // in is themed.
    context.assertRuntimeOverlayThemable();
    // any additional calls are just returned
    synchronized (sIsStartedGuard) {
        if (sIsStarted) {
            Log.d(TAG, "Request to shutdown already running, returning.");
            return;
        }
    }
    final int longPressBehavior = context.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    final int resourceId = mRebootSafeMode ? com.android.internal.R.string.reboot_safemode_confirm : (longPressBehavior == 2 ? com.android.internal.R.string.shutdown_confirm_question : com.android.internal.R.string.shutdown_confirm);
    Log.d(TAG, "Notifying thread to start shutdown longPressBehavior=" + longPressBehavior);
    if (confirm) {
        final CloseDialogReceiver closer = new CloseDialogReceiver(context);
        if (sConfirmDialog != null) {
            sConfirmDialog.dismiss();
        }
        sConfirmDialog = new AlertDialog.Builder(context).setTitle(mRebootSafeMode ? com.android.internal.R.string.reboot_safemode_title : com.android.internal.R.string.power_off).setMessage(resourceId).setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() {

            public void onClick(DialogInterface dialog, int which) {
                beginShutdownSequence(context);
            }
        }).setNegativeButton(com.android.internal.R.string.no, null).create();
        closer.dialog = sConfirmDialog;
        sConfirmDialog.setOnDismissListener(closer);
        sConfirmDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
        sConfirmDialog.show();
    } else {
        beginShutdownSequence(context);
    }
}
#end_block

#method_before
public static void reboot(final Context context, String reason, boolean confirm) {
    mReboot = true;
    mRebootSafeMode = false;
    mRebootHasProgressBar = false;
    mReason = reason;
    shutdownInner(context, confirm);
}
#method_after
public static void reboot(final Context context, String reason, boolean confirm) {
    mReboot = true;
    mRebootSafeMode = false;
    mRebootHasProgressBar = false;
    mReason = reason;
    mRebootCustom = false;
    shutdownInner(context, confirm);
}
#end_block

#method_before
public static void rebootSafeMode(final Context context, boolean confirm) {
    UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);
    if (um.hasUserRestriction(UserManager.DISALLOW_SAFE_BOOT)) {
        return;
    }
    mReboot = true;
    mRebootSafeMode = true;
    mRebootHasProgressBar = false;
    mReason = null;
    shutdownInner(context, confirm);
}
#method_after
public static void rebootSafeMode(final Context context, boolean confirm) {
    UserManager um = (UserManager) context.getSystemService(Context.USER_SERVICE);
    if (um.hasUserRestriction(UserManager.DISALLOW_SAFE_BOOT)) {
        return;
    }
    mReboot = true;
    mRebootSafeMode = true;
    mRebootHasProgressBar = false;
    mReason = null;
    mRebootCustom = false;
    shutdownInner(context, confirm);
}
#end_block

#method_before
private static ProgressDialog showShutdownDialog(Context context) {
    // Throw up a system dialog to indicate the device is rebooting / shutting down.
    ProgressDialog pd = new ProgressDialog(context);
    // mReason could be "recovery-update" or "recovery-update,quiescent".
    if (mReason != null && mReason.startsWith(PowerManager.REBOOT_RECOVERY_UPDATE)) {
        if (RECOVERY_COMMAND_FILE.exists()) {
            try {
                mRebootWipe = new String(FileUtils.readTextFile(RECOVERY_COMMAND_FILE, 0, null)).contains("wipe");
            } catch (IOException e) {
            }
        }
        // We need the progress bar if uncrypt will be invoked during the
        // reboot, which might be time-consuming.
        mRebootHasProgressBar = RecoverySystem.UNCRYPT_PACKAGE_FILE.exists() && !(RecoverySystem.BLOCK_MAP_FILE.exists());
        pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_update_title));
        if (mRebootHasProgressBar) {
            pd.setMax(100);
            pd.setProgress(0);
            pd.setIndeterminate(false);
            pd.setProgressNumberFormat(null);
            pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
            pd.setMessage(context.getText(com.android.internal.R.string.reboot_to_update_prepare));
        } else {
            if (showSysuiReboot()) {
                return null;
            }
            pd.setIndeterminate(true);
            pd.setMessage(context.getText(com.android.internal.R.string.reboot_to_update_reboot));
        }
    } else if (mReason != null && mReason.equals(PowerManager.REBOOT_RECOVERY) && mRebootWipe) {
        if (RescueParty.isAttemptingFactoryReset()) {
            // scary dialog message.
            if (mReboot) {
                pd.setTitle(context.getText(com.android.internal.R.string.reboot_title));
                pd.setMessage(context.getText(com.android.internal.R.string.reboot_progress));
            } else {
                pd.setTitle(context.getText(com.android.internal.R.string.power_off));
                pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
            }
            pd.setIndeterminate(true);
        } else {
            // Factory reset path. Set the dialog message accordingly.
            pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_reset_title));
            pd.setMessage(context.getText(com.android.internal.R.string.reboot_to_reset_message));
            pd.setIndeterminate(true);
        }
    } else {
        if (showSysuiReboot()) {
            return null;
        }
        if (mReboot) {
            pd.setTitle(context.getText(com.android.internal.R.string.reboot_title));
            pd.setMessage(context.getText(com.android.internal.R.string.reboot_progress));
        } else {
            pd.setTitle(context.getText(com.android.internal.R.string.power_off));
            pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
        }
        pd.setIndeterminate(true);
    }
    pd.setCancelable(false);
    pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    pd.show();
    return pd;
}
#method_after
private static ProgressDialog showShutdownDialog(Context context) {
    // Throw up a system dialog to indicate the device is rebooting / shutting down.
    ProgressDialog pd = new ProgressDialog(context);
    // mReason could be "recovery-update" or "recovery-update,quiescent".
    if (mReason != null && mReason.startsWith(PowerManager.REBOOT_RECOVERY_UPDATE)) {
        // We need the progress bar if uncrypt will be invoked during the
        // reboot, which might be time-consuming.
        mRebootHasProgressBar = RecoverySystem.UNCRYPT_PACKAGE_FILE.exists() && !(RecoverySystem.BLOCK_MAP_FILE.exists());
        pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_update_title));
        if (mRebootHasProgressBar) {
            pd.setMax(100);
            pd.setProgress(0);
            pd.setIndeterminate(false);
            pd.setProgressNumberFormat(null);
            pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
            pd.setMessage(context.getText(com.android.internal.R.string.reboot_to_update_prepare));
        } else {
            if (showSysuiReboot()) {
                return null;
            }
            pd.setIndeterminate(true);
            pd.setMessage(context.getText(com.android.internal.R.string.reboot_to_update_reboot));
        }
    } else if (mReason != null && mReason.equals(PowerManager.REBOOT_RECOVERY)) {
        if (mRebootCustom && showSysuiReboot()) {
            return null;
        }
        if (RescueParty.isAttemptingFactoryReset()) {
            // We're not actually doing a factory reset yet; we're rebooting
            // to ask the user if they'd like to reset, so give them a less
            // scary dialog message.
            pd.setTitle(context.getText(com.android.internal.R.string.power_off));
            pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
            pd.setIndeterminate(true);
        } else {
            // Factory reset path. Set the dialog message accordingly.
            pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_reset_title));
            pd.setMessage(context.getText(com.android.internal.R.string.reboot_to_reset_message));
            pd.setIndeterminate(true);
        }
    } else {
        if (showSysuiReboot()) {
            return null;
        }
        pd.setTitle(context.getText(com.android.internal.R.string.power_off));
        pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
        pd.setIndeterminate(true);
    }
    pd.setCancelable(false);
    pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    pd.show();
    return pd;
}
#end_block

#method_before
private static boolean showSysuiReboot() {
    Log.d(TAG, "Attempting to use SysUI shutdown UI");
    try {
        StatusBarManagerInternal service = LocalServices.getService(StatusBarManagerInternal.class);
        if (service.showShutdownUi(mReboot, mReason)) {
            // Sysui will handle shutdown UI.
            Log.d(TAG, "SysUI handling shutdown UI");
            return true;
        }
    } catch (Exception e) {
    // If anything went wrong, ignore it and use fallback ui
    }
    Log.d(TAG, "SysUI is unavailable");
    return false;
}
#method_after
private static boolean showSysuiReboot() {
    Log.d(TAG, "Attempting to use SysUI shutdown UI");
    try {
        StatusBarManagerInternal service = LocalServices.getService(StatusBarManagerInternal.class);
        if (service.showShutdownUi(mReboot, mReason, mRebootCustom)) {
            // Sysui will handle shutdown UI.
            Log.d(TAG, "SysUI handling shutdown UI");
            return true;
        }
    } catch (Exception e) {
    // If anything went wrong, ignore it and use fallback ui
    }
    Log.d(TAG, "SysUI is unavailable");
    return false;
}
#end_block

#method_before
public static boolean isSupported() {
    /*
         * this needed because there is no setActive(false) on boot, it will be
         * disabled in case navbar enabled (setActive(true))
         */
    Fingerprint.enableNav(true);
    return true;
}
#method_after
public static boolean isSupported() {
    return true;
}
#end_block

#method_before
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    int mDeviceHardwareWakeKeys = mContext.getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareWakeKeys);
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mRingHomeBehavior = CMSettings.Secure.getIntForUser(resolver, CMSettings.Secure.RING_HOME_BUTTON_BEHAVIOR, CMSettings.Secure.RING_HOME_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mTorchLongPressPowerEnabled = CMSettings.System.getIntForUser(resolver, CMSettings.System.TORCH_LONG_PRESS_POWER_GESTURE, 0, UserHandle.USER_CURRENT) == 1;
        mTorchTimeout = CMSettings.System.getIntForUser(resolver, CMSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT, 0, UserHandle.USER_CURRENT);
        mHomeWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.HOME_WAKE_SCREEN, 1, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_HOME) != 0);
        mBackWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.BACK_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_BACK) != 0);
        mMenuWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.MENU_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_MENU) != 0);
        mAssistWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.ASSIST_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_ASSIST) != 0);
        mAppSwitchWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.APP_SWITCH_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_APP_SWITCH) != 0);
        mCameraWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.CAMERA_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_CAMERA) != 0);
        mCameraSleepOnRelease = (CMSettings.System.getIntForUser(resolver, CMSettings.System.CAMERA_SLEEP_ON_RELEASE, 0, UserHandle.USER_CURRENT) == 1);
        mCameraLaunch = (CMSettings.System.getIntForUser(resolver, CMSettings.System.CAMERA_LAUNCH, 0, UserHandle.USER_CURRENT) == 1);
        mVolumeWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.VOLUME_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_VOLUME) != 0);
        mVolBtnMusicControls = (CMSettings.System.getIntForUser(resolver, CMSettings.System.VOLBTN_MUSIC_CONTROLS, 1, UserHandle.USER_CURRENT) == 1);
        mVolumeAnswerCall = CMSettings.System.getIntForUser(resolver, CMSettings.System.VOLUME_ANSWER_CALL, 0, UserHandle.USER_CURRENT) == 1;
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        int devForceNavbar = CMSettings.Global.getIntForUser(resolver, CMSettings.Global.DEV_FORCE_SHOW_NAVBAR, 0, UserHandle.USER_CURRENT);
        if (devForceNavbar != mDevForceNavbar) {
            mDevForceNavbar = devForceNavbar;
            if (mCMHardware.isSupported(CMHardwareManager.FEATURE_KEY_DISABLE)) {
                mCMHardware.set(CMHardwareManager.FEATURE_KEY_DISABLE, mDevForceNavbar == 1 ? true : false);
            }
        }
        mNavigationBarLeftInLandscape = CMSettings.System.getIntForUser(resolver, CMSettings.System.NAVBAR_LEFT_IN_LANDSCAPE, 0, UserHandle.USER_CURRENT) == 1;
        updateKeyAssignments();
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mUserRotationAngles = Settings.System.getInt(resolver, Settings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        WindowManagerPolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#method_after
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    int mDeviceHardwareWakeKeys = mContext.getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareWakeKeys);
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mRingHomeBehavior = CMSettings.Secure.getIntForUser(resolver, CMSettings.Secure.RING_HOME_BUTTON_BEHAVIOR, CMSettings.Secure.RING_HOME_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mTorchLongPressPowerEnabled = CMSettings.System.getIntForUser(resolver, CMSettings.System.TORCH_LONG_PRESS_POWER_GESTURE, 0, UserHandle.USER_CURRENT) == 1;
        mTorchTimeout = CMSettings.System.getIntForUser(resolver, CMSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT, 0, UserHandle.USER_CURRENT);
        mHomeWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.HOME_WAKE_SCREEN, 1, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_HOME) != 0);
        mBackWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.BACK_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_BACK) != 0);
        mMenuWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.MENU_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_MENU) != 0);
        mAssistWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.ASSIST_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_ASSIST) != 0);
        mAppSwitchWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.APP_SWITCH_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_APP_SWITCH) != 0);
        mCameraWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.CAMERA_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_CAMERA) != 0);
        mCameraSleepOnRelease = (CMSettings.System.getIntForUser(resolver, CMSettings.System.CAMERA_SLEEP_ON_RELEASE, 0, UserHandle.USER_CURRENT) == 1);
        mCameraLaunch = (CMSettings.System.getIntForUser(resolver, CMSettings.System.CAMERA_LAUNCH, 0, UserHandle.USER_CURRENT) == 1);
        mVolumeWakeScreen = (CMSettings.System.getIntForUser(resolver, CMSettings.System.VOLUME_WAKE_SCREEN, 0, UserHandle.USER_CURRENT) == 1) && ((mDeviceHardwareWakeKeys & KEY_MASK_VOLUME) != 0);
        mVolBtnMusicControls = (CMSettings.System.getIntForUser(resolver, CMSettings.System.VOLBTN_MUSIC_CONTROLS, 1, UserHandle.USER_CURRENT) == 1);
        mVolumeAnswerCall = CMSettings.System.getIntForUser(resolver, CMSettings.System.VOLUME_ANSWER_CALL, 0, UserHandle.USER_CURRENT) == 1;
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        int devForceNavbar = CMSettings.Global.getIntForUser(resolver, CMSettings.Global.DEV_FORCE_SHOW_NAVBAR, 0, UserHandle.USER_CURRENT);
        if (devForceNavbar != mDevForceNavbar) {
            mDevForceNavbar = devForceNavbar;
            if (mCMHardware.isSupported(CMHardwareManager.FEATURE_KEY_DISABLE)) {
                mCMHardware.set(CMHardwareManager.FEATURE_KEY_DISABLE, mDevForceNavbar == 1);
            }
        }
        mNavigationBarLeftInLandscape = CMSettings.System.getIntForUser(resolver, CMSettings.System.NAVBAR_LEFT_IN_LANDSCAPE, 0, UserHandle.USER_CURRENT) == 1;
        updateKeyAssignments();
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mUserRotationAngles = Settings.System.getInt(resolver, Settings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        WindowManagerPolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#end_block

#method_before
private void update() {
    ContentResolver resolver = mContext.getContentResolver();
    Resources res = mContext.getResources();
    mVolBtnMusicControls = LineageSettings.System.getInt(resolver, LineageSettings.System.VOLBTN_MUSIC_CONTROLS, 0) != 0;
    if (DEBUG) {
        Slog.d(TAG, "music controls enabled = " + mVolBtnMusicControls);
    }
}
#method_after
private void update() {
    ContentResolver resolver = mContext.getContentResolver();
    Resources res = mContext.getResources();
    mVolBtnMusicControls = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.VOLBTN_MUSIC_CONTROLS, 1, UserHandle.USER_CURRENT) == 1;
    if (DEBUG) {
        Slog.d(TAG, "music controls enabled = " + mVolBtnMusicControls);
    }
}
#end_block

#method_before
private void launchCameraAction() {
    sendCloseSystemWindows();
    Intent intent = new Intent(Intent.ACTION_CAMERA_BUTTON, null);
    mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT_OR_SELF, null, null, null, 0, null, null);
}
#method_after
private void launchCameraAction() {
    sendCloseSystemWindows();
    Intent intent = new Intent(lineageos.content.Intent.ACTION_SCREEN_CAMERA_GESTURE);
    mContext.sendBroadcast(intent, android.Manifest.permission.STATUS_BAR_SERVICE);
}
#end_block

#method_before
private void launchCameraAction() {
    sendCloseSystemWindows();
    Intent intent = new Intent(Intent.ACTION_CAMERA_BUTTON, null);
    mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT_OR_SELF, null, null, null, 0, null, null);
}
#method_after
private void launchCameraAction() {
    sendCloseSystemWindows();
    Intent intent = new Intent(lineageos.content.Intent.ACTION_SCREEN_CAMERA_GESTURE);
    mContext.sendBroadcast(intent, android.Manifest.permission.STATUS_BAR_SERVICE);
}
#end_block

#method_before
private void performKeyAction(Action action, KeyEvent event) {
    switch(action) {
        case NOTHING:
            break;
        case MENU:
            triggerVirtualKeypress(KeyEvent.KEYCODE_MENU);
            break;
        case APP_SWITCH:
            toggleRecentApps();
            break;
        case SEARCH:
            launchAssistAction(null, event.getDeviceId());
            break;
        case VOICE_SEARCH:
            launchAssistLongPressAction();
            break;
        case IN_APP_SEARCH:
            triggerVirtualKeypress(KeyEvent.KEYCODE_SEARCH);
            break;
        case LAUNCH_CAMERA:
            launchCameraAction();
            break;
        case SLEEP:
            mPowerManager.goToSleep(SystemClock.uptimeMillis());
            break;
        case SPLIT_SCREEN:
            toggleSplitScreen();
            break;
        default:
            break;
    }
}
#method_after
private void performKeyAction(Action action, KeyEvent event) {
    switch(action) {
        case NOTHING:
            break;
        case MENU:
            triggerVirtualKeypress(KeyEvent.KEYCODE_MENU);
            break;
        case APP_SWITCH:
            toggleRecentApps();
            break;
        case SEARCH:
            launchAssistAction(null, event.getDeviceId());
            break;
        case VOICE_SEARCH:
            launchAssistLongPressAction();
            break;
        case IN_APP_SEARCH:
            triggerVirtualKeypress(KeyEvent.KEYCODE_SEARCH);
            break;
        case LAUNCH_CAMERA:
            launchCameraAction();
            break;
        case SLEEP:
            mPowerManager.goToSleep(SystemClock.uptimeMillis());
            break;
        case LAST_APP:
            ActionUtils.switchToLastApp(mContext, mCurrentUserId);
            break;
        case SPLIT_SCREEN:
            toggleSplitScreen();
            break;
        default:
            break;
    }
}
#end_block

#method_before
private void updateKeyAssignments() {
    int activeHardwareKeys = mDeviceHardwareKeys;
    if (mDevForceNavbar) {
        activeHardwareKeys = 0;
    }
    final boolean hasMenu = (activeHardwareKeys & KEY_MASK_MENU) != 0;
    final boolean hasAssist = (activeHardwareKeys & KEY_MASK_ASSIST) != 0;
    final boolean hasAppSwitch = (activeHardwareKeys & KEY_MASK_APP_SWITCH) != 0;
    final ContentResolver resolver = mContext.getContentResolver();
    final Resources res = mContext.getResources();
    // Initialize all assignments to sane defaults.
    mMenuPressAction = Action.MENU;
    mMenuLongPressAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_longPressOnMenuBehavior));
    if (mMenuLongPressAction == Action.NOTHING && (hasMenu && !hasAssist)) {
        mMenuLongPressAction = Action.SEARCH;
    }
    mAssistPressAction = Action.SEARCH;
    mAssistLongPressAction = Action.VOICE_SEARCH;
    mAppSwitchPressAction = Action.APP_SWITCH;
    mAppSwitchLongPressAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_longPressOnAppSwitchBehavior));
    mHomeLongPressAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_longPressOnHomeBehavior));
    if (mHomeLongPressAction.ordinal() < Action.NOTHING.ordinal() || mHomeLongPressAction.ordinal() > Action.SLEEP.ordinal()) {
        mHomeLongPressAction = Action.NOTHING;
    }
    mHomeDoubleTapAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_doubleTapOnHomeBehavior));
    if (mHomeDoubleTapAction.ordinal() < Action.NOTHING.ordinal() || mHomeDoubleTapAction.ordinal() > Action.SLEEP.ordinal()) {
        mHomeDoubleTapAction = Action.NOTHING;
    }
    mHomeLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_HOME_LONG_PRESS_ACTION, mHomeLongPressAction);
    mHomeDoubleTapAction = Action.fromSettings(resolver, LineageSettings.System.KEY_HOME_DOUBLE_TAP_ACTION, mHomeDoubleTapAction);
    if (hasMenu) {
        mMenuPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_MENU_ACTION, mMenuPressAction);
        mMenuLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_MENU_LONG_PRESS_ACTION, mMenuLongPressAction);
    }
    if (hasAssist) {
        mAssistPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_ASSIST_ACTION, mAssistPressAction);
        mAssistLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_ASSIST_LONG_PRESS_ACTION, mAssistLongPressAction);
    }
    if (hasAppSwitch) {
        mAppSwitchPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_APP_SWITCH_ACTION, mAppSwitchPressAction);
        mAppSwitchLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION, mAppSwitchLongPressAction);
    }
    mShortPressWindowBehavior = SHORT_PRESS_WINDOW_NOTHING;
    if (mContext.getPackageManager().hasSystemFeature(FEATURE_PICTURE_IN_PICTURE)) {
        mShortPressWindowBehavior = SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE;
    }
    mNavBarOpacityMode = res.getInteger(com.android.internal.R.integer.config_navBarOpacityMode);
}
#method_after
private void updateKeyAssignments() {
    int activeHardwareKeys = mDeviceHardwareKeys;
    if (mDevForceNavbar) {
        activeHardwareKeys = 0;
    }
    final boolean hasMenu = (activeHardwareKeys & KEY_MASK_MENU) != 0;
    final boolean hasAssist = (activeHardwareKeys & KEY_MASK_ASSIST) != 0;
    final boolean hasAppSwitch = (activeHardwareKeys & KEY_MASK_APP_SWITCH) != 0;
    final ContentResolver resolver = mContext.getContentResolver();
    final Resources res = mContext.getResources();
    // Initialize all assignments to sane defaults.
    mMenuPressAction = Action.MENU;
    mMenuLongPressAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_longPressOnMenuBehavior));
    if (mMenuLongPressAction == Action.NOTHING && (hasMenu && !hasAssist)) {
        mMenuLongPressAction = Action.SEARCH;
    }
    mAssistPressAction = Action.SEARCH;
    mAssistLongPressAction = Action.VOICE_SEARCH;
    mAppSwitchPressAction = Action.APP_SWITCH;
    mAppSwitchLongPressAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_longPressOnAppSwitchBehavior));
    mHomeLongPressAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_longPressOnHomeBehavior));
    if (mHomeLongPressAction.ordinal() > Action.SLEEP.ordinal()) {
        mHomeLongPressAction = Action.NOTHING;
    }
    mHomeDoubleTapAction = Action.fromIntSafe(res.getInteger(org.lineageos.platform.internal.R.integer.config_doubleTapOnHomeBehavior));
    if (mHomeDoubleTapAction.ordinal() > Action.SLEEP.ordinal()) {
        mHomeDoubleTapAction = Action.NOTHING;
    }
    mHomeLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_HOME_LONG_PRESS_ACTION, mHomeLongPressAction);
    mHomeDoubleTapAction = Action.fromSettings(resolver, LineageSettings.System.KEY_HOME_DOUBLE_TAP_ACTION, mHomeDoubleTapAction);
    if (hasMenu) {
        mMenuPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_MENU_ACTION, mMenuPressAction);
        mMenuLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_MENU_LONG_PRESS_ACTION, mMenuLongPressAction);
    }
    if (hasAssist) {
        mAssistPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_ASSIST_ACTION, mAssistPressAction);
        mAssistLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_ASSIST_LONG_PRESS_ACTION, mAssistLongPressAction);
    }
    if (hasAppSwitch) {
        mAppSwitchPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_APP_SWITCH_ACTION, mAppSwitchPressAction);
        mAppSwitchLongPressAction = Action.fromSettings(resolver, LineageSettings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION, mAppSwitchLongPressAction);
    }
    mShortPressWindowBehavior = SHORT_PRESS_WINDOW_NOTHING;
    if (mContext.getPackageManager().hasSystemFeature(FEATURE_PICTURE_IN_PICTURE)) {
        mShortPressWindowBehavior = SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE;
    }
    mNavBarOpacityMode = res.getInteger(com.android.internal.R.integer.config_navBarOpacityMode);
}
#end_block

#method_before
private void launchCameraAction() {
    sendCloseSystemWindows();
    Intent intent = new Intent(Intent.ACTION_CAMERA_BUTTON, null);
    mContext.sendOrderedBroadcastAsUser(intent, UserHandle.CURRENT_OR_SELF, null, null, null, 0, null, null);
}
#method_after
private void launchCameraAction() {
    sendCloseSystemWindows();
    Intent intent = new Intent(lineageos.content.Intent.ACTION_SCREEN_CAMERA_GESTURE);
    mContext.sendBroadcast(intent, android.Manifest.permission.STATUS_BAR_SERVICE);
}
#end_block

#method_before
private void performKeyAction(Action action, KeyEvent event) {
    switch(action) {
        case NOTHING:
            break;
        case MENU:
            triggerVirtualKeypress(KeyEvent.KEYCODE_MENU);
            break;
        case APP_SWITCH:
            toggleRecentApps();
            break;
        case SEARCH:
            launchAssistAction(null, event.getDeviceId());
            break;
        case VOICE_SEARCH:
            launchAssistLongPressAction();
            break;
        case IN_APP_SEARCH:
            triggerVirtualKeypress(KeyEvent.KEYCODE_SEARCH);
            break;
        case LAUNCH_CAMERA:
            launchCameraAction();
            break;
        case SLEEP:
            mPowerManager.goToSleep(SystemClock.uptimeMillis());
            break;
        case SPLIT_SCREEN:
            toggleSplitScreen();
            break;
        default:
            break;
    }
}
#method_after
private void performKeyAction(Action action, KeyEvent event) {
    switch(action) {
        case NOTHING:
            break;
        case MENU:
            triggerVirtualKeypress(KeyEvent.KEYCODE_MENU);
            break;
        case APP_SWITCH:
            toggleRecentApps();
            break;
        case SEARCH:
            launchAssistAction(null, event.getDeviceId());
            break;
        case VOICE_SEARCH:
            launchAssistLongPressAction();
            break;
        case IN_APP_SEARCH:
            triggerVirtualKeypress(KeyEvent.KEYCODE_SEARCH);
            break;
        case LAUNCH_CAMERA:
            launchCameraAction();
            break;
        case SLEEP:
            mPowerManager.goToSleep(SystemClock.uptimeMillis());
            break;
        case LAST_APP:
            ActionUtils.switchToLastApp(mContext, mCurrentUserId);
            break;
        case SPLIT_SCREEN:
            toggleSplitScreen();
            break;
        default:
            break;
    }
}
#end_block

#method_before
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.TORCH_LONG_PRESS_POWER_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#method_after
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.Global.getUriFor(LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.TORCH_LONG_PRESS_POWER_GESTURE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(LineageSettings.System.getUriFor(LineageSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#end_block

#method_before
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    mHasFeatureLeanback = mContext.getPackageManager().hasSystemFeature(FEATURE_LEANBACK);
    mAccessibilityShortcutController = new AccessibilityShortcutController(mContext, new Handler(), mCurrentUserId);
    mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mCameraManager = (CameraManager) mContext.getSystemService(Context.CAMERA_SERVICE);
    mCameraManager.registerTorchCallback(new TorchModeCallback(), mHandler);
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getDefaultDisplayRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mVrHeadsetHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mVrHeadsetHomeIntent.addCategory(Intent.CATEGORY_VR_HOME);
    mVrHeadsetHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mPanicPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_backPanicBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mHandleVolumeKeysInWM = mContext.getResources().getBoolean(com.android.internal.R.bool.config_handleVolumeKeysInWindowManager);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerHint.INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    mWindowManagerInternal.registerAppTransitionListener(new AppTransitionListener() {

        @Override
        public int onAppTransitionStartingLocked(int transit, IBinder openToken, IBinder closeToken, Animation openAnimation, Animation closeAnimation) {
            return handleStartTransitionForKeyguardLw(transit, openAnimation);
        }

        @Override
        public void onAppTransitionCancelledLocked(int transit) {
            handleStartTransitionForKeyguardLw(transit, null);
        }
    });
    mKeyguardDelegate = new KeyguardServiceDelegate(mContext, new StateCallback() {

        @Override
        public void onTrustedChanged() {
            mWindowManagerFuncs.notifyKeyguardTrustedChanged();
        }
    });
    final Resources res = mContext.getResources();
    final String[] deviceKeyHandlerLibs = res.getStringArray(org.lineageos.platform.internal.R.array.config_deviceKeyHandlerLibs);
    final String[] deviceKeyHandlerClasses = res.getStringArray(org.lineageos.platform.internal.R.array.config_deviceKeyHandlerClasses);
    for (int i = 0; i < deviceKeyHandlerLibs.length && i < deviceKeyHandlerClasses.length; i++) {
        try {
            PathClassLoader loader = new PathClassLoader(deviceKeyHandlerLibs[i], getClass().getClassLoader());
            Class<?> klass = loader.loadClass(deviceKeyHandlerClasses[i]);
            Constructor<?> constructor = klass.getConstructor(Context.class);
            mDeviceKeyHandlers.add((DeviceKeyHandler) constructor.newInstance(mContext));
        } catch (Exception e) {
            Slog.w(TAG, "Could not instantiate device key handler " + deviceKeyHandlerLibs[i] + " from class " + deviceKeyHandlerClasses[i], e);
        }
    }
    if (DEBUG)
        Slog.d(TAG, "" + mDeviceKeyHandlers.size() + " device key handlers loaded");
    // Register for torch off events
    BroadcastReceiver torchReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            mTorchOffPendingIntent = null;
            if (mTorchEnabled) {
                mHandler.removeMessages(MSG_TOGGLE_TORCH);
                Message msg = mHandler.obtainMessage(MSG_TOGGLE_TORCH);
                msg.setAsynchronous(true);
                msg.sendToTarget();
            }
        }
    };
    filter = new IntentFilter();
    filter.addAction(ACTION_TORCH_OFF);
    context.registerReceiver(torchReceiver, filter);
}
#method_after
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mHasFeatureWatch = mContext.getPackageManager().hasSystemFeature(FEATURE_WATCH);
    mHasFeatureLeanback = mContext.getPackageManager().hasSystemFeature(FEATURE_LEANBACK);
    mAccessibilityShortcutController = new AccessibilityShortcutController(mContext, new Handler(), mCurrentUserId);
    mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mCameraManager = (CameraManager) mContext.getSystemService(Context.CAMERA_SERVICE);
    mCameraManager.registerTorchCallback(new TorchModeCallback(), mHandler);
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getDefaultDisplayRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mEnableCarDockHomeCapture = context.getResources().getBoolean(com.android.internal.R.bool.config_enableCarDockHomeLaunch);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mVrHeadsetHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mVrHeadsetHomeIntent.addCategory(Intent.CATEGORY_VR_HOME);
    mVrHeadsetHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsScreenLock = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsScreenLock);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mLongPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnBackBehavior);
    mPanicPressOnBackBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_backPanicBehavior);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mHandleVolumeKeysInWM = mContext.getResources().getBoolean(com.android.internal.R.bool.config_handleVolumeKeysInWindowManager);
    readConfigurationDependentBehaviors();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_BOTTOM) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_RIGHT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromLeft() {
            if (mNavigationBar != null && mNavigationBarPosition == NAV_BAR_LEFT) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerHint.INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }

        @Override
        public void onMouseHoverAtTop() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_STATUS;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseHoverAtBottom() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
            Message msg = mHandler.obtainMessage(MSG_REQUEST_TRANSIENT_BARS);
            msg.arg1 = MSG_REQUEST_TRANSIENT_BARS_ARG_NAVIGATION;
            mHandler.sendMessageDelayed(msg, 500);
        }

        @Override
        public void onMouseLeaveFromEdge() {
            mHandler.removeMessages(MSG_REQUEST_TRANSIENT_BARS);
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    mWindowManagerInternal.registerAppTransitionListener(new AppTransitionListener() {

        @Override
        public int onAppTransitionStartingLocked(int transit, IBinder openToken, IBinder closeToken, Animation openAnimation, Animation closeAnimation) {
            return handleStartTransitionForKeyguardLw(transit, openAnimation);
        }

        @Override
        public void onAppTransitionCancelledLocked(int transit) {
            handleStartTransitionForKeyguardLw(transit, null);
        }
    });
    mKeyguardDelegate = new KeyguardServiceDelegate(mContext, new StateCallback() {

        @Override
        public void onTrustedChanged() {
            mWindowManagerFuncs.notifyKeyguardTrustedChanged();
        }
    });
    final Resources res = mContext.getResources();
    final String[] deviceKeyHandlerLibs = res.getStringArray(org.lineageos.platform.internal.R.array.config_deviceKeyHandlerLibs);
    final String[] deviceKeyHandlerClasses = res.getStringArray(org.lineageos.platform.internal.R.array.config_deviceKeyHandlerClasses);
    for (int i = 0; i < deviceKeyHandlerLibs.length && i < deviceKeyHandlerClasses.length; i++) {
        try {
            PathClassLoader loader = new PathClassLoader(deviceKeyHandlerLibs[i], getClass().getClassLoader());
            Class<?> klass = loader.loadClass(deviceKeyHandlerClasses[i]);
            Constructor<?> constructor = klass.getConstructor(Context.class);
            mDeviceKeyHandlers.add((DeviceKeyHandler) constructor.newInstance(mContext));
        } catch (Exception e) {
            Slog.w(TAG, "Could not instantiate device key handler " + deviceKeyHandlerLibs[i] + " from class " + deviceKeyHandlerClasses[i], e);
        }
    }
    if (DEBUG)
        Slog.d(TAG, "" + mDeviceKeyHandlers.size() + " device key handlers loaded");
    // Register for torch off events
    BroadcastReceiver torchReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            mTorchOffPendingIntent = null;
            if (mTorchEnabled) {
                mHandler.removeMessages(MSG_TOGGLE_TORCH);
                Message msg = mHandler.obtainMessage(MSG_TOGGLE_TORCH);
                msg.setAsynchronous(true);
                msg.sendToTarget();
            }
        }
    };
    filter = new IntentFilter();
    filter.addAction(ACTION_TORCH_OFF);
    context.registerReceiver(torchReceiver, filter);
}
#end_block

#method_before
private boolean canHideNavigationBar() {
    return mHasNavigationBar;
}
#method_after
private boolean canHideNavigationBar() {
    return hasNavigationBar();
}
#end_block

#method_before
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mTorchLongPressPowerEnabled = true;
        /*LineageSettings.System.getIntForUser(
                    resolver, LineageSettings.System.TORCH_LONG_PRESS_POWER_GESTURE, 0,
                    UserHandle.USER_CURRENT) == 1;*/
        mTorchTimeout = 60;
        /*LineageSettings.System.getIntForUser(
                    resolver, LineageSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT, 0,
                    UserHandle.USER_CURRENT);*/
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#method_after
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallBackBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR, Settings.Secure.INCALL_BACK_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mTorchLongPressPowerEnabled = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.TORCH_LONG_PRESS_POWER_GESTURE, 0, UserHandle.USER_CURRENT) == 1;
        mTorchTimeout = LineageSettings.System.getIntForUser(resolver, LineageSettings.System.TORCH_LONG_PRESS_POWER_TIMEOUT, 0, UserHandle.USER_CURRENT);
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        boolean devForceNavbar = LineageSettings.Global.getIntForUser(resolver, LineageSettings.Global.DEV_FORCE_SHOW_NAVBAR, 0, UserHandle.USER_CURRENT) == 1;
        if (devForceNavbar != mDevForceNavbar) {
            mDevForceNavbar = devForceNavbar;
            if (mLineageHardware.isSupported(LineageHardwareManager.FEATURE_KEY_DISABLE)) {
                mLineageHardware.set(LineageHardwareManager.FEATURE_KEY_DISABLE, mDevForceNavbar);
            }
        }
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mUserRotationAngles = LineageSettings.System.getInt(resolver, LineageSettings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#end_block

#method_before
@Override
public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId) {
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && mHasNavigationBar) {
        // the navigation bar to the side.
        if (mNavigationBarCanMove && fullWidth > fullHeight) {
            return fullWidth - getNavigationBarWidth(rotation, uiMode);
        }
    }
    return fullWidth;
}
#method_after
@Override
public int getNonDecorDisplayWidth(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId) {
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && hasNavigationBar()) {
        // the navigation bar to the side.
        if (mNavigationBarCanMove && fullWidth > fullHeight) {
            return fullWidth - getNavigationBarWidth(rotation, uiMode);
        }
    }
    return fullWidth;
}
#end_block

#method_before
@Override
public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId) {
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && mHasNavigationBar) {
        // the navigation bar to the bottom.
        if (!mNavigationBarCanMove || fullWidth < fullHeight) {
            return fullHeight - getNavigationBarHeight(rotation, uiMode);
        }
    }
    return fullHeight;
}
#method_after
@Override
public int getNonDecorDisplayHeight(int fullWidth, int fullHeight, int rotation, int uiMode, int displayId) {
    // TODO(multi-display): Support navigation bar on secondary displays.
    if (displayId == DEFAULT_DISPLAY && hasNavigationBar()) {
        // the navigation bar to the bottom.
        if (!mNavigationBarCanMove || fullWidth < fullHeight) {
            return fullHeight - getNavigationBarHeight(rotation, uiMode);
        }
    }
    return fullHeight;
}
#end_block

#method_before
@Override
public int rotationForOrientationLw(int orientation, int lastRotation) {
    if (false) {
        Slog.v(TAG, "rotationForOrientationLw(orient=" + orientation + ", last=" + lastRotation + "); user=" + mUserRotation + " " + ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED) ? "USER_ROTATION_LOCKED" : ""));
    }
    if (mForceDefaultOrientation) {
        return Surface.ROTATION_0;
    }
    synchronized (mLock) {
        // may be -1
        int sensorRotation = mOrientationListener.getProposedRotation();
        if (sensorRotation < 0) {
            sensorRotation = lastRotation;
        }
        final int preferredRotation;
        if (mLidState == LID_OPEN && mLidOpenRotation >= 0) {
            // Ignore sensor when lid switch is open and rotation is forced.
            preferredRotation = mLidOpenRotation;
        } else if (mDockMode == Intent.EXTRA_DOCK_STATE_CAR && (mCarDockEnablesAccelerometer || mCarDockRotation >= 0)) {
            // Ignore sensor when in car dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mCarDockEnablesAccelerometer ? sensorRotation : mCarDockRotation;
        } else if ((mDockMode == Intent.EXTRA_DOCK_STATE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK) && (mDeskDockEnablesAccelerometer || mDeskDockRotation >= 0)) {
            // Ignore sensor when in desk dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mDeskDockEnablesAccelerometer ? sensorRotation : mDeskDockRotation;
        } else if (mHdmiPlugged && mDemoHdmiRotationLock) {
            // Ignore sensor when plugged into HDMI when demo HDMI rotation lock enabled.
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mDemoHdmiRotation;
        } else if (mHdmiPlugged && mDockMode == Intent.EXTRA_DOCK_STATE_UNDOCKED && mUndockedHdmiRotation >= 0) {
            // Ignore sensor when plugged into HDMI and an undocked orientation has
            // been specified in the configuration (only for legacy devices without
            // full multi-display support).
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mUndockedHdmiRotation;
        } else if (mDemoRotationLock) {
            // Ignore sensor when demo rotation lock is enabled.
            // Note that the dock orientation and HDMI rotation lock override this.
            preferredRotation = mDemoRotation;
        } else if (mPersistentVrModeEnabled) {
            // While in VR, apps always prefer a portrait rotation. This does not change
            // any apps that explicitly set landscape, but does cause sensors be ignored,
            // and ignored any orientation lock that the user has set (this conditional
            // should remain above the ORIENTATION_LOCKED conditional below).
            preferredRotation = mPortraitRotation;
        } else if (orientation == ActivityInfo.SCREEN_ORIENTATION_LOCKED) {
            // Application just wants to remain locked in the last rotation.
            preferredRotation = lastRotation;
        } else if (!mSupportAutoRotation) {
            // If we don't support auto-rotation then bail out here and ignore
            // the sensor and any rotation lock settings.
            preferredRotation = -1;
        } else if ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_FREE && (orientation == ActivityInfo.SCREEN_ORIENTATION_USER || orientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_USER)) || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT) {
            // by default for USER or UNSPECIFIED modes.  Does not apply to NOSENSOR.
            if (mAllowAllRotations < 0) {
                // Can't read this during init() because the context doesn't
                // have display metrics at that time so we cannot determine
                // tablet vs. phone then.
                mAllowAllRotations = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowAllRotations) ? 1 : 0;
            }
            if (sensorRotation != Surface.ROTATION_180 || mAllowAllRotations == 1 || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_USER) {
                preferredRotation = sensorRotation;
            } else {
                preferredRotation = lastRotation;
            }
        } else if (mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED && orientation != ActivityInfo.SCREEN_ORIENTATION_NOSENSOR) {
            // Apply rotation lock.  Does not apply to NOSENSOR.
            // The idea is that the user rotation expresses a weak preference for the direction
            // of gravity and as NOSENSOR is never affected by gravity, then neither should
            // NOSENSOR be affected by rotation lock (although it will be affected by docks).
            preferredRotation = mUserRotation;
        } else {
            // No overriding preference.
            // We will do exactly what the application asked us to do.
            preferredRotation = -1;
        }
        switch(orientation) {
            case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
                // Return portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mPortraitRotation;
            case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
                // Return landscape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT:
                // Return reverse portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mUpsideDownRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE:
                // Return seascape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mSeascapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE:
            case ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE:
                // Return either landscape rotation.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                if (isLandscapeOrSeascape(lastRotation)) {
                    return lastRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT:
            case ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT:
                // Return either portrait rotation.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                if (isAnyPortrait(lastRotation)) {
                    return lastRotation;
                }
                return mPortraitRotation;
            default:
                // just return the preferred orientation we already calculated.
                if (preferredRotation >= 0) {
                    return preferredRotation;
                }
                return Surface.ROTATION_0;
        }
    }
}
#method_after
@Override
public int rotationForOrientationLw(int orientation, int lastRotation) {
    if (false) {
        Slog.v(TAG, "rotationForOrientationLw(orient=" + orientation + ", last=" + lastRotation + "); user=" + mUserRotation + " " + ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED) ? "USER_ROTATION_LOCKED" : ""));
    }
    if (mForceDefaultOrientation) {
        return Surface.ROTATION_0;
    }
    synchronized (mLock) {
        // may be -1
        int sensorRotation = mOrientationListener.getProposedRotation();
        if (sensorRotation < 0) {
            sensorRotation = lastRotation;
        }
        final int preferredRotation;
        if (mLidState == LID_OPEN && mLidOpenRotation >= 0) {
            // Ignore sensor when lid switch is open and rotation is forced.
            preferredRotation = mLidOpenRotation;
        } else if (mDockMode == Intent.EXTRA_DOCK_STATE_CAR && (mCarDockEnablesAccelerometer || mCarDockRotation >= 0)) {
            // Ignore sensor when in car dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mCarDockEnablesAccelerometer ? sensorRotation : mCarDockRotation;
        } else if ((mDockMode == Intent.EXTRA_DOCK_STATE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK) && (mDeskDockEnablesAccelerometer || mDeskDockRotation >= 0)) {
            // Ignore sensor when in desk dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mDeskDockEnablesAccelerometer ? sensorRotation : mDeskDockRotation;
        } else if (mHdmiPlugged && mDemoHdmiRotationLock) {
            // Ignore sensor when plugged into HDMI when demo HDMI rotation lock enabled.
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mDemoHdmiRotation;
        } else if (mHdmiPlugged && mDockMode == Intent.EXTRA_DOCK_STATE_UNDOCKED && mUndockedHdmiRotation >= 0) {
            // Ignore sensor when plugged into HDMI and an undocked orientation has
            // been specified in the configuration (only for legacy devices without
            // full multi-display support).
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mUndockedHdmiRotation;
        } else if (mDemoRotationLock) {
            // Ignore sensor when demo rotation lock is enabled.
            // Note that the dock orientation and HDMI rotation lock override this.
            preferredRotation = mDemoRotation;
        } else if (mPersistentVrModeEnabled) {
            // While in VR, apps always prefer a portrait rotation. This does not change
            // any apps that explicitly set landscape, but does cause sensors be ignored,
            // and ignored any orientation lock that the user has set (this conditional
            // should remain above the ORIENTATION_LOCKED conditional below).
            preferredRotation = mPortraitRotation;
        } else if (orientation == ActivityInfo.SCREEN_ORIENTATION_LOCKED) {
            // Application just wants to remain locked in the last rotation.
            preferredRotation = lastRotation;
        } else if (!mSupportAutoRotation) {
            // If we don't support auto-rotation then bail out here and ignore
            // the sensor and any rotation lock settings.
            preferredRotation = -1;
        } else if ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_FREE && (orientation == ActivityInfo.SCREEN_ORIENTATION_USER || orientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_USER)) || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT) {
            // by default for USER or UNSPECIFIED modes.  Does not apply to NOSENSOR.
            if (mAllowAllRotations < 0) {
                // Can't read this during init() because the context doesn't
                // have display metrics at that time so we cannot determine
                // tablet vs. phone then.
                mAllowAllRotations = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowAllRotations) ? 1 : 0;
            }
            // Rotation setting bitmask
            // 1=0 2=90 4=180 8=270
            boolean allowed = true;
            if (mUserRotationAngles < 0) {
                // Not set by user so use these defaults
                mUserRotationAngles = mAllowAllRotations == 1 ? // All angles
                (1 | 2 | 4 | 8) : // All except 180
                (1 | 2 | 8);
            }
            switch(sensorRotation) {
                case Surface.ROTATION_0:
                    allowed = (mUserRotationAngles & 1) != 0;
                    break;
                case Surface.ROTATION_90:
                    allowed = (mUserRotationAngles & 2) != 0;
                    break;
                case Surface.ROTATION_180:
                    allowed = (mUserRotationAngles & 4) != 0;
                    break;
                case Surface.ROTATION_270:
                    allowed = (mUserRotationAngles & 8) != 0;
                    break;
            }
            if (allowed) {
                preferredRotation = sensorRotation;
            } else {
                preferredRotation = lastRotation;
            }
        } else if (mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED && orientation != ActivityInfo.SCREEN_ORIENTATION_NOSENSOR) {
            // Apply rotation lock.  Does not apply to NOSENSOR.
            // The idea is that the user rotation expresses a weak preference for the direction
            // of gravity and as NOSENSOR is never affected by gravity, then neither should
            // NOSENSOR be affected by rotation lock (although it will be affected by docks).
            preferredRotation = mUserRotation;
        } else {
            // No overriding preference.
            // We will do exactly what the application asked us to do.
            preferredRotation = -1;
        }
        switch(orientation) {
            case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
                // Return portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mPortraitRotation;
            case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
                // Return landscape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT:
                // Return reverse portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mUpsideDownRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE:
                // Return seascape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mSeascapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE:
            case ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE:
                // Return either landscape rotation.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                if (isLandscapeOrSeascape(lastRotation)) {
                    return lastRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT:
            case ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT:
                // Return either portrait rotation.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                if (isAnyPortrait(lastRotation)) {
                    return lastRotation;
                }
                return mPortraitRotation;
            default:
                // just return the preferred orientation we already calculated.
                if (preferredRotation >= 0) {
                    return preferredRotation;
                }
                return Surface.ROTATION_0;
        }
    }
}
#end_block

#method_before
@Override
public void systemReady() {
    // In normal flow, systemReady is called before other system services are ready.
    // So it is better not to bind keyguard here.
    mKeyguardDelegate.onSystemReady();
    mVrManagerInternal = LocalServices.getService(VrManagerInternal.class);
    if (mVrManagerInternal != null) {
        mVrManagerInternal.addPersistentVrModeStateListener(mPersistentVrModeListener);
    }
    readCameraLensCoverState();
    updateUiMode();
    synchronized (mLock) {
        updateOrientationListenerLp();
        mSystemReady = true;
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                updateSettings();
            }
        });
        // And keyguard should be already bound from systemBooted
        if (mSystemBooted) {
            mKeyguardDelegate.onBootCompleted();
        }
    }
    mSystemGestures.systemReady();
    mImmersiveModeConfirmation.systemReady();
    mAutofillManagerInternal = LocalServices.getService(AutofillManagerInternal.class);
}
#method_after
@Override
public void systemReady() {
    // In normal flow, systemReady is called before other system services are ready.
    // So it is better not to bind keyguard here.
    mKeyguardDelegate.onSystemReady();
    mVrManagerInternal = LocalServices.getService(VrManagerInternal.class);
    if (mVrManagerInternal != null) {
        mVrManagerInternal.addPersistentVrModeStateListener(mPersistentVrModeListener);
    }
    mLineageHardware = LineageHardwareManager.getInstance(mContext);
    // Ensure observe happens in systemReady() since we need
    // LineageHardwareService to be up and running
    mSettingsObserver.observe();
    readCameraLensCoverState();
    updateUiMode();
    synchronized (mLock) {
        updateOrientationListenerLp();
        mSystemReady = true;
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                updateSettings();
            }
        });
        // And keyguard should be already bound from systemBooted
        if (mSystemBooted) {
            mKeyguardDelegate.onBootCompleted();
        }
    }
    mSystemGestures.systemReady();
    mImmersiveModeConfirmation.systemReady();
    mAutofillManagerInternal = LocalServices.getService(AutofillManagerInternal.class);
}
#end_block

#method_before
// Use this instead of checking config_showNavigationBar so that it can be consistently
@Override
public boolean hasNavigationBar() {
    return mHasNavigationBar;
}
#method_after
// Use this instead of checking config_showNavigationBar so that it can be consistently
@Override
public boolean hasNavigationBar() {
    return mHasNavigationBar || mDevForceNavbar;
}
#end_block

#method_before
void processMessage(Message msg) {
    Bundle bundle = (Bundle) msg.obj;
    // On reboot, update the notification bar with the contents of the
    // CalendarAlerts table.
    String action = bundle.getString("action");
    if (DEBUG) {
        Log.d(TAG, bundle.getLong(android.provider.CalendarContract.CalendarAlerts.ALARM_TIME) + " Action = " + action);
    }
    // Some OEMs had changed the provider's EVENT_REMINDER broadcast to their own event,
    // which broke our unbundled app's reminders.  So we added backup alarm scheduling to the
    // app, but we know we can turn it off if we ever receive the EVENT_REMINDER broadcast.
    boolean providerReminder = action.equals(android.provider.CalendarContract.ACTION_EVENT_REMINDER);
    if (providerReminder) {
        if (sReceivedProviderReminderBroadcast == null) {
            sReceivedProviderReminderBroadcast = Utils.getSharedPreference(this, PROVIDER_REMINDER_PREF_KEY, false);
        }
        if (!sReceivedProviderReminderBroadcast) {
            sReceivedProviderReminderBroadcast = true;
            Log.d(TAG, "Setting key " + PROVIDER_REMINDER_PREF_KEY + " to: true");
            Utils.setSharedPreference(this, PROVIDER_REMINDER_PREF_KEY, true);
        }
    }
    if (providerReminder || action.equals(Intent.ACTION_PROVIDER_CHANGED) || action.equals(android.provider.CalendarContract.ACTION_EVENT_REMINDER) || action.equals(AlertReceiver.EVENT_REMINDER_APP_ACTION) || action.equals(Intent.ACTION_LOCALE_CHANGED)) {
        // stale notifications.
        if (action.equals(Intent.ACTION_PROVIDER_CHANGED)) {
            try {
                Thread.sleep(5000);
            } catch (Exception e) {
            // Ignore.
            }
        }
        // If we dismissed a notification for a new event, then we need to sync the cache when
        // an ACTION_PROVIDER_CHANGED event has been sent. Unfortunately, the data provider
        // has a delay of CalendarProvider2.SYNC_UPDATE_BROADCAST_TIMEOUT_MILLIS (ie. 30 sec.)
        // until it notifies us that the sync adapter has finished.
        // TODO(psliwowski): Find a quicker way to be notified when the data provider has the
        // syncId for event.
        GlobalDismissManager.syncSenderDismissCache(this);
        updateAlertNotification(this);
    } else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
        // The provider usually initiates this setting up of alarms on startup,
        // but there was a bug (b/7221716) where a race condition caused this step to be
        // skipped, resulting in missed alarms.  This is a stopgap to minimize this bug
        // for devices that don't have the provider fix, by initiating this a 2nd time here.
        // However, it would still theoretically be possible to hit the race condition
        // the 2nd time and still miss alarms.
        // 
        // TODO: Remove this when the provider fix is rolled out everywhere.
        Intent intent = new Intent();
        intent.setClass(this, InitAlarmsService.class);
        startService(intent);
    } else if (action.equals(Intent.ACTION_TIME_CHANGED)) {
        doTimeChanged();
    } else if (action.equals(AlertReceiver.ACTION_DISMISS_OLD_REMINDERS)) {
        dismissOldAlerts(this);
    } else {
        Log.w(TAG, "Invalid action: " + action);
    }
    // Schedule the alarm for the next upcoming reminder, if not done by the provider.
    if (sReceivedProviderReminderBroadcast == null || !sReceivedProviderReminderBroadcast) {
        Log.d(TAG, "Scheduling next alarm with AlarmScheduler. " + "sEventReminderReceived: " + sReceivedProviderReminderBroadcast);
        AlarmScheduler.scheduleNextAlarm(this);
    }
}
#method_after
void processMessage(Message msg) {
    Bundle bundle = (Bundle) msg.obj;
    // On reboot, update the notification bar with the contents of the
    // CalendarAlerts table.
    String action = bundle.getString("action");
    if (DEBUG) {
        Log.d(TAG, bundle.getLong(android.provider.CalendarContract.CalendarAlerts.ALARM_TIME) + " Action = " + action);
    }
    // Some OEMs had changed the provider's EVENT_REMINDER broadcast to their own event,
    // which broke our unbundled app's reminders.  So we added backup alarm scheduling to the
    // app, but we know we can turn it off if we ever receive the EVENT_REMINDER broadcast.
    boolean providerReminder = action.equals(android.provider.CalendarContract.ACTION_EVENT_REMINDER);
    if (providerReminder) {
        if (sReceivedProviderReminderBroadcast == null) {
            sReceivedProviderReminderBroadcast = Utils.getSharedPreference(this, PROVIDER_REMINDER_PREF_KEY, false);
        }
        if (!sReceivedProviderReminderBroadcast) {
            sReceivedProviderReminderBroadcast = true;
            Log.d(TAG, "Setting key " + PROVIDER_REMINDER_PREF_KEY + " to: true");
            Utils.setSharedPreference(this, PROVIDER_REMINDER_PREF_KEY, true);
        }
    }
    if (providerReminder || action.equals(Intent.ACTION_PROVIDER_CHANGED) || action.equals(android.provider.CalendarContract.ACTION_EVENT_REMINDER) || (action.equals(AlertReceiver.EVENT_REMINDER_APP_ACTION) && !Boolean.TRUE.equals(sReceivedProviderReminderBroadcast)) || action.equals(Intent.ACTION_LOCALE_CHANGED)) {
        // stale notifications.
        if (action.equals(Intent.ACTION_PROVIDER_CHANGED)) {
            try {
                Thread.sleep(5000);
            } catch (Exception e) {
            // Ignore.
            }
        }
        // If we dismissed a notification for a new event, then we need to sync the cache when
        // an ACTION_PROVIDER_CHANGED event has been sent. Unfortunately, the data provider
        // has a delay of CalendarProvider2.SYNC_UPDATE_BROADCAST_TIMEOUT_MILLIS (ie. 30 sec.)
        // until it notifies us that the sync adapter has finished.
        // TODO(psliwowski): Find a quicker way to be notified when the data provider has the
        // syncId for event.
        GlobalDismissManager.syncSenderDismissCache(this);
        updateAlertNotification(this);
    } else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
        // The provider usually initiates this setting up of alarms on startup,
        // but there was a bug (b/7221716) where a race condition caused this step to be
        // skipped, resulting in missed alarms.  This is a stopgap to minimize this bug
        // for devices that don't have the provider fix, by initiating this a 2nd time here.
        // However, it would still theoretically be possible to hit the race condition
        // the 2nd time and still miss alarms.
        // 
        // TODO: Remove this when the provider fix is rolled out everywhere.
        Intent intent = new Intent();
        intent.setClass(this, InitAlarmsService.class);
        startService(intent);
    } else if (action.equals(Intent.ACTION_TIME_CHANGED)) {
        doTimeChanged();
    } else if (action.equals(AlertReceiver.ACTION_DISMISS_OLD_REMINDERS)) {
        dismissOldAlerts(this);
    } else {
        Log.w(TAG, "Invalid action: " + action);
    }
    // Schedule the alarm for the next upcoming reminder, if not done by the provider.
    if (sReceivedProviderReminderBroadcast == null || !sReceivedProviderReminderBroadcast) {
        Log.d(TAG, "Scheduling next alarm with AlarmScheduler. " + "sEventReminderReceived: " + sReceivedProviderReminderBroadcast);
        AlarmScheduler.scheduleNextAlarm(this);
    }
}
#end_block

#method_before
@Override
public void onCreate() {
    sReceivedProviderReminderBroadcast = Utils.getSharedPreference(this, PROVIDER_REMINDER_PREF_KEY, false);
    HandlerThread thread = new HandlerThread("AlertService", Process.THREAD_PRIORITY_BACKGROUND);
    thread.start();
    mServiceLooper = thread.getLooper();
    mServiceHandler = new ServiceHandler(mServiceLooper);
    // Flushes old fired alerts from internal storage, if needed.
    AlertUtils.flushOldAlertsFromInternalStorage(getApplication());
}
#method_after
@Override
public void onCreate() {
    HandlerThread thread = new HandlerThread("AlertService", Process.THREAD_PRIORITY_BACKGROUND);
    thread.start();
    mServiceLooper = thread.getLooper();
    mServiceHandler = new ServiceHandler(mServiceLooper);
    // Flushes old fired alerts from internal storage, if needed.
    AlertUtils.flushOldAlertsFromInternalStorage(getApplication());
}
#end_block

#method_before
int checkGrantUriPermissionLocked(int callingUid, String targetPkg, Uri uri, int modeFlags, int lastTargetUid) {
    final boolean persistable = (modeFlags & Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION) != 0;
    modeFlags &= (Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
    if (modeFlags == 0) {
        return -1;
    }
    if (targetPkg != null) {
        if (DEBUG_URI_PERMISSION)
            Slog.v(TAG, "Checking grant " + targetPkg + " permission to " + uri);
    }
    final IPackageManager pm = AppGlobals.getPackageManager();
    // If this is not a content: uri, we can't do anything with it.
    if (!ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {
        if (DEBUG_URI_PERMISSION)
            Slog.v(TAG, "Can't grant URI permission for non-content URI: " + uri);
        return -1;
    }
    // Bail early if system is trying to hand out permissions directly; it
    // must always grant permissions on behalf of someone explicit.
    final int callingAppId = UserHandle.getAppId(callingUid);
    if (callingAppId == Process.SYSTEM_UID) {
        if ("com.android.settings.files".equals(uri.getAuthority())) {
        // Exempted authority for cropping user photos in Settings app
        } else {
            Slog.w(TAG, "For security reasons, the system cannot issue a Uri permission" + "; use startActivityAsCaller() instead");
            return -1;
        }
    }
    final String authority = uri.getAuthority();
    final ProviderInfo pi = getProviderInfoLocked(authority, UserHandle.getUserId(callingUid));
    if (pi == null) {
        Slog.w(TAG, "No content provider found for permission check: " + uri.toSafeString());
        return -1;
    }
    int targetUid = lastTargetUid;
    if (targetUid < 0 && targetPkg != null) {
        try {
            targetUid = pm.getPackageUid(targetPkg, UserHandle.getUserId(callingUid));
            if (targetUid < 0) {
                if (DEBUG_URI_PERMISSION)
                    Slog.v(TAG, "Can't grant URI permission no uid for: " + targetPkg);
                return -1;
            }
        } catch (RemoteException ex) {
            return -1;
        }
    }
    if (targetUid >= 0) {
        // First...  does the target actually need this permission?
        if (checkHoldingPermissionsLocked(pm, pi, uri, targetUid, modeFlags)) {
            // No need to grant the target this permission.
            if (DEBUG_URI_PERMISSION)
                Slog.v(TAG, "Target " + targetPkg + " already has full permission to " + uri);
            return -1;
        }
    } else {
        // First...  there is no target package, so can anyone access it?
        boolean allowed = pi.exported;
        if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
            if (pi.readPermission != null) {
                allowed = false;
            }
        }
        if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
            if (pi.writePermission != null) {
                allowed = false;
            }
        }
        if (allowed) {
            return -1;
        }
    }
    // Second...  is the provider allowing granting of URI permissions?
    if (!pi.grantUriPermissions) {
        throw new SecurityException("Provider " + pi.packageName + "/" + pi.name + " does not allow granting of Uri permissions (uri " + uri + ")");
    }
    if (pi.uriPermissionPatterns != null) {
        final int N = pi.uriPermissionPatterns.length;
        boolean allowed = false;
        for (int i = 0; i < N; i++) {
            if (pi.uriPermissionPatterns[i] != null && pi.uriPermissionPatterns[i].match(uri.getPath())) {
                allowed = true;
                break;
            }
        }
        if (!allowed) {
            throw new SecurityException("Provider " + pi.packageName + "/" + pi.name + " does not allow granting of permission to path of Uri " + uri);
        }
    }
    // this uri?
    if (callingUid != Process.myUid()) {
        if (!checkHoldingPermissionsLocked(pm, pi, uri, callingUid, modeFlags)) {
            // Require they hold a strong enough Uri permission
            final int minStrength = persistable ? UriPermission.STRENGTH_PERSISTABLE : UriPermission.STRENGTH_OWNED;
            if (!checkUriPermissionLocked(uri, callingUid, modeFlags, minStrength)) {
                throw new SecurityException("Uid " + callingUid + " does not have permission to uri " + uri);
            }
        }
    }
    return targetUid;
}
#method_after
int checkGrantUriPermissionLocked(int callingUid, String targetPkg, Uri uri, int modeFlags, int lastTargetUid) {
    final boolean persistable = (modeFlags & Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION) != 0;
    modeFlags &= (Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
    if (modeFlags == 0) {
        return -1;
    }
    if (targetPkg != null) {
        if (DEBUG_URI_PERMISSION)
            Slog.v(TAG, "Checking grant " + targetPkg + " permission to " + uri);
    }
    final IPackageManager pm = AppGlobals.getPackageManager();
    // If this is not a content: uri, we can't do anything with it.
    if (!ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {
        if (DEBUG_URI_PERMISSION)
            Slog.v(TAG, "Can't grant URI permission for non-content URI: " + uri);
        return -1;
    }
    // Bail early if system is trying to hand out permissions directly; it
    // must always grant permissions on behalf of someone explicit.
    final int callingAppId = UserHandle.getAppId(callingUid);
    if (callingAppId == Process.SYSTEM_UID) {
        if ("com.android.settings.files".equals(uri.getAuthority())) {
        // Exempted authority for cropping user photos in Settings app
        } else {
            Slog.w(TAG, "For security reasons, the system cannot issue a Uri permission" + " grant to " + uri.getAuthority() + "; use startActivityAsCaller() instead");
            return -1;
        }
    }
    final String authority = uri.getAuthority();
    final ProviderInfo pi = getProviderInfoLocked(authority, UserHandle.getUserId(callingUid));
    if (pi == null) {
        Slog.w(TAG, "No content provider found for permission check: " + uri.toSafeString());
        return -1;
    }
    int targetUid = lastTargetUid;
    if (targetUid < 0 && targetPkg != null) {
        try {
            targetUid = pm.getPackageUid(targetPkg, UserHandle.getUserId(callingUid));
            if (targetUid < 0) {
                if (DEBUG_URI_PERMISSION)
                    Slog.v(TAG, "Can't grant URI permission no uid for: " + targetPkg);
                return -1;
            }
        } catch (RemoteException ex) {
            return -1;
        }
    }
    if (targetUid >= 0) {
        // First...  does the target actually need this permission?
        if (checkHoldingPermissionsLocked(pm, pi, uri, targetUid, modeFlags)) {
            // No need to grant the target this permission.
            if (DEBUG_URI_PERMISSION)
                Slog.v(TAG, "Target " + targetPkg + " already has full permission to " + uri);
            return -1;
        }
    } else {
        // First...  there is no target package, so can anyone access it?
        boolean allowed = pi.exported;
        if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
            if (pi.readPermission != null) {
                allowed = false;
            }
        }
        if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
            if (pi.writePermission != null) {
                allowed = false;
            }
        }
        if (allowed) {
            return -1;
        }
    }
    // Second...  is the provider allowing granting of URI permissions?
    if (!pi.grantUriPermissions) {
        throw new SecurityException("Provider " + pi.packageName + "/" + pi.name + " does not allow granting of Uri permissions (uri " + uri + ")");
    }
    if (pi.uriPermissionPatterns != null) {
        final int N = pi.uriPermissionPatterns.length;
        boolean allowed = false;
        for (int i = 0; i < N; i++) {
            if (pi.uriPermissionPatterns[i] != null && pi.uriPermissionPatterns[i].match(uri.getPath())) {
                allowed = true;
                break;
            }
        }
        if (!allowed) {
            throw new SecurityException("Provider " + pi.packageName + "/" + pi.name + " does not allow granting of permission to path of Uri " + uri);
        }
    }
    // this uri?
    if (callingUid != Process.myUid()) {
        if (!checkHoldingPermissionsLocked(pm, pi, uri, callingUid, modeFlags)) {
            // Require they hold a strong enough Uri permission
            final int minStrength = persistable ? UriPermission.STRENGTH_PERSISTABLE : UriPermission.STRENGTH_OWNED;
            if (!checkUriPermissionLocked(uri, callingUid, modeFlags, minStrength)) {
                throw new SecurityException("Uid " + callingUid + " does not have permission to uri " + uri);
            }
        }
    }
    return targetUid;
}
#end_block

#method_before
public void swapCursor(Cursor cursor) {
    if (cursor == mCursor) {
        return;
    }
    if (mCursor != null) {
        mCursor.close();
    }
    mCursor = cursor;
    if (mCursor != null) {
        mIdColumnIndex = cursor.getColumnIndexOrThrow(FavoriteProvider.Columns._ID);
        mTitleColumnIndex = cursor.getColumnIndexOrThrow(FavoriteProvider.Columns.TITLE);
        mUrlColumnIndex = cursor.getColumnIndexOrThrow(FavoriteProvider.Columns.URL);
        mColorColumnIndex = cursor.getColumnIndexOrThrow(FavoriteProvider.Columns.COLOR);
    }
    notifyDataSetChanged();
}
#method_after
void swapCursor(Cursor cursor) {
    if (cursor == mCursor) {
        return;
    }
    if (mCursor != null) {
        mCursor.close();
    }
    mCursor = cursor;
    if (mCursor != null) {
        mIdColumnIndex = cursor.getColumnIndexOrThrow(FavoriteProvider.Columns._ID);
        mTitleColumnIndex = cursor.getColumnIndexOrThrow(FavoriteProvider.Columns.TITLE);
        mUrlColumnIndex = cursor.getColumnIndexOrThrow(FavoriteProvider.Columns.URL);
        mColorColumnIndex = cursor.getColumnIndexOrThrow(FavoriteProvider.Columns.COLOR);
    }
    notifyDataSetChanged();
}
#end_block

#method_before
private void setAsFavorite(String title, String url) {
    boolean hasValidIcon = mUrlIcon != null && !mUrlIcon.isRecycled();
    int color = hasValidIcon ? UiUtils.getColor(mUrlIcon, false) : Color.TRANSPARENT;
    if (color == Color.TRANSPARENT) {
        color = ContextCompat.getColor(MainActivity.this, R.color.colorAccent);
    }
    new SetAsFavoriteTask(getContentResolver(), title, url, color, mCoordinator).execute();
}
#method_after
private void setAsFavorite(String title, String url) {
    boolean hasValidIcon = mUrlIcon != null && !mUrlIcon.isRecycled();
    int color = hasValidIcon ? UiUtils.getColor(mUrlIcon, false) : Color.TRANSPARENT;
    if (color == Color.TRANSPARENT) {
        color = ContextCompat.getColor(this, R.color.colorAccent);
    }
    new SetAsFavoriteTask(getContentResolver(), title, url, color, mCoordinator).execute();
}
#end_block

#method_before
@Override
protected Boolean doInBackground(Void... params) {
    FavoriteProvider.updateItem(contentResolver, id, title, url);
    return true;
}
#method_after
@Override
protected Void doInBackground(Void... params) {
    FavoriteProvider.updateItem(contentResolver, id, title, url);
    return null;
}
#end_block

#method_before
@Override
protected Boolean doInBackground(Long... ids) {
    for (int i = 0; i < ids.length; i++) {
        Uri uri = ContentUris.withAppendedId(FavoriteProvider.Columns.CONTENT_URI, ids[i]);
        contentResolver.delete(uri, null, null);
    }
    return true;
}
#method_after
@Override
protected Void doInBackground(Long... ids) {
    for (Long id : ids) {
        Uri uri = ContentUris.withAppendedId(FavoriteProvider.Columns.CONTENT_URI, id);
        contentResolver.delete(uri, null, null);
    }
    return null;
}
#end_block

#method_before
private WeatherInfo processWeatherResponse(CurrentWeatherResponse currentWeatherResponse, ForecastResponse forecastResponse, int tempUnit) {
    if (currentWeatherResponse.getInternalCode() == 404) {
        // city ID that we got by looking up a city...not our fault
        return null;
    }
    final String cityName = currentWeatherResponse.getCityName();
    final double temperature = currentWeatherResponse.getTemperature();
    // We need at least the city name and current temperature
    if (cityName == null || Double.isNaN(temperature))
        return null;
    WeatherInfo.Builder builder = new WeatherInfo.Builder(cityName, sanitizeTemperature(temperature, true), tempUnit).setTimestamp(System.currentTimeMillis());
    builder.setWeatherCondition(mapConditionIconToCode(currentWeatherResponse.getWeatherIconId(), currentWeatherResponse.getConditionCode()));
    final double humidity = currentWeatherResponse.getHumidity();
    if (!Double.isNaN(humidity)) {
        builder.setHumidity(humidity);
    }
    final double todaysHigh = currentWeatherResponse.getTodaysMaxTemp();
    if (!Double.isNaN(todaysHigh)) {
        builder.setTodaysHigh(todaysHigh);
    }
    final double todaysLow = currentWeatherResponse.getTodaysMinTemp();
    if (!Double.isNaN(todaysLow)) {
        builder.setTodaysLow(todaysLow);
    }
    final double windDir = currentWeatherResponse.getWindDirection();
    final double windSpeed = currentWeatherResponse.getWindSpeed();
    if (!Double.isNaN(windDir) && !Double.isNaN(windSpeed)) {
        builder.setWind(windSpeed, windDir, WeatherContract.WeatherColumns.WindSpeedUnit.KPH);
    }
    if (forecastResponse != null) {
        List<WeatherInfo.DayForecast> forecastList = new ArrayList<>();
        for (ForecastResponse.DayForecast forecast : forecastResponse.getForecastList()) {
            WeatherInfo.DayForecast.Builder forecastBuilder = new WeatherInfo.DayForecast.Builder(mapConditionIconToCode(forecast.getWeatherIconId(), forecast.getConditionCode()));
            final double max = forecast.getMaxTemp();
            if (!Double.isNaN(max)) {
                forecastBuilder.setHigh(max);
            }
            final double min = forecast.getMinTemp();
            if (!Double.isNaN(min)) {
                forecastBuilder.setLow(min);
            }
            forecastList.add(forecastBuilder.build());
        }
        builder.setForecast(forecastList);
    }
    return builder.build();
}
#method_after
private WeatherInfo processWeatherResponse(CurrentWeatherResponse currentWeatherResponse, ForecastResponse forecastResponse, int tempUnit) {
    if (currentWeatherResponse.getInternalCode() == 404) {
        // city ID that we got by looking up a city...not our fault
        return null;
    }
    final String cityName = currentWeatherResponse.getCityName();
    final double temperature = currentWeatherResponse.getTemperature();
    // We need at least the city name and current temperature
    if (cityName == null || Double.isNaN(temperature))
        return null;
    WeatherInfo.Builder builder = new WeatherInfo.Builder(cityName, sanitizeTemperature(temperature, true), tempUnit).setTimestamp(System.currentTimeMillis());
    final int condition = mapConditionIconToCode(currentWeatherResponse.getWeatherIconId(), currentWeatherResponse.getConditionCode());
    builder.setWeatherCondition(condition);
    final double humidity = currentWeatherResponse.getHumidity();
    if (!Double.isNaN(humidity)) {
        builder.setHumidity(humidity);
    }
    final double todaysHigh = currentWeatherResponse.getTodaysMaxTemp();
    if (!Double.isNaN(todaysHigh)) {
        builder.setTodaysHigh(todaysHigh);
    }
    final double todaysLow = currentWeatherResponse.getTodaysMinTemp();
    if (!Double.isNaN(todaysLow)) {
        builder.setTodaysLow(todaysLow);
    }
    final double windDir = currentWeatherResponse.getWindDirection();
    double windSpeed = currentWeatherResponse.getWindSpeed();
    if (!Double.isNaN(windDir) && !Double.isNaN(windSpeed)) {
        if (tempUnit == WeatherContract.WeatherColumns.TempUnit.CELSIUS) {
            windSpeed *= MPS_TO_KPH;
        }
        builder.setWind(windSpeed, windDir, WeatherContract.WeatherColumns.WindSpeedUnit.KPH);
    }
    if (forecastResponse != null) {
        List<WeatherInfo.DayForecast> forecastList = new ArrayList<>();
        List<ForecastResponse.DayForecast> forecastResponses = forecastResponse.getForecastList();
        double dayMinimum = Double.NaN;
        double dayMaximum = Double.NaN;
        WeatherInfo.DayForecast.Builder forecastBuilder = null;
        int maxItems = forecastResponses.size();
        for (int i = 0; i < maxItems; i++) {
            ForecastResponse.DayForecast forecast = forecastResponses.get(i);
            Calendar forecastCalendar = Calendar.getInstance();
            forecastCalendar.setTimeInMillis(forecast.getTimestamp() * 1000);
            // today's values so the list is populated correctly.
            if (i == 0) {
                int forecastDay = forecastCalendar.get(Calendar.DAY_OF_YEAR);
                int currentDay = Calendar.getInstance().get(Calendar.DAY_OF_YEAR);
                if (currentDay != forecastDay) {
                    forecastBuilder = new WeatherInfo.DayForecast.Builder(condition);
                    if (!Double.isNaN(todaysHigh)) {
                        forecastBuilder.setHigh(todaysHigh);
                    }
                    if (!Double.isNaN(todaysLow)) {
                        forecastBuilder.setLow(todaysLow);
                    }
                    forecastList.add(forecastBuilder.build());
                    // Remove items from the list so we add the forecast for 5 days only
                    maxItems -= FORECAST_ITEMS_PER_DAY;
                }
            }
            final double max = forecast.getMaxTemp();
            if (!Double.isNaN(max) && (Double.isNaN(dayMaximum) || max > dayMaximum)) {
                dayMaximum = max;
            }
            final double min = forecast.getMinTemp();
            if (!Double.isNaN(min) && (Double.isNaN(dayMinimum) || min < dayMinimum)) {
                dayMinimum = min;
            }
            // so you get a forecast for the same time every day
            if (i % FORECAST_ITEMS_PER_DAY == 0) {
                forecastBuilder = new WeatherInfo.DayForecast.Builder(mapConditionIconToCode(forecast.getWeatherIconId(), forecast.getConditionCode()));
            }
            // If it's the last result of each day (within 3 hours from the next day),
            // build the forecast and add the calculated min and max temperatures
            int forecastHour = forecastCalendar.get(Calendar.HOUR_OF_DAY);
            if (forecastHour >= 21) {
                if (!Double.isNaN(dayMinimum)) {
                    forecastBuilder.setLow(dayMinimum);
                }
                if (!Double.isNaN(dayMaximum)) {
                    forecastBuilder.setHigh(dayMaximum);
                }
                forecastList.add(forecastBuilder.build());
                dayMinimum = Double.NaN;
                dayMaximum = Double.NaN;
            }
        }
        builder.setForecast(forecastList);
    }
    return builder.build();
}
#end_block

#method_before
@Override
public void onCreate() {
    super.onCreate();
    registerReceiver(mShutdownReceiver, new IntentFilter(Intent.ACTION_SHUTDOWN));
}
#method_after
@Override
public void onCreate() {
    super.onCreate();
    mNotificationManager = getSystemService(NotificationManager.class);
    CharSequence name = getString(R.string.sound_channel_title);
    String description = getString(R.string.sound_channel_desc);
    NotificationChannel notificationChannel = new NotificationChannel(SOUNDRECORDER_NOTIFICATION_CHANNEL, name, NotificationManager.IMPORTANCE_LOW);
    notificationChannel.setDescription(description);
    mNotificationManager.createNotificationChannel(notificationChannel);
    registerReceiver(mShutdownReceiver, new IntentFilter(Intent.ACTION_SHUTDOWN));
}
#end_block

#method_before
private void startVisualizerThread() {
    mVisualizerThread = new Thread(() -> {
        while (isRecording()) {
            try {
                Thread.sleep(100L);
            } catch (InterruptedException e) {
                Log.e(TAG, e.getMessage());
            }
            double val = 0d;
            for (byte mByte : mData) {
                val += Math.pow(mByte, 2);
            }
            val /= mData.length;
            if (mAudioListener != null) {
                mAudioListener.onAudioLevelUpdated((int) Math.sqrt(val));
            }
        }
    });
    mVisualizerThread.start();
}
#method_after
private void startVisualizerThread() {
    mVisualizerThread = new Thread(() -> {
        while (isRecording()) {
            try {
                Thread.sleep(150L);
            } catch (InterruptedException e) {
                Log.e(TAG, e.getMessage());
            }
            double val = 0d;
            for (byte mByte : mData) {
                val += Math.pow(mByte, 2);
            }
            val /= mData.length;
            if (mAudioListener != null) {
                mAudioListener.onAudioLevelUpdated((int) Math.sqrt(val));
            }
        }
    });
    mVisualizerThread.start();
}
#end_block

#method_before
private void startTimer() {
    Timer timer = new Timer();
    mTimerListener = (seconds -> {
        NotificationManager nm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
        nm.notify(NOTIFICATION_ID, createRecordingNotification());
    });
    mTask = new TimerTask() {

        @Override
        public void run() {
            mElapsedTime++;
            if (mTimerListener != null) {
                mTimerListener.onTimerUpdated(mElapsedTime);
            }
        }
    };
    timer.scheduleAtFixedRate(mTask, 1000, 1000);
}
#method_after
private void startTimer() {
    Timer timer = new Timer();
    mTimerListener = (seconds -> mNotificationManager.notify(NOTIFICATION_ID, createRecordingNotification()));
    mTask = new TimerTask() {

        @Override
        public void run() {
            mElapsedTime += 1000;
            if (mTimerListener != null) {
                mTimerListener.onTimerUpdated(mElapsedTime);
            }
        }
    };
    timer.scheduleAtFixedRate(mTask, 1000, 1000);
}
#end_block

#method_before
private Notification createRecordingNotification() {
    Intent intent = new Intent(this, RecorderActivity.class);
    // Fake launcher intent to resume previous activity - FIXME: use singleTop instead?
    intent.setAction(Intent.ACTION_MAIN);
    intent.addCategory(Intent.CATEGORY_LAUNCHER);
    PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);
    NotificationManager mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
    String id = "soundrecorder_persist_channel";
    CharSequence name = "Sound is being recorded";
    String description = "Persistent notification when recording sound";
    int importance = NotificationManager.IMPORTANCE_LOW;
    NotificationChannel mChannel = new NotificationChannel(id, name, importance);
    mChannel.setDescription(description);
    mNotificationManager.createNotificationChannel(mChannel);
    NotificationCompat.Builder builder = new NotificationCompat.Builder(this, "soundrecorder_persist_channel").setContentTitle(getString(R.string.sound_notification_title)).setContentText(getString(R.string.sound_notification_message, DateUtils.formatElapsedTime(mElapsedTime))).setOngoing(true).setSmallIcon(R.drawable.ic_action_sound_record).setContentIntent(pi).setColor(ContextCompat.getColor(this, R.color.colorPrimary));
    return builder.build();
}
#method_after
private Notification createRecordingNotification() {
    Intent intent = new Intent(this, RecorderActivity.class);
    PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);
    NotificationCompat.Builder builder = new NotificationCompat.Builder(this, SOUNDRECORDER_NOTIFICATION_CHANNEL).setContentTitle(getString(R.string.sound_notification_title)).setContentText(getString(R.string.sound_notification_message, DateUtils.formatElapsedTime(mElapsedTime / 1000))).setOngoing(true).setSmallIcon(R.drawable.ic_action_sound_record).setContentIntent(pi).setColor(ContextCompat.getColor(this, R.color.colorPrimary));
    return builder.build();
}
#end_block

#method_before
public void createShareNotification() {
    Intent intent = new Intent(this, RecorderActivity.class);
    // Fake launcher intent to resume previous activity - FIXME: use singleTop instead?
    intent.setAction(Intent.ACTION_MAIN);
    intent.addCategory(Intent.CATEGORY_LAUNCHER);
    PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);
    PendingIntent playPIntent = PendingIntent.getActivity(this, 0, LastRecordHelper.getOpenIntent(this, mOutFilePath, "audio/wav"), PendingIntent.FLAG_CANCEL_CURRENT);
    PendingIntent sharePIntent = PendingIntent.getActivity(this, 0, LastRecordHelper.getShareIntent(this, mOutFilePath, "audio/wav"), PendingIntent.FLAG_CANCEL_CURRENT);
    LastRecordHelper.setLastItem(this, mOutFilePath, mElapsedTime, true);
    NotificationManager mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
    String id = "soundrecorder_complete_channel";
    CharSequence name = "Sound recording complete";
    String description = "Notification showing sound recording is complete";
    int importance = NotificationManager.IMPORTANCE_LOW;
    NotificationChannel mChannel = new NotificationChannel(id, name, importance);
    mChannel.setDescription(description);
    mNotificationManager.createNotificationChannel(mChannel);
    Notification notification = new NotificationCompat.Builder(this, "soundrecorder_complete_channel").setWhen(System.currentTimeMillis()).setSmallIcon(R.drawable.ic_action_sound_record).setContentTitle(getString(R.string.sound_notification_title)).setContentText(getString(R.string.sound_notification_message, DateUtils.formatElapsedTime(mElapsedTime))).addAction(R.drawable.ic_play, getString(R.string.play), playPIntent).addAction(R.drawable.ic_share, getString(R.string.share), sharePIntent).setContentIntent(pi).build();
    NotificationManager nm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
    nm.notify(NOTIFICATION_ID, notification);
}
#method_after
public void createShareNotification() {
    Intent intent = new Intent(this, RecorderActivity.class);
    PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);
    PendingIntent playPIntent = PendingIntent.getActivity(this, 0, LastRecordHelper.getOpenIntent(this, mOutFilePath, "audio/wav"), PendingIntent.FLAG_CANCEL_CURRENT);
    PendingIntent sharePIntent = PendingIntent.getActivity(this, 0, LastRecordHelper.getShareIntent(this, mOutFilePath, "audio/wav"), PendingIntent.FLAG_CANCEL_CURRENT);
    PendingIntent deletePIntent = PendingIntent.getActivity(this, 0, LastRecordHelper.getDeleteIntent(this, true), PendingIntent.FLAG_CANCEL_CURRENT);
    LastRecordHelper.setLastItem(this, mOutFilePath, mElapsedTime, true);
    Notification notification = new NotificationCompat.Builder(this, SOUNDRECORDER_NOTIFICATION_CHANNEL).setWhen(System.currentTimeMillis()).setSmallIcon(R.drawable.ic_action_sound_record).setContentTitle(getString(R.string.sound_notification_title)).setContentText(getString(R.string.sound_notification_message, DateUtils.formatElapsedTime(mElapsedTime / 1000))).addAction(R.drawable.ic_play, getString(R.string.play), playPIntent).addAction(R.drawable.ic_share, getString(R.string.share), sharePIntent).addAction(R.drawable.ic_delete, getString(R.string.delete), deletePIntent).setContentIntent(pi).build();
    mNotificationManager.notify(NOTIFICATION_ID, notification);
}
#end_block

#method_before
@Override
public void onCreate() {
    super.onCreate();
    mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_USER_BACKGROUND);
    filter.addAction(Intent.ACTION_SHUTDOWN);
    registerReceiver(mBroadcastReceiver, filter);
}
#method_after
@Override
public void onCreate() {
    super.onCreate();
    mNotificationManager = getSystemService(NotificationManager.class);
    CharSequence name = getString(R.string.screen_channel_title);
    String description = getString(R.string.screen_channel_desc);
    NotificationChannel notificationChannel = new NotificationChannel(SCREENCAST_NOTIFICATION_CHANNEL, name, NotificationManager.IMPORTANCE_LOW);
    notificationChannel.setDescription(description);
    mNotificationManager.createNotificationChannel(notificationChannel);
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_USER_BACKGROUND);
    filter.addAction(Intent.ACTION_SHUTDOWN);
    registerReceiver(mBroadcastReceiver, filter);
}
#end_block

#method_before
private NotificationCompat.Builder createNotificationBuilder() {
    Intent intent = new Intent(this, RecorderActivity.class);
    // Fake launcher intent to resume previous activity - FIXME: use singleTop?
    intent.setAction(Intent.ACTION_MAIN);
    intent.addCategory(Intent.CATEGORY_LAUNCHER);
    Intent stopRecordingIntent = new Intent(ACTION_STOP_SCREENCAST);
    stopRecordingIntent.setClass(this, ScreencastService.class);
    String id = "screencast_persist_channel";
    CharSequence name = "Screen is being recorded";
    String description = "Persistent notification when recording the screen";
    int importance = NotificationManager.IMPORTANCE_LOW;
    NotificationChannel notificationChannel = new NotificationChannel(id, name, importance);
    notificationChannel.setDescription(description);
    mNotificationManager.createNotificationChannel(notificationChannel);
    return new NotificationCompat.Builder(this, id).setOngoing(true).setSmallIcon(R.drawable.ic_action_screen_record).setContentTitle(getString(R.string.screen_notification_title)).setContentText(getString(R.string.screen_notification_message)).setContentIntent(PendingIntent.getActivity(this, 0, intent, 0)).addAction(R.drawable.ic_stop, getString(R.string.stop), PendingIntent.getService(this, 0, stopRecordingIntent, 0));
}
#method_after
private NotificationCompat.Builder createNotificationBuilder() {
    Intent intent = new Intent(this, RecorderActivity.class);
    Intent stopRecordingIntent = new Intent(ACTION_STOP_SCREENCAST);
    stopRecordingIntent.setClass(this, ScreencastService.class);
    return new NotificationCompat.Builder(this, SCREENCAST_NOTIFICATION_CHANNEL).setOngoing(true).setSmallIcon(R.drawable.ic_action_screen_record).setContentTitle(getString(R.string.screen_notification_title)).setContentText(getString(R.string.screen_notification_message)).setContentIntent(PendingIntent.getActivity(this, 0, intent, 0)).addAction(R.drawable.ic_stop, getString(R.string.stop), PendingIntent.getService(this, 0, stopRecordingIntent, 0));
}
#end_block

#method_before
private NotificationCompat.Builder createShareNotificationBuilder(String file) {
    Intent intent = new Intent(this, RecorderActivity.class);
    // Fake launcher intent to resume previous activity - FIXME: use singleTop instead?
    intent.setAction(Intent.ACTION_MAIN);
    intent.addCategory(Intent.CATEGORY_LAUNCHER);
    PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);
    PendingIntent playPIntent = PendingIntent.getActivity(this, 0, LastRecordHelper.getOpenIntent(this, file, "video/mp4"), PendingIntent.FLAG_CANCEL_CURRENT);
    PendingIntent sharePIntent = PendingIntent.getActivity(this, 0, LastRecordHelper.getShareIntent(this, file, "video/mp4"), PendingIntent.FLAG_CANCEL_CURRENT);
    long timeElapsed = SystemClock.elapsedRealtime() - mStartTime;
    LastRecordHelper.setLastItem(this, file, timeElapsed, false);
    Log.i(LOGTAG, "Video complete: " + file);
    NotificationManager mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
    String id = "screencast_complete_channel";
    CharSequence name = "Screen record complete";
    String description = "Notification showing screen recording is complete";
    int importance = NotificationManager.IMPORTANCE_LOW;
    NotificationChannel mChannel = new NotificationChannel(id, name, importance);
    mChannel.setDescription(description);
    mNotificationManager.createNotificationChannel(mChannel);
    return new NotificationCompat.Builder(this, "screencast_complete_channel").setWhen(System.currentTimeMillis()).setSmallIcon(R.drawable.ic_action_screen_record).setContentTitle(getString(R.string.screen_notification_message_done)).setContentText(getString(R.string.screen_notification_message, DateUtils.formatElapsedTime(timeElapsed / 1000))).addAction(R.drawable.ic_play, getString(R.string.play), playPIntent).addAction(R.drawable.ic_share, getString(R.string.share), sharePIntent).setContentIntent(pi);
}
#method_after
private NotificationCompat.Builder createShareNotificationBuilder(String file) {
    Intent intent = new Intent(this, RecorderActivity.class);
    PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);
    PendingIntent playPIntent = PendingIntent.getActivity(this, 0, LastRecordHelper.getOpenIntent(this, file, "video/mp4"), PendingIntent.FLAG_CANCEL_CURRENT);
    PendingIntent sharePIntent = PendingIntent.getActivity(this, 0, LastRecordHelper.getShareIntent(this, file, "video/mp4"), PendingIntent.FLAG_CANCEL_CURRENT);
    PendingIntent deletePIntent = PendingIntent.getActivity(this, 0, LastRecordHelper.getDeleteIntent(this, false), PendingIntent.FLAG_CANCEL_CURRENT);
    long timeElapsed = SystemClock.elapsedRealtime() - mStartTime;
    LastRecordHelper.setLastItem(this, file, timeElapsed, false);
    Log.i(LOGTAG, "Video complete: " + file);
    return new NotificationCompat.Builder(this, SCREENCAST_NOTIFICATION_CHANNEL).setWhen(System.currentTimeMillis()).setSmallIcon(R.drawable.ic_action_screen_record).setContentTitle(getString(R.string.screen_notification_message_done)).setContentText(getString(R.string.screen_notification_message, DateUtils.formatElapsedTime(timeElapsed / 1000))).addAction(R.drawable.ic_play, getString(R.string.play), playPIntent).addAction(R.drawable.ic_share, getString(R.string.share), sharePIntent).addAction(R.drawable.ic_delete, getString(R.string.delete), deletePIntent).setContentIntent(pi);
}
#end_block

#method_before
public static Intent getDeleteIntent(Context context, boolean isSound) {
    Intent intent = new Intent(context, DialogActivity.class);
    intent.putExtra(DialogActivity.EXTRA_TITLE, R.string.sound_last_title);
    intent.putExtra(DialogActivity.EXTRA_LAST_SOUND, isSound);
    intent.putExtra(DialogActivity.EXTRA_DELETE_LAST_RECORDING, true);
    return intent;
}
#method_after
public static Intent getDeleteIntent(Context context, boolean isSound) {
    Intent intent = new Intent(context, DialogActivity.class);
    intent.putExtra(DialogActivity.EXTRA_TITLE, isSound ? R.string.sound_last_title : R.string.screen_last_title);
    intent.putExtra(DialogActivity.EXTRA_LAST_SCREEN, !isSound);
    intent.putExtra(DialogActivity.EXTRA_LAST_SOUND, isSound);
    intent.putExtra(DialogActivity.EXTRA_DELETE_LAST_RECORDING, true);
    return intent;
}
#end_block

#method_before
@Override
protected Object responseCallList(Parcel p) {
    int num;
    int voiceSettings;
    ArrayList<DriverCall> response;
    DriverCall dc;
    num = p.readInt();
    response = new ArrayList<DriverCall>(num);
    if (RILJ_LOGV) {
        riljLog("responseCallList: num=" + num + " mEmergencyCallbackModeRegistrant=" + mEmergencyCallbackModeRegistrant + " mTestingEmergencyCall=" + mTestingEmergencyCall.get());
    }
    for (int i = 0; i < num; i++) {
        dc = new DriverCall();
        dc.state = DriverCall.stateFromCLCC(p.readInt());
        dc.index = p.readInt() & 0xff;
        dc.TOA = p.readInt();
        dc.isMpty = (0 != p.readInt());
        dc.isMT = (0 != p.readInt());
        dc.als = p.readInt();
        dc.isVoice = (0 != p.readInt());
        // Samsung CallDetails
        int call_type = p.readInt();
        // Samsung CallDetails
        int call_domain = p.readInt();
        // Samsung CallDetails
        String csv = p.readString();
        dc.isVoicePrivacy = (0 != p.readInt());
        dc.number = p.readString();
        int np = p.readInt();
        dc.numberPresentation = DriverCall.presentationFromCLIP(np);
        dc.name = p.readString();
        dc.namePresentation = DriverCall.presentationFromCLIP(p.readInt());
        int uusInfoPresent = p.readInt();
        if (uusInfoPresent == 1) {
            dc.uusInfo = new UUSInfo();
            dc.uusInfo.setType(p.readInt());
            dc.uusInfo.setDcs(p.readInt());
            byte[] userData = p.createByteArray();
            dc.uusInfo.setUserData(userData);
            riljLogv(String.format("Incoming UUS : type=%d, dcs=%d, length=%d", dc.uusInfo.getType(), dc.uusInfo.getDcs(), dc.uusInfo.getUserData().length));
            riljLogv("Incoming UUS : data (string)=" + new String(dc.uusInfo.getUserData()));
            riljLogv("Incoming UUS : data (hex): " + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
        } else {
            riljLogv("Incoming UUS : NOT present!");
        }
        // Make sure there's a leading + on addresses with a TOA of 145
        dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
        response.add(dc);
        if (dc.isVoicePrivacy) {
            mVoicePrivacyOnRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is enabled");
        } else {
            mVoicePrivacyOffRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is disabled");
        }
    }
    Collections.sort(response);
    if ((num == 0) && mTestingEmergencyCall.getAndSet(false)) {
        if (mEmergencyCallbackModeRegistrant != null) {
            riljLog("responseCallList: call ended, testing emergency call," + " notify ECM Registrants");
            mEmergencyCallbackModeRegistrant.notifyRegistrant();
        }
    }
    return response;
}
#method_after
@Override
protected Object responseCallList(Parcel p) {
    int num;
    int voiceSettings;
    ArrayList<DriverCall> response;
    DriverCall dc;
    num = p.readInt();
    response = new ArrayList<DriverCall>(num);
    if (RILJ_LOGV) {
        riljLog("responseCallList: num=" + num + " mEmergencyCallbackModeRegistrant=" + mEmergencyCallbackModeRegistrant + " mTestingEmergencyCall=" + mTestingEmergencyCall.get());
    }
    for (int i = 0; i < num; i++) {
        dc = new DriverCall();
        dc.state = DriverCall.stateFromCLCC(p.readInt());
        dc.index = p.readInt() & 0xff;
        dc.TOA = p.readInt();
        dc.isMpty = (0 != p.readInt());
        dc.isMT = (0 != p.readInt());
        dc.als = p.readInt();
        voiceSettings = p.readInt();
        dc.isVoice = (0 != voiceSettings);
        // Samsung CallDetails
        int call_type = p.readInt();
        // Samsung CallDetails
        int call_domain = p.readInt();
        // Samsung CallDetails
        String csv = p.readString();
        dc.isVoicePrivacy = (0 != p.readInt());
        dc.number = p.readString();
        int np = p.readInt();
        dc.numberPresentation = DriverCall.presentationFromCLIP(np);
        dc.name = p.readString();
        dc.namePresentation = DriverCall.presentationFromCLIP(p.readInt());
        int uusInfoPresent = p.readInt();
        if (uusInfoPresent == 1) {
            dc.uusInfo = new UUSInfo();
            dc.uusInfo.setType(p.readInt());
            dc.uusInfo.setDcs(p.readInt());
            byte[] userData = p.createByteArray();
            dc.uusInfo.setUserData(userData);
            riljLogv(String.format("Incoming UUS : type=%d, dcs=%d, length=%d", dc.uusInfo.getType(), dc.uusInfo.getDcs(), dc.uusInfo.getUserData().length));
            riljLogv("Incoming UUS : data (string)=" + new String(dc.uusInfo.getUserData()));
            riljLogv("Incoming UUS : data (hex): " + IccUtils.bytesToHexString(dc.uusInfo.getUserData()));
        } else {
            riljLogv("Incoming UUS : NOT present!");
        }
        // Make sure there's a leading + on addresses with a TOA of 145
        dc.number = PhoneNumberUtils.stringFromStringAndTOA(dc.number, dc.TOA);
        response.add(dc);
        if (dc.isVoicePrivacy) {
            mVoicePrivacyOnRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is enabled");
        } else {
            mVoicePrivacyOffRegistrants.notifyRegistrants();
            riljLog("InCall VoicePrivacy is disabled");
        }
    }
    Collections.sort(response);
    if ((num == 0) && mTestingEmergencyCall.getAndSet(false)) {
        if (mEmergencyCallbackModeRegistrant != null) {
            riljLog("responseCallList: call ended, testing emergency call," + " notify ECM Registrants");
            mEmergencyCallbackModeRegistrant.notifyRegistrant();
        }
    }
    return response;
}
#end_block

#method_before
public static void disableComponentsForMissingFeatures(Context context) {
    disableComponent(context, BluetoothSetupActivity.class);
    if (!hasFingerprint(context)) {
        disableComponent(context, FingerprintActivity.class);
    }
    if (!hasTelephony(context)) {
        disableComponent(context, MobileDataActivity.class);
        disableComponent(context, SimMissingActivity.class);
        disableComponent(context, ChooseDataSimActivity.class);
    } else if (!SetupWizardUtils.isMultiSimDevice(context)) {
        disableComponent(context, ChooseDataSimActivity.class);
    }
    ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
    if (!SetupWizardUtils.hasWifi(context) || (cm.getActiveNetworkInfo() != null && cm.getActiveNetworkInfo().getType() == ConnectivityManager.TYPE_ETHERNET)) {
        disableComponent(context, WifiSetupActivity.class);
    }
    // unprovisioned. Disable it for now.
    if (hasLeanback(context) && PackageManagerUtils.isAppInstalled(context, GMS_TV_SUW_PACKAGE)) {
        disableApplication(context, GMS_TV_SUW_PACKAGE);
    }
}
#method_after
public static void disableComponentsForMissingFeatures(Context context) {
    if (!hasLeanback(context)) {
        disableComponent(context, BluetoothSetupActivity.class);
    }
    if (!hasFingerprint(context)) {
        disableComponent(context, FingerprintActivity.class);
    }
    if (!hasTelephony(context)) {
        disableComponent(context, MobileDataActivity.class);
        disableComponent(context, SimMissingActivity.class);
        disableComponent(context, ChooseDataSimActivity.class);
    }
    if (!SetupWizardUtils.isMultiSimDevice(context)) {
        disableComponent(context, ChooseDataSimActivity.class);
    } else if (simMissing()) {
        disableComponent(context, MobileDataActivity.class);
        disableComponent(context, ChooseDataSimActivity.class);
    }
    if (!SetupWizardUtils.hasWifi(context) || isEthernetConnected(context)) {
        disableComponent(context, WifiSetupActivity.class);
    }
    // unprovisioned. Disable it for now.
    if (hasLeanback(context) && PackageManagerUtils.isAppInstalled(context, GMS_TV_SUW_PACKAGE)) {
        disableApplication(context, GMS_TV_SUW_PACKAGE);
    }
}
#end_block

#method_before
private void applyLidSwitchState() {
    if (mLidState == LID_CLOSED && mLidControlsSleep) {
        mPowerManager.goToSleep(SystemClock.uptimeMillis(), PowerManager.GO_TO_SLEEP_REASON_LID_SWITCH, PowerManager.GO_TO_SLEEP_FLAG_NO_DOZE);
    } else if (mLidState == LID_CLOSED && mLidControlsScreenLock) {
        mWindowManagerFuncs.lockDeviceNow();
    }
    synchronized (mLock) {
        updateWakeGestureListenerLp();
    }
}
#method_after
private void applyLidSwitchState() {
    if (mLidState == LID_CLOSED && mLidControlsSleep) {
        mPowerManager.goToSleep(SystemClock.uptimeMillis(), PowerManager.GO_TO_SLEEP_REASON_LID_SWITCH, PowerManager.GO_TO_SLEEP_FLAG_NO_DOZE);
    } else if (mLidState == LID_CLOSED && mLidControlsScreenLock) {
        mWindowManagerFuncs.lockDeviceNow();
    }
    synchronized (mLock) {
        updateWakeGestureListenerLp();
    }
    sendLidChangeBroadcast();
}
#end_block

#method_before
void updateMwi(int subId, boolean visible, boolean enableNotificationSound) {
    if (!PhoneGlobals.sVoiceCapable) {
        // Do not show the message waiting indicator on devices which are not voice capable.
        // These events *should* be blocked at the telephony layer for such devices.
        Log.w(LOG_TAG, "Called updateMwi() on non-voice-capable device! Ignoring...");
        return;
    }
    int[] mwiIcon = { R.drawable.stat_notify_voicemail_sub1, R.drawable.stat_notify_voicemail_sub2 };
    Phone phone = PhoneGlobals.getPhone(subId);
    if (phone == null) {
        Log.w(LOG_TAG, "updateMwi: phone is null, returning...");
        return;
    }
    int phoneId = phone.getPhoneId();
    int notificationId = getNotificationId(VOICEMAIL_NOTIFICATION, phoneId);
    if (visible && phone != null && shouldCheckVisualVoicemailConfigurationForMwi(subId)) {
        VoicemailStatusQueryHelper queryHelper = new VoicemailStatusQueryHelper(mContext);
        PhoneAccountHandle phoneAccount = PhoneUtils.makePstnPhoneAccountHandle(phone);
        if (queryHelper.isVoicemailSourceConfigured(phoneAccount)) {
            Log.v(LOG_TAG, "Source configured for visual voicemail, hiding mwi.");
            // MWI may not be suppressed if the PIN is not set on VVM3 because it is also a
            // "Not OK" configuration state. But VVM3 never send a MWI after the service is
            // activated so this should be fine.
            // TODO(twyen): once unbundled the client should be able to set a flag to suppress
            // MWI, instead of letting the NotificationMgr try to interpret the states.
            visible = false;
        }
    }
    boolean notifProp = mApp.getResources().getBoolean(R.bool.sprint_mwi_quirk);
    boolean notifOption = CMSettings.System.getInt(mApp.getContentResolver(), CMSettings.System.ENABLE_MWI_NOTIFICATION, 0) == 1;
    if (notifProp && !notifOption) {
        // sprint_mwi_quirk is true, and ENABLE_MWI_NOTIFICATION is unchecked or unset (false)
        // hide the mwi, but log if we're debugging.
        visible = false;
        if (DBG)
            log("updateMwi(): mwi_notification is disabled. Ignoring...");
        return;
    }
    Log.i(LOG_TAG, "updateMwi(): subId " + subId + " update to " + visible);
    mMwiVisible.put(subId, visible);
    if (visible) {
        if (phone == null) {
            Log.w(LOG_TAG, "Found null phone for: " + subId);
            return;
        }
        SubscriptionInfo subInfo = mSubscriptionManager.getActiveSubscriptionInfo(subId);
        if (subInfo == null) {
            Log.w(LOG_TAG, "Found null subscription info for: " + subId);
            return;
        }
        int resId = android.R.drawable.stat_notify_voicemail;
        if (mTelephonyManager.getPhoneCount() > 1) {
            resId = mwiIcon[phoneId];
        }
        // This Notification can get a lot fancier once we have more
        // information about the current voicemail messages.
        // (For example, the current voicemail system can't tell
        // us the caller-id or timestamp of a message, or tell us the
        // message count.)
        // But for now, the UI is ultra-simple: if the MWI indication
        // is supposed to be visible, just show a single generic
        // notification.
        String notificationTitle = mContext.getString(R.string.notification_voicemail_title);
        String vmNumber = phone.getVoiceMailNumber();
        if (DBG)
            log("- got vm number: '" + vmNumber + "'");
        // SubscriptionListener in CallNotifier will update this once the SIM is loaded.
        if ((vmNumber == null) && !phone.getIccRecordsLoaded()) {
            if (DBG)
                log("- Null vm number: SIM records not loaded (yet)...");
            return;
        }
        Integer vmCount = null;
        if (TelephonyCapabilities.supportsVoiceMessageCount(phone)) {
            vmCount = phone.getVoiceMessageCount();
            String titleFormat = mContext.getString(R.string.notification_voicemail_title_count);
            notificationTitle = String.format(titleFormat, vmCount);
        }
        // This pathway only applies to PSTN accounts; only SIMS have subscription ids.
        PhoneAccountHandle phoneAccountHandle = PhoneUtils.makePstnPhoneAccountHandle(phone);
        Intent intent;
        String notificationText;
        boolean isSettingsIntent = TextUtils.isEmpty(vmNumber);
        if (isSettingsIntent) {
            notificationText = mContext.getString(R.string.notification_voicemail_no_vm_number);
            // If the voicemail number if unknown, instead of calling voicemail, take the user
            // to the voicemail settings.
            notificationText = mContext.getString(R.string.notification_voicemail_no_vm_number);
            intent = new Intent(VoicemailSettingsActivity.ACTION_ADD_VOICEMAIL);
            intent.putExtra(SubscriptionInfoHelper.SUB_ID_EXTRA, subId);
            intent.setClass(mContext, VoicemailSettingsActivity.class);
        } else {
            if (mTelephonyManager.getPhoneCount() > 1) {
                notificationText = subInfo.getDisplayName().toString();
            } else {
                notificationText = String.format(mContext.getString(R.string.notification_voicemail_text_format), PhoneNumberUtils.formatNumber(vmNumber));
            }
            intent = new Intent(Intent.ACTION_CALL, Uri.fromParts(PhoneAccount.SCHEME_VOICEMAIL, "", null));
            intent.putExtra(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE, phoneAccountHandle);
        }
        PendingIntent pendingIntent = PendingIntent.getActivity(mContext, subId, /* requestCode */
        intent, 0);
        Uri ringtoneUri = null;
        if (enableNotificationSound) {
            ringtoneUri = VoicemailNotificationSettingsUtil.getRingtoneUri(phone);
        }
        Resources res = mContext.getResources();
        PersistableBundle carrierConfig = PhoneGlobals.getInstance().getCarrierConfigForSubId(subId);
        Notification.Builder builder = new Notification.Builder(mContext);
        builder.setSmallIcon(resId).setWhen(System.currentTimeMillis()).setColor(subInfo.getIconTint()).setContentTitle(notificationTitle).setContentText(notificationText).setContentIntent(pendingIntent).setSound(ringtoneUri).setColor(res.getColor(R.color.dialer_theme_color)).setOngoing(carrierConfig.getBoolean(CarrierConfigManager.KEY_VOICEMAIL_NOTIFICATION_PERSISTENT_BOOL));
        // reading it by clear or swipe option.
        if (mContext.getResources().getBoolean(R.bool.config_show_vm_notification_always)) {
            builder.setOngoing(true);
        }
        if (VoicemailNotificationSettingsUtil.isVibrationEnabled(phone)) {
            builder.setDefaults(Notification.DEFAULT_VIBRATE);
        }
        final Notification notification = builder.build();
        List<UserInfo> users = mUserManager.getUsers(true);
        for (int i = 0; i < users.size(); i++) {
            final UserInfo user = users.get(i);
            final UserHandle userHandle = user.getUserHandle();
            if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_OUTGOING_CALLS, userHandle) && !user.isManagedProfile()) {
                if (!sendNotificationCustomComponent(vmCount, vmNumber, pendingIntent, isSettingsIntent)) {
                    mNotificationManager.notifyAsUser(Integer.toString(subId), /* tag */
                    notificationId, notification, userHandle);
                }
            }
        }
    } else {
        if (!sendNotificationCustomComponent(0, null, null, false)) {
            mNotificationManager.cancelAsUser(Integer.toString(subId), /* tag */
            notificationId, UserHandle.ALL);
        }
    }
}
#method_after
void updateMwi(int subId, boolean visible, boolean enableNotificationSound) {
    if (!PhoneGlobals.sVoiceCapable) {
        // Do not show the message waiting indicator on devices which are not voice capable.
        // These events *should* be blocked at the telephony layer for such devices.
        Log.w(LOG_TAG, "Called updateMwi() on non-voice-capable device! Ignoring...");
        return;
    }
    int[] mwiIcon = { R.drawable.stat_notify_voicemail_sub1, R.drawable.stat_notify_voicemail_sub2 };
    Phone phone = PhoneGlobals.getPhone(subId);
    if (phone == null) {
        Log.w(LOG_TAG, "updateMwi: phone is null, returning...");
        return;
    }
    int phoneId = phone.getPhoneId();
    int notificationId = getNotificationId(VOICEMAIL_NOTIFICATION, phoneId);
    if (visible && phone != null && shouldCheckVisualVoicemailConfigurationForMwi(subId)) {
        VoicemailStatusQueryHelper queryHelper = new VoicemailStatusQueryHelper(mContext);
        PhoneAccountHandle phoneAccount = PhoneUtils.makePstnPhoneAccountHandle(phone);
        if (queryHelper.isVoicemailSourceConfigured(phoneAccount)) {
            Log.v(LOG_TAG, "Source configured for visual voicemail, hiding mwi.");
            // MWI may not be suppressed if the PIN is not set on VVM3 because it is also a
            // "Not OK" configuration state. But VVM3 never send a MWI after the service is
            // activated so this should be fine.
            // TODO(twyen): once unbundled the client should be able to set a flag to suppress
            // MWI, instead of letting the NotificationMgr try to interpret the states.
            visible = false;
        }
    }
    CarrierConfigManager ccm = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (ccm == null) {
        Log.e(LOG_TAG, "Unable to get carrier config service");
    } else {
        PersistableBundle cc = ccm.getConfigForSubId(subId);
        if (cc == null) {
            Log.e(LOG_TAG, "Unable to get carrier config");
        } else {
            if (cc.getBoolean("sprint_mwi_quirk")) {
                Log.v(LOG_TAG, "sprint_mwi_quirk is set, hiding mwi");
                visible = false;
            }
        }
    }
    Log.i(LOG_TAG, "updateMwi(): subId " + subId + " update to " + visible);
    mMwiVisible.put(subId, visible);
    if (visible) {
        if (phone == null) {
            Log.w(LOG_TAG, "Found null phone for: " + subId);
            return;
        }
        SubscriptionInfo subInfo = mSubscriptionManager.getActiveSubscriptionInfo(subId);
        if (subInfo == null) {
            Log.w(LOG_TAG, "Found null subscription info for: " + subId);
            return;
        }
        int resId = android.R.drawable.stat_notify_voicemail;
        if (mTelephonyManager.getPhoneCount() > 1) {
            resId = mwiIcon[phoneId];
        }
        // This Notification can get a lot fancier once we have more
        // information about the current voicemail messages.
        // (For example, the current voicemail system can't tell
        // us the caller-id or timestamp of a message, or tell us the
        // message count.)
        // But for now, the UI is ultra-simple: if the MWI indication
        // is supposed to be visible, just show a single generic
        // notification.
        String notificationTitle = mContext.getString(R.string.notification_voicemail_title);
        String vmNumber = phone.getVoiceMailNumber();
        if (DBG)
            log("- got vm number: '" + vmNumber + "'");
        // SubscriptionListener in CallNotifier will update this once the SIM is loaded.
        if ((vmNumber == null) && !phone.getIccRecordsLoaded()) {
            if (DBG)
                log("- Null vm number: SIM records not loaded (yet)...");
            return;
        }
        Integer vmCount = null;
        if (TelephonyCapabilities.supportsVoiceMessageCount(phone)) {
            vmCount = phone.getVoiceMessageCount();
            String titleFormat = mContext.getString(R.string.notification_voicemail_title_count);
            notificationTitle = String.format(titleFormat, vmCount);
        }
        // This pathway only applies to PSTN accounts; only SIMS have subscription ids.
        PhoneAccountHandle phoneAccountHandle = PhoneUtils.makePstnPhoneAccountHandle(phone);
        Intent intent;
        String notificationText;
        boolean isSettingsIntent = TextUtils.isEmpty(vmNumber);
        if (isSettingsIntent) {
            notificationText = mContext.getString(R.string.notification_voicemail_no_vm_number);
            // If the voicemail number if unknown, instead of calling voicemail, take the user
            // to the voicemail settings.
            notificationText = mContext.getString(R.string.notification_voicemail_no_vm_number);
            intent = new Intent(VoicemailSettingsActivity.ACTION_ADD_VOICEMAIL);
            intent.putExtra(SubscriptionInfoHelper.SUB_ID_EXTRA, subId);
            intent.setClass(mContext, VoicemailSettingsActivity.class);
        } else {
            if (mTelephonyManager.getPhoneCount() > 1) {
                notificationText = subInfo.getDisplayName().toString();
            } else {
                notificationText = String.format(mContext.getString(R.string.notification_voicemail_text_format), PhoneNumberUtils.formatNumber(vmNumber));
            }
            intent = new Intent(Intent.ACTION_CALL, Uri.fromParts(PhoneAccount.SCHEME_VOICEMAIL, "", null));
            intent.putExtra(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE, phoneAccountHandle);
        }
        PendingIntent pendingIntent = PendingIntent.getActivity(mContext, subId, /* requestCode */
        intent, 0);
        Uri ringtoneUri = null;
        if (enableNotificationSound) {
            ringtoneUri = VoicemailNotificationSettingsUtil.getRingtoneUri(phone);
        }
        Resources res = mContext.getResources();
        PersistableBundle carrierConfig = PhoneGlobals.getInstance().getCarrierConfigForSubId(subId);
        Notification.Builder builder = new Notification.Builder(mContext);
        builder.setSmallIcon(resId).setWhen(System.currentTimeMillis()).setColor(subInfo.getIconTint()).setContentTitle(notificationTitle).setContentText(notificationText).setContentIntent(pendingIntent).setSound(ringtoneUri).setColor(res.getColor(R.color.dialer_theme_color)).setOngoing(carrierConfig.getBoolean(CarrierConfigManager.KEY_VOICEMAIL_NOTIFICATION_PERSISTENT_BOOL));
        // reading it by clear or swipe option.
        if (mContext.getResources().getBoolean(R.bool.config_show_vm_notification_always)) {
            builder.setOngoing(true);
        }
        if (VoicemailNotificationSettingsUtil.isVibrationEnabled(phone)) {
            builder.setDefaults(Notification.DEFAULT_VIBRATE);
        }
        final Notification notification = builder.build();
        List<UserInfo> users = mUserManager.getUsers(true);
        for (int i = 0; i < users.size(); i++) {
            final UserInfo user = users.get(i);
            final UserHandle userHandle = user.getUserHandle();
            if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_OUTGOING_CALLS, userHandle) && !user.isManagedProfile()) {
                if (!sendNotificationCustomComponent(vmCount, vmNumber, pendingIntent, isSettingsIntent)) {
                    mNotificationManager.notifyAsUser(Integer.toString(subId), /* tag */
                    notificationId, notification, userHandle);
                }
            }
        }
    } else {
        if (!sendNotificationCustomComponent(0, null, null, false)) {
            mNotificationManager.cancelAsUser(Integer.toString(subId), /* tag */
            notificationId, UserHandle.ALL);
        }
    }
}
#end_block

#method_before
public static boolean isSupported() {
    return FileUtils.isFileWritable(CONTROL_PATH);
}
#method_after
public static boolean isSupported() {
    return FileUtils.isFileReadable(LEVEL_PATH) && FileUtils.isFileWritable(LEVEL_PATH);
}
#end_block

#method_before
public static int getMaxIntensity() {
    return 3596;
}
#method_after
public static int getMaxIntensity() {
    return Integer.parseInt(FileUtils.readOneLine(MAX_PATH));
}
#end_block

#method_before
public static int getMinIntensity() {
    return 116;
}
#method_after
public static int getMinIntensity() {
    return Integer.parseInt(FileUtils.readOneLine(MIN_PATH));
}
#end_block

#method_before
public static int getCurIntensity() {
    return Integer.parseInt(FileUtils.readOneLine(CONTROL_PATH));
}
#method_after
public static int getCurIntensity() {
    return Integer.parseInt(FileUtils.readOneLine(LEVEL_PATH));
}
#end_block

#method_before
public static int getDefaultIntensity() {
    return 3300;
}
#method_after
public static int getDefaultIntensity() {
    return Integer.parseInt(FileUtils.readOneLine(DEFAULT_PATH));
}
#end_block

#method_before
public static boolean setIntensity(int intensity) {
    return FileUtils.writeLine(CONTROL_PATH, String.valueOf(intensity));
}
#method_after
public static boolean setIntensity(int intensity) {
    return FileUtils.writeLine(LEVEL_PATH, String.valueOf(intensity));
}
#end_block

#method_before
public static boolean readFromBuildConfigIfGestureInputEnabled(final Resources res) {
    if (!JniUtils.mHaveGestureLib) {
        return false;
    }
    return res.getBoolean(R.bool.config_gesture_input_enabled_by_build_config);
}
#method_after
public static boolean readFromBuildConfigIfGestureInputEnabled(final Resources res) {
    if (!JniUtils.sHaveGestureLib) {
        return false;
    }
    return res.getBoolean(R.bool.config_gesture_input_enabled_by_build_config);
}
#end_block

#method_before
public void setShakeToPlayEnabled(boolean enabled) {
    if (D) {
        Log.d(TAG, "ShakeToPlay status: " + enabled);
    }
    final SharedPreferences.Editor editor = mPreferences.edit();
    editor.putBoolean(PreferenceUtils.SHAKE_TO_PLAY, enabled);
    editor.apply();
    if (enabled) {
        if (mShakeDetector == null) {
            mShakeDetector = new ShakeDetector(mShakeDetectorListener);
        }
        // if song is already playing, start listening immediately
        if (isPlaying()) {
            startShakeDetector();
        }
    } else {
        stopShakeDetector(true);
    }
}
#method_after
public void setShakeToPlayEnabled(boolean enabled) {
    if (D) {
        Log.d(TAG, "ShakeToPlay status: " + enabled);
    }
    if (enabled) {
        if (mShakeDetector == null) {
            mShakeDetector = new ShakeDetector(mShakeDetectorListener);
        }
        // if song is already playing, start listening immediately
        if (isPlaying()) {
            startShakeDetector();
        }
    } else {
        stopShakeDetector(true);
    }
}
#end_block

#method_before
public void setLockscreenAlbumArt(boolean enabled) {
    mShowAlbumArtOnLockscreen = enabled;
    final SharedPreferences.Editor editor = mPreferences.edit();
    editor.putBoolean(PreferenceUtils.SHOW_ALBUM_ART_ON_LOCKSCREEN, enabled);
    editor.apply();
    notifyChange(META_CHANGED);
}
#method_after
public void setLockscreenAlbumArt(boolean enabled) {
    mShowAlbumArtOnLockscreen = enabled;
    notifyChange(META_CHANGED);
}
#end_block

#method_before
@Override
public void onReceivedTitle(WebView view, String title) {
    String url = view.getUrl();
    mEditTextExt.setTitle(title);
    mEditTextExt.setUrl(url);
    if (url.startsWith("https://")) {
        mEditTextExt.setText(title);
    } else {
        mEditTextExt.setText(url);
    }
    if (!mIncognito) {
        mHistoryHandler.addItem(new HistoryItem(title, url));
    }
}
#method_after
@Override
public void onReceivedTitle(WebView view, String title) {
    mUrlBarController.onTitleReceived(title);
    if (!mIncognito) {
        HistoryProvider.addOrUpdateItem(mActivity.getContentResolver(), title, view.getUrl());
    }
}
#end_block

#method_before
@Override
public void onReceivedIcon(WebView view, Bitmap icon) {
    mActivity.setColor(icon, mIncognito);
}
#method_after
@Override
public void onReceivedIcon(WebView view, Bitmap icon) {
    mActivity.onFaviconLoaded(icon);
}
#end_block

#method_before
@Override
public void loadUrl(String url) {
    String fixedUrl = UrlUtils.smartUrlFilter(url);
    if (fixedUrl != null) {
        super.loadUrl(fixedUrl);
        return;
    }
    String templateUri = PrefsUtils.getSearchEngine(mActivity);
    fixedUrl = UrlUtils.getFormattedUri(templateUri, url);
    if (fixedUrl != null) {
        super.loadUrl(fixedUrl);
    }
}
#method_after
@Override
public void loadUrl(String url) {
    mLastLoadedUrl = url;
    followUrl(url);
}
#end_block

#method_before
private void setup() {
    getSettings().setJavaScriptEnabled(PrefsUtils.getJavascript(mActivity));
    getSettings().setJavaScriptCanOpenWindowsAutomatically(PrefsUtils.getJavascript(mActivity));
    getSettings().setGeolocationEnabled(PrefsUtils.getLocation(mActivity));
    getSettings().setBuiltInZoomControls(true);
    getSettings().setDisplayZoomControls(false);
    setWebViewClient(new WebClient());
    setOnLongClickListener(new OnLongClickListener() {

        boolean shouldAllowDownload;

        @Override
        public boolean onLongClick(View v) {
            HitTestResult result = getHitTestResult();
            switch(result.getType()) {
                case HitTestResult.IMAGE_TYPE:
                case HitTestResult.SRC_IMAGE_ANCHOR_TYPE:
                    shouldAllowDownload = true;
                case HitTestResult.SRC_ANCHOR_TYPE:
                    mActivity.showSheetMenu(result.getExtra(), shouldAllowDownload);
                    shouldAllowDownload = false;
                    return true;
            }
            return false;
        }
    });
    setDownloadListener((url, userAgent, contentDescription, mimeType, contentLength) -> mActivity.downloadFileAsk(url, URLUtil.guessFileName(url, contentDescription, mimeType)));
    // Mobile: Remove "wv" from the WebView's user agent. Some websites don't work
    // properly if the browser reports itself as a simple WebView.
    // Desktop: Generate the desktop user agent starting from the mobile one so that
    // we always report the current engine version.
    Pattern pattern = Pattern.compile("([^)]+ \\()([^)]+)(\\) .*)");
    Matcher matcher = pattern.matcher(getSettings().getUserAgentString());
    if (matcher.matches()) {
        String mobileDevice = matcher.group(2).replace("; wv", "");
        mMobileUserAgent = matcher.group(1) + mobileDevice + matcher.group(3);
        mDesktopUserAgent = matcher.group(1) + DESKTOP_DEVICE + matcher.group(3);
        getSettings().setUserAgentString(mMobileUserAgent);
    } else {
        Log.e(TAG, "Couldn't parse the user agent");
        mMobileUserAgent = getSettings().getUserAgentString();
        mDesktopUserAgent = DESKTOP_USER_AGENT_FALLBACK;
    }
}
#method_after
private void setup() {
    getSettings().setJavaScriptEnabled(PrefsUtils.getJavascript(mActivity));
    getSettings().setJavaScriptCanOpenWindowsAutomatically(PrefsUtils.getJavascript(mActivity));
    getSettings().setGeolocationEnabled(PrefsUtils.getLocation(mActivity));
    getSettings().setSaveFormData(!mIncognito && PrefsUtils.getSaveFormData(mActivity));
    getSettings().setBuiltInZoomControls(true);
    getSettings().setDisplayZoomControls(false);
    getSettings().setAppCacheEnabled(!mIncognito);
    getSettings().setDatabaseEnabled(!mIncognito);
    getSettings().setDomStorageEnabled(!mIncognito);
    getSettings().setAppCachePath(mActivity.getDir("appcache", Context.MODE_PRIVATE).getPath());
    setOnLongClickListener(new OnLongClickListener() {

        boolean shouldAllowDownload;

        @Override
        public boolean onLongClick(View v) {
            HitTestResult result = getHitTestResult();
            switch(result.getType()) {
                case HitTestResult.IMAGE_TYPE:
                case HitTestResult.SRC_IMAGE_ANCHOR_TYPE:
                    shouldAllowDownload = true;
                case HitTestResult.SRC_ANCHOR_TYPE:
                    mActivity.showSheetMenu(result.getExtra(), shouldAllowDownload);
                    shouldAllowDownload = false;
                    return true;
            }
            return false;
        }
    });
    setDownloadListener((url, userAgent, contentDescription, mimeType, contentLength) -> mActivity.downloadFileAsk(url, contentDescription, mimeType));
    // Mobile: Remove "wv" from the WebView's user agent. Some websites don't work
    // properly if the browser reports itself as a simple WebView.
    // Desktop: Generate the desktop user agent starting from the mobile one so that
    // we always report the current engine version.
    Pattern pattern = Pattern.compile("([^)]+ \\()([^)]+)(\\) .*)");
    Matcher matcher = pattern.matcher(getSettings().getUserAgentString());
    if (matcher.matches()) {
        String mobileDevice = matcher.group(2).replace("; wv", "");
        mMobileUserAgent = matcher.group(1) + mobileDevice + matcher.group(3);
        mDesktopUserAgent = matcher.group(1) + DESKTOP_DEVICE + matcher.group(3).replace(" Mobile ", " ");
        getSettings().setUserAgentString(mMobileUserAgent);
    } else {
        Log.e(TAG, "Couldn't parse the user agent");
        mMobileUserAgent = getSettings().getUserAgentString();
        mDesktopUserAgent = DESKTOP_USER_AGENT_FALLBACK;
    }
    if (PrefsUtils.getDoNotTrack(mActivity)) {
        mRequestHeaders.put(HEADER_DNT, "1");
    }
}
#end_block

#method_before
public void init(WebViewExtActivity activity, EditTextExt editText, ProgressBar progressBar, boolean incognito) {
    mActivity = activity;
    mIncognito = incognito;
    ChromeClient chromeClient = new ChromeClient(activity, incognito);
    chromeClient.bindEditText(editText);
    chromeClient.bindProgressBar(progressBar);
    setWebChromeClient(chromeClient);
    setup();
}
#method_after
public void init(WebViewExtActivity activity, UrlBarController urlBarController, ProgressBar progressBar, boolean incognito) {
    mActivity = activity;
    mIncognito = incognito;
    ChromeClient chromeClient = new ChromeClient(activity, incognito, urlBarController, progressBar);
    setWebChromeClient(chromeClient);
    setWebViewClient(new WebClient(urlBarController));
    setup();
}
#end_block

#method_before
public static String getInstalledVersion() {
    return SystemProperties.get("ro.cm.version").toLowerCase();
}
#method_after
public static String getInstalledVersion() {
    return SystemProperties.get("ro.cm.version").toLowerCase(Locale.ROOT);
}
#end_block

#method_before
@Override
public void onBackPressed() {
    if (mSearchActive) {
        mSearchController.onCancel();
        mSearchActive = false;
    } else if (mCustomView != null) {
        onHideCustomView();
    } else if (mWebView.canGoBack()) {
        mWebView.goBack();
    } else {
        super.onBackPressed();
    }
}
#method_after
@Override
public void onBackPressed() {
    if (mSearchActive) {
        mSearchController.onCancel();
    } else if (mCustomView != null) {
        onHideCustomView();
    } else if (mWebView.canGoBack()) {
        mWebView.goBack();
    } else {
        super.onBackPressed();
    }
}
#end_block

#method_before
@Override
public void onCancelSearch() {
    findViewById(R.id.toolbar_search_page).setVisibility(View.GONE);
    findViewById(R.id.toolbar_search_bar).setVisibility(View.VISIBLE);
}
#method_after
@Override
public void onCancelSearch() {
    findViewById(R.id.toolbar_search_page).setVisibility(View.GONE);
    findViewById(R.id.toolbar_search_bar).setVisibility(View.VISIBLE);
    mSearchActive = false;
}
#end_block

#method_before
private void setup() {
    getSettings().setJavaScriptEnabled(PrefsUtils.getJavascript(mActivity));
    getSettings().setJavaScriptCanOpenWindowsAutomatically(PrefsUtils.getJavascript(mActivity));
    getSettings().setGeolocationEnabled(PrefsUtils.getLocation(mActivity));
    getSettings().setSaveFormData(PrefsUtils.getSaveFormData(mActivity) && !mIncognito);
    getSettings().setBuiltInZoomControls(true);
    getSettings().setDisplayZoomControls(false);
    if (!mIncognito) {
        getSettings().setAppCacheEnabled(true);
        getSettings().setDatabaseEnabled(true);
        getSettings().setDomStorageEnabled(true);
        getSettings().setAppCachePath(mActivity.getDir("appcache", 0).getPath());
    }
    setWebViewClient(new WebClient());
    setOnLongClickListener(new OnLongClickListener() {

        boolean shouldAllowDownload;

        @Override
        public boolean onLongClick(View v) {
            HitTestResult result = getHitTestResult();
            switch(result.getType()) {
                case HitTestResult.IMAGE_TYPE:
                case HitTestResult.SRC_IMAGE_ANCHOR_TYPE:
                    shouldAllowDownload = true;
                case HitTestResult.SRC_ANCHOR_TYPE:
                    mActivity.showSheetMenu(result.getExtra(), shouldAllowDownload);
                    shouldAllowDownload = false;
                    return true;
            }
            return false;
        }
    });
    setDownloadListener((url, userAgent, contentDescription, mimeType, contentLength) -> mActivity.downloadFileAsk(url, contentDescription, mimeType));
    // Mobile: Remove "wv" from the WebView's user agent. Some websites don't work
    // properly if the browser reports itself as a simple WebView.
    // Desktop: Generate the desktop user agent starting from the mobile one so that
    // we always report the current engine version.
    Pattern pattern = Pattern.compile("([^)]+ \\()([^)]+)(\\) .*)");
    Matcher matcher = pattern.matcher(getSettings().getUserAgentString());
    if (matcher.matches()) {
        String mobileDevice = matcher.group(2).replace("; wv", "");
        mMobileUserAgent = matcher.group(1) + mobileDevice + matcher.group(3);
        mDesktopUserAgent = matcher.group(1) + DESKTOP_DEVICE + matcher.group(3);
        getSettings().setUserAgentString(mMobileUserAgent);
    } else {
        Log.e(TAG, "Couldn't parse the user agent");
        mMobileUserAgent = getSettings().getUserAgentString();
        mDesktopUserAgent = DESKTOP_USER_AGENT_FALLBACK;
    }
    if (PrefsUtils.getDoNotTrack(mActivity)) {
        mRequestHeaders.put(HEADER_DNT, "1");
    }
}
#method_after
private void setup() {
    getSettings().setJavaScriptEnabled(PrefsUtils.getJavascript(mActivity));
    getSettings().setJavaScriptCanOpenWindowsAutomatically(PrefsUtils.getJavascript(mActivity));
    getSettings().setGeolocationEnabled(PrefsUtils.getLocation(mActivity));
    getSettings().setSaveFormData(!mIncognito && PrefsUtils.getSaveFormData(mActivity));
    getSettings().setBuiltInZoomControls(true);
    getSettings().setDisplayZoomControls(false);
    getSettings().setAppCacheEnabled(!mIncognito);
    getSettings().setDatabaseEnabled(!mIncognito);
    getSettings().setDomStorageEnabled(!mIncognito);
    getSettings().setAppCachePath(mActivity.getDir("appcache", Context.MODE_PRIVATE).getPath());
    setWebViewClient(new WebClient());
    setOnLongClickListener(new OnLongClickListener() {

        boolean shouldAllowDownload;

        @Override
        public boolean onLongClick(View v) {
            HitTestResult result = getHitTestResult();
            switch(result.getType()) {
                case HitTestResult.IMAGE_TYPE:
                case HitTestResult.SRC_IMAGE_ANCHOR_TYPE:
                    shouldAllowDownload = true;
                case HitTestResult.SRC_ANCHOR_TYPE:
                    mActivity.showSheetMenu(result.getExtra(), shouldAllowDownload);
                    shouldAllowDownload = false;
                    return true;
            }
            return false;
        }
    });
    setDownloadListener((url, userAgent, contentDescription, mimeType, contentLength) -> mActivity.downloadFileAsk(url, contentDescription, mimeType));
    // Mobile: Remove "wv" from the WebView's user agent. Some websites don't work
    // properly if the browser reports itself as a simple WebView.
    // Desktop: Generate the desktop user agent starting from the mobile one so that
    // we always report the current engine version.
    Pattern pattern = Pattern.compile("([^)]+ \\()([^)]+)(\\) .*)");
    Matcher matcher = pattern.matcher(getSettings().getUserAgentString());
    if (matcher.matches()) {
        String mobileDevice = matcher.group(2).replace("; wv", "");
        mMobileUserAgent = matcher.group(1) + mobileDevice + matcher.group(3);
        mDesktopUserAgent = matcher.group(1) + DESKTOP_DEVICE + matcher.group(3).replace(" Mobile ", " ");
        getSettings().setUserAgentString(mMobileUserAgent);
    } else {
        Log.e(TAG, "Couldn't parse the user agent");
        mMobileUserAgent = getSettings().getUserAgentString();
        mDesktopUserAgent = DESKTOP_USER_AGENT_FALLBACK;
    }
    if (PrefsUtils.getDoNotTrack(mActivity)) {
        mRequestHeaders.put(HEADER_DNT, "1");
    }
}
#end_block

#method_before
@Override
public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    getEmptyTextView().setText(R.string.wifi_advanced_not_available);
    if (mUnavailable) {
        getPreferenceScreen().removeAll();
    }
}
#method_after
@Override
public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    getEmptyTextView().setText(R.string.wifi_advanced_not_available);
    if (mUnavailable) {
        getPreferenceScreen().removeAll();
    } else {
        mWifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);
    }
}
#end_block

#method_before
@Override
public int addSubInfoRecord(String iccId, int slotId) {
    if (DBG)
        logdl("[addSubInfoRecord]+ iccId:" + SubscriptionInfo.givePrintableIccid(iccId) + " slotId:" + slotId);
    enforceModifyPhoneState("addSubInfoRecord");
    // Now that all security checks passes, perform the operation as ourselves.
    final long identity = Binder.clearCallingIdentity();
    try {
        if (iccId == null) {
            if (DBG)
                logdl("[addSubInfoRecord]- null iccId");
            return -1;
        }
        ContentResolver resolver = mContext.getContentResolver();
        Cursor cursor = resolver.query(SubscriptionManager.CONTENT_URI, new String[] { SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID, SubscriptionManager.SIM_SLOT_INDEX, SubscriptionManager.NAME_SOURCE }, SubscriptionManager.ICC_ID + "=?", new String[] { iccId }, null);
        int color = getUnusedColor(mContext.getOpPackageName());
        boolean setDisplayName = false;
        try {
            if (cursor == null || !cursor.moveToFirst()) {
                setDisplayName = true;
                ContentValues value = new ContentValues();
                value.put(SubscriptionManager.ICC_ID, iccId);
                // default SIM color differs between slots
                value.put(SubscriptionManager.COLOR, color);
                value.put(SubscriptionManager.SIM_SLOT_INDEX, slotId);
                value.put(SubscriptionManager.CARRIER_NAME, "");
                Uri uri = resolver.insert(SubscriptionManager.CONTENT_URI, value);
                if (DBG)
                    logdl("[addSubInfoRecord] New record created: " + uri);
            } else {
                int subId = cursor.getInt(0);
                int oldSimInfoId = cursor.getInt(1);
                int nameSource = cursor.getInt(2);
                ContentValues value = new ContentValues();
                if (slotId != oldSimInfoId) {
                    value.put(SubscriptionManager.SIM_SLOT_INDEX, slotId);
                }
                if (nameSource != SubscriptionManager.NAME_SOURCE_USER_INPUT) {
                    setDisplayName = true;
                }
                if (value.size() > 0) {
                    resolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
                }
                if (DBG)
                    logdl("[addSubInfoRecord] Record already exists");
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        cursor = resolver.query(SubscriptionManager.CONTENT_URI, null, SubscriptionManager.SIM_SLOT_INDEX + "=?", new String[] { String.valueOf(slotId) }, null);
        try {
            if (cursor != null && cursor.moveToFirst()) {
                do {
                    int subId = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID));
                    // If sSlotIdxToSubId already has a valid subId for a slotId/phoneId,
                    // do not add another subId for same slotId/phoneId.
                    Integer currentSubId = sSlotIdxToSubId.get(slotId);
                    if (currentSubId == null || !SubscriptionManager.isValidSubscriptionId(currentSubId)) {
                        // TODO While two subs active, if user deactivats first
                        // one, need to update the default subId with second one.
                        // FIXME: Currently we assume phoneId == slotId which in the future
                        // may not be true, for instance with multiple subs per slot.
                        // But is true at the moment.
                        sSlotIdxToSubId.put(slotId, subId);
                        int subIdCountMax = getActiveSubInfoCountMax();
                        int defaultSubId = getDefaultSubId();
                        if (DBG) {
                            logdl("[addSubInfoRecord]" + " sSlotIdxToSubId.size=" + sSlotIdxToSubId.size() + " slotId=" + slotId + " subId=" + subId + " defaultSubId=" + defaultSubId + " simCount=" + subIdCountMax);
                        }
                        // Set the default sub if not set or if single sim device
                        if (!SubscriptionManager.isValidSubscriptionId(defaultSubId) || subIdCountMax == 1 || (!isActiveSubId(defaultSubId))) {
                            setDefaultFallbackSubId(subId);
                        }
                        // If single sim device, set this subscription as the default for everything
                        if (subIdCountMax == 1) {
                            if (DBG) {
                                logdl("[addSubInfoRecord] one sim set defaults to subId=" + subId);
                            }
                            setDefaultDataSubId(subId);
                            setDefaultSmsSubId(subId);
                            setDefaultVoiceSubId(subId);
                        }
                        // FIXME: Workaround the scenario where default sms subid is not
                        // being set externally
                        // CYNGNOS-2185
                        int phoneId = SubscriptionController.getInstance().getPhoneId(getDefaultSmsSubId());
                        if (phoneId < 0 || phoneId >= TelephonyManager.getDefault().getPhoneCount()) {
                            Rlog.i(LOG_TAG, "Subscription is invalid. Set default to " + subId);
                            if (mUserPreferredSmsSubId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
                                mUserPreferredSmsSubId = getDefaultSmsSubId();
                            }
                            setDefaultSmsSubId(subId);
                            PhoneFactory.setSMSPromptEnabled(subIdCountMax > 1);
                        } else if (subId == mUserPreferredSmsSubId) {
                            Rlog.i(LOG_TAG, "SMS subscription was different than user choice," + " set to " + subId);
                            setDefaultSmsSubId(subId);
                        }
                    } else {
                        if (DBG) {
                            logdl("[addSubInfoRecord] currentSubId != null" + " && currentSubId is valid, IGNORE");
                        }
                    }
                    if (DBG)
                        logdl("[addSubInfoRecord] hashmap(" + slotId + "," + subId + ")");
                } while (cursor.moveToNext());
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        // Set Display name after sub id is set above so as to get valid simCarrierName
        int[] subIds = getSubId(slotId);
        if (subIds == null || subIds.length == 0) {
            if (DBG) {
                logdl("[addSubInfoRecord]- getSubId failed subIds == null || length == 0 subIds=" + subIds);
            }
            return -1;
        }
        if (setDisplayName) {
            String simCarrierName = mTelephonyManager.getSimOperatorName(subIds[0]);
            String nameToSet;
            if (!TextUtils.isEmpty(simCarrierName)) {
                nameToSet = simCarrierName;
            } else {
                nameToSet = "CARD " + Integer.toString(slotId + 1);
            }
            ContentValues value = new ContentValues();
            value.put(SubscriptionManager.DISPLAY_NAME, nameToSet);
            resolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subIds[0]), null);
            if (DBG)
                logdl("[addSubInfoRecord] sim name = " + nameToSet);
        }
        // Once the records are loaded, notify DcTracker
        sPhones[slotId].updateDataConnectionTracker();
        if (DBG)
            logdl("[addSubInfoRecord]- info size=" + sSlotIdxToSubId.size());
        if (PhoneFactory.getSubscriptionInfoUpdater().getInsertedSimCount() <= 1) {
            PhoneFactory.setSMSPromptEnabled(false);
        }
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
    return 0;
}
#method_after
@Override
public int addSubInfoRecord(String iccId, int slotId) {
    if (DBG)
        logdl("[addSubInfoRecord]+ iccId:" + SubscriptionInfo.givePrintableIccid(iccId) + " slotId:" + slotId);
    enforceModifyPhoneState("addSubInfoRecord");
    // Now that all security checks passes, perform the operation as ourselves.
    final long identity = Binder.clearCallingIdentity();
    try {
        if (iccId == null) {
            if (DBG)
                logdl("[addSubInfoRecord]- null iccId");
            return -1;
        }
        ContentResolver resolver = mContext.getContentResolver();
        Cursor cursor = resolver.query(SubscriptionManager.CONTENT_URI, new String[] { SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID, SubscriptionManager.SIM_SLOT_INDEX, SubscriptionManager.NAME_SOURCE }, SubscriptionManager.ICC_ID + "=?", new String[] { iccId }, null);
        int color = getUnusedColor(mContext.getOpPackageName());
        boolean setDisplayName = false;
        try {
            if (cursor == null || !cursor.moveToFirst()) {
                setDisplayName = true;
                ContentValues value = new ContentValues();
                value.put(SubscriptionManager.ICC_ID, iccId);
                // default SIM color differs between slots
                value.put(SubscriptionManager.COLOR, color);
                value.put(SubscriptionManager.SIM_SLOT_INDEX, slotId);
                value.put(SubscriptionManager.CARRIER_NAME, "");
                Uri uri = resolver.insert(SubscriptionManager.CONTENT_URI, value);
                if (DBG)
                    logdl("[addSubInfoRecord] New record created: " + uri);
            } else {
                int subId = cursor.getInt(0);
                int oldSimInfoId = cursor.getInt(1);
                int nameSource = cursor.getInt(2);
                ContentValues value = new ContentValues();
                if (slotId != oldSimInfoId) {
                    value.put(SubscriptionManager.SIM_SLOT_INDEX, slotId);
                }
                if (nameSource != SubscriptionManager.NAME_SOURCE_USER_INPUT) {
                    setDisplayName = true;
                }
                if (value.size() > 0) {
                    resolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subId), null);
                }
                if (DBG)
                    logdl("[addSubInfoRecord] Record already exists");
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        cursor = resolver.query(SubscriptionManager.CONTENT_URI, null, SubscriptionManager.SIM_SLOT_INDEX + "=?", new String[] { String.valueOf(slotId) }, null);
        try {
            if (cursor != null && cursor.moveToFirst()) {
                do {
                    int subId = cursor.getInt(cursor.getColumnIndexOrThrow(SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID));
                    // If sSlotIdxToSubId already has a valid subId for a slotId/phoneId,
                    // do not add another subId for same slotId/phoneId.
                    Integer currentSubId = sSlotIdxToSubId.get(slotId);
                    if (currentSubId == null || !SubscriptionManager.isValidSubscriptionId(currentSubId)) {
                        // TODO While two subs active, if user deactivats first
                        // one, need to update the default subId with second one.
                        // FIXME: Currently we assume phoneId == slotId which in the future
                        // may not be true, for instance with multiple subs per slot.
                        // But is true at the moment.
                        sSlotIdxToSubId.put(slotId, subId);
                        int subIdCountMax = getActiveSubInfoCountMax();
                        int defaultSubId = getDefaultSubId();
                        if (DBG) {
                            logdl("[addSubInfoRecord]" + " sSlotIdxToSubId.size=" + sSlotIdxToSubId.size() + " slotId=" + slotId + " subId=" + subId + " defaultSubId=" + defaultSubId + " simCount=" + subIdCountMax);
                        }
                        // Set the default sub if not set or if single sim device
                        if (!SubscriptionManager.isValidSubscriptionId(defaultSubId) || subIdCountMax == 1 || (!isActiveSubId(defaultSubId))) {
                            setDefaultFallbackSubId(subId);
                        }
                        // If single sim device, set this subscription as the default for everything
                        if (subIdCountMax == 1) {
                            if (DBG) {
                                logdl("[addSubInfoRecord] one sim set defaults to subId=" + subId);
                            }
                            setDefaultDataSubId(subId);
                            setDefaultSmsSubId(subId);
                            setDefaultVoiceSubId(subId);
                        }
                        // FIXME: Workaround the scenario where default sms subid is not
                        // being set externally
                        // CYNGNOS-2185
                        int phoneId = SubscriptionController.getInstance().getPhoneId(getDefaultSmsSubId());
                        if (phoneId < 0 || phoneId >= TelephonyManager.getDefault().getPhoneCount()) {
                            Rlog.i(LOG_TAG, "Subscription is invalid. Set default to " + subId);
                            mUserPreferredSmsSubId = getDefaultSmsSubId();
                            setDefaultSmsSubId(subId);
                            PhoneFactory.setSMSPromptEnabled(subIdCountMax > 1);
                        } else if (subId == mUserPreferredSmsSubId) {
                            Rlog.i(LOG_TAG, "SMS subscription was different than user choice");
                            setDefaultSmsSubId(subId);
                            mUserPreferredSmsSubId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
                        }
                    } else {
                        if (DBG) {
                            logdl("[addSubInfoRecord] currentSubId != null" + " && currentSubId is valid, IGNORE");
                        }
                    }
                    if (DBG)
                        logdl("[addSubInfoRecord] hashmap(" + slotId + "," + subId + ")");
                } while (cursor.moveToNext());
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        // Reset user choice for defaultSmsSubId in case only one Sim is inserted
        if (sSlotIdxToSubId.size() == 1) {
            Rlog.i(LOG_TAG, "Only one SIM found, resetting user preferred SMS sub");
            mUserPreferredSmsSubId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        }
        // Set Display name after sub id is set above so as to get valid simCarrierName
        int[] subIds = getSubId(slotId);
        if (subIds == null || subIds.length == 0) {
            if (DBG) {
                logdl("[addSubInfoRecord]- getSubId failed subIds == null || length == 0 subIds=" + subIds);
            }
            return -1;
        }
        if (setDisplayName) {
            String simCarrierName = mTelephonyManager.getSimOperatorName(subIds[0]);
            String nameToSet;
            if (!TextUtils.isEmpty(simCarrierName)) {
                nameToSet = simCarrierName;
            } else {
                nameToSet = "CARD " + Integer.toString(slotId + 1);
            }
            ContentValues value = new ContentValues();
            value.put(SubscriptionManager.DISPLAY_NAME, nameToSet);
            resolver.update(SubscriptionManager.CONTENT_URI, value, SubscriptionManager.UNIQUE_KEY_SUBSCRIPTION_ID + "=" + Long.toString(subIds[0]), null);
            if (DBG)
                logdl("[addSubInfoRecord] sim name = " + nameToSet);
        }
        // Once the records are loaded, notify DcTracker
        sPhones[slotId].updateDataConnectionTracker();
        if (DBG)
            logdl("[addSubInfoRecord]- info size=" + sSlotIdxToSubId.size());
        if (PhoneFactory.getSubscriptionInfoUpdater().getInsertedSimCount() <= 1) {
            PhoneFactory.setSMSPromptEnabled(false);
        }
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
    return 0;
}
#end_block

#method_before
@Override
public void onReceivedTitle(WebView view, String title) {
    mEditText.setText(view.getUrl());
    if (!mIncognito) {
        mHistoryHandler.addItem(new HistoryItem(title, view.getUrl()));
    }
}
#method_after
@Override
public void onReceivedTitle(WebView view, String title) {
    mEditText.setText(view.getUrl());
    if (!mIncognito) {
        HistoryProvider.addOrUpdateItem(mActivity.getContentResolver(), title, view.getUrl());
    }
}
#end_block

#method_before
@Override
public void onReceivedIcon(WebView view, Bitmap icon) {
    mActivity.setColor(icon, mIncognito);
}
#method_after
@Override
public void onReceivedIcon(WebView view, Bitmap icon) {
    mActivity.onFaviconLoaded(icon);
}
#end_block

#method_before
public void onShowCustomView(View view, WebChromeClient.CustomViewCallback callback) {
    mActivity.onShowCustomView(view, callback);
}
#method_after
@Override
public void onShowCustomView(View view, WebChromeClient.CustomViewCallback callback) {
    mActivity.onShowCustomView(view, callback);
}
#end_block

#method_before
public void onHideCustomView() {
    mActivity.onHideCustomView();
}
#method_after
@Override
public void onHideCustomView() {
    mActivity.onHideCustomView();
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
    setSupportActionBar(toolbar);
    mCoordinator = (CoordinatorLayout) findViewById(R.id.coordinator_layout);
    mSwipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.swipe_refresh);
    mSwipeRefreshLayout.setOnRefreshListener(() -> {
        mWebView.reload();
        new Handler().postDelayed(() -> mSwipeRefreshLayout.setRefreshing(false), 1000);
    });
    ProgressBar progressBar = (ProgressBar) findViewById(R.id.load_progress);
    EditTextExt editText = (EditTextExt) findViewById(R.id.url_bar);
    editText.setOnEditorActionListener((v, actionId, event) -> {
        if (actionId == EditorInfo.IME_ACTION_SEARCH) {
            InputMethodManager manager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
            manager.hideSoftInputFromWindow(editText.getApplicationWindowToken(), 0);
            mWebView.loadUrl(editText.getText().toString());
            editText.clearFocus();
            return true;
        }
        return false;
    });
    Intent intent = getIntent();
    String url = intent.getDataString();
    boolean incognito = intent.getBooleanExtra(EXTRA_INCOGNITO, false);
    boolean desktopMode = false;
    // Restore from previous instance
    if (savedInstanceState != null) {
        incognito = savedInstanceState.getBoolean(EXTRA_INCOGNITO, incognito);
        if (url == null || url.isEmpty()) {
            url = savedInstanceState.getString(EXTRA_URL, null);
        }
        desktopMode = savedInstanceState.getBoolean(EXTRA_DESKTOP_MODE, false);
    }
    // Make sure prefs are set before loading them
    PreferenceManager.setDefaultValues(this, R.xml.settings, false);
    setupMenu();
    mWebView = (WebViewExt) findViewById(R.id.web_view);
    mWebView.init(this, editText, progressBar, incognito);
    mWebView.setDesktopMode(desktopMode);
    mWebView.loadUrl(url == null ? PrefsUtils.getHomePage(this) : url);
    mGestureDetector = new GestureDetectorCompat(this, new GestureDetector.SimpleOnGestureListener() {

        @Override
        public boolean onDoubleTapEvent(MotionEvent e) {
            mGestureOngoing = true;
            return false;
        }
    });
    mWebView.setOnTouchListener(this);
    mWebView.setOnScrollChangeListener(this);
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
    setSupportActionBar(toolbar);
    mCoordinator = (CoordinatorLayout) findViewById(R.id.coordinator_layout);
    mSwipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.swipe_refresh);
    mSwipeRefreshLayout.setOnRefreshListener(() -> {
        mWebView.reload();
        new Handler().postDelayed(() -> mSwipeRefreshLayout.setRefreshing(false), 1000);
    });
    mLoadingProgress = (ProgressBar) findViewById(R.id.load_progress);
    AutoCompleteTextView autoCompleteTextView = (AutoCompleteTextView) findViewById(R.id.url_bar);
    autoCompleteTextView.setAdapter(new SuggestionsAdapter(this));
    autoCompleteTextView.setOnEditorActionListener((v, actionId, event) -> {
        if (actionId == EditorInfo.IME_ACTION_SEARCH) {
            UiUtils.hideKeyboard(autoCompleteTextView);
            mWebView.loadUrl(autoCompleteTextView.getText().toString());
            autoCompleteTextView.clearFocus();
            return true;
        }
        return false;
    });
    autoCompleteTextView.setOnKeyListener((v, keyCode, event) -> {
        if (keyCode == KeyEvent.KEYCODE_ENTER) {
            UiUtils.hideKeyboard(autoCompleteTextView);
            mWebView.loadUrl(autoCompleteTextView.getText().toString());
            autoCompleteTextView.clearFocus();
            return true;
        }
        return false;
    });
    autoCompleteTextView.setOnItemClickListener((adapterView, view, pos, l) -> {
        CharSequence searchString = ((TextView) view.findViewById(R.id.title)).getText();
        String url = searchString.toString();
        UiUtils.hideKeyboard(autoCompleteTextView);
        autoCompleteTextView.clearFocus();
        mWebView.loadUrl(url);
    });
    Intent intent = getIntent();
    String url = intent.getDataString();
    mIncognito = intent.getBooleanExtra(EXTRA_INCOGNITO, false);
    boolean desktopMode = false;
    // Restore from previous instance
    if (savedInstanceState != null) {
        mIncognito = savedInstanceState.getBoolean(EXTRA_INCOGNITO, mIncognito);
        if (url == null || url.isEmpty()) {
            url = savedInstanceState.getString(EXTRA_URL, null);
        }
        desktopMode = savedInstanceState.getBoolean(EXTRA_DESKTOP_MODE, false);
        mThemeColor = savedInstanceState.getInt(STATE_KEY_THEME_COLOR, 0);
    }
    // Make sure prefs are set before loading them
    PreferenceManager.setDefaultValues(this, R.xml.settings, false);
    ImageView incognitoIcon = (ImageView) findViewById(R.id.incognito);
    incognitoIcon.setVisibility(mIncognito ? View.VISIBLE : View.GONE);
    setupMenu();
    mWebView = (WebViewExt) findViewById(R.id.web_view);
    mWebView.init(this, autoCompleteTextView, mLoadingProgress, mIncognito);
    mWebView.setDesktopMode(desktopMode);
    mWebView.loadUrl(url == null ? PrefsUtils.getHomePage(this) : url);
    mHasThemeColorSupport = WebViewCompat.isThemeColorSupported(mWebView);
    mGestureDetector = new GestureDetectorCompat(this, new GestureDetector.SimpleOnGestureListener() {

        @Override
        public boolean onDoubleTapEvent(MotionEvent e) {
            mGestureOngoing = true;
            return false;
        }
    });
    mWebView.setOnTouchListener(this);
    mWebView.setOnScrollChangeListener(this);
    mSearchController = new SearchBarController(mWebView, (EditText) findViewById(R.id.search_menu_edit), (TextView) findViewById(R.id.search_status), (ImageButton) findViewById(R.id.search_menu_prev), (ImageButton) findViewById(R.id.search_menu_next), (ImageButton) findViewById(R.id.search_menu_cancel), this);
    applyThemeColor(mThemeColor);
    try {
        File httpCacheDir = new File(getCacheDir(), "suggestion_responses");
        // 1 MiB
        long httpCacheSize = 1024 * 1024;
        HttpResponseCache.install(httpCacheDir, httpCacheSize);
    } catch (IOException e) {
        Log.i(TAG, "HTTP response cache installation failed:" + e);
    }
}
#end_block

#method_before
@Override
protected void onStop() {
    CookieManager.getInstance().flush();
    super.onStop();
}
#method_after
@Override
protected void onStop() {
    CookieManager.getInstance().flush();
    unregisterReceiver(mUrlResolvedReceiver);
    HttpResponseCache cache = HttpResponseCache.getInstalled();
    if (cache != null) {
        cache.flush();
    }
    super.onStop();
}
#end_block

#method_before
@Override
protected void onResume() {
    CookieManager.getInstance().setAcceptCookie(PrefsUtils.getCookie(this));
    super.onResume();
    if (PrefsUtils.getLookLock(this)) {
        getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE);
    } else {
        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_SECURE);
    }
}
#method_after
@Override
protected void onResume() {
    super.onResume();
    mWebView.onResume();
    CookieManager.getInstance().setAcceptCookie(!mWebView.isIncognito() && PrefsUtils.getCookie(this));
    if (PrefsUtils.getLookLock(this)) {
        getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE);
    } else {
        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_SECURE);
    }
}
#end_block

#method_before
@Override
public void onBackPressed() {
    if (mCustomView != null) {
        onHideCustomView();
    } else if (mWebView.canGoBack()) {
        mWebView.goBack();
    } else {
        super.onBackPressed();
    }
}
#method_after
@Override
public void onBackPressed() {
    mSearchController.onCancel();
    if (mCustomView != null) {
        onHideCustomView();
    } else if (mWebView.canGoBack()) {
        mWebView.goBack();
    } else {
        super.onBackPressed();
    }
}
#end_block

#method_before
@Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] results) {
    switch(requestCode) {
        case LOCATION_PERM_REQ:
            if (hasLocationPermission()) {
                mWebView.reload();
            }
            break;
        case STORAGE_PERM_REQ:
            if (hasStoragePermission() && mWaitingDownloadUrl != null) {
                downloadFileAsk(mWaitingDownloadUrl, mWaitingDownloadName);
            } else {
                if (shouldShowRequestPermissionRationale(Manifest.permission.WRITE_EXTERNAL_STORAGE)) {
                    new AlertDialog.Builder(this).setTitle(R.string.permission_error_title).setMessage(R.string.permission_error_storage).setCancelable(false).setPositiveButton(getString(R.string.permission_error_ask_again), ((dialog, which) -> requestStoragePermission())).setNegativeButton(getString(R.string.dismiss), (((dialog, which) -> dialog.dismiss()))).show();
                } else {
                    Snackbar.make(mCoordinator, getString(R.string.permission_error_forever), Snackbar.LENGTH_LONG).show();
                }
            }
            break;
    }
}
#method_after
@Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] results) {
    switch(requestCode) {
        case LOCATION_PERM_REQ:
            if (hasLocationPermission()) {
                mWebView.reload();
            }
            break;
        case STORAGE_PERM_REQ:
            if (hasStoragePermission() && mWaitingDownloadUrl != null) {
                downloadFileAsk(mWaitingDownloadUrl, null, null);
            } else {
                if (shouldShowRequestPermissionRationale(Manifest.permission.WRITE_EXTERNAL_STORAGE)) {
                    new AlertDialog.Builder(this).setTitle(R.string.permission_error_title).setMessage(R.string.permission_error_storage).setCancelable(false).setPositiveButton(getString(R.string.permission_error_ask_again), ((dialog, which) -> requestStoragePermission())).setNegativeButton(getString(R.string.dismiss), (((dialog, which) -> dialog.dismiss()))).show();
                } else {
                    Snackbar.make(mCoordinator, getString(R.string.permission_error_forever), Snackbar.LENGTH_LONG).show();
                }
            }
            break;
    }
}
#end_block

#method_before
@Override
public void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    // Preserve webView status
    outState.putString(EXTRA_URL, mWebView.getUrl());
    outState.putBoolean(EXTRA_INCOGNITO, mWebView.isIncognito());
    outState.putBoolean(EXTRA_DESKTOP_MODE, mWebView.isDesktopMode());
}
#method_after
@Override
public void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    // Preserve webView status
    outState.putString(EXTRA_URL, mWebView.getUrl());
    outState.putBoolean(EXTRA_INCOGNITO, mWebView.isIncognito());
    outState.putBoolean(EXTRA_DESKTOP_MODE, mWebView.isDesktopMode());
    outState.putInt(STATE_KEY_THEME_COLOR, mThemeColor);
}
#end_block

#method_before
private void setupMenu() {
    ImageButton menu = (ImageButton) findViewById(R.id.search_menu);
    menu.setOnClickListener(v -> {
        boolean isDesktop = mWebView.isDesktopMode();
        ContextThemeWrapper wrapper = new ContextThemeWrapper(this, R.style.AppTheme_PopupMenuOverlapAnchor);
        PopupMenu popupMenu = new PopupMenu(wrapper, menu, Gravity.NO_GRAVITY, R.attr.actionOverflowMenuStyle, 0);
        popupMenu.inflate(R.menu.menu_main);
        MenuItem desktopMode = popupMenu.getMenu().findItem(R.id.desktop_mode);
        desktopMode.setTitle(getString(isDesktop ? R.string.menu_mobile_mode : R.string.menu_desktop_mode));
        desktopMode.setIcon(ContextCompat.getDrawable(this, isDesktop ? R.drawable.ic_mobile : R.drawable.ic_desktop));
        popupMenu.setOnMenuItemClickListener(item -> {
            switch(item.getItemId()) {
                case R.id.menu_new:
                    openInNewTab(null);
                    break;
                case R.id.menu_incognito:
                    Intent intent = new Intent(this, MainActivity.class);
                    intent.putExtra(EXTRA_INCOGNITO, true);
                    startActivity(intent);
                    break;
                case R.id.menu_reload:
                    mWebView.reload();
                    break;
                case R.id.menu_add_favorite:
                    setAsFavorite(mWebView.getTitle(), mWebView.getUrl());
                    break;
                case R.id.menu_share:
                    // Delay a bit to allow popup menu hide animation to play
                    new Handler().postDelayed(() -> shareUrl(mWebView.getUrl()), 300);
                    break;
                case R.id.menu_favorite:
                    startActivity(new Intent(this, FavoriteActivity.class));
                    break;
                case R.id.menu_history:
                    startActivity(new Intent(this, HistoryActivity.class));
                    break;
                case R.id.menu_shortcut:
                    addShortcut();
                    break;
                case R.id.menu_settings:
                    startActivity(new Intent(this, SettingsActivity.class));
                    break;
                case R.id.desktop_mode:
                    mWebView.setDesktopMode(!isDesktop);
                    desktopMode.setTitle(getString(isDesktop ? R.string.menu_desktop_mode : R.string.menu_mobile_mode));
                    desktopMode.setIcon(ContextCompat.getDrawable(this, isDesktop ? R.drawable.ic_desktop : R.drawable.ic_mobile));
                    break;
            }
            return true;
        });
        // Fuck you, lint
        // noinspection RestrictedApi
        MenuPopupHelper helper = new MenuPopupHelper(wrapper, (MenuBuilder) popupMenu.getMenu(), menu);
        // noinspection RestrictedApi
        helper.setForceShowIcon(true);
        // noinspection RestrictedApi
        helper.show();
    });
}
#method_after
private void setupMenu() {
    ImageButton menu = (ImageButton) findViewById(R.id.search_menu);
    menu.setOnClickListener(v -> {
        boolean isDesktop = mWebView.isDesktopMode();
        ContextThemeWrapper wrapper = new ContextThemeWrapper(this, R.style.AppTheme_PopupMenuOverlapAnchor);
        PopupMenu popupMenu = new PopupMenu(wrapper, menu, Gravity.NO_GRAVITY, R.attr.actionOverflowMenuStyle, 0);
        popupMenu.inflate(R.menu.menu_main);
        MenuItem desktopMode = popupMenu.getMenu().findItem(R.id.desktop_mode);
        desktopMode.setTitle(getString(isDesktop ? R.string.menu_mobile_mode : R.string.menu_desktop_mode));
        desktopMode.setIcon(ContextCompat.getDrawable(this, isDesktop ? R.drawable.ic_mobile : R.drawable.ic_desktop));
        popupMenu.setOnMenuItemClickListener(item -> {
            switch(item.getItemId()) {
                case R.id.menu_new:
                    openInNewTab(null, false);
                    break;
                case R.id.menu_incognito:
                    openInNewTab(null, true);
                    break;
                case R.id.menu_reload:
                    mWebView.reload();
                    break;
                case R.id.menu_add_favorite:
                    setAsFavorite(mWebView.getTitle(), mWebView.getUrl());
                    break;
                case R.id.menu_share:
                    // Delay a bit to allow popup menu hide animation to play
                    new Handler().postDelayed(() -> shareUrl(mWebView.getUrl()), 300);
                    break;
                case R.id.menu_search:
                    // Run the search setup
                    showSearch();
                    break;
                case R.id.menu_favorite:
                    startActivity(new Intent(this, FavoriteActivity.class));
                    break;
                case R.id.menu_history:
                    startActivity(new Intent(this, HistoryActivity.class));
                    break;
                case R.id.menu_shortcut:
                    addShortcut();
                    break;
                case R.id.menu_settings:
                    startActivity(new Intent(this, SettingsActivity.class));
                    break;
                case R.id.desktop_mode:
                    mWebView.setDesktopMode(!isDesktop);
                    desktopMode.setTitle(getString(isDesktop ? R.string.menu_desktop_mode : R.string.menu_mobile_mode));
                    desktopMode.setIcon(ContextCompat.getDrawable(this, isDesktop ? R.drawable.ic_desktop : R.drawable.ic_mobile));
                    break;
            }
            return true;
        });
        // Fuck you, lint
        // noinspection RestrictedApi
        MenuPopupHelper helper = new MenuPopupHelper(wrapper, (MenuBuilder) popupMenu.getMenu(), menu);
        // noinspection RestrictedApi
        helper.setForceShowIcon(true);
        // noinspection RestrictedApi
        helper.show();
    });
}
#end_block

#method_before
private void openInNewTab(String url) {
    Intent intent = new Intent(this, MainActivity.class);
    if (url != null && !url.isEmpty()) {
        intent.setData(Uri.parse(url));
    }
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT | Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
    startActivity(intent);
}
#method_after
private void openInNewTab(String url, boolean incognito) {
    Intent intent = new Intent(this, MainActivity.class);
    if (url != null && !url.isEmpty()) {
        intent.setData(Uri.parse(url));
    }
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT | Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
    intent.putExtra(EXTRA_INCOGNITO, incognito);
    startActivity(intent);
}
#end_block

#method_before
private void shareUrl(String url) {
    Intent intent = new Intent(Intent.ACTION_SEND);
    intent.putExtra(Intent.EXTRA_TEXT, url);
    if (PrefsUtils.getAdvancedShare(this) && url.equals(mWebView.getUrl())) {
        try {
            File file = new File(getCacheDir(), String.valueOf(System.currentTimeMillis()) + ".png");
            FileOutputStream out = new FileOutputStream(file);
            Bitmap bm = mWebView.getSnap();
            if (bm == null) {
                return;
            }
            bm.compress(Bitmap.CompressFormat.PNG, 70, out);
            out.flush();
            out.close();
            intent.putExtra(Intent.EXTRA_STREAM, FileProvider.getUriForFile(this, PROVIDER, file));
            intent.setType("image/png");
            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
        } catch (IOException e) {
            Log.e(TAG, e.getMessage());
        }
    } else {
        intent.setType("text/plain");
    }
    startActivity(Intent.createChooser(intent, getString(R.string.share_title)));
}
#method_after
private void shareUrl(String url) {
    Intent intent = new Intent(Intent.ACTION_SEND);
    intent.putExtra(Intent.EXTRA_TEXT, url);
    if (PrefsUtils.getAdvancedShare(this) && url.equals(mWebView.getUrl())) {
        try {
            File file = new File(getCacheDir(), String.valueOf(System.currentTimeMillis()) + ".png");
            FileOutputStream out = new FileOutputStream(file);
            Bitmap bm = mWebView.getSnap();
            if (bm == null) {
                out.close();
                return;
            }
            bm.compress(Bitmap.CompressFormat.PNG, 70, out);
            out.flush();
            out.close();
            intent.putExtra(Intent.EXTRA_STREAM, FileProvider.getUriForFile(this, PROVIDER, file));
            intent.setType("image/png");
            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
        } catch (IOException e) {
            Log.e(TAG, e.getMessage());
        }
    } else {
        intent.setType("text/plain");
    }
    startActivity(Intent.createChooser(intent, getString(R.string.share_title)));
}
#end_block

#method_before
private void setAsFavorite(String title, String url) {
    FavoriteDatabaseHandler handler = new FavoriteDatabaseHandler(this);
    boolean hasValidIcon = mUrlIcon != null && !mUrlIcon.isRecycled();
    handler.addItem(new Favorite(title, url, hasValidIcon ? UiUtils.getColor(this, mUrlIcon, false) : ContextCompat.getColor(this, R.color.colorAccent)));
    Snackbar.make(mCoordinator, getString(R.string.favorite_added), Snackbar.LENGTH_LONG).show();
}
#method_after
private void setAsFavorite(String title, String url) {
    FavoriteDatabaseHandler handler = new FavoriteDatabaseHandler(this);
    boolean hasValidIcon = mUrlIcon != null && !mUrlIcon.isRecycled();
    int color = hasValidIcon ? UiUtils.getColor(mUrlIcon, false) : Color.TRANSPARENT;
    if (color == Color.TRANSPARENT) {
        color = ContextCompat.getColor(this, R.color.colorAccent);
    }
    handler.addItem(new Favorite(title, url, color));
    Snackbar.make(mCoordinator, getString(R.string.favorite_added), Snackbar.LENGTH_LONG).show();
}
#end_block

#method_before
public void downloadFileAsk(String url, String fileName) {
    if (!hasStoragePermission()) {
        mWaitingDownloadUrl = url;
        mWaitingDownloadName = fileName;
        requestStoragePermission();
        return;
    }
    mWaitingDownloadUrl = null;
    mWaitingDownloadName = null;
    new AlertDialog.Builder(this).setTitle(R.string.download_title).setMessage(getString(R.string.download_message, fileName)).setPositiveButton(getString(R.string.download_positive), (dialog, which) -> fetchFile(url, fileName)).setNegativeButton(getString(R.string.dismiss), ((dialog, which) -> dialog.dismiss())).show();
}
#method_after
public void downloadFileAsk(String url, String contentDisposition, String mimeType) {
    String fileName = URLUtil.guessFileName(url, contentDisposition, mimeType);
    if (!hasStoragePermission()) {
        mWaitingDownloadUrl = url;
        requestStoragePermission();
        return;
    }
    mWaitingDownloadUrl = null;
    new AlertDialog.Builder(this).setTitle(R.string.download_title).setMessage(getString(R.string.download_message, fileName)).setPositiveButton(getString(R.string.download_positive), (dialog, which) -> fetchFile(url, fileName)).setNegativeButton(getString(R.string.dismiss), ((dialog, which) -> dialog.dismiss())).show();
}
#end_block

#method_before
private void fetchFile(String url, String fileName) {
    DownloadManager.Request request = new DownloadManager.Request(Uri.parse(url));
    request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE);
    request.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, fileName);
    DownloadManager manager = (DownloadManager) getSystemService(DOWNLOAD_SERVICE);
    manager.enqueue(request);
}
#method_after
private void fetchFile(String url, String fileName) {
    DownloadManager.Request request = new DownloadManager.Request(Uri.parse(url));
    // Let this downloaded file be scanned by MediaScanner - so that it can
    // show up in Gallery app, for example.
    request.allowScanningByMediaScanner();
    request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);
    request.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, fileName);
    DownloadManager manager = (DownloadManager) getSystemService(DOWNLOAD_SERVICE);
    manager.enqueue(request);
}
#end_block

#method_before
public void showSheetMenu(String url, boolean shouldAllowDownload) {
    final BottomSheetDialog sheet = new BottomSheetDialog(this);
    @SuppressLint("InflateParams")
    View view = getLayoutInflater().inflate(R.layout.sheet_actions, null);
    View tabLayout = view.findViewById(R.id.sheet_new_tab);
    View shareLayout = view.findViewById(R.id.sheet_share);
    View favouriteLayout = view.findViewById(R.id.sheet_favourite);
    View downloadLayout = view.findViewById(R.id.sheet_download);
    tabLayout.setOnClickListener(v -> openInNewTab(url));
    shareLayout.setOnClickListener(v -> shareUrl(url));
    favouriteLayout.setOnClickListener(v -> setAsFavorite(url, url));
    if (shouldAllowDownload) {
        downloadLayout.setOnClickListener(v -> downloadFileAsk(url, ""));
        downloadLayout.setVisibility(View.VISIBLE);
    }
    sheet.setContentView(view);
    sheet.show();
}
#method_after
public void showSheetMenu(String url, boolean shouldAllowDownload) {
    final BottomSheetDialog sheet = new BottomSheetDialog(this);
    View view = getLayoutInflater().inflate(R.layout.sheet_actions, new LinearLayout(this));
    View tabLayout = view.findViewById(R.id.sheet_new_tab);
    View shareLayout = view.findViewById(R.id.sheet_share);
    View favouriteLayout = view.findViewById(R.id.sheet_favourite);
    View downloadLayout = view.findViewById(R.id.sheet_download);
    tabLayout.setOnClickListener(v -> {
        openInNewTab(url, mIncognito);
        sheet.dismiss();
    });
    shareLayout.setOnClickListener(v -> {
        shareUrl(url);
        sheet.dismiss();
    });
    favouriteLayout.setOnClickListener(v -> {
        setAsFavorite(url, url);
        sheet.dismiss();
    });
    if (shouldAllowDownload) {
        downloadLayout.setOnClickListener(v -> {
            downloadFileAsk(url, null, null);
            sheet.dismiss();
        });
        downloadLayout.setVisibility(View.VISIBLE);
    }
    sheet.setContentView(view);
    sheet.show();
}
#end_block

#method_before
@Override
public void onShowCustomView(View view, WebChromeClient.CustomViewCallback callback) {
    if (mCustomView != null) {
        callback.onCustomViewHidden();
        return;
    }
    mCustomView = view;
    mFullScreenCallback = callback;
    immersiveModeEnabled(true);
    mCustomView.setBackgroundColor(ContextCompat.getColor(this, android.R.color.black));
    addContentView(mCustomView, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
    findViewById(R.id.app_bar_layout).setVisibility(View.GONE);
    mSwipeRefreshLayout.setVisibility(View.GONE);
}
#method_after
@Override
public void onShowCustomView(View view, WebChromeClient.CustomViewCallback callback) {
    if (mCustomView != null) {
        callback.onCustomViewHidden();
        return;
    }
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
    mCustomView = view;
    mFullScreenCallback = callback;
    setImmersiveMode(true);
    mCustomView.setBackgroundColor(ContextCompat.getColor(this, android.R.color.black));
    addContentView(mCustomView, new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
    findViewById(R.id.app_bar_layout).setVisibility(View.GONE);
    mSwipeRefreshLayout.setVisibility(View.GONE);
}
#end_block

#method_before
@Override
public void onHideCustomView() {
    if (mCustomView == null) {
        return;
    }
    immersiveModeEnabled(false);
    findViewById(R.id.app_bar_layout).setVisibility(View.VISIBLE);
    mSwipeRefreshLayout.setVisibility(View.VISIBLE);
    ViewGroup viewGroup = (ViewGroup) mCustomView.getParent();
    viewGroup.removeView(mCustomView);
    mFullScreenCallback.onCustomViewHidden();
    mFullScreenCallback = null;
    mCustomView = null;
}
#method_after
@Override
public void onHideCustomView() {
    if (mCustomView == null) {
        return;
    }
    getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
    setImmersiveMode(false);
    findViewById(R.id.app_bar_layout).setVisibility(View.VISIBLE);
    mSwipeRefreshLayout.setVisibility(View.VISIBLE);
    ViewGroup viewGroup = (ViewGroup) mCustomView.getParent();
    viewGroup.removeView(mCustomView);
    mFullScreenCallback.onCustomViewHidden();
    mFullScreenCallback = null;
    mCustomView = null;
}
#end_block

#method_before
private void addShortcut() {
    Intent intent = new Intent(this, MainActivity.class);
    intent.setData(Uri.parse(mWebView.getUrl()));
    intent.setAction(Intent.ACTION_MAIN);
    Bitmap icon = mUrlIcon == null ? BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher) : mUrlIcon;
    Bitmap launcherIcon = UiUtils.getShortcutIcon(this, icon);
    Intent addIntent = new Intent();
    addIntent.putExtra(Intent.EXTRA_SHORTCUT_NAME, mWebView.getTitle());
    addIntent.putExtra(Intent.EXTRA_SHORTCUT_ICON, launcherIcon);
    addIntent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, intent);
    addIntent.setAction("com.android.launcher.action.INSTALL_SHORTCUT");
    sendBroadcast(addIntent);
    launcherIcon.recycle();
    Snackbar.make(mCoordinator, getString(R.string.shortcut_added), Snackbar.LENGTH_LONG).show();
}
#method_after
private void addShortcut() {
    Intent intent = new Intent(this, MainActivity.class);
    intent.setData(Uri.parse(mWebView.getUrl()));
    intent.setAction(Intent.ACTION_MAIN);
    Bitmap icon = mUrlIcon == null ? BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher) : mUrlIcon;
    Bitmap launcherIcon = UiUtils.getShortcutIcon(icon, getThemeColorWithFallback());
    Intent addIntent = new Intent();
    addIntent.putExtra(Intent.EXTRA_SHORTCUT_NAME, mWebView.getTitle());
    addIntent.putExtra(Intent.EXTRA_SHORTCUT_ICON, launcherIcon);
    addIntent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, intent);
    addIntent.setAction("com.android.launcher.action.INSTALL_SHORTCUT");
    sendBroadcast(addIntent);
    launcherIcon.recycle();
    Snackbar.make(mCoordinator, getString(R.string.shortcut_added), Snackbar.LENGTH_LONG).show();
}
#end_block

#method_before
@Override
public void onWindowFocusChanged(boolean hasFocus) {
    super.onWindowFocusChanged(hasFocus);
    immersiveModeEnabled(hasFocus && mCustomView != null);
}
#method_after
@Override
public void onWindowFocusChanged(boolean hasFocus) {
    super.onWindowFocusChanged(hasFocus);
    setImmersiveMode(hasFocus && mCustomView != null);
}
#end_block

#method_before
public static Suggestion getSuggestionProvider(Context context) {
    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
    try {
        return Suggestion.valueOf(prefs.getString(KEY_SUGGESTION_PROVIDER, Suggestion.SUGGESTION_GOOGLE.name()));
    } catch (IllegalArgumentException ignored) {
        return Suggestion.SUGGESTION_NONE;
    }
}
#method_after
public static SuggestionProviderType getSuggestionProvider(Context context) {
    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
    try {
        String value = prefs.getString(KEY_SUGGESTION_PROVIDER, null);
        if (value == null) {
            value = context.getString(R.string.default_suggestion_provider);
        }
        return SuggestionProviderType.valueOf(value);
    } catch (IllegalArgumentException ignored) {
        return SuggestionProviderType.NONE;
    }
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
    setSupportActionBar(toolbar);
    mCoordinator = (CoordinatorLayout) findViewById(R.id.coordinator_layout);
    mSwipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.swipe_refresh);
    mSwipeRefreshLayout.setOnRefreshListener(() -> {
        mWebView.reload();
        new Handler().postDelayed(() -> mSwipeRefreshLayout.setRefreshing(false), 1000);
    });
    mLoadingProgress = (ProgressBar) findViewById(R.id.load_progress);
    AutoCompleteTextView autoCompleteTextView = (AutoCompleteTextView) findViewById(R.id.url_bar);
    autoCompleteTextView.setOnEditorActionListener((v, actionId, event) -> {
        if (actionId == EditorInfo.IME_ACTION_SEARCH) {
            InputMethodManager manager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
            manager.hideSoftInputFromWindow(autoCompleteTextView.getApplicationWindowToken(), 0);
            mWebView.loadUrl(autoCompleteTextView.getText().toString());
            autoCompleteTextView.clearFocus();
            return true;
        }
        return false;
    });
    autoCompleteTextView.setOnItemClickListener((adapterView, view, pos, l) -> {
        CharSequence searchString = ((TextView) view.findViewById(R.id.title)).getText();
        String url = searchString.toString();
        InputMethodManager manager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
        manager.hideSoftInputFromWindow(autoCompleteTextView.getApplicationWindowToken(), 0);
        autoCompleteTextView.clearFocus();
        autoCompleteTextView.setText(url);
        mWebView.loadUrl(url);
    });
    SuggestionsAdapter mAdaper = new SuggestionsAdapter(getApplicationContext());
    autoCompleteTextView.setAdapter(mAdaper);
    Intent intent = getIntent();
    String url = intent.getDataString();
    mIncognito = intent.getBooleanExtra(EXTRA_INCOGNITO, false);
    boolean desktopMode = false;
    // Restore from previous instance
    if (savedInstanceState != null) {
        mIncognito = savedInstanceState.getBoolean(EXTRA_INCOGNITO, mIncognito);
        if (url == null || url.isEmpty()) {
            url = savedInstanceState.getString(EXTRA_URL, null);
        }
        desktopMode = savedInstanceState.getBoolean(EXTRA_DESKTOP_MODE, false);
        mThemeColor = savedInstanceState.getInt(STATE_KEY_THEME_COLOR, 0);
    }
    // Make sure prefs are set before loading them
    PreferenceManager.setDefaultValues(this, R.xml.settings, false);
    ImageView incognitoIcon = (ImageView) findViewById(R.id.incognito);
    incognitoIcon.setVisibility(mIncognito ? View.VISIBLE : View.GONE);
    setupMenu();
    mWebView = (WebViewExt) findViewById(R.id.web_view);
    mWebView.init(this, autoCompleteTextView, mLoadingProgress, mIncognito);
    mWebView.setDesktopMode(desktopMode);
    mWebView.loadUrl(url == null ? PrefsUtils.getHomePage(this) : url);
    mHasThemeColorSupport = WebViewCompat.isThemeColorSupported(mWebView);
    mGestureDetector = new GestureDetectorCompat(this, new GestureDetector.SimpleOnGestureListener() {

        @Override
        public boolean onDoubleTapEvent(MotionEvent e) {
            mGestureOngoing = true;
            return false;
        }
    });
    mWebView.setOnTouchListener(this);
    mWebView.setOnScrollChangeListener(this);
    applyThemeColor(mThemeColor);
    try {
        File httpCacheDir = new File(getApplicationContext().getCacheDir(), "suggestion_responses");
        // 1 MiB
        long httpCacheSize = 1024 * 1024;
        HttpResponseCache.install(httpCacheDir, httpCacheSize);
    } catch (IOException e) {
        Log.i(TAG, "HTTP response cache installation failed:" + e);
    }
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
    setSupportActionBar(toolbar);
    mCoordinator = (CoordinatorLayout) findViewById(R.id.coordinator_layout);
    mSwipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.swipe_refresh);
    mSwipeRefreshLayout.setOnRefreshListener(() -> {
        mWebView.reload();
        new Handler().postDelayed(() -> mSwipeRefreshLayout.setRefreshing(false), 1000);
    });
    mLoadingProgress = (ProgressBar) findViewById(R.id.load_progress);
    AutoCompleteTextView autoCompleteTextView = (AutoCompleteTextView) findViewById(R.id.url_bar);
    autoCompleteTextView.setAdapter(new SuggestionsAdapter(this));
    autoCompleteTextView.setOnEditorActionListener((v, actionId, event) -> {
        if (actionId == EditorInfo.IME_ACTION_SEARCH) {
            UiUtils.hideKeyboard(autoCompleteTextView);
            mWebView.loadUrl(autoCompleteTextView.getText().toString());
            autoCompleteTextView.clearFocus();
            return true;
        }
        return false;
    });
    autoCompleteTextView.setOnKeyListener((v, keyCode, event) -> {
        if (keyCode == KeyEvent.KEYCODE_ENTER) {
            UiUtils.hideKeyboard(autoCompleteTextView);
            mWebView.loadUrl(autoCompleteTextView.getText().toString());
            autoCompleteTextView.clearFocus();
            return true;
        }
        return false;
    });
    autoCompleteTextView.setOnItemClickListener((adapterView, view, pos, l) -> {
        CharSequence searchString = ((TextView) view.findViewById(R.id.title)).getText();
        String url = searchString.toString();
        UiUtils.hideKeyboard(autoCompleteTextView);
        autoCompleteTextView.clearFocus();
        mWebView.loadUrl(url);
    });
    Intent intent = getIntent();
    String url = intent.getDataString();
    mIncognito = intent.getBooleanExtra(EXTRA_INCOGNITO, false);
    boolean desktopMode = false;
    // Restore from previous instance
    if (savedInstanceState != null) {
        mIncognito = savedInstanceState.getBoolean(EXTRA_INCOGNITO, mIncognito);
        if (url == null || url.isEmpty()) {
            url = savedInstanceState.getString(EXTRA_URL, null);
        }
        desktopMode = savedInstanceState.getBoolean(EXTRA_DESKTOP_MODE, false);
        mThemeColor = savedInstanceState.getInt(STATE_KEY_THEME_COLOR, 0);
    }
    // Make sure prefs are set before loading them
    PreferenceManager.setDefaultValues(this, R.xml.settings, false);
    ImageView incognitoIcon = (ImageView) findViewById(R.id.incognito);
    incognitoIcon.setVisibility(mIncognito ? View.VISIBLE : View.GONE);
    setupMenu();
    mWebView = (WebViewExt) findViewById(R.id.web_view);
    mWebView.init(this, autoCompleteTextView, mLoadingProgress, mIncognito);
    mWebView.setDesktopMode(desktopMode);
    mWebView.loadUrl(url == null ? PrefsUtils.getHomePage(this) : url);
    mHasThemeColorSupport = WebViewCompat.isThemeColorSupported(mWebView);
    mGestureDetector = new GestureDetectorCompat(this, new GestureDetector.SimpleOnGestureListener() {

        @Override
        public boolean onDoubleTapEvent(MotionEvent e) {
            mGestureOngoing = true;
            return false;
        }
    });
    mWebView.setOnTouchListener(this);
    mWebView.setOnScrollChangeListener(this);
    applyThemeColor(mThemeColor);
    try {
        File httpCacheDir = new File(getApplicationContext().getCacheDir(), "suggestion_responses");
        // 1 MiB
        long httpCacheSize = 1024 * 1024;
        HttpResponseCache.install(httpCacheDir, httpCacheSize);
    } catch (IOException e) {
        Log.i(TAG, "HTTP response cache installation failed:" + e);
    }
}
#end_block

#method_before
@Override
public int getCount() {
    return items.size();
}
#method_after
@Override
public int getCount() {
    return mItems.size();
}
#end_block

#method_before
@Override
public Object getItem(int position) {
    return items.get(position);
}
#method_after
@Override
public Object getItem(int position) {
    return mItems.get(position);
}
#end_block

#method_before
@Override
public View getView(int position, View convertView, ViewGroup parent) {
    // Get the data item for this position
    SuggestionItem item = items.get(position);
    // Check if an existing view is being reused, otherwise inflate the view
    if (convertView == null) {
        convertView = LayoutInflater.from(mContext).inflate(R.layout.item_suggestion, parent, false);
    }
    // Lookup view for data population
    TextView title = (TextView) convertView.findViewById(R.id.title);
    // Populate the data into the template view using the data object
    title.setText(item.getSuggestion());
    // Return the completed view to render on screen
    return convertView;
}
#method_after
@Override
public View getView(int position, View convertView, ViewGroup parent) {
    if (convertView == null) {
        convertView = mInflater.inflate(R.layout.item_suggestion, parent, false);
    }
    TextView title = (TextView) convertView.findViewById(R.id.title);
    String suggestion = mItems.get(position);
    if (mQueryText != null) {
        SpannableStringBuilder spannable = new SpannableStringBuilder(suggestion);
        String lcSuggestion = suggestion.toLowerCase(Locale.getDefault());
        int queryTextPos = lcSuggestion.indexOf(mQueryText);
        while (queryTextPos >= 0) {
            spannable.setSpan(new StyleSpan(Typeface.BOLD), queryTextPos, queryTextPos + mQueryText.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
            queryTextPos = lcSuggestion.indexOf(mQueryText, queryTextPos + mQueryText.length());
        }
        title.setText(spannable);
    } else {
        title.setText(suggestion);
    }
    return convertView;
}
#end_block

#method_before
@Override
protected FilterResults performFiltering(CharSequence constraint) {
    FilterResults results = new FilterResults();
    if (constraint == null || constraint.length() == 0) {
        clear();
        return results;
    }
    String query = constraint.toString().toLowerCase(Locale.getDefault()).trim();
    mSuggestionsTask.disable();
    mSuggestionsTask = new SuggestionsTask(mSuggestionsAdapter);
    mSuggestionsTask.execute(query);
    results.count = 1;
    return results;
}
#method_after
@Override
protected FilterResults performFiltering(CharSequence constraint) {
    FilterResults results = new FilterResults();
    if (constraint == null || constraint.length() == 0) {
        return results;
    }
    SuggestionProvider provider = getProvider();
    String query = constraint.toString().toLowerCase(Locale.getDefault()).trim();
    if (provider != null) {
        List<String> items = provider.fetchResults(query);
        results.count = items.size();
        results.values = items;
    }
    return results;
}
#end_block

#method_before
@Override
protected void publishResults(CharSequence constraint, FilterResults results) {
}
#method_after
@Override
protected void publishResults(CharSequence constraint, FilterResults results) {
    mItems.clear();
    if (results.values != null) {
        List<String> items = (List<String>) results.values;
        mItems.addAll(items);
    }
    mQueryText = constraint != null ? constraint.toString().toLowerCase(Locale.getDefault()).trim() : null;
    notifyDataSetChanged();
}
#end_block

#method_before
private void readConfigurationLocked() {
    final Resources resources = mContext.getResources();
    mDecoupleHalAutoSuspendModeFromDisplayConfig = resources.getBoolean(com.android.internal.R.bool.config_powerDecoupleAutoSuspendModeFromDisplay);
    mDecoupleHalInteractiveModeFromDisplayConfig = resources.getBoolean(com.android.internal.R.bool.config_powerDecoupleInteractiveModeFromDisplay);
    mWakeUpWhenPluggedOrUnpluggedConfig = resources.getBoolean(com.android.internal.R.bool.config_unplugTurnsOnScreen);
    mWakeUpWhenPluggedOrUnpluggedInTheaterModeConfig = resources.getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromUnplug);
    mSuspendWhenScreenOffDueToProximityConfig = resources.getBoolean(com.android.internal.R.bool.config_suspendWhenScreenOffDueToProximity);
    mDreamsSupportedConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsSupported);
    mDreamsEnabledByDefaultConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsEnabledByDefault);
    mDreamsActivatedOnSleepByDefaultConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsActivatedOnSleepByDefault);
    mDreamsActivatedOnDockByDefaultConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsActivatedOnDockByDefault);
    mDreamsEnabledOnBatteryConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsEnabledOnBattery);
    mDreamsBatteryLevelMinimumWhenPoweredConfig = resources.getInteger(com.android.internal.R.integer.config_dreamsBatteryLevelMinimumWhenPowered);
    mDreamsBatteryLevelMinimumWhenNotPoweredConfig = resources.getInteger(com.android.internal.R.integer.config_dreamsBatteryLevelMinimumWhenNotPowered);
    mDreamsBatteryLevelDrainCutoffConfig = resources.getInteger(com.android.internal.R.integer.config_dreamsBatteryLevelDrainCutoff);
    mDozeAfterScreenOffConfig = resources.getBoolean(com.android.internal.R.bool.config_dozeAfterScreenOff);
    mMinimumScreenOffTimeoutConfig = resources.getInteger(com.android.internal.R.integer.config_minimumScreenOffTimeout);
    mMaximumScreenDimDurationConfig = resources.getInteger(com.android.internal.R.integer.config_maximumScreenDimDuration);
    mMaximumScreenDimRatioConfig = resources.getFraction(com.android.internal.R.fraction.config_maximumScreenDimRatio, 1, 1);
    mSupportsDoubleTapWakeConfig = resources.getBoolean(com.android.internal.R.bool.config_supportDoubleTapWake);
    mProximityWakeSupported = resources.getBoolean(org.cyanogenmod.platform.internal.R.bool.config_proximityCheckOnWake);
    mProximityWakeEnabledByDefaultConfig = resources.getBoolean(org.cyanogenmod.platform.internal.R.bool.config_proximityCheckOnWakeEnabledByDefault);
    mProximityTimeOut = resources.getInteger(org.cyanogenmod.platform.internal.R.integer.config_proximityCheckTimeout);
    if (mProximityWakeSupported) {
        mProximityWakeLock = ((PowerManager) mContext.getSystemService(Context.POWER_SERVICE)).newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "ProximityWakeLock");
    }
    mButtonLightOnKeypressOnly = resources.getBoolean(com.android.internal.R.bool.config_ButtonLightOnKeypressOnly);
}
#method_after
private void readConfigurationLocked() {
    final Resources resources = mContext.getResources();
    mDecoupleHalAutoSuspendModeFromDisplayConfig = resources.getBoolean(com.android.internal.R.bool.config_powerDecoupleAutoSuspendModeFromDisplay);
    mDecoupleHalInteractiveModeFromDisplayConfig = resources.getBoolean(com.android.internal.R.bool.config_powerDecoupleInteractiveModeFromDisplay);
    mWakeUpWhenPluggedOrUnpluggedConfig = resources.getBoolean(com.android.internal.R.bool.config_unplugTurnsOnScreen);
    mWakeUpWhenPluggedOrUnpluggedInTheaterModeConfig = resources.getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromUnplug);
    mSuspendWhenScreenOffDueToProximityConfig = resources.getBoolean(com.android.internal.R.bool.config_suspendWhenScreenOffDueToProximity);
    mDreamsSupportedConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsSupported);
    mDreamsEnabledByDefaultConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsEnabledByDefault);
    mDreamsActivatedOnSleepByDefaultConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsActivatedOnSleepByDefault);
    mDreamsActivatedOnDockByDefaultConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsActivatedOnDockByDefault);
    mDreamsEnabledOnBatteryConfig = resources.getBoolean(com.android.internal.R.bool.config_dreamsEnabledOnBattery);
    mDreamsBatteryLevelMinimumWhenPoweredConfig = resources.getInteger(com.android.internal.R.integer.config_dreamsBatteryLevelMinimumWhenPowered);
    mDreamsBatteryLevelMinimumWhenNotPoweredConfig = resources.getInteger(com.android.internal.R.integer.config_dreamsBatteryLevelMinimumWhenNotPowered);
    mDreamsBatteryLevelDrainCutoffConfig = resources.getInteger(com.android.internal.R.integer.config_dreamsBatteryLevelDrainCutoff);
    mDozeAfterScreenOffConfig = resources.getBoolean(com.android.internal.R.bool.config_dozeAfterScreenOff);
    mMinimumScreenOffTimeoutConfig = resources.getInteger(com.android.internal.R.integer.config_minimumScreenOffTimeout);
    mMaximumScreenDimDurationConfig = resources.getInteger(com.android.internal.R.integer.config_maximumScreenDimDuration);
    mMaximumScreenDimRatioConfig = resources.getFraction(com.android.internal.R.fraction.config_maximumScreenDimRatio, 1, 1);
    mSupportsDoubleTapWakeConfig = resources.getBoolean(com.android.internal.R.bool.config_supportDoubleTapWake);
    mProximityWakeSupported = resources.getBoolean(org.cyanogenmod.platform.internal.R.bool.config_proximityCheckOnWake);
    mProximityWakeEnabledByDefaultConfig = resources.getBoolean(org.cyanogenmod.platform.internal.R.bool.config_proximityCheckOnWakeEnabledByDefault);
    mProximityTimeOut = resources.getInteger(org.cyanogenmod.platform.internal.R.integer.config_proximityCheckTimeout);
    if (mProximityWakeSupported) {
        mProximityWakeLock = ((PowerManager) mContext.getSystemService(Context.POWER_SERVICE)).newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "ProximityWakeLock");
    }
    mButtonLightOnKeypressOnly = resources.getBoolean(com.android.internal.R.bool.config_buttonLightOnKeypressOnly);
}
#end_block

#method_before
private boolean userActivityNoUpdateLocked(long eventTime, int event, int flags, int uid) {
    if (DEBUG_SPEW) {
        Slog.d(TAG, "userActivityNoUpdateLocked: eventTime=" + eventTime + ", event=" + event + ", flags=0x" + Integer.toHexString(flags) + ", uid=" + uid);
    }
    if (eventTime < mLastSleepTime || eventTime < mLastWakeTime || !mBootCompleted || !mSystemReady) {
        return false;
    }
    Trace.traceBegin(Trace.TRACE_TAG_POWER, "userActivity");
    try {
        mEvent = event;
        if (eventTime > mLastInteractivePowerHintTime) {
            powerHintInternal(POWER_HINT_INTERACTION, 0);
            mLastInteractivePowerHintTime = eventTime;
        }
        mNotifier.onUserActivity(event, uid);
        if (mUserInactiveOverrideFromWindowManager) {
            mUserInactiveOverrideFromWindowManager = false;
            mOverriddenTimeout = -1;
        }
        if (mWakefulness == WAKEFULNESS_ASLEEP || mWakefulness == WAKEFULNESS_DOZING || (flags & PowerManager.USER_ACTIVITY_FLAG_INDIRECT) != 0) {
            return false;
        }
        if ((event & PowerManager.USER_ACTIVITY_EVENT_BUTTON) != 0) {
            mLastButtonActivityTime = eventTime;
        }
        if ((flags & PowerManager.USER_ACTIVITY_FLAG_NO_CHANGE_LIGHTS) != 0) {
            if (eventTime > mLastUserActivityTimeNoChangeLights && eventTime > mLastUserActivityTime) {
                mLastUserActivityTimeNoChangeLights = eventTime;
                mDirty |= DIRTY_USER_ACTIVITY;
                return true;
            }
        } else {
            if (eventTime > mLastUserActivityTime) {
                mLastUserActivityTime = eventTime;
                mDirty |= DIRTY_USER_ACTIVITY;
                return true;
            }
        }
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_POWER);
    }
    return false;
}
#method_after
private boolean userActivityNoUpdateLocked(long eventTime, int event, int flags, int uid) {
    if (DEBUG_SPEW) {
        Slog.d(TAG, "userActivityNoUpdateLocked: eventTime=" + eventTime + ", event=" + event + ", flags=0x" + Integer.toHexString(flags) + ", uid=" + uid);
    }
    if (eventTime < mLastSleepTime || eventTime < mLastWakeTime || !mBootCompleted || !mSystemReady) {
        return false;
    }
    Trace.traceBegin(Trace.TRACE_TAG_POWER, "userActivity");
    try {
        if (eventTime > mLastInteractivePowerHintTime) {
            powerHintInternal(POWER_HINT_INTERACTION, 0);
            mLastInteractivePowerHintTime = eventTime;
        }
        mNotifier.onUserActivity(event, uid);
        if (mUserInactiveOverrideFromWindowManager) {
            mUserInactiveOverrideFromWindowManager = false;
            mOverriddenTimeout = -1;
        }
        if (mWakefulness == WAKEFULNESS_ASLEEP || mWakefulness == WAKEFULNESS_DOZING || (flags & PowerManager.USER_ACTIVITY_FLAG_INDIRECT) != 0) {
            return false;
        }
        if ((flags & PowerManager.USER_ACTIVITY_FLAG_NO_CHANGE_LIGHTS) != 0) {
            if (eventTime > mLastUserActivityTimeNoChangeLights && eventTime > mLastUserActivityTime) {
                mLastUserActivityTimeNoChangeLights = eventTime;
                mDirty |= DIRTY_USER_ACTIVITY;
                return true;
            }
        } else {
            if (eventTime > mLastUserActivityTime) {
                mButtonPressed = event == PowerManager.USER_ACTIVITY_EVENT_BUTTON;
                if (mButtonLightOnKeypressOnly && mButtonPressed) {
                    mLastButtonActivityTime = eventTime;
                }
                mLastUserActivityTime = eventTime;
                mDirty |= DIRTY_USER_ACTIVITY;
                return true;
            }
        }
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_POWER);
    }
    return false;
}
#end_block

#method_before
private void updateUserActivitySummaryLocked(long now, int dirty) {
    // Update the status of the user activity timeout timer.
    if ((dirty & (DIRTY_WAKE_LOCKS | DIRTY_USER_ACTIVITY | DIRTY_WAKEFULNESS | DIRTY_SETTINGS)) != 0) {
        mHandler.removeMessages(MSG_USER_ACTIVITY_TIMEOUT);
        long nextTimeout = 0;
        if (mWakefulness == WAKEFULNESS_AWAKE || mWakefulness == WAKEFULNESS_DREAMING || mWakefulness == WAKEFULNESS_DOZING) {
            final int sleepTimeout = getSleepTimeoutLocked();
            final int screenOffTimeout = getScreenOffTimeoutLocked(sleepTimeout);
            final int screenDimDuration = getScreenDimDurationLocked(screenOffTimeout);
            final boolean userInactiveOverride = mUserInactiveOverrideFromWindowManager;
            final boolean buttonPressed = mButtonLightOnKeypressOnly ? (mEvent == PowerManager.USER_ACTIVITY_EVENT_BUTTON) : true;
            mUserActivitySummary = 0;
            if (mLastUserActivityTime >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTime + screenOffTimeout - screenDimDuration;
                if (now < nextTimeout) {
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                    if (mWakefulness == WAKEFULNESS_AWAKE) {
                        int buttonBrightness, keyboardBrightness;
                        if (mButtonBrightnessOverrideFromWindowManager >= 0) {
                            buttonBrightness = mButtonBrightnessOverrideFromWindowManager;
                            keyboardBrightness = mButtonBrightnessOverrideFromWindowManager;
                        } else {
                            if (!mForceNavbar) {
                                buttonBrightness = mButtonBrightness;
                            } else {
                                buttonBrightness = 0;
                            }
                            keyboardBrightness = mKeyboardBrightness;
                        }
                        mKeyboardLight.setBrightness(mKeyboardVisible ? keyboardBrightness : 0);
                        mLastButtonActivityTime = mButtonLightOnKeypressOnly ? mLastButtonActivityTime : mLastUserActivityTime;
                        if (mButtonTimeout != 0 && now > mLastButtonActivityTime + mButtonTimeout) {
                            mButtonsLight.setBrightness(0);
                        } else {
                            if (buttonPressed && !mProximityPositive) {
                                mButtonsLight.setBrightness(buttonBrightness);
                                if (buttonBrightness != 0 && mButtonTimeout != 0) {
                                    nextTimeout = now + mButtonTimeout;
                                }
                            }
                        }
                    }
                } else {
                    nextTimeout = mLastUserActivityTime + screenOffTimeout;
                    if (now < nextTimeout) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                        if (mWakefulness == WAKEFULNESS_AWAKE) {
                            mButtonsLight.setBrightness(0);
                            mKeyboardLight.setBrightness(0);
                        }
                    }
                }
            }
            if (mUserActivitySummary == 0 && mLastUserActivityTimeNoChangeLights >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTimeNoChangeLights + screenOffTimeout;
                if (now < nextTimeout) {
                    if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_BRIGHT) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                    } else if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_DIM) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                    }
                }
            }
            if (mUserActivitySummary == 0) {
                if (sleepTimeout >= 0) {
                    final long anyUserActivity = Math.max(mLastUserActivityTime, mLastUserActivityTimeNoChangeLights);
                    if (anyUserActivity >= mLastWakeTime) {
                        nextTimeout = anyUserActivity + sleepTimeout;
                        if (now < nextTimeout) {
                            mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                        }
                    }
                } else {
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                    nextTimeout = -1;
                }
            }
            if (mUserActivitySummary != USER_ACTIVITY_SCREEN_DREAM && userInactiveOverride) {
                if ((mUserActivitySummary & (USER_ACTIVITY_SCREEN_BRIGHT | USER_ACTIVITY_SCREEN_DIM)) != 0) {
                    // Device is being kept awake by recent user activity
                    if (nextTimeout >= now && mOverriddenTimeout == -1) {
                        // Save when the next timeout would have occurred
                        mOverriddenTimeout = nextTimeout;
                    }
                }
                mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                nextTimeout = -1;
            }
            if (mUserActivitySummary != 0 && nextTimeout >= 0) {
                Message msg = mHandler.obtainMessage(MSG_USER_ACTIVITY_TIMEOUT);
                msg.setAsynchronous(true);
                mHandler.sendMessageAtTime(msg, nextTimeout);
            }
        } else {
            mUserActivitySummary = 0;
        }
        if (DEBUG_SPEW) {
            Slog.d(TAG, "updateUserActivitySummaryLocked: mWakefulness=" + PowerManagerInternal.wakefulnessToString(mWakefulness) + ", mUserActivitySummary=0x" + Integer.toHexString(mUserActivitySummary) + ", nextTimeout=" + TimeUtils.formatUptime(nextTimeout));
        }
    }
}
#method_after
private void updateUserActivitySummaryLocked(long now, int dirty) {
    // Update the status of the user activity timeout timer.
    if ((dirty & (DIRTY_WAKE_LOCKS | DIRTY_USER_ACTIVITY | DIRTY_WAKEFULNESS | DIRTY_SETTINGS)) != 0) {
        mHandler.removeMessages(MSG_USER_ACTIVITY_TIMEOUT);
        long nextTimeout = 0;
        if (mWakefulness == WAKEFULNESS_AWAKE || mWakefulness == WAKEFULNESS_DREAMING || mWakefulness == WAKEFULNESS_DOZING) {
            final int sleepTimeout = getSleepTimeoutLocked();
            final int screenOffTimeout = getScreenOffTimeoutLocked(sleepTimeout);
            final int screenDimDuration = getScreenDimDurationLocked(screenOffTimeout);
            final boolean userInactiveOverride = mUserInactiveOverrideFromWindowManager;
            mUserActivitySummary = 0;
            if (mLastUserActivityTime >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTime + screenOffTimeout - screenDimDuration;
                if (now < nextTimeout) {
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                    if (mWakefulness == WAKEFULNESS_AWAKE) {
                        int buttonBrightness, keyboardBrightness;
                        if (mButtonBrightnessOverrideFromWindowManager >= 0) {
                            buttonBrightness = mButtonBrightnessOverrideFromWindowManager;
                            keyboardBrightness = mButtonBrightnessOverrideFromWindowManager;
                        } else {
                            if (!mForceNavbar) {
                                buttonBrightness = mButtonBrightness;
                            } else {
                                buttonBrightness = 0;
                            }
                            keyboardBrightness = mKeyboardBrightness;
                        }
                        mKeyboardLight.setBrightness(mKeyboardVisible ? keyboardBrightness : 0);
                        mLastButtonActivityTime = mButtonLightOnKeypressOnly ? mLastButtonActivityTime : mLastUserActivityTime;
                        if (mButtonTimeout != 0 && now > mLastButtonActivityTime + mButtonTimeout) {
                            mButtonsLight.setBrightness(0);
                        } else {
                            if ((!mButtonLightOnKeypressOnly || mButtonPressed) && !mProximityPositive) {
                                mButtonsLight.setBrightness(buttonBrightness);
                                mButtonPressed = false;
                                if (buttonBrightness != 0 && mButtonTimeout != 0) {
                                    nextTimeout = now + mButtonTimeout;
                                }
                            }
                        }
                    }
                } else {
                    nextTimeout = mLastUserActivityTime + screenOffTimeout;
                    if (now < nextTimeout) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                        if (mWakefulness == WAKEFULNESS_AWAKE) {
                            mButtonsLight.setBrightness(0);
                            mKeyboardLight.setBrightness(0);
                        }
                    }
                }
            }
            if (mUserActivitySummary == 0 && mLastUserActivityTimeNoChangeLights >= mLastWakeTime) {
                nextTimeout = mLastUserActivityTimeNoChangeLights + screenOffTimeout;
                if (now < nextTimeout) {
                    if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_BRIGHT) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;
                    } else if (mDisplayPowerRequest.policy == DisplayPowerRequest.POLICY_DIM) {
                        mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;
                    }
                }
            }
            if (mUserActivitySummary == 0) {
                if (sleepTimeout >= 0) {
                    final long anyUserActivity = Math.max(mLastUserActivityTime, mLastUserActivityTimeNoChangeLights);
                    if (anyUserActivity >= mLastWakeTime) {
                        nextTimeout = anyUserActivity + sleepTimeout;
                        if (now < nextTimeout) {
                            mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                        }
                    }
                } else {
                    mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                    nextTimeout = -1;
                }
            }
            if (mUserActivitySummary != USER_ACTIVITY_SCREEN_DREAM && userInactiveOverride) {
                if ((mUserActivitySummary & (USER_ACTIVITY_SCREEN_BRIGHT | USER_ACTIVITY_SCREEN_DIM)) != 0) {
                    // Device is being kept awake by recent user activity
                    if (nextTimeout >= now && mOverriddenTimeout == -1) {
                        // Save when the next timeout would have occurred
                        mOverriddenTimeout = nextTimeout;
                    }
                }
                mUserActivitySummary = USER_ACTIVITY_SCREEN_DREAM;
                nextTimeout = -1;
            }
            if (mUserActivitySummary != 0 && nextTimeout >= 0) {
                Message msg = mHandler.obtainMessage(MSG_USER_ACTIVITY_TIMEOUT);
                msg.setAsynchronous(true);
                mHandler.sendMessageAtTime(msg, nextTimeout);
            }
        } else {
            mUserActivitySummary = 0;
        }
        if (DEBUG_SPEW) {
            Slog.d(TAG, "updateUserActivitySummaryLocked: mWakefulness=" + PowerManagerInternal.wakefulnessToString(mWakefulness) + ", mUserActivitySummary=0x" + Integer.toHexString(mUserActivitySummary) + ", nextTimeout=" + TimeUtils.formatUptime(nextTimeout));
        }
    }
}
#end_block

#method_before
@Override
public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
    String url = request.getUrl().toString();
    if (!mWebViewExt.isIncognito() && (IntentUtils.isIntent(view, url) || IntentUtils.startActivityForUrl(view, url))) {
        return true;
    }
    if (mWebViewExt.getRequestHeaders().isEmpty()) {
        return false;
    } else {
        mWebViewExt.loadUrl(url);
        return true;
    }
}
#method_after
@Override
public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
    if (request.isForMainFrame()) {
        WebViewExt webViewExt = (WebViewExt) view;
        String url = request.getUrl().toString();
        boolean needsLookup = request.hasGesture() || !TextUtils.equals(url, webViewExt.getLastLoadedUrl());
        if (!webViewExt.isIncognito() && needsLookup && !request.isRedirect() && startActivityForUrl(view, url)) {
            return true;
        } else if (!webViewExt.getRequestHeaders().isEmpty()) {
            webViewExt.followUrl(url);
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void fetchFile(String url, String fileName) {
    DownloadManager.Request request;
    try {
        request = new DownloadManager.Request(Uri.parse(url));
    } catch (IllegalArgumentException e) {
        Log.e(TAG, "Cannot download non http or https scheme");
        return;
    }
    // Let this downloaded file be scanned by MediaScanner - so that it can
    // show up in Gallery app, for example.
    request.allowScanningByMediaScanner();
    request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);
    request.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, fileName);
    DownloadManager manager = (DownloadManager) getSystemService(DOWNLOAD_SERVICE);
    manager.enqueue(request);
}
#method_after
private void fetchFile(String url, String fileName) {
    DownloadManager.Request request = new DownloadManager.Request(Uri.parse(url));
    // Let this downloaded file be scanned by MediaScanner - so that it can
    // show up in Gallery app, for example.
    request.allowScanningByMediaScanner();
    request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);
    request.setDestinationInExternalPublicDir(Environment.DIRECTORY_DOWNLOADS, fileName);
    DownloadManager manager = (DownloadManager) getSystemService(DOWNLOAD_SERVICE);
    manager.enqueue(request);
}
#end_block

#method_before
@Override
protected void processUnsolicited(Parcel p, int type) {
    Object ret;
    int dataPosition = p.dataPosition();
    int response = p.readInt();
    int newResponse = response;
    switch(response) {
        case RIL_UNSOL_NITZ_TIME_RECEIVED:
            handleNitzTimeReceived(p);
            break;
        case RIL_UNSOL_ON_SS_LL:
            newResponse = RIL_UNSOL_ON_SS;
            break;
    }
    if (newResponse != response) {
        p.setDataPosition(dataPosition);
        p.writeInt(newResponse);
    }
    p.setDataPosition(dataPosition);
    super.processUnsolicited(p, type);
}
#method_after
@Override
protected void processUnsolicited(Parcel p, int type) {
    Object ret;
    int dataPosition = p.dataPosition();
    int response = p.readInt();
    int newResponse = response;
    switch(response) {
        case RIL_UNSOL_NITZ_TIME_RECEIVED:
            fixNitz(p);
            break;
        case RIL_UNSOL_ON_SS_LL:
            newResponse = RIL_UNSOL_ON_SS;
            break;
    }
    if (newResponse != response) {
        p.setDataPosition(dataPosition);
        p.writeInt(newResponse);
    }
    p.setDataPosition(dataPosition);
    super.processUnsolicited(p, type);
}
#end_block

#method_before
@Override
public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
    mContext = getActivity();
    mDownloadManager = (DownloadManager) mContext.getSystemService(mContext.DOWNLOAD_SERVICE);
    // Load the layouts
    setPreferencesFromResource(R.xml.main, null);
    mUpdatesList = (PreferenceCategory) findPreference(UPDATES_CATEGORY);
    mUpdateCheck = (ListPreference) findPreference(Constants.UPDATE_CHECK_PREF);
    // Load the stored preference data
    mPrefs = PreferenceManager.getDefaultSharedPreferences(mContext);
    if (mUpdateCheck != null) {
        int check = mPrefs.getInt(Constants.UPDATE_CHECK_PREF, Constants.UPDATE_FREQ_WEEKLY);
        mUpdateCheck.setValue(String.valueOf(check));
        mUpdateCheck.setSummary(mapCheckValue(check));
        mUpdateCheck.setOnPreferenceChangeListener(this);
    }
    // Force a refresh if UPDATE_TYPE_PREF does not match release type
    int updateType = Utils.getUpdateType();
    int updateTypePref = mPrefs.getInt(Constants.UPDATE_TYPE_PREF, Constants.UPDATE_TYPE_SNAPSHOT);
    if (updateTypePref != updateType) {
        updateUpdatesType(updateType);
    }
}
#method_after
@Override
public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
    mContext = getActivity();
    mDownloadManager = (DownloadManager) mContext.getSystemService(mContext.DOWNLOAD_SERVICE);
    // Load the layouts
    setPreferencesFromResource(R.xml.main, null);
    mUpdatesList = (PreferenceCategory) findPreference(UPDATES_CATEGORY);
    mUpdateCheck = (ListPreference) findPreference(Constants.UPDATE_CHECK_PREF);
    // Load the stored preference data
    mPrefs = PreferenceManager.getDefaultSharedPreferences(mContext);
    cleanupPrefs();
    if (mUpdateCheck != null) {
        int check = mPrefs.getInt(Constants.UPDATE_CHECK_PREF, Constants.UPDATE_FREQ_WEEKLY);
        mUpdateCheck.setValue(String.valueOf(check));
        mUpdateCheck.setSummary(mapCheckValue(check));
        mUpdateCheck.setOnPreferenceChangeListener(this);
    }
    // Force a refresh if UPDATE_TYPE_PREF does not match release type
    String updateType = Utils.getUpdateType();
    String updateTypePref = mPrefs.getString(Constants.UPDATE_TYPE_PREF, Constants.CM_UPDATE_TYPE_DEFAULT);
    if (!TextUtils.equals(updateTypePref, updateType)) {
        updateUpdatesType(updateType);
    }
}
#end_block

#method_before
private void updateUpdatesType(int type) {
    mPrefs.edit().putInt(Constants.UPDATE_TYPE_PREF, type).apply();
    checkForUpdates();
}
#method_after
private void updateUpdatesType(String type) {
    mPrefs.edit().putString(Constants.UPDATE_TYPE_PREF, type).apply();
    checkForUpdates();
}
#end_block

#method_before
public static String getInstalledVersion() {
    return SystemProperties.get("ro.cm.version");
}
#method_after
public static String getInstalledVersion() {
    return SystemProperties.get("ro.cm.version").toLowerCase();
}
#end_block

#method_before
public static String getInstalledBuildType() {
    return SystemProperties.get("ro.cm.releasetype", Constants.CM_RELEASETYPE_UNOFFICIAL);
}
#method_after
public static String getInstalledBuildType() {
    return SystemProperties.get(Constants.PROPERTY_CM_RELEASETYPE, Constants.CM_RELEASE_TYPE_DEFAULT).toLowerCase();
}
#end_block

#method_before
public static long getTimestampFromFileName(String fileName) {
    String[] subStrings = fileName.split("-");
    if (subStrings.length < 3 || subStrings[2].length() < 8) {
        Log.e(TAG, "The given filename is not valid: " + fileName);
        return 0;
    }
    try {
        int year = Integer.parseInt(subStrings[2].substring(0, 4));
        int month = Integer.parseInt(subStrings[2].substring(4, 6)) - 1;
        int day = Integer.parseInt(subStrings[2].substring(6, 8));
        Calendar cal = Calendar.getInstance();
        cal.set(year, month, day);
        return cal.getTimeInMillis() / 1000;
    } catch (NumberFormatException e) {
        Log.e(TAG, "The given filename is not valid: " + fileName);
        return 0;
    }
}
#method_after
public static long getTimestampFromFileName(String fileName) {
    String[] subStrings = fileName.split("-");
    if (subStrings.length < 3 || subStrings[2].length() < 8) {
        Log.e(TAG, "The given filename is not valid: " + fileName);
        return 0;
    }
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyyMMdd");
    try {
        return (dateFormat.parse(subStrings[2]).getTime() / 1000);
    } catch (ParseException e) {
        Log.e(TAG, "The given filename is not valid: " + fileName);
        return 0;
    }
}
#end_block

#method_before
public static String getTypeFromFileName(String fileName) {
    String[] subStrings = fileName.split("-");
    if (subStrings.length < 4 || subStrings[3].length() < 2) {
        Log.e(TAG, "The given filename is not valid: " + fileName);
        return "???????";
    }
    return subStrings[3].toLowerCase();
}
#method_after
public static String getTypeFromFileName(String fileName) {
    String[] subStrings = fileName.split("-");
    if (subStrings.length < 4 || subStrings[3].length() < 7) {
        Log.e(TAG, "The given filename is not valid: " + fileName);
        return "???????";
    }
    return subStrings[3];
}
#end_block

#method_before
public static int getUpdateType() {
    String releaseType;
    try {
        releaseType = SystemProperties.get(Constants.PROPERTY_CM_RELEASETYPE);
    } catch (IllegalArgumentException e) {
        releaseType = Constants.CM_RELEASETYPE_UNOFFICIAL;
    }
    int updateType;
    switch(releaseType) {
        case Constants.CM_RELEASETYPE_SNAPSHOT:
            updateType = Constants.UPDATE_TYPE_SNAPSHOT;
            break;
        case Constants.CM_RELEASETYPE_NIGHTLY:
            updateType = Constants.UPDATE_TYPE_NIGHTLY;
            break;
        case Constants.CM_RELEASETYPE_EXPERIMENTAL:
            updateType = Constants.UPDATE_TYPE_EXPERIMENTAL;
            break;
        case Constants.CM_RELEASETYPE_UNOFFICIAL:
        default:
            updateType = Constants.UPDATE_TYPE_UNOFFICIAL;
            break;
    }
    return updateType;
}
#method_after
public static String getUpdateType() {
    return getInstalledBuildType();
}
#end_block

#method_before
@Override
public void onBindViewHolder(PreferenceViewHolder view) {
    super.onBindViewHolder(view);
    mBuildType = mUpdateInfo.getTypeString().toLowerCase();
    mBuildVersionName = mUpdateInfo.getVersion();
    mBuildDateString = Utils.getDateLocalized(mContext, mUpdateInfo.getDate());
    // Store the views from the layout
    mTitleText = (TextView) view.findViewById(R.id.title);
    mSummaryText = (TextView) view.findViewById(R.id.summary);
    mProgressBar = (ProgressBar) view.findViewById(R.id.download_progress_bar);
    mStopDownloadButton = (ImageView) view.findViewById(R.id.updates_button);
    mButton = (Button) view.findViewById(R.id.button);
    mStopDownloadButton.setOnClickListener(mButtonClickListener);
    mButton.setOnClickListener(mButtonClickListener);
    mUpdatesPref = view.findViewById(R.id.updates_pref);
    mUpdatesPref.setOnClickListener(this);
    mUpdatesPref.setOnLongClickListener(this);
    // Update the views
    updatePreferenceViews();
    mSummaryText.setText(String.format(mContext.getString(R.string.summary), mBuildDateString, mBuildVersionName, Utils.getAndroidVersion(mBuildVersionName)));
    if (mOnReadyListener != null) {
        mOnReadyListener.onReady(this);
    }
}
#method_after
@Override
public void onBindViewHolder(PreferenceViewHolder view) {
    super.onBindViewHolder(view);
    mBuildType = mUpdateInfo.getType();
    mBuildVersionName = mUpdateInfo.getVersion();
    mBuildDateString = Utils.getDateLocalized(mContext, mUpdateInfo.getDate());
    // Store the views from the layout
    mTitleText = (TextView) view.findViewById(R.id.title);
    mSummaryText = (TextView) view.findViewById(R.id.summary);
    mProgressBar = (ProgressBar) view.findViewById(R.id.download_progress_bar);
    mStopDownloadButton = (ImageView) view.findViewById(R.id.updates_button);
    mButton = (Button) view.findViewById(R.id.button);
    mStopDownloadButton.setOnClickListener(mButtonClickListener);
    mButton.setOnClickListener(mButtonClickListener);
    mUpdatesPref = view.findViewById(R.id.updates_pref);
    mUpdatesPref.setOnClickListener(this);
    mUpdatesPref.setOnLongClickListener(this);
    // Update the views
    updatePreferenceViews();
    mSummaryText.setText(String.format(mContext.getString(R.string.summary), mBuildDateString, mBuildVersionName, Utils.getAndroidVersion(mBuildVersionName)));
    if (mOnReadyListener != null) {
        mOnReadyListener.onReady(this);
    }
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
    setSupportActionBar(toolbar);
    mCoordinator = (CoordinatorLayout) findViewById(R.id.coordinator_layout);
    SwipeRefreshLayout refreshLayout = (SwipeRefreshLayout) findViewById(R.id.swipe_refresh);
    refreshLayout.setOnRefreshListener(() -> {
        mWebView.reload();
        new Handler().postDelayed(() -> refreshLayout.setRefreshing(false), 1000);
    });
    ProgressBar progressBar = (ProgressBar) findViewById(R.id.load_progress);
    EditTextExt editText = (EditTextExt) findViewById(R.id.url_bar);
    editText.setOnEditorActionListener((v, actionId, event) -> {
        if (actionId == EditorInfo.IME_ACTION_SEARCH) {
            InputMethodManager manager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
            manager.hideSoftInputFromWindow(editText.getApplicationWindowToken(), 0);
            mWebView.loadUrl(editText.getText().toString());
            editText.clearFocus();
            return true;
        }
        return false;
    });
    Intent intent = getIntent();
    String url = intent.getDataString();
    boolean incognito = intent.getBooleanExtra(EXTRA_INCOGNITO, false);
    // Restore from previous instance
    if (savedInstanceState != null) {
        incognito = savedInstanceState.getBoolean(EXTRA_INCOGNITO, incognito);
        if (url == null || url.isEmpty()) {
            url = savedInstanceState.getString(EXTRA_URL, null);
        }
    }
    // Make sure prefs are set before loading them
    PreferenceManager.setDefaultValues(this, R.xml.settings, false);
    setupMenu();
    CookieManager.getInstance().setAcceptCookie(!incognito);
    mWebView = (WebViewExt) findViewById(R.id.web_view);
    mWebView.init(this, editText, progressBar, incognito);
    mWebView.loadUrl(url == null ? PrefsUtils.getHomePage(this) : url);
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
    setSupportActionBar(toolbar);
    mCoordinator = (CoordinatorLayout) findViewById(R.id.coordinator_layout);
    mSwipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.swipe_refresh);
    mSwipeRefreshLayout.setOnRefreshListener(() -> {
        mWebView.reload();
        new Handler().postDelayed(() -> mSwipeRefreshLayout.setRefreshing(false), 1000);
    });
    ProgressBar progressBar = (ProgressBar) findViewById(R.id.load_progress);
    EditTextExt editText = (EditTextExt) findViewById(R.id.url_bar);
    editText.setOnEditorActionListener((v, actionId, event) -> {
        if (actionId == EditorInfo.IME_ACTION_SEARCH) {
            InputMethodManager manager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
            manager.hideSoftInputFromWindow(editText.getApplicationWindowToken(), 0);
            mWebView.loadUrl(editText.getText().toString());
            editText.clearFocus();
            return true;
        }
        return false;
    });
    Intent intent = getIntent();
    String url = intent.getDataString();
    boolean incognito = intent.getBooleanExtra(EXTRA_INCOGNITO, false);
    boolean desktopMode = false;
    // Restore from previous instance
    if (savedInstanceState != null) {
        incognito = savedInstanceState.getBoolean(EXTRA_INCOGNITO, incognito);
        if (url == null || url.isEmpty()) {
            url = savedInstanceState.getString(EXTRA_URL, null);
        }
        desktopMode = savedInstanceState.getBoolean(EXTRA_DESKTOP_MODE, false);
    }
    // Make sure prefs are set before loading them
    PreferenceManager.setDefaultValues(this, R.xml.settings, false);
    setupMenu();
    mWebView = (WebViewExt) findViewById(R.id.web_view);
    mWebView.init(this, editText, progressBar, incognito);
    mWebView.setDesktopMode(desktopMode);
    mWebView.loadUrl(url == null ? PrefsUtils.getHomePage(this) : url);
    mGestureDetector = new GestureDetectorCompat(this, new GestureDetector.SimpleOnGestureListener() {

        @Override
        public boolean onDoubleTapEvent(MotionEvent e) {
            mGestureOngoing = true;
            return false;
        }
    });
    mWebView.setOnTouchListener(this);
    mWebView.setOnScrollChangeListener(this);
}
#end_block

#method_before
@Override
protected void onResume() {
    CookieManager.setAcceptFileSchemeCookies(PrefsUtils.getCookie(this));
    super.onResume();
    if (PrefsUtils.getLookLock(this)) {
        getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE);
    } else {
        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_SECURE);
    }
}
#method_after
@Override
protected void onResume() {
    super.onResume();
    mWebView.onResume();
    CookieManager.getInstance().setAcceptCookie(!mWebView.isIncognito() && PrefsUtils.getCookie(this));
    if (PrefsUtils.getLookLock(this)) {
        getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE);
    } else {
        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_SECURE);
    }
}
#end_block

#method_before
@Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] results) {
    switch(requestCode) {
        case LOCATION_PERM_REQ:
            if (hasLocationPermission()) {
                mWebView.reload();
            }
            break;
        case STORAGE_PERM_REQ:
            if (hasStoragePermission()) {
                if (shouldShowRequestPermissionRationale(Manifest.permission.WRITE_EXTERNAL_STORAGE)) {
                    new AlertDialog.Builder(this).setTitle(R.string.permission_error_title).setMessage(R.string.permission_error_storage).setCancelable(false).setPositiveButton(getString(R.string.permission_error_ask_again), ((dialog, which) -> requestStoragePermission())).setNegativeButton(getString(R.string.dismiss), (((dialog, which) -> dialog.dismiss()))).show();
                } else {
                    Snackbar.make(mCoordinator, getString(R.string.permission_error_forever), Snackbar.LENGTH_LONG).show();
                }
            }
            break;
    }
}
#method_after
@Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] results) {
    switch(requestCode) {
        case LOCATION_PERM_REQ:
            if (hasLocationPermission()) {
                mWebView.reload();
            }
            break;
        case STORAGE_PERM_REQ:
            if (hasStoragePermission() && mWaitingDownloadUrl != null) {
                downloadFileAsk(mWaitingDownloadUrl, mWaitingDownloadName);
            } else {
                if (shouldShowRequestPermissionRationale(Manifest.permission.WRITE_EXTERNAL_STORAGE)) {
                    new AlertDialog.Builder(this).setTitle(R.string.permission_error_title).setMessage(R.string.permission_error_storage).setCancelable(false).setPositiveButton(getString(R.string.permission_error_ask_again), ((dialog, which) -> requestStoragePermission())).setNegativeButton(getString(R.string.dismiss), (((dialog, which) -> dialog.dismiss()))).show();
                } else {
                    Snackbar.make(mCoordinator, getString(R.string.permission_error_forever), Snackbar.LENGTH_LONG).show();
                }
            }
            break;
    }
}
#end_block

#method_before
@Override
public void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    // Preserve webView status
    outState.putString(EXTRA_URL, mWebView.getUrl());
    outState.putBoolean(EXTRA_INCOGNITO, mWebView.isIncognito());
}
#method_after
@Override
public void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    // Preserve webView status
    outState.putString(EXTRA_URL, mWebView.getUrl());
    outState.putBoolean(EXTRA_INCOGNITO, mWebView.isIncognito());
    outState.putBoolean(EXTRA_DESKTOP_MODE, mWebView.isDesktopMode());
}
#end_block

#method_before
private void setupMenu() {
    ImageButton menu = (ImageButton) findViewById(R.id.search_menu);
    menu.setOnClickListener(v -> {
        ContextThemeWrapper wrapper = new ContextThemeWrapper(this, R.style.AppTheme_PopupMenuOverlapAnchor);
        PopupMenu popupMenu = new PopupMenu(wrapper, menu, Gravity.NO_GRAVITY, R.attr.actionOverflowMenuStyle, 0);
        popupMenu.inflate(R.menu.menu_main);
        popupMenu.setOnMenuItemClickListener(item -> {
            switch(item.getItemId()) {
                case R.id.menu_new:
                    openInNewTab(null);
                    break;
                case R.id.menu_incognito:
                    Intent intent = new Intent(this, MainActivity.class);
                    intent.putExtra(EXTRA_INCOGNITO, true);
                    startActivity(intent);
                    break;
                case R.id.menu_reload:
                    mWebView.reload();
                    break;
                case R.id.menu_add_favorite:
                    setAsFavorite(mWebView.getTitle(), mWebView.getUrl());
                    break;
                case R.id.menu_share:
                    // Delay a bit to allow popup menu hide animation to play
                    new Handler().postDelayed(() -> shareUrl(mWebView.getUrl()), 300);
                    break;
                case R.id.menu_favorite:
                    startActivity(new Intent(this, FavoriteActivity.class));
                    break;
                case R.id.menu_history:
                    startActivity(new Intent(this, HistoryActivity.class));
                    break;
                case R.id.menu_shortcut:
                    addShortcut();
                    break;
                case R.id.menu_settings:
                    startActivity(new Intent(this, SettingsActivity.class));
                    break;
            }
            return true;
        });
        // Fuck you, lint
        // noinspection RestrictedApi
        MenuPopupHelper helper = new MenuPopupHelper(wrapper, (MenuBuilder) popupMenu.getMenu(), menu);
        // noinspection RestrictedApi
        helper.setForceShowIcon(true);
        // noinspection RestrictedApi
        helper.show();
    });
}
#method_after
private void setupMenu() {
    ImageButton menu = (ImageButton) findViewById(R.id.search_menu);
    menu.setOnClickListener(v -> {
        boolean isDesktop = mWebView.isDesktopMode();
        ContextThemeWrapper wrapper = new ContextThemeWrapper(this, R.style.AppTheme_PopupMenuOverlapAnchor);
        PopupMenu popupMenu = new PopupMenu(wrapper, menu, Gravity.NO_GRAVITY, R.attr.actionOverflowMenuStyle, 0);
        popupMenu.inflate(R.menu.menu_main);
        MenuItem desktopMode = popupMenu.getMenu().findItem(R.id.desktop_mode);
        desktopMode.setTitle(getString(isDesktop ? R.string.menu_mobile_mode : R.string.menu_desktop_mode));
        desktopMode.setIcon(ContextCompat.getDrawable(this, isDesktop ? R.drawable.ic_mobile : R.drawable.ic_desktop));
        popupMenu.setOnMenuItemClickListener(item -> {
            switch(item.getItemId()) {
                case R.id.menu_new:
                    openInNewTab(null);
                    break;
                case R.id.menu_incognito:
                    Intent intent = new Intent(this, MainActivity.class);
                    intent.putExtra(EXTRA_INCOGNITO, true);
                    startActivity(intent);
                    break;
                case R.id.menu_reload:
                    mWebView.reload();
                    break;
                case R.id.menu_add_favorite:
                    setAsFavorite(mWebView.getTitle(), mWebView.getUrl());
                    break;
                case R.id.menu_share:
                    // Delay a bit to allow popup menu hide animation to play
                    new Handler().postDelayed(() -> shareUrl(mWebView.getUrl()), 300);
                    break;
                case R.id.menu_favorite:
                    startActivity(new Intent(this, FavoriteActivity.class));
                    break;
                case R.id.menu_history:
                    startActivity(new Intent(this, HistoryActivity.class));
                    break;
                case R.id.menu_shortcut:
                    addShortcut();
                    break;
                case R.id.menu_settings:
                    startActivity(new Intent(this, SettingsActivity.class));
                    break;
                case R.id.desktop_mode:
                    mWebView.setDesktopMode(!isDesktop);
                    desktopMode.setTitle(getString(isDesktop ? R.string.menu_desktop_mode : R.string.menu_mobile_mode));
                    desktopMode.setIcon(ContextCompat.getDrawable(this, isDesktop ? R.drawable.ic_desktop : R.drawable.ic_mobile));
                    break;
            }
            return true;
        });
        // Fuck you, lint
        // noinspection RestrictedApi
        MenuPopupHelper helper = new MenuPopupHelper(wrapper, (MenuBuilder) popupMenu.getMenu(), menu);
        // noinspection RestrictedApi
        helper.setForceShowIcon(true);
        // noinspection RestrictedApi
        helper.show();
    });
}
#end_block

#method_before
private void shareUrl(String url) {
    Intent intent = new Intent(Intent.ACTION_SEND);
    intent.putExtra(Intent.EXTRA_TEXT, url);
    if (PrefsUtils.getAdvancedShare(this) && url.equals(mWebView.getUrl())) {
        try {
            File file = new File(getCacheDir(), String.valueOf(System.currentTimeMillis()) + ".png");
            FileOutputStream out = new FileOutputStream(file);
            Bitmap bm = mWebView.getSnap();
            if (bm == null) {
                return;
            }
            bm.compress(Bitmap.CompressFormat.PNG, 70, out);
            out.flush();
            out.close();
            intent.putExtra(Intent.EXTRA_STREAM, FileProvider.getUriForFile(this, PROVIDER, file));
            intent.setType("image/png");
            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
        } catch (IOException e) {
            Log.e(TAG, e.getMessage());
        }
    } else {
        intent.setType("text/plain");
    }
    startActivity(Intent.createChooser(intent, getString(R.string.share_title)));
}
#method_after
private void shareUrl(String url) {
    Intent intent = new Intent(Intent.ACTION_SEND);
    intent.putExtra(Intent.EXTRA_TEXT, url);
    if (PrefsUtils.getAdvancedShare(this) && url.equals(mWebView.getUrl())) {
        try {
            File file = new File(getCacheDir(), String.valueOf(System.currentTimeMillis()) + ".png");
            FileOutputStream out = new FileOutputStream(file);
            Bitmap bm = mWebView.getSnap();
            if (bm == null) {
                out.close();
                return;
            }
            bm.compress(Bitmap.CompressFormat.PNG, 70, out);
            out.flush();
            out.close();
            intent.putExtra(Intent.EXTRA_STREAM, FileProvider.getUriForFile(this, PROVIDER, file));
            intent.setType("image/png");
            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
        } catch (IOException e) {
            Log.e(TAG, e.getMessage());
        }
    } else {
        intent.setType("text/plain");
    }
    startActivity(Intent.createChooser(intent, getString(R.string.share_title)));
}
#end_block

#method_before
public void downloadFileAsk(String url, String fileName) {
    if (!hasStoragePermission()) {
        requestStoragePermission();
        return;
    }
    new AlertDialog.Builder(this).setTitle(R.string.download_title).setMessage(getString(R.string.download_message, fileName)).setPositiveButton(getString(R.string.download_positive), (dialog, which) -> fetchFile(url, fileName)).setNegativeButton(getString(R.string.dismiss), ((dialog, which) -> dialog.dismiss())).show();
}
#method_after
public void downloadFileAsk(String url, String fileName) {
    if (!hasStoragePermission()) {
        mWaitingDownloadUrl = url;
        mWaitingDownloadName = fileName;
        requestStoragePermission();
        return;
    }
    mWaitingDownloadUrl = null;
    mWaitingDownloadName = null;
    new AlertDialog.Builder(this).setTitle(R.string.download_title).setMessage(getString(R.string.download_message, fileName)).setPositiveButton(getString(R.string.download_positive), (dialog, which) -> fetchFile(url, fileName)).setNegativeButton(getString(R.string.dismiss), ((dialog, which) -> dialog.dismiss())).show();
}
#end_block

#method_before
public void showSheetMenu(String url, boolean shouldAllowDownload) {
    final BottomSheetDialog sheet = new BottomSheetDialog(this);
    @SuppressLint("InflateParams")
    View view = getLayoutInflater().inflate(R.layout.sheet_actions, null);
    View tabLayout = view.findViewById(R.id.sheet_new_tab);
    View shareLayout = view.findViewById(R.id.sheet_share);
    View favouriteLayout = view.findViewById(R.id.sheet_favourite);
    View downloadLayout = view.findViewById(R.id.sheet_download);
    tabLayout.setOnClickListener(v -> openInNewTab(url));
    shareLayout.setOnClickListener(v -> shareUrl(url));
    favouriteLayout.setOnClickListener(v -> setAsFavorite(url, url));
    if (shouldAllowDownload) {
        downloadLayout.setOnClickListener(v -> downloadFileAsk(url, ""));
        downloadLayout.setVisibility(View.VISIBLE);
    }
    sheet.setContentView(view);
    sheet.show();
}
#method_after
public void showSheetMenu(String url, boolean shouldAllowDownload) {
    final BottomSheetDialog sheet = new BottomSheetDialog(this);
    View view = getLayoutInflater().inflate(R.layout.sheet_actions, new LinearLayout(this));
    View tabLayout = view.findViewById(R.id.sheet_new_tab);
    View shareLayout = view.findViewById(R.id.sheet_share);
    View favouriteLayout = view.findViewById(R.id.sheet_favourite);
    View downloadLayout = view.findViewById(R.id.sheet_download);
    tabLayout.setOnClickListener(v -> openInNewTab(url));
    shareLayout.setOnClickListener(v -> shareUrl(url));
    favouriteLayout.setOnClickListener(v -> setAsFavorite(url, url));
    if (shouldAllowDownload) {
        downloadLayout.setOnClickListener(v -> downloadFileAsk(url, ""));
        downloadLayout.setVisibility(View.VISIBLE);
    }
    sheet.setContentView(view);
    sheet.show();
}
#end_block

#method_before
@Override
public void onChange(boolean selfChange, Uri uri) {
    if (selfChange)
        return;
    if (BRIGHTNESS_MODE_URI.equals(uri)) {
        mBackgroundHandler.post(mUpdateModeRunnable);
        mBackgroundHandler.post(mUpdateSliderRunnable);
    } else if (BRIGHTNESS_URI.equals(uri) && !mAutomatic) {
        mBackgroundHandler.post(mUpdateSliderRunnable);
    } else if (BRIGHTNESS_ADJ_URI.equals(uri) && mAutomatic) {
        mBackgroundHandler.post(mUpdateSliderRunnable);
    } else {
        mBackgroundHandler.post(mUpdateModeRunnable);
        mBackgroundHandler.post(mUpdateSliderRunnable);
    }
    for (BrightnessStateChangeCallback cb : mChangeCallbacks) {
        cb.onBrightnessLevelChanged();
    }
}
#method_after
@Override
public void onChange(boolean selfChange, Uri uri) {
    if (selfChange)
        return;
    if (BRIGHTNESS_MODE_URI.equals(uri)) {
        mBackgroundHandler.post(mUpdateModeRunnable);
        mBackgroundHandler.post(mUpdateSliderRunnable);
    } else if (BRIGHTNESS_URI.equals(uri) && !mAutomatic) {
        mBackgroundHandler.post(mUpdateSliderRunnable);
    } else if (BRIGHTNESS_FOR_VR_URI.equals(uri)) {
        mBackgroundHandler.post(mUpdateSliderRunnable);
    } else if (BRIGHTNESS_ADJ_URI.equals(uri) && mAutomatic) {
        mBackgroundHandler.post(mUpdateSliderRunnable);
    } else {
        mBackgroundHandler.post(mUpdateModeRunnable);
        mBackgroundHandler.post(mUpdateSliderRunnable);
    }
    for (BrightnessStateChangeCallback cb : mChangeCallbacks) {
        cb.onBrightnessLevelChanged();
    }
}
#end_block

#method_before
public void startObserving() {
    final ContentResolver cr = mContext.getContentResolver();
    cr.unregisterContentObserver(this);
    cr.registerContentObserver(BRIGHTNESS_MODE_URI, false, this, UserHandle.USER_ALL);
    cr.registerContentObserver(BRIGHTNESS_URI, false, this, UserHandle.USER_ALL);
    cr.registerContentObserver(BRIGHTNESS_ADJ_URI, false, this, UserHandle.USER_ALL);
}
#method_after
public void startObserving() {
    final ContentResolver cr = mContext.getContentResolver();
    cr.unregisterContentObserver(this);
    cr.registerContentObserver(BRIGHTNESS_MODE_URI, false, this, UserHandle.USER_ALL);
    cr.registerContentObserver(BRIGHTNESS_URI, false, this, UserHandle.USER_ALL);
    cr.registerContentObserver(BRIGHTNESS_FOR_VR_URI, false, this, UserHandle.USER_ALL);
    cr.registerContentObserver(BRIGHTNESS_ADJ_URI, false, this, UserHandle.USER_ALL);
}
#end_block

#method_before
public void registerCallbacks() {
    if (mListening) {
        return;
    }
    mBackgroundHandler.post(mStartListeningRunnable);
    mListening = true;
}
#method_after
public void registerCallbacks() {
    if (mListening) {
        return;
    }
    if (mVrManager != null) {
        try {
            mVrManager.registerListener(mVrStateCallbacks);
            mIsVrModeEnabled = mVrManager.getVrModeState();
        } catch (RemoteException e) {
            Log.e(TAG, "Failed to register VR mode state listener: ", e);
        }
    }
    mBackgroundHandler.post(mStartListeningRunnable);
    mListening = true;
}
#end_block

#method_before
public void unregisterCallbacks() {
    if (!mListening) {
        return;
    }
    mBackgroundHandler.post(mStopListeningRunnable);
    mListening = false;
}
#method_after
public void unregisterCallbacks() {
    if (!mListening) {
        return;
    }
    if (mVrManager != null) {
        try {
            mVrManager.unregisterListener(mVrStateCallbacks);
        } catch (RemoteException e) {
            Log.e(TAG, "Failed to unregister VR mode state listener: ", e);
        }
    }
    mBackgroundHandler.post(mStopListeningRunnable);
    mListening = false;
}
#end_block

#method_before
@Override
public void onChanged(ToggleSlider view, boolean tracking, boolean automatic, int value, boolean stopTracking) {
    updateIcon(mAutomatic);
    if (mExternalChange)
        return;
    if (!mAutomatic) {
        final int val = value + mMinimumBacklight;
        if (stopTracking) {
            MetricsLogger.action(mContext, MetricsEvent.ACTION_BRIGHTNESS, val);
        }
        setBrightness(val);
        if (!tracking) {
            AsyncTask.execute(new Runnable() {

                public void run() {
                    Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, val, UserHandle.USER_CURRENT);
                }
            });
        }
    } else {
        final float adj = value / (BRIGHTNESS_ADJ_RESOLUTION / 2f) - 1;
        if (stopTracking) {
            MetricsLogger.action(mContext, MetricsEvent.ACTION_BRIGHTNESS_AUTO, value);
        }
        setBrightnessAdj(adj);
        if (!tracking) {
            AsyncTask.execute(new Runnable() {

                public void run() {
                    Settings.System.putFloatForUser(mContext.getContentResolver(), Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ, adj, UserHandle.USER_CURRENT);
                }
            });
        }
    }
    for (BrightnessStateChangeCallback cb : mChangeCallbacks) {
        cb.onBrightnessLevelChanged();
    }
}
#method_after
@Override
public void onChanged(ToggleSlider view, boolean tracking, boolean automatic, int value, boolean stopTracking) {
    updateIcon(mAutomatic);
    if (mExternalChange)
        return;
    if (mIsVrModeEnabled) {
        final int val = value + mMinimumBacklightForVr;
        if (stopTracking) {
            MetricsLogger.action(mContext, MetricsEvent.ACTION_BRIGHTNESS_FOR_VR, val);
        }
        setBrightness(val);
        if (!tracking) {
            AsyncTask.execute(new Runnable() {

                public void run() {
                    Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_FOR_VR, val, UserHandle.USER_CURRENT);
                }
            });
        }
    } else if (!mAutomatic) {
        final int val = value + mMinimumBacklight;
        if (stopTracking) {
            MetricsLogger.action(mContext, MetricsEvent.ACTION_BRIGHTNESS, val);
        }
        setBrightness(val);
        if (!tracking) {
            AsyncTask.execute(new Runnable() {

                public void run() {
                    Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, val, UserHandle.USER_CURRENT);
                }
            });
        }
    } else {
        final float adj = value / (BRIGHTNESS_ADJ_RESOLUTION / 2f) - 1;
        if (stopTracking) {
            MetricsLogger.action(mContext, MetricsEvent.ACTION_BRIGHTNESS_AUTO, value);
        }
        setBrightnessAdj(adj);
        if (!tracking) {
            AsyncTask.execute(new Runnable() {

                public void run() {
                    Settings.System.putFloatForUser(mContext.getContentResolver(), Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ, adj, UserHandle.USER_CURRENT);
                }
            });
        }
    }
    for (BrightnessStateChangeCallback cb : mChangeCallbacks) {
        cb.onBrightnessLevelChanged();
    }
}
#end_block

#method_before
@Override
protected void onHandleIntent(Intent intent) {
    if (!intent.hasExtra(Constants.DOWNLOAD_ID)) {
        return;
    }
    long id = intent.getLongExtra(Constants.DOWNLOAD_ID, -1);
    Intent updateIntent = new Intent(this, UpdatesActivity.class);
    updateIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    int status = fetchDownloadStatus(id);
    if (status == DownloadManager.STATUS_SUCCESSFUL) {
        // Get the full path name of the downloaded file
        // Strip off the .partial at the end to get the completed file
        String partialFileFullPath = mPrefs.getString(Constants.DOWNLOAD_NAME, null);
        if (partialFileFullPath == null) {
            displayErrorResult(updateIntent, R.string.unable_to_download_file);
        }
        String destName = new File(partialFileFullPath).getName().replace(".partial", "");
        String destPath = Utils.makeUpdateFolder(getApplicationContext()).getPath() + "/" + destName;
        File destFile = new File(destPath);
        mPrefs.edit().putString(Constants.DOWNLOAD_NAME, "").commit();
        try {
            FileOutputStream outStream = new FileOutputStream(destFile);
            ParcelFileDescriptor file = mDm.openDownloadedFile(id);
            FileInputStream inStream = new FileInputStream(file.getFileDescriptor());
            FileChannel inChannel = inStream.getChannel();
            FileChannel outChannel = outStream.getChannel();
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (IOException e) {
            mDm.remove(id);
            displayErrorResult(updateIntent, R.string.unable_to_download_file);
            return;
        }
        // Check the signature of the downloaded file
        try {
            android.os.RecoverySystem.verifyPackage(destFile, null, null);
        } catch (Exception e) {
            if (destFile.exists()) {
                destFile.delete();
            }
            mDm.remove(id);
            displayErrorResult(updateIntent, R.string.verification_failed);
            return;
        }
        // We passed. Bring the main app to the foreground and trigger download completed
        updateIntent.putExtra(UpdatesSettings.EXTRA_FINISHED_DOWNLOAD_ID, id);
        updateIntent.putExtra(UpdatesSettings.EXTRA_FINISHED_DOWNLOAD_PATH, destPath);
        mDm.remove(id);
        displaySuccessResult(updateIntent, destFile);
    } else if (status == DownloadManager.STATUS_FAILED) {
        // The download failed, reset
        mDm.remove(id);
        displayErrorResult(updateIntent, R.string.unable_to_download_file);
    }
}
#method_after
@Override
protected void onHandleIntent(Intent intent) {
    if (!intent.hasExtra(Constants.DOWNLOAD_ID)) {
        return;
    }
    long id = intent.getLongExtra(Constants.DOWNLOAD_ID, -1);
    Intent updateIntent = new Intent(this, UpdatesActivity.class);
    updateIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    int status = fetchDownloadStatus(id);
    if (status == DownloadManager.STATUS_SUCCESSFUL) {
        // Get the full path name of the downloaded file
        // Strip off the .partial at the end to get the completed file
        String partialFileFullPath = mPrefs.getString(Constants.DOWNLOAD_NAME, null);
        if (partialFileFullPath == null) {
            displayErrorResult(updateIntent, R.string.unable_to_download_file);
        }
        String destName = new File(partialFileFullPath).getName().replace(".partial", "");
        String destPath = Utils.makeUpdateFolder(getApplicationContext()).getPath() + "/" + destName;
        File destFile = new File(destPath);
        mPrefs.edit().putString(Constants.DOWNLOAD_NAME, "").commit();
        try (FileOutputStream outStream = new FileOutputStream(destFile);
            ParcelFileDescriptor file = mDm.openDownloadedFile(id);
            FileInputStream inStream = new FileInputStream(file.getFileDescriptor());
            FileChannel inChannel = inStream.getChannel();
            FileChannel outChannel = outStream.getChannel()) {
            inChannel.transferTo(0, inChannel.size(), outChannel);
        } catch (IOException e) {
            displayErrorResult(updateIntent, R.string.unable_to_download_file);
            return;
        } finally {
            mDm.remove(id);
        }
        // Check the signature of the downloaded file
        try {
            android.os.RecoverySystem.verifyPackage(destFile, null, null);
        } catch (Exception e) {
            if (destFile.exists()) {
                destFile.delete();
            }
            displayErrorResult(updateIntent, R.string.verification_failed);
            return;
        }
        // We passed. Bring the main app to the foreground and trigger download completed
        updateIntent.putExtra(UpdatesSettings.EXTRA_FINISHED_DOWNLOAD_ID, id);
        updateIntent.putExtra(UpdatesSettings.EXTRA_FINISHED_DOWNLOAD_PATH, destPath);
        displaySuccessResult(updateIntent, destFile);
    } else if (status == DownloadManager.STATUS_FAILED) {
        // The download failed, reset
        mDm.remove(id);
        displayErrorResult(updateIntent, R.string.unable_to_download_file);
    }
}
#end_block

